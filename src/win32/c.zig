pub const va_list = [*c]u8;
pub extern fn __va_start(arg0: [*c]([*c]u8), ...) void;
pub const ptrdiff_t = c_longlong;
pub const __vcrt_bool = bool;
pub const wchar_t = c_ushort;
pub extern fn __security_init_cookie() void;
pub extern fn __security_check_cookie(_StackCookie: usize) void;
pub extern fn __report_gsfailure(_StackCookie: usize) noreturn;
pub extern var __security_cookie: usize;
pub const ExceptionContinueExecution = enum__EXCEPTION_DISPOSITION.ExceptionContinueExecution;
pub const ExceptionContinueSearch = enum__EXCEPTION_DISPOSITION.ExceptionContinueSearch;
pub const ExceptionNestedException = enum__EXCEPTION_DISPOSITION.ExceptionNestedException;
pub const ExceptionCollidedUnwind = enum__EXCEPTION_DISPOSITION.ExceptionCollidedUnwind;
pub const enum__EXCEPTION_DISPOSITION = extern enum {
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind,
};
pub const EXCEPTION_DISPOSITION = enum__EXCEPTION_DISPOSITION;
pub const DWORD = c_ulong;
pub const PVOID = ?*c_void;
pub const ULONG_PTR = c_ulonglong;
pub const struct__EXCEPTION_RECORD = extern struct {
    ExceptionCode: DWORD,
    ExceptionFlags: DWORD,
    ExceptionRecord: [*c]struct__EXCEPTION_RECORD,
    ExceptionAddress: PVOID,
    NumberParameters: DWORD,
    ExceptionInformation: [15]ULONG_PTR,
};
pub const DWORD64 = c_ulonglong;
pub const WORD = c_ushort;
pub const BYTE = u8;
pub const ULONGLONG = c_ulonglong;
pub const LONGLONG = c_longlong;
pub const struct__M128A = extern struct {
    Low: ULONGLONG,
    High: LONGLONG,
};
pub const M128A = struct__M128A;
pub const struct__XSAVE_FORMAT = extern struct {
    ControlWord: WORD,
    StatusWord: WORD,
    TagWord: BYTE,
    Reserved1: BYTE,
    ErrorOpcode: WORD,
    ErrorOffset: DWORD,
    ErrorSelector: WORD,
    Reserved2: WORD,
    DataOffset: DWORD,
    DataSelector: WORD,
    Reserved3: WORD,
    MxCsr: DWORD,
    MxCsr_Mask: DWORD,
    FloatRegisters: [8]M128A,
    XmmRegisters: [16]M128A,
    Reserved4: [96]BYTE,
};
pub const XSAVE_FORMAT = struct__XSAVE_FORMAT;
pub const XMM_SAVE_AREA32 = XSAVE_FORMAT;
pub const struct__CONTEXT = extern struct {
    P1Home: DWORD64,
    P2Home: DWORD64,
    P3Home: DWORD64,
    P4Home: DWORD64,
    P5Home: DWORD64,
    P6Home: DWORD64,
    ContextFlags: DWORD,
    MxCsr: DWORD,
    SegCs: WORD,
    SegDs: WORD,
    SegEs: WORD,
    SegFs: WORD,
    SegGs: WORD,
    SegSs: WORD,
    EFlags: DWORD,
    Dr0: DWORD64,
    Dr1: DWORD64,
    Dr2: DWORD64,
    Dr3: DWORD64,
    Dr6: DWORD64,
    Dr7: DWORD64,
    Rax: DWORD64,
    Rcx: DWORD64,
    Rdx: DWORD64,
    Rbx: DWORD64,
    Rsp: DWORD64,
    Rbp: DWORD64,
    Rsi: DWORD64,
    Rdi: DWORD64,
    R8: DWORD64,
    R9: DWORD64,
    R10: DWORD64,
    R11: DWORD64,
    R12: DWORD64,
    R13: DWORD64,
    R14: DWORD64,
    R15: DWORD64,
    Rip: DWORD64,
    @"": extern union {
        FltSave: XMM_SAVE_AREA32,
        @"": extern struct {
            Header: [2]M128A,
            Legacy: [8]M128A,
            Xmm0: M128A,
            Xmm1: M128A,
            Xmm2: M128A,
            Xmm3: M128A,
            Xmm4: M128A,
            Xmm5: M128A,
            Xmm6: M128A,
            Xmm7: M128A,
            Xmm8: M128A,
            Xmm9: M128A,
            Xmm10: M128A,
            Xmm11: M128A,
            Xmm12: M128A,
            Xmm13: M128A,
            Xmm14: M128A,
            Xmm15: M128A,
        },
    },
    VectorRegister: [26]M128A,
    VectorControl: DWORD64,
    DebugControl: DWORD64,
    LastBranchToRip: DWORD64,
    LastBranchFromRip: DWORD64,
    LastExceptionToRip: DWORD64,
    LastExceptionFromRip: DWORD64,
};
pub const struct__IMAGE_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: DWORD,
    EndAddress: DWORD,
    @"": extern union {
        UnwindInfoAddress: DWORD,
        UnwindData: DWORD,
    },
};
pub const PRUNTIME_FUNCTION = [*c]struct__IMAGE_RUNTIME_FUNCTION_ENTRY;
pub const PCONTEXT = [*c]struct__CONTEXT;
pub const EXCEPTION_ROUTINE = fn ([*c]struct__EXCEPTION_RECORD, PVOID, [*c]struct__CONTEXT, PVOID) callconv(.C) EXCEPTION_DISPOSITION;
pub const PEXCEPTION_ROUTINE = [*c]EXCEPTION_ROUTINE;
pub const struct__UNWIND_HISTORY_TABLE_ENTRY = extern struct {
    ImageBase: DWORD64,
    FunctionEntry: PRUNTIME_FUNCTION,
};
pub const UNWIND_HISTORY_TABLE_ENTRY = struct__UNWIND_HISTORY_TABLE_ENTRY;
pub const struct__UNWIND_HISTORY_TABLE = extern struct {
    Count: DWORD,
    LocalHint: BYTE,
    GlobalHint: BYTE,
    Search: BYTE,
    Once: BYTE,
    LowAddress: DWORD64,
    HighAddress: DWORD64,
    Entry: [12]UNWIND_HISTORY_TABLE_ENTRY,
};
pub const PUNWIND_HISTORY_TABLE = [*c]struct__UNWIND_HISTORY_TABLE;
pub const struct__DISPATCHER_CONTEXT = extern struct {
    ControlPc: DWORD64,
    ImageBase: DWORD64,
    FunctionEntry: PRUNTIME_FUNCTION,
    EstablisherFrame: DWORD64,
    TargetIp: DWORD64,
    ContextRecord: PCONTEXT,
    LanguageHandler: PEXCEPTION_ROUTINE,
    HandlerData: PVOID,
    HistoryTable: PUNWIND_HISTORY_TABLE,
    ScopeIndex: DWORD,
    Fill0: DWORD,
};
pub extern fn __C_specific_handler(ExceptionRecord: [*c]struct__EXCEPTION_RECORD, EstablisherFrame: ?*c_void, ContextRecord: [*c]struct__CONTEXT, DispatcherContext: [*c]struct__DISPATCHER_CONTEXT) EXCEPTION_DISPOSITION;
pub extern fn _exception_code() c_ulong;
pub extern fn _exception_info() ?*c_void;
pub extern fn _abnormal_termination() c_int;
pub const __builtin_va_list = [*c]u8;
pub const __gnuc_va_list = __builtin_va_list;
pub const ULONG = c_ulong;
pub const PULONG = [*c]ULONG;
pub const USHORT = c_ushort;
pub const PUSHORT = [*c]USHORT;
pub const UCHAR = u8;
pub const PUCHAR = [*c]UCHAR;
pub const PSZ = [*c]u8;
pub const BOOL = c_int;
pub const FLOAT = f32;
pub const PFLOAT = [*c]FLOAT;
pub const PBOOL = [*c]BOOL;
pub const LPBOOL = [*c]BOOL;
pub const PBYTE = [*c]BYTE;
pub const LPBYTE = [*c]BYTE;
pub const PINT = [*c]c_int;
pub const LPINT = [*c]c_int;
pub const PWORD = [*c]WORD;
pub const LPWORD = [*c]WORD;
pub const LPLONG = [*c]c_long;
pub const PDWORD = [*c]DWORD;
pub const LPDWORD = [*c]DWORD;
pub const LPVOID = ?*c_void;
pub const LPCVOID = ?*const c_void;
pub const INT = c_int;
pub const UINT = c_uint;
pub const PUINT = [*c]c_uint;
pub const __crt_bool = bool;
pub extern fn _invalid_parameter(arg0: [*c]const wchar_t, arg1: [*c]const wchar_t, arg2: [*c]const wchar_t, arg3: c_uint, arg4: usize) void;
pub extern fn _invalid_parameter_noinfo() void;
pub extern fn _invalid_parameter_noinfo_noreturn() noreturn;
pub extern fn _invoke_watson(_Expression: [*c]const wchar_t, _FunctionName: [*c]const wchar_t, _FileName: [*c]const wchar_t, _LineNo: c_uint, _Reserved: usize) noreturn;
pub const errno_t = c_int;
pub const wint_t = c_ushort;
pub const wctype_t = c_ushort;
pub const __time32_t = c_long;
pub const __time64_t = c_longlong;
pub const struct___crt_locale_data_public = extern struct {
    _locale_pctype: [*c]const c_ushort,
    _locale_mb_cur_max: c_int,
    _locale_lc_codepage: c_uint,
};
pub const __crt_locale_data_public = struct___crt_locale_data_public;
pub const struct___crt_locale_data = @OpaqueType();
pub const struct___crt_multibyte_data = @OpaqueType();
pub const struct___crt_locale_pointers = extern struct {
    locinfo: ?*struct___crt_locale_data,
    mbcinfo: ?*struct___crt_multibyte_data,
};
pub const __crt_locale_pointers = struct___crt_locale_pointers;
pub const _locale_t = [*c]__crt_locale_pointers;
pub const struct__Mbstatet = extern struct {
    _Wchar: c_ulong,
    _Byte: c_ushort,
    _State: c_ushort,
};
pub const _Mbstatet = struct__Mbstatet;
pub const mbstate_t = _Mbstatet;
pub const time_t = __time64_t;
pub const rsize_t = usize;
pub extern fn __pctype_func() [*c]const c_ushort;
pub extern fn __pwctype_func() [*c]const wctype_t;
pub extern fn iswalnum(_C: wint_t) c_int;
pub extern fn iswalpha(_C: wint_t) c_int;
pub extern fn iswascii(_C: wint_t) c_int;
pub extern fn iswblank(_C: wint_t) c_int;
pub extern fn iswcntrl(_C: wint_t) c_int;
pub extern fn iswdigit(_C: wint_t) c_int;
pub extern fn iswgraph(_C: wint_t) c_int;
pub extern fn iswlower(_C: wint_t) c_int;
pub extern fn iswprint(_C: wint_t) c_int;
pub extern fn iswpunct(_C: wint_t) c_int;
pub extern fn iswspace(_C: wint_t) c_int;
pub extern fn iswupper(_C: wint_t) c_int;
pub extern fn iswxdigit(_C: wint_t) c_int;
pub extern fn __iswcsymf(_C: wint_t) c_int;
pub extern fn __iswcsym(_C: wint_t) c_int;
pub extern fn _iswalnum_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn _iswalpha_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn _iswblank_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn _iswcntrl_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn _iswdigit_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn _iswgraph_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn _iswlower_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn _iswprint_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn _iswpunct_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn _iswspace_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn _iswupper_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn _iswxdigit_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn _iswcsymf_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn _iswcsym_l(_C: wint_t, _Locale: _locale_t) c_int;
pub extern fn towupper(_C: wint_t) wint_t;
pub extern fn towlower(_C: wint_t) wint_t;
pub extern fn iswctype(_C: wint_t, _Type: wctype_t) c_int;
pub extern fn _towupper_l(_C: wint_t, _Locale: _locale_t) wint_t;
pub extern fn _towlower_l(_C: wint_t, _Locale: _locale_t) wint_t;
pub extern fn _iswctype_l(_C: wint_t, _Type: wctype_t, _Locale: _locale_t) c_int;
pub extern fn isleadbyte(_C: c_int) c_int;
pub extern fn _isleadbyte_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn is_wctype(_C: wint_t, _Type: wctype_t) c_int;
pub extern fn _isctype(_C: c_int, _Type: c_int) c_int;
pub extern fn _isctype_l(_C: c_int, _Type: c_int, _Locale: _locale_t) c_int;
pub extern fn isalpha(_C: c_int) c_int;
pub extern fn _isalpha_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn isupper(_C: c_int) c_int;
pub extern fn _isupper_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn islower(_C: c_int) c_int;
pub extern fn _islower_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn isdigit(_C: c_int) c_int;
pub extern fn _isdigit_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn isxdigit(_C: c_int) c_int;
pub extern fn _isxdigit_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn isspace(_C: c_int) c_int;
pub extern fn _isspace_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn ispunct(_C: c_int) c_int;
pub extern fn _ispunct_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn isblank(_C: c_int) c_int;
pub extern fn _isblank_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn isalnum(_C: c_int) c_int;
pub extern fn _isalnum_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn isprint(_C: c_int) c_int;
pub extern fn _isprint_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn isgraph(_C: c_int) c_int;
pub extern fn _isgraph_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn iscntrl(_C: c_int) c_int;
pub extern fn _iscntrl_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn toupper(_C: c_int) c_int;
pub extern fn tolower(_C: c_int) c_int;
pub extern fn _tolower(_C: c_int) c_int;
pub extern fn _tolower_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn _toupper(_C: c_int) c_int;
pub extern fn _toupper_l(_C: c_int, _Locale: _locale_t) c_int;
pub extern fn __isascii(_C: c_int) c_int;
pub extern fn __toascii(_C: c_int) c_int;
pub extern fn __iscsymf(_C: c_int) c_int;
pub extern fn __iscsym(_C: c_int) c_int;
pub fn __acrt_locale_get_ctype_array_value(_Locale_pctype_array: [*c]const c_ushort, _Char_value: c_int, _Mask: c_int) c_int {
    if ((_Char_value >= (-1)) and (_Char_value <= 255)) {
        return @as(c_int, _Locale_pctype_array[_Char_value]) & _Mask;
    }
    return 0;
}
pub extern fn ___mb_cur_max_func() c_int;
pub extern fn ___mb_cur_max_l_func(_Locale: _locale_t) c_int;
pub extern fn _chvalidator(_Ch: c_int, _Mask: c_int) c_int;
pub fn __ascii_tolower(_C: c_int) c_int {
    if ((_C >= 'A') and (_C <= 'Z')) {
        return _C - ('A' - 'a');
    }
    return _C;
}
pub fn __ascii_toupper(_C: c_int) c_int {
    if ((_C >= 'a') and (_C <= 'z')) {
        return _C - ('a' - 'A');
    }
    return _C;
}
pub fn __ascii_iswalpha(_C: c_int) c_int {
    return ((_C >= 'A') and (_C <= 'Z')) or ((_C >= 'a') and (_C <= 'z'));
}
pub fn __ascii_iswdigit(_C: c_int) c_int {
    return (_C >= '0') and (_C <= '9');
}
pub fn __ascii_towlower(_C: c_int) c_int {
    return __ascii_tolower(_C);
}
pub fn __ascii_towupper(_C: c_int) c_int {
    return __ascii_toupper(_C);
}
pub fn __acrt_get_locale_data_prefix(_LocalePointers: ?*const volatile c_void) [*c]__crt_locale_data_public {
    const _TypedLocalePointers: _locale_t = @ptrCast(_locale_t, @alignCast(@alignOf(__crt_locale_pointers), _LocalePointers));
    return @ptrCast([*c]__crt_locale_data_public, @alignCast(@alignOf(__crt_locale_data_public), _TypedLocalePointers.?.locinfo));
}
pub extern fn _chvalidator_l(arg0: _locale_t, _Ch: c_int, _Mask: c_int) c_int;
pub fn _chvalidchk_l(_C: c_int, _Mask: c_int, _Locale: _locale_t) c_int {
    return _chvalidator_l(_Locale, _C, _Mask);
}
pub fn _ischartype_l(_C: c_int, _Mask: c_int, _Locale: _locale_t) c_int {
    if (_locale_t) {
        if ((_C >= (-1)) and (_C <= 255)) {
            return @as(c_int, __acrt_get_locale_data_prefix(@ptrCast(?*const volatile c_void, _Locale)).?._locale_pctype[_C]) & _Mask;
        }
        if (__acrt_get_locale_data_prefix(@ptrCast(?*const volatile c_void, _Locale)).?._locale_mb_cur_max > 1) {
            return _isctype_l(_C, _Mask, _Locale);
        }
        return 0;
    }
    return _chvalidchk_l(_C, _Mask, null);
}
pub const POINTER_64_INT = c_ulonglong;
pub const INT8 = i8;
pub const PINT8 = [*c]i8;
pub const INT16 = c_short;
pub const PINT16 = [*c]c_short;
pub const INT32 = c_int;
pub const PINT32 = [*c]c_int;
pub const INT64 = c_longlong;
pub const PINT64 = [*c]c_longlong;
pub const UINT8 = u8;
pub const PUINT8 = [*c]u8;
pub const UINT16 = c_ushort;
pub const PUINT16 = [*c]c_ushort;
pub const UINT32 = c_uint;
pub const PUINT32 = [*c]c_uint;
pub const UINT64 = c_ulonglong;
pub const PUINT64 = [*c]c_ulonglong;
pub const LONG32 = c_int;
pub const PLONG32 = [*c]c_int;
pub const ULONG32 = c_uint;
pub const PULONG32 = [*c]c_uint;
pub const DWORD32 = c_uint;
pub const PDWORD32 = [*c]c_uint;
pub const INT_PTR = c_longlong;
pub const PINT_PTR = [*c]c_longlong;
pub const UINT_PTR = c_ulonglong;
pub const PUINT_PTR = [*c]c_ulonglong;
pub const LONG_PTR = c_longlong;
pub const PLONG_PTR = [*c]c_longlong;
pub const PULONG_PTR = [*c]c_ulonglong;
pub const SHANDLE_PTR = c_longlong;
pub const HANDLE_PTR = c_ulonglong;
pub const UHALF_PTR = c_uint;
pub const PUHALF_PTR = [*c]c_uint;
pub const HALF_PTR = c_int;
pub const PHALF_PTR = [*c]c_int;
pub fn HandleToULong(h: ?*const c_void) c_ulong {
    return @as(c_ulong, ULONG_PTR(@ptrToInt(h)));
}
pub fn HandleToLong(h: ?*const c_void) c_long {
    return @as(c_long, LONG_PTR(h));
}
pub fn ULongToHandle(h: c_ulong) ?*c_void {
    return @intToPtr(?*c_void, UINT_PTR(h));
}
pub fn LongToHandle(h: c_long) ?*c_void {
    return (?*c_void)(INT_PTR(h));
}
pub fn PtrToUlong(p: ?*const c_void) c_ulong {
    return @as(c_ulong, ULONG_PTR(@ptrToInt(p)));
}
pub fn PtrToUint(p: ?*const c_void) c_uint {
    return @as(c_uint, UINT_PTR(@ptrToInt(p)));
}
pub fn PtrToUshort(p: ?*const c_void) c_ushort {
    return @as(c_ushort, @as(c_ulong, ULONG_PTR(@ptrToInt(p))));
}
pub fn PtrToLong(p: ?*const c_void) c_long {
    return @as(c_long, LONG_PTR(p));
}
pub fn PtrToInt(p: ?*const c_void) c_int {
    return @as(c_int, INT_PTR(p));
}
pub fn PtrToShort(p: ?*const c_void) c_short {
    return @as(c_short, @as(c_long, LONG_PTR(p)));
}
pub fn IntToPtr(i: c_int) ?*c_void {
    return (?*c_void)(INT_PTR(i));
}
pub fn UIntToPtr(ui: c_uint) ?*c_void {
    return @intToPtr(?*c_void, UINT_PTR(ui));
}
pub fn LongToPtr(l: c_long) ?*c_void {
    return (?*c_void)(LONG_PTR(l));
}
pub fn ULongToPtr(ul: c_ulong) ?*c_void {
    return @intToPtr(?*c_void, ULONG_PTR(ul));
}
pub fn Ptr32ToPtr(p: ?*const c_void) ?*c_void {
    return @intToPtr(?*c_void, ULONG_PTR(@as(c_ulong, @ptrToInt(p))));
}
pub fn Handle32ToHandle(h: ?*const c_void) ?*c_void {
    return (?*c_void)(LONG_PTR(@as(c_long, h)));
}
pub fn PtrToPtr32(p: ?*const c_void) ?*c_void {
    return @intToPtr(?*c_void, @as(c_ulong, ULONG_PTR(@ptrToInt(p))));
}
pub const SIZE_T = ULONG_PTR;
pub const PSIZE_T = [*c]ULONG_PTR;
pub const SSIZE_T = LONG_PTR;
pub const PSSIZE_T = [*c]LONG_PTR;
pub const DWORD_PTR = ULONG_PTR;
pub const PDWORD_PTR = [*c]ULONG_PTR;
pub const LONG64 = c_longlong;
pub const PLONG64 = [*c]c_longlong;
pub const ULONG64 = c_ulonglong;
pub const PULONG64 = [*c]c_ulonglong;
pub const PDWORD64 = [*c]c_ulonglong;
pub const KAFFINITY = ULONG_PTR;
pub const PKAFFINITY = [*c]KAFFINITY;
pub const PVOID64 = ?*c_void;
pub const CHAR = u8;
pub const SHORT = c_short;
pub const LONG = c_long;
pub const WCHAR = wchar_t;
pub const PWCHAR = [*c]WCHAR;
pub const LPWCH = [*c]WCHAR;
pub const PWCH = [*c]WCHAR;
pub const LPCWCH = [*c]const WCHAR;
pub const PCWCH = [*c]const WCHAR;
pub const NWPSTR = [*c]WCHAR;
pub const LPWSTR = [*c]WCHAR;
pub const PWSTR = [*c]WCHAR;
pub const PZPWSTR = [*c]PWSTR;
pub const PCZPWSTR = [*c]const PWSTR;
pub const LPUWSTR = [*c]WCHAR;
pub const PUWSTR = [*c]WCHAR;
pub const LPCWSTR = [*c]const WCHAR;
pub const PCWSTR = [*c]const WCHAR;
pub const PZPCWSTR = [*c]PCWSTR;
pub const PCZPCWSTR = [*c]const PCWSTR;
pub const LPCUWSTR = [*c]const WCHAR;
pub const PCUWSTR = [*c]const WCHAR;
pub const PZZWSTR = [*c]WCHAR;
pub const PCZZWSTR = [*c]const WCHAR;
pub const PUZZWSTR = [*c]WCHAR;
pub const PCUZZWSTR = [*c]const WCHAR;
pub const PNZWCH = [*c]WCHAR;
pub const PCNZWCH = [*c]const WCHAR;
pub const PUNZWCH = [*c]WCHAR;
pub const PCUNZWCH = [*c]const WCHAR;
pub const LPCWCHAR = [*c]const WCHAR;
pub const PCWCHAR = [*c]const WCHAR;
pub const LPCUWCHAR = [*c]const WCHAR;
pub const PCUWCHAR = [*c]const WCHAR;
pub const UCSCHAR = c_ulong;
pub const PUCSCHAR = [*c]UCSCHAR;
pub const PCUCSCHAR = [*c]const UCSCHAR;
pub const PUCSSTR = [*c]UCSCHAR;
pub const PUUCSSTR = [*c]UCSCHAR;
pub const PCUCSSTR = [*c]const UCSCHAR;
pub const PCUUCSSTR = [*c]const UCSCHAR;
pub const PUUCSCHAR = [*c]UCSCHAR;
pub const PCUUCSCHAR = [*c]const UCSCHAR;
pub const PCHAR = [*c]CHAR;
pub const LPCH = [*c]CHAR;
pub const PCH = [*c]CHAR;
pub const LPCCH = [*c]const CHAR;
pub const PCCH = [*c]const CHAR;
pub const NPSTR = [*c]CHAR;
pub const LPSTR = [*c]CHAR;
pub const PSTR = [*c]CHAR;
pub const PZPSTR = [*c]PSTR;
pub const PCZPSTR = [*c]const PSTR;
pub const LPCSTR = [*c]const CHAR;
pub const PCSTR = [*c]const CHAR;
pub const PZPCSTR = [*c]PCSTR;
pub const PCZPCSTR = [*c]const PCSTR;
pub const PZZSTR = [*c]CHAR;
pub const PCZZSTR = [*c]const CHAR;
pub const PNZCH = [*c]CHAR;
pub const PCNZCH = [*c]const CHAR;
pub const TCHAR = u8;
pub const PTCHAR = [*c]u8;
pub const TBYTE = u8;
pub const PTBYTE = [*c]u8;
pub const LPTCH = LPCH;
pub const PTCH = LPCH;
pub const LPCTCH = LPCCH;
pub const PCTCH = LPCCH;
pub const PTSTR = LPSTR;
pub const LPTSTR = LPSTR;
pub const PUTSTR = LPSTR;
pub const LPUTSTR = LPSTR;
pub const PCTSTR = LPCSTR;
pub const LPCTSTR = LPCSTR;
pub const PCUTSTR = LPCSTR;
pub const LPCUTSTR = LPCSTR;
pub const PZZTSTR = PZZSTR;
pub const PUZZTSTR = PZZSTR;
pub const PCZZTSTR = PCZZSTR;
pub const PCUZZTSTR = PCZZSTR;
pub const PZPTSTR = PZPSTR;
pub const PNZTCH = PNZCH;
pub const PUNZTCH = PNZCH;
pub const PCNZTCH = PCNZCH;
pub const PCUNZTCH = PCNZCH;
pub const PSHORT = [*c]SHORT;
pub const PLONG = [*c]LONG;
pub const struct__PROCESSOR_NUMBER = extern struct {
    Group: WORD,
    Number: BYTE,
    Reserved: BYTE,
};
pub const PROCESSOR_NUMBER = struct__PROCESSOR_NUMBER;
pub const PPROCESSOR_NUMBER = [*c]struct__PROCESSOR_NUMBER;
pub const struct__GROUP_AFFINITY = extern struct {
    Mask: KAFFINITY,
    Group: WORD,
    Reserved: [3]WORD,
};
pub const GROUP_AFFINITY = struct__GROUP_AFFINITY;
pub const PGROUP_AFFINITY = [*c]struct__GROUP_AFFINITY;
pub const HANDLE = ?*c_void;
pub const PHANDLE = [*c]HANDLE;
pub const FCHAR = BYTE;
pub const FSHORT = WORD;
pub const FLONG = DWORD;
pub const HRESULT = c_long;
pub const CCHAR = u8;
pub const LCID = DWORD;
pub const PLCID = PDWORD;
pub const LANGID = WORD;
pub const UNSPECIFIED_COMPARTMENT_ID = 0;
pub const DEFAULT_COMPARTMENT_ID = 1;
pub const COMPARTMENT_ID = extern enum {
    UNSPECIFIED_COMPARTMENT_ID = 0,
    DEFAULT_COMPARTMENT_ID = 1,
};
pub const PCOMPARTMENT_ID = [*c]extern enum {
    UNSPECIFIED_COMPARTMENT_ID = 0,
    DEFAULT_COMPARTMENT_ID = 1,
};
pub const struct__FLOAT128 = extern struct {
    LowPart: c_longlong,
    HighPart: c_longlong,
};
pub const FLOAT128 = struct__FLOAT128;
pub const PFLOAT128 = [*c]FLOAT128;
pub const PLONGLONG = [*c]LONGLONG;
pub const PULONGLONG = [*c]ULONGLONG;
pub const USN = LONGLONG;
pub const union__LARGE_INTEGER = extern union {
    @"": extern struct {
        LowPart: DWORD,
        HighPart: LONG,
    },
    u: extern struct {
        LowPart: DWORD,
        HighPart: LONG,
    },
    QuadPart: LONGLONG,
};
pub const LARGE_INTEGER = union__LARGE_INTEGER;
pub const PLARGE_INTEGER = [*c]LARGE_INTEGER;
pub const union__ULARGE_INTEGER = extern union {
    @"": extern struct {
        LowPart: DWORD,
        HighPart: DWORD,
    },
    u: extern struct {
        LowPart: DWORD,
        HighPart: DWORD,
    },
    QuadPart: ULONGLONG,
};
pub const ULARGE_INTEGER = union__ULARGE_INTEGER;
pub const PULARGE_INTEGER = [*c]ULARGE_INTEGER;
pub const RTL_REFERENCE_COUNT = LONG_PTR;
pub const PRTL_REFERENCE_COUNT = [*c]LONG_PTR;
pub const RTL_REFERENCE_COUNT32 = LONG;
pub const PRTL_REFERENCE_COUNT32 = [*c]LONG;
pub const struct__LUID = extern struct {
    LowPart: DWORD,
    HighPart: LONG,
};
pub const LUID = struct__LUID;
pub const PLUID = [*c]struct__LUID;
pub const DWORDLONG = ULONGLONG;
pub const PDWORDLONG = [*c]DWORDLONG;
pub extern fn _rotl8(Value: u8, Shift: u8) u8;
pub extern fn _rotl16(Value: c_ushort, Shift: u8) c_ushort;
pub extern fn _rotr8(Value: u8, Shift: u8) u8;
pub extern fn _rotr16(Value: c_ushort, Shift: u8) c_ushort;
pub extern fn _rotl(Value: c_uint, Shift: c_int) c_uint;
pub extern fn _rotl64(Value: c_ulonglong, Shift: c_int) c_ulonglong;
pub extern fn _rotr(Value: c_uint, Shift: c_int) c_uint;
pub extern fn _rotr64(Value: c_ulonglong, Shift: c_int) c_ulonglong;
pub const BOOLEAN = BYTE;
pub const PBOOLEAN = [*c]BOOLEAN;
pub const struct__LIST_ENTRY = extern struct {
    Flink: [*c]struct__LIST_ENTRY,
    Blink: [*c]struct__LIST_ENTRY,
};
pub const LIST_ENTRY = struct__LIST_ENTRY;
pub const PLIST_ENTRY = [*c]struct__LIST_ENTRY;
pub const PRLIST_ENTRY = [*c]struct__LIST_ENTRY;
pub const struct__SINGLE_LIST_ENTRY = extern struct {
    Next: [*c]struct__SINGLE_LIST_ENTRY,
};
pub const SINGLE_LIST_ENTRY = struct__SINGLE_LIST_ENTRY;
pub const PSINGLE_LIST_ENTRY = [*c]struct__SINGLE_LIST_ENTRY;
pub const struct_LIST_ENTRY32 = extern struct {
    Flink: DWORD,
    Blink: DWORD,
};
pub const LIST_ENTRY32 = struct_LIST_ENTRY32;
pub const PLIST_ENTRY32 = [*c]LIST_ENTRY32;
pub const struct_LIST_ENTRY64 = extern struct {
    Flink: ULONGLONG,
    Blink: ULONGLONG,
};
pub const LIST_ENTRY64 = struct_LIST_ENTRY64;
pub const PLIST_ENTRY64 = [*c]LIST_ENTRY64;
pub const struct__GUID = extern struct {
    Data1: c_ulong,
    Data2: c_ushort,
    Data3: c_ushort,
    Data4: [8]u8,
};
pub const GUID = struct__GUID;
pub const LPGUID = [*c]GUID;
pub const LPCGUID = [*c]const GUID;
pub const IID = GUID;
pub const LPIID = [*c]IID;
pub const CLSID = GUID;
pub const LPCLSID = [*c]CLSID;
pub const FMTID = GUID;
pub const LPFMTID = [*c]FMTID;
pub extern fn _errno() [*c]c_int;
pub extern fn _set_errno(_Value: c_int) errno_t;
pub extern fn _get_errno(_Value: [*c]c_int) errno_t;
pub extern fn __doserrno() [*c]c_ulong;
pub extern fn _set_doserrno(_Value: c_ulong) errno_t;
pub extern fn _get_doserrno(_Value: [*c]c_ulong) errno_t;
pub extern fn memchr(_Buf: ?*const c_void, _Val: c_int, _MaxCount: c_ulonglong) ?*c_void;
pub extern fn memcmp(_Buf1: ?*const c_void, _Buf2: ?*const c_void, _Size: c_ulonglong) c_int;
pub extern fn memcpy(_Dst: ?*c_void, _Src: ?*const c_void, _Size: c_ulonglong) ?*c_void;
pub extern fn memmove(_Dst: ?*c_void, _Src: ?*const c_void, _Size: c_ulonglong) ?*c_void;
pub extern fn memset(_Dst: ?*c_void, _Val: c_int, _Size: c_ulonglong) ?*c_void;
pub extern fn strchr(_Str: [*c]const u8, _Val: c_int) [*c]u8;
pub extern fn strrchr(_Str: [*c]const u8, _Ch: c_int) [*c]u8;
pub extern fn strstr(_Str: [*c]const u8, _SubStr: [*c]const u8) [*c]u8;
pub extern fn wcschr(_Str: [*c]const c_ushort, _Ch: c_ushort) [*c]c_ushort;
pub extern fn wcsrchr(_Str: [*c]const wchar_t, _Ch: wchar_t) [*c]wchar_t;
pub extern fn wcsstr(_Str: [*c]const wchar_t, _SubStr: [*c]const wchar_t) [*c]wchar_t;
pub fn memcpy_s(_Destination: ?*c_void, _DestinationSize: rsize_t, _Source: ?*const c_void, _SourceSize: rsize_t) errno_t {
    if (_SourceSize == @as(c_ulonglong, 0)) {
        return 0;
    }
    {
        var _Expr_val: c_int = !!(_Destination != (?*c_void)(0));
        if (!(_Expr_val != 0)) {
            _errno().?.* = 22;
            _invalid_parameter_noinfo();
            return 22;
        }
    }
    {}
    if ((_Source == @ptrCast(?*const c_void, (?*c_void)(0))) or (_DestinationSize < _SourceSize)) {
        _ = memset(_Destination, 0, _DestinationSize);
        {
            var _Expr_val: c_int = !!(_Source != @ptrCast(?*const c_void, (?*c_void)(0)));
            if (!(_Expr_val != 0)) {
                _errno().?.* = 22;
                _invalid_parameter_noinfo();
                return 22;
            }
        }
        {}
        {
            var _Expr_val: c_int = !!(_DestinationSize >= _SourceSize);
            if (!(_Expr_val != 0)) {
                _errno().?.* = 34;
                _invalid_parameter_noinfo();
                return 34;
            }
        }
        {}
        return 22;
    }
    _ = memcpy(_Destination, _Source, _SourceSize);
    return 0;
}
pub fn memmove_s(_Destination: ?*c_void, _DestinationSize: rsize_t, _Source: ?*const c_void, _SourceSize: rsize_t) errno_t {
    if (_SourceSize == @as(c_ulonglong, 0)) {
        return 0;
    }
    {
        var _Expr_val: c_int = !!(_Destination != (?*c_void)(0));
        if (!(_Expr_val != 0)) {
            _errno().?.* = 22;
            _invalid_parameter_noinfo();
            return 22;
        }
    }
    {}
    {
        var _Expr_val: c_int = !!(_Source != @ptrCast(?*const c_void, (?*c_void)(0)));
        if (!(_Expr_val != 0)) {
            _errno().?.* = 22;
            _invalid_parameter_noinfo();
            return 22;
        }
    }
    {}
    {
        var _Expr_val: c_int = !!(_DestinationSize >= _SourceSize);
        if (!(_Expr_val != 0)) {
            _errno().?.* = 34;
            _invalid_parameter_noinfo();
            return 34;
        }
    }
    {}
    _ = memmove(_Destination, _Source, _SourceSize);
    return 0;
}
pub extern fn _memicmp(_Buf1: ?*const c_void, _Buf2: ?*const c_void, _Size: usize) c_int;
pub extern fn _memicmp_l(_Buf1: ?*const c_void, _Buf2: ?*const c_void, _Size: usize, _Locale: _locale_t) c_int;
pub extern fn memccpy(_Dst: ?*c_void, _Src: ?*const c_void, _Val: c_int, _Size: usize) ?*c_void;
pub extern fn memicmp(_Buf1: ?*const c_void, _Buf2: ?*const c_void, _Size: usize) c_int;
pub extern fn wcscat_s(_Destination: [*c]wchar_t, _SizeInWords: rsize_t, _Source: [*c]const wchar_t) errno_t;
pub extern fn wcscpy_s(_Destination: [*c]wchar_t, _SizeInWords: rsize_t, _Source: [*c]const wchar_t) errno_t;
pub extern fn wcsncat_s(_Destination: [*c]wchar_t, _SizeInWords: rsize_t, _Source: [*c]const wchar_t, _MaxCount: rsize_t) errno_t;
pub extern fn wcsncpy_s(_Destination: [*c]wchar_t, _SizeInWords: rsize_t, _Source: [*c]const wchar_t, _MaxCount: rsize_t) errno_t;
pub extern fn wcstok_s(_String: [*c]wchar_t, _Delimiter: [*c]const wchar_t, _Context: [*c]([*c]wchar_t)) [*c]wchar_t;
pub extern fn _wcsdup(_String: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcscat(_Destination: [*c]wchar_t, _Source: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcscmp(_String1: [*c]const c_ushort, _String2: [*c]const c_ushort) c_int;
pub extern fn wcscpy(_Destination: [*c]wchar_t, _Source: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcscspn(_String: [*c]const wchar_t, _Control: [*c]const wchar_t) usize;
pub extern fn wcslen(_String: [*c]const c_ushort) c_ulonglong;
pub extern fn wcsnlen(_Source: [*c]const wchar_t, _MaxCount: usize) usize;
pub fn wcsnlen_s(_Source: [*c]const wchar_t, _MaxCount: usize) usize {
    return if (_Source == null) @as(c_ulonglong, 0) else wcsnlen(_Source, _MaxCount);
}
pub extern fn wcsncat(_Destination: [*c]wchar_t, _Source: [*c]const wchar_t, _Count: usize) [*c]wchar_t;
pub extern fn wcsncmp(_String1: [*c]const c_ushort, _String2: [*c]const c_ushort, _MaxCount: c_ulonglong) c_int;
pub extern fn wcsncpy(_Destination: [*c]wchar_t, _Source: [*c]const wchar_t, _Count: usize) [*c]wchar_t;
pub extern fn wcspbrk(_String: [*c]const wchar_t, _Control: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcsspn(_String: [*c]const wchar_t, _Control: [*c]const wchar_t) usize;
pub extern fn wcstok(_String: [*c]wchar_t, _Delimiter: [*c]const wchar_t, _Context: [*c]([*c]wchar_t)) [*c]wchar_t;
pub fn _wcstok(_String: [*c]wchar_t, _Delimiter: [*c]const wchar_t) [*c]wchar_t {
    return wcstok(_String, _Delimiter, null);
}
pub extern fn _wcserror(_ErrorNumber: c_int) [*c]wchar_t;
pub extern fn _wcserror_s(_Buffer: [*c]wchar_t, _SizeInWords: usize, _ErrorNumber: c_int) errno_t;
pub extern fn __wcserror(_String: [*c]const wchar_t) [*c]wchar_t;
pub extern fn __wcserror_s(_Buffer: [*c]wchar_t, _SizeInWords: usize, _ErrorMessage: [*c]const wchar_t) errno_t;
pub extern fn _wcsicmp(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t) c_int;
pub extern fn _wcsicmp_l(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _Locale: _locale_t) c_int;
pub extern fn _wcsnicmp(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _MaxCount: usize) c_int;
pub extern fn _wcsnicmp_l(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn _wcsnset_s(_Destination: [*c]wchar_t, _SizeInWords: usize, _Value: wchar_t, _MaxCount: usize) errno_t;
pub extern fn _wcsnset(_String: [*c]wchar_t, _Value: wchar_t, _MaxCount: usize) [*c]wchar_t;
pub extern fn _wcsrev(_String: [*c]wchar_t) [*c]wchar_t;
pub extern fn _wcsset_s(_Destination: [*c]wchar_t, _SizeInWords: usize, _Value: wchar_t) errno_t;
pub extern fn _wcsset(_String: [*c]wchar_t, _Value: wchar_t) [*c]wchar_t;
pub extern fn _wcslwr_s(_String: [*c]wchar_t, _SizeInWords: usize) errno_t;
pub extern fn _wcslwr(_String: [*c]wchar_t) [*c]wchar_t;
pub extern fn _wcslwr_s_l(_String: [*c]wchar_t, _SizeInWords: usize, _Locale: _locale_t) errno_t;
pub extern fn _wcslwr_l(_String: [*c]wchar_t, _Locale: _locale_t) [*c]wchar_t;
pub extern fn _wcsupr_s(_String: [*c]wchar_t, _Size: usize) errno_t;
pub extern fn _wcsupr(_String: [*c]wchar_t) [*c]wchar_t;
pub extern fn _wcsupr_s_l(_String: [*c]wchar_t, _Size: usize, _Locale: _locale_t) errno_t;
pub extern fn _wcsupr_l(_String: [*c]wchar_t, _Locale: _locale_t) [*c]wchar_t;
pub extern fn wcsxfrm(_Destination: [*c]wchar_t, _Source: [*c]const wchar_t, _MaxCount: usize) usize;
pub extern fn _wcsxfrm_l(_Destination: [*c]wchar_t, _Source: [*c]const wchar_t, _MaxCount: usize, _Locale: _locale_t) usize;
pub extern fn wcscoll(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t) c_int;
pub extern fn _wcscoll_l(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _Locale: _locale_t) c_int;
pub extern fn _wcsicoll(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t) c_int;
pub extern fn _wcsicoll_l(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _Locale: _locale_t) c_int;
pub extern fn _wcsncoll(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _MaxCount: usize) c_int;
pub extern fn _wcsncoll_l(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn _wcsnicoll(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _MaxCount: usize) c_int;
pub extern fn _wcsnicoll_l(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn wcsdup(_String: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcsicmp(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t) c_int;
pub extern fn wcsnicmp(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _MaxCount: usize) c_int;
pub extern fn wcsnset(_String: [*c]wchar_t, _Value: wchar_t, _MaxCount: usize) [*c]wchar_t;
pub extern fn wcsrev(_String: [*c]wchar_t) [*c]wchar_t;
pub extern fn wcsset(_String: [*c]wchar_t, _Value: wchar_t) [*c]wchar_t;
pub extern fn wcslwr(_String: [*c]wchar_t) [*c]wchar_t;
pub extern fn wcsupr(_String: [*c]wchar_t) [*c]wchar_t;
pub extern fn wcsicoll(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t) c_int;
pub extern fn strcpy_s(_Destination: [*c]u8, _SizeInBytes: rsize_t, _Source: [*c]const u8) errno_t;
pub extern fn strcat_s(_Destination: [*c]u8, _SizeInBytes: rsize_t, _Source: [*c]const u8) errno_t;
pub extern fn strerror_s(_Buffer: [*c]u8, _SizeInBytes: usize, _ErrorNumber: c_int) errno_t;
pub extern fn strncat_s(_Destination: [*c]u8, _SizeInBytes: rsize_t, _Source: [*c]const u8, _MaxCount: rsize_t) errno_t;
pub extern fn strncpy_s(_Destination: [*c]u8, _SizeInBytes: rsize_t, _Source: [*c]const u8, _MaxCount: rsize_t) errno_t;
pub extern fn strtok_s(_String: [*c]u8, _Delimiter: [*c]const u8, _Context: [*c]([*c]u8)) [*c]u8;
pub extern fn _memccpy(_Dst: ?*c_void, _Src: ?*const c_void, _Val: c_int, _MaxCount: usize) ?*c_void;
pub extern fn strcat(_Destination: [*c]u8, _Source: [*c]const u8) [*c]u8;
pub extern fn strcmp(_Str1: [*c]const u8, _Str2: [*c]const u8) c_int;
pub extern fn _strcmpi(_String1: [*c]const u8, _String2: [*c]const u8) c_int;
pub extern fn strcoll(_String1: [*c]const u8, _String2: [*c]const u8) c_int;
pub extern fn _strcoll_l(_String1: [*c]const u8, _String2: [*c]const u8, _Locale: _locale_t) c_int;
pub extern fn strcpy(_Destination: [*c]u8, _Source: [*c]const u8) [*c]u8;
pub extern fn strcspn(_Str: [*c]const u8, _Control: [*c]const u8) c_ulonglong;
pub extern fn _strdup(_Source: [*c]const u8) [*c]u8;
pub extern fn _strerror(_ErrorMessage: [*c]const u8) [*c]u8;
pub extern fn _strerror_s(_Buffer: [*c]u8, _SizeInBytes: usize, _ErrorMessage: [*c]const u8) errno_t;
pub extern fn strerror(_ErrorMessage: c_int) [*c]u8;
pub extern fn _stricmp(_String1: [*c]const u8, _String2: [*c]const u8) c_int;
pub extern fn _stricoll(_String1: [*c]const u8, _String2: [*c]const u8) c_int;
pub extern fn _stricoll_l(_String1: [*c]const u8, _String2: [*c]const u8, _Locale: _locale_t) c_int;
pub extern fn _stricmp_l(_String1: [*c]const u8, _String2: [*c]const u8, _Locale: _locale_t) c_int;
pub extern fn strlen(_Str: [*c]const u8) c_ulonglong;
pub extern fn _strlwr_s(_String: [*c]u8, _Size: usize) errno_t;
pub extern fn _strlwr(_String: [*c]u8) [*c]u8;
pub extern fn _strlwr_s_l(_String: [*c]u8, _Size: usize, _Locale: _locale_t) errno_t;
pub extern fn _strlwr_l(_String: [*c]u8, _Locale: _locale_t) [*c]u8;
pub extern fn strncat(_Destination: [*c]u8, _Source: [*c]const u8, _Count: c_ulonglong) [*c]u8;
pub extern fn strncmp(_Str1: [*c]const u8, _Str2: [*c]const u8, _MaxCount: c_ulonglong) c_int;
pub extern fn _strnicmp(_String1: [*c]const u8, _String2: [*c]const u8, _MaxCount: usize) c_int;
pub extern fn _strnicmp_l(_String1: [*c]const u8, _String2: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn _strnicoll(_String1: [*c]const u8, _String2: [*c]const u8, _MaxCount: usize) c_int;
pub extern fn _strnicoll_l(_String1: [*c]const u8, _String2: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn _strncoll(_String1: [*c]const u8, _String2: [*c]const u8, _MaxCount: usize) c_int;
pub extern fn _strncoll_l(_String1: [*c]const u8, _String2: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn __strncnt(_String: [*c]const u8, _Count: usize) usize;
pub extern fn strncpy(_Destination: [*c]u8, _Source: [*c]const u8, _Count: c_ulonglong) [*c]u8;
pub extern fn strnlen(_String: [*c]const u8, _MaxCount: usize) usize;
pub fn strnlen_s(_String: [*c]const u8, _MaxCount: usize) usize {
    return if (_String == null) @as(c_ulonglong, 0) else strnlen(_String, _MaxCount);
}
pub extern fn _strnset_s(_String: [*c]u8, _SizeInBytes: usize, _Value: c_int, _MaxCount: usize) errno_t;
pub extern fn _strnset(_Destination: [*c]u8, _Value: c_int, _Count: usize) [*c]u8;
pub extern fn strpbrk(_Str: [*c]const u8, _Control: [*c]const u8) [*c]u8;
pub extern fn _strrev(_Str: [*c]u8) [*c]u8;
pub extern fn _strset_s(_Destination: [*c]u8, _DestinationSize: usize, _Value: c_int) errno_t;
pub extern fn _strset(_Destination: [*c]u8, _Value: c_int) [*c]u8;
pub extern fn strspn(_Str: [*c]const u8, _Control: [*c]const u8) c_ulonglong;
pub extern fn strtok(_String: [*c]u8, _Delimiter: [*c]const u8) [*c]u8;
pub extern fn _strupr_s(_String: [*c]u8, _Size: usize) errno_t;
pub extern fn _strupr(_String: [*c]u8) [*c]u8;
pub extern fn _strupr_s_l(_String: [*c]u8, _Size: usize, _Locale: _locale_t) errno_t;
pub extern fn _strupr_l(_String: [*c]u8, _Locale: _locale_t) [*c]u8;
pub extern fn strxfrm(_Destination: [*c]u8, _Source: [*c]const u8, _MaxCount: c_ulonglong) c_ulonglong;
pub extern fn _strxfrm_l(_Destination: [*c]u8, _Source: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) usize;
pub extern fn strdup(_String: [*c]const u8) [*c]u8;
pub extern fn strcmpi(_String1: [*c]const u8, _String2: [*c]const u8) c_int;
pub extern fn stricmp(_String1: [*c]const u8, _String2: [*c]const u8) c_int;
pub extern fn strlwr(_String: [*c]u8) [*c]u8;
pub extern fn strnicmp(_String1: [*c]const u8, _String2: [*c]const u8, _MaxCount: usize) c_int;
pub extern fn strnset(_String: [*c]u8, _Value: c_int, _MaxCount: usize) [*c]u8;
pub extern fn strrev(_String: [*c]u8) [*c]u8;
pub extern fn strset(_String: [*c]u8, _Value: c_int) [*c]u8;
pub extern fn strupr(_String: [*c]u8) [*c]u8;
pub const struct__OBJECTID = extern struct {
    Lineage: GUID,
    Uniquifier: DWORD,
};
pub const OBJECTID = struct__OBJECTID;
pub const __C_ASSERT__ = [1]u8;
pub const KSPIN_LOCK = ULONG_PTR;
pub const PKSPIN_LOCK = [*c]KSPIN_LOCK;
pub const PM128A = [*c]struct__M128A;
pub const PXSAVE_FORMAT = [*c]struct__XSAVE_FORMAT;
pub const struct__XSAVE_CET_U_FORMAT = extern struct {
    Ia32CetUMsr: DWORD64,
    Ia32Pl3SspMsr: DWORD64,
};
pub const XSAVE_CET_U_FORMAT = struct__XSAVE_CET_U_FORMAT;
pub const PXSAVE_CET_U_FORMAT = [*c]struct__XSAVE_CET_U_FORMAT;
pub const struct__XSAVE_AREA_HEADER = extern struct {
    Mask: DWORD64,
    CompactionMask: DWORD64,
    Reserved2: [6]DWORD64,
};
pub const XSAVE_AREA_HEADER = struct__XSAVE_AREA_HEADER;
pub const PXSAVE_AREA_HEADER = [*c]struct__XSAVE_AREA_HEADER;
pub const struct__XSAVE_AREA = extern struct {
    LegacyState: XSAVE_FORMAT,
    Header: XSAVE_AREA_HEADER,
};
pub const XSAVE_AREA = struct__XSAVE_AREA;
pub const PXSAVE_AREA = [*c]struct__XSAVE_AREA;
pub const struct__XSTATE_CONTEXT = extern struct {
    Mask: DWORD64,
    Length: DWORD,
    Reserved1: DWORD,
    Area: PXSAVE_AREA,
    Buffer: PVOID,
};
pub const XSTATE_CONTEXT = struct__XSTATE_CONTEXT;
pub const PXSTATE_CONTEXT = [*c]struct__XSTATE_CONTEXT;
pub const struct__SCOPE_TABLE_AMD64 = extern struct {
    Count: DWORD,
    ScopeRecord: [1]extern struct {
        BeginAddress: DWORD,
        EndAddress: DWORD,
        HandlerAddress: DWORD,
        JumpTarget: DWORD,
    },
};
pub const SCOPE_TABLE_AMD64 = struct__SCOPE_TABLE_AMD64;
pub const PSCOPE_TABLE_AMD64 = [*c]struct__SCOPE_TABLE_AMD64;
pub extern fn _bittest(Base: [*c]const c_long, Offset: c_long) u8;
pub extern fn _bittestandcomplement(Base: [*c]c_long, Offset: c_long) u8;
pub extern fn _bittestandset(Base: [*c]c_long, Offset: c_long) u8;
pub extern fn _bittestandreset(Base: [*c]c_long, Offset: c_long) u8;
pub extern fn _interlockedbittestandset(Base: [*c]volatile c_long, Offset: c_long) u8;
pub extern fn _interlockedbittestandreset(Base: [*c]volatile c_long, Offset: c_long) u8;
pub extern fn _bittest64(Base: [*c]const c_longlong, Offset: c_longlong) u8;
pub extern fn _bittestandcomplement64(Base: [*c]c_longlong, Offset: c_longlong) u8;
pub extern fn _bittestandset64(Base: [*c]c_longlong, Offset: c_longlong) u8;
pub extern fn _bittestandreset64(Base: [*c]c_longlong, Offset: c_longlong) u8;
pub extern fn _interlockedbittestandset64(Base: [*c]volatile c_longlong, Offset: c_longlong) u8;
pub extern fn _interlockedbittestandreset64(Base: [*c]volatile c_longlong, Offset: c_longlong) u8;
pub extern fn _BitScanForward(Index: [*c]c_ulong, Mask: c_ulong) u8;
pub extern fn _BitScanReverse(Index: [*c]c_ulong, Mask: c_ulong) u8;
pub extern fn _BitScanForward64(Index: [*c]c_ulong, Mask: c_ulonglong) u8;
pub extern fn _BitScanReverse64(Index: [*c]c_ulong, Mask: c_ulonglong) u8;
pub extern fn _InterlockedIncrement16(Addend: [*c]volatile c_short) c_short;
pub extern fn _InterlockedDecrement16(Addend: [*c]volatile c_short) c_short;
pub extern fn _InterlockedCompareExchange16(Destination: [*c]volatile c_short, ExChange: c_short, Comperand: c_short) c_short;
pub extern fn _InterlockedAnd(Destination: [*c]volatile c_long, Value: c_long) c_long;
pub extern fn _InterlockedOr(Destination: [*c]volatile c_long, Value: c_long) c_long;
pub extern fn _InterlockedXor(Destination: [*c]volatile c_long, Value: c_long) c_long;
pub extern fn _InterlockedAnd64(Destination: [*c]volatile c_longlong, Value: c_longlong) c_longlong;
pub extern fn _InterlockedOr64(Destination: [*c]volatile c_longlong, Value: c_longlong) c_longlong;
pub extern fn _InterlockedXor64(Destination: [*c]volatile c_longlong, Value: c_longlong) c_longlong;
pub extern fn _InterlockedIncrement(Addend: [*c]volatile c_long) c_long;
pub extern fn _InterlockedDecrement(Addend: [*c]volatile c_long) c_long;
pub extern fn _InterlockedExchange(Target: [*c]volatile c_long, Value: c_long) c_long;
pub extern fn _InterlockedExchangeAdd(Addend: [*c]volatile c_long, Value: c_long) c_long;
pub extern fn _InterlockedCompareExchange(Destination: [*c]volatile c_long, ExChange: c_long, Comperand: c_long) c_long;
pub extern fn _InterlockedIncrement64(Addend: [*c]volatile c_longlong) c_longlong;
pub extern fn _InterlockedDecrement64(Addend: [*c]volatile c_longlong) c_longlong;
pub extern fn _InterlockedExchange64(Target: [*c]volatile c_longlong, Value: c_longlong) c_longlong;
pub extern fn _InterlockedExchangeAdd64(Addend: [*c]volatile c_longlong, Value: c_longlong) c_longlong;
pub extern fn _InterlockedCompareExchange64(Destination: [*c]volatile c_longlong, ExChange: c_longlong, Comperand: c_longlong) c_longlong;
pub extern fn _InterlockedCompareExchange128(Destination: [*c]volatile c_longlong, ExchangeHigh: c_longlong, ExchangeLow: c_longlong, ComparandResult: [*c]c_longlong) u8;
pub extern fn _InterlockedCompareExchangePointer(Destination: [*c]volatile (?*c_void), Exchange: ?*c_void, Comperand: ?*c_void) ?*c_void;
pub extern fn _InterlockedExchangePointer(Target: [*c]volatile (?*c_void), Value: ?*c_void) ?*c_void;
pub extern fn _InterlockedExchange8(Target: [*c]volatile u8, Value: u8) u8;
pub extern fn _InterlockedExchange16(Destination: [*c]volatile c_short, ExChange: c_short) c_short;
pub extern fn _InterlockedExchangeAdd8(_Addend: [*c]volatile u8, _Value: u8) u8;
pub extern fn _InterlockedAnd8(Destination: [*c]volatile u8, Value: u8) u8;
pub extern fn _InterlockedOr8(Destination: [*c]volatile u8, Value: u8) u8;
pub extern fn _InterlockedXor8(Destination: [*c]volatile u8, Value: u8) u8;
pub extern fn _InterlockedAnd16(Destination: [*c]volatile c_short, Value: c_short) c_short;
pub extern fn _InterlockedOr16(Destination: [*c]volatile c_short, Value: c_short) c_short;
pub extern fn _InterlockedXor16(Destination: [*c]volatile c_short, Value: c_short) c_short;
pub extern fn __cpuidex(CPUInfo: [*c]c_int, Function: c_int, SubLeaf: c_int) void;
pub extern fn _mm_clflush(Address: ?*const c_void) void;
pub extern fn _ReadWriteBarrier() void;
pub extern fn __faststorefence() void;
pub extern fn _mm_lfence() void;
pub extern fn _mm_mfence() void;
pub extern fn _mm_sfence() void;
pub extern fn _mm_pause() void;
pub extern fn _mm_prefetch(a: [*c]const u8, sel: c_int) void;
pub extern fn _m_prefetchw(Source: ?*const volatile c_void) void;
pub extern fn _mm_getcsr() c_uint;
pub extern fn _mm_setcsr(MxCsr: c_uint) void;
pub extern fn __getcallerseflags() c_uint;
pub extern fn __segmentlimit(Selector: DWORD) DWORD;
pub extern fn __readpmc(Counter: DWORD) DWORD64;
pub extern fn __rdtsc() c_ulonglong;
pub extern fn __movsb(Destination: PBYTE, Source: [*c]const BYTE, Count: SIZE_T) void;
pub extern fn __movsw(Destination: PWORD, Source: [*c]const WORD, Count: SIZE_T) void;
pub extern fn __movsd(Destination: PDWORD, Source: [*c]const DWORD, Count: SIZE_T) void;
pub extern fn __movsq(Destination: PDWORD64, Source: [*c]const DWORD64, Count: SIZE_T) void;
pub extern fn __stosb(Destination: [*c]u8, Value: u8, Count: c_ulonglong) void;
pub extern fn __stosw(Destination: PWORD, Value: WORD, Count: SIZE_T) void;
pub extern fn __stosd(Destination: PDWORD, Value: DWORD, Count: SIZE_T) void;
pub extern fn __stosq(Destination: PDWORD64, Value: DWORD64, Count: SIZE_T) void;
pub extern fn __mulh(Multiplier: c_longlong, Multiplicand: c_longlong) c_longlong;
pub extern fn __umulh(Multiplier: c_ulonglong, Multiplicand: c_ulonglong) c_ulonglong;
pub extern fn __popcnt64(operand: c_ulonglong) c_ulonglong;
pub extern fn __shiftleft128(LowPart: c_ulonglong, HighPart: c_ulonglong, Shift: u8) c_ulonglong;
pub extern fn __shiftright128(LowPart: c_ulonglong, HighPart: c_ulonglong, Shift: u8) c_ulonglong;
pub extern fn _mul128(Multiplier: c_longlong, Multiplicand: c_longlong, HighProduct: [*c]c_longlong) c_longlong;
pub extern fn _umul128(Multiplier: c_ulonglong, Multiplicand: c_ulonglong, HighProduct: [*c]c_ulonglong) c_ulonglong;
pub extern fn __readgsbyte(Offset: c_ulong) u8;
pub extern fn __readgsword(Offset: c_ulong) c_ushort;
pub extern fn __readgsdword(Offset: c_ulong) c_ulong;
pub extern fn __readgsqword(Offset: c_ulong) c_ulonglong;
pub extern fn __writegsbyte(Offset: DWORD, Data: BYTE) void;
pub extern fn __writegsword(Offset: DWORD, Data: WORD) void;
pub extern fn __writegsdword(Offset: DWORD, Data: DWORD) void;
pub extern fn __writegsqword(Offset: DWORD, Data: DWORD64) void;
pub extern fn __incgsbyte(Offset: DWORD) void;
pub extern fn __addgsbyte(Offset: DWORD, Value: BYTE) void;
pub extern fn __incgsword(Offset: DWORD) void;
pub extern fn __addgsword(Offset: DWORD, Value: WORD) void;
pub extern fn __incgsdword(Offset: DWORD) void;
pub extern fn __addgsdword(Offset: DWORD, Value: DWORD) void;
pub extern fn __incgsqword(Offset: DWORD) void;
pub extern fn __addgsqword(Offset: DWORD, Value: DWORD64) void;
pub const PXMM_SAVE_AREA32 = [*c]XSAVE_FORMAT;
pub const CONTEXT = struct__CONTEXT;
pub const RUNTIME_FUNCTION = struct__IMAGE_RUNTIME_FUNCTION_ENTRY;
pub const SCOPE_TABLE = SCOPE_TABLE_AMD64;
pub const PSCOPE_TABLE = [*c]SCOPE_TABLE_AMD64;
pub const PUNWIND_HISTORY_TABLE_ENTRY = [*c]struct__UNWIND_HISTORY_TABLE_ENTRY;
pub const UNWIND_HISTORY_TABLE = struct__UNWIND_HISTORY_TABLE;
pub const GET_RUNTIME_FUNCTION_CALLBACK = fn (DWORD64, PVOID) callconv(.C) PRUNTIME_FUNCTION;
pub const PGET_RUNTIME_FUNCTION_CALLBACK = ?GET_RUNTIME_FUNCTION_CALLBACK;
pub const OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK = fn (HANDLE, PVOID, PDWORD, [*c]PRUNTIME_FUNCTION) callconv(.C) DWORD;
pub const POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK = ?OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK;
pub const DISPATCHER_CONTEXT = struct__DISPATCHER_CONTEXT;
pub const PDISPATCHER_CONTEXT = [*c]struct__DISPATCHER_CONTEXT;
pub const EXCEPTION_RECORD = struct__EXCEPTION_RECORD;
pub const PEXCEPTION_RECORD = [*c]EXCEPTION_RECORD;
pub const struct__EXCEPTION_POINTERS = extern struct {
    ExceptionRecord: PEXCEPTION_RECORD,
    ContextRecord: PCONTEXT,
};
pub const PEXCEPTION_FILTER = ?fn ([*c]struct__EXCEPTION_POINTERS, PVOID) callconv(.C) LONG;
pub const PTERMINATION_HANDLER = ?fn (BOOLEAN, PVOID) callconv(.C) void;
pub const struct__KNONVOLATILE_CONTEXT_POINTERS = extern struct {
    @"": extern union {
        FloatingContext: [16]PM128A,
        @"": extern struct {
            Xmm0: PM128A,
            Xmm1: PM128A,
            Xmm2: PM128A,
            Xmm3: PM128A,
            Xmm4: PM128A,
            Xmm5: PM128A,
            Xmm6: PM128A,
            Xmm7: PM128A,
            Xmm8: PM128A,
            Xmm9: PM128A,
            Xmm10: PM128A,
            Xmm11: PM128A,
            Xmm12: PM128A,
            Xmm13: PM128A,
            Xmm14: PM128A,
            Xmm15: PM128A,
        },
    },
    @"": extern union {
        IntegerContext: [16]PDWORD64,
        @"": extern struct {
            Rax: PDWORD64,
            Rcx: PDWORD64,
            Rdx: PDWORD64,
            Rbx: PDWORD64,
            Rsp: PDWORD64,
            Rbp: PDWORD64,
            Rsi: PDWORD64,
            Rdi: PDWORD64,
            R8: PDWORD64,
            R9: PDWORD64,
            R10: PDWORD64,
            R11: PDWORD64,
            R12: PDWORD64,
            R13: PDWORD64,
            R14: PDWORD64,
            R15: PDWORD64,
        },
    },
};
pub const KNONVOLATILE_CONTEXT_POINTERS = struct__KNONVOLATILE_CONTEXT_POINTERS;
pub const PKNONVOLATILE_CONTEXT_POINTERS = [*c]struct__KNONVOLATILE_CONTEXT_POINTERS;
pub const struct__SCOPE_TABLE_ARM = extern struct {
    Count: DWORD,
    ScopeRecord: [1]extern struct {
        BeginAddress: DWORD,
        EndAddress: DWORD,
        HandlerAddress: DWORD,
        JumpTarget: DWORD,
    },
};
pub const SCOPE_TABLE_ARM = struct__SCOPE_TABLE_ARM;
pub const PSCOPE_TABLE_ARM = [*c]struct__SCOPE_TABLE_ARM;
pub const struct__SCOPE_TABLE_ARM64 = extern struct {
    Count: DWORD,
    ScopeRecord: [1]extern struct {
        BeginAddress: DWORD,
        EndAddress: DWORD,
        HandlerAddress: DWORD,
        JumpTarget: DWORD,
    },
};
pub const SCOPE_TABLE_ARM64 = struct__SCOPE_TABLE_ARM64;
pub const PSCOPE_TABLE_ARM64 = [*c]struct__SCOPE_TABLE_ARM64;
pub const struct__KNONVOLATILE_CONTEXT_POINTERS_ARM64 = extern struct {
    X19: PDWORD64,
    X20: PDWORD64,
    X21: PDWORD64,
    X22: PDWORD64,
    X23: PDWORD64,
    X24: PDWORD64,
    X25: PDWORD64,
    X26: PDWORD64,
    X27: PDWORD64,
    X28: PDWORD64,
    Fp: PDWORD64,
    Lr: PDWORD64,
    D8: PDWORD64,
    D9: PDWORD64,
    D10: PDWORD64,
    D11: PDWORD64,
    D12: PDWORD64,
    D13: PDWORD64,
    D14: PDWORD64,
    D15: PDWORD64,
};
pub const KNONVOLATILE_CONTEXT_POINTERS_ARM64 = struct__KNONVOLATILE_CONTEXT_POINTERS_ARM64;
pub const PKNONVOLATILE_CONTEXT_POINTERS_ARM64 = [*c]struct__KNONVOLATILE_CONTEXT_POINTERS_ARM64;
pub extern fn __int2c() noreturn;
pub const struct__LDT_ENTRY = extern struct {
    LimitLow: WORD,
    BaseLow: WORD,
    HighWord: extern union {
        Bytes: extern struct {
            BaseMid: BYTE,
            Flags1: BYTE,
            Flags2: BYTE,
            BaseHi: BYTE,
        },
        Bits: @OpaqueType(),
    },
};
pub const LDT_ENTRY = struct__LDT_ENTRY;
pub const PLDT_ENTRY = [*c]struct__LDT_ENTRY;
pub fn ReadAcquire8(Source: [*c]const volatile CHAR) CHAR {
    var Value: CHAR = undefined;
    Value = Source.?.*;
    return Value;
}
pub fn ReadNoFence8(Source: [*c]const volatile CHAR) CHAR {
    var Value: CHAR = undefined;
    Value = Source.?.*;
    return Value;
}
pub fn WriteRelease8(Destination: [*c]volatile CHAR, Value: CHAR) void {
    Destination.?.* = Value;
    return;
}
pub fn WriteNoFence8(Destination: [*c]volatile CHAR, Value: CHAR) void {
    Destination.?.* = Value;
    return;
}
pub fn ReadAcquire16(Source: [*c]const volatile SHORT) SHORT {
    var Value: SHORT = undefined;
    Value = Source.?.*;
    return Value;
}
pub fn ReadNoFence16(Source: [*c]const volatile SHORT) SHORT {
    var Value: SHORT = undefined;
    Value = Source.?.*;
    return Value;
}
pub fn WriteRelease16(Destination: [*c]volatile SHORT, Value: SHORT) void {
    Destination.?.* = Value;
    return;
}
pub fn WriteNoFence16(Destination: [*c]volatile SHORT, Value: SHORT) void {
    Destination.?.* = Value;
    return;
}
pub fn ReadAcquire(Source: [*c]const volatile LONG) LONG {
    var Value: LONG = undefined;
    Value = Source.?.*;
    return Value;
}
pub fn ReadNoFence(Source: [*c]const volatile LONG) LONG {
    var Value: LONG = undefined;
    Value = Source.?.*;
    return Value;
}
pub fn WriteRelease(Destination: [*c]volatile LONG, Value: LONG) void {
    Destination.?.* = Value;
    return;
}
pub fn WriteNoFence(Destination: [*c]volatile LONG, Value: LONG) void {
    Destination.?.* = Value;
    return;
}
pub fn ReadAcquire64(Source: [*c]const volatile LONG64) LONG64 {
    var Value: LONG64 = undefined;
    Value = Source.?.*;
    return Value;
}
pub fn ReadNoFence64(Source: [*c]const volatile LONG64) LONG64 {
    var Value: LONG64 = undefined;
    Value = Source.?.*;
    return Value;
}
pub fn WriteRelease64(Destination: [*c]volatile LONG64, Value: LONG64) void {
    Destination.?.* = Value;
    return;
}
pub fn WriteNoFence64(Destination: [*c]volatile LONG64, Value: LONG64) void {
    Destination.?.* = Value;
    return;
}
pub fn ReadRaw8(Source: [*c]const volatile CHAR) CHAR {
    var Value: CHAR = undefined;
    Value = @ptrCast([*c]CHAR, @alignCast(@alignOf(CHAR), Source)).?.*;
    return Value;
}
pub fn WriteRaw8(Destination: [*c]volatile CHAR, Value: CHAR) void {
    @ptrCast([*c]CHAR, @alignCast(@alignOf(CHAR), Destination)).?.* = Value;
    return;
}
pub fn ReadRaw16(Source: [*c]const volatile SHORT) SHORT {
    var Value: SHORT = undefined;
    Value = @ptrCast([*c]SHORT, @alignCast(@alignOf(SHORT), Source)).?.*;
    return Value;
}
pub fn WriteRaw16(Destination: [*c]volatile SHORT, Value: SHORT) void {
    @ptrCast([*c]SHORT, @alignCast(@alignOf(SHORT), Destination)).?.* = Value;
    return;
}
pub fn ReadRaw(Source: [*c]const volatile LONG) LONG {
    var Value: LONG = undefined;
    Value = @ptrCast([*c]LONG, @alignCast(@alignOf(LONG), Source)).?.*;
    return Value;
}
pub fn WriteRaw(Destination: [*c]volatile LONG, Value: LONG) void {
    @ptrCast([*c]LONG, @alignCast(@alignOf(LONG), Destination)).?.* = Value;
    return;
}
pub fn ReadRaw64(Source: [*c]const volatile LONG64) LONG64 {
    var Value: LONG64 = undefined;
    Value = @ptrCast([*c]LONG64, @alignCast(@alignOf(LONG64), Source)).?.*;
    return Value;
}
pub fn WriteRaw64(Destination: [*c]volatile LONG64, Value: LONG64) void {
    @ptrCast([*c]LONG64, @alignCast(@alignOf(LONG64), Destination)).?.* = Value;
    return;
}
pub fn ReadUCharAcquire(Source: [*c]const volatile BYTE) BYTE {
    return BYTE(ReadAcquire8(@ptrCast(PCHAR, @alignCast(@alignOf(CHAR), Source))));
}
pub fn ReadUCharNoFence(Source: [*c]const volatile BYTE) BYTE {
    return BYTE(ReadNoFence8(@ptrCast(PCHAR, @alignCast(@alignOf(CHAR), Source))));
}
pub fn ReadBooleanAcquire(Source: [*c]const volatile BOOLEAN) BYTE {
    return BOOLEAN(ReadAcquire8(@ptrCast(PCHAR, @alignCast(@alignOf(CHAR), Source))));
}
pub fn ReadBooleanNoFence(Source: [*c]const volatile BOOLEAN) BYTE {
    return BOOLEAN(ReadNoFence8(@ptrCast(PCHAR, @alignCast(@alignOf(CHAR), Source))));
}
pub fn ReadUCharRaw(Source: [*c]const volatile BYTE) BYTE {
    return BYTE(ReadRaw8(@ptrCast(PCHAR, @alignCast(@alignOf(CHAR), Source))));
}
pub fn WriteUCharRelease(Destination: [*c]volatile BYTE, Value: BYTE) void {
    WriteRelease8(@ptrCast(PCHAR, @alignCast(@alignOf(CHAR), Destination)), CHAR(Value));
    return;
}
pub fn WriteUCharNoFence(Destination: [*c]volatile BYTE, Value: BYTE) void {
    WriteNoFence8(@ptrCast(PCHAR, @alignCast(@alignOf(CHAR), Destination)), CHAR(Value));
    return;
}
pub fn WriteBooleanRelease(Destination: [*c]volatile BOOLEAN, Value: BOOLEAN) void {
    WriteRelease8(@ptrCast(PCHAR, @alignCast(@alignOf(CHAR), Destination)), CHAR(Value));
    return;
}
pub fn WriteBooleanNoFence(Destination: [*c]volatile BOOLEAN, Value: BOOLEAN) void {
    WriteNoFence8(@ptrCast(PCHAR, @alignCast(@alignOf(CHAR), Destination)), CHAR(Value));
    return;
}
pub fn WriteUCharRaw(Destination: [*c]volatile BYTE, Value: BYTE) void {
    WriteRaw8(@ptrCast(PCHAR, @alignCast(@alignOf(CHAR), Destination)), CHAR(Value));
    return;
}
pub fn ReadUShortAcquire(Source: [*c]const volatile WORD) WORD {
    return WORD(ReadAcquire16(@ptrCast(PSHORT, @alignCast(@alignOf(SHORT), Source))));
}
pub fn ReadUShortNoFence(Source: [*c]const volatile WORD) WORD {
    return WORD(ReadNoFence16(@ptrCast(PSHORT, @alignCast(@alignOf(SHORT), Source))));
}
pub fn ReadUShortRaw(Source: [*c]const volatile WORD) WORD {
    return WORD(ReadRaw16(@ptrCast(PSHORT, @alignCast(@alignOf(SHORT), Source))));
}
pub fn WriteUShortRelease(Destination: [*c]volatile WORD, Value: WORD) void {
    WriteRelease16(@ptrCast(PSHORT, @alignCast(@alignOf(SHORT), Destination)), SHORT(Value));
    return;
}
pub fn WriteUShortNoFence(Destination: [*c]volatile WORD, Value: WORD) void {
    WriteNoFence16(@ptrCast(PSHORT, @alignCast(@alignOf(SHORT), Destination)), SHORT(Value));
    return;
}
pub fn WriteUShortRaw(Destination: [*c]volatile WORD, Value: WORD) void {
    WriteRaw16(@ptrCast(PSHORT, @alignCast(@alignOf(SHORT), Destination)), SHORT(Value));
    return;
}
pub fn ReadULongAcquire(Source: [*c]const volatile DWORD) DWORD {
    return DWORD(ReadAcquire(@ptrCast(PLONG, @alignCast(@alignOf(LONG), Source))));
}
pub fn ReadULongNoFence(Source: [*c]const volatile DWORD) DWORD {
    return DWORD(ReadNoFence(@ptrCast(PLONG, @alignCast(@alignOf(LONG), Source))));
}
pub fn ReadULongRaw(Source: [*c]const volatile DWORD) DWORD {
    return DWORD(ReadRaw(@ptrCast(PLONG, @alignCast(@alignOf(LONG), Source))));
}
pub fn WriteULongRelease(Destination: [*c]volatile DWORD, Value: DWORD) void {
    WriteRelease(@ptrCast(PLONG, @alignCast(@alignOf(LONG), Destination)), LONG(Value));
    return;
}
pub fn WriteULongNoFence(Destination: [*c]volatile DWORD, Value: DWORD) void {
    WriteNoFence(@ptrCast(PLONG, @alignCast(@alignOf(LONG), Destination)), LONG(Value));
    return;
}
pub fn WriteULongRaw(Destination: [*c]volatile DWORD, Value: DWORD) void {
    WriteRaw(@ptrCast(PLONG, @alignCast(@alignOf(LONG), Destination)), LONG(Value));
    return;
}
pub fn ReadULong64Acquire(Source: [*c]const volatile DWORD64) DWORD64 {
    return DWORD64(ReadAcquire64(@ptrCast(PLONG64, @alignCast(@alignOf(c_longlong), Source))));
}
pub fn ReadULong64NoFence(Source: [*c]const volatile DWORD64) DWORD64 {
    return DWORD64(ReadNoFence64(@ptrCast(PLONG64, @alignCast(@alignOf(c_longlong), Source))));
}
pub fn ReadULong64Raw(Source: [*c]const volatile DWORD64) DWORD64 {
    return DWORD64(ReadRaw64(@ptrCast(PLONG64, @alignCast(@alignOf(c_longlong), Source))));
}
pub fn WriteULong64Release(Destination: [*c]volatile DWORD64, Value: DWORD64) void {
    WriteRelease64(@ptrCast(PLONG64, @alignCast(@alignOf(c_longlong), Destination)), LONG64(Value));
    return;
}
pub fn WriteULong64NoFence(Destination: [*c]volatile DWORD64, Value: DWORD64) void {
    WriteNoFence64(@ptrCast(PLONG64, @alignCast(@alignOf(c_longlong), Destination)), LONG64(Value));
    return;
}
pub fn WriteULong64Raw(Destination: [*c]volatile DWORD64, Value: DWORD64) void {
    WriteRaw64(@ptrCast(PLONG64, @alignCast(@alignOf(c_longlong), Destination)), LONG64(Value));
    return;
}
pub fn ReadPointerAcquire(Source: [*c]const volatile PVOID) PVOID {
    return PVOID(ReadAcquire64(@ptrCast(PLONG64, @alignCast(@alignOf(c_longlong), Source))));
}
pub fn ReadPointerNoFence(Source: [*c]const volatile PVOID) PVOID {
    return PVOID(ReadNoFence64(@ptrCast(PLONG64, @alignCast(@alignOf(c_longlong), Source))));
}
pub fn ReadPointerRaw(Source: [*c]const volatile PVOID) PVOID {
    return PVOID(ReadRaw64(@ptrCast(PLONG64, @alignCast(@alignOf(c_longlong), Source))));
}
pub fn WritePointerRelease(Destination: [*c]volatile PVOID, Value: PVOID) void {
    WriteRelease64(@ptrCast(PLONG64, @alignCast(@alignOf(c_longlong), Destination)), LONG64(Value));
    return;
}
pub fn WritePointerNoFence(Destination: [*c]volatile PVOID, Value: PVOID) void {
    WriteNoFence64(@ptrCast(PLONG64, @alignCast(@alignOf(c_longlong), Destination)), LONG64(Value));
    return;
}
pub fn WritePointerRaw(Destination: [*c]volatile PVOID, Value: PVOID) void {
    WriteRaw64(@ptrCast(PLONG64, @alignCast(@alignOf(c_longlong), Destination)), LONG64(Value));
    return;
}
pub const struct__WOW64_FLOATING_SAVE_AREA = extern struct {
    ControlWord: DWORD,
    StatusWord: DWORD,
    TagWord: DWORD,
    ErrorOffset: DWORD,
    ErrorSelector: DWORD,
    DataOffset: DWORD,
    DataSelector: DWORD,
    RegisterArea: [80]BYTE,
    Cr0NpxState: DWORD,
};
pub const WOW64_FLOATING_SAVE_AREA = struct__WOW64_FLOATING_SAVE_AREA;
pub const PWOW64_FLOATING_SAVE_AREA = [*c]WOW64_FLOATING_SAVE_AREA;
pub const struct__WOW64_CONTEXT = extern struct {
    ContextFlags: DWORD,
    Dr0: DWORD,
    Dr1: DWORD,
    Dr2: DWORD,
    Dr3: DWORD,
    Dr6: DWORD,
    Dr7: DWORD,
    FloatSave: WOW64_FLOATING_SAVE_AREA,
    SegGs: DWORD,
    SegFs: DWORD,
    SegEs: DWORD,
    SegDs: DWORD,
    Edi: DWORD,
    Esi: DWORD,
    Ebx: DWORD,
    Edx: DWORD,
    Ecx: DWORD,
    Eax: DWORD,
    Ebp: DWORD,
    Eip: DWORD,
    SegCs: DWORD,
    EFlags: DWORD,
    Esp: DWORD,
    SegSs: DWORD,
    ExtendedRegisters: [512]BYTE,
};
pub const WOW64_CONTEXT = struct__WOW64_CONTEXT;
pub const PWOW64_CONTEXT = [*c]WOW64_CONTEXT;
pub const struct__WOW64_LDT_ENTRY = extern struct {
    LimitLow: WORD,
    BaseLow: WORD,
    HighWord: extern union {
        Bytes: extern struct {
            BaseMid: BYTE,
            Flags1: BYTE,
            Flags2: BYTE,
            BaseHi: BYTE,
        },
        Bits: @OpaqueType(),
    },
};
pub const WOW64_LDT_ENTRY = struct__WOW64_LDT_ENTRY;
pub const PWOW64_LDT_ENTRY = [*c]struct__WOW64_LDT_ENTRY;
pub const struct__WOW64_DESCRIPTOR_TABLE_ENTRY = extern struct {
    Selector: DWORD,
    Descriptor: WOW64_LDT_ENTRY,
};
pub const WOW64_DESCRIPTOR_TABLE_ENTRY = struct__WOW64_DESCRIPTOR_TABLE_ENTRY;
pub const PWOW64_DESCRIPTOR_TABLE_ENTRY = [*c]struct__WOW64_DESCRIPTOR_TABLE_ENTRY;
pub const struct__EXCEPTION_RECORD32 = extern struct {
    ExceptionCode: DWORD,
    ExceptionFlags: DWORD,
    ExceptionRecord: DWORD,
    ExceptionAddress: DWORD,
    NumberParameters: DWORD,
    ExceptionInformation: [15]DWORD,
};
pub const EXCEPTION_RECORD32 = struct__EXCEPTION_RECORD32;
pub const PEXCEPTION_RECORD32 = [*c]struct__EXCEPTION_RECORD32;
pub const struct__EXCEPTION_RECORD64 = extern struct {
    ExceptionCode: DWORD,
    ExceptionFlags: DWORD,
    ExceptionRecord: DWORD64,
    ExceptionAddress: DWORD64,
    NumberParameters: DWORD,
    __unusedAlignment: DWORD,
    ExceptionInformation: [15]DWORD64,
};
pub const EXCEPTION_RECORD64 = struct__EXCEPTION_RECORD64;
pub const PEXCEPTION_RECORD64 = [*c]struct__EXCEPTION_RECORD64;
pub const EXCEPTION_POINTERS = struct__EXCEPTION_POINTERS;
pub const PEXCEPTION_POINTERS = [*c]struct__EXCEPTION_POINTERS;
pub const PACCESS_TOKEN = PVOID;
pub const PSECURITY_DESCRIPTOR = PVOID;
pub const PSID = PVOID;
pub const PCLAIMS_BLOB = PVOID;
pub const ACCESS_MASK = DWORD;
pub const PACCESS_MASK = [*c]ACCESS_MASK;
pub const struct__GENERIC_MAPPING = extern struct {
    GenericRead: ACCESS_MASK,
    GenericWrite: ACCESS_MASK,
    GenericExecute: ACCESS_MASK,
    GenericAll: ACCESS_MASK,
};
pub const GENERIC_MAPPING = struct__GENERIC_MAPPING;
pub const PGENERIC_MAPPING = [*c]GENERIC_MAPPING;
pub const struct__LUID_AND_ATTRIBUTES = extern struct {
    Luid: LUID,
    Attributes: DWORD,
};
pub const LUID_AND_ATTRIBUTES = struct__LUID_AND_ATTRIBUTES;
pub const PLUID_AND_ATTRIBUTES = [*c]struct__LUID_AND_ATTRIBUTES;
pub const LUID_AND_ATTRIBUTES_ARRAY = [1]LUID_AND_ATTRIBUTES;
pub const PLUID_AND_ATTRIBUTES_ARRAY = [*c]LUID_AND_ATTRIBUTES_ARRAY;
pub const struct__SID_IDENTIFIER_AUTHORITY = extern struct {
    Value: [6]BYTE,
};
pub const SID_IDENTIFIER_AUTHORITY = struct__SID_IDENTIFIER_AUTHORITY;
pub const PSID_IDENTIFIER_AUTHORITY = [*c]struct__SID_IDENTIFIER_AUTHORITY;
pub const struct__SID = extern struct {
    Revision: BYTE,
    SubAuthorityCount: BYTE,
    IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
    SubAuthority: [1]DWORD,
};
pub const SID = struct__SID;
pub const PISID = [*c]struct__SID;
pub const union__SE_SID = extern union {
    Sid: SID,
    Buffer: [68]BYTE,
};
pub const SE_SID = union__SE_SID;
pub const PSE_SID = [*c]union__SE_SID;
pub const SidTypeUser = enum__SID_NAME_USE.SidTypeUser;
pub const SidTypeGroup = enum__SID_NAME_USE.SidTypeGroup;
pub const SidTypeDomain = enum__SID_NAME_USE.SidTypeDomain;
pub const SidTypeAlias = enum__SID_NAME_USE.SidTypeAlias;
pub const SidTypeWellKnownGroup = enum__SID_NAME_USE.SidTypeWellKnownGroup;
pub const SidTypeDeletedAccount = enum__SID_NAME_USE.SidTypeDeletedAccount;
pub const SidTypeInvalid = enum__SID_NAME_USE.SidTypeInvalid;
pub const SidTypeUnknown = enum__SID_NAME_USE.SidTypeUnknown;
pub const SidTypeComputer = enum__SID_NAME_USE.SidTypeComputer;
pub const SidTypeLabel = enum__SID_NAME_USE.SidTypeLabel;
pub const SidTypeLogonSession = enum__SID_NAME_USE.SidTypeLogonSession;
pub const enum__SID_NAME_USE = extern enum {
    SidTypeUser = 1,
    SidTypeGroup = 2,
    SidTypeDomain = 3,
    SidTypeAlias = 4,
    SidTypeWellKnownGroup = 5,
    SidTypeDeletedAccount = 6,
    SidTypeInvalid = 7,
    SidTypeUnknown = 8,
    SidTypeComputer = 9,
    SidTypeLabel = 10,
    SidTypeLogonSession = 11,
};
pub const SID_NAME_USE = enum__SID_NAME_USE;
pub const PSID_NAME_USE = [*c]enum__SID_NAME_USE;
pub const struct__SID_AND_ATTRIBUTES = extern struct {
    Sid: PSID,
    Attributes: DWORD,
};
pub const SID_AND_ATTRIBUTES = struct__SID_AND_ATTRIBUTES;
pub const PSID_AND_ATTRIBUTES = [*c]struct__SID_AND_ATTRIBUTES;
pub const SID_AND_ATTRIBUTES_ARRAY = [1]SID_AND_ATTRIBUTES;
pub const PSID_AND_ATTRIBUTES_ARRAY = [*c]SID_AND_ATTRIBUTES_ARRAY;
pub const SID_HASH_ENTRY = ULONG_PTR;
pub const PSID_HASH_ENTRY = [*c]ULONG_PTR;
pub const struct__SID_AND_ATTRIBUTES_HASH = extern struct {
    SidCount: DWORD,
    SidAttr: PSID_AND_ATTRIBUTES,
    Hash: [32]SID_HASH_ENTRY,
};
pub const SID_AND_ATTRIBUTES_HASH = struct__SID_AND_ATTRIBUTES_HASH;
pub const PSID_AND_ATTRIBUTES_HASH = [*c]struct__SID_AND_ATTRIBUTES_HASH;
pub const WinNullSid = 0;
pub const WinWorldSid = 1;
pub const WinLocalSid = 2;
pub const WinCreatorOwnerSid = 3;
pub const WinCreatorGroupSid = 4;
pub const WinCreatorOwnerServerSid = 5;
pub const WinCreatorGroupServerSid = 6;
pub const WinNtAuthoritySid = 7;
pub const WinDialupSid = 8;
pub const WinNetworkSid = 9;
pub const WinBatchSid = 10;
pub const WinInteractiveSid = 11;
pub const WinServiceSid = 12;
pub const WinAnonymousSid = 13;
pub const WinProxySid = 14;
pub const WinEnterpriseControllersSid = 15;
pub const WinSelfSid = 16;
pub const WinAuthenticatedUserSid = 17;
pub const WinRestrictedCodeSid = 18;
pub const WinTerminalServerSid = 19;
pub const WinRemoteLogonIdSid = 20;
pub const WinLogonIdsSid = 21;
pub const WinLocalSystemSid = 22;
pub const WinLocalServiceSid = 23;
pub const WinNetworkServiceSid = 24;
pub const WinBuiltinDomainSid = 25;
pub const WinBuiltinAdministratorsSid = 26;
pub const WinBuiltinUsersSid = 27;
pub const WinBuiltinGuestsSid = 28;
pub const WinBuiltinPowerUsersSid = 29;
pub const WinBuiltinAccountOperatorsSid = 30;
pub const WinBuiltinSystemOperatorsSid = 31;
pub const WinBuiltinPrintOperatorsSid = 32;
pub const WinBuiltinBackupOperatorsSid = 33;
pub const WinBuiltinReplicatorSid = 34;
pub const WinBuiltinPreWindows2000CompatibleAccessSid = 35;
pub const WinBuiltinRemoteDesktopUsersSid = 36;
pub const WinBuiltinNetworkConfigurationOperatorsSid = 37;
pub const WinAccountAdministratorSid = 38;
pub const WinAccountGuestSid = 39;
pub const WinAccountKrbtgtSid = 40;
pub const WinAccountDomainAdminsSid = 41;
pub const WinAccountDomainUsersSid = 42;
pub const WinAccountDomainGuestsSid = 43;
pub const WinAccountComputersSid = 44;
pub const WinAccountControllersSid = 45;
pub const WinAccountCertAdminsSid = 46;
pub const WinAccountSchemaAdminsSid = 47;
pub const WinAccountEnterpriseAdminsSid = 48;
pub const WinAccountPolicyAdminsSid = 49;
pub const WinAccountRasAndIasServersSid = 50;
pub const WinNTLMAuthenticationSid = 51;
pub const WinDigestAuthenticationSid = 52;
pub const WinSChannelAuthenticationSid = 53;
pub const WinThisOrganizationSid = 54;
pub const WinOtherOrganizationSid = 55;
pub const WinBuiltinIncomingForestTrustBuildersSid = 56;
pub const WinBuiltinPerfMonitoringUsersSid = 57;
pub const WinBuiltinPerfLoggingUsersSid = 58;
pub const WinBuiltinAuthorizationAccessSid = 59;
pub const WinBuiltinTerminalServerLicenseServersSid = 60;
pub const WinBuiltinDCOMUsersSid = 61;
pub const WinBuiltinIUsersSid = 62;
pub const WinIUserSid = 63;
pub const WinBuiltinCryptoOperatorsSid = 64;
pub const WinUntrustedLabelSid = 65;
pub const WinLowLabelSid = 66;
pub const WinMediumLabelSid = 67;
pub const WinHighLabelSid = 68;
pub const WinSystemLabelSid = 69;
pub const WinWriteRestrictedCodeSid = 70;
pub const WinCreatorOwnerRightsSid = 71;
pub const WinCacheablePrincipalsGroupSid = 72;
pub const WinNonCacheablePrincipalsGroupSid = 73;
pub const WinEnterpriseReadonlyControllersSid = 74;
pub const WinAccountReadonlyControllersSid = 75;
pub const WinBuiltinEventLogReadersGroup = 76;
pub const WinNewEnterpriseReadonlyControllersSid = 77;
pub const WinBuiltinCertSvcDComAccessGroup = 78;
pub const WinMediumPlusLabelSid = 79;
pub const WinLocalLogonSid = 80;
pub const WinConsoleLogonSid = 81;
pub const WinThisOrganizationCertificateSid = 82;
pub const WinApplicationPackageAuthoritySid = 83;
pub const WinBuiltinAnyPackageSid = 84;
pub const WinCapabilityInternetClientSid = 85;
pub const WinCapabilityInternetClientServerSid = 86;
pub const WinCapabilityPrivateNetworkClientServerSid = 87;
pub const WinCapabilityPicturesLibrarySid = 88;
pub const WinCapabilityVideosLibrarySid = 89;
pub const WinCapabilityMusicLibrarySid = 90;
pub const WinCapabilityDocumentsLibrarySid = 91;
pub const WinCapabilitySharedUserCertificatesSid = 92;
pub const WinCapabilityEnterpriseAuthenticationSid = 93;
pub const WinCapabilityRemovableStorageSid = 94;
pub const WinBuiltinRDSRemoteAccessServersSid = 95;
pub const WinBuiltinRDSEndpointServersSid = 96;
pub const WinBuiltinRDSManagementServersSid = 97;
pub const WinUserModeDriversSid = 98;
pub const WinBuiltinHyperVAdminsSid = 99;
pub const WinAccountCloneableControllersSid = 100;
pub const WinBuiltinAccessControlAssistanceOperatorsSid = 101;
pub const WinBuiltinRemoteManagementUsersSid = 102;
pub const WinAuthenticationAuthorityAssertedSid = 103;
pub const WinAuthenticationServiceAssertedSid = 104;
pub const WinLocalAccountSid = 105;
pub const WinLocalAccountAndAdministratorSid = 106;
pub const WinAccountProtectedUsersSid = 107;
pub const WinCapabilityAppointmentsSid = 108;
pub const WinCapabilityContactsSid = 109;
pub const WinAccountDefaultSystemManagedSid = 110;
pub const WinBuiltinDefaultSystemManagedGroupSid = 111;
pub const WinBuiltinStorageReplicaAdminsSid = 112;
pub const WinAccountKeyAdminsSid = 113;
pub const WinAccountEnterpriseKeyAdminsSid = 114;
pub const WinAuthenticationKeyTrustSid = 115;
pub const WinAuthenticationKeyPropertyMFASid = 116;
pub const WinAuthenticationKeyPropertyAttestationSid = 117;
pub const WinAuthenticationFreshKeyAuthSid = 118;
pub const WinBuiltinDeviceOwnersSid = 119;
pub const WELL_KNOWN_SID_TYPE = extern enum {
    WinNullSid = 0,
    WinWorldSid = 1,
    WinLocalSid = 2,
    WinCreatorOwnerSid = 3,
    WinCreatorGroupSid = 4,
    WinCreatorOwnerServerSid = 5,
    WinCreatorGroupServerSid = 6,
    WinNtAuthoritySid = 7,
    WinDialupSid = 8,
    WinNetworkSid = 9,
    WinBatchSid = 10,
    WinInteractiveSid = 11,
    WinServiceSid = 12,
    WinAnonymousSid = 13,
    WinProxySid = 14,
    WinEnterpriseControllersSid = 15,
    WinSelfSid = 16,
    WinAuthenticatedUserSid = 17,
    WinRestrictedCodeSid = 18,
    WinTerminalServerSid = 19,
    WinRemoteLogonIdSid = 20,
    WinLogonIdsSid = 21,
    WinLocalSystemSid = 22,
    WinLocalServiceSid = 23,
    WinNetworkServiceSid = 24,
    WinBuiltinDomainSid = 25,
    WinBuiltinAdministratorsSid = 26,
    WinBuiltinUsersSid = 27,
    WinBuiltinGuestsSid = 28,
    WinBuiltinPowerUsersSid = 29,
    WinBuiltinAccountOperatorsSid = 30,
    WinBuiltinSystemOperatorsSid = 31,
    WinBuiltinPrintOperatorsSid = 32,
    WinBuiltinBackupOperatorsSid = 33,
    WinBuiltinReplicatorSid = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid = 36,
    WinBuiltinNetworkConfigurationOperatorsSid = 37,
    WinAccountAdministratorSid = 38,
    WinAccountGuestSid = 39,
    WinAccountKrbtgtSid = 40,
    WinAccountDomainAdminsSid = 41,
    WinAccountDomainUsersSid = 42,
    WinAccountDomainGuestsSid = 43,
    WinAccountComputersSid = 44,
    WinAccountControllersSid = 45,
    WinAccountCertAdminsSid = 46,
    WinAccountSchemaAdminsSid = 47,
    WinAccountEnterpriseAdminsSid = 48,
    WinAccountPolicyAdminsSid = 49,
    WinAccountRasAndIasServersSid = 50,
    WinNTLMAuthenticationSid = 51,
    WinDigestAuthenticationSid = 52,
    WinSChannelAuthenticationSid = 53,
    WinThisOrganizationSid = 54,
    WinOtherOrganizationSid = 55,
    WinBuiltinIncomingForestTrustBuildersSid = 56,
    WinBuiltinPerfMonitoringUsersSid = 57,
    WinBuiltinPerfLoggingUsersSid = 58,
    WinBuiltinAuthorizationAccessSid = 59,
    WinBuiltinTerminalServerLicenseServersSid = 60,
    WinBuiltinDCOMUsersSid = 61,
    WinBuiltinIUsersSid = 62,
    WinIUserSid = 63,
    WinBuiltinCryptoOperatorsSid = 64,
    WinUntrustedLabelSid = 65,
    WinLowLabelSid = 66,
    WinMediumLabelSid = 67,
    WinHighLabelSid = 68,
    WinSystemLabelSid = 69,
    WinWriteRestrictedCodeSid = 70,
    WinCreatorOwnerRightsSid = 71,
    WinCacheablePrincipalsGroupSid = 72,
    WinNonCacheablePrincipalsGroupSid = 73,
    WinEnterpriseReadonlyControllersSid = 74,
    WinAccountReadonlyControllersSid = 75,
    WinBuiltinEventLogReadersGroup = 76,
    WinNewEnterpriseReadonlyControllersSid = 77,
    WinBuiltinCertSvcDComAccessGroup = 78,
    WinMediumPlusLabelSid = 79,
    WinLocalLogonSid = 80,
    WinConsoleLogonSid = 81,
    WinThisOrganizationCertificateSid = 82,
    WinApplicationPackageAuthoritySid = 83,
    WinBuiltinAnyPackageSid = 84,
    WinCapabilityInternetClientSid = 85,
    WinCapabilityInternetClientServerSid = 86,
    WinCapabilityPrivateNetworkClientServerSid = 87,
    WinCapabilityPicturesLibrarySid = 88,
    WinCapabilityVideosLibrarySid = 89,
    WinCapabilityMusicLibrarySid = 90,
    WinCapabilityDocumentsLibrarySid = 91,
    WinCapabilitySharedUserCertificatesSid = 92,
    WinCapabilityEnterpriseAuthenticationSid = 93,
    WinCapabilityRemovableStorageSid = 94,
    WinBuiltinRDSRemoteAccessServersSid = 95,
    WinBuiltinRDSEndpointServersSid = 96,
    WinBuiltinRDSManagementServersSid = 97,
    WinUserModeDriversSid = 98,
    WinBuiltinHyperVAdminsSid = 99,
    WinAccountCloneableControllersSid = 100,
    WinBuiltinAccessControlAssistanceOperatorsSid = 101,
    WinBuiltinRemoteManagementUsersSid = 102,
    WinAuthenticationAuthorityAssertedSid = 103,
    WinAuthenticationServiceAssertedSid = 104,
    WinLocalAccountSid = 105,
    WinLocalAccountAndAdministratorSid = 106,
    WinAccountProtectedUsersSid = 107,
    WinCapabilityAppointmentsSid = 108,
    WinCapabilityContactsSid = 109,
    WinAccountDefaultSystemManagedSid = 110,
    WinBuiltinDefaultSystemManagedGroupSid = 111,
    WinBuiltinStorageReplicaAdminsSid = 112,
    WinAccountKeyAdminsSid = 113,
    WinAccountEnterpriseKeyAdminsSid = 114,
    WinAuthenticationKeyTrustSid = 115,
    WinAuthenticationKeyPropertyMFASid = 116,
    WinAuthenticationKeyPropertyAttestationSid = 117,
    WinAuthenticationFreshKeyAuthSid = 118,
    WinBuiltinDeviceOwnersSid = 119,
};
pub const struct__ACL = extern struct {
    AclRevision: BYTE,
    Sbz1: BYTE,
    AclSize: WORD,
    AceCount: WORD,
    Sbz2: WORD,
};
pub const ACL = struct__ACL;
pub const PACL = [*c]ACL;
pub const struct__ACE_HEADER = extern struct {
    AceType: BYTE,
    AceFlags: BYTE,
    AceSize: WORD,
};
pub const ACE_HEADER = struct__ACE_HEADER;
pub const PACE_HEADER = [*c]ACE_HEADER;
pub const struct__ACCESS_ALLOWED_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    SidStart: DWORD,
};
pub const ACCESS_ALLOWED_ACE = struct__ACCESS_ALLOWED_ACE;
pub const PACCESS_ALLOWED_ACE = [*c]ACCESS_ALLOWED_ACE;
pub const struct__ACCESS_DENIED_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    SidStart: DWORD,
};
pub const ACCESS_DENIED_ACE = struct__ACCESS_DENIED_ACE;
pub const PACCESS_DENIED_ACE = [*c]ACCESS_DENIED_ACE;
pub const struct__SYSTEM_AUDIT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    SidStart: DWORD,
};
pub const SYSTEM_AUDIT_ACE = struct__SYSTEM_AUDIT_ACE;
pub const PSYSTEM_AUDIT_ACE = [*c]SYSTEM_AUDIT_ACE;
pub const struct__SYSTEM_ALARM_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    SidStart: DWORD,
};
pub const SYSTEM_ALARM_ACE = struct__SYSTEM_ALARM_ACE;
pub const PSYSTEM_ALARM_ACE = [*c]SYSTEM_ALARM_ACE;
pub const struct__SYSTEM_RESOURCE_ATTRIBUTE_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    SidStart: DWORD,
};
pub const SYSTEM_RESOURCE_ATTRIBUTE_ACE = struct__SYSTEM_RESOURCE_ATTRIBUTE_ACE;
pub const PSYSTEM_RESOURCE_ATTRIBUTE_ACE = [*c]struct__SYSTEM_RESOURCE_ATTRIBUTE_ACE;
pub const struct__SYSTEM_SCOPED_POLICY_ID_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    SidStart: DWORD,
};
pub const SYSTEM_SCOPED_POLICY_ID_ACE = struct__SYSTEM_SCOPED_POLICY_ID_ACE;
pub const PSYSTEM_SCOPED_POLICY_ID_ACE = [*c]struct__SYSTEM_SCOPED_POLICY_ID_ACE;
pub const struct__SYSTEM_MANDATORY_LABEL_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    SidStart: DWORD,
};
pub const SYSTEM_MANDATORY_LABEL_ACE = struct__SYSTEM_MANDATORY_LABEL_ACE;
pub const PSYSTEM_MANDATORY_LABEL_ACE = [*c]struct__SYSTEM_MANDATORY_LABEL_ACE;
pub const struct__SYSTEM_PROCESS_TRUST_LABEL_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    SidStart: DWORD,
};
pub const SYSTEM_PROCESS_TRUST_LABEL_ACE = struct__SYSTEM_PROCESS_TRUST_LABEL_ACE;
pub const PSYSTEM_PROCESS_TRUST_LABEL_ACE = [*c]struct__SYSTEM_PROCESS_TRUST_LABEL_ACE;
pub const struct__SYSTEM_ACCESS_FILTER_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    SidStart: DWORD,
};
pub const SYSTEM_ACCESS_FILTER_ACE = struct__SYSTEM_ACCESS_FILTER_ACE;
pub const PSYSTEM_ACCESS_FILTER_ACE = [*c]struct__SYSTEM_ACCESS_FILTER_ACE;
pub const struct__ACCESS_ALLOWED_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    Flags: DWORD,
    ObjectType: GUID,
    InheritedObjectType: GUID,
    SidStart: DWORD,
};
pub const ACCESS_ALLOWED_OBJECT_ACE = struct__ACCESS_ALLOWED_OBJECT_ACE;
pub const PACCESS_ALLOWED_OBJECT_ACE = [*c]struct__ACCESS_ALLOWED_OBJECT_ACE;
pub const struct__ACCESS_DENIED_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    Flags: DWORD,
    ObjectType: GUID,
    InheritedObjectType: GUID,
    SidStart: DWORD,
};
pub const ACCESS_DENIED_OBJECT_ACE = struct__ACCESS_DENIED_OBJECT_ACE;
pub const PACCESS_DENIED_OBJECT_ACE = [*c]struct__ACCESS_DENIED_OBJECT_ACE;
pub const struct__SYSTEM_AUDIT_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    Flags: DWORD,
    ObjectType: GUID,
    InheritedObjectType: GUID,
    SidStart: DWORD,
};
pub const SYSTEM_AUDIT_OBJECT_ACE = struct__SYSTEM_AUDIT_OBJECT_ACE;
pub const PSYSTEM_AUDIT_OBJECT_ACE = [*c]struct__SYSTEM_AUDIT_OBJECT_ACE;
pub const struct__SYSTEM_ALARM_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    Flags: DWORD,
    ObjectType: GUID,
    InheritedObjectType: GUID,
    SidStart: DWORD,
};
pub const SYSTEM_ALARM_OBJECT_ACE = struct__SYSTEM_ALARM_OBJECT_ACE;
pub const PSYSTEM_ALARM_OBJECT_ACE = [*c]struct__SYSTEM_ALARM_OBJECT_ACE;
pub const struct__ACCESS_ALLOWED_CALLBACK_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    SidStart: DWORD,
};
pub const ACCESS_ALLOWED_CALLBACK_ACE = struct__ACCESS_ALLOWED_CALLBACK_ACE;
pub const PACCESS_ALLOWED_CALLBACK_ACE = [*c]struct__ACCESS_ALLOWED_CALLBACK_ACE;
pub const struct__ACCESS_DENIED_CALLBACK_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    SidStart: DWORD,
};
pub const ACCESS_DENIED_CALLBACK_ACE = struct__ACCESS_DENIED_CALLBACK_ACE;
pub const PACCESS_DENIED_CALLBACK_ACE = [*c]struct__ACCESS_DENIED_CALLBACK_ACE;
pub const struct__SYSTEM_AUDIT_CALLBACK_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    SidStart: DWORD,
};
pub const SYSTEM_AUDIT_CALLBACK_ACE = struct__SYSTEM_AUDIT_CALLBACK_ACE;
pub const PSYSTEM_AUDIT_CALLBACK_ACE = [*c]struct__SYSTEM_AUDIT_CALLBACK_ACE;
pub const struct__SYSTEM_ALARM_CALLBACK_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    SidStart: DWORD,
};
pub const SYSTEM_ALARM_CALLBACK_ACE = struct__SYSTEM_ALARM_CALLBACK_ACE;
pub const PSYSTEM_ALARM_CALLBACK_ACE = [*c]struct__SYSTEM_ALARM_CALLBACK_ACE;
pub const struct__ACCESS_ALLOWED_CALLBACK_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    Flags: DWORD,
    ObjectType: GUID,
    InheritedObjectType: GUID,
    SidStart: DWORD,
};
pub const ACCESS_ALLOWED_CALLBACK_OBJECT_ACE = struct__ACCESS_ALLOWED_CALLBACK_OBJECT_ACE;
pub const PACCESS_ALLOWED_CALLBACK_OBJECT_ACE = [*c]struct__ACCESS_ALLOWED_CALLBACK_OBJECT_ACE;
pub const struct__ACCESS_DENIED_CALLBACK_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    Flags: DWORD,
    ObjectType: GUID,
    InheritedObjectType: GUID,
    SidStart: DWORD,
};
pub const ACCESS_DENIED_CALLBACK_OBJECT_ACE = struct__ACCESS_DENIED_CALLBACK_OBJECT_ACE;
pub const PACCESS_DENIED_CALLBACK_OBJECT_ACE = [*c]struct__ACCESS_DENIED_CALLBACK_OBJECT_ACE;
pub const struct__SYSTEM_AUDIT_CALLBACK_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    Flags: DWORD,
    ObjectType: GUID,
    InheritedObjectType: GUID,
    SidStart: DWORD,
};
pub const SYSTEM_AUDIT_CALLBACK_OBJECT_ACE = struct__SYSTEM_AUDIT_CALLBACK_OBJECT_ACE;
pub const PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE = [*c]struct__SYSTEM_AUDIT_CALLBACK_OBJECT_ACE;
pub const struct__SYSTEM_ALARM_CALLBACK_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: ACCESS_MASK,
    Flags: DWORD,
    ObjectType: GUID,
    InheritedObjectType: GUID,
    SidStart: DWORD,
};
pub const SYSTEM_ALARM_CALLBACK_OBJECT_ACE = struct__SYSTEM_ALARM_CALLBACK_OBJECT_ACE;
pub const PSYSTEM_ALARM_CALLBACK_OBJECT_ACE = [*c]struct__SYSTEM_ALARM_CALLBACK_OBJECT_ACE;
pub const AclRevisionInformation = enum__ACL_INFORMATION_CLASS.AclRevisionInformation;
pub const AclSizeInformation = enum__ACL_INFORMATION_CLASS.AclSizeInformation;
pub const enum__ACL_INFORMATION_CLASS = extern enum {
    AclRevisionInformation = 1,
    AclSizeInformation = 2,
};
pub const ACL_INFORMATION_CLASS = enum__ACL_INFORMATION_CLASS;
pub const struct__ACL_REVISION_INFORMATION = extern struct {
    AclRevision: DWORD,
};
pub const ACL_REVISION_INFORMATION = struct__ACL_REVISION_INFORMATION;
pub const PACL_REVISION_INFORMATION = [*c]ACL_REVISION_INFORMATION;
pub const struct__ACL_SIZE_INFORMATION = extern struct {
    AceCount: DWORD,
    AclBytesInUse: DWORD,
    AclBytesFree: DWORD,
};
pub const ACL_SIZE_INFORMATION = struct__ACL_SIZE_INFORMATION;
pub const PACL_SIZE_INFORMATION = [*c]ACL_SIZE_INFORMATION;
pub const SECURITY_DESCRIPTOR_CONTROL = WORD;
pub const PSECURITY_DESCRIPTOR_CONTROL = [*c]WORD;
pub const struct__SECURITY_DESCRIPTOR_RELATIVE = extern struct {
    Revision: BYTE,
    Sbz1: BYTE,
    Control: SECURITY_DESCRIPTOR_CONTROL,
    Owner: DWORD,
    Group: DWORD,
    Sacl: DWORD,
    Dacl: DWORD,
};
pub const SECURITY_DESCRIPTOR_RELATIVE = struct__SECURITY_DESCRIPTOR_RELATIVE;
pub const PISECURITY_DESCRIPTOR_RELATIVE = [*c]struct__SECURITY_DESCRIPTOR_RELATIVE;
pub const struct__SECURITY_DESCRIPTOR = extern struct {
    Revision: BYTE,
    Sbz1: BYTE,
    Control: SECURITY_DESCRIPTOR_CONTROL,
    Owner: PSID,
    Group: PSID,
    Sacl: PACL,
    Dacl: PACL,
};
pub const SECURITY_DESCRIPTOR = struct__SECURITY_DESCRIPTOR;
pub const PISECURITY_DESCRIPTOR = [*c]struct__SECURITY_DESCRIPTOR;
pub const struct__SECURITY_OBJECT_AI_PARAMS = extern struct {
    Size: DWORD,
    ConstraintMask: DWORD,
};
pub const SECURITY_OBJECT_AI_PARAMS = struct__SECURITY_OBJECT_AI_PARAMS;
pub const PSECURITY_OBJECT_AI_PARAMS = [*c]struct__SECURITY_OBJECT_AI_PARAMS;
pub const struct__OBJECT_TYPE_LIST = extern struct {
    Level: WORD,
    Sbz: WORD,
    ObjectType: [*c]GUID,
};
pub const OBJECT_TYPE_LIST = struct__OBJECT_TYPE_LIST;
pub const POBJECT_TYPE_LIST = [*c]struct__OBJECT_TYPE_LIST;
pub const AuditEventObjectAccess = enum__AUDIT_EVENT_TYPE.AuditEventObjectAccess;
pub const AuditEventDirectoryServiceAccess = enum__AUDIT_EVENT_TYPE.AuditEventDirectoryServiceAccess;
pub const enum__AUDIT_EVENT_TYPE = extern enum {
    AuditEventObjectAccess,
    AuditEventDirectoryServiceAccess,
};
pub const AUDIT_EVENT_TYPE = enum__AUDIT_EVENT_TYPE;
pub const PAUDIT_EVENT_TYPE = [*c]enum__AUDIT_EVENT_TYPE;
pub const struct__PRIVILEGE_SET = extern struct {
    PrivilegeCount: DWORD,
    Control: DWORD,
    Privilege: [1]LUID_AND_ATTRIBUTES,
};
pub const PRIVILEGE_SET = struct__PRIVILEGE_SET;
pub const PPRIVILEGE_SET = [*c]struct__PRIVILEGE_SET;
pub const AccessReasonNone = enum__ACCESS_REASON_TYPE.AccessReasonNone;
pub const AccessReasonAllowedAce = enum__ACCESS_REASON_TYPE.AccessReasonAllowedAce;
pub const AccessReasonDeniedAce = enum__ACCESS_REASON_TYPE.AccessReasonDeniedAce;
pub const AccessReasonAllowedParentAce = enum__ACCESS_REASON_TYPE.AccessReasonAllowedParentAce;
pub const AccessReasonDeniedParentAce = enum__ACCESS_REASON_TYPE.AccessReasonDeniedParentAce;
pub const AccessReasonNotGrantedByCape = enum__ACCESS_REASON_TYPE.AccessReasonNotGrantedByCape;
pub const AccessReasonNotGrantedByParentCape = enum__ACCESS_REASON_TYPE.AccessReasonNotGrantedByParentCape;
pub const AccessReasonNotGrantedToAppContainer = enum__ACCESS_REASON_TYPE.AccessReasonNotGrantedToAppContainer;
pub const AccessReasonMissingPrivilege = enum__ACCESS_REASON_TYPE.AccessReasonMissingPrivilege;
pub const AccessReasonFromPrivilege = enum__ACCESS_REASON_TYPE.AccessReasonFromPrivilege;
pub const AccessReasonIntegrityLevel = enum__ACCESS_REASON_TYPE.AccessReasonIntegrityLevel;
pub const AccessReasonOwnership = enum__ACCESS_REASON_TYPE.AccessReasonOwnership;
pub const AccessReasonNullDacl = enum__ACCESS_REASON_TYPE.AccessReasonNullDacl;
pub const AccessReasonEmptyDacl = enum__ACCESS_REASON_TYPE.AccessReasonEmptyDacl;
pub const AccessReasonNoSD = enum__ACCESS_REASON_TYPE.AccessReasonNoSD;
pub const AccessReasonNoGrant = enum__ACCESS_REASON_TYPE.AccessReasonNoGrant;
pub const AccessReasonTrustLabel = enum__ACCESS_REASON_TYPE.AccessReasonTrustLabel;
pub const AccessReasonFilterAce = enum__ACCESS_REASON_TYPE.AccessReasonFilterAce;
pub const enum__ACCESS_REASON_TYPE = extern enum {
    AccessReasonNone = 0,
    AccessReasonAllowedAce = 65536,
    AccessReasonDeniedAce = 131072,
    AccessReasonAllowedParentAce = 196608,
    AccessReasonDeniedParentAce = 262144,
    AccessReasonNotGrantedByCape = 327680,
    AccessReasonNotGrantedByParentCape = 393216,
    AccessReasonNotGrantedToAppContainer = 458752,
    AccessReasonMissingPrivilege = 1048576,
    AccessReasonFromPrivilege = 2097152,
    AccessReasonIntegrityLevel = 3145728,
    AccessReasonOwnership = 4194304,
    AccessReasonNullDacl = 5242880,
    AccessReasonEmptyDacl = 6291456,
    AccessReasonNoSD = 7340032,
    AccessReasonNoGrant = 8388608,
    AccessReasonTrustLabel = 9437184,
    AccessReasonFilterAce = 10485760,
};
pub const ACCESS_REASON_TYPE = enum__ACCESS_REASON_TYPE;
pub const ACCESS_REASON = DWORD;
pub const struct__ACCESS_REASONS = extern struct {
    Data: [32]ACCESS_REASON,
};
pub const ACCESS_REASONS = struct__ACCESS_REASONS;
pub const PACCESS_REASONS = [*c]struct__ACCESS_REASONS;
pub const struct__SE_SECURITY_DESCRIPTOR = extern struct {
    Size: DWORD,
    Flags: DWORD,
    SecurityDescriptor: PSECURITY_DESCRIPTOR,
};
pub const SE_SECURITY_DESCRIPTOR = struct__SE_SECURITY_DESCRIPTOR;
pub const PSE_SECURITY_DESCRIPTOR = [*c]struct__SE_SECURITY_DESCRIPTOR;
pub const struct__SE_ACCESS_REQUEST = extern struct {
    Size: DWORD,
    SeSecurityDescriptor: PSE_SECURITY_DESCRIPTOR,
    DesiredAccess: ACCESS_MASK,
    PreviouslyGrantedAccess: ACCESS_MASK,
    PrincipalSelfSid: PSID,
    GenericMapping: PGENERIC_MAPPING,
    ObjectTypeListCount: DWORD,
    ObjectTypeList: POBJECT_TYPE_LIST,
};
pub const SE_ACCESS_REQUEST = struct__SE_ACCESS_REQUEST;
pub const PSE_ACCESS_REQUEST = [*c]struct__SE_ACCESS_REQUEST;
pub const struct__SE_ACCESS_REPLY = extern struct {
    Size: DWORD,
    ResultListCount: DWORD,
    GrantedAccess: PACCESS_MASK,
    AccessStatus: PDWORD,
    AccessReason: PACCESS_REASONS,
    Privileges: [*c]PPRIVILEGE_SET,
};
pub const SE_ACCESS_REPLY = struct__SE_ACCESS_REPLY;
pub const PSE_ACCESS_REPLY = [*c]struct__SE_ACCESS_REPLY;
pub const SecurityAnonymous = enum__SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous;
pub const SecurityIdentification = enum__SECURITY_IMPERSONATION_LEVEL.SecurityIdentification;
pub const SecurityImpersonation = enum__SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation;
pub const SecurityDelegation = enum__SECURITY_IMPERSONATION_LEVEL.SecurityDelegation;
pub const enum__SECURITY_IMPERSONATION_LEVEL = extern enum {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation,
};
pub const SECURITY_IMPERSONATION_LEVEL = enum__SECURITY_IMPERSONATION_LEVEL;
pub const PSECURITY_IMPERSONATION_LEVEL = [*c]enum__SECURITY_IMPERSONATION_LEVEL;
pub const TokenPrimary = enum__TOKEN_TYPE.TokenPrimary;
pub const TokenImpersonation = enum__TOKEN_TYPE.TokenImpersonation;
pub const enum__TOKEN_TYPE = extern enum {
    TokenPrimary = 1,
    TokenImpersonation = 2,
};
pub const TOKEN_TYPE = enum__TOKEN_TYPE;
pub const PTOKEN_TYPE = [*c]TOKEN_TYPE;
pub const TokenElevationTypeDefault = enum__TOKEN_ELEVATION_TYPE.TokenElevationTypeDefault;
pub const TokenElevationTypeFull = enum__TOKEN_ELEVATION_TYPE.TokenElevationTypeFull;
pub const TokenElevationTypeLimited = enum__TOKEN_ELEVATION_TYPE.TokenElevationTypeLimited;
pub const enum__TOKEN_ELEVATION_TYPE = extern enum {
    TokenElevationTypeDefault = 1,
    TokenElevationTypeFull = 2,
    TokenElevationTypeLimited = 3,
};
pub const TOKEN_ELEVATION_TYPE = enum__TOKEN_ELEVATION_TYPE;
pub const PTOKEN_ELEVATION_TYPE = [*c]enum__TOKEN_ELEVATION_TYPE;
pub const TokenUser = enum__TOKEN_INFORMATION_CLASS.TokenUser;
pub const TokenGroups = enum__TOKEN_INFORMATION_CLASS.TokenGroups;
pub const TokenPrivileges = enum__TOKEN_INFORMATION_CLASS.TokenPrivileges;
pub const TokenOwner = enum__TOKEN_INFORMATION_CLASS.TokenOwner;
pub const TokenPrimaryGroup = enum__TOKEN_INFORMATION_CLASS.TokenPrimaryGroup;
pub const TokenDefaultDacl = enum__TOKEN_INFORMATION_CLASS.TokenDefaultDacl;
pub const TokenSource = enum__TOKEN_INFORMATION_CLASS.TokenSource;
pub const TokenType = enum__TOKEN_INFORMATION_CLASS.TokenType;
pub const TokenImpersonationLevel = enum__TOKEN_INFORMATION_CLASS.TokenImpersonationLevel;
pub const TokenStatistics = enum__TOKEN_INFORMATION_CLASS.TokenStatistics;
pub const TokenRestrictedSids = enum__TOKEN_INFORMATION_CLASS.TokenRestrictedSids;
pub const TokenSessionId = enum__TOKEN_INFORMATION_CLASS.TokenSessionId;
pub const TokenGroupsAndPrivileges = enum__TOKEN_INFORMATION_CLASS.TokenGroupsAndPrivileges;
pub const TokenSessionReference = enum__TOKEN_INFORMATION_CLASS.TokenSessionReference;
pub const TokenSandBoxInert = enum__TOKEN_INFORMATION_CLASS.TokenSandBoxInert;
pub const TokenAuditPolicy = enum__TOKEN_INFORMATION_CLASS.TokenAuditPolicy;
pub const TokenOrigin = enum__TOKEN_INFORMATION_CLASS.TokenOrigin;
pub const TokenElevationType = enum__TOKEN_INFORMATION_CLASS.TokenElevationType;
pub const TokenLinkedToken = enum__TOKEN_INFORMATION_CLASS.TokenLinkedToken;
pub const TokenElevation = enum__TOKEN_INFORMATION_CLASS.TokenElevation;
pub const TokenHasRestrictions = enum__TOKEN_INFORMATION_CLASS.TokenHasRestrictions;
pub const TokenAccessInformation = enum__TOKEN_INFORMATION_CLASS.TokenAccessInformation;
pub const TokenVirtualizationAllowed = enum__TOKEN_INFORMATION_CLASS.TokenVirtualizationAllowed;
pub const TokenVirtualizationEnabled = enum__TOKEN_INFORMATION_CLASS.TokenVirtualizationEnabled;
pub const TokenIntegrityLevel = enum__TOKEN_INFORMATION_CLASS.TokenIntegrityLevel;
pub const TokenUIAccess = enum__TOKEN_INFORMATION_CLASS.TokenUIAccess;
pub const TokenMandatoryPolicy = enum__TOKEN_INFORMATION_CLASS.TokenMandatoryPolicy;
pub const TokenLogonSid = enum__TOKEN_INFORMATION_CLASS.TokenLogonSid;
pub const TokenIsAppContainer = enum__TOKEN_INFORMATION_CLASS.TokenIsAppContainer;
pub const TokenCapabilities = enum__TOKEN_INFORMATION_CLASS.TokenCapabilities;
pub const TokenAppContainerSid = enum__TOKEN_INFORMATION_CLASS.TokenAppContainerSid;
pub const TokenAppContainerNumber = enum__TOKEN_INFORMATION_CLASS.TokenAppContainerNumber;
pub const TokenUserClaimAttributes = enum__TOKEN_INFORMATION_CLASS.TokenUserClaimAttributes;
pub const TokenDeviceClaimAttributes = enum__TOKEN_INFORMATION_CLASS.TokenDeviceClaimAttributes;
pub const TokenRestrictedUserClaimAttributes = enum__TOKEN_INFORMATION_CLASS.TokenRestrictedUserClaimAttributes;
pub const TokenRestrictedDeviceClaimAttributes = enum__TOKEN_INFORMATION_CLASS.TokenRestrictedDeviceClaimAttributes;
pub const TokenDeviceGroups = enum__TOKEN_INFORMATION_CLASS.TokenDeviceGroups;
pub const TokenRestrictedDeviceGroups = enum__TOKEN_INFORMATION_CLASS.TokenRestrictedDeviceGroups;
pub const TokenSecurityAttributes = enum__TOKEN_INFORMATION_CLASS.TokenSecurityAttributes;
pub const TokenIsRestricted = enum__TOKEN_INFORMATION_CLASS.TokenIsRestricted;
pub const TokenProcessTrustLevel = enum__TOKEN_INFORMATION_CLASS.TokenProcessTrustLevel;
pub const TokenPrivateNameSpace = enum__TOKEN_INFORMATION_CLASS.TokenPrivateNameSpace;
pub const TokenSingletonAttributes = enum__TOKEN_INFORMATION_CLASS.TokenSingletonAttributes;
pub const TokenBnoIsolation = enum__TOKEN_INFORMATION_CLASS.TokenBnoIsolation;
pub const TokenChildProcessFlags = enum__TOKEN_INFORMATION_CLASS.TokenChildProcessFlags;
pub const TokenIsLessPrivilegedAppContainer = enum__TOKEN_INFORMATION_CLASS.TokenIsLessPrivilegedAppContainer;
pub const TokenIsSandboxed = enum__TOKEN_INFORMATION_CLASS.TokenIsSandboxed;
pub const TokenOriginatingProcessTrustLevel = enum__TOKEN_INFORMATION_CLASS.TokenOriginatingProcessTrustLevel;
pub const MaxTokenInfoClass = enum__TOKEN_INFORMATION_CLASS.MaxTokenInfoClass;
pub const enum__TOKEN_INFORMATION_CLASS = extern enum {
    TokenUser = 1,
    TokenGroups = 2,
    TokenPrivileges = 3,
    TokenOwner = 4,
    TokenPrimaryGroup = 5,
    TokenDefaultDacl = 6,
    TokenSource = 7,
    TokenType = 8,
    TokenImpersonationLevel = 9,
    TokenStatistics = 10,
    TokenRestrictedSids = 11,
    TokenSessionId = 12,
    TokenGroupsAndPrivileges = 13,
    TokenSessionReference = 14,
    TokenSandBoxInert = 15,
    TokenAuditPolicy = 16,
    TokenOrigin = 17,
    TokenElevationType = 18,
    TokenLinkedToken = 19,
    TokenElevation = 20,
    TokenHasRestrictions = 21,
    TokenAccessInformation = 22,
    TokenVirtualizationAllowed = 23,
    TokenVirtualizationEnabled = 24,
    TokenIntegrityLevel = 25,
    TokenUIAccess = 26,
    TokenMandatoryPolicy = 27,
    TokenLogonSid = 28,
    TokenIsAppContainer = 29,
    TokenCapabilities = 30,
    TokenAppContainerSid = 31,
    TokenAppContainerNumber = 32,
    TokenUserClaimAttributes = 33,
    TokenDeviceClaimAttributes = 34,
    TokenRestrictedUserClaimAttributes = 35,
    TokenRestrictedDeviceClaimAttributes = 36,
    TokenDeviceGroups = 37,
    TokenRestrictedDeviceGroups = 38,
    TokenSecurityAttributes = 39,
    TokenIsRestricted = 40,
    TokenProcessTrustLevel = 41,
    TokenPrivateNameSpace = 42,
    TokenSingletonAttributes = 43,
    TokenBnoIsolation = 44,
    TokenChildProcessFlags = 45,
    TokenIsLessPrivilegedAppContainer = 46,
    TokenIsSandboxed = 47,
    TokenOriginatingProcessTrustLevel = 48,
    MaxTokenInfoClass = 49,
};
pub const TOKEN_INFORMATION_CLASS = enum__TOKEN_INFORMATION_CLASS;
pub const PTOKEN_INFORMATION_CLASS = [*c]enum__TOKEN_INFORMATION_CLASS;
pub const struct__TOKEN_USER = extern struct {
    User: SID_AND_ATTRIBUTES,
};
pub const TOKEN_USER = struct__TOKEN_USER;
pub const PTOKEN_USER = [*c]struct__TOKEN_USER;
pub const struct__SE_TOKEN_USER = extern struct {
    @"": extern union {
        TokenUser: TOKEN_USER,
        User: SID_AND_ATTRIBUTES,
    },
    @"": extern union {
        Sid: SID,
        Buffer: [68]BYTE,
    },
};
pub const SE_TOKEN_USER = struct__SE_TOKEN_USER;
pub const PSE_TOKEN_USER = struct__SE_TOKEN_USER;
pub const struct__TOKEN_GROUPS = extern struct {
    GroupCount: DWORD,
    Groups: [1]SID_AND_ATTRIBUTES,
};
pub const TOKEN_GROUPS = struct__TOKEN_GROUPS;
pub const PTOKEN_GROUPS = [*c]struct__TOKEN_GROUPS;
pub const struct__TOKEN_PRIVILEGES = extern struct {
    PrivilegeCount: DWORD,
    Privileges: [1]LUID_AND_ATTRIBUTES,
};
pub const TOKEN_PRIVILEGES = struct__TOKEN_PRIVILEGES;
pub const PTOKEN_PRIVILEGES = [*c]struct__TOKEN_PRIVILEGES;
pub const struct__TOKEN_OWNER = extern struct {
    Owner: PSID,
};
pub const TOKEN_OWNER = struct__TOKEN_OWNER;
pub const PTOKEN_OWNER = [*c]struct__TOKEN_OWNER;
pub const struct__TOKEN_PRIMARY_GROUP = extern struct {
    PrimaryGroup: PSID,
};
pub const TOKEN_PRIMARY_GROUP = struct__TOKEN_PRIMARY_GROUP;
pub const PTOKEN_PRIMARY_GROUP = [*c]struct__TOKEN_PRIMARY_GROUP;
pub const struct__TOKEN_DEFAULT_DACL = extern struct {
    DefaultDacl: PACL,
};
pub const TOKEN_DEFAULT_DACL = struct__TOKEN_DEFAULT_DACL;
pub const PTOKEN_DEFAULT_DACL = [*c]struct__TOKEN_DEFAULT_DACL;
pub const struct__TOKEN_USER_CLAIMS = extern struct {
    UserClaims: PCLAIMS_BLOB,
};
pub const TOKEN_USER_CLAIMS = struct__TOKEN_USER_CLAIMS;
pub const PTOKEN_USER_CLAIMS = [*c]struct__TOKEN_USER_CLAIMS;
pub const struct__TOKEN_DEVICE_CLAIMS = extern struct {
    DeviceClaims: PCLAIMS_BLOB,
};
pub const TOKEN_DEVICE_CLAIMS = struct__TOKEN_DEVICE_CLAIMS;
pub const PTOKEN_DEVICE_CLAIMS = [*c]struct__TOKEN_DEVICE_CLAIMS;
pub const struct__TOKEN_GROUPS_AND_PRIVILEGES = extern struct {
    SidCount: DWORD,
    SidLength: DWORD,
    Sids: PSID_AND_ATTRIBUTES,
    RestrictedSidCount: DWORD,
    RestrictedSidLength: DWORD,
    RestrictedSids: PSID_AND_ATTRIBUTES,
    PrivilegeCount: DWORD,
    PrivilegeLength: DWORD,
    Privileges: PLUID_AND_ATTRIBUTES,
    AuthenticationId: LUID,
};
pub const TOKEN_GROUPS_AND_PRIVILEGES = struct__TOKEN_GROUPS_AND_PRIVILEGES;
pub const PTOKEN_GROUPS_AND_PRIVILEGES = [*c]struct__TOKEN_GROUPS_AND_PRIVILEGES;
pub const struct__TOKEN_LINKED_TOKEN = extern struct {
    LinkedToken: HANDLE,
};
pub const TOKEN_LINKED_TOKEN = struct__TOKEN_LINKED_TOKEN;
pub const PTOKEN_LINKED_TOKEN = [*c]struct__TOKEN_LINKED_TOKEN;
pub const struct__TOKEN_ELEVATION = extern struct {
    TokenIsElevated: DWORD,
};
pub const TOKEN_ELEVATION = struct__TOKEN_ELEVATION;
pub const PTOKEN_ELEVATION = [*c]struct__TOKEN_ELEVATION;
pub const struct__TOKEN_MANDATORY_LABEL = extern struct {
    Label: SID_AND_ATTRIBUTES,
};
pub const TOKEN_MANDATORY_LABEL = struct__TOKEN_MANDATORY_LABEL;
pub const PTOKEN_MANDATORY_LABEL = [*c]struct__TOKEN_MANDATORY_LABEL;
pub const struct__TOKEN_MANDATORY_POLICY = extern struct {
    Policy: DWORD,
};
pub const TOKEN_MANDATORY_POLICY = struct__TOKEN_MANDATORY_POLICY;
pub const PTOKEN_MANDATORY_POLICY = [*c]struct__TOKEN_MANDATORY_POLICY;
pub const PSECURITY_ATTRIBUTES_OPAQUE = PVOID;
pub const struct__TOKEN_ACCESS_INFORMATION = extern struct {
    SidHash: PSID_AND_ATTRIBUTES_HASH,
    RestrictedSidHash: PSID_AND_ATTRIBUTES_HASH,
    Privileges: PTOKEN_PRIVILEGES,
    AuthenticationId: LUID,
    TokenType: TOKEN_TYPE,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    MandatoryPolicy: TOKEN_MANDATORY_POLICY,
    Flags: DWORD,
    AppContainerNumber: DWORD,
    PackageSid: PSID,
    CapabilitiesHash: PSID_AND_ATTRIBUTES_HASH,
    TrustLevelSid: PSID,
    SecurityAttributes: PSECURITY_ATTRIBUTES_OPAQUE,
};
pub const TOKEN_ACCESS_INFORMATION = struct__TOKEN_ACCESS_INFORMATION;
pub const PTOKEN_ACCESS_INFORMATION = [*c]struct__TOKEN_ACCESS_INFORMATION;
pub const struct__TOKEN_AUDIT_POLICY = extern struct {
    PerUserPolicy: [30]BYTE,
};
pub const TOKEN_AUDIT_POLICY = struct__TOKEN_AUDIT_POLICY;
pub const PTOKEN_AUDIT_POLICY = [*c]struct__TOKEN_AUDIT_POLICY;
pub const struct__TOKEN_SOURCE = extern struct {
    SourceName: [8]CHAR,
    SourceIdentifier: LUID,
};
pub const TOKEN_SOURCE = struct__TOKEN_SOURCE;
pub const PTOKEN_SOURCE = [*c]struct__TOKEN_SOURCE;
pub const struct__TOKEN_STATISTICS = extern struct {
    TokenId: LUID,
    AuthenticationId: LUID,
    ExpirationTime: LARGE_INTEGER,
    TokenType: TOKEN_TYPE,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    DynamicCharged: DWORD,
    DynamicAvailable: DWORD,
    GroupCount: DWORD,
    PrivilegeCount: DWORD,
    ModifiedId: LUID,
};
pub const TOKEN_STATISTICS = struct__TOKEN_STATISTICS;
pub const PTOKEN_STATISTICS = [*c]struct__TOKEN_STATISTICS;
pub const struct__TOKEN_CONTROL = extern struct {
    TokenId: LUID,
    AuthenticationId: LUID,
    ModifiedId: LUID,
    TokenSource: TOKEN_SOURCE,
};
pub const TOKEN_CONTROL = struct__TOKEN_CONTROL;
pub const PTOKEN_CONTROL = [*c]struct__TOKEN_CONTROL;
pub const struct__TOKEN_ORIGIN = extern struct {
    OriginatingLogonSession: LUID,
};
pub const TOKEN_ORIGIN = struct__TOKEN_ORIGIN;
pub const PTOKEN_ORIGIN = [*c]struct__TOKEN_ORIGIN;
pub const MandatoryLevelUntrusted = enum__MANDATORY_LEVEL.MandatoryLevelUntrusted;
pub const MandatoryLevelLow = enum__MANDATORY_LEVEL.MandatoryLevelLow;
pub const MandatoryLevelMedium = enum__MANDATORY_LEVEL.MandatoryLevelMedium;
pub const MandatoryLevelHigh = enum__MANDATORY_LEVEL.MandatoryLevelHigh;
pub const MandatoryLevelSystem = enum__MANDATORY_LEVEL.MandatoryLevelSystem;
pub const MandatoryLevelSecureProcess = enum__MANDATORY_LEVEL.MandatoryLevelSecureProcess;
pub const MandatoryLevelCount = enum__MANDATORY_LEVEL.MandatoryLevelCount;
pub const enum__MANDATORY_LEVEL = extern enum {
    MandatoryLevelUntrusted = 0,
    MandatoryLevelLow = 1,
    MandatoryLevelMedium = 2,
    MandatoryLevelHigh = 3,
    MandatoryLevelSystem = 4,
    MandatoryLevelSecureProcess = 5,
    MandatoryLevelCount = 6,
};
pub const MANDATORY_LEVEL = enum__MANDATORY_LEVEL;
pub const PMANDATORY_LEVEL = [*c]enum__MANDATORY_LEVEL;
pub const struct__TOKEN_APPCONTAINER_INFORMATION = extern struct {
    TokenAppContainer: PSID,
};
pub const TOKEN_APPCONTAINER_INFORMATION = struct__TOKEN_APPCONTAINER_INFORMATION;
pub const PTOKEN_APPCONTAINER_INFORMATION = [*c]struct__TOKEN_APPCONTAINER_INFORMATION;
pub const struct__TOKEN_SID_INFORMATION = extern struct {
    Sid: PSID,
};
pub const TOKEN_SID_INFORMATION = struct__TOKEN_SID_INFORMATION;
pub const PTOKEN_SID_INFORMATION = [*c]struct__TOKEN_SID_INFORMATION;
pub const struct__TOKEN_BNO_ISOLATION_INFORMATION = extern struct {
    IsolationPrefix: PWSTR,
    IsolationEnabled: BOOLEAN,
};
pub const TOKEN_BNO_ISOLATION_INFORMATION = struct__TOKEN_BNO_ISOLATION_INFORMATION;
pub const PTOKEN_BNO_ISOLATION_INFORMATION = [*c]struct__TOKEN_BNO_ISOLATION_INFORMATION;
pub const struct__CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = extern struct {
    Version: DWORD64,
    Name: PWSTR,
};
pub const CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = struct__CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
pub const PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = [*c]struct__CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
pub const struct__CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = extern struct {
    pValue: PVOID,
    ValueLength: DWORD,
};
pub const CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = struct__CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
pub const PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = [*c]struct__CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
pub const struct__CLAIM_SECURITY_ATTRIBUTE_V1 = extern struct {
    Name: PWSTR,
    ValueType: WORD,
    Reserved: WORD,
    Flags: DWORD,
    ValueCount: DWORD,
    Values: extern union {
        pInt64: PLONG64,
        pUint64: PDWORD64,
        ppString: [*c]PWSTR,
        pFqbn: PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE,
        pOctetString: PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
    },
};
pub const CLAIM_SECURITY_ATTRIBUTE_V1 = struct__CLAIM_SECURITY_ATTRIBUTE_V1;
pub const PCLAIM_SECURITY_ATTRIBUTE_V1 = [*c]struct__CLAIM_SECURITY_ATTRIBUTE_V1;
pub const struct__CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = extern struct {
    Name: DWORD,
    ValueType: WORD,
    Reserved: WORD,
    Flags: DWORD,
    ValueCount: DWORD,
    Values: extern union {
        pInt64: [1]DWORD,
        pUint64: [1]DWORD,
        ppString: [1]DWORD,
        pFqbn: [1]DWORD,
        pOctetString: [1]DWORD,
    },
};
pub const CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = struct__CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
pub const PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = [*c]struct__CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
pub const struct__CLAIM_SECURITY_ATTRIBUTES_INFORMATION = extern struct {
    Version: WORD,
    Reserved: WORD,
    AttributeCount: DWORD,
    Attribute: extern union {
        pAttributeV1: PCLAIM_SECURITY_ATTRIBUTE_V1,
    },
};
pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION = struct__CLAIM_SECURITY_ATTRIBUTES_INFORMATION;
pub const PCLAIM_SECURITY_ATTRIBUTES_INFORMATION = [*c]struct__CLAIM_SECURITY_ATTRIBUTES_INFORMATION;
pub const SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN;
pub const PSECURITY_CONTEXT_TRACKING_MODE = [*c]BOOLEAN;
pub const struct__SECURITY_QUALITY_OF_SERVICE = extern struct {
    Length: DWORD,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    ContextTrackingMode: SECURITY_CONTEXT_TRACKING_MODE,
    EffectiveOnly: BOOLEAN,
};
pub const SECURITY_QUALITY_OF_SERVICE = struct__SECURITY_QUALITY_OF_SERVICE;
pub const PSECURITY_QUALITY_OF_SERVICE = [*c]struct__SECURITY_QUALITY_OF_SERVICE;
pub const struct__SE_IMPERSONATION_STATE = extern struct {
    Token: PACCESS_TOKEN,
    CopyOnOpen: BOOLEAN,
    EffectiveOnly: BOOLEAN,
    Level: SECURITY_IMPERSONATION_LEVEL,
};
pub const SE_IMPERSONATION_STATE = struct__SE_IMPERSONATION_STATE;
pub const PSE_IMPERSONATION_STATE = [*c]struct__SE_IMPERSONATION_STATE;
pub const SECURITY_INFORMATION = DWORD;
pub const PSECURITY_INFORMATION = [*c]DWORD;
pub const SE_SIGNING_LEVEL = BYTE;
pub const PSE_SIGNING_LEVEL = [*c]BYTE;
pub const SeImageSignatureNone = enum__SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureNone;
pub const SeImageSignatureEmbedded = enum__SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureEmbedded;
pub const SeImageSignatureCache = enum__SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureCache;
pub const SeImageSignatureCatalogCached = enum__SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureCatalogCached;
pub const SeImageSignatureCatalogNotCached = enum__SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureCatalogNotCached;
pub const SeImageSignatureCatalogHint = enum__SE_IMAGE_SIGNATURE_TYPE.SeImageSignatureCatalogHint;
pub const SeImageSignaturePackageCatalog = enum__SE_IMAGE_SIGNATURE_TYPE.SeImageSignaturePackageCatalog;
pub const enum__SE_IMAGE_SIGNATURE_TYPE = extern enum {
    SeImageSignatureNone = 0,
    SeImageSignatureEmbedded = 1,
    SeImageSignatureCache = 2,
    SeImageSignatureCatalogCached = 3,
    SeImageSignatureCatalogNotCached = 4,
    SeImageSignatureCatalogHint = 5,
    SeImageSignaturePackageCatalog = 6,
};
pub const SE_IMAGE_SIGNATURE_TYPE = enum__SE_IMAGE_SIGNATURE_TYPE;
pub const PSE_IMAGE_SIGNATURE_TYPE = [*c]enum__SE_IMAGE_SIGNATURE_TYPE;
pub const SeLearningModeInvalidType = enum__SE_LEARNING_MODE_DATA_TYPE.SeLearningModeInvalidType;
pub const SeLearningModeSettings = enum__SE_LEARNING_MODE_DATA_TYPE.SeLearningModeSettings;
pub const SeLearningModeMax = enum__SE_LEARNING_MODE_DATA_TYPE.SeLearningModeMax;
pub const enum__SE_LEARNING_MODE_DATA_TYPE = extern enum {
    SeLearningModeInvalidType = 0,
    SeLearningModeSettings = 1,
    SeLearningModeMax = 2,
};
pub const SE_LEARNING_MODE_DATA_TYPE = enum__SE_LEARNING_MODE_DATA_TYPE;
pub const struct__SECURITY_CAPABILITIES = extern struct {
    AppContainerSid: PSID,
    Capabilities: PSID_AND_ATTRIBUTES,
    CapabilityCount: DWORD,
    Reserved: DWORD,
};
pub const SECURITY_CAPABILITIES = struct__SECURITY_CAPABILITIES;
pub const PSECURITY_CAPABILITIES = [*c]struct__SECURITY_CAPABILITIES;
pub const LPSECURITY_CAPABILITIES = [*c]struct__SECURITY_CAPABILITIES;
pub const struct__JOB_SET_ARRAY = extern struct {
    JobHandle: HANDLE,
    MemberLevel: DWORD,
    Flags: DWORD,
};
pub const JOB_SET_ARRAY = struct__JOB_SET_ARRAY;
pub const PJOB_SET_ARRAY = [*c]struct__JOB_SET_ARRAY;
pub const struct__EXCEPTION_REGISTRATION_RECORD = extern struct {
    Next: [*c]struct__EXCEPTION_REGISTRATION_RECORD,
    Handler: PEXCEPTION_ROUTINE,
};
pub const EXCEPTION_REGISTRATION_RECORD = struct__EXCEPTION_REGISTRATION_RECORD;
pub const PEXCEPTION_REGISTRATION_RECORD = [*c]EXCEPTION_REGISTRATION_RECORD;
pub const struct__NT_TIB = extern struct {
    ExceptionList: [*c]struct__EXCEPTION_REGISTRATION_RECORD,
    StackBase: PVOID,
    StackLimit: PVOID,
    SubSystemTib: PVOID,
    @"": extern union {
        FiberData: PVOID,
        Version: DWORD,
    },
    ArbitraryUserPointer: PVOID,
    Self: [*c]struct__NT_TIB,
};
pub const NT_TIB = struct__NT_TIB;
pub const PNT_TIB = [*c]NT_TIB;
pub const struct__NT_TIB32 = extern struct {
    ExceptionList: DWORD,
    StackBase: DWORD,
    StackLimit: DWORD,
    SubSystemTib: DWORD,
    @"": extern union {
        FiberData: DWORD,
        Version: DWORD,
    },
    ArbitraryUserPointer: DWORD,
    Self: DWORD,
};
pub const NT_TIB32 = struct__NT_TIB32;
pub const PNT_TIB32 = [*c]struct__NT_TIB32;
pub const struct__NT_TIB64 = extern struct {
    ExceptionList: DWORD64,
    StackBase: DWORD64,
    StackLimit: DWORD64,
    SubSystemTib: DWORD64,
    @"": extern union {
        FiberData: DWORD64,
        Version: DWORD,
    },
    ArbitraryUserPointer: DWORD64,
    Self: DWORD64,
};
pub const NT_TIB64 = struct__NT_TIB64;
pub const PNT_TIB64 = [*c]struct__NT_TIB64;
pub const struct__UMS_CREATE_THREAD_ATTRIBUTES = extern struct {
    UmsVersion: DWORD,
    UmsContext: PVOID,
    UmsCompletionList: PVOID,
};
pub const UMS_CREATE_THREAD_ATTRIBUTES = struct__UMS_CREATE_THREAD_ATTRIBUTES;
pub const PUMS_CREATE_THREAD_ATTRIBUTES = [*c]struct__UMS_CREATE_THREAD_ATTRIBUTES;
pub const struct__WOW64_ARCHITECTURE_INFORMATION = @OpaqueType();
pub const WOW64_ARCHITECTURE_INFORMATION = struct__WOW64_ARCHITECTURE_INFORMATION;
pub const struct__QUOTA_LIMITS = extern struct {
    PagedPoolLimit: SIZE_T,
    NonPagedPoolLimit: SIZE_T,
    MinimumWorkingSetSize: SIZE_T,
    MaximumWorkingSetSize: SIZE_T,
    PagefileLimit: SIZE_T,
    TimeLimit: LARGE_INTEGER,
};
pub const QUOTA_LIMITS = struct__QUOTA_LIMITS;
pub const PQUOTA_LIMITS = [*c]struct__QUOTA_LIMITS;
pub const union__RATE_QUOTA_LIMIT = extern union {
    RateData: DWORD,
    @"": @OpaqueType(),
};
pub const RATE_QUOTA_LIMIT = union__RATE_QUOTA_LIMIT;
pub const PRATE_QUOTA_LIMIT = [*c]union__RATE_QUOTA_LIMIT;
pub const struct__QUOTA_LIMITS_EX = extern struct {
    PagedPoolLimit: SIZE_T,
    NonPagedPoolLimit: SIZE_T,
    MinimumWorkingSetSize: SIZE_T,
    MaximumWorkingSetSize: SIZE_T,
    PagefileLimit: SIZE_T,
    TimeLimit: LARGE_INTEGER,
    WorkingSetLimit: SIZE_T,
    Reserved2: SIZE_T,
    Reserved3: SIZE_T,
    Reserved4: SIZE_T,
    Flags: DWORD,
    CpuRateLimit: RATE_QUOTA_LIMIT,
};
pub const QUOTA_LIMITS_EX = struct__QUOTA_LIMITS_EX;
pub const PQUOTA_LIMITS_EX = [*c]struct__QUOTA_LIMITS_EX;
pub const struct__IO_COUNTERS = extern struct {
    ReadOperationCount: ULONGLONG,
    WriteOperationCount: ULONGLONG,
    OtherOperationCount: ULONGLONG,
    ReadTransferCount: ULONGLONG,
    WriteTransferCount: ULONGLONG,
    OtherTransferCount: ULONGLONG,
};
pub const IO_COUNTERS = struct__IO_COUNTERS;
pub const PIO_COUNTERS = [*c]IO_COUNTERS;
pub const PMCCounter = enum__HARDWARE_COUNTER_TYPE.PMCCounter;
pub const MaxHardwareCounterType = enum__HARDWARE_COUNTER_TYPE.MaxHardwareCounterType;
pub const enum__HARDWARE_COUNTER_TYPE = extern enum {
    PMCCounter,
    MaxHardwareCounterType,
};
pub const HARDWARE_COUNTER_TYPE = enum__HARDWARE_COUNTER_TYPE;
pub const PHARDWARE_COUNTER_TYPE = [*c]enum__HARDWARE_COUNTER_TYPE;
pub const ProcessDEPPolicy = enum__PROCESS_MITIGATION_POLICY.ProcessDEPPolicy;
pub const ProcessASLRPolicy = enum__PROCESS_MITIGATION_POLICY.ProcessASLRPolicy;
pub const ProcessDynamicCodePolicy = enum__PROCESS_MITIGATION_POLICY.ProcessDynamicCodePolicy;
pub const ProcessStrictHandleCheckPolicy = enum__PROCESS_MITIGATION_POLICY.ProcessStrictHandleCheckPolicy;
pub const ProcessSystemCallDisablePolicy = enum__PROCESS_MITIGATION_POLICY.ProcessSystemCallDisablePolicy;
pub const ProcessMitigationOptionsMask = enum__PROCESS_MITIGATION_POLICY.ProcessMitigationOptionsMask;
pub const ProcessExtensionPointDisablePolicy = enum__PROCESS_MITIGATION_POLICY.ProcessExtensionPointDisablePolicy;
pub const ProcessControlFlowGuardPolicy = enum__PROCESS_MITIGATION_POLICY.ProcessControlFlowGuardPolicy;
pub const ProcessSignaturePolicy = enum__PROCESS_MITIGATION_POLICY.ProcessSignaturePolicy;
pub const ProcessFontDisablePolicy = enum__PROCESS_MITIGATION_POLICY.ProcessFontDisablePolicy;
pub const ProcessImageLoadPolicy = enum__PROCESS_MITIGATION_POLICY.ProcessImageLoadPolicy;
pub const ProcessSystemCallFilterPolicy = enum__PROCESS_MITIGATION_POLICY.ProcessSystemCallFilterPolicy;
pub const ProcessPayloadRestrictionPolicy = enum__PROCESS_MITIGATION_POLICY.ProcessPayloadRestrictionPolicy;
pub const ProcessChildProcessPolicy = enum__PROCESS_MITIGATION_POLICY.ProcessChildProcessPolicy;
pub const ProcessSideChannelIsolationPolicy = enum__PROCESS_MITIGATION_POLICY.ProcessSideChannelIsolationPolicy;
pub const MaxProcessMitigationPolicy = enum__PROCESS_MITIGATION_POLICY.MaxProcessMitigationPolicy;
pub const enum__PROCESS_MITIGATION_POLICY = extern enum {
    ProcessDEPPolicy,
    ProcessASLRPolicy,
    ProcessDynamicCodePolicy,
    ProcessStrictHandleCheckPolicy,
    ProcessSystemCallDisablePolicy,
    ProcessMitigationOptionsMask,
    ProcessExtensionPointDisablePolicy,
    ProcessControlFlowGuardPolicy,
    ProcessSignaturePolicy,
    ProcessFontDisablePolicy,
    ProcessImageLoadPolicy,
    ProcessSystemCallFilterPolicy,
    ProcessPayloadRestrictionPolicy,
    ProcessChildProcessPolicy,
    ProcessSideChannelIsolationPolicy,
    MaxProcessMitigationPolicy,
};
pub const PROCESS_MITIGATION_POLICY = enum__PROCESS_MITIGATION_POLICY;
pub const PPROCESS_MITIGATION_POLICY = [*c]enum__PROCESS_MITIGATION_POLICY;
pub const struct__PROCESS_MITIGATION_ASLR_POLICY = extern struct {
    @"": extern union {
        Flags: DWORD,
        @"": @OpaqueType(),
    },
};
pub const PROCESS_MITIGATION_ASLR_POLICY = struct__PROCESS_MITIGATION_ASLR_POLICY;
pub const PPROCESS_MITIGATION_ASLR_POLICY = [*c]struct__PROCESS_MITIGATION_ASLR_POLICY;
pub const struct__PROCESS_MITIGATION_DEP_POLICY = extern struct {
    @"": extern union {
        Flags: DWORD,
        @"": @OpaqueType(),
    },
    Permanent: BOOLEAN,
};
pub const PROCESS_MITIGATION_DEP_POLICY = struct__PROCESS_MITIGATION_DEP_POLICY;
pub const PPROCESS_MITIGATION_DEP_POLICY = [*c]struct__PROCESS_MITIGATION_DEP_POLICY;
pub const struct__PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY = extern struct {
    @"": extern union {
        Flags: DWORD,
        @"": @OpaqueType(),
    },
};
pub const PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY = struct__PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
pub const PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY = [*c]struct__PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
pub const struct__PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY = extern struct {
    @"": extern union {
        Flags: DWORD,
        @"": @OpaqueType(),
    },
};
pub const PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY = struct__PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
pub const PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY = [*c]struct__PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
pub const struct__PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY = extern struct {
    @"": extern union {
        Flags: DWORD,
        @"": @OpaqueType(),
    },
};
pub const PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY = struct__PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
pub const PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY = [*c]struct__PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
pub const struct__PROCESS_MITIGATION_DYNAMIC_CODE_POLICY = extern struct {
    @"": extern union {
        Flags: DWORD,
        @"": @OpaqueType(),
    },
};
pub const PROCESS_MITIGATION_DYNAMIC_CODE_POLICY = struct__PROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
pub const PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY = [*c]struct__PROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
pub const struct__PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY = extern struct {
    @"": extern union {
        Flags: DWORD,
        @"": @OpaqueType(),
    },
};
pub const PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY = struct__PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
pub const PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY = [*c]struct__PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
pub const struct__PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = extern struct {
    @"": extern union {
        Flags: DWORD,
        @"": @OpaqueType(),
    },
};
pub const PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = struct__PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
pub const PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = [*c]struct__PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
pub const struct__PROCESS_MITIGATION_FONT_DISABLE_POLICY = extern struct {
    @"": extern union {
        Flags: DWORD,
        @"": @OpaqueType(),
    },
};
pub const PROCESS_MITIGATION_FONT_DISABLE_POLICY = struct__PROCESS_MITIGATION_FONT_DISABLE_POLICY;
pub const PPROCESS_MITIGATION_FONT_DISABLE_POLICY = [*c]struct__PROCESS_MITIGATION_FONT_DISABLE_POLICY;
pub const struct__PROCESS_MITIGATION_IMAGE_LOAD_POLICY = extern struct {
    @"": extern union {
        Flags: DWORD,
        @"": @OpaqueType(),
    },
};
pub const PROCESS_MITIGATION_IMAGE_LOAD_POLICY = struct__PROCESS_MITIGATION_IMAGE_LOAD_POLICY;
pub const PPROCESS_MITIGATION_IMAGE_LOAD_POLICY = [*c]struct__PROCESS_MITIGATION_IMAGE_LOAD_POLICY;
pub const struct__PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY = extern struct {
    @"": extern union {
        Flags: DWORD,
        @"": @OpaqueType(),
    },
};
pub const PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY = struct__PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;
pub const PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY = [*c]struct__PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;
pub const struct__PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY = extern struct {
    @"": extern union {
        Flags: DWORD,
        @"": @OpaqueType(),
    },
};
pub const PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY = struct__PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
pub const PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY = [*c]struct__PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
pub const struct__PROCESS_MITIGATION_CHILD_PROCESS_POLICY = extern struct {
    @"": extern union {
        Flags: DWORD,
        @"": @OpaqueType(),
    },
};
pub const PROCESS_MITIGATION_CHILD_PROCESS_POLICY = struct__PROCESS_MITIGATION_CHILD_PROCESS_POLICY;
pub const PPROCESS_MITIGATION_CHILD_PROCESS_POLICY = [*c]struct__PROCESS_MITIGATION_CHILD_PROCESS_POLICY;
pub const struct__PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY = extern struct {
    @"": extern union {
        Flags: DWORD,
        @"": @OpaqueType(),
    },
};
pub const PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY = struct__PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY;
pub const PPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY = [*c]struct__PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY;
pub const struct__JOBOBJECT_BASIC_ACCOUNTING_INFORMATION = extern struct {
    TotalUserTime: LARGE_INTEGER,
    TotalKernelTime: LARGE_INTEGER,
    ThisPeriodTotalUserTime: LARGE_INTEGER,
    ThisPeriodTotalKernelTime: LARGE_INTEGER,
    TotalPageFaultCount: DWORD,
    TotalProcesses: DWORD,
    ActiveProcesses: DWORD,
    TotalTerminatedProcesses: DWORD,
};
pub const JOBOBJECT_BASIC_ACCOUNTING_INFORMATION = struct__JOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
pub const PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = [*c]struct__JOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
pub const struct__JOBOBJECT_BASIC_LIMIT_INFORMATION = extern struct {
    PerProcessUserTimeLimit: LARGE_INTEGER,
    PerJobUserTimeLimit: LARGE_INTEGER,
    LimitFlags: DWORD,
    MinimumWorkingSetSize: SIZE_T,
    MaximumWorkingSetSize: SIZE_T,
    ActiveProcessLimit: DWORD,
    Affinity: ULONG_PTR,
    PriorityClass: DWORD,
    SchedulingClass: DWORD,
};
pub const JOBOBJECT_BASIC_LIMIT_INFORMATION = struct__JOBOBJECT_BASIC_LIMIT_INFORMATION;
pub const PJOBOBJECT_BASIC_LIMIT_INFORMATION = [*c]struct__JOBOBJECT_BASIC_LIMIT_INFORMATION;
pub const struct__JOBOBJECT_EXTENDED_LIMIT_INFORMATION = extern struct {
    BasicLimitInformation: JOBOBJECT_BASIC_LIMIT_INFORMATION,
    IoInfo: IO_COUNTERS,
    ProcessMemoryLimit: SIZE_T,
    JobMemoryLimit: SIZE_T,
    PeakProcessMemoryUsed: SIZE_T,
    PeakJobMemoryUsed: SIZE_T,
};
pub const JOBOBJECT_EXTENDED_LIMIT_INFORMATION = struct__JOBOBJECT_EXTENDED_LIMIT_INFORMATION;
pub const PJOBOBJECT_EXTENDED_LIMIT_INFORMATION = [*c]struct__JOBOBJECT_EXTENDED_LIMIT_INFORMATION;
pub const struct__JOBOBJECT_BASIC_PROCESS_ID_LIST = extern struct {
    NumberOfAssignedProcesses: DWORD,
    NumberOfProcessIdsInList: DWORD,
    ProcessIdList: [1]ULONG_PTR,
};
pub const JOBOBJECT_BASIC_PROCESS_ID_LIST = struct__JOBOBJECT_BASIC_PROCESS_ID_LIST;
pub const PJOBOBJECT_BASIC_PROCESS_ID_LIST = [*c]struct__JOBOBJECT_BASIC_PROCESS_ID_LIST;
pub const struct__JOBOBJECT_BASIC_UI_RESTRICTIONS = extern struct {
    UIRestrictionsClass: DWORD,
};
pub const JOBOBJECT_BASIC_UI_RESTRICTIONS = struct__JOBOBJECT_BASIC_UI_RESTRICTIONS;
pub const PJOBOBJECT_BASIC_UI_RESTRICTIONS = [*c]struct__JOBOBJECT_BASIC_UI_RESTRICTIONS;
pub const struct__JOBOBJECT_SECURITY_LIMIT_INFORMATION = extern struct {
    SecurityLimitFlags: DWORD,
    JobToken: HANDLE,
    SidsToDisable: PTOKEN_GROUPS,
    PrivilegesToDelete: PTOKEN_PRIVILEGES,
    RestrictedSids: PTOKEN_GROUPS,
};
pub const JOBOBJECT_SECURITY_LIMIT_INFORMATION = struct__JOBOBJECT_SECURITY_LIMIT_INFORMATION;
pub const PJOBOBJECT_SECURITY_LIMIT_INFORMATION = [*c]struct__JOBOBJECT_SECURITY_LIMIT_INFORMATION;
pub const struct__JOBOBJECT_END_OF_JOB_TIME_INFORMATION = extern struct {
    EndOfJobTimeAction: DWORD,
};
pub const JOBOBJECT_END_OF_JOB_TIME_INFORMATION = struct__JOBOBJECT_END_OF_JOB_TIME_INFORMATION;
pub const PJOBOBJECT_END_OF_JOB_TIME_INFORMATION = [*c]struct__JOBOBJECT_END_OF_JOB_TIME_INFORMATION;
pub const struct__JOBOBJECT_ASSOCIATE_COMPLETION_PORT = extern struct {
    CompletionKey: PVOID,
    CompletionPort: HANDLE,
};
pub const JOBOBJECT_ASSOCIATE_COMPLETION_PORT = struct__JOBOBJECT_ASSOCIATE_COMPLETION_PORT;
pub const PJOBOBJECT_ASSOCIATE_COMPLETION_PORT = [*c]struct__JOBOBJECT_ASSOCIATE_COMPLETION_PORT;
pub const struct__JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = extern struct {
    BasicInfo: JOBOBJECT_BASIC_ACCOUNTING_INFORMATION,
    IoInfo: IO_COUNTERS,
};
pub const JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = struct__JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
pub const PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = [*c]struct__JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
pub const struct__JOBOBJECT_JOBSET_INFORMATION = extern struct {
    MemberLevel: DWORD,
};
pub const JOBOBJECT_JOBSET_INFORMATION = struct__JOBOBJECT_JOBSET_INFORMATION;
pub const PJOBOBJECT_JOBSET_INFORMATION = [*c]struct__JOBOBJECT_JOBSET_INFORMATION;
pub const ToleranceLow = enum__JOBOBJECT_RATE_CONTROL_TOLERANCE.ToleranceLow;
pub const ToleranceMedium = enum__JOBOBJECT_RATE_CONTROL_TOLERANCE.ToleranceMedium;
pub const ToleranceHigh = enum__JOBOBJECT_RATE_CONTROL_TOLERANCE.ToleranceHigh;
pub const enum__JOBOBJECT_RATE_CONTROL_TOLERANCE = extern enum {
    ToleranceLow = 1,
    ToleranceMedium = 2,
    ToleranceHigh = 3,
};
pub const JOBOBJECT_RATE_CONTROL_TOLERANCE = enum__JOBOBJECT_RATE_CONTROL_TOLERANCE;
pub const PJOBOBJECT_RATE_CONTROL_TOLERANCE = [*c]enum__JOBOBJECT_RATE_CONTROL_TOLERANCE;
pub const ToleranceIntervalShort = enum__JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL.ToleranceIntervalShort;
pub const ToleranceIntervalMedium = enum__JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL.ToleranceIntervalMedium;
pub const ToleranceIntervalLong = enum__JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL.ToleranceIntervalLong;
pub const enum__JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = extern enum {
    ToleranceIntervalShort = 1,
    ToleranceIntervalMedium = 2,
    ToleranceIntervalLong = 3,
};
pub const JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = enum__JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL;
pub const PJOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = [*c]enum__JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL;
pub const struct__JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = extern struct {
    IoReadBytesLimit: DWORD64,
    IoWriteBytesLimit: DWORD64,
    PerJobUserTimeLimit: LARGE_INTEGER,
    JobMemoryLimit: DWORD64,
    RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    RateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    LimitFlags: DWORD,
};
pub const JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = struct__JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;
pub const PJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = [*c]struct__JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;
pub const struct_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 = extern struct {
    IoReadBytesLimit: DWORD64,
    IoWriteBytesLimit: DWORD64,
    PerJobUserTimeLimit: LARGE_INTEGER,
    @"": extern union {
        JobHighMemoryLimit: DWORD64,
        JobMemoryLimit: DWORD64,
    },
    @"": extern union {
        RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
        CpuRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    },
    @"": extern union {
        RateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
        CpuRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    },
    LimitFlags: DWORD,
    IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    JobLowMemoryLimit: DWORD64,
    IoRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    NetRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
};
pub const JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 = struct_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2;
pub const struct__JOBOBJECT_LIMIT_VIOLATION_INFORMATION = extern struct {
    LimitFlags: DWORD,
    ViolationLimitFlags: DWORD,
    IoReadBytes: DWORD64,
    IoReadBytesLimit: DWORD64,
    IoWriteBytes: DWORD64,
    IoWriteBytesLimit: DWORD64,
    PerJobUserTime: LARGE_INTEGER,
    PerJobUserTimeLimit: LARGE_INTEGER,
    JobMemory: DWORD64,
    JobMemoryLimit: DWORD64,
    RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    RateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
};
pub const JOBOBJECT_LIMIT_VIOLATION_INFORMATION = struct__JOBOBJECT_LIMIT_VIOLATION_INFORMATION;
pub const PJOBOBJECT_LIMIT_VIOLATION_INFORMATION = [*c]struct__JOBOBJECT_LIMIT_VIOLATION_INFORMATION;
pub const struct_JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 = extern struct {
    LimitFlags: DWORD,
    ViolationLimitFlags: DWORD,
    IoReadBytes: DWORD64,
    IoReadBytesLimit: DWORD64,
    IoWriteBytes: DWORD64,
    IoWriteBytesLimit: DWORD64,
    PerJobUserTime: LARGE_INTEGER,
    PerJobUserTimeLimit: LARGE_INTEGER,
    JobMemory: DWORD64,
    @"": extern union {
        JobHighMemoryLimit: DWORD64,
        JobMemoryLimit: DWORD64,
    },
    @"": extern union {
        RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
        CpuRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    },
    @"": extern union {
        RateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
        CpuRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    },
    JobLowMemoryLimit: DWORD64,
    IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    IoRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    NetRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
};
pub const JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 = struct_JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2;
pub const struct__JOBOBJECT_CPU_RATE_CONTROL_INFORMATION = extern struct {
    ControlFlags: DWORD,
    @"": extern union {
        CpuRate: DWORD,
        Weight: DWORD,
        @"": extern struct {
            MinRate: WORD,
            MaxRate: WORD,
        },
    },
};
pub const JOBOBJECT_CPU_RATE_CONTROL_INFORMATION = struct__JOBOBJECT_CPU_RATE_CONTROL_INFORMATION;
pub const PJOBOBJECT_CPU_RATE_CONTROL_INFORMATION = [*c]struct__JOBOBJECT_CPU_RATE_CONTROL_INFORMATION;
pub const JOB_OBJECT_NET_RATE_CONTROL_ENABLE = enum_JOB_OBJECT_NET_RATE_CONTROL_FLAGS.JOB_OBJECT_NET_RATE_CONTROL_ENABLE;
pub const JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = enum_JOB_OBJECT_NET_RATE_CONTROL_FLAGS.JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH;
pub const JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = enum_JOB_OBJECT_NET_RATE_CONTROL_FLAGS.JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG;
pub const JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = enum_JOB_OBJECT_NET_RATE_CONTROL_FLAGS.JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS;
pub const enum_JOB_OBJECT_NET_RATE_CONTROL_FLAGS = extern enum {
    JOB_OBJECT_NET_RATE_CONTROL_ENABLE = 1,
    JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = 2,
    JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = 4,
    JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = 7,
};
pub const JOB_OBJECT_NET_RATE_CONTROL_FLAGS = enum_JOB_OBJECT_NET_RATE_CONTROL_FLAGS;
pub const struct_JOBOBJECT_NET_RATE_CONTROL_INFORMATION = extern struct {
    MaxBandwidth: DWORD64,
    ControlFlags: JOB_OBJECT_NET_RATE_CONTROL_FLAGS,
    DscpTag: BYTE,
};
pub const JOBOBJECT_NET_RATE_CONTROL_INFORMATION = struct_JOBOBJECT_NET_RATE_CONTROL_INFORMATION;
pub const JOB_OBJECT_IO_RATE_CONTROL_ENABLE = enum_JOB_OBJECT_IO_RATE_CONTROL_FLAGS.JOB_OBJECT_IO_RATE_CONTROL_ENABLE;
pub const JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = enum_JOB_OBJECT_IO_RATE_CONTROL_FLAGS.JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME;
pub const JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL = enum_JOB_OBJECT_IO_RATE_CONTROL_FLAGS.JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL;
pub const JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP = enum_JOB_OBJECT_IO_RATE_CONTROL_FLAGS.JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP;
pub const JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = enum_JOB_OBJECT_IO_RATE_CONTROL_FLAGS.JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS;
pub const enum_JOB_OBJECT_IO_RATE_CONTROL_FLAGS = extern enum {
    JOB_OBJECT_IO_RATE_CONTROL_ENABLE = 1,
    JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = 2,
    JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL = 4,
    JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP = 8,
    JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = 15,
};
pub const JOB_OBJECT_IO_RATE_CONTROL_FLAGS = enum_JOB_OBJECT_IO_RATE_CONTROL_FLAGS;
pub const struct_JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE = extern struct {
    MaxIops: LONG64,
    MaxBandwidth: LONG64,
    ReservationIops: LONG64,
    VolumeName: PWSTR,
    BaseIoSize: DWORD,
    ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    VolumeNameLength: WORD,
};
pub const JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE = struct_JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE;
pub const JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V1 = JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE;
pub const struct_JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 = extern struct {
    MaxIops: LONG64,
    MaxBandwidth: LONG64,
    ReservationIops: LONG64,
    VolumeName: PWSTR,
    BaseIoSize: DWORD,
    ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    VolumeNameLength: WORD,
    CriticalReservationIops: LONG64,
    ReservationBandwidth: LONG64,
    CriticalReservationBandwidth: LONG64,
    MaxTimePercent: LONG64,
    ReservationTimePercent: LONG64,
    CriticalReservationTimePercent: LONG64,
};
pub const JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 = struct_JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2;
pub const struct_JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 = extern struct {
    MaxIops: LONG64,
    MaxBandwidth: LONG64,
    ReservationIops: LONG64,
    VolumeName: PWSTR,
    BaseIoSize: DWORD,
    ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    VolumeNameLength: WORD,
    CriticalReservationIops: LONG64,
    ReservationBandwidth: LONG64,
    CriticalReservationBandwidth: LONG64,
    MaxTimePercent: LONG64,
    ReservationTimePercent: LONG64,
    CriticalReservationTimePercent: LONG64,
    SoftMaxIops: LONG64,
    SoftMaxBandwidth: LONG64,
    SoftMaxTimePercent: LONG64,
    LimitExcessNotifyIops: LONG64,
    LimitExcessNotifyBandwidth: LONG64,
    LimitExcessNotifyTimePercent: LONG64,
};
pub const JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 = struct_JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3;
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE = enum_JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS.JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE;
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE = enum_JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS.JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE;
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS = enum_JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS.JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS;
pub const enum_JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS = extern enum {
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE = 1,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE = 2,
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS = 3,
};
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS = enum_JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS;
pub const struct__JOBOBJECT_IO_ATTRIBUTION_STATS = extern struct {
    IoCount: ULONG_PTR,
    TotalNonOverlappedQueueTime: ULONGLONG,
    TotalNonOverlappedServiceTime: ULONGLONG,
    TotalSize: ULONGLONG,
};
pub const JOBOBJECT_IO_ATTRIBUTION_STATS = struct__JOBOBJECT_IO_ATTRIBUTION_STATS;
pub const PJOBOBJECT_IO_ATTRIBUTION_STATS = [*c]struct__JOBOBJECT_IO_ATTRIBUTION_STATS;
pub const struct__JOBOBJECT_IO_ATTRIBUTION_INFORMATION = extern struct {
    ControlFlags: DWORD,
    ReadStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
    WriteStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
};
pub const JOBOBJECT_IO_ATTRIBUTION_INFORMATION = struct__JOBOBJECT_IO_ATTRIBUTION_INFORMATION;
pub const PJOBOBJECT_IO_ATTRIBUTION_INFORMATION = [*c]struct__JOBOBJECT_IO_ATTRIBUTION_INFORMATION;
pub const JobObjectBasicAccountingInformation = enum__JOBOBJECTINFOCLASS.JobObjectBasicAccountingInformation;
pub const JobObjectBasicLimitInformation = enum__JOBOBJECTINFOCLASS.JobObjectBasicLimitInformation;
pub const JobObjectBasicProcessIdList = enum__JOBOBJECTINFOCLASS.JobObjectBasicProcessIdList;
pub const JobObjectBasicUIRestrictions = enum__JOBOBJECTINFOCLASS.JobObjectBasicUIRestrictions;
pub const JobObjectSecurityLimitInformation = enum__JOBOBJECTINFOCLASS.JobObjectSecurityLimitInformation;
pub const JobObjectEndOfJobTimeInformation = enum__JOBOBJECTINFOCLASS.JobObjectEndOfJobTimeInformation;
pub const JobObjectAssociateCompletionPortInformation = enum__JOBOBJECTINFOCLASS.JobObjectAssociateCompletionPortInformation;
pub const JobObjectBasicAndIoAccountingInformation = enum__JOBOBJECTINFOCLASS.JobObjectBasicAndIoAccountingInformation;
pub const JobObjectExtendedLimitInformation = enum__JOBOBJECTINFOCLASS.JobObjectExtendedLimitInformation;
pub const JobObjectJobSetInformation = enum__JOBOBJECTINFOCLASS.JobObjectJobSetInformation;
pub const JobObjectGroupInformation = enum__JOBOBJECTINFOCLASS.JobObjectGroupInformation;
pub const JobObjectNotificationLimitInformation = enum__JOBOBJECTINFOCLASS.JobObjectNotificationLimitInformation;
pub const JobObjectLimitViolationInformation = enum__JOBOBJECTINFOCLASS.JobObjectLimitViolationInformation;
pub const JobObjectGroupInformationEx = enum__JOBOBJECTINFOCLASS.JobObjectGroupInformationEx;
pub const JobObjectCpuRateControlInformation = enum__JOBOBJECTINFOCLASS.JobObjectCpuRateControlInformation;
pub const JobObjectCompletionFilter = enum__JOBOBJECTINFOCLASS.JobObjectCompletionFilter;
pub const JobObjectCompletionCounter = enum__JOBOBJECTINFOCLASS.JobObjectCompletionCounter;
pub const JobObjectReserved1Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved1Information;
pub const JobObjectReserved2Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved2Information;
pub const JobObjectReserved3Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved3Information;
pub const JobObjectReserved4Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved4Information;
pub const JobObjectReserved5Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved5Information;
pub const JobObjectReserved6Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved6Information;
pub const JobObjectReserved7Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved7Information;
pub const JobObjectReserved8Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved8Information;
pub const JobObjectReserved9Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved9Information;
pub const JobObjectReserved10Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved10Information;
pub const JobObjectReserved11Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved11Information;
pub const JobObjectReserved12Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved12Information;
pub const JobObjectReserved13Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved13Information;
pub const JobObjectReserved14Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved14Information;
pub const JobObjectNetRateControlInformation = enum__JOBOBJECTINFOCLASS.JobObjectNetRateControlInformation;
pub const JobObjectNotificationLimitInformation2 = enum__JOBOBJECTINFOCLASS.JobObjectNotificationLimitInformation2;
pub const JobObjectLimitViolationInformation2 = enum__JOBOBJECTINFOCLASS.JobObjectLimitViolationInformation2;
pub const JobObjectCreateSilo = enum__JOBOBJECTINFOCLASS.JobObjectCreateSilo;
pub const JobObjectSiloBasicInformation = enum__JOBOBJECTINFOCLASS.JobObjectSiloBasicInformation;
pub const JobObjectReserved15Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved15Information;
pub const JobObjectReserved16Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved16Information;
pub const JobObjectReserved17Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved17Information;
pub const JobObjectReserved18Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved18Information;
pub const JobObjectReserved19Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved19Information;
pub const JobObjectReserved20Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved20Information;
pub const JobObjectReserved21Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved21Information;
pub const JobObjectReserved22Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved22Information;
pub const JobObjectReserved23Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved23Information;
pub const JobObjectReserved24Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved24Information;
pub const JobObjectReserved25Information = enum__JOBOBJECTINFOCLASS.JobObjectReserved25Information;
pub const MaxJobObjectInfoClass = enum__JOBOBJECTINFOCLASS.MaxJobObjectInfoClass;
pub const enum__JOBOBJECTINFOCLASS = extern enum {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation = 2,
    JobObjectBasicProcessIdList = 3,
    JobObjectBasicUIRestrictions = 4,
    JobObjectSecurityLimitInformation = 5,
    JobObjectEndOfJobTimeInformation = 6,
    JobObjectAssociateCompletionPortInformation = 7,
    JobObjectBasicAndIoAccountingInformation = 8,
    JobObjectExtendedLimitInformation = 9,
    JobObjectJobSetInformation = 10,
    JobObjectGroupInformation = 11,
    JobObjectNotificationLimitInformation = 12,
    JobObjectLimitViolationInformation = 13,
    JobObjectGroupInformationEx = 14,
    JobObjectCpuRateControlInformation = 15,
    JobObjectCompletionFilter = 16,
    JobObjectCompletionCounter = 17,
    JobObjectReserved1Information = 18,
    JobObjectReserved2Information = 19,
    JobObjectReserved3Information = 20,
    JobObjectReserved4Information = 21,
    JobObjectReserved5Information = 22,
    JobObjectReserved6Information = 23,
    JobObjectReserved7Information = 24,
    JobObjectReserved8Information = 25,
    JobObjectReserved9Information = 26,
    JobObjectReserved10Information = 27,
    JobObjectReserved11Information = 28,
    JobObjectReserved12Information = 29,
    JobObjectReserved13Information = 30,
    JobObjectReserved14Information = 31,
    JobObjectNetRateControlInformation = 32,
    JobObjectNotificationLimitInformation2 = 33,
    JobObjectLimitViolationInformation2 = 34,
    JobObjectCreateSilo = 35,
    JobObjectSiloBasicInformation = 36,
    JobObjectReserved15Information = 37,
    JobObjectReserved16Information = 38,
    JobObjectReserved17Information = 39,
    JobObjectReserved18Information = 40,
    JobObjectReserved19Information = 41,
    JobObjectReserved20Information = 42,
    JobObjectReserved21Information = 43,
    JobObjectReserved22Information = 44,
    JobObjectReserved23Information = 45,
    JobObjectReserved24Information = 46,
    JobObjectReserved25Information = 47,
    MaxJobObjectInfoClass = 48,
};
pub const JOBOBJECTINFOCLASS = enum__JOBOBJECTINFOCLASS;
pub const struct__SILOOBJECT_BASIC_INFORMATION = extern struct {
    SiloId: DWORD,
    SiloParentId: DWORD,
    NumberOfProcesses: DWORD,
    IsInServerSilo: BOOLEAN,
    Reserved: [3]BYTE,
};
pub const SILOOBJECT_BASIC_INFORMATION = struct__SILOOBJECT_BASIC_INFORMATION;
pub const PSILOOBJECT_BASIC_INFORMATION = [*c]struct__SILOOBJECT_BASIC_INFORMATION;
pub const SERVERSILO_INITING = enum__SERVERSILO_STATE.SERVERSILO_INITING;
pub const SERVERSILO_STARTED = enum__SERVERSILO_STATE.SERVERSILO_STARTED;
pub const SERVERSILO_SHUTTING_DOWN = enum__SERVERSILO_STATE.SERVERSILO_SHUTTING_DOWN;
pub const SERVERSILO_TERMINATING = enum__SERVERSILO_STATE.SERVERSILO_TERMINATING;
pub const SERVERSILO_TERMINATED = enum__SERVERSILO_STATE.SERVERSILO_TERMINATED;
pub const enum__SERVERSILO_STATE = extern enum {
    SERVERSILO_INITING = 0,
    SERVERSILO_STARTED = 1,
    SERVERSILO_SHUTTING_DOWN = 2,
    SERVERSILO_TERMINATING = 3,
    SERVERSILO_TERMINATED = 4,
};
pub const SERVERSILO_STATE = enum__SERVERSILO_STATE;
pub const PSERVERSILO_STATE = [*c]enum__SERVERSILO_STATE;
pub const struct__SERVERSILO_BASIC_INFORMATION = extern struct {
    ServiceSessionId: DWORD,
    State: SERVERSILO_STATE,
    ExitStatus: DWORD,
};
pub const SERVERSILO_BASIC_INFORMATION = struct__SERVERSILO_BASIC_INFORMATION;
pub const PSERVERSILO_BASIC_INFORMATION = [*c]struct__SERVERSILO_BASIC_INFORMATION;
pub const FirmwareTypeUnknown = enum__FIRMWARE_TYPE.FirmwareTypeUnknown;
pub const FirmwareTypeBios = enum__FIRMWARE_TYPE.FirmwareTypeBios;
pub const FirmwareTypeUefi = enum__FIRMWARE_TYPE.FirmwareTypeUefi;
pub const FirmwareTypeMax = enum__FIRMWARE_TYPE.FirmwareTypeMax;
pub const enum__FIRMWARE_TYPE = extern enum {
    FirmwareTypeUnknown,
    FirmwareTypeBios,
    FirmwareTypeUefi,
    FirmwareTypeMax,
};
pub const FIRMWARE_TYPE = enum__FIRMWARE_TYPE;
pub const PFIRMWARE_TYPE = [*c]enum__FIRMWARE_TYPE;
pub const RelationProcessorCore = enum__LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorCore;
pub const RelationNumaNode = enum__LOGICAL_PROCESSOR_RELATIONSHIP.RelationNumaNode;
pub const RelationCache = enum__LOGICAL_PROCESSOR_RELATIONSHIP.RelationCache;
pub const RelationProcessorPackage = enum__LOGICAL_PROCESSOR_RELATIONSHIP.RelationProcessorPackage;
pub const RelationGroup = enum__LOGICAL_PROCESSOR_RELATIONSHIP.RelationGroup;
pub const RelationAll = enum__LOGICAL_PROCESSOR_RELATIONSHIP.RelationAll;
pub const enum__LOGICAL_PROCESSOR_RELATIONSHIP = extern enum {
    RelationProcessorCore = 0,
    RelationNumaNode = 1,
    RelationCache = 2,
    RelationProcessorPackage = 3,
    RelationGroup = 4,
    RelationAll = 65535,
};
pub const LOGICAL_PROCESSOR_RELATIONSHIP = enum__LOGICAL_PROCESSOR_RELATIONSHIP;
pub const CacheUnified = enum__PROCESSOR_CACHE_TYPE.CacheUnified;
pub const CacheInstruction = enum__PROCESSOR_CACHE_TYPE.CacheInstruction;
pub const CacheData = enum__PROCESSOR_CACHE_TYPE.CacheData;
pub const CacheTrace = enum__PROCESSOR_CACHE_TYPE.CacheTrace;
pub const enum__PROCESSOR_CACHE_TYPE = extern enum {
    CacheUnified,
    CacheInstruction,
    CacheData,
    CacheTrace,
};
pub const PROCESSOR_CACHE_TYPE = enum__PROCESSOR_CACHE_TYPE;
pub const struct__CACHE_DESCRIPTOR = extern struct {
    Level: BYTE,
    Associativity: BYTE,
    LineSize: WORD,
    Size: DWORD,
    Type: PROCESSOR_CACHE_TYPE,
};
pub const CACHE_DESCRIPTOR = struct__CACHE_DESCRIPTOR;
pub const PCACHE_DESCRIPTOR = [*c]struct__CACHE_DESCRIPTOR;
pub const struct__SYSTEM_LOGICAL_PROCESSOR_INFORMATION = extern struct {
    ProcessorMask: ULONG_PTR,
    Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    @"": extern union {
        ProcessorCore: extern struct {
            Flags: BYTE,
        },
        NumaNode: extern struct {
            NodeNumber: DWORD,
        },
        Cache: CACHE_DESCRIPTOR,
        Reserved: [2]ULONGLONG,
    },
};
pub const SYSTEM_LOGICAL_PROCESSOR_INFORMATION = struct__SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
pub const PSYSTEM_LOGICAL_PROCESSOR_INFORMATION = [*c]struct__SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
pub const struct__PROCESSOR_RELATIONSHIP = extern struct {
    Flags: BYTE,
    EfficiencyClass: BYTE,
    Reserved: [20]BYTE,
    GroupCount: WORD,
    GroupMask: [1]GROUP_AFFINITY,
};
pub const PROCESSOR_RELATIONSHIP = struct__PROCESSOR_RELATIONSHIP;
pub const PPROCESSOR_RELATIONSHIP = [*c]struct__PROCESSOR_RELATIONSHIP;
pub const struct__NUMA_NODE_RELATIONSHIP = extern struct {
    NodeNumber: DWORD,
    Reserved: [20]BYTE,
    GroupMask: GROUP_AFFINITY,
};
pub const NUMA_NODE_RELATIONSHIP = struct__NUMA_NODE_RELATIONSHIP;
pub const PNUMA_NODE_RELATIONSHIP = [*c]struct__NUMA_NODE_RELATIONSHIP;
pub const struct__CACHE_RELATIONSHIP = extern struct {
    Level: BYTE,
    Associativity: BYTE,
    LineSize: WORD,
    CacheSize: DWORD,
    Type: PROCESSOR_CACHE_TYPE,
    Reserved: [20]BYTE,
    GroupMask: GROUP_AFFINITY,
};
pub const CACHE_RELATIONSHIP = struct__CACHE_RELATIONSHIP;
pub const PCACHE_RELATIONSHIP = [*c]struct__CACHE_RELATIONSHIP;
pub const struct__PROCESSOR_GROUP_INFO = extern struct {
    MaximumProcessorCount: BYTE,
    ActiveProcessorCount: BYTE,
    Reserved: [38]BYTE,
    ActiveProcessorMask: KAFFINITY,
};
pub const PROCESSOR_GROUP_INFO = struct__PROCESSOR_GROUP_INFO;
pub const PPROCESSOR_GROUP_INFO = [*c]struct__PROCESSOR_GROUP_INFO;
pub const struct__GROUP_RELATIONSHIP = extern struct {
    MaximumGroupCount: WORD,
    ActiveGroupCount: WORD,
    Reserved: [20]BYTE,
    GroupInfo: [1]PROCESSOR_GROUP_INFO,
};
pub const GROUP_RELATIONSHIP = struct__GROUP_RELATIONSHIP;
pub const PGROUP_RELATIONSHIP = [*c]struct__GROUP_RELATIONSHIP;
pub const struct__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = extern struct {
    Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    Size: DWORD,
    @"": extern union {
        Processor: PROCESSOR_RELATIONSHIP,
        NumaNode: NUMA_NODE_RELATIONSHIP,
        Cache: CACHE_RELATIONSHIP,
        Group: GROUP_RELATIONSHIP,
    },
};
pub const SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = struct__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
pub const PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = [*c]struct__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
pub const CpuSetInformation = enum__CPU_SET_INFORMATION_TYPE.CpuSetInformation;
pub const enum__CPU_SET_INFORMATION_TYPE = extern enum {
    CpuSetInformation,
};
pub const CPU_SET_INFORMATION_TYPE = enum__CPU_SET_INFORMATION_TYPE;
pub const PCPU_SET_INFORMATION_TYPE = [*c]enum__CPU_SET_INFORMATION_TYPE;
pub const struct__SYSTEM_CPU_SET_INFORMATION = extern struct {
    Size: DWORD,
    Type: CPU_SET_INFORMATION_TYPE,
    @"": extern union {
        CpuSet: extern struct {
            Id: DWORD,
            Group: WORD,
            LogicalProcessorIndex: BYTE,
            CoreIndex: BYTE,
            LastLevelCacheIndex: BYTE,
            NumaNodeIndex: BYTE,
            EfficiencyClass: BYTE,
            @"": extern union {
                AllFlags: BYTE,
                @"": @OpaqueType(),
            },
            @"": extern union {
                Reserved: DWORD,
                SchedulingClass: BYTE,
            },
            AllocationTag: DWORD64,
        },
    },
};
pub const SYSTEM_CPU_SET_INFORMATION = struct__SYSTEM_CPU_SET_INFORMATION;
pub const PSYSTEM_CPU_SET_INFORMATION = [*c]struct__SYSTEM_CPU_SET_INFORMATION;
pub const struct__SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = extern struct {
    CycleTime: DWORD64,
};
pub const SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = struct__SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
pub const PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = [*c]struct__SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
pub const struct__XSTATE_FEATURE = extern struct {
    Offset: DWORD,
    Size: DWORD,
};
pub const XSTATE_FEATURE = struct__XSTATE_FEATURE;
pub const PXSTATE_FEATURE = [*c]struct__XSTATE_FEATURE;
pub const struct__XSTATE_CONFIGURATION = extern struct {
    EnabledFeatures: DWORD64,
    EnabledVolatileFeatures: DWORD64,
    Size: DWORD,
    @"": extern union {
        ControlFlags: DWORD,
        @"": @OpaqueType(),
    },
    Features: [64]XSTATE_FEATURE,
    EnabledSupervisorFeatures: DWORD64,
    AlignedFeatures: DWORD64,
    AllFeatureSize: DWORD,
    AllFeatures: [64]DWORD,
    EnabledUserVisibleSupervisorFeatures: DWORD64,
};
pub const XSTATE_CONFIGURATION = struct__XSTATE_CONFIGURATION;
pub const PXSTATE_CONFIGURATION = [*c]struct__XSTATE_CONFIGURATION;
pub const struct__MEMORY_BASIC_INFORMATION = extern struct {
    BaseAddress: PVOID,
    AllocationBase: PVOID,
    AllocationProtect: DWORD,
    RegionSize: SIZE_T,
    State: DWORD,
    Protect: DWORD,
    Type: DWORD,
};
pub const MEMORY_BASIC_INFORMATION = struct__MEMORY_BASIC_INFORMATION;
pub const PMEMORY_BASIC_INFORMATION = [*c]struct__MEMORY_BASIC_INFORMATION;
pub const struct__MEMORY_BASIC_INFORMATION32 = extern struct {
    BaseAddress: DWORD,
    AllocationBase: DWORD,
    AllocationProtect: DWORD,
    RegionSize: DWORD,
    State: DWORD,
    Protect: DWORD,
    Type: DWORD,
};
pub const MEMORY_BASIC_INFORMATION32 = struct__MEMORY_BASIC_INFORMATION32;
pub const PMEMORY_BASIC_INFORMATION32 = [*c]struct__MEMORY_BASIC_INFORMATION32;
pub const struct__MEMORY_BASIC_INFORMATION64 = extern struct {
    BaseAddress: ULONGLONG,
    AllocationBase: ULONGLONG,
    AllocationProtect: DWORD,
    __alignment1: DWORD,
    RegionSize: ULONGLONG,
    State: DWORD,
    Protect: DWORD,
    Type: DWORD,
    __alignment2: DWORD,
};
pub const MEMORY_BASIC_INFORMATION64 = struct__MEMORY_BASIC_INFORMATION64;
pub const PMEMORY_BASIC_INFORMATION64 = [*c]struct__MEMORY_BASIC_INFORMATION64;
pub const struct__CFG_CALL_TARGET_INFO = extern struct {
    Offset: ULONG_PTR,
    Flags: ULONG_PTR,
};
pub const CFG_CALL_TARGET_INFO = struct__CFG_CALL_TARGET_INFO;
pub const PCFG_CALL_TARGET_INFO = [*c]struct__CFG_CALL_TARGET_INFO;
pub const struct__MEM_ADDRESS_REQUIREMENTS = extern struct {
    LowestStartingAddress: PVOID,
    HighestEndingAddress: PVOID,
    Alignment: SIZE_T,
};
pub const MEM_ADDRESS_REQUIREMENTS = struct__MEM_ADDRESS_REQUIREMENTS;
pub const PMEM_ADDRESS_REQUIREMENTS = [*c]struct__MEM_ADDRESS_REQUIREMENTS;
pub const MemExtendedParameterInvalidType = enum_MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterInvalidType;
pub const MemExtendedParameterAddressRequirements = enum_MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterAddressRequirements;
pub const MemExtendedParameterNumaNode = enum_MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterNumaNode;
pub const MemExtendedParameterPartitionHandle = enum_MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterPartitionHandle;
pub const MemExtendedParameterUserPhysicalHandle = enum_MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterUserPhysicalHandle;
pub const MemExtendedParameterAttributeFlags = enum_MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterAttributeFlags;
pub const MemExtendedParameterMax = enum_MEM_EXTENDED_PARAMETER_TYPE.MemExtendedParameterMax;
pub const enum_MEM_EXTENDED_PARAMETER_TYPE = extern enum {
    MemExtendedParameterInvalidType = 0,
    MemExtendedParameterAddressRequirements = 1,
    MemExtendedParameterNumaNode = 2,
    MemExtendedParameterPartitionHandle = 3,
    MemExtendedParameterUserPhysicalHandle = 4,
    MemExtendedParameterAttributeFlags = 5,
    MemExtendedParameterMax = 6,
};
pub const MEM_EXTENDED_PARAMETER_TYPE = enum_MEM_EXTENDED_PARAMETER_TYPE;
pub const PMEM_EXTENDED_PARAMETER_TYPE = [*c]enum_MEM_EXTENDED_PARAMETER_TYPE;
pub const struct_MEM_EXTENDED_PARAMETER = extern struct {
    @"": @OpaqueType(),
    @"": extern union {
        ULong64: DWORD64,
        Pointer: PVOID,
        Size: SIZE_T,
        Handle: HANDLE,
        ULong: DWORD,
    },
};
pub const MEM_EXTENDED_PARAMETER = struct_MEM_EXTENDED_PARAMETER;
pub const PMEM_EXTENDED_PARAMETER = [*c]struct_MEM_EXTENDED_PARAMETER;
pub const MemSectionExtendedParameterInvalidType = enum_MEM_SECTION_EXTENDED_PARAMETER_TYPE.MemSectionExtendedParameterInvalidType;
pub const MemSectionExtendedParameterUserPhysicalFlags = enum_MEM_SECTION_EXTENDED_PARAMETER_TYPE.MemSectionExtendedParameterUserPhysicalFlags;
pub const MemSectionExtendedParameterNumaNode = enum_MEM_SECTION_EXTENDED_PARAMETER_TYPE.MemSectionExtendedParameterNumaNode;
pub const MemSectionExtendedParameterMax = enum_MEM_SECTION_EXTENDED_PARAMETER_TYPE.MemSectionExtendedParameterMax;
pub const enum_MEM_SECTION_EXTENDED_PARAMETER_TYPE = extern enum {
    MemSectionExtendedParameterInvalidType = 0,
    MemSectionExtendedParameterUserPhysicalFlags = 1,
    MemSectionExtendedParameterNumaNode = 2,
    MemSectionExtendedParameterMax = 3,
};
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE = enum_MEM_SECTION_EXTENDED_PARAMETER_TYPE;
pub const PMEM_SECTION_EXTENDED_PARAMETER_TYPE = [*c]enum_MEM_SECTION_EXTENDED_PARAMETER_TYPE;
pub const struct__ENCLAVE_CREATE_INFO_SGX = extern struct {
    Secs: [4096]BYTE,
};
pub const ENCLAVE_CREATE_INFO_SGX = struct__ENCLAVE_CREATE_INFO_SGX;
pub const PENCLAVE_CREATE_INFO_SGX = [*c]struct__ENCLAVE_CREATE_INFO_SGX;
pub const struct__ENCLAVE_INIT_INFO_SGX = extern struct {
    SigStruct: [1808]BYTE,
    Reserved1: [240]BYTE,
    EInitToken: [304]BYTE,
    Reserved2: [1744]BYTE,
};
pub const ENCLAVE_INIT_INFO_SGX = struct__ENCLAVE_INIT_INFO_SGX;
pub const PENCLAVE_INIT_INFO_SGX = [*c]struct__ENCLAVE_INIT_INFO_SGX;
pub const struct__ENCLAVE_CREATE_INFO_VBS = extern struct {
    Flags: DWORD,
    OwnerID: [32]BYTE,
};
pub const ENCLAVE_CREATE_INFO_VBS = struct__ENCLAVE_CREATE_INFO_VBS;
pub const PENCLAVE_CREATE_INFO_VBS = [*c]struct__ENCLAVE_CREATE_INFO_VBS;
pub const struct__ENCLAVE_CREATE_INFO_VBS_BASIC = extern struct {
    Flags: DWORD,
    OwnerID: [32]BYTE,
};
pub const ENCLAVE_CREATE_INFO_VBS_BASIC = struct__ENCLAVE_CREATE_INFO_VBS_BASIC;
pub const PENCLAVE_CREATE_INFO_VBS_BASIC = [*c]struct__ENCLAVE_CREATE_INFO_VBS_BASIC;
pub const struct__ENCLAVE_LOAD_DATA_VBS_BASIC = extern struct {
    PageType: DWORD,
};
pub const ENCLAVE_LOAD_DATA_VBS_BASIC = struct__ENCLAVE_LOAD_DATA_VBS_BASIC;
pub const PENCLAVE_LOAD_DATA_VBS_BASIC = [*c]struct__ENCLAVE_LOAD_DATA_VBS_BASIC;
pub const struct__ENCLAVE_INIT_INFO_VBS_BASIC = extern struct {
    FamilyId: [16]BYTE,
    ImageId: [16]BYTE,
    EnclaveSize: ULONGLONG,
    EnclaveSvn: DWORD,
    Reserved: DWORD,
    @"": extern union {
        SignatureInfoHandle: HANDLE,
        Unused: ULONGLONG,
    },
};
pub const ENCLAVE_INIT_INFO_VBS_BASIC = struct__ENCLAVE_INIT_INFO_VBS_BASIC;
pub const PENCLAVE_INIT_INFO_VBS_BASIC = [*c]struct__ENCLAVE_INIT_INFO_VBS_BASIC;
pub const struct__ENCLAVE_INIT_INFO_VBS = extern struct {
    Length: DWORD,
    ThreadCount: DWORD,
};
pub const ENCLAVE_INIT_INFO_VBS = struct__ENCLAVE_INIT_INFO_VBS;
pub const PENCLAVE_INIT_INFO_VBS = [*c]struct__ENCLAVE_INIT_INFO_VBS;
pub const ENCLAVE_TARGET_FUNCTION = fn (PVOID) callconv(.C) PVOID;
pub const PENCLAVE_TARGET_FUNCTION = [*c]ENCLAVE_TARGET_FUNCTION;
pub const LPENCLAVE_TARGET_FUNCTION = PENCLAVE_TARGET_FUNCTION;
pub const struct__FILE_ID_128 = extern struct {
    Identifier: [16]BYTE,
};
pub const FILE_ID_128 = struct__FILE_ID_128;
pub const PFILE_ID_128 = [*c]struct__FILE_ID_128;
pub const struct__FILE_NOTIFY_INFORMATION = extern struct {
    NextEntryOffset: DWORD,
    Action: DWORD,
    FileNameLength: DWORD,
    FileName: [1]WCHAR,
};
pub const FILE_NOTIFY_INFORMATION = struct__FILE_NOTIFY_INFORMATION;
pub const PFILE_NOTIFY_INFORMATION = [*c]struct__FILE_NOTIFY_INFORMATION;
pub const struct__FILE_NOTIFY_EXTENDED_INFORMATION = extern struct {
    NextEntryOffset: DWORD,
    Action: DWORD,
    CreationTime: LARGE_INTEGER,
    LastModificationTime: LARGE_INTEGER,
    LastChangeTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    AllocatedLength: LARGE_INTEGER,
    FileSize: LARGE_INTEGER,
    FileAttributes: DWORD,
    ReparsePointTag: DWORD,
    FileId: LARGE_INTEGER,
    ParentFileId: LARGE_INTEGER,
    FileNameLength: DWORD,
    FileName: [1]WCHAR,
};
pub const FILE_NOTIFY_EXTENDED_INFORMATION = struct__FILE_NOTIFY_EXTENDED_INFORMATION;
pub const PFILE_NOTIFY_EXTENDED_INFORMATION = [*c]struct__FILE_NOTIFY_EXTENDED_INFORMATION;
pub const union__FILE_SEGMENT_ELEMENT = extern union {
    Buffer: PVOID64,
    Alignment: ULONGLONG,
};
pub const FILE_SEGMENT_ELEMENT = union__FILE_SEGMENT_ELEMENT;
pub const PFILE_SEGMENT_ELEMENT = [*c]union__FILE_SEGMENT_ELEMENT;
pub const struct__REPARSE_GUID_DATA_BUFFER = extern struct {
    ReparseTag: DWORD,
    ReparseDataLength: WORD,
    Reserved: WORD,
    ReparseGuid: GUID,
    GenericReparseBuffer: extern struct {
        DataBuffer: [1]BYTE,
    },
};
pub const REPARSE_GUID_DATA_BUFFER = struct__REPARSE_GUID_DATA_BUFFER;
pub const PREPARSE_GUID_DATA_BUFFER = [*c]struct__REPARSE_GUID_DATA_BUFFER;
pub const struct__SCRUB_DATA_INPUT = extern struct {
    Size: DWORD,
    Flags: DWORD,
    MaximumIos: DWORD,
    ObjectId: [4]DWORD,
    Reserved: [25]DWORD,
    ResumeContext: [816]BYTE,
};
pub const SCRUB_DATA_INPUT = struct__SCRUB_DATA_INPUT;
pub const PSCRUB_DATA_INPUT = [*c]struct__SCRUB_DATA_INPUT;
pub const struct__SCRUB_PARITY_EXTENT = extern struct {
    Offset: LONGLONG,
    Length: ULONGLONG,
};
pub const SCRUB_PARITY_EXTENT = struct__SCRUB_PARITY_EXTENT;
pub const PSCRUB_PARITY_EXTENT = [*c]struct__SCRUB_PARITY_EXTENT;
pub const struct__SCRUB_PARITY_EXTENT_DATA = extern struct {
    Size: WORD,
    Flags: WORD,
    NumberOfParityExtents: WORD,
    MaximumNumberOfParityExtents: WORD,
    ParityExtents: [1]SCRUB_PARITY_EXTENT,
};
pub const SCRUB_PARITY_EXTENT_DATA = struct__SCRUB_PARITY_EXTENT_DATA;
pub const PSCRUB_PARITY_EXTENT_DATA = [*c]struct__SCRUB_PARITY_EXTENT_DATA;
pub const struct__SCRUB_DATA_OUTPUT = extern struct {
    Size: DWORD,
    Flags: DWORD,
    Status: DWORD,
    ErrorFileOffset: ULONGLONG,
    ErrorLength: ULONGLONG,
    NumberOfBytesRepaired: ULONGLONG,
    NumberOfBytesFailed: ULONGLONG,
    InternalFileReference: ULONGLONG,
    ResumeContextLength: WORD,
    ParityExtentDataOffset: WORD,
    Reserved: [9]DWORD,
    NumberOfMetadataBytesProcessed: ULONGLONG,
    NumberOfDataBytesProcessed: ULONGLONG,
    TotalNumberOfMetadataBytesInUse: ULONGLONG,
    TotalNumberOfDataBytesInUse: ULONGLONG,
    ResumeContext: [816]BYTE,
};
pub const SCRUB_DATA_OUTPUT = struct__SCRUB_DATA_OUTPUT;
pub const PSCRUB_DATA_OUTPUT = [*c]struct__SCRUB_DATA_OUTPUT;
pub const SharedVirtualDisksUnsupported = enum__SharedVirtualDiskSupportType.SharedVirtualDisksUnsupported;
pub const SharedVirtualDisksSupported = enum__SharedVirtualDiskSupportType.SharedVirtualDisksSupported;
pub const SharedVirtualDiskSnapshotsSupported = enum__SharedVirtualDiskSupportType.SharedVirtualDiskSnapshotsSupported;
pub const SharedVirtualDiskCDPSnapshotsSupported = enum__SharedVirtualDiskSupportType.SharedVirtualDiskCDPSnapshotsSupported;
pub const enum__SharedVirtualDiskSupportType = extern enum {
    SharedVirtualDisksUnsupported = 0,
    SharedVirtualDisksSupported = 1,
    SharedVirtualDiskSnapshotsSupported = 3,
    SharedVirtualDiskCDPSnapshotsSupported = 7,
};
pub const SharedVirtualDiskSupportType = enum__SharedVirtualDiskSupportType;
pub const SharedVirtualDiskHandleStateNone = enum__SharedVirtualDiskHandleState.SharedVirtualDiskHandleStateNone;
pub const SharedVirtualDiskHandleStateFileShared = enum__SharedVirtualDiskHandleState.SharedVirtualDiskHandleStateFileShared;
pub const SharedVirtualDiskHandleStateHandleShared = enum__SharedVirtualDiskHandleState.SharedVirtualDiskHandleStateHandleShared;
pub const enum__SharedVirtualDiskHandleState = extern enum {
    SharedVirtualDiskHandleStateNone = 0,
    SharedVirtualDiskHandleStateFileShared = 1,
    SharedVirtualDiskHandleStateHandleShared = 3,
};
pub const SharedVirtualDiskHandleState = enum__SharedVirtualDiskHandleState;
pub const struct__SHARED_VIRTUAL_DISK_SUPPORT = extern struct {
    SharedVirtualDiskSupport: SharedVirtualDiskSupportType,
    HandleState: SharedVirtualDiskHandleState,
};
pub const SHARED_VIRTUAL_DISK_SUPPORT = struct__SHARED_VIRTUAL_DISK_SUPPORT;
pub const PSHARED_VIRTUAL_DISK_SUPPORT = [*c]struct__SHARED_VIRTUAL_DISK_SUPPORT;
pub const struct__REARRANGE_FILE_DATA = extern struct {
    SourceStartingOffset: ULONGLONG,
    TargetOffset: ULONGLONG,
    SourceFileHandle: HANDLE,
    Length: DWORD,
    Flags: DWORD,
};
pub const REARRANGE_FILE_DATA = struct__REARRANGE_FILE_DATA;
pub const PREARRANGE_FILE_DATA = [*c]struct__REARRANGE_FILE_DATA;
pub const struct__REARRANGE_FILE_DATA32 = extern struct {
    SourceStartingOffset: ULONGLONG,
    TargetOffset: ULONGLONG,
    SourceFileHandle: UINT32,
    Length: DWORD,
    Flags: DWORD,
};
pub const REARRANGE_FILE_DATA32 = struct__REARRANGE_FILE_DATA32;
pub const PREARRANGE_FILE_DATA32 = [*c]struct__REARRANGE_FILE_DATA32;
pub const struct__SHUFFLE_FILE_DATA = extern struct {
    StartingOffset: LONGLONG,
    Length: LONGLONG,
    Flags: DWORD,
};
pub const SHUFFLE_FILE_DATA = struct__SHUFFLE_FILE_DATA;
pub const PSHUFFLE_FILE_DATA = [*c]struct__SHUFFLE_FILE_DATA;
pub const struct__NETWORK_APP_INSTANCE_EA = extern struct {
    AppInstanceID: GUID,
    CsvFlags: DWORD,
};
pub const NETWORK_APP_INSTANCE_EA = struct__NETWORK_APP_INSTANCE_EA;
pub const PNETWORK_APP_INSTANCE_EA = [*c]struct__NETWORK_APP_INSTANCE_EA;
pub extern const GUID_MAX_POWER_SAVINGS: GUID;
pub extern const GUID_MIN_POWER_SAVINGS: GUID;
pub extern const GUID_TYPICAL_POWER_SAVINGS: GUID;
pub extern const NO_SUBGROUP_GUID: GUID;
pub extern const ALL_POWERSCHEMES_GUID: GUID;
pub extern const GUID_POWERSCHEME_PERSONALITY: GUID;
pub extern const GUID_ACTIVE_POWERSCHEME: GUID;
pub extern const GUID_IDLE_RESILIENCY_SUBGROUP: GUID;
pub extern const GUID_IDLE_RESILIENCY_PERIOD: GUID;
pub extern const GUID_DEEP_SLEEP_ENABLED: GUID;
pub extern const GUID_DEEP_SLEEP_PLATFORM_STATE: GUID;
pub extern const GUID_DISK_COALESCING_POWERDOWN_TIMEOUT: GUID;
pub extern const GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT: GUID;
pub extern const GUID_VIDEO_SUBGROUP: GUID;
pub extern const GUID_VIDEO_POWERDOWN_TIMEOUT: GUID;
pub extern const GUID_VIDEO_ANNOYANCE_TIMEOUT: GUID;
pub extern const GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE: GUID;
pub extern const GUID_VIDEO_DIM_TIMEOUT: GUID;
pub extern const GUID_VIDEO_ADAPTIVE_POWERDOWN: GUID;
pub extern const GUID_MONITOR_POWER_ON: GUID;
pub extern const GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS: GUID;
pub extern const GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS: GUID;
pub extern const GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS: GUID;
pub extern const GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS: GUID;
pub extern const GUID_CONSOLE_DISPLAY_STATE: GUID;
pub extern const GUID_ALLOW_DISPLAY_REQUIRED: GUID;
pub extern const GUID_VIDEO_CONSOLE_LOCK_TIMEOUT: GUID;
pub extern const GUID_ADVANCED_COLOR_QUALITY_BIAS: GUID;
pub extern const GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP: GUID;
pub extern const GUID_NON_ADAPTIVE_INPUT_TIMEOUT: GUID;
pub extern const GUID_ADAPTIVE_INPUT_CONTROLLER_STATE: GUID;
pub extern const GUID_DISK_SUBGROUP: GUID;
pub extern const GUID_DISK_MAX_POWER: GUID;
pub extern const GUID_DISK_POWERDOWN_TIMEOUT: GUID;
pub extern const GUID_DISK_IDLE_TIMEOUT: GUID;
pub extern const GUID_DISK_BURST_IGNORE_THRESHOLD: GUID;
pub extern const GUID_DISK_ADAPTIVE_POWERDOWN: GUID;
pub extern const GUID_SLEEP_SUBGROUP: GUID;
pub extern const GUID_SLEEP_IDLE_THRESHOLD: GUID;
pub extern const GUID_STANDBY_TIMEOUT: GUID;
pub extern const GUID_UNATTEND_SLEEP_TIMEOUT: GUID;
pub extern const GUID_HIBERNATE_TIMEOUT: GUID;
pub extern const GUID_HIBERNATE_FASTS4_POLICY: GUID;
pub extern const GUID_CRITICAL_POWER_TRANSITION: GUID;
pub extern const GUID_SYSTEM_AWAYMODE: GUID;
pub extern const GUID_ALLOW_AWAYMODE: GUID;
pub extern const GUID_USER_PRESENCE_PREDICTION: GUID;
pub extern const GUID_STANDBY_BUDGET_GRACE_PERIOD: GUID;
pub extern const GUID_STANDBY_BUDGET_PERCENT: GUID;
pub extern const GUID_STANDBY_RESERVE_GRACE_PERIOD: GUID;
pub extern const GUID_STANDBY_RESERVE_TIME: GUID;
pub extern const GUID_STANDBY_RESET_PERCENT: GUID;
pub extern const GUID_ALLOW_STANDBY_STATES: GUID;
pub extern const GUID_ALLOW_RTC_WAKE: GUID;
pub extern const GUID_LEGACY_RTC_MITIGATION: GUID;
pub extern const GUID_ALLOW_SYSTEM_REQUIRED: GUID;
pub extern const GUID_POWER_SAVING_STATUS: GUID;
pub extern const GUID_ENERGY_SAVER_SUBGROUP: GUID;
pub extern const GUID_ENERGY_SAVER_BATTERY_THRESHOLD: GUID;
pub extern const GUID_ENERGY_SAVER_BRIGHTNESS: GUID;
pub extern const GUID_ENERGY_SAVER_POLICY: GUID;
pub extern const GUID_SYSTEM_BUTTON_SUBGROUP: GUID;
pub extern const GUID_POWERBUTTON_ACTION: GUID;
pub extern const GUID_SLEEPBUTTON_ACTION: GUID;
pub extern const GUID_USERINTERFACEBUTTON_ACTION: GUID;
pub extern const GUID_LIDCLOSE_ACTION: GUID;
pub extern const GUID_LIDOPEN_POWERSTATE: GUID;
pub extern const GUID_BATTERY_SUBGROUP: GUID;
pub extern const GUID_BATTERY_DISCHARGE_ACTION_0: GUID;
pub extern const GUID_BATTERY_DISCHARGE_LEVEL_0: GUID;
pub extern const GUID_BATTERY_DISCHARGE_FLAGS_0: GUID;
pub extern const GUID_BATTERY_DISCHARGE_ACTION_1: GUID;
pub extern const GUID_BATTERY_DISCHARGE_LEVEL_1: GUID;
pub extern const GUID_BATTERY_DISCHARGE_FLAGS_1: GUID;
pub extern const GUID_BATTERY_DISCHARGE_ACTION_2: GUID;
pub extern const GUID_BATTERY_DISCHARGE_LEVEL_2: GUID;
pub extern const GUID_BATTERY_DISCHARGE_FLAGS_2: GUID;
pub extern const GUID_BATTERY_DISCHARGE_ACTION_3: GUID;
pub extern const GUID_BATTERY_DISCHARGE_LEVEL_3: GUID;
pub extern const GUID_BATTERY_DISCHARGE_FLAGS_3: GUID;
pub extern const GUID_PROCESSOR_SETTINGS_SUBGROUP: GUID;
pub extern const GUID_PROCESSOR_THROTTLE_POLICY: GUID;
pub extern const GUID_PROCESSOR_THROTTLE_MAXIMUM: GUID;
pub extern const GUID_PROCESSOR_THROTTLE_MAXIMUM_1: GUID;
pub extern const GUID_PROCESSOR_THROTTLE_MINIMUM: GUID;
pub extern const GUID_PROCESSOR_THROTTLE_MINIMUM_1: GUID;
pub extern const GUID_PROCESSOR_FREQUENCY_LIMIT: GUID;
pub extern const GUID_PROCESSOR_FREQUENCY_LIMIT_1: GUID;
pub extern const GUID_PROCESSOR_ALLOW_THROTTLING: GUID;
pub extern const GUID_PROCESSOR_IDLESTATE_POLICY: GUID;
pub extern const GUID_PROCESSOR_PERFSTATE_POLICY: GUID;
pub extern const GUID_PROCESSOR_PERF_INCREASE_THRESHOLD: GUID;
pub extern const GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1: GUID;
pub extern const GUID_PROCESSOR_PERF_DECREASE_THRESHOLD: GUID;
pub extern const GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1: GUID;
pub extern const GUID_PROCESSOR_PERF_INCREASE_POLICY: GUID;
pub extern const GUID_PROCESSOR_PERF_INCREASE_POLICY_1: GUID;
pub extern const GUID_PROCESSOR_PERF_DECREASE_POLICY: GUID;
pub extern const GUID_PROCESSOR_PERF_DECREASE_POLICY_1: GUID;
pub extern const GUID_PROCESSOR_PERF_INCREASE_TIME: GUID;
pub extern const GUID_PROCESSOR_PERF_INCREASE_TIME_1: GUID;
pub extern const GUID_PROCESSOR_PERF_DECREASE_TIME: GUID;
pub extern const GUID_PROCESSOR_PERF_DECREASE_TIME_1: GUID;
pub extern const GUID_PROCESSOR_PERF_TIME_CHECK: GUID;
pub extern const GUID_PROCESSOR_PERF_BOOST_POLICY: GUID;
pub extern const GUID_PROCESSOR_PERF_BOOST_MODE: GUID;
pub extern const GUID_PROCESSOR_PERF_AUTONOMOUS_MODE: GUID;
pub extern const GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE: GUID;
pub extern const GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE_1: GUID;
pub extern const GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW: GUID;
pub extern const GUID_PROCESSOR_DUTY_CYCLING: GUID;
pub extern const GUID_PROCESSOR_IDLE_ALLOW_SCALING: GUID;
pub extern const GUID_PROCESSOR_IDLE_DISABLE: GUID;
pub extern const GUID_PROCESSOR_IDLE_STATE_MAXIMUM: GUID;
pub extern const GUID_PROCESSOR_IDLE_TIME_CHECK: GUID;
pub extern const GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD: GUID;
pub extern const GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD: GUID;
pub extern const GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD: GUID;
pub extern const GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD: GUID;
pub extern const GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY: GUID;
pub extern const GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY: GUID;
pub extern const GUID_PROCESSOR_CORE_PARKING_MAX_CORES: GUID;
pub extern const GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1: GUID;
pub extern const GUID_PROCESSOR_CORE_PARKING_MIN_CORES: GUID;
pub extern const GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1: GUID;
pub extern const GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME: GUID;
pub extern const GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME: GUID;
pub extern const GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR: GUID;
pub extern const GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD: GUID;
pub extern const GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING: GUID;
pub extern const GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR: GUID;
pub extern const GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD: GUID;
pub extern const GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING: GUID;
pub extern const GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD: GUID;
pub extern const GUID_PROCESSOR_PARKING_CORE_OVERRIDE: GUID;
pub extern const GUID_PROCESSOR_PARKING_PERF_STATE: GUID;
pub extern const GUID_PROCESSOR_PARKING_PERF_STATE_1: GUID;
pub extern const GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD: GUID;
pub extern const GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD: GUID;
pub extern const GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD: GUID;
pub extern const GUID_PROCESSOR_PERF_HISTORY: GUID;
pub extern const GUID_PROCESSOR_PERF_HISTORY_1: GUID;
pub extern const GUID_PROCESSOR_PERF_INCREASE_HISTORY: GUID;
pub extern const GUID_PROCESSOR_PERF_DECREASE_HISTORY: GUID;
pub extern const GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY: GUID;
pub extern const GUID_PROCESSOR_PERF_LATENCY_HINT: GUID;
pub extern const GUID_PROCESSOR_PERF_LATENCY_HINT_PERF: GUID;
pub extern const GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1: GUID;
pub extern const GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK: GUID;
pub extern const GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1: GUID;
pub extern const GUID_PROCESSOR_DISTRIBUTE_UTILITY: GUID;
pub extern const GUID_PROCESSOR_HETEROGENEOUS_POLICY: GUID;
pub extern const GUID_PROCESSOR_HETERO_DECREASE_TIME: GUID;
pub extern const GUID_PROCESSOR_HETERO_INCREASE_TIME: GUID;
pub extern const GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD: GUID;
pub extern const GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD: GUID;
pub extern const GUID_PROCESSOR_CLASS0_FLOOR_PERF: GUID;
pub extern const GUID_PROCESSOR_CLASS1_INITIAL_PERF: GUID;
pub extern const GUID_PROCESSOR_THREAD_SCHEDULING_POLICY: GUID;
pub extern const GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY: GUID;
pub extern const GUID_SYSTEM_COOLING_POLICY: GUID;
pub extern const GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD: GUID;
pub extern const GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD_1: GUID;
pub extern const GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD: GUID;
pub extern const GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD_1: GUID;
pub extern const GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME: GUID;
pub extern const GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME_1: GUID;
pub extern const GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME: GUID;
pub extern const GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME_1: GUID;
pub extern const GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING: GUID;
pub extern const GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING_1: GUID;
pub extern const GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR: GUID;
pub extern const GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR_1: GUID;
pub extern const GUID_LOCK_CONSOLE_ON_WAKE: GUID;
pub extern const GUID_DEVICE_IDLE_POLICY: GUID;
pub extern const GUID_CONNECTIVITY_IN_STANDBY: GUID;
pub extern const GUID_DISCONNECTED_STANDBY_MODE: GUID;
pub extern const GUID_ACDC_POWER_SOURCE: GUID;
pub extern const GUID_LIDSWITCH_STATE_CHANGE: GUID;
pub extern const GUID_BATTERY_PERCENTAGE_REMAINING: GUID;
pub extern const GUID_BATTERY_COUNT: GUID;
pub extern const GUID_GLOBAL_USER_PRESENCE: GUID;
pub extern const GUID_SESSION_DISPLAY_STATUS: GUID;
pub extern const GUID_SESSION_USER_PRESENCE: GUID;
pub extern const GUID_IDLE_BACKGROUND_TASK: GUID;
pub extern const GUID_BACKGROUND_TASK_NOTIFICATION: GUID;
pub extern const GUID_APPLAUNCH_BUTTON: GUID;
pub extern const GUID_PCIEXPRESS_SETTINGS_SUBGROUP: GUID;
pub extern const GUID_PCIEXPRESS_ASPM_POLICY: GUID;
pub extern const GUID_ENABLE_SWITCH_FORCED_SHUTDOWN: GUID;
pub extern const GUID_INTSTEER_SUBGROUP: GUID;
pub extern const GUID_INTSTEER_MODE: GUID;
pub extern const GUID_INTSTEER_LOAD_PER_PROC_TRIGGER: GUID;
pub extern const GUID_INTSTEER_TIME_UNPARK_TRIGGER: GUID;
pub extern const GUID_GRAPHICS_SUBGROUP: GUID;
pub extern const GUID_GPU_PREFERENCE_POLICY: GUID;
pub extern const GUID_MIXED_REALITY_MODE: GUID;
pub extern const GUID_SPR_ACTIVE_SESSION_CHANGE: GUID;
pub const PowerSystemUnspecified = enum__SYSTEM_POWER_STATE.PowerSystemUnspecified;
pub const PowerSystemWorking = enum__SYSTEM_POWER_STATE.PowerSystemWorking;
pub const PowerSystemSleeping1 = enum__SYSTEM_POWER_STATE.PowerSystemSleeping1;
pub const PowerSystemSleeping2 = enum__SYSTEM_POWER_STATE.PowerSystemSleeping2;
pub const PowerSystemSleeping3 = enum__SYSTEM_POWER_STATE.PowerSystemSleeping3;
pub const PowerSystemHibernate = enum__SYSTEM_POWER_STATE.PowerSystemHibernate;
pub const PowerSystemShutdown = enum__SYSTEM_POWER_STATE.PowerSystemShutdown;
pub const PowerSystemMaximum = enum__SYSTEM_POWER_STATE.PowerSystemMaximum;
pub const enum__SYSTEM_POWER_STATE = extern enum {
    PowerSystemUnspecified = 0,
    PowerSystemWorking = 1,
    PowerSystemSleeping1 = 2,
    PowerSystemSleeping2 = 3,
    PowerSystemSleeping3 = 4,
    PowerSystemHibernate = 5,
    PowerSystemShutdown = 6,
    PowerSystemMaximum = 7,
};
pub const SYSTEM_POWER_STATE = enum__SYSTEM_POWER_STATE;
pub const PSYSTEM_POWER_STATE = [*c]enum__SYSTEM_POWER_STATE;
pub const PowerActionNone = 0;
pub const PowerActionReserved = 1;
pub const PowerActionSleep = 2;
pub const PowerActionHibernate = 3;
pub const PowerActionShutdown = 4;
pub const PowerActionShutdownReset = 5;
pub const PowerActionShutdownOff = 6;
pub const PowerActionWarmEject = 7;
pub const PowerActionDisplayOff = 8;
pub const POWER_ACTION = extern enum {
    PowerActionNone = 0,
    PowerActionReserved = 1,
    PowerActionSleep = 2,
    PowerActionHibernate = 3,
    PowerActionShutdown = 4,
    PowerActionShutdownReset = 5,
    PowerActionShutdownOff = 6,
    PowerActionWarmEject = 7,
    PowerActionDisplayOff = 8,
};
pub const PPOWER_ACTION = [*c]extern enum {
    PowerActionNone = 0,
    PowerActionReserved = 1,
    PowerActionSleep = 2,
    PowerActionHibernate = 3,
    PowerActionShutdown = 4,
    PowerActionShutdownReset = 5,
    PowerActionShutdownOff = 6,
    PowerActionWarmEject = 7,
    PowerActionDisplayOff = 8,
};
pub const PowerDeviceUnspecified = enum__DEVICE_POWER_STATE.PowerDeviceUnspecified;
pub const PowerDeviceD0 = enum__DEVICE_POWER_STATE.PowerDeviceD0;
pub const PowerDeviceD1 = enum__DEVICE_POWER_STATE.PowerDeviceD1;
pub const PowerDeviceD2 = enum__DEVICE_POWER_STATE.PowerDeviceD2;
pub const PowerDeviceD3 = enum__DEVICE_POWER_STATE.PowerDeviceD3;
pub const PowerDeviceMaximum = enum__DEVICE_POWER_STATE.PowerDeviceMaximum;
pub const enum__DEVICE_POWER_STATE = extern enum {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0 = 1,
    PowerDeviceD1 = 2,
    PowerDeviceD2 = 3,
    PowerDeviceD3 = 4,
    PowerDeviceMaximum = 5,
};
pub const DEVICE_POWER_STATE = enum__DEVICE_POWER_STATE;
pub const PDEVICE_POWER_STATE = [*c]enum__DEVICE_POWER_STATE;
pub const PowerMonitorOff = enum__MONITOR_DISPLAY_STATE.PowerMonitorOff;
pub const PowerMonitorOn = enum__MONITOR_DISPLAY_STATE.PowerMonitorOn;
pub const PowerMonitorDim = enum__MONITOR_DISPLAY_STATE.PowerMonitorDim;
pub const enum__MONITOR_DISPLAY_STATE = extern enum {
    PowerMonitorOff = 0,
    PowerMonitorOn = 1,
    PowerMonitorDim = 2,
};
pub const MONITOR_DISPLAY_STATE = enum__MONITOR_DISPLAY_STATE;
pub const PMONITOR_DISPLAY_STATE = [*c]enum__MONITOR_DISPLAY_STATE;
pub const PowerUserPresent = enum__USER_ACTIVITY_PRESENCE.PowerUserPresent;
pub const PowerUserNotPresent = enum__USER_ACTIVITY_PRESENCE.PowerUserNotPresent;
pub const PowerUserInactive = enum__USER_ACTIVITY_PRESENCE.PowerUserInactive;
pub const PowerUserMaximum = enum__USER_ACTIVITY_PRESENCE.PowerUserMaximum;
pub const PowerUserInvalid = enum__USER_ACTIVITY_PRESENCE.PowerUserInvalid;
pub const enum__USER_ACTIVITY_PRESENCE = extern enum {
    PowerUserPresent = 0,
    PowerUserNotPresent = 1,
    PowerUserInactive = 2,
    PowerUserMaximum = 3,
    PowerUserInvalid = 3,
};
pub const USER_ACTIVITY_PRESENCE = enum__USER_ACTIVITY_PRESENCE;
pub const PUSER_ACTIVITY_PRESENCE = [*c]enum__USER_ACTIVITY_PRESENCE;
pub const EXECUTION_STATE = DWORD;
pub const PEXECUTION_STATE = [*c]DWORD;
pub const LT_DONT_CARE = 0;
pub const LT_LOWEST_LATENCY = 1;
pub const LATENCY_TIME = extern enum {
    LT_DONT_CARE = 0,
    LT_LOWEST_LATENCY = 1,
};
pub const PowerRequestDisplayRequired = enum__POWER_REQUEST_TYPE.PowerRequestDisplayRequired;
pub const PowerRequestSystemRequired = enum__POWER_REQUEST_TYPE.PowerRequestSystemRequired;
pub const PowerRequestAwayModeRequired = enum__POWER_REQUEST_TYPE.PowerRequestAwayModeRequired;
pub const PowerRequestExecutionRequired = enum__POWER_REQUEST_TYPE.PowerRequestExecutionRequired;
pub const enum__POWER_REQUEST_TYPE = extern enum {
    PowerRequestDisplayRequired,
    PowerRequestSystemRequired,
    PowerRequestAwayModeRequired,
    PowerRequestExecutionRequired,
};
pub const POWER_REQUEST_TYPE = enum__POWER_REQUEST_TYPE;
pub const PPOWER_REQUEST_TYPE = [*c]enum__POWER_REQUEST_TYPE;
pub const struct_CM_Power_Data_s = extern struct {
    PD_Size: DWORD,
    PD_MostRecentPowerState: DEVICE_POWER_STATE,
    PD_Capabilities: DWORD,
    PD_D1Latency: DWORD,
    PD_D2Latency: DWORD,
    PD_D3Latency: DWORD,
    PD_PowerStateMapping: [7]DEVICE_POWER_STATE,
    PD_DeepestSystemWake: SYSTEM_POWER_STATE,
};
pub const CM_POWER_DATA = struct_CM_Power_Data_s;
pub const PCM_POWER_DATA = [*c]struct_CM_Power_Data_s;
pub const SystemPowerPolicyAc = 0;
pub const SystemPowerPolicyDc = 1;
pub const VerifySystemPolicyAc = 2;
pub const VerifySystemPolicyDc = 3;
pub const SystemPowerCapabilities = 4;
pub const SystemBatteryState = 5;
pub const SystemPowerStateHandler = 6;
pub const ProcessorStateHandler = 7;
pub const SystemPowerPolicyCurrent = 8;
pub const AdministratorPowerPolicy = 9;
pub const SystemReserveHiberFile = 10;
pub const ProcessorInformation = 11;
pub const SystemPowerInformation = 12;
pub const ProcessorStateHandler2 = 13;
pub const LastWakeTime = 14;
pub const LastSleepTime = 15;
pub const SystemExecutionState = 16;
pub const SystemPowerStateNotifyHandler = 17;
pub const ProcessorPowerPolicyAc = 18;
pub const ProcessorPowerPolicyDc = 19;
pub const VerifyProcessorPowerPolicyAc = 20;
pub const VerifyProcessorPowerPolicyDc = 21;
pub const ProcessorPowerPolicyCurrent = 22;
pub const SystemPowerStateLogging = 23;
pub const SystemPowerLoggingEntry = 24;
pub const SetPowerSettingValue = 25;
pub const NotifyUserPowerSetting = 26;
pub const PowerInformationLevelUnused0 = 27;
pub const SystemMonitorHiberBootPowerOff = 28;
pub const SystemVideoState = 29;
pub const TraceApplicationPowerMessage = 30;
pub const TraceApplicationPowerMessageEnd = 31;
pub const ProcessorPerfStates = 32;
pub const ProcessorIdleStates = 33;
pub const ProcessorCap = 34;
pub const SystemWakeSource = 35;
pub const SystemHiberFileInformation = 36;
pub const TraceServicePowerMessage = 37;
pub const ProcessorLoad = 38;
pub const PowerShutdownNotification = 39;
pub const MonitorCapabilities = 40;
pub const SessionPowerInit = 41;
pub const SessionDisplayState = 42;
pub const PowerRequestCreate = 43;
pub const PowerRequestAction = 44;
pub const GetPowerRequestList = 45;
pub const ProcessorInformationEx = 46;
pub const NotifyUserModeLegacyPowerEvent = 47;
pub const GroupPark = 48;
pub const ProcessorIdleDomains = 49;
pub const WakeTimerList = 50;
pub const SystemHiberFileSize = 51;
pub const ProcessorIdleStatesHv = 52;
pub const ProcessorPerfStatesHv = 53;
pub const ProcessorPerfCapHv = 54;
pub const ProcessorSetIdle = 55;
pub const LogicalProcessorIdling = 56;
pub const UserPresence = 57;
pub const PowerSettingNotificationName = 58;
pub const GetPowerSettingValue = 59;
pub const IdleResiliency = 60;
pub const SessionRITState = 61;
pub const SessionConnectNotification = 62;
pub const SessionPowerCleanup = 63;
pub const SessionLockState = 64;
pub const SystemHiberbootState = 65;
pub const PlatformInformation = 66;
pub const PdcInvocation = 67;
pub const MonitorInvocation = 68;
pub const FirmwareTableInformationRegistered = 69;
pub const SetShutdownSelectedTime = 70;
pub const SuspendResumeInvocation = 71;
pub const PlmPowerRequestCreate = 72;
pub const ScreenOff = 73;
pub const CsDeviceNotification = 74;
pub const PlatformRole = 75;
pub const LastResumePerformance = 76;
pub const DisplayBurst = 77;
pub const ExitLatencySamplingPercentage = 78;
pub const RegisterSpmPowerSettings = 79;
pub const PlatformIdleStates = 80;
pub const ProcessorIdleVeto = 81;
pub const PlatformIdleVeto = 82;
pub const SystemBatteryStatePrecise = 83;
pub const ThermalEvent = 84;
pub const PowerRequestActionInternal = 85;
pub const BatteryDeviceState = 86;
pub const PowerInformationInternal = 87;
pub const ThermalStandby = 88;
pub const SystemHiberFileType = 89;
pub const PhysicalPowerButtonPress = 90;
pub const QueryPotentialDripsConstraint = 91;
pub const EnergyTrackerCreate = 92;
pub const EnergyTrackerQuery = 93;
pub const UpdateBlackBoxRecorder = 94;
pub const PowerInformationLevelMaximum = 95;
pub const POWER_INFORMATION_LEVEL = extern enum {
    SystemPowerPolicyAc = 0,
    SystemPowerPolicyDc = 1,
    VerifySystemPolicyAc = 2,
    VerifySystemPolicyDc = 3,
    SystemPowerCapabilities = 4,
    SystemBatteryState = 5,
    SystemPowerStateHandler = 6,
    ProcessorStateHandler = 7,
    SystemPowerPolicyCurrent = 8,
    AdministratorPowerPolicy = 9,
    SystemReserveHiberFile = 10,
    ProcessorInformation = 11,
    SystemPowerInformation = 12,
    ProcessorStateHandler2 = 13,
    LastWakeTime = 14,
    LastSleepTime = 15,
    SystemExecutionState = 16,
    SystemPowerStateNotifyHandler = 17,
    ProcessorPowerPolicyAc = 18,
    ProcessorPowerPolicyDc = 19,
    VerifyProcessorPowerPolicyAc = 20,
    VerifyProcessorPowerPolicyDc = 21,
    ProcessorPowerPolicyCurrent = 22,
    SystemPowerStateLogging = 23,
    SystemPowerLoggingEntry = 24,
    SetPowerSettingValue = 25,
    NotifyUserPowerSetting = 26,
    PowerInformationLevelUnused0 = 27,
    SystemMonitorHiberBootPowerOff = 28,
    SystemVideoState = 29,
    TraceApplicationPowerMessage = 30,
    TraceApplicationPowerMessageEnd = 31,
    ProcessorPerfStates = 32,
    ProcessorIdleStates = 33,
    ProcessorCap = 34,
    SystemWakeSource = 35,
    SystemHiberFileInformation = 36,
    TraceServicePowerMessage = 37,
    ProcessorLoad = 38,
    PowerShutdownNotification = 39,
    MonitorCapabilities = 40,
    SessionPowerInit = 41,
    SessionDisplayState = 42,
    PowerRequestCreate = 43,
    PowerRequestAction = 44,
    GetPowerRequestList = 45,
    ProcessorInformationEx = 46,
    NotifyUserModeLegacyPowerEvent = 47,
    GroupPark = 48,
    ProcessorIdleDomains = 49,
    WakeTimerList = 50,
    SystemHiberFileSize = 51,
    ProcessorIdleStatesHv = 52,
    ProcessorPerfStatesHv = 53,
    ProcessorPerfCapHv = 54,
    ProcessorSetIdle = 55,
    LogicalProcessorIdling = 56,
    UserPresence = 57,
    PowerSettingNotificationName = 58,
    GetPowerSettingValue = 59,
    IdleResiliency = 60,
    SessionRITState = 61,
    SessionConnectNotification = 62,
    SessionPowerCleanup = 63,
    SessionLockState = 64,
    SystemHiberbootState = 65,
    PlatformInformation = 66,
    PdcInvocation = 67,
    MonitorInvocation = 68,
    FirmwareTableInformationRegistered = 69,
    SetShutdownSelectedTime = 70,
    SuspendResumeInvocation = 71,
    PlmPowerRequestCreate = 72,
    ScreenOff = 73,
    CsDeviceNotification = 74,
    PlatformRole = 75,
    LastResumePerformance = 76,
    DisplayBurst = 77,
    ExitLatencySamplingPercentage = 78,
    RegisterSpmPowerSettings = 79,
    PlatformIdleStates = 80,
    ProcessorIdleVeto = 81,
    PlatformIdleVeto = 82,
    SystemBatteryStatePrecise = 83,
    ThermalEvent = 84,
    PowerRequestActionInternal = 85,
    BatteryDeviceState = 86,
    PowerInformationInternal = 87,
    ThermalStandby = 88,
    SystemHiberFileType = 89,
    PhysicalPowerButtonPress = 90,
    QueryPotentialDripsConstraint = 91,
    EnergyTrackerCreate = 92,
    EnergyTrackerQuery = 93,
    UpdateBlackBoxRecorder = 94,
    PowerInformationLevelMaximum = 95,
};
pub const UserNotPresent = 0;
pub const UserPresent = 1;
pub const UserUnknown = 255;
pub const POWER_USER_PRESENCE_TYPE = extern enum {
    UserNotPresent = 0,
    UserPresent = 1,
    UserUnknown = 255,
};
pub const PPOWER_USER_PRESENCE_TYPE = [*c]extern enum {
    UserNotPresent = 0,
    UserPresent = 1,
    UserUnknown = 255,
};
pub const struct__POWER_USER_PRESENCE = extern struct {
    UserPresence: POWER_USER_PRESENCE_TYPE,
};
pub const POWER_USER_PRESENCE = struct__POWER_USER_PRESENCE;
pub const PPOWER_USER_PRESENCE = [*c]struct__POWER_USER_PRESENCE;
pub const struct__POWER_SESSION_CONNECT = extern struct {
    Connected: BOOLEAN,
    Console: BOOLEAN,
};
pub const POWER_SESSION_CONNECT = struct__POWER_SESSION_CONNECT;
pub const PPOWER_SESSION_CONNECT = [*c]struct__POWER_SESSION_CONNECT;
pub const struct__POWER_SESSION_TIMEOUTS = extern struct {
    InputTimeout: DWORD,
    DisplayTimeout: DWORD,
};
pub const POWER_SESSION_TIMEOUTS = struct__POWER_SESSION_TIMEOUTS;
pub const PPOWER_SESSION_TIMEOUTS = [*c]struct__POWER_SESSION_TIMEOUTS;
pub const struct__POWER_SESSION_RIT_STATE = extern struct {
    Active: BOOLEAN,
    LastInputTime: DWORD,
};
pub const POWER_SESSION_RIT_STATE = struct__POWER_SESSION_RIT_STATE;
pub const PPOWER_SESSION_RIT_STATE = [*c]struct__POWER_SESSION_RIT_STATE;
pub const struct__POWER_SESSION_WINLOGON = extern struct {
    SessionId: DWORD,
    Console: BOOLEAN,
    Locked: BOOLEAN,
};
pub const POWER_SESSION_WINLOGON = struct__POWER_SESSION_WINLOGON;
pub const PPOWER_SESSION_WINLOGON = [*c]struct__POWER_SESSION_WINLOGON;
pub const struct__POWER_IDLE_RESILIENCY = extern struct {
    CoalescingTimeout: DWORD,
    IdleResiliencyPeriod: DWORD,
};
pub const POWER_IDLE_RESILIENCY = struct__POWER_IDLE_RESILIENCY;
pub const PPOWER_IDLE_RESILIENCY = [*c]struct__POWER_IDLE_RESILIENCY;
pub const MonitorRequestReasonUnknown = 0;
pub const MonitorRequestReasonPowerButton = 1;
pub const MonitorRequestReasonRemoteConnection = 2;
pub const MonitorRequestReasonScMonitorpower = 3;
pub const MonitorRequestReasonUserInput = 4;
pub const MonitorRequestReasonAcDcDisplayBurst = 5;
pub const MonitorRequestReasonUserDisplayBurst = 6;
pub const MonitorRequestReasonPoSetSystemState = 7;
pub const MonitorRequestReasonSetThreadExecutionState = 8;
pub const MonitorRequestReasonFullWake = 9;
pub const MonitorRequestReasonSessionUnlock = 10;
pub const MonitorRequestReasonScreenOffRequest = 11;
pub const MonitorRequestReasonIdleTimeout = 12;
pub const MonitorRequestReasonPolicyChange = 13;
pub const MonitorRequestReasonSleepButton = 14;
pub const MonitorRequestReasonLid = 15;
pub const MonitorRequestReasonBatteryCountChange = 16;
pub const MonitorRequestReasonGracePeriod = 17;
pub const MonitorRequestReasonPnP = 18;
pub const MonitorRequestReasonDP = 19;
pub const MonitorRequestReasonSxTransition = 20;
pub const MonitorRequestReasonSystemIdle = 21;
pub const MonitorRequestReasonNearProximity = 22;
pub const MonitorRequestReasonThermalStandby = 23;
pub const MonitorRequestReasonResumePdc = 24;
pub const MonitorRequestReasonResumeS4 = 25;
pub const MonitorRequestReasonTerminal = 26;
pub const MonitorRequestReasonPdcSignal = 27;
pub const MonitorRequestReasonAcDcDisplayBurstSuppressed = 28;
pub const MonitorRequestReasonSystemStateEntered = 29;
pub const MonitorRequestReasonWinrt = 30;
pub const MonitorRequestReasonUserInputKeyboard = 31;
pub const MonitorRequestReasonUserInputMouse = 32;
pub const MonitorRequestReasonUserInputTouch = 33;
pub const MonitorRequestReasonUserInputPen = 34;
pub const MonitorRequestReasonUserInputAccelerometer = 35;
pub const MonitorRequestReasonUserInputHid = 36;
pub const MonitorRequestReasonUserInputPoUserPresent = 37;
pub const MonitorRequestReasonUserInputSessionSwitch = 38;
pub const MonitorRequestReasonUserInputInitialization = 39;
pub const MonitorRequestReasonPdcSignalWindowsMobilePwrNotif = 40;
pub const MonitorRequestReasonPdcSignalWindowsMobileShell = 41;
pub const MonitorRequestReasonPdcSignalHeyCortana = 42;
pub const MonitorRequestReasonPdcSignalHolographicShell = 43;
pub const MonitorRequestReasonPdcSignalFingerprint = 44;
pub const MonitorRequestReasonDirectedDrips = 45;
pub const MonitorRequestReasonMax = 46;
pub const POWER_MONITOR_REQUEST_REASON = extern enum {
    MonitorRequestReasonUnknown = 0,
    MonitorRequestReasonPowerButton = 1,
    MonitorRequestReasonRemoteConnection = 2,
    MonitorRequestReasonScMonitorpower = 3,
    MonitorRequestReasonUserInput = 4,
    MonitorRequestReasonAcDcDisplayBurst = 5,
    MonitorRequestReasonUserDisplayBurst = 6,
    MonitorRequestReasonPoSetSystemState = 7,
    MonitorRequestReasonSetThreadExecutionState = 8,
    MonitorRequestReasonFullWake = 9,
    MonitorRequestReasonSessionUnlock = 10,
    MonitorRequestReasonScreenOffRequest = 11,
    MonitorRequestReasonIdleTimeout = 12,
    MonitorRequestReasonPolicyChange = 13,
    MonitorRequestReasonSleepButton = 14,
    MonitorRequestReasonLid = 15,
    MonitorRequestReasonBatteryCountChange = 16,
    MonitorRequestReasonGracePeriod = 17,
    MonitorRequestReasonPnP = 18,
    MonitorRequestReasonDP = 19,
    MonitorRequestReasonSxTransition = 20,
    MonitorRequestReasonSystemIdle = 21,
    MonitorRequestReasonNearProximity = 22,
    MonitorRequestReasonThermalStandby = 23,
    MonitorRequestReasonResumePdc = 24,
    MonitorRequestReasonResumeS4 = 25,
    MonitorRequestReasonTerminal = 26,
    MonitorRequestReasonPdcSignal = 27,
    MonitorRequestReasonAcDcDisplayBurstSuppressed = 28,
    MonitorRequestReasonSystemStateEntered = 29,
    MonitorRequestReasonWinrt = 30,
    MonitorRequestReasonUserInputKeyboard = 31,
    MonitorRequestReasonUserInputMouse = 32,
    MonitorRequestReasonUserInputTouch = 33,
    MonitorRequestReasonUserInputPen = 34,
    MonitorRequestReasonUserInputAccelerometer = 35,
    MonitorRequestReasonUserInputHid = 36,
    MonitorRequestReasonUserInputPoUserPresent = 37,
    MonitorRequestReasonUserInputSessionSwitch = 38,
    MonitorRequestReasonUserInputInitialization = 39,
    MonitorRequestReasonPdcSignalWindowsMobilePwrNotif = 40,
    MonitorRequestReasonPdcSignalWindowsMobileShell = 41,
    MonitorRequestReasonPdcSignalHeyCortana = 42,
    MonitorRequestReasonPdcSignalHolographicShell = 43,
    MonitorRequestReasonPdcSignalFingerprint = 44,
    MonitorRequestReasonDirectedDrips = 45,
    MonitorRequestReasonMax = 46,
};
pub const MonitorRequestTypeOff = enum__POWER_MONITOR_REQUEST_TYPE.MonitorRequestTypeOff;
pub const MonitorRequestTypeOnAndPresent = enum__POWER_MONITOR_REQUEST_TYPE.MonitorRequestTypeOnAndPresent;
pub const MonitorRequestTypeToggleOn = enum__POWER_MONITOR_REQUEST_TYPE.MonitorRequestTypeToggleOn;
pub const enum__POWER_MONITOR_REQUEST_TYPE = extern enum {
    MonitorRequestTypeOff,
    MonitorRequestTypeOnAndPresent,
    MonitorRequestTypeToggleOn,
};
pub const POWER_MONITOR_REQUEST_TYPE = enum__POWER_MONITOR_REQUEST_TYPE;
pub const struct__POWER_MONITOR_INVOCATION = extern struct {
    Console: BOOLEAN,
    RequestReason: POWER_MONITOR_REQUEST_REASON,
};
pub const POWER_MONITOR_INVOCATION = struct__POWER_MONITOR_INVOCATION;
pub const PPOWER_MONITOR_INVOCATION = [*c]struct__POWER_MONITOR_INVOCATION;
pub const struct__RESUME_PERFORMANCE = extern struct {
    PostTimeMs: DWORD,
    TotalResumeTimeMs: ULONGLONG,
    ResumeCompleteTimestamp: ULONGLONG,
};
pub const RESUME_PERFORMANCE = struct__RESUME_PERFORMANCE;
pub const PRESUME_PERFORMANCE = [*c]struct__RESUME_PERFORMANCE;
pub const PoAc = 0;
pub const PoDc = 1;
pub const PoHot = 2;
pub const PoConditionMaximum = 3;
pub const SYSTEM_POWER_CONDITION = extern enum {
    PoAc = 0,
    PoDc = 1,
    PoHot = 2,
    PoConditionMaximum = 3,
};
pub const SET_POWER_SETTING_VALUE = extern struct {
    Version: DWORD,
    Guid: GUID,
    PowerCondition: SYSTEM_POWER_CONDITION,
    DataLength: DWORD,
    Data: [1]BYTE,
};
pub const PSET_POWER_SETTING_VALUE = [*c]extern struct {
    Version: DWORD,
    Guid: GUID,
    PowerCondition: SYSTEM_POWER_CONDITION,
    DataLength: DWORD,
    Data: [1]BYTE,
};
pub const NOTIFY_USER_POWER_SETTING = extern struct {
    Guid: GUID,
};
pub const PNOTIFY_USER_POWER_SETTING = [*c]extern struct {
    Guid: GUID,
};
pub const struct__APPLICATIONLAUNCH_SETTING_VALUE = extern struct {
    ActivationTime: LARGE_INTEGER,
    Flags: DWORD,
    ButtonInstanceID: DWORD,
};
pub const APPLICATIONLAUNCH_SETTING_VALUE = struct__APPLICATIONLAUNCH_SETTING_VALUE;
pub const PAPPLICATIONLAUNCH_SETTING_VALUE = [*c]struct__APPLICATIONLAUNCH_SETTING_VALUE;
pub const PlatformRoleUnspecified = enum__POWER_PLATFORM_ROLE.PlatformRoleUnspecified;
pub const PlatformRoleDesktop = enum__POWER_PLATFORM_ROLE.PlatformRoleDesktop;
pub const PlatformRoleMobile = enum__POWER_PLATFORM_ROLE.PlatformRoleMobile;
pub const PlatformRoleWorkstation = enum__POWER_PLATFORM_ROLE.PlatformRoleWorkstation;
pub const PlatformRoleEnterpriseServer = enum__POWER_PLATFORM_ROLE.PlatformRoleEnterpriseServer;
pub const PlatformRoleSOHOServer = enum__POWER_PLATFORM_ROLE.PlatformRoleSOHOServer;
pub const PlatformRoleAppliancePC = enum__POWER_PLATFORM_ROLE.PlatformRoleAppliancePC;
pub const PlatformRolePerformanceServer = enum__POWER_PLATFORM_ROLE.PlatformRolePerformanceServer;
pub const PlatformRoleSlate = enum__POWER_PLATFORM_ROLE.PlatformRoleSlate;
pub const PlatformRoleMaximum = enum__POWER_PLATFORM_ROLE.PlatformRoleMaximum;
pub const enum__POWER_PLATFORM_ROLE = extern enum {
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop = 1,
    PlatformRoleMobile = 2,
    PlatformRoleWorkstation = 3,
    PlatformRoleEnterpriseServer = 4,
    PlatformRoleSOHOServer = 5,
    PlatformRoleAppliancePC = 6,
    PlatformRolePerformanceServer = 7,
    PlatformRoleSlate = 8,
    PlatformRoleMaximum = 9,
};
pub const POWER_PLATFORM_ROLE = enum__POWER_PLATFORM_ROLE;
pub const PPOWER_PLATFORM_ROLE = [*c]enum__POWER_PLATFORM_ROLE;
pub const struct__POWER_PLATFORM_INFORMATION = extern struct {
    AoAc: BOOLEAN,
};
pub const POWER_PLATFORM_INFORMATION = struct__POWER_PLATFORM_INFORMATION;
pub const PPOWER_PLATFORM_INFORMATION = [*c]struct__POWER_PLATFORM_INFORMATION;
pub const BATTERY_REPORTING_SCALE = extern struct {
    Granularity: DWORD,
    Capacity: DWORD,
};
pub const PBATTERY_REPORTING_SCALE = [*c]extern struct {
    Granularity: DWORD,
    Capacity: DWORD,
};
pub const PPM_WMI_LEGACY_PERFSTATE = extern struct {
    Frequency: DWORD,
    Flags: DWORD,
    PercentFrequency: DWORD,
};
pub const PPPM_WMI_LEGACY_PERFSTATE = [*c]extern struct {
    Frequency: DWORD,
    Flags: DWORD,
    PercentFrequency: DWORD,
};
pub const PPM_WMI_IDLE_STATE = extern struct {
    Latency: DWORD,
    Power: DWORD,
    TimeCheck: DWORD,
    PromotePercent: BYTE,
    DemotePercent: BYTE,
    StateType: BYTE,
    Reserved: BYTE,
    StateFlags: DWORD,
    Context: DWORD,
    IdleHandler: DWORD,
    Reserved1: DWORD,
};
pub const PPPM_WMI_IDLE_STATE = [*c]extern struct {
    Latency: DWORD,
    Power: DWORD,
    TimeCheck: DWORD,
    PromotePercent: BYTE,
    DemotePercent: BYTE,
    StateType: BYTE,
    Reserved: BYTE,
    StateFlags: DWORD,
    Context: DWORD,
    IdleHandler: DWORD,
    Reserved1: DWORD,
};
pub const PPM_WMI_IDLE_STATES = extern struct {
    Type: DWORD,
    Count: DWORD,
    TargetState: DWORD,
    OldState: DWORD,
    TargetProcessors: DWORD64,
    State: [1]PPM_WMI_IDLE_STATE,
};
pub const PPPM_WMI_IDLE_STATES = [*c]extern struct {
    Type: DWORD,
    Count: DWORD,
    TargetState: DWORD,
    OldState: DWORD,
    TargetProcessors: DWORD64,
    State: [1]PPM_WMI_IDLE_STATE,
};
pub const PPM_WMI_IDLE_STATES_EX = extern struct {
    Type: DWORD,
    Count: DWORD,
    TargetState: DWORD,
    OldState: DWORD,
    TargetProcessors: PVOID,
    State: [1]PPM_WMI_IDLE_STATE,
};
pub const PPPM_WMI_IDLE_STATES_EX = [*c]extern struct {
    Type: DWORD,
    Count: DWORD,
    TargetState: DWORD,
    OldState: DWORD,
    TargetProcessors: PVOID,
    State: [1]PPM_WMI_IDLE_STATE,
};
pub const PPM_WMI_PERF_STATE = extern struct {
    Frequency: DWORD,
    Power: DWORD,
    PercentFrequency: BYTE,
    IncreaseLevel: BYTE,
    DecreaseLevel: BYTE,
    Type: BYTE,
    IncreaseTime: DWORD,
    DecreaseTime: DWORD,
    Control: DWORD64,
    Status: DWORD64,
    HitCount: DWORD,
    Reserved1: DWORD,
    Reserved2: DWORD64,
    Reserved3: DWORD64,
};
pub const PPPM_WMI_PERF_STATE = [*c]extern struct {
    Frequency: DWORD,
    Power: DWORD,
    PercentFrequency: BYTE,
    IncreaseLevel: BYTE,
    DecreaseLevel: BYTE,
    Type: BYTE,
    IncreaseTime: DWORD,
    DecreaseTime: DWORD,
    Control: DWORD64,
    Status: DWORD64,
    HitCount: DWORD,
    Reserved1: DWORD,
    Reserved2: DWORD64,
    Reserved3: DWORD64,
};
pub const PPM_WMI_PERF_STATES = extern struct {
    Count: DWORD,
    MaxFrequency: DWORD,
    CurrentState: DWORD,
    MaxPerfState: DWORD,
    MinPerfState: DWORD,
    LowestPerfState: DWORD,
    ThermalConstraint: DWORD,
    BusyAdjThreshold: BYTE,
    PolicyType: BYTE,
    Type: BYTE,
    Reserved: BYTE,
    TimerInterval: DWORD,
    TargetProcessors: DWORD64,
    PStateHandler: DWORD,
    PStateContext: DWORD,
    TStateHandler: DWORD,
    TStateContext: DWORD,
    FeedbackHandler: DWORD,
    Reserved1: DWORD,
    Reserved2: DWORD64,
    State: [1]PPM_WMI_PERF_STATE,
};
pub const PPPM_WMI_PERF_STATES = [*c]extern struct {
    Count: DWORD,
    MaxFrequency: DWORD,
    CurrentState: DWORD,
    MaxPerfState: DWORD,
    MinPerfState: DWORD,
    LowestPerfState: DWORD,
    ThermalConstraint: DWORD,
    BusyAdjThreshold: BYTE,
    PolicyType: BYTE,
    Type: BYTE,
    Reserved: BYTE,
    TimerInterval: DWORD,
    TargetProcessors: DWORD64,
    PStateHandler: DWORD,
    PStateContext: DWORD,
    TStateHandler: DWORD,
    TStateContext: DWORD,
    FeedbackHandler: DWORD,
    Reserved1: DWORD,
    Reserved2: DWORD64,
    State: [1]PPM_WMI_PERF_STATE,
};
pub const PPM_WMI_PERF_STATES_EX = extern struct {
    Count: DWORD,
    MaxFrequency: DWORD,
    CurrentState: DWORD,
    MaxPerfState: DWORD,
    MinPerfState: DWORD,
    LowestPerfState: DWORD,
    ThermalConstraint: DWORD,
    BusyAdjThreshold: BYTE,
    PolicyType: BYTE,
    Type: BYTE,
    Reserved: BYTE,
    TimerInterval: DWORD,
    TargetProcessors: PVOID,
    PStateHandler: DWORD,
    PStateContext: DWORD,
    TStateHandler: DWORD,
    TStateContext: DWORD,
    FeedbackHandler: DWORD,
    Reserved1: DWORD,
    Reserved2: DWORD64,
    State: [1]PPM_WMI_PERF_STATE,
};
pub const PPPM_WMI_PERF_STATES_EX = [*c]extern struct {
    Count: DWORD,
    MaxFrequency: DWORD,
    CurrentState: DWORD,
    MaxPerfState: DWORD,
    MinPerfState: DWORD,
    LowestPerfState: DWORD,
    ThermalConstraint: DWORD,
    BusyAdjThreshold: BYTE,
    PolicyType: BYTE,
    Type: BYTE,
    Reserved: BYTE,
    TimerInterval: DWORD,
    TargetProcessors: PVOID,
    PStateHandler: DWORD,
    PStateContext: DWORD,
    TStateHandler: DWORD,
    TStateContext: DWORD,
    FeedbackHandler: DWORD,
    Reserved1: DWORD,
    Reserved2: DWORD64,
    State: [1]PPM_WMI_PERF_STATE,
};
pub const PPM_IDLE_STATE_ACCOUNTING = extern struct {
    IdleTransitions: DWORD,
    FailedTransitions: DWORD,
    InvalidBucketIndex: DWORD,
    TotalTime: DWORD64,
    IdleTimeBuckets: [6]DWORD,
};
pub const PPPM_IDLE_STATE_ACCOUNTING = [*c]extern struct {
    IdleTransitions: DWORD,
    FailedTransitions: DWORD,
    InvalidBucketIndex: DWORD,
    TotalTime: DWORD64,
    IdleTimeBuckets: [6]DWORD,
};
pub const PPM_IDLE_ACCOUNTING = extern struct {
    StateCount: DWORD,
    TotalTransitions: DWORD,
    ResetCount: DWORD,
    StartTime: DWORD64,
    State: [1]PPM_IDLE_STATE_ACCOUNTING,
};
pub const PPPM_IDLE_ACCOUNTING = [*c]extern struct {
    StateCount: DWORD,
    TotalTransitions: DWORD,
    ResetCount: DWORD,
    StartTime: DWORD64,
    State: [1]PPM_IDLE_STATE_ACCOUNTING,
};
pub const PPM_IDLE_STATE_BUCKET_EX = extern struct {
    TotalTimeUs: DWORD64,
    MinTimeUs: DWORD,
    MaxTimeUs: DWORD,
    Count: DWORD,
};
pub const PPPM_IDLE_STATE_BUCKET_EX = [*c]extern struct {
    TotalTimeUs: DWORD64,
    MinTimeUs: DWORD,
    MaxTimeUs: DWORD,
    Count: DWORD,
};
pub const PPM_IDLE_STATE_ACCOUNTING_EX = extern struct {
    TotalTime: DWORD64,
    IdleTransitions: DWORD,
    FailedTransitions: DWORD,
    InvalidBucketIndex: DWORD,
    MinTimeUs: DWORD,
    MaxTimeUs: DWORD,
    CancelledTransitions: DWORD,
    IdleTimeBuckets: [16]PPM_IDLE_STATE_BUCKET_EX,
};
pub const PPPM_IDLE_STATE_ACCOUNTING_EX = [*c]extern struct {
    TotalTime: DWORD64,
    IdleTransitions: DWORD,
    FailedTransitions: DWORD,
    InvalidBucketIndex: DWORD,
    MinTimeUs: DWORD,
    MaxTimeUs: DWORD,
    CancelledTransitions: DWORD,
    IdleTimeBuckets: [16]PPM_IDLE_STATE_BUCKET_EX,
};
pub const PPM_IDLE_ACCOUNTING_EX = extern struct {
    StateCount: DWORD,
    TotalTransitions: DWORD,
    ResetCount: DWORD,
    AbortCount: DWORD,
    StartTime: DWORD64,
    State: [1]PPM_IDLE_STATE_ACCOUNTING_EX,
};
pub const PPPM_IDLE_ACCOUNTING_EX = [*c]extern struct {
    StateCount: DWORD,
    TotalTransitions: DWORD,
    ResetCount: DWORD,
    AbortCount: DWORD,
    StartTime: DWORD64,
    State: [1]PPM_IDLE_STATE_ACCOUNTING_EX,
};
pub extern const PPM_PERFSTATE_CHANGE_GUID: GUID;
pub extern const PPM_PERFSTATE_DOMAIN_CHANGE_GUID: GUID;
pub extern const PPM_IDLESTATE_CHANGE_GUID: GUID;
pub extern const PPM_PERFSTATES_DATA_GUID: GUID;
pub extern const PPM_IDLESTATES_DATA_GUID: GUID;
pub extern const PPM_IDLE_ACCOUNTING_GUID: GUID;
pub extern const PPM_IDLE_ACCOUNTING_EX_GUID: GUID;
pub extern const PPM_THERMALCONSTRAINT_GUID: GUID;
pub extern const PPM_PERFMON_PERFSTATE_GUID: GUID;
pub extern const PPM_THERMAL_POLICY_CHANGE_GUID: GUID;
pub const PPM_PERFSTATE_EVENT = extern struct {
    State: DWORD,
    Status: DWORD,
    Latency: DWORD,
    Speed: DWORD,
    Processor: DWORD,
};
pub const PPPM_PERFSTATE_EVENT = [*c]extern struct {
    State: DWORD,
    Status: DWORD,
    Latency: DWORD,
    Speed: DWORD,
    Processor: DWORD,
};
pub const PPM_PERFSTATE_DOMAIN_EVENT = extern struct {
    State: DWORD,
    Latency: DWORD,
    Speed: DWORD,
    Processors: DWORD64,
};
pub const PPPM_PERFSTATE_DOMAIN_EVENT = [*c]extern struct {
    State: DWORD,
    Latency: DWORD,
    Speed: DWORD,
    Processors: DWORD64,
};
pub const PPM_IDLESTATE_EVENT = extern struct {
    NewState: DWORD,
    OldState: DWORD,
    Processors: DWORD64,
};
pub const PPPM_IDLESTATE_EVENT = [*c]extern struct {
    NewState: DWORD,
    OldState: DWORD,
    Processors: DWORD64,
};
pub const PPM_THERMALCHANGE_EVENT = extern struct {
    ThermalConstraint: DWORD,
    Processors: DWORD64,
};
pub const PPPM_THERMALCHANGE_EVENT = [*c]extern struct {
    ThermalConstraint: DWORD,
    Processors: DWORD64,
};
pub const PPM_THERMAL_POLICY_EVENT = extern struct {
    Mode: BYTE,
    Processors: DWORD64,
};
pub const PPPM_THERMAL_POLICY_EVENT = [*c]extern struct {
    Mode: BYTE,
    Processors: DWORD64,
};
pub const POWER_ACTION_POLICY = extern struct {
    Action: POWER_ACTION,
    Flags: DWORD,
    EventCode: DWORD,
};
pub const PPOWER_ACTION_POLICY = [*c]extern struct {
    Action: POWER_ACTION,
    Flags: DWORD,
    EventCode: DWORD,
};
pub const SYSTEM_POWER_LEVEL = extern struct {
    Enable: BOOLEAN,
    Spare: [3]BYTE,
    BatteryLevel: DWORD,
    PowerPolicy: POWER_ACTION_POLICY,
    MinSystemState: SYSTEM_POWER_STATE,
};
pub const PSYSTEM_POWER_LEVEL = [*c]extern struct {
    Enable: BOOLEAN,
    Spare: [3]BYTE,
    BatteryLevel: DWORD,
    PowerPolicy: POWER_ACTION_POLICY,
    MinSystemState: SYSTEM_POWER_STATE,
};
pub const struct__SYSTEM_POWER_POLICY = extern struct {
    Revision: DWORD,
    PowerButton: POWER_ACTION_POLICY,
    SleepButton: POWER_ACTION_POLICY,
    LidClose: POWER_ACTION_POLICY,
    LidOpenWake: SYSTEM_POWER_STATE,
    Reserved: DWORD,
    Idle: POWER_ACTION_POLICY,
    IdleTimeout: DWORD,
    IdleSensitivity: BYTE,
    DynamicThrottle: BYTE,
    Spare2: [2]BYTE,
    MinSleep: SYSTEM_POWER_STATE,
    MaxSleep: SYSTEM_POWER_STATE,
    ReducedLatencySleep: SYSTEM_POWER_STATE,
    WinLogonFlags: DWORD,
    Spare3: DWORD,
    DozeS4Timeout: DWORD,
    BroadcastCapacityResolution: DWORD,
    DischargePolicy: [4]SYSTEM_POWER_LEVEL,
    VideoTimeout: DWORD,
    VideoDimDisplay: BOOLEAN,
    VideoReserved: [3]DWORD,
    SpindownTimeout: DWORD,
    OptimizeForPower: BOOLEAN,
    FanThrottleTolerance: BYTE,
    ForcedThrottle: BYTE,
    MinThrottle: BYTE,
    OverThrottled: POWER_ACTION_POLICY,
};
pub const SYSTEM_POWER_POLICY = struct__SYSTEM_POWER_POLICY;
pub const PSYSTEM_POWER_POLICY = [*c]struct__SYSTEM_POWER_POLICY;
pub const PROCESSOR_IDLESTATE_INFO = extern struct {
    TimeCheck: DWORD,
    DemotePercent: BYTE,
    PromotePercent: BYTE,
    Spare: [2]BYTE,
};
pub const PPROCESSOR_IDLESTATE_INFO = [*c]extern struct {
    TimeCheck: DWORD,
    DemotePercent: BYTE,
    PromotePercent: BYTE,
    Spare: [2]BYTE,
};
pub const PROCESSOR_IDLESTATE_POLICY = extern struct {
    Revision: WORD,
    Flags: extern union {
        AsWORD: WORD,
        @"": @OpaqueType(),
    },
    PolicyCount: DWORD,
    Policy: [3]PROCESSOR_IDLESTATE_INFO,
};
pub const PPROCESSOR_IDLESTATE_POLICY = [*c]extern struct {
    Revision: WORD,
    Flags: extern union {
        AsWORD: WORD,
        @"": @OpaqueType(),
    },
    PolicyCount: DWORD,
    Policy: [3]PROCESSOR_IDLESTATE_INFO,
};
pub const struct__PROCESSOR_POWER_POLICY_INFO = @OpaqueType();
pub const PROCESSOR_POWER_POLICY_INFO = struct__PROCESSOR_POWER_POLICY_INFO;
pub const PPROCESSOR_POWER_POLICY_INFO = ?*struct__PROCESSOR_POWER_POLICY_INFO;
pub const struct__PROCESSOR_POWER_POLICY = @OpaqueType();
pub const PROCESSOR_POWER_POLICY = struct__PROCESSOR_POWER_POLICY;
pub const PPROCESSOR_POWER_POLICY = ?*struct__PROCESSOR_POWER_POLICY;
pub const PROCESSOR_PERFSTATE_POLICY = extern struct {
    Revision: DWORD,
    MaxThrottle: BYTE,
    MinThrottle: BYTE,
    BusyAdjThreshold: BYTE,
    @"": extern union {
        Spare: BYTE,
        Flags: extern union {
            AsBYTE: BYTE,
            @"": @OpaqueType(),
        },
    },
    TimeCheck: DWORD,
    IncreaseTime: DWORD,
    DecreaseTime: DWORD,
    IncreasePercent: DWORD,
    DecreasePercent: DWORD,
};
pub const PPROCESSOR_PERFSTATE_POLICY = [*c]extern struct {
    Revision: DWORD,
    MaxThrottle: BYTE,
    MinThrottle: BYTE,
    BusyAdjThreshold: BYTE,
    @"": extern union {
        Spare: BYTE,
        Flags: extern union {
            AsBYTE: BYTE,
            @"": @OpaqueType(),
        },
    },
    TimeCheck: DWORD,
    IncreaseTime: DWORD,
    DecreaseTime: DWORD,
    IncreasePercent: DWORD,
    DecreasePercent: DWORD,
};
pub const struct__ADMINISTRATOR_POWER_POLICY = extern struct {
    MinSleep: SYSTEM_POWER_STATE,
    MaxSleep: SYSTEM_POWER_STATE,
    MinVideoTimeout: DWORD,
    MaxVideoTimeout: DWORD,
    MinSpindownTimeout: DWORD,
    MaxSpindownTimeout: DWORD,
};
pub const ADMINISTRATOR_POWER_POLICY = struct__ADMINISTRATOR_POWER_POLICY;
pub const PADMINISTRATOR_POWER_POLICY = [*c]struct__ADMINISTRATOR_POWER_POLICY;
pub const HiberFileBucket1GB = enum__HIBERFILE_BUCKET_SIZE.HiberFileBucket1GB;
pub const HiberFileBucket2GB = enum__HIBERFILE_BUCKET_SIZE.HiberFileBucket2GB;
pub const HiberFileBucket4GB = enum__HIBERFILE_BUCKET_SIZE.HiberFileBucket4GB;
pub const HiberFileBucket8GB = enum__HIBERFILE_BUCKET_SIZE.HiberFileBucket8GB;
pub const HiberFileBucket16GB = enum__HIBERFILE_BUCKET_SIZE.HiberFileBucket16GB;
pub const HiberFileBucket32GB = enum__HIBERFILE_BUCKET_SIZE.HiberFileBucket32GB;
pub const HiberFileBucketUnlimited = enum__HIBERFILE_BUCKET_SIZE.HiberFileBucketUnlimited;
pub const HiberFileBucketMax = enum__HIBERFILE_BUCKET_SIZE.HiberFileBucketMax;
pub const enum__HIBERFILE_BUCKET_SIZE = extern enum {
    HiberFileBucket1GB = 0,
    HiberFileBucket2GB = 1,
    HiberFileBucket4GB = 2,
    HiberFileBucket8GB = 3,
    HiberFileBucket16GB = 4,
    HiberFileBucket32GB = 5,
    HiberFileBucketUnlimited = 6,
    HiberFileBucketMax = 7,
};
pub const HIBERFILE_BUCKET_SIZE = enum__HIBERFILE_BUCKET_SIZE;
pub const PHIBERFILE_BUCKET_SIZE = [*c]enum__HIBERFILE_BUCKET_SIZE;
pub const struct__HIBERFILE_BUCKET = extern struct {
    MaxPhysicalMemory: DWORD64,
    PhysicalMemoryPercent: [3]DWORD,
};
pub const HIBERFILE_BUCKET = struct__HIBERFILE_BUCKET;
pub const PHIBERFILE_BUCKET = [*c]struct__HIBERFILE_BUCKET;
pub const SYSTEM_POWER_CAPABILITIES = extern struct {
    PowerButtonPresent: BOOLEAN,
    SleepButtonPresent: BOOLEAN,
    LidPresent: BOOLEAN,
    SystemS1: BOOLEAN,
    SystemS2: BOOLEAN,
    SystemS3: BOOLEAN,
    SystemS4: BOOLEAN,
    SystemS5: BOOLEAN,
    HiberFilePresent: BOOLEAN,
    FullWake: BOOLEAN,
    VideoDimPresent: BOOLEAN,
    ApmPresent: BOOLEAN,
    UpsPresent: BOOLEAN,
    ThermalControl: BOOLEAN,
    ProcessorThrottle: BOOLEAN,
    ProcessorMinThrottle: BYTE,
    ProcessorMaxThrottle: BYTE,
    FastSystemS4: BOOLEAN,
    Hiberboot: BOOLEAN,
    WakeAlarmPresent: BOOLEAN,
    AoAc: BOOLEAN,
    DiskSpinDown: BOOLEAN,
    HiberFileType: BYTE,
    AoAcConnectivitySupported: BOOLEAN,
    spare3: [6]BYTE,
    SystemBatteriesPresent: BOOLEAN,
    BatteriesAreShortTerm: BOOLEAN,
    BatteryScale: [3]BATTERY_REPORTING_SCALE,
    AcOnLineWake: SYSTEM_POWER_STATE,
    SoftLidWake: SYSTEM_POWER_STATE,
    RtcWake: SYSTEM_POWER_STATE,
    MinDeviceWakeState: SYSTEM_POWER_STATE,
    DefaultLowLatencyWake: SYSTEM_POWER_STATE,
};
pub const PSYSTEM_POWER_CAPABILITIES = [*c]extern struct {
    PowerButtonPresent: BOOLEAN,
    SleepButtonPresent: BOOLEAN,
    LidPresent: BOOLEAN,
    SystemS1: BOOLEAN,
    SystemS2: BOOLEAN,
    SystemS3: BOOLEAN,
    SystemS4: BOOLEAN,
    SystemS5: BOOLEAN,
    HiberFilePresent: BOOLEAN,
    FullWake: BOOLEAN,
    VideoDimPresent: BOOLEAN,
    ApmPresent: BOOLEAN,
    UpsPresent: BOOLEAN,
    ThermalControl: BOOLEAN,
    ProcessorThrottle: BOOLEAN,
    ProcessorMinThrottle: BYTE,
    ProcessorMaxThrottle: BYTE,
    FastSystemS4: BOOLEAN,
    Hiberboot: BOOLEAN,
    WakeAlarmPresent: BOOLEAN,
    AoAc: BOOLEAN,
    DiskSpinDown: BOOLEAN,
    HiberFileType: BYTE,
    AoAcConnectivitySupported: BOOLEAN,
    spare3: [6]BYTE,
    SystemBatteriesPresent: BOOLEAN,
    BatteriesAreShortTerm: BOOLEAN,
    BatteryScale: [3]BATTERY_REPORTING_SCALE,
    AcOnLineWake: SYSTEM_POWER_STATE,
    SoftLidWake: SYSTEM_POWER_STATE,
    RtcWake: SYSTEM_POWER_STATE,
    MinDeviceWakeState: SYSTEM_POWER_STATE,
    DefaultLowLatencyWake: SYSTEM_POWER_STATE,
};
pub const SYSTEM_BATTERY_STATE = extern struct {
    AcOnLine: BOOLEAN,
    BatteryPresent: BOOLEAN,
    Charging: BOOLEAN,
    Discharging: BOOLEAN,
    Spare1: [3]BOOLEAN,
    Tag: BYTE,
    MaxCapacity: DWORD,
    RemainingCapacity: DWORD,
    Rate: DWORD,
    EstimatedTime: DWORD,
    DefaultAlert1: DWORD,
    DefaultAlert2: DWORD,
};
pub const PSYSTEM_BATTERY_STATE = [*c]extern struct {
    AcOnLine: BOOLEAN,
    BatteryPresent: BOOLEAN,
    Charging: BOOLEAN,
    Discharging: BOOLEAN,
    Spare1: [3]BOOLEAN,
    Tag: BYTE,
    MaxCapacity: DWORD,
    RemainingCapacity: DWORD,
    Rate: DWORD,
    EstimatedTime: DWORD,
    DefaultAlert1: DWORD,
    DefaultAlert2: DWORD,
};
pub const struct__IMAGE_DOS_HEADER = extern struct {
    e_magic: WORD,
    e_cblp: WORD,
    e_cp: WORD,
    e_crlc: WORD,
    e_cparhdr: WORD,
    e_minalloc: WORD,
    e_maxalloc: WORD,
    e_ss: WORD,
    e_sp: WORD,
    e_csum: WORD,
    e_ip: WORD,
    e_cs: WORD,
    e_lfarlc: WORD,
    e_ovno: WORD,
    e_res: [4]WORD,
    e_oemid: WORD,
    e_oeminfo: WORD,
    e_res2: [10]WORD,
    e_lfanew: LONG,
};
pub const IMAGE_DOS_HEADER = struct__IMAGE_DOS_HEADER;
pub const PIMAGE_DOS_HEADER = [*c]struct__IMAGE_DOS_HEADER;
pub const struct__IMAGE_OS2_HEADER = extern struct {
    ne_magic: WORD,
    ne_ver: CHAR,
    ne_rev: CHAR,
    ne_enttab: WORD,
    ne_cbenttab: WORD,
    ne_crc: LONG,
    ne_flags: WORD,
    ne_autodata: WORD,
    ne_heap: WORD,
    ne_stack: WORD,
    ne_csip: LONG,
    ne_sssp: LONG,
    ne_cseg: WORD,
    ne_cmod: WORD,
    ne_cbnrestab: WORD,
    ne_segtab: WORD,
    ne_rsrctab: WORD,
    ne_restab: WORD,
    ne_modtab: WORD,
    ne_imptab: WORD,
    ne_nrestab: LONG,
    ne_cmovent: WORD,
    ne_align: WORD,
    ne_cres: WORD,
    ne_exetyp: BYTE,
    ne_flagsothers: BYTE,
    ne_pretthunks: WORD,
    ne_psegrefbytes: WORD,
    ne_swaparea: WORD,
    ne_expver: WORD,
};
pub const IMAGE_OS2_HEADER = struct__IMAGE_OS2_HEADER;
pub const PIMAGE_OS2_HEADER = [*c]struct__IMAGE_OS2_HEADER;
pub const struct__IMAGE_VXD_HEADER = extern struct {
    e32_magic: WORD,
    e32_border: BYTE,
    e32_worder: BYTE,
    e32_level: DWORD,
    e32_cpu: WORD,
    e32_os: WORD,
    e32_ver: DWORD,
    e32_mflags: DWORD,
    e32_mpages: DWORD,
    e32_startobj: DWORD,
    e32_eip: DWORD,
    e32_stackobj: DWORD,
    e32_esp: DWORD,
    e32_pagesize: DWORD,
    e32_lastpagesize: DWORD,
    e32_fixupsize: DWORD,
    e32_fixupsum: DWORD,
    e32_ldrsize: DWORD,
    e32_ldrsum: DWORD,
    e32_objtab: DWORD,
    e32_objcnt: DWORD,
    e32_objmap: DWORD,
    e32_itermap: DWORD,
    e32_rsrctab: DWORD,
    e32_rsrccnt: DWORD,
    e32_restab: DWORD,
    e32_enttab: DWORD,
    e32_dirtab: DWORD,
    e32_dircnt: DWORD,
    e32_fpagetab: DWORD,
    e32_frectab: DWORD,
    e32_impmod: DWORD,
    e32_impmodcnt: DWORD,
    e32_impproc: DWORD,
    e32_pagesum: DWORD,
    e32_datapage: DWORD,
    e32_preload: DWORD,
    e32_nrestab: DWORD,
    e32_cbnrestab: DWORD,
    e32_nressum: DWORD,
    e32_autodata: DWORD,
    e32_debuginfo: DWORD,
    e32_debuglen: DWORD,
    e32_instpreload: DWORD,
    e32_instdemand: DWORD,
    e32_heapsize: DWORD,
    e32_res3: [12]BYTE,
    e32_winresoff: DWORD,
    e32_winreslen: DWORD,
    e32_devid: WORD,
    e32_ddkver: WORD,
};
pub const IMAGE_VXD_HEADER = struct__IMAGE_VXD_HEADER;
pub const PIMAGE_VXD_HEADER = [*c]struct__IMAGE_VXD_HEADER;
pub const struct__IMAGE_FILE_HEADER = extern struct {
    Machine: WORD,
    NumberOfSections: WORD,
    TimeDateStamp: DWORD,
    PointerToSymbolTable: DWORD,
    NumberOfSymbols: DWORD,
    SizeOfOptionalHeader: WORD,
    Characteristics: WORD,
};
pub const IMAGE_FILE_HEADER = struct__IMAGE_FILE_HEADER;
pub const PIMAGE_FILE_HEADER = [*c]struct__IMAGE_FILE_HEADER;
pub const struct__IMAGE_DATA_DIRECTORY = extern struct {
    VirtualAddress: DWORD,
    Size: DWORD,
};
pub const IMAGE_DATA_DIRECTORY = struct__IMAGE_DATA_DIRECTORY;
pub const PIMAGE_DATA_DIRECTORY = [*c]struct__IMAGE_DATA_DIRECTORY;
pub const struct__IMAGE_OPTIONAL_HEADER = extern struct {
    Magic: WORD,
    MajorLinkerVersion: BYTE,
    MinorLinkerVersion: BYTE,
    SizeOfCode: DWORD,
    SizeOfInitializedData: DWORD,
    SizeOfUninitializedData: DWORD,
    AddressOfEntryPoint: DWORD,
    BaseOfCode: DWORD,
    BaseOfData: DWORD,
    ImageBase: DWORD,
    SectionAlignment: DWORD,
    FileAlignment: DWORD,
    MajorOperatingSystemVersion: WORD,
    MinorOperatingSystemVersion: WORD,
    MajorImageVersion: WORD,
    MinorImageVersion: WORD,
    MajorSubsystemVersion: WORD,
    MinorSubsystemVersion: WORD,
    Win32VersionValue: DWORD,
    SizeOfImage: DWORD,
    SizeOfHeaders: DWORD,
    CheckSum: DWORD,
    Subsystem: WORD,
    DllCharacteristics: WORD,
    SizeOfStackReserve: DWORD,
    SizeOfStackCommit: DWORD,
    SizeOfHeapReserve: DWORD,
    SizeOfHeapCommit: DWORD,
    LoaderFlags: DWORD,
    NumberOfRvaAndSizes: DWORD,
    DataDirectory: [16]IMAGE_DATA_DIRECTORY,
};
pub const IMAGE_OPTIONAL_HEADER32 = struct__IMAGE_OPTIONAL_HEADER;
pub const PIMAGE_OPTIONAL_HEADER32 = [*c]struct__IMAGE_OPTIONAL_HEADER;
pub const struct__IMAGE_ROM_OPTIONAL_HEADER = extern struct {
    Magic: WORD,
    MajorLinkerVersion: BYTE,
    MinorLinkerVersion: BYTE,
    SizeOfCode: DWORD,
    SizeOfInitializedData: DWORD,
    SizeOfUninitializedData: DWORD,
    AddressOfEntryPoint: DWORD,
    BaseOfCode: DWORD,
    BaseOfData: DWORD,
    BaseOfBss: DWORD,
    GprMask: DWORD,
    CprMask: [4]DWORD,
    GpValue: DWORD,
};
pub const IMAGE_ROM_OPTIONAL_HEADER = struct__IMAGE_ROM_OPTIONAL_HEADER;
pub const PIMAGE_ROM_OPTIONAL_HEADER = [*c]struct__IMAGE_ROM_OPTIONAL_HEADER;
pub const struct__IMAGE_OPTIONAL_HEADER64 = extern struct {
    Magic: WORD,
    MajorLinkerVersion: BYTE,
    MinorLinkerVersion: BYTE,
    SizeOfCode: DWORD,
    SizeOfInitializedData: DWORD,
    SizeOfUninitializedData: DWORD,
    AddressOfEntryPoint: DWORD,
    BaseOfCode: DWORD,
    ImageBase: ULONGLONG,
    SectionAlignment: DWORD,
    FileAlignment: DWORD,
    MajorOperatingSystemVersion: WORD,
    MinorOperatingSystemVersion: WORD,
    MajorImageVersion: WORD,
    MinorImageVersion: WORD,
    MajorSubsystemVersion: WORD,
    MinorSubsystemVersion: WORD,
    Win32VersionValue: DWORD,
    SizeOfImage: DWORD,
    SizeOfHeaders: DWORD,
    CheckSum: DWORD,
    Subsystem: WORD,
    DllCharacteristics: WORD,
    SizeOfStackReserve: ULONGLONG,
    SizeOfStackCommit: ULONGLONG,
    SizeOfHeapReserve: ULONGLONG,
    SizeOfHeapCommit: ULONGLONG,
    LoaderFlags: DWORD,
    NumberOfRvaAndSizes: DWORD,
    DataDirectory: [16]IMAGE_DATA_DIRECTORY,
};
pub const IMAGE_OPTIONAL_HEADER64 = struct__IMAGE_OPTIONAL_HEADER64;
pub const PIMAGE_OPTIONAL_HEADER64 = [*c]struct__IMAGE_OPTIONAL_HEADER64;
pub const IMAGE_OPTIONAL_HEADER = IMAGE_OPTIONAL_HEADER64;
pub const PIMAGE_OPTIONAL_HEADER = PIMAGE_OPTIONAL_HEADER64;
pub const struct__IMAGE_NT_HEADERS64 = extern struct {
    Signature: DWORD,
    FileHeader: IMAGE_FILE_HEADER,
    OptionalHeader: IMAGE_OPTIONAL_HEADER64,
};
pub const IMAGE_NT_HEADERS64 = struct__IMAGE_NT_HEADERS64;
pub const PIMAGE_NT_HEADERS64 = [*c]struct__IMAGE_NT_HEADERS64;
pub const struct__IMAGE_NT_HEADERS = extern struct {
    Signature: DWORD,
    FileHeader: IMAGE_FILE_HEADER,
    OptionalHeader: IMAGE_OPTIONAL_HEADER32,
};
pub const IMAGE_NT_HEADERS32 = struct__IMAGE_NT_HEADERS;
pub const PIMAGE_NT_HEADERS32 = [*c]struct__IMAGE_NT_HEADERS;
pub const struct__IMAGE_ROM_HEADERS = extern struct {
    FileHeader: IMAGE_FILE_HEADER,
    OptionalHeader: IMAGE_ROM_OPTIONAL_HEADER,
};
pub const IMAGE_ROM_HEADERS = struct__IMAGE_ROM_HEADERS;
pub const PIMAGE_ROM_HEADERS = [*c]struct__IMAGE_ROM_HEADERS;
pub const IMAGE_NT_HEADERS = IMAGE_NT_HEADERS64;
pub const PIMAGE_NT_HEADERS = PIMAGE_NT_HEADERS64;
pub const struct_ANON_OBJECT_HEADER = extern struct {
    Sig1: WORD,
    Sig2: WORD,
    Version: WORD,
    Machine: WORD,
    TimeDateStamp: DWORD,
    ClassID: CLSID,
    SizeOfData: DWORD,
};
pub const ANON_OBJECT_HEADER = struct_ANON_OBJECT_HEADER;
pub const struct_ANON_OBJECT_HEADER_V2 = extern struct {
    Sig1: WORD,
    Sig2: WORD,
    Version: WORD,
    Machine: WORD,
    TimeDateStamp: DWORD,
    ClassID: CLSID,
    SizeOfData: DWORD,
    Flags: DWORD,
    MetaDataSize: DWORD,
    MetaDataOffset: DWORD,
};
pub const ANON_OBJECT_HEADER_V2 = struct_ANON_OBJECT_HEADER_V2;
pub const struct_ANON_OBJECT_HEADER_BIGOBJ = extern struct {
    Sig1: WORD,
    Sig2: WORD,
    Version: WORD,
    Machine: WORD,
    TimeDateStamp: DWORD,
    ClassID: CLSID,
    SizeOfData: DWORD,
    Flags: DWORD,
    MetaDataSize: DWORD,
    MetaDataOffset: DWORD,
    NumberOfSections: DWORD,
    PointerToSymbolTable: DWORD,
    NumberOfSymbols: DWORD,
};
pub const ANON_OBJECT_HEADER_BIGOBJ = struct_ANON_OBJECT_HEADER_BIGOBJ;
pub const struct__IMAGE_SECTION_HEADER = extern struct {
    Name: [8]BYTE,
    Misc: extern union {
        PhysicalAddress: DWORD,
        VirtualSize: DWORD,
    },
    VirtualAddress: DWORD,
    SizeOfRawData: DWORD,
    PointerToRawData: DWORD,
    PointerToRelocations: DWORD,
    PointerToLinenumbers: DWORD,
    NumberOfRelocations: WORD,
    NumberOfLinenumbers: WORD,
    Characteristics: DWORD,
};
pub const IMAGE_SECTION_HEADER = struct__IMAGE_SECTION_HEADER;
pub const PIMAGE_SECTION_HEADER = [*c]struct__IMAGE_SECTION_HEADER;
pub const struct__IMAGE_SYMBOL = extern struct {
    N: extern union {
        ShortName: [8]BYTE,
        Name: extern struct {
            Short: DWORD,
            Long: DWORD,
        },
        LongName: [2]DWORD,
    },
    Value: DWORD,
    SectionNumber: SHORT,
    Type: WORD,
    StorageClass: BYTE,
    NumberOfAuxSymbols: BYTE,
};
pub const IMAGE_SYMBOL = struct__IMAGE_SYMBOL;
pub const PIMAGE_SYMBOL = [*c]IMAGE_SYMBOL;
pub const struct__IMAGE_SYMBOL_EX = extern struct {
    N: extern union {
        ShortName: [8]BYTE,
        Name: extern struct {
            Short: DWORD,
            Long: DWORD,
        },
        LongName: [2]DWORD,
    },
    Value: DWORD,
    SectionNumber: LONG,
    Type: WORD,
    StorageClass: BYTE,
    NumberOfAuxSymbols: BYTE,
};
pub const IMAGE_SYMBOL_EX = struct__IMAGE_SYMBOL_EX;
pub const PIMAGE_SYMBOL_EX = [*c]IMAGE_SYMBOL_EX;
pub const struct_IMAGE_AUX_SYMBOL_TOKEN_DEF = extern struct {
    bAuxType: BYTE,
    bReserved: BYTE,
    SymbolTableIndex: DWORD,
    rgbReserved: [12]BYTE,
};
pub const IMAGE_AUX_SYMBOL_TOKEN_DEF = struct_IMAGE_AUX_SYMBOL_TOKEN_DEF;
pub const PIMAGE_AUX_SYMBOL_TOKEN_DEF = [*c]IMAGE_AUX_SYMBOL_TOKEN_DEF;
pub const union__IMAGE_AUX_SYMBOL = extern union {
    Sym: extern struct {
        TagIndex: DWORD,
        Misc: extern union {
            LnSz: extern struct {
                Linenumber: WORD,
                Size: WORD,
            },
            TotalSize: DWORD,
        },
        FcnAry: extern union {
            Function: extern struct {
                PointerToLinenumber: DWORD,
                PointerToNextFunction: DWORD,
            },
            Array: extern struct {
                Dimension: [4]WORD,
            },
        },
        TvIndex: WORD,
    },
    File: extern struct {
        Name: [18]BYTE,
    },
    Section: extern struct {
        Length: DWORD,
        NumberOfRelocations: WORD,
        NumberOfLinenumbers: WORD,
        CheckSum: DWORD,
        Number: SHORT,
        Selection: BYTE,
        bReserved: BYTE,
        HighNumber: SHORT,
    },
    TokenDef: IMAGE_AUX_SYMBOL_TOKEN_DEF,
    CRC: extern struct {
        crc: DWORD,
        rgbReserved: [14]BYTE,
    },
};
pub const IMAGE_AUX_SYMBOL = union__IMAGE_AUX_SYMBOL;
pub const PIMAGE_AUX_SYMBOL = [*c]IMAGE_AUX_SYMBOL;
pub const union__IMAGE_AUX_SYMBOL_EX = extern union {
    Sym: extern struct {
        WeakDefaultSymIndex: DWORD,
        WeakSearchType: DWORD,
        rgbReserved: [12]BYTE,
    },
    File: extern struct {
        Name: [20]BYTE,
    },
    Section: extern struct {
        Length: DWORD,
        NumberOfRelocations: WORD,
        NumberOfLinenumbers: WORD,
        CheckSum: DWORD,
        Number: SHORT,
        Selection: BYTE,
        bReserved: BYTE,
        HighNumber: SHORT,
        rgbReserved: [2]BYTE,
    },
    @"": extern struct {
        TokenDef: IMAGE_AUX_SYMBOL_TOKEN_DEF,
        rgbReserved: [2]BYTE,
    },
    CRC: extern struct {
        crc: DWORD,
        rgbReserved: [16]BYTE,
    },
};
pub const IMAGE_AUX_SYMBOL_EX = union__IMAGE_AUX_SYMBOL_EX;
pub const PIMAGE_AUX_SYMBOL_EX = [*c]IMAGE_AUX_SYMBOL_EX;
pub const IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = enum_IMAGE_AUX_SYMBOL_TYPE._TOKEN_DEF;
pub const enum_IMAGE_AUX_SYMBOL_TYPE = extern enum {
    _TOKEN_DEF = 1,
};
pub const IMAGE_AUX_SYMBOL_TYPE = enum_IMAGE_AUX_SYMBOL_TYPE;
pub const struct__IMAGE_RELOCATION = extern struct {
    @"": extern union {
        VirtualAddress: DWORD,
        RelocCount: DWORD,
    },
    SymbolTableIndex: DWORD,
    Type: WORD,
};
pub const IMAGE_RELOCATION = struct__IMAGE_RELOCATION;
pub const PIMAGE_RELOCATION = [*c]IMAGE_RELOCATION;
pub const struct__IMAGE_LINENUMBER = extern struct {
    Type: extern union {
        SymbolTableIndex: DWORD,
        VirtualAddress: DWORD,
    },
    Linenumber: WORD,
};
pub const IMAGE_LINENUMBER = struct__IMAGE_LINENUMBER;
pub const PIMAGE_LINENUMBER = [*c]IMAGE_LINENUMBER;
pub const struct__IMAGE_BASE_RELOCATION = extern struct {
    VirtualAddress: DWORD,
    SizeOfBlock: DWORD,
};
pub const IMAGE_BASE_RELOCATION = struct__IMAGE_BASE_RELOCATION;
pub const PIMAGE_BASE_RELOCATION = [*c]IMAGE_BASE_RELOCATION;
pub const struct__IMAGE_ARCHIVE_MEMBER_HEADER = extern struct {
    Name: [16]BYTE,
    Date: [12]BYTE,
    UserID: [6]BYTE,
    GroupID: [6]BYTE,
    Mode: [8]BYTE,
    Size: [10]BYTE,
    EndHeader: [2]BYTE,
};
pub const IMAGE_ARCHIVE_MEMBER_HEADER = struct__IMAGE_ARCHIVE_MEMBER_HEADER;
pub const PIMAGE_ARCHIVE_MEMBER_HEADER = [*c]struct__IMAGE_ARCHIVE_MEMBER_HEADER;
pub const struct__IMAGE_EXPORT_DIRECTORY = extern struct {
    Characteristics: DWORD,
    TimeDateStamp: DWORD,
    MajorVersion: WORD,
    MinorVersion: WORD,
    Name: DWORD,
    Base: DWORD,
    NumberOfFunctions: DWORD,
    NumberOfNames: DWORD,
    AddressOfFunctions: DWORD,
    AddressOfNames: DWORD,
    AddressOfNameOrdinals: DWORD,
};
pub const IMAGE_EXPORT_DIRECTORY = struct__IMAGE_EXPORT_DIRECTORY;
pub const PIMAGE_EXPORT_DIRECTORY = [*c]struct__IMAGE_EXPORT_DIRECTORY;
pub const struct__IMAGE_IMPORT_BY_NAME = extern struct {
    Hint: WORD,
    Name: [1]CHAR,
};
pub const IMAGE_IMPORT_BY_NAME = struct__IMAGE_IMPORT_BY_NAME;
pub const PIMAGE_IMPORT_BY_NAME = [*c]struct__IMAGE_IMPORT_BY_NAME;
pub const struct__IMAGE_THUNK_DATA64 = extern struct {
    u1: extern union {
        ForwarderString: ULONGLONG,
        Function: ULONGLONG,
        Ordinal: ULONGLONG,
        AddressOfData: ULONGLONG,
    },
};
pub const IMAGE_THUNK_DATA64 = struct__IMAGE_THUNK_DATA64;
pub const PIMAGE_THUNK_DATA64 = [*c]IMAGE_THUNK_DATA64;
pub const struct__IMAGE_THUNK_DATA32 = extern struct {
    u1: extern union {
        ForwarderString: DWORD,
        Function: DWORD,
        Ordinal: DWORD,
        AddressOfData: DWORD,
    },
};
pub const IMAGE_THUNK_DATA32 = struct__IMAGE_THUNK_DATA32;
pub const PIMAGE_THUNK_DATA32 = [*c]IMAGE_THUNK_DATA32;
pub const PIMAGE_TLS_CALLBACK = ?fn (PVOID, DWORD, PVOID) callconv(.C) void;
pub const struct__IMAGE_TLS_DIRECTORY64 = extern struct {
    StartAddressOfRawData: ULONGLONG,
    EndAddressOfRawData: ULONGLONG,
    AddressOfIndex: ULONGLONG,
    AddressOfCallBacks: ULONGLONG,
    SizeOfZeroFill: DWORD,
    @"": extern union {
        Characteristics: DWORD,
        @"": @OpaqueType(),
    },
};
pub const IMAGE_TLS_DIRECTORY64 = struct__IMAGE_TLS_DIRECTORY64;
pub const PIMAGE_TLS_DIRECTORY64 = [*c]IMAGE_TLS_DIRECTORY64;
pub const struct__IMAGE_TLS_DIRECTORY32 = extern struct {
    StartAddressOfRawData: DWORD,
    EndAddressOfRawData: DWORD,
    AddressOfIndex: DWORD,
    AddressOfCallBacks: DWORD,
    SizeOfZeroFill: DWORD,
    @"": extern union {
        Characteristics: DWORD,
        @"": @OpaqueType(),
    },
};
pub const IMAGE_TLS_DIRECTORY32 = struct__IMAGE_TLS_DIRECTORY32;
pub const PIMAGE_TLS_DIRECTORY32 = [*c]IMAGE_TLS_DIRECTORY32;
pub const IMAGE_THUNK_DATA = IMAGE_THUNK_DATA64;
pub const PIMAGE_THUNK_DATA = PIMAGE_THUNK_DATA64;
pub const IMAGE_TLS_DIRECTORY = IMAGE_TLS_DIRECTORY64;
pub const PIMAGE_TLS_DIRECTORY = PIMAGE_TLS_DIRECTORY64;
pub const struct__IMAGE_IMPORT_DESCRIPTOR = extern struct {
    @"": extern union {
        Characteristics: DWORD,
        OriginalFirstThunk: DWORD,
    },
    TimeDateStamp: DWORD,
    ForwarderChain: DWORD,
    Name: DWORD,
    FirstThunk: DWORD,
};
pub const IMAGE_IMPORT_DESCRIPTOR = struct__IMAGE_IMPORT_DESCRIPTOR;
pub const PIMAGE_IMPORT_DESCRIPTOR = [*c]IMAGE_IMPORT_DESCRIPTOR;
pub const struct__IMAGE_BOUND_IMPORT_DESCRIPTOR = extern struct {
    TimeDateStamp: DWORD,
    OffsetModuleName: WORD,
    NumberOfModuleForwarderRefs: WORD,
};
pub const IMAGE_BOUND_IMPORT_DESCRIPTOR = struct__IMAGE_BOUND_IMPORT_DESCRIPTOR;
pub const PIMAGE_BOUND_IMPORT_DESCRIPTOR = [*c]struct__IMAGE_BOUND_IMPORT_DESCRIPTOR;
pub const struct__IMAGE_BOUND_FORWARDER_REF = extern struct {
    TimeDateStamp: DWORD,
    OffsetModuleName: WORD,
    Reserved: WORD,
};
pub const IMAGE_BOUND_FORWARDER_REF = struct__IMAGE_BOUND_FORWARDER_REF;
pub const PIMAGE_BOUND_FORWARDER_REF = [*c]struct__IMAGE_BOUND_FORWARDER_REF;
pub const struct__IMAGE_DELAYLOAD_DESCRIPTOR = extern struct {
    Attributes: extern union {
        AllAttributes: DWORD,
        @"": @OpaqueType(),
    },
    DllNameRVA: DWORD,
    ModuleHandleRVA: DWORD,
    ImportAddressTableRVA: DWORD,
    ImportNameTableRVA: DWORD,
    BoundImportAddressTableRVA: DWORD,
    UnloadInformationTableRVA: DWORD,
    TimeDateStamp: DWORD,
};
pub const IMAGE_DELAYLOAD_DESCRIPTOR = struct__IMAGE_DELAYLOAD_DESCRIPTOR;
pub const PIMAGE_DELAYLOAD_DESCRIPTOR = [*c]struct__IMAGE_DELAYLOAD_DESCRIPTOR;
pub const PCIMAGE_DELAYLOAD_DESCRIPTOR = [*c]const IMAGE_DELAYLOAD_DESCRIPTOR;
pub const struct__IMAGE_RESOURCE_DIRECTORY = extern struct {
    Characteristics: DWORD,
    TimeDateStamp: DWORD,
    MajorVersion: WORD,
    MinorVersion: WORD,
    NumberOfNamedEntries: WORD,
    NumberOfIdEntries: WORD,
};
pub const IMAGE_RESOURCE_DIRECTORY = struct__IMAGE_RESOURCE_DIRECTORY;
pub const PIMAGE_RESOURCE_DIRECTORY = [*c]struct__IMAGE_RESOURCE_DIRECTORY;
pub const struct__IMAGE_RESOURCE_DIRECTORY_ENTRY = extern struct {
    @"": extern union {
        @"": @OpaqueType(),
        Name: DWORD,
        Id: WORD,
    },
    @"": extern union {
        OffsetToData: DWORD,
        @"": @OpaqueType(),
    },
};
pub const IMAGE_RESOURCE_DIRECTORY_ENTRY = struct__IMAGE_RESOURCE_DIRECTORY_ENTRY;
pub const PIMAGE_RESOURCE_DIRECTORY_ENTRY = [*c]struct__IMAGE_RESOURCE_DIRECTORY_ENTRY;
pub const struct__IMAGE_RESOURCE_DIRECTORY_STRING = extern struct {
    Length: WORD,
    NameString: [1]CHAR,
};
pub const IMAGE_RESOURCE_DIRECTORY_STRING = struct__IMAGE_RESOURCE_DIRECTORY_STRING;
pub const PIMAGE_RESOURCE_DIRECTORY_STRING = [*c]struct__IMAGE_RESOURCE_DIRECTORY_STRING;
pub const struct__IMAGE_RESOURCE_DIR_STRING_U = extern struct {
    Length: WORD,
    NameString: [1]WCHAR,
};
pub const IMAGE_RESOURCE_DIR_STRING_U = struct__IMAGE_RESOURCE_DIR_STRING_U;
pub const PIMAGE_RESOURCE_DIR_STRING_U = [*c]struct__IMAGE_RESOURCE_DIR_STRING_U;
pub const struct__IMAGE_RESOURCE_DATA_ENTRY = extern struct {
    OffsetToData: DWORD,
    Size: DWORD,
    CodePage: DWORD,
    Reserved: DWORD,
};
pub const IMAGE_RESOURCE_DATA_ENTRY = struct__IMAGE_RESOURCE_DATA_ENTRY;
pub const PIMAGE_RESOURCE_DATA_ENTRY = [*c]struct__IMAGE_RESOURCE_DATA_ENTRY;
pub const struct__IMAGE_LOAD_CONFIG_CODE_INTEGRITY = extern struct {
    Flags: WORD,
    Catalog: WORD,
    CatalogOffset: DWORD,
    Reserved: DWORD,
};
pub const IMAGE_LOAD_CONFIG_CODE_INTEGRITY = struct__IMAGE_LOAD_CONFIG_CODE_INTEGRITY;
pub const PIMAGE_LOAD_CONFIG_CODE_INTEGRITY = [*c]struct__IMAGE_LOAD_CONFIG_CODE_INTEGRITY;
pub const struct__IMAGE_DYNAMIC_RELOCATION_TABLE = extern struct {
    Version: DWORD,
    Size: DWORD,
};
pub const IMAGE_DYNAMIC_RELOCATION_TABLE = struct__IMAGE_DYNAMIC_RELOCATION_TABLE;
pub const PIMAGE_DYNAMIC_RELOCATION_TABLE = [*c]struct__IMAGE_DYNAMIC_RELOCATION_TABLE;
pub const struct__IMAGE_DYNAMIC_RELOCATION32 = extern struct {
    Symbol: DWORD,
    BaseRelocSize: DWORD,
};
pub const IMAGE_DYNAMIC_RELOCATION32 = struct__IMAGE_DYNAMIC_RELOCATION32;
pub const PIMAGE_DYNAMIC_RELOCATION32 = [*c]struct__IMAGE_DYNAMIC_RELOCATION32;
pub const struct__IMAGE_DYNAMIC_RELOCATION64 = extern struct {
    Symbol: ULONGLONG,
    BaseRelocSize: DWORD,
};
pub const IMAGE_DYNAMIC_RELOCATION64 = struct__IMAGE_DYNAMIC_RELOCATION64;
pub const PIMAGE_DYNAMIC_RELOCATION64 = [*c]struct__IMAGE_DYNAMIC_RELOCATION64;
pub const struct__IMAGE_DYNAMIC_RELOCATION32_V2 = extern struct {
    HeaderSize: DWORD,
    FixupInfoSize: DWORD,
    Symbol: DWORD,
    SymbolGroup: DWORD,
    Flags: DWORD,
};
pub const IMAGE_DYNAMIC_RELOCATION32_V2 = struct__IMAGE_DYNAMIC_RELOCATION32_V2;
pub const PIMAGE_DYNAMIC_RELOCATION32_V2 = [*c]struct__IMAGE_DYNAMIC_RELOCATION32_V2;
pub const struct__IMAGE_DYNAMIC_RELOCATION64_V2 = extern struct {
    HeaderSize: DWORD,
    FixupInfoSize: DWORD,
    Symbol: ULONGLONG,
    SymbolGroup: DWORD,
    Flags: DWORD,
};
pub const IMAGE_DYNAMIC_RELOCATION64_V2 = struct__IMAGE_DYNAMIC_RELOCATION64_V2;
pub const PIMAGE_DYNAMIC_RELOCATION64_V2 = [*c]struct__IMAGE_DYNAMIC_RELOCATION64_V2;
pub const IMAGE_DYNAMIC_RELOCATION = IMAGE_DYNAMIC_RELOCATION64;
pub const PIMAGE_DYNAMIC_RELOCATION = PIMAGE_DYNAMIC_RELOCATION64;
pub const IMAGE_DYNAMIC_RELOCATION_V2 = IMAGE_DYNAMIC_RELOCATION64_V2;
pub const PIMAGE_DYNAMIC_RELOCATION_V2 = PIMAGE_DYNAMIC_RELOCATION64_V2;
pub const struct__IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER = extern struct {
    PrologueByteCount: BYTE,
};
pub const IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER = struct__IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;
pub const PIMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER = [*c]IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;
pub const struct__IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER = extern struct {
    EpilogueCount: DWORD,
    EpilogueByteCount: BYTE,
    BranchDescriptorElementSize: BYTE,
    BranchDescriptorCount: WORD,
};
pub const IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER = struct__IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;
pub const PIMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER = [*c]IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;
pub const struct__IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION = @OpaqueType();
pub const IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION = struct__IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
pub const PIMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION = ?*IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
pub const struct__IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION = @OpaqueType();
pub const IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION = struct__IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
pub const PIMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION = ?*IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
pub const struct__IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION = @OpaqueType();
pub const IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION = struct__IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION;
pub const PIMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION = ?*IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION;
pub const struct__IMAGE_LOAD_CONFIG_DIRECTORY32 = extern struct {
    Size: DWORD,
    TimeDateStamp: DWORD,
    MajorVersion: WORD,
    MinorVersion: WORD,
    GlobalFlagsClear: DWORD,
    GlobalFlagsSet: DWORD,
    CriticalSectionDefaultTimeout: DWORD,
    DeCommitFreeBlockThreshold: DWORD,
    DeCommitTotalFreeThreshold: DWORD,
    LockPrefixTable: DWORD,
    MaximumAllocationSize: DWORD,
    VirtualMemoryThreshold: DWORD,
    ProcessHeapFlags: DWORD,
    ProcessAffinityMask: DWORD,
    CSDVersion: WORD,
    DependentLoadFlags: WORD,
    EditList: DWORD,
    SecurityCookie: DWORD,
    SEHandlerTable: DWORD,
    SEHandlerCount: DWORD,
    GuardCFCheckFunctionPointer: DWORD,
    GuardCFDispatchFunctionPointer: DWORD,
    GuardCFFunctionTable: DWORD,
    GuardCFFunctionCount: DWORD,
    GuardFlags: DWORD,
    CodeIntegrity: IMAGE_LOAD_CONFIG_CODE_INTEGRITY,
    GuardAddressTakenIatEntryTable: DWORD,
    GuardAddressTakenIatEntryCount: DWORD,
    GuardLongJumpTargetTable: DWORD,
    GuardLongJumpTargetCount: DWORD,
    DynamicValueRelocTable: DWORD,
    CHPEMetadataPointer: DWORD,
    GuardRFFailureRoutine: DWORD,
    GuardRFFailureRoutineFunctionPointer: DWORD,
    DynamicValueRelocTableOffset: DWORD,
    DynamicValueRelocTableSection: WORD,
    Reserved2: WORD,
    GuardRFVerifyStackPointerFunctionPointer: DWORD,
    HotPatchTableOffset: DWORD,
    Reserved3: DWORD,
    EnclaveConfigurationPointer: DWORD,
    VolatileMetadataPointer: DWORD,
};
pub const IMAGE_LOAD_CONFIG_DIRECTORY32 = struct__IMAGE_LOAD_CONFIG_DIRECTORY32;
pub const PIMAGE_LOAD_CONFIG_DIRECTORY32 = [*c]struct__IMAGE_LOAD_CONFIG_DIRECTORY32;
pub const struct__IMAGE_LOAD_CONFIG_DIRECTORY64 = extern struct {
    Size: DWORD,
    TimeDateStamp: DWORD,
    MajorVersion: WORD,
    MinorVersion: WORD,
    GlobalFlagsClear: DWORD,
    GlobalFlagsSet: DWORD,
    CriticalSectionDefaultTimeout: DWORD,
    DeCommitFreeBlockThreshold: ULONGLONG,
    DeCommitTotalFreeThreshold: ULONGLONG,
    LockPrefixTable: ULONGLONG,
    MaximumAllocationSize: ULONGLONG,
    VirtualMemoryThreshold: ULONGLONG,
    ProcessAffinityMask: ULONGLONG,
    ProcessHeapFlags: DWORD,
    CSDVersion: WORD,
    DependentLoadFlags: WORD,
    EditList: ULONGLONG,
    SecurityCookie: ULONGLONG,
    SEHandlerTable: ULONGLONG,
    SEHandlerCount: ULONGLONG,
    GuardCFCheckFunctionPointer: ULONGLONG,
    GuardCFDispatchFunctionPointer: ULONGLONG,
    GuardCFFunctionTable: ULONGLONG,
    GuardCFFunctionCount: ULONGLONG,
    GuardFlags: DWORD,
    CodeIntegrity: IMAGE_LOAD_CONFIG_CODE_INTEGRITY,
    GuardAddressTakenIatEntryTable: ULONGLONG,
    GuardAddressTakenIatEntryCount: ULONGLONG,
    GuardLongJumpTargetTable: ULONGLONG,
    GuardLongJumpTargetCount: ULONGLONG,
    DynamicValueRelocTable: ULONGLONG,
    CHPEMetadataPointer: ULONGLONG,
    GuardRFFailureRoutine: ULONGLONG,
    GuardRFFailureRoutineFunctionPointer: ULONGLONG,
    DynamicValueRelocTableOffset: DWORD,
    DynamicValueRelocTableSection: WORD,
    Reserved2: WORD,
    GuardRFVerifyStackPointerFunctionPointer: ULONGLONG,
    HotPatchTableOffset: DWORD,
    Reserved3: DWORD,
    EnclaveConfigurationPointer: ULONGLONG,
    VolatileMetadataPointer: ULONGLONG,
};
pub const IMAGE_LOAD_CONFIG_DIRECTORY64 = struct__IMAGE_LOAD_CONFIG_DIRECTORY64;
pub const PIMAGE_LOAD_CONFIG_DIRECTORY64 = [*c]struct__IMAGE_LOAD_CONFIG_DIRECTORY64;
pub const IMAGE_LOAD_CONFIG_DIRECTORY = IMAGE_LOAD_CONFIG_DIRECTORY64;
pub const PIMAGE_LOAD_CONFIG_DIRECTORY = PIMAGE_LOAD_CONFIG_DIRECTORY64;
pub const struct__IMAGE_HOT_PATCH_INFO = extern struct {
    Version: DWORD,
    Size: DWORD,
    SequenceNumber: DWORD,
    BaseImageList: DWORD,
    BaseImageCount: DWORD,
    BufferOffset: DWORD,
    ExtraPatchSize: DWORD,
};
pub const IMAGE_HOT_PATCH_INFO = struct__IMAGE_HOT_PATCH_INFO;
pub const PIMAGE_HOT_PATCH_INFO = [*c]struct__IMAGE_HOT_PATCH_INFO;
pub const struct__IMAGE_HOT_PATCH_BASE = extern struct {
    SequenceNumber: DWORD,
    Flags: DWORD,
    OriginalTimeDateStamp: DWORD,
    OriginalCheckSum: DWORD,
    CodeIntegrityInfo: DWORD,
    CodeIntegritySize: DWORD,
    PatchTable: DWORD,
    BufferOffset: DWORD,
};
pub const IMAGE_HOT_PATCH_BASE = struct__IMAGE_HOT_PATCH_BASE;
pub const PIMAGE_HOT_PATCH_BASE = [*c]struct__IMAGE_HOT_PATCH_BASE;
pub const struct__IMAGE_HOT_PATCH_HASHES = extern struct {
    SHA256: [32]BYTE,
    SHA1: [20]BYTE,
};
pub const IMAGE_HOT_PATCH_HASHES = struct__IMAGE_HOT_PATCH_HASHES;
pub const PIMAGE_HOT_PATCH_HASHES = [*c]struct__IMAGE_HOT_PATCH_HASHES;
pub const struct__IMAGE_CE_RUNTIME_FUNCTION_ENTRY = @OpaqueType();
pub const IMAGE_CE_RUNTIME_FUNCTION_ENTRY = struct__IMAGE_CE_RUNTIME_FUNCTION_ENTRY;
pub const PIMAGE_CE_RUNTIME_FUNCTION_ENTRY = ?*struct__IMAGE_CE_RUNTIME_FUNCTION_ENTRY;
pub const struct__IMAGE_ARM_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: DWORD,
    @"": extern union {
        UnwindData: DWORD,
        @"": @OpaqueType(),
    },
};
pub const IMAGE_ARM_RUNTIME_FUNCTION_ENTRY = struct__IMAGE_ARM_RUNTIME_FUNCTION_ENTRY;
pub const PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY = [*c]struct__IMAGE_ARM_RUNTIME_FUNCTION_ENTRY;
pub const struct__IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: DWORD,
    @"": extern union {
        UnwindData: DWORD,
        @"": @OpaqueType(),
    },
};
pub const IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = struct__IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
pub const PIMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = [*c]struct__IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
pub const struct__IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: ULONGLONG,
    EndAddress: ULONGLONG,
    ExceptionHandler: ULONGLONG,
    HandlerData: ULONGLONG,
    PrologEndAddress: ULONGLONG,
};
pub const IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = struct__IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;
pub const PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = [*c]struct__IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;
pub const struct__IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = extern struct {
    BeginAddress: DWORD,
    EndAddress: DWORD,
    ExceptionHandler: DWORD,
    HandlerData: DWORD,
    PrologEndAddress: DWORD,
};
pub const IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = struct__IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;
pub const PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = [*c]struct__IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;
pub const _IMAGE_RUNTIME_FUNCTION_ENTRY = struct__IMAGE_RUNTIME_FUNCTION_ENTRY;
pub const _PIMAGE_RUNTIME_FUNCTION_ENTRY = [*c]struct__IMAGE_RUNTIME_FUNCTION_ENTRY;
pub const IMAGE_IA64_RUNTIME_FUNCTION_ENTRY = _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub const PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY = _PIMAGE_RUNTIME_FUNCTION_ENTRY;
pub const IMAGE_RUNTIME_FUNCTION_ENTRY = _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub const PIMAGE_RUNTIME_FUNCTION_ENTRY = _PIMAGE_RUNTIME_FUNCTION_ENTRY;
pub const struct__IMAGE_ENCLAVE_CONFIG32 = extern struct {
    Size: DWORD,
    MinimumRequiredConfigSize: DWORD,
    PolicyFlags: DWORD,
    NumberOfImports: DWORD,
    ImportList: DWORD,
    ImportEntrySize: DWORD,
    FamilyID: [16]BYTE,
    ImageID: [16]BYTE,
    ImageVersion: DWORD,
    SecurityVersion: DWORD,
    EnclaveSize: DWORD,
    NumberOfThreads: DWORD,
    EnclaveFlags: DWORD,
};
pub const IMAGE_ENCLAVE_CONFIG32 = struct__IMAGE_ENCLAVE_CONFIG32;
pub const PIMAGE_ENCLAVE_CONFIG32 = [*c]struct__IMAGE_ENCLAVE_CONFIG32;
pub const struct__IMAGE_ENCLAVE_CONFIG64 = extern struct {
    Size: DWORD,
    MinimumRequiredConfigSize: DWORD,
    PolicyFlags: DWORD,
    NumberOfImports: DWORD,
    ImportList: DWORD,
    ImportEntrySize: DWORD,
    FamilyID: [16]BYTE,
    ImageID: [16]BYTE,
    ImageVersion: DWORD,
    SecurityVersion: DWORD,
    EnclaveSize: ULONGLONG,
    NumberOfThreads: DWORD,
    EnclaveFlags: DWORD,
};
pub const IMAGE_ENCLAVE_CONFIG64 = struct__IMAGE_ENCLAVE_CONFIG64;
pub const PIMAGE_ENCLAVE_CONFIG64 = [*c]struct__IMAGE_ENCLAVE_CONFIG64;
pub const IMAGE_ENCLAVE_CONFIG = IMAGE_ENCLAVE_CONFIG64;
pub const PIMAGE_ENCLAVE_CONFIG = PIMAGE_ENCLAVE_CONFIG64;
pub const struct__IMAGE_ENCLAVE_IMPORT = extern struct {
    MatchType: DWORD,
    MinimumSecurityVersion: DWORD,
    UniqueOrAuthorID: [32]BYTE,
    FamilyID: [16]BYTE,
    ImageID: [16]BYTE,
    ImportName: DWORD,
    Reserved: DWORD,
};
pub const IMAGE_ENCLAVE_IMPORT = struct__IMAGE_ENCLAVE_IMPORT;
pub const PIMAGE_ENCLAVE_IMPORT = [*c]struct__IMAGE_ENCLAVE_IMPORT;
pub const struct__IMAGE_DEBUG_DIRECTORY = extern struct {
    Characteristics: DWORD,
    TimeDateStamp: DWORD,
    MajorVersion: WORD,
    MinorVersion: WORD,
    Type: DWORD,
    SizeOfData: DWORD,
    AddressOfRawData: DWORD,
    PointerToRawData: DWORD,
};
pub const IMAGE_DEBUG_DIRECTORY = struct__IMAGE_DEBUG_DIRECTORY;
pub const PIMAGE_DEBUG_DIRECTORY = [*c]struct__IMAGE_DEBUG_DIRECTORY;
pub const struct__IMAGE_COFF_SYMBOLS_HEADER = extern struct {
    NumberOfSymbols: DWORD,
    LvaToFirstSymbol: DWORD,
    NumberOfLinenumbers: DWORD,
    LvaToFirstLinenumber: DWORD,
    RvaToFirstByteOfCode: DWORD,
    RvaToLastByteOfCode: DWORD,
    RvaToFirstByteOfData: DWORD,
    RvaToLastByteOfData: DWORD,
};
pub const IMAGE_COFF_SYMBOLS_HEADER = struct__IMAGE_COFF_SYMBOLS_HEADER;
pub const PIMAGE_COFF_SYMBOLS_HEADER = [*c]struct__IMAGE_COFF_SYMBOLS_HEADER;
pub const struct__FPO_DATA = @OpaqueType();
pub const FPO_DATA = struct__FPO_DATA;
pub const PFPO_DATA = ?*struct__FPO_DATA;
pub const struct__IMAGE_DEBUG_MISC = extern struct {
    DataType: DWORD,
    Length: DWORD,
    Unicode: BOOLEAN,
    Reserved: [3]BYTE,
    Data: [1]BYTE,
};
pub const IMAGE_DEBUG_MISC = struct__IMAGE_DEBUG_MISC;
pub const PIMAGE_DEBUG_MISC = [*c]struct__IMAGE_DEBUG_MISC;
pub const struct__IMAGE_FUNCTION_ENTRY = extern struct {
    StartingAddress: DWORD,
    EndingAddress: DWORD,
    EndOfPrologue: DWORD,
};
pub const IMAGE_FUNCTION_ENTRY = struct__IMAGE_FUNCTION_ENTRY;
pub const PIMAGE_FUNCTION_ENTRY = [*c]struct__IMAGE_FUNCTION_ENTRY;
pub const struct__IMAGE_FUNCTION_ENTRY64 = extern struct {
    StartingAddress: ULONGLONG,
    EndingAddress: ULONGLONG,
    @"": extern union {
        EndOfPrologue: ULONGLONG,
        UnwindInfoAddress: ULONGLONG,
    },
};
pub const IMAGE_FUNCTION_ENTRY64 = struct__IMAGE_FUNCTION_ENTRY64;
pub const PIMAGE_FUNCTION_ENTRY64 = [*c]struct__IMAGE_FUNCTION_ENTRY64;
pub const struct__IMAGE_SEPARATE_DEBUG_HEADER = extern struct {
    Signature: WORD,
    Flags: WORD,
    Machine: WORD,
    Characteristics: WORD,
    TimeDateStamp: DWORD,
    CheckSum: DWORD,
    ImageBase: DWORD,
    SizeOfImage: DWORD,
    NumberOfSections: DWORD,
    ExportedNamesSize: DWORD,
    DebugDirectorySize: DWORD,
    SectionAlignment: DWORD,
    Reserved: [2]DWORD,
};
pub const IMAGE_SEPARATE_DEBUG_HEADER = struct__IMAGE_SEPARATE_DEBUG_HEADER;
pub const PIMAGE_SEPARATE_DEBUG_HEADER = [*c]struct__IMAGE_SEPARATE_DEBUG_HEADER;
pub const struct__NON_PAGED_DEBUG_INFO = extern struct {
    Signature: WORD,
    Flags: WORD,
    Size: DWORD,
    Machine: WORD,
    Characteristics: WORD,
    TimeDateStamp: DWORD,
    CheckSum: DWORD,
    SizeOfImage: DWORD,
    ImageBase: ULONGLONG,
};
pub const NON_PAGED_DEBUG_INFO = struct__NON_PAGED_DEBUG_INFO;
pub const PNON_PAGED_DEBUG_INFO = [*c]struct__NON_PAGED_DEBUG_INFO;
pub const struct__ImageArchitectureHeader = @OpaqueType();
pub const IMAGE_ARCHITECTURE_HEADER = struct__ImageArchitectureHeader;
pub const PIMAGE_ARCHITECTURE_HEADER = ?*struct__ImageArchitectureHeader;
pub const struct__ImageArchitectureEntry = extern struct {
    FixupInstRVA: DWORD,
    NewInst: DWORD,
};
pub const IMAGE_ARCHITECTURE_ENTRY = struct__ImageArchitectureEntry;
pub const PIMAGE_ARCHITECTURE_ENTRY = [*c]struct__ImageArchitectureEntry;
pub const struct_IMPORT_OBJECT_HEADER = @OpaqueType();
pub const IMPORT_OBJECT_HEADER = struct_IMPORT_OBJECT_HEADER;
pub const IMPORT_OBJECT_CODE = enum_IMPORT_OBJECT_TYPE.IMPORT_OBJECT_CODE;
pub const IMPORT_OBJECT_DATA = enum_IMPORT_OBJECT_TYPE.IMPORT_OBJECT_DATA;
pub const IMPORT_OBJECT_CONST = enum_IMPORT_OBJECT_TYPE.IMPORT_OBJECT_CONST;
pub const enum_IMPORT_OBJECT_TYPE = extern enum {
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2,
};
pub const IMPORT_OBJECT_TYPE = enum_IMPORT_OBJECT_TYPE;
pub const IMPORT_OBJECT_ORDINAL = enum_IMPORT_OBJECT_NAME_TYPE.IMPORT_OBJECT_ORDINAL;
pub const IMPORT_OBJECT_NAME = enum_IMPORT_OBJECT_NAME_TYPE.IMPORT_OBJECT_NAME;
pub const IMPORT_OBJECT_NAME_NO_PREFIX = enum_IMPORT_OBJECT_NAME_TYPE.IMPORT_OBJECT_NAME_NO_PREFIX;
pub const IMPORT_OBJECT_NAME_UNDECORATE = enum_IMPORT_OBJECT_NAME_TYPE.IMPORT_OBJECT_NAME_UNDECORATE;
pub const IMPORT_OBJECT_NAME_EXPORTAS = enum_IMPORT_OBJECT_NAME_TYPE.IMPORT_OBJECT_NAME_EXPORTAS;
pub const enum_IMPORT_OBJECT_NAME_TYPE = extern enum {
    IMPORT_OBJECT_ORDINAL = 0,
    IMPORT_OBJECT_NAME = 1,
    IMPORT_OBJECT_NAME_NO_PREFIX = 2,
    IMPORT_OBJECT_NAME_UNDECORATE = 3,
    IMPORT_OBJECT_NAME_EXPORTAS = 4,
};
pub const IMPORT_OBJECT_NAME_TYPE = enum_IMPORT_OBJECT_NAME_TYPE;
pub const COMIMAGE_FLAGS_ILONLY = enum_ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_ILONLY;
pub const COMIMAGE_FLAGS_32BITREQUIRED = enum_ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITREQUIRED;
pub const COMIMAGE_FLAGS_IL_LIBRARY = enum_ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_IL_LIBRARY;
pub const COMIMAGE_FLAGS_STRONGNAMESIGNED = enum_ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_STRONGNAMESIGNED;
pub const COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = enum_ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_NATIVE_ENTRYPOINT;
pub const COMIMAGE_FLAGS_TRACKDEBUGDATA = enum_ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_TRACKDEBUGDATA;
pub const COMIMAGE_FLAGS_32BITPREFERRED = enum_ReplacesCorHdrNumericDefines.COMIMAGE_FLAGS_32BITPREFERRED;
pub const COR_VERSION_MAJOR_V2 = enum_ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR_V2;
pub const COR_VERSION_MAJOR = enum_ReplacesCorHdrNumericDefines.COR_VERSION_MAJOR;
pub const COR_VERSION_MINOR = enum_ReplacesCorHdrNumericDefines.COR_VERSION_MINOR;
pub const COR_DELETED_NAME_LENGTH = enum_ReplacesCorHdrNumericDefines.COR_DELETED_NAME_LENGTH;
pub const COR_VTABLEGAP_NAME_LENGTH = enum_ReplacesCorHdrNumericDefines.COR_VTABLEGAP_NAME_LENGTH;
pub const NATIVE_TYPE_MAX_CB = enum_ReplacesCorHdrNumericDefines.NATIVE_TYPE_MAX_CB;
pub const COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = enum_ReplacesCorHdrNumericDefines.COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE;
pub const IMAGE_COR_MIH_METHODRVA = enum_ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_METHODRVA;
pub const IMAGE_COR_MIH_EHRVA = enum_ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_EHRVA;
pub const IMAGE_COR_MIH_BASICBLOCK = enum_ReplacesCorHdrNumericDefines.IMAGE_COR_MIH_BASICBLOCK;
pub const COR_VTABLE_32BIT = enum_ReplacesCorHdrNumericDefines.COR_VTABLE_32BIT;
pub const COR_VTABLE_64BIT = enum_ReplacesCorHdrNumericDefines.COR_VTABLE_64BIT;
pub const COR_VTABLE_FROM_UNMANAGED = enum_ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED;
pub const COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = enum_ReplacesCorHdrNumericDefines.COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN;
pub const COR_VTABLE_CALL_MOST_DERIVED = enum_ReplacesCorHdrNumericDefines.COR_VTABLE_CALL_MOST_DERIVED;
pub const IMAGE_COR_EATJ_THUNK_SIZE = enum_ReplacesCorHdrNumericDefines.IMAGE_COR_EATJ_THUNK_SIZE;
pub const MAX_CLASS_NAME = enum_ReplacesCorHdrNumericDefines.MAX_CLASS_NAME;
pub const MAX_PACKAGE_NAME = enum_ReplacesCorHdrNumericDefines.MAX_PACKAGE_NAME;
pub const enum_ReplacesCorHdrNumericDefines = extern enum {
    COMIMAGE_FLAGS_ILONLY = 1,
    COMIMAGE_FLAGS_32BITREQUIRED = 2,
    COMIMAGE_FLAGS_IL_LIBRARY = 4,
    COMIMAGE_FLAGS_STRONGNAMESIGNED = 8,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 16,
    COMIMAGE_FLAGS_TRACKDEBUGDATA = 65536,
    COMIMAGE_FLAGS_32BITPREFERRED = 131072,
    COR_VERSION_MAJOR_V2 = 2,
    COR_VERSION_MAJOR = 2,
    COR_VERSION_MINOR = 5,
    COR_DELETED_NAME_LENGTH = 8,
    COR_VTABLEGAP_NAME_LENGTH = 8,
    NATIVE_TYPE_MAX_CB = 1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 255,
    IMAGE_COR_MIH_METHODRVA = 1,
    IMAGE_COR_MIH_EHRVA = 2,
    IMAGE_COR_MIH_BASICBLOCK = 8,
    COR_VTABLE_32BIT = 1,
    COR_VTABLE_64BIT = 2,
    COR_VTABLE_FROM_UNMANAGED = 4,
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 8,
    COR_VTABLE_CALL_MOST_DERIVED = 16,
    IMAGE_COR_EATJ_THUNK_SIZE = 32,
    MAX_CLASS_NAME = 1024,
    MAX_PACKAGE_NAME = 1024,
};
pub const ReplacesCorHdrNumericDefines = enum_ReplacesCorHdrNumericDefines;
pub const struct_IMAGE_COR20_HEADER = extern struct {
    cb: DWORD,
    MajorRuntimeVersion: WORD,
    MinorRuntimeVersion: WORD,
    MetaData: IMAGE_DATA_DIRECTORY,
    Flags: DWORD,
    @"": extern union {
        EntryPointToken: DWORD,
        EntryPointRVA: DWORD,
    },
    Resources: IMAGE_DATA_DIRECTORY,
    StrongNameSignature: IMAGE_DATA_DIRECTORY,
    CodeManagerTable: IMAGE_DATA_DIRECTORY,
    VTableFixups: IMAGE_DATA_DIRECTORY,
    ExportAddressTableJumps: IMAGE_DATA_DIRECTORY,
    ManagedNativeHeader: IMAGE_DATA_DIRECTORY,
};
pub const IMAGE_COR20_HEADER = struct_IMAGE_COR20_HEADER;
pub const PIMAGE_COR20_HEADER = [*c]struct_IMAGE_COR20_HEADER;
pub extern "ntoskrnl" fn RtlCaptureStackBackTrace(FramesToSkip: DWORD, FramesToCapture: DWORD, BackTrace: [*c]PVOID, BackTraceHash: PDWORD) callconv(.Stdcall) WORD;
pub extern "ntoskrnl" fn RtlCaptureContext(ContextRecord: PCONTEXT) callconv(.Stdcall) void;
pub extern "ntoskrnl" fn RtlUnwind(TargetFrame: PVOID, TargetIp: PVOID, ExceptionRecord: PEXCEPTION_RECORD, ReturnValue: PVOID) callconv(.Stdcall) void;
pub extern "ntoskrnl" fn RtlAddFunctionTable(FunctionTable: PRUNTIME_FUNCTION, EntryCount: DWORD, BaseAddress: DWORD64) callconv(.Stdcall) BOOLEAN;
pub extern "ntoskrnl" fn RtlDeleteFunctionTable(FunctionTable: PRUNTIME_FUNCTION) callconv(.Stdcall) BOOLEAN;
pub extern "ntoskrnl" fn RtlInstallFunctionTableCallback(TableIdentifier: DWORD64, BaseAddress: DWORD64, Length: DWORD, Callback: PGET_RUNTIME_FUNCTION_CALLBACK, Context: PVOID, OutOfProcessCallbackDll: PCWSTR) callconv(.Stdcall) BOOLEAN;
pub extern "ntoskrnl" fn RtlAddGrowableFunctionTable(DynamicTable: [*c]PVOID, FunctionTable: PRUNTIME_FUNCTION, EntryCount: DWORD, MaximumEntryCount: DWORD, RangeBase: ULONG_PTR, RangeEnd: ULONG_PTR) callconv(.Stdcall) DWORD;
pub extern "ntoskrnl" fn RtlGrowFunctionTable(DynamicTable: PVOID, NewEntryCount: DWORD) callconv(.Stdcall) void;
pub extern "ntoskrnl" fn RtlDeleteGrowableFunctionTable(DynamicTable: PVOID) callconv(.Stdcall) void;
pub extern "ntoskrnl" fn RtlLookupFunctionEntry(ControlPc: DWORD64, ImageBase: PDWORD64, HistoryTable: PUNWIND_HISTORY_TABLE) callconv(.Stdcall) PRUNTIME_FUNCTION;
pub extern "ntoskrnl" fn RtlRestoreContext(ContextRecord: PCONTEXT, ExceptionRecord: [*c]struct__EXCEPTION_RECORD) callconv(.Stdcall) void;
pub extern "ntoskrnl" fn RtlUnwindEx(TargetFrame: PVOID, TargetIp: PVOID, ExceptionRecord: PEXCEPTION_RECORD, ReturnValue: PVOID, ContextRecord: PCONTEXT, HistoryTable: PUNWIND_HISTORY_TABLE) callconv(.Stdcall) void;
pub extern "ntoskrnl" fn RtlVirtualUnwind(HandlerType: DWORD, ImageBase: DWORD64, ControlPc: DWORD64, FunctionEntry: PRUNTIME_FUNCTION, ContextRecord: PCONTEXT, HandlerData: [*c]PVOID, EstablisherFrame: PDWORD64, ContextPointers: PKNONVOLATILE_CONTEXT_POINTERS) callconv(.Stdcall) PEXCEPTION_ROUTINE;
pub extern "ntoskrnl" fn RtlRaiseException(ExceptionRecord: PEXCEPTION_RECORD) callconv(.Stdcall) void;
pub extern "ntoskrnl" fn RtlPcToFileHeader(PcValue: PVOID, BaseOfImage: [*c]PVOID) callconv(.Stdcall) PVOID;
pub extern "ntoskrnl" fn RtlCompareMemory(Source1: ?*const c_void, Source2: ?*const c_void, Length: SIZE_T) callconv(.Stdcall) SIZE_T;
pub const struct__SLIST_ENTRY = extern struct {
    Next: [*c]struct__SLIST_ENTRY,
};
pub const SLIST_ENTRY = struct__SLIST_ENTRY;
pub const PSLIST_ENTRY = [*c]struct__SLIST_ENTRY;
pub const union__SLIST_HEADER = extern union {
    @"": extern struct {
        Alignment: ULONGLONG,
        Region: ULONGLONG,
    },
    HeaderX64: @OpaqueType(),
};
pub const SLIST_HEADER = union__SLIST_HEADER;
pub const PSLIST_HEADER = [*c]union__SLIST_HEADER;
pub extern "ntoskrnl" fn RtlInitializeSListHead(ListHead: PSLIST_HEADER) callconv(.Stdcall) void;
pub extern "ntoskrnl" fn RtlFirstEntrySList(ListHead: [*c]const SLIST_HEADER) callconv(.Stdcall) PSLIST_ENTRY;
pub extern "ntoskrnl" fn RtlInterlockedPopEntrySList(ListHead: PSLIST_HEADER) callconv(.Stdcall) PSLIST_ENTRY;
pub extern "ntoskrnl" fn RtlInterlockedPushEntrySList(ListHead: PSLIST_HEADER, ListEntry: PSLIST_ENTRY) callconv(.Stdcall) PSLIST_ENTRY;
pub extern "ntoskrnl" fn RtlInterlockedPushListSListEx(ListHead: PSLIST_HEADER, List: PSLIST_ENTRY, ListEnd: PSLIST_ENTRY, Count: DWORD) callconv(.Stdcall) PSLIST_ENTRY;
pub extern "ntoskrnl" fn RtlInterlockedFlushSList(ListHead: PSLIST_HEADER) callconv(.Stdcall) PSLIST_ENTRY;
pub extern "ntoskrnl" fn RtlQueryDepthSList(ListHead: PSLIST_HEADER) callconv(.Stdcall) WORD;
pub const union__RTL_RUN_ONCE = extern union {
    Ptr: PVOID,
};
pub const RTL_RUN_ONCE = union__RTL_RUN_ONCE;
pub const PRTL_RUN_ONCE = [*c]union__RTL_RUN_ONCE;
pub const struct__RTL_BARRIER = extern struct {
    Reserved1: DWORD,
    Reserved2: DWORD,
    Reserved3: [2]ULONG_PTR,
    Reserved4: DWORD,
    Reserved5: DWORD,
};
pub const RTL_BARRIER = struct__RTL_BARRIER;
pub const PRTL_BARRIER = [*c]struct__RTL_BARRIER;
pub extern fn __fastfail(Code: c_uint) noreturn;
pub fn HEAP_MAKE_TAG_FLAGS(TagBase: DWORD, Tag: DWORD) DWORD {
    return DWORD(TagBase +% (Tag << @import("std").math.Log2Int(DWORD)(18)));
}
pub const struct__MESSAGE_RESOURCE_ENTRY = extern struct {
    Length: WORD,
    Flags: WORD,
    Text: [1]BYTE,
};
pub const MESSAGE_RESOURCE_ENTRY = struct__MESSAGE_RESOURCE_ENTRY;
pub const PMESSAGE_RESOURCE_ENTRY = [*c]struct__MESSAGE_RESOURCE_ENTRY;
pub const struct__MESSAGE_RESOURCE_BLOCK = extern struct {
    LowId: DWORD,
    HighId: DWORD,
    OffsetToEntries: DWORD,
};
pub const MESSAGE_RESOURCE_BLOCK = struct__MESSAGE_RESOURCE_BLOCK;
pub const PMESSAGE_RESOURCE_BLOCK = [*c]struct__MESSAGE_RESOURCE_BLOCK;
pub const struct__MESSAGE_RESOURCE_DATA = extern struct {
    NumberOfBlocks: DWORD,
    Blocks: [1]MESSAGE_RESOURCE_BLOCK,
};
pub const MESSAGE_RESOURCE_DATA = struct__MESSAGE_RESOURCE_DATA;
pub const PMESSAGE_RESOURCE_DATA = [*c]struct__MESSAGE_RESOURCE_DATA;
pub const struct__OSVERSIONINFOA = extern struct {
    dwOSVersionInfoSize: DWORD,
    dwMajorVersion: DWORD,
    dwMinorVersion: DWORD,
    dwBuildNumber: DWORD,
    dwPlatformId: DWORD,
    szCSDVersion: [128]CHAR,
};
pub const OSVERSIONINFOA = struct__OSVERSIONINFOA;
pub const POSVERSIONINFOA = [*c]struct__OSVERSIONINFOA;
pub const LPOSVERSIONINFOA = [*c]struct__OSVERSIONINFOA;
pub const struct__OSVERSIONINFOW = extern struct {
    dwOSVersionInfoSize: DWORD,
    dwMajorVersion: DWORD,
    dwMinorVersion: DWORD,
    dwBuildNumber: DWORD,
    dwPlatformId: DWORD,
    szCSDVersion: [128]WCHAR,
};
pub const OSVERSIONINFOW = struct__OSVERSIONINFOW;
pub const POSVERSIONINFOW = [*c]struct__OSVERSIONINFOW;
pub const LPOSVERSIONINFOW = [*c]struct__OSVERSIONINFOW;
pub const RTL_OSVERSIONINFOW = struct__OSVERSIONINFOW;
pub const PRTL_OSVERSIONINFOW = [*c]struct__OSVERSIONINFOW;
pub const OSVERSIONINFO = OSVERSIONINFOA;
pub const POSVERSIONINFO = POSVERSIONINFOA;
pub const LPOSVERSIONINFO = LPOSVERSIONINFOA;
pub const struct__OSVERSIONINFOEXA = extern struct {
    dwOSVersionInfoSize: DWORD,
    dwMajorVersion: DWORD,
    dwMinorVersion: DWORD,
    dwBuildNumber: DWORD,
    dwPlatformId: DWORD,
    szCSDVersion: [128]CHAR,
    wServicePackMajor: WORD,
    wServicePackMinor: WORD,
    wSuiteMask: WORD,
    wProductType: BYTE,
    wReserved: BYTE,
};
pub const OSVERSIONINFOEXA = struct__OSVERSIONINFOEXA;
pub const POSVERSIONINFOEXA = [*c]struct__OSVERSIONINFOEXA;
pub const LPOSVERSIONINFOEXA = [*c]struct__OSVERSIONINFOEXA;
pub const struct__OSVERSIONINFOEXW = extern struct {
    dwOSVersionInfoSize: DWORD,
    dwMajorVersion: DWORD,
    dwMinorVersion: DWORD,
    dwBuildNumber: DWORD,
    dwPlatformId: DWORD,
    szCSDVersion: [128]WCHAR,
    wServicePackMajor: WORD,
    wServicePackMinor: WORD,
    wSuiteMask: WORD,
    wProductType: BYTE,
    wReserved: BYTE,
};
pub const OSVERSIONINFOEXW = struct__OSVERSIONINFOEXW;
pub const POSVERSIONINFOEXW = [*c]struct__OSVERSIONINFOEXW;
pub const LPOSVERSIONINFOEXW = [*c]struct__OSVERSIONINFOEXW;
pub const RTL_OSVERSIONINFOEXW = struct__OSVERSIONINFOEXW;
pub const PRTL_OSVERSIONINFOEXW = [*c]struct__OSVERSIONINFOEXW;
pub const OSVERSIONINFOEX = OSVERSIONINFOEXA;
pub const POSVERSIONINFOEX = POSVERSIONINFOEXA;
pub const LPOSVERSIONINFOEX = LPOSVERSIONINFOEXA;
pub extern "kernel32" fn VerSetConditionMask(ConditionMask: ULONGLONG, TypeMask: DWORD, Condition: BYTE) callconv(.Stdcall) ULONGLONG;
pub extern "kernel32" fn RtlGetProductInfo(OSMajorVersion: DWORD, OSMinorVersion: DWORD, SpMajorVersion: DWORD, SpMinorVersion: DWORD, ReturnedProductType: PDWORD) callconv(.Stdcall) BOOLEAN;
pub const UmsThreadInvalidInfoClass = enum__RTL_UMS_THREAD_INFO_CLASS.UmsThreadInvalidInfoClass;
pub const UmsThreadUserContext = enum__RTL_UMS_THREAD_INFO_CLASS.UmsThreadUserContext;
pub const UmsThreadPriority = enum__RTL_UMS_THREAD_INFO_CLASS.UmsThreadPriority;
pub const UmsThreadAffinity = enum__RTL_UMS_THREAD_INFO_CLASS.UmsThreadAffinity;
pub const UmsThreadTeb = enum__RTL_UMS_THREAD_INFO_CLASS.UmsThreadTeb;
pub const UmsThreadIsSuspended = enum__RTL_UMS_THREAD_INFO_CLASS.UmsThreadIsSuspended;
pub const UmsThreadIsTerminated = enum__RTL_UMS_THREAD_INFO_CLASS.UmsThreadIsTerminated;
pub const UmsThreadMaxInfoClass = enum__RTL_UMS_THREAD_INFO_CLASS.UmsThreadMaxInfoClass;
pub const enum__RTL_UMS_THREAD_INFO_CLASS = extern enum {
    UmsThreadInvalidInfoClass = 0,
    UmsThreadUserContext = 1,
    UmsThreadPriority = 2,
    UmsThreadAffinity = 3,
    UmsThreadTeb = 4,
    UmsThreadIsSuspended = 5,
    UmsThreadIsTerminated = 6,
    UmsThreadMaxInfoClass = 7,
};
pub const RTL_UMS_THREAD_INFO_CLASS = enum__RTL_UMS_THREAD_INFO_CLASS;
pub const PRTL_UMS_THREAD_INFO_CLASS = [*c]enum__RTL_UMS_THREAD_INFO_CLASS;
pub const UmsSchedulerStartup = enum__RTL_UMS_SCHEDULER_REASON.UmsSchedulerStartup;
pub const UmsSchedulerThreadBlocked = enum__RTL_UMS_SCHEDULER_REASON.UmsSchedulerThreadBlocked;
pub const UmsSchedulerThreadYield = enum__RTL_UMS_SCHEDULER_REASON.UmsSchedulerThreadYield;
pub const enum__RTL_UMS_SCHEDULER_REASON = extern enum {
    UmsSchedulerStartup = 0,
    UmsSchedulerThreadBlocked = 1,
    UmsSchedulerThreadYield = 2,
};
pub const RTL_UMS_SCHEDULER_REASON = enum__RTL_UMS_SCHEDULER_REASON;
pub const PRTL_UMS_SCHEDULER_REASON = [*c]enum__RTL_UMS_SCHEDULER_REASON;
pub const RTL_UMS_SCHEDULER_ENTRY_POINT = fn (RTL_UMS_SCHEDULER_REASON, ULONG_PTR, PVOID) callconv(.C) void;
pub const PRTL_UMS_SCHEDULER_ENTRY_POINT = [*c]RTL_UMS_SCHEDULER_ENTRY_POINT;
pub extern fn RtlCrc32(Buffer: ?*const c_void, Size: usize, InitialCrc: DWORD) DWORD;
pub extern fn RtlCrc64(Buffer: ?*const c_void, Size: usize, InitialCrc: ULONGLONG) ULONGLONG;
pub const OS_DEPLOYMENT_STANDARD = enum__OS_DEPLOYEMENT_STATE_VALUES.OS_DEPLOYMENT_STANDARD;
pub const OS_DEPLOYMENT_COMPACT = enum__OS_DEPLOYEMENT_STATE_VALUES.OS_DEPLOYMENT_COMPACT;
pub const enum__OS_DEPLOYEMENT_STATE_VALUES = extern enum {
    OS_DEPLOYMENT_STANDARD = 1,
    OS_DEPLOYMENT_COMPACT = 2,
};
pub const OS_DEPLOYEMENT_STATE_VALUES = enum__OS_DEPLOYEMENT_STATE_VALUES;
pub extern fn RtlOsDeploymentState(Flags: DWORD) OS_DEPLOYEMENT_STATE_VALUES;
pub const struct__NV_MEMORY_RANGE = extern struct {
    BaseAddress: ?*c_void,
    Length: SIZE_T,
};
pub const NV_MEMORY_RANGE = struct__NV_MEMORY_RANGE;
pub const PNV_MEMORY_RANGE = [*c]struct__NV_MEMORY_RANGE;
pub extern fn RtlGetNonVolatileToken(NvBuffer: PVOID, Size: SIZE_T, NvToken: [*c]PVOID) DWORD;
pub extern fn RtlFreeNonVolatileToken(NvToken: PVOID) DWORD;
pub extern fn RtlFlushNonVolatileMemory(NvToken: PVOID, NvBuffer: PVOID, Size: SIZE_T, Flags: DWORD) DWORD;
pub extern fn RtlDrainNonVolatileFlush(NvToken: PVOID) DWORD;
pub extern fn RtlWriteNonVolatileMemory(NvToken: PVOID, NvDestination: ?*c_void, Source: ?*const c_void, Size: SIZE_T, Flags: DWORD) DWORD;
pub extern fn RtlFillNonVolatileMemory(NvToken: PVOID, NvDestination: ?*c_void, Size: SIZE_T, Value: BYTE, Flags: DWORD) DWORD;
pub extern fn RtlFlushNonVolatileMemoryRanges(NvToken: PVOID, NvRanges: PNV_MEMORY_RANGE, NumRanges: SIZE_T, Flags: DWORD) DWORD;
pub const struct_CORRELATION_VECTOR = extern struct {
    Version: CHAR,
    Vector: [129]CHAR,
};
pub const CORRELATION_VECTOR = struct_CORRELATION_VECTOR;
pub const PCORRELATION_VECTOR = [*c]CORRELATION_VECTOR;
pub extern fn RtlInitializeCorrelationVector(CorrelationVector: PCORRELATION_VECTOR, Version: c_int, Guid: [*c]const GUID) DWORD;
pub extern fn RtlIncrementCorrelationVector(CorrelationVector: PCORRELATION_VECTOR) DWORD;
pub extern fn RtlExtendCorrelationVector(CorrelationVector: PCORRELATION_VECTOR) DWORD;
pub extern fn RtlValidateCorrelationVector(Vector: PCORRELATION_VECTOR) DWORD;
pub const struct__CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = extern struct {
    Size: DWORD,
    TriggerId: PCWSTR,
};
pub const CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = struct__CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG;
pub const PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = [*c]struct__CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG;
pub fn CUSTOM_SYSTEM_EVENT_TRIGGER_INIT(Config: PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG, TriggerId: PCWSTR) void {
    _ = memset(@ptrCast(?*c_void, Config), 0, @sizeOf(CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG));
    Config.?.Size = DWORD(@sizeOf(CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG));
    Config.?.TriggerId = TriggerId;
}
pub extern fn RtlRaiseCustomSystemEventTrigger(TriggerConfig: PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG) DWORD;
pub const ImagePolicyEntryTypeNone = enum__IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeNone;
pub const ImagePolicyEntryTypeBool = enum__IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeBool;
pub const ImagePolicyEntryTypeInt8 = enum__IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeInt8;
pub const ImagePolicyEntryTypeUInt8 = enum__IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUInt8;
pub const ImagePolicyEntryTypeInt16 = enum__IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeInt16;
pub const ImagePolicyEntryTypeUInt16 = enum__IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUInt16;
pub const ImagePolicyEntryTypeInt32 = enum__IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeInt32;
pub const ImagePolicyEntryTypeUInt32 = enum__IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUInt32;
pub const ImagePolicyEntryTypeInt64 = enum__IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeInt64;
pub const ImagePolicyEntryTypeUInt64 = enum__IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUInt64;
pub const ImagePolicyEntryTypeAnsiString = enum__IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeAnsiString;
pub const ImagePolicyEntryTypeUnicodeString = enum__IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUnicodeString;
pub const ImagePolicyEntryTypeOverride = enum__IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeOverride;
pub const ImagePolicyEntryTypeMaximum = enum__IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeMaximum;
pub const enum__IMAGE_POLICY_ENTRY_TYPE = extern enum {
    ImagePolicyEntryTypeNone = 0,
    ImagePolicyEntryTypeBool = 1,
    ImagePolicyEntryTypeInt8 = 2,
    ImagePolicyEntryTypeUInt8 = 3,
    ImagePolicyEntryTypeInt16 = 4,
    ImagePolicyEntryTypeUInt16 = 5,
    ImagePolicyEntryTypeInt32 = 6,
    ImagePolicyEntryTypeUInt32 = 7,
    ImagePolicyEntryTypeInt64 = 8,
    ImagePolicyEntryTypeUInt64 = 9,
    ImagePolicyEntryTypeAnsiString = 10,
    ImagePolicyEntryTypeUnicodeString = 11,
    ImagePolicyEntryTypeOverride = 12,
    ImagePolicyEntryTypeMaximum = 13,
};
pub const IMAGE_POLICY_ENTRY_TYPE = enum__IMAGE_POLICY_ENTRY_TYPE;
pub const ImagePolicyIdNone = enum__IMAGE_POLICY_ID.ImagePolicyIdNone;
pub const ImagePolicyIdEtw = enum__IMAGE_POLICY_ID.ImagePolicyIdEtw;
pub const ImagePolicyIdDebug = enum__IMAGE_POLICY_ID.ImagePolicyIdDebug;
pub const ImagePolicyIdCrashDump = enum__IMAGE_POLICY_ID.ImagePolicyIdCrashDump;
pub const ImagePolicyIdCrashDumpKey = enum__IMAGE_POLICY_ID.ImagePolicyIdCrashDumpKey;
pub const ImagePolicyIdCrashDumpKeyGuid = enum__IMAGE_POLICY_ID.ImagePolicyIdCrashDumpKeyGuid;
pub const ImagePolicyIdParentSd = enum__IMAGE_POLICY_ID.ImagePolicyIdParentSd;
pub const ImagePolicyIdParentSdRev = enum__IMAGE_POLICY_ID.ImagePolicyIdParentSdRev;
pub const ImagePolicyIdSvn = enum__IMAGE_POLICY_ID.ImagePolicyIdSvn;
pub const ImagePolicyIdDeviceId = enum__IMAGE_POLICY_ID.ImagePolicyIdDeviceId;
pub const ImagePolicyIdCapability = enum__IMAGE_POLICY_ID.ImagePolicyIdCapability;
pub const ImagePolicyIdScenarioId = enum__IMAGE_POLICY_ID.ImagePolicyIdScenarioId;
pub const ImagePolicyIdMaximum = enum__IMAGE_POLICY_ID.ImagePolicyIdMaximum;
pub const enum__IMAGE_POLICY_ID = extern enum {
    ImagePolicyIdNone = 0,
    ImagePolicyIdEtw = 1,
    ImagePolicyIdDebug = 2,
    ImagePolicyIdCrashDump = 3,
    ImagePolicyIdCrashDumpKey = 4,
    ImagePolicyIdCrashDumpKeyGuid = 5,
    ImagePolicyIdParentSd = 6,
    ImagePolicyIdParentSdRev = 7,
    ImagePolicyIdSvn = 8,
    ImagePolicyIdDeviceId = 9,
    ImagePolicyIdCapability = 10,
    ImagePolicyIdScenarioId = 11,
    ImagePolicyIdMaximum = 12,
};
pub const IMAGE_POLICY_ID = enum__IMAGE_POLICY_ID;
pub const struct__IMAGE_POLICY_ENTRY = extern struct {
    Type: IMAGE_POLICY_ENTRY_TYPE,
    PolicyId: IMAGE_POLICY_ID,
    u: extern union {
        None: ?*const c_void,
        BoolValue: BOOLEAN,
        Int8Value: INT8,
        UInt8Value: UINT8,
        Int16Value: INT16,
        UInt16Value: UINT16,
        Int32Value: INT32,
        UInt32Value: UINT32,
        Int64Value: INT64,
        UInt64Value: UINT64,
        AnsiStringValue: PCSTR,
        UnicodeStringValue: PCWSTR,
    },
};
pub const IMAGE_POLICY_ENTRY = struct__IMAGE_POLICY_ENTRY;
pub const PCIMAGE_POLICY_ENTRY = [*c]const IMAGE_POLICY_ENTRY;
pub const struct__IMAGE_POLICY_METADATA = extern struct {
    Version: BYTE,
    Reserved0: [7]BYTE,
    ApplicationId: ULONGLONG,
    Policies: [*c]IMAGE_POLICY_ENTRY,
};
pub const IMAGE_POLICY_METADATA = struct__IMAGE_POLICY_METADATA;
pub const PCIMAGE_POLICY_METADATA = [*c]const IMAGE_POLICY_METADATA;
pub const PRTL_CRITICAL_SECTION_DEBUG = [*c]struct__RTL_CRITICAL_SECTION_DEBUG;
pub const struct__RTL_CRITICAL_SECTION = extern struct {
    DebugInfo: PRTL_CRITICAL_SECTION_DEBUG,
    LockCount: LONG,
    RecursionCount: LONG,
    OwningThread: HANDLE,
    LockSemaphore: HANDLE,
    SpinCount: ULONG_PTR,
};
pub const struct__RTL_CRITICAL_SECTION_DEBUG = extern struct {
    Type: WORD,
    CreatorBackTraceIndex: WORD,
    CriticalSection: [*c]struct__RTL_CRITICAL_SECTION,
    ProcessLocksList: LIST_ENTRY,
    EntryCount: DWORD,
    ContentionCount: DWORD,
    Flags: DWORD,
    CreatorBackTraceIndexHigh: WORD,
    SpareWORD: WORD,
};
pub const RTL_CRITICAL_SECTION_DEBUG = struct__RTL_CRITICAL_SECTION_DEBUG;
pub const RTL_RESOURCE_DEBUG = struct__RTL_CRITICAL_SECTION_DEBUG;
pub const PRTL_RESOURCE_DEBUG = [*c]struct__RTL_CRITICAL_SECTION_DEBUG;
pub const RTL_CRITICAL_SECTION = struct__RTL_CRITICAL_SECTION;
pub const PRTL_CRITICAL_SECTION = [*c]struct__RTL_CRITICAL_SECTION;
pub const struct__RTL_SRWLOCK = extern struct {
    Ptr: PVOID,
};
pub const RTL_SRWLOCK = struct__RTL_SRWLOCK;
pub const PRTL_SRWLOCK = [*c]struct__RTL_SRWLOCK;
pub const struct__RTL_CONDITION_VARIABLE = extern struct {
    Ptr: PVOID,
};
pub const RTL_CONDITION_VARIABLE = struct__RTL_CONDITION_VARIABLE;
pub const PRTL_CONDITION_VARIABLE = [*c]struct__RTL_CONDITION_VARIABLE;
pub const PAPCFUNC = ?fn (ULONG_PTR) callconv(.C) void;
pub const PVECTORED_EXCEPTION_HANDLER = ?fn ([*c]struct__EXCEPTION_POINTERS) callconv(.C) LONG;
pub const HeapCompatibilityInformation = enum__HEAP_INFORMATION_CLASS.HeapCompatibilityInformation;
pub const HeapEnableTerminationOnCorruption = enum__HEAP_INFORMATION_CLASS.HeapEnableTerminationOnCorruption;
pub const HeapOptimizeResources = enum__HEAP_INFORMATION_CLASS.HeapOptimizeResources;
pub const enum__HEAP_INFORMATION_CLASS = extern enum {
    HeapCompatibilityInformation = 0,
    HeapEnableTerminationOnCorruption = 1,
    HeapOptimizeResources = 3,
};
pub const HEAP_INFORMATION_CLASS = enum__HEAP_INFORMATION_CLASS;
pub const struct__HEAP_OPTIMIZE_RESOURCES_INFORMATION = extern struct {
    Version: DWORD,
    Flags: DWORD,
};
pub const HEAP_OPTIMIZE_RESOURCES_INFORMATION = struct__HEAP_OPTIMIZE_RESOURCES_INFORMATION;
pub const PHEAP_OPTIMIZE_RESOURCES_INFORMATION = [*c]struct__HEAP_OPTIMIZE_RESOURCES_INFORMATION;
pub const WAITORTIMERCALLBACKFUNC = ?fn (PVOID, BOOLEAN) callconv(.C) void;
pub const WORKERCALLBACKFUNC = ?fn (PVOID) callconv(.C) void;
pub const APC_CALLBACK_FUNCTION = ?fn (DWORD, PVOID, PVOID) callconv(.C) void;
pub const WAITORTIMERCALLBACK = WAITORTIMERCALLBACKFUNC;
pub const PFLS_CALLBACK_FUNCTION = ?fn (PVOID) callconv(.C) void;
pub const PSECURE_MEMORY_CACHE_CALLBACK = ?fn (PVOID, SIZE_T) callconv(.C) BOOLEAN;
pub const ActivationContextBasicInformation = enum__ACTIVATION_CONTEXT_INFO_CLASS.ActivationContextBasicInformation;
pub const ActivationContextDetailedInformation = enum__ACTIVATION_CONTEXT_INFO_CLASS.ActivationContextDetailedInformation;
pub const AssemblyDetailedInformationInActivationContext = enum__ACTIVATION_CONTEXT_INFO_CLASS.AssemblyDetailedInformationInActivationContext;
pub const FileInformationInAssemblyOfAssemblyInActivationContext = enum__ACTIVATION_CONTEXT_INFO_CLASS.FileInformationInAssemblyOfAssemblyInActivationContext;
pub const RunlevelInformationInActivationContext = enum__ACTIVATION_CONTEXT_INFO_CLASS.RunlevelInformationInActivationContext;
pub const CompatibilityInformationInActivationContext = enum__ACTIVATION_CONTEXT_INFO_CLASS.CompatibilityInformationInActivationContext;
pub const ActivationContextManifestResourceName = enum__ACTIVATION_CONTEXT_INFO_CLASS.ActivationContextManifestResourceName;
pub const MaxActivationContextInfoClass = enum__ACTIVATION_CONTEXT_INFO_CLASS.MaxActivationContextInfoClass;
pub const AssemblyDetailedInformationInActivationContxt = enum__ACTIVATION_CONTEXT_INFO_CLASS.AssemblyDetailedInformationInActivationContxt;
pub const FileInformationInAssemblyOfAssemblyInActivationContxt = enum__ACTIVATION_CONTEXT_INFO_CLASS.FileInformationInAssemblyOfAssemblyInActivationContxt;
pub const enum__ACTIVATION_CONTEXT_INFO_CLASS = extern enum {
    ActivationContextBasicInformation = 1,
    ActivationContextDetailedInformation = 2,
    AssemblyDetailedInformationInActivationContext = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext = 4,
    RunlevelInformationInActivationContext = 5,
    CompatibilityInformationInActivationContext = 6,
    ActivationContextManifestResourceName = 7,
    MaxActivationContextInfoClass = 8,
    AssemblyDetailedInformationInActivationContxt = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt = 4,
};
pub const ACTIVATION_CONTEXT_INFO_CLASS = enum__ACTIVATION_CONTEXT_INFO_CLASS;
pub const struct__ACTIVATION_CONTEXT_QUERY_INDEX = extern struct {
    ulAssemblyIndex: DWORD,
    ulFileIndexInAssembly: DWORD,
};
pub const ACTIVATION_CONTEXT_QUERY_INDEX = struct__ACTIVATION_CONTEXT_QUERY_INDEX;
pub const PACTIVATION_CONTEXT_QUERY_INDEX = [*c]struct__ACTIVATION_CONTEXT_QUERY_INDEX;
pub const PCACTIVATION_CONTEXT_QUERY_INDEX = [*c]const struct__ACTIVATION_CONTEXT_QUERY_INDEX;
pub const struct__ASSEMBLY_FILE_DETAILED_INFORMATION = extern struct {
    ulFlags: DWORD,
    ulFilenameLength: DWORD,
    ulPathLength: DWORD,
    lpFileName: PCWSTR,
    lpFilePath: PCWSTR,
};
pub const ASSEMBLY_FILE_DETAILED_INFORMATION = struct__ASSEMBLY_FILE_DETAILED_INFORMATION;
pub const PASSEMBLY_FILE_DETAILED_INFORMATION = [*c]struct__ASSEMBLY_FILE_DETAILED_INFORMATION;
pub const PCASSEMBLY_FILE_DETAILED_INFORMATION = [*c]const ASSEMBLY_FILE_DETAILED_INFORMATION;
pub const struct__ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = extern struct {
    ulFlags: DWORD,
    ulEncodedAssemblyIdentityLength: DWORD,
    ulManifestPathType: DWORD,
    ulManifestPathLength: DWORD,
    liManifestLastWriteTime: LARGE_INTEGER,
    ulPolicyPathType: DWORD,
    ulPolicyPathLength: DWORD,
    liPolicyLastWriteTime: LARGE_INTEGER,
    ulMetadataSatelliteRosterIndex: DWORD,
    ulManifestVersionMajor: DWORD,
    ulManifestVersionMinor: DWORD,
    ulPolicyVersionMajor: DWORD,
    ulPolicyVersionMinor: DWORD,
    ulAssemblyDirectoryNameLength: DWORD,
    lpAssemblyEncodedAssemblyIdentity: PCWSTR,
    lpAssemblyManifestPath: PCWSTR,
    lpAssemblyPolicyPath: PCWSTR,
    lpAssemblyDirectoryName: PCWSTR,
    ulFileCount: DWORD,
};
pub const ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = struct__ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
pub const PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = [*c]struct__ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
pub const PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = [*c]const struct__ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
pub const ACTCTX_RUN_LEVEL_UNSPECIFIED = 0;
pub const ACTCTX_RUN_LEVEL_AS_INVOKER = 1;
pub const ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = 2;
pub const ACTCTX_RUN_LEVEL_REQUIRE_ADMIN = 3;
pub const ACTCTX_RUN_LEVEL_NUMBERS = 4;
pub const ACTCTX_REQUESTED_RUN_LEVEL = extern enum {
    ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
    ACTCTX_RUN_LEVEL_AS_INVOKER = 1,
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = 2,
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN = 3,
    ACTCTX_RUN_LEVEL_NUMBERS = 4,
};
pub const struct__ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = extern struct {
    ulFlags: DWORD,
    RunLevel: ACTCTX_REQUESTED_RUN_LEVEL,
    UiAccess: DWORD,
};
pub const ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = struct__ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
pub const PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = [*c]struct__ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
pub const PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = [*c]const struct__ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS = 1;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION = 2;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED = 3;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE = extern enum {
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS = 1,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION = 2,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED = 3,
};
pub const struct__COMPATIBILITY_CONTEXT_ELEMENT = extern struct {
    Id: GUID,
    Type: ACTCTX_COMPATIBILITY_ELEMENT_TYPE,
    MaxVersionTested: ULONGLONG,
};
pub const COMPATIBILITY_CONTEXT_ELEMENT = struct__COMPATIBILITY_CONTEXT_ELEMENT;
pub const PCOMPATIBILITY_CONTEXT_ELEMENT = [*c]struct__COMPATIBILITY_CONTEXT_ELEMENT;
pub const PCCOMPATIBILITY_CONTEXT_ELEMENT = [*c]const struct__COMPATIBILITY_CONTEXT_ELEMENT;
pub const struct__ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = extern struct {
    ElementCount: DWORD,
    Elements: [*c]COMPATIBILITY_CONTEXT_ELEMENT,
};
pub const ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = struct__ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
pub const PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = [*c]struct__ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
pub const PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = [*c]const struct__ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
pub const struct__SUPPORTED_OS_INFO = extern struct {
    MajorVersion: WORD,
    MinorVersion: WORD,
};
pub const SUPPORTED_OS_INFO = struct__SUPPORTED_OS_INFO;
pub const PSUPPORTED_OS_INFO = [*c]struct__SUPPORTED_OS_INFO;
pub const struct__MAXVERSIONTESTED_INFO = extern struct {
    MaxVersionTested: ULONGLONG,
};
pub const MAXVERSIONTESTED_INFO = struct__MAXVERSIONTESTED_INFO;
pub const PMAXVERSIONTESTED_INFO = [*c]struct__MAXVERSIONTESTED_INFO;
pub const struct__ACTIVATION_CONTEXT_DETAILED_INFORMATION = extern struct {
    dwFlags: DWORD,
    ulFormatVersion: DWORD,
    ulAssemblyCount: DWORD,
    ulRootManifestPathType: DWORD,
    ulRootManifestPathChars: DWORD,
    ulRootConfigurationPathType: DWORD,
    ulRootConfigurationPathChars: DWORD,
    ulAppDirPathType: DWORD,
    ulAppDirPathChars: DWORD,
    lpRootManifestPath: PCWSTR,
    lpRootConfigurationPath: PCWSTR,
    lpAppDirPath: PCWSTR,
};
pub const ACTIVATION_CONTEXT_DETAILED_INFORMATION = struct__ACTIVATION_CONTEXT_DETAILED_INFORMATION;
pub const PACTIVATION_CONTEXT_DETAILED_INFORMATION = [*c]struct__ACTIVATION_CONTEXT_DETAILED_INFORMATION;
pub const PCACTIVATION_CONTEXT_DETAILED_INFORMATION = [*c]const struct__ACTIVATION_CONTEXT_DETAILED_INFORMATION;
pub const struct__HARDWARE_COUNTER_DATA = extern struct {
    Type: HARDWARE_COUNTER_TYPE,
    Reserved: DWORD,
    Value: DWORD64,
};
pub const HARDWARE_COUNTER_DATA = struct__HARDWARE_COUNTER_DATA;
pub const PHARDWARE_COUNTER_DATA = [*c]struct__HARDWARE_COUNTER_DATA;
pub const struct__PERFORMANCE_DATA = extern struct {
    Size: WORD,
    Version: BYTE,
    HwCountersCount: BYTE,
    ContextSwitchCount: DWORD,
    WaitReasonBitMap: DWORD64,
    CycleTime: DWORD64,
    RetryCount: DWORD,
    Reserved: DWORD,
    HwCounters: [16]HARDWARE_COUNTER_DATA,
};
pub const PERFORMANCE_DATA = struct__PERFORMANCE_DATA;
pub const PPERFORMANCE_DATA = [*c]struct__PERFORMANCE_DATA;
pub extern fn RtlGetDeviceFamilyInfoEnum(pullUAPInfo: [*c]ULONGLONG, pulDeviceFamily: [*c]DWORD, pulDeviceForm: [*c]DWORD) void;
pub extern fn RtlConvertDeviceFamilyInfoToString(pulDeviceFamilyBufferSize: PDWORD, pulDeviceFormBufferSize: PDWORD, DeviceFamily: PWSTR, DeviceForm: PWSTR) DWORD;
pub extern fn RtlSwitchedVVI(VersionInfo: PRTL_OSVERSIONINFOEXW, TypeMask: DWORD, ConditionMask: ULONGLONG) DWORD;
pub const struct__EVENTLOGRECORD = extern struct {
    Length: DWORD,
    Reserved: DWORD,
    RecordNumber: DWORD,
    TimeGenerated: DWORD,
    TimeWritten: DWORD,
    EventID: DWORD,
    EventType: WORD,
    NumStrings: WORD,
    EventCategory: WORD,
    ReservedFlags: WORD,
    ClosingRecordNumber: DWORD,
    StringOffset: DWORD,
    UserSidLength: DWORD,
    UserSidOffset: DWORD,
    DataLength: DWORD,
    DataOffset: DWORD,
};
pub const EVENTLOGRECORD = struct__EVENTLOGRECORD;
pub const PEVENTLOGRECORD = [*c]struct__EVENTLOGRECORD;
pub const struct__EVENTSFORLOGFILE = extern struct {
    ulSize: DWORD,
    szLogicalLogFile: [256]WCHAR,
    ulNumRecords: DWORD,
    pEventLogRecords: [*c]EVENTLOGRECORD,
};
pub const EVENTSFORLOGFILE = struct__EVENTSFORLOGFILE;
pub const PEVENTSFORLOGFILE = [*c]struct__EVENTSFORLOGFILE;
pub const struct__PACKEDEVENTINFO = extern struct {
    ulSize: DWORD,
    ulNumEventsForLogFile: DWORD,
    ulOffsets: [*c]DWORD,
};
pub const PACKEDEVENTINFO = struct__PACKEDEVENTINFO;
pub const PPACKEDEVENTINFO = [*c]struct__PACKEDEVENTINFO;
pub const DriverType = enum__CM_SERVICE_NODE_TYPE.DriverType;
pub const FileSystemType = enum__CM_SERVICE_NODE_TYPE.FileSystemType;
pub const Win32ServiceOwnProcess = enum__CM_SERVICE_NODE_TYPE.Win32ServiceOwnProcess;
pub const Win32ServiceShareProcess = enum__CM_SERVICE_NODE_TYPE.Win32ServiceShareProcess;
pub const AdapterType = enum__CM_SERVICE_NODE_TYPE.AdapterType;
pub const RecognizerType = enum__CM_SERVICE_NODE_TYPE.RecognizerType;
pub const enum__CM_SERVICE_NODE_TYPE = extern enum {
    DriverType = 1,
    FileSystemType = 2,
    Win32ServiceOwnProcess = 16,
    Win32ServiceShareProcess = 32,
    AdapterType = 4,
    RecognizerType = 8,
};
pub const SERVICE_NODE_TYPE = enum__CM_SERVICE_NODE_TYPE;
pub const BootLoad = enum__CM_SERVICE_LOAD_TYPE.BootLoad;
pub const SystemLoad = enum__CM_SERVICE_LOAD_TYPE.SystemLoad;
pub const AutoLoad = enum__CM_SERVICE_LOAD_TYPE.AutoLoad;
pub const DemandLoad = enum__CM_SERVICE_LOAD_TYPE.DemandLoad;
pub const DisableLoad = enum__CM_SERVICE_LOAD_TYPE.DisableLoad;
pub const enum__CM_SERVICE_LOAD_TYPE = extern enum {
    BootLoad = 0,
    SystemLoad = 1,
    AutoLoad = 2,
    DemandLoad = 3,
    DisableLoad = 4,
};
pub const SERVICE_LOAD_TYPE = enum__CM_SERVICE_LOAD_TYPE;
pub const IgnoreError = enum__CM_ERROR_CONTROL_TYPE.IgnoreError;
pub const NormalError = enum__CM_ERROR_CONTROL_TYPE.NormalError;
pub const SevereError = enum__CM_ERROR_CONTROL_TYPE.SevereError;
pub const CriticalError = enum__CM_ERROR_CONTROL_TYPE.CriticalError;
pub const enum__CM_ERROR_CONTROL_TYPE = extern enum {
    IgnoreError = 0,
    NormalError = 1,
    SevereError = 2,
    CriticalError = 3,
};
pub const SERVICE_ERROR_TYPE = enum__CM_ERROR_CONTROL_TYPE;
pub const struct__TAPE_ERASE = extern struct {
    Type: DWORD,
    Immediate: BOOLEAN,
};
pub const TAPE_ERASE = struct__TAPE_ERASE;
pub const PTAPE_ERASE = [*c]struct__TAPE_ERASE;
pub const struct__TAPE_PREPARE = extern struct {
    Operation: DWORD,
    Immediate: BOOLEAN,
};
pub const TAPE_PREPARE = struct__TAPE_PREPARE;
pub const PTAPE_PREPARE = [*c]struct__TAPE_PREPARE;
pub const struct__TAPE_WRITE_MARKS = extern struct {
    Type: DWORD,
    Count: DWORD,
    Immediate: BOOLEAN,
};
pub const TAPE_WRITE_MARKS = struct__TAPE_WRITE_MARKS;
pub const PTAPE_WRITE_MARKS = [*c]struct__TAPE_WRITE_MARKS;
pub const struct__TAPE_GET_POSITION = extern struct {
    Type: DWORD,
    Partition: DWORD,
    Offset: LARGE_INTEGER,
};
pub const TAPE_GET_POSITION = struct__TAPE_GET_POSITION;
pub const PTAPE_GET_POSITION = [*c]struct__TAPE_GET_POSITION;
pub const struct__TAPE_SET_POSITION = extern struct {
    Method: DWORD,
    Partition: DWORD,
    Offset: LARGE_INTEGER,
    Immediate: BOOLEAN,
};
pub const TAPE_SET_POSITION = struct__TAPE_SET_POSITION;
pub const PTAPE_SET_POSITION = [*c]struct__TAPE_SET_POSITION;
pub const struct__TAPE_GET_DRIVE_PARAMETERS = extern struct {
    ECC: BOOLEAN,
    Compression: BOOLEAN,
    DataPadding: BOOLEAN,
    ReportSetmarks: BOOLEAN,
    DefaultBlockSize: DWORD,
    MaximumBlockSize: DWORD,
    MinimumBlockSize: DWORD,
    MaximumPartitionCount: DWORD,
    FeaturesLow: DWORD,
    FeaturesHigh: DWORD,
    EOTWarningZoneSize: DWORD,
};
pub const TAPE_GET_DRIVE_PARAMETERS = struct__TAPE_GET_DRIVE_PARAMETERS;
pub const PTAPE_GET_DRIVE_PARAMETERS = [*c]struct__TAPE_GET_DRIVE_PARAMETERS;
pub const struct__TAPE_SET_DRIVE_PARAMETERS = extern struct {
    ECC: BOOLEAN,
    Compression: BOOLEAN,
    DataPadding: BOOLEAN,
    ReportSetmarks: BOOLEAN,
    EOTWarningZoneSize: DWORD,
};
pub const TAPE_SET_DRIVE_PARAMETERS = struct__TAPE_SET_DRIVE_PARAMETERS;
pub const PTAPE_SET_DRIVE_PARAMETERS = [*c]struct__TAPE_SET_DRIVE_PARAMETERS;
pub const struct__TAPE_GET_MEDIA_PARAMETERS = extern struct {
    Capacity: LARGE_INTEGER,
    Remaining: LARGE_INTEGER,
    BlockSize: DWORD,
    PartitionCount: DWORD,
    WriteProtected: BOOLEAN,
};
pub const TAPE_GET_MEDIA_PARAMETERS = struct__TAPE_GET_MEDIA_PARAMETERS;
pub const PTAPE_GET_MEDIA_PARAMETERS = [*c]struct__TAPE_GET_MEDIA_PARAMETERS;
pub const struct__TAPE_SET_MEDIA_PARAMETERS = extern struct {
    BlockSize: DWORD,
};
pub const TAPE_SET_MEDIA_PARAMETERS = struct__TAPE_SET_MEDIA_PARAMETERS;
pub const PTAPE_SET_MEDIA_PARAMETERS = [*c]struct__TAPE_SET_MEDIA_PARAMETERS;
pub const struct__TAPE_CREATE_PARTITION = extern struct {
    Method: DWORD,
    Count: DWORD,
    Size: DWORD,
};
pub const TAPE_CREATE_PARTITION = struct__TAPE_CREATE_PARTITION;
pub const PTAPE_CREATE_PARTITION = [*c]struct__TAPE_CREATE_PARTITION;
pub const struct__TAPE_WMI_OPERATIONS = extern struct {
    Method: DWORD,
    DataBufferSize: DWORD,
    DataBuffer: PVOID,
};
pub const TAPE_WMI_OPERATIONS = struct__TAPE_WMI_OPERATIONS;
pub const PTAPE_WMI_OPERATIONS = [*c]struct__TAPE_WMI_OPERATIONS;
pub const TapeDriveProblemNone = enum__TAPE_DRIVE_PROBLEM_TYPE.TapeDriveProblemNone;
pub const TapeDriveReadWriteWarning = enum__TAPE_DRIVE_PROBLEM_TYPE.TapeDriveReadWriteWarning;
pub const TapeDriveReadWriteError = enum__TAPE_DRIVE_PROBLEM_TYPE.TapeDriveReadWriteError;
pub const TapeDriveReadWarning = enum__TAPE_DRIVE_PROBLEM_TYPE.TapeDriveReadWarning;
pub const TapeDriveWriteWarning = enum__TAPE_DRIVE_PROBLEM_TYPE.TapeDriveWriteWarning;
pub const TapeDriveReadError = enum__TAPE_DRIVE_PROBLEM_TYPE.TapeDriveReadError;
pub const TapeDriveWriteError = enum__TAPE_DRIVE_PROBLEM_TYPE.TapeDriveWriteError;
pub const TapeDriveHardwareError = enum__TAPE_DRIVE_PROBLEM_TYPE.TapeDriveHardwareError;
pub const TapeDriveUnsupportedMedia = enum__TAPE_DRIVE_PROBLEM_TYPE.TapeDriveUnsupportedMedia;
pub const TapeDriveScsiConnectionError = enum__TAPE_DRIVE_PROBLEM_TYPE.TapeDriveScsiConnectionError;
pub const TapeDriveTimetoClean = enum__TAPE_DRIVE_PROBLEM_TYPE.TapeDriveTimetoClean;
pub const TapeDriveCleanDriveNow = enum__TAPE_DRIVE_PROBLEM_TYPE.TapeDriveCleanDriveNow;
pub const TapeDriveMediaLifeExpired = enum__TAPE_DRIVE_PROBLEM_TYPE.TapeDriveMediaLifeExpired;
pub const TapeDriveSnappedTape = enum__TAPE_DRIVE_PROBLEM_TYPE.TapeDriveSnappedTape;
pub const enum__TAPE_DRIVE_PROBLEM_TYPE = extern enum {
    TapeDriveProblemNone,
    TapeDriveReadWriteWarning,
    TapeDriveReadWriteError,
    TapeDriveReadWarning,
    TapeDriveWriteWarning,
    TapeDriveReadError,
    TapeDriveWriteError,
    TapeDriveHardwareError,
    TapeDriveUnsupportedMedia,
    TapeDriveScsiConnectionError,
    TapeDriveTimetoClean,
    TapeDriveCleanDriveNow,
    TapeDriveMediaLifeExpired,
    TapeDriveSnappedTape,
};
pub const TAPE_DRIVE_PROBLEM_TYPE = enum__TAPE_DRIVE_PROBLEM_TYPE;
pub const UOW = GUID;
pub const PUOW = [*c]GUID;
pub const CRM_PROTOCOL_ID = GUID;
pub const PCRM_PROTOCOL_ID = [*c]GUID;
pub const NOTIFICATION_MASK = ULONG;
pub const struct__TRANSACTION_NOTIFICATION = extern struct {
    TransactionKey: PVOID,
    TransactionNotification: ULONG,
    TmVirtualClock: LARGE_INTEGER,
    ArgumentLength: ULONG,
};
pub const TRANSACTION_NOTIFICATION = struct__TRANSACTION_NOTIFICATION;
pub const PTRANSACTION_NOTIFICATION = [*c]struct__TRANSACTION_NOTIFICATION;
pub const struct__TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = extern struct {
    EnlistmentId: GUID,
    UOW: UOW,
};
pub const TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = struct__TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
pub const PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = [*c]struct__TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
pub const struct__TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = extern struct {
    TmIdentity: GUID,
    Flags: ULONG,
};
pub const TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = struct__TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
pub const PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = [*c]struct__TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
pub const SAVEPOINT_ID = ULONG;
pub const PSAVEPOINT_ID = [*c]ULONG;
pub const struct__TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = extern struct {
    SavepointId: SAVEPOINT_ID,
};
pub const TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = struct__TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
pub const PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = [*c]struct__TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
pub const struct__TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = extern struct {
    PropagationCookie: ULONG,
    UOW: GUID,
    TmIdentity: GUID,
    BufferLength: ULONG,
};
pub const TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = struct__TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub const PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = [*c]struct__TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub const struct__TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = extern struct {
    MarshalCookie: ULONG,
    UOW: GUID,
};
pub const TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = struct__TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
pub const PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = [*c]struct__TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
pub const TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT = TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub const PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT = [*c]TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub const struct__KCRM_MARSHAL_HEADER = extern struct {
    VersionMajor: ULONG,
    VersionMinor: ULONG,
    NumProtocols: ULONG,
    Unused: ULONG,
};
pub const KCRM_MARSHAL_HEADER = struct__KCRM_MARSHAL_HEADER;
pub const PKCRM_MARSHAL_HEADER = [*c]struct__KCRM_MARSHAL_HEADER;
pub const PRKCRM_MARSHAL_HEADER = [*c]struct__KCRM_MARSHAL_HEADER;
pub const struct__KCRM_TRANSACTION_BLOB = extern struct {
    UOW: UOW,
    TmIdentity: GUID,
    IsolationLevel: ULONG,
    IsolationFlags: ULONG,
    Timeout: ULONG,
    Description: [64]WCHAR,
};
pub const KCRM_TRANSACTION_BLOB = struct__KCRM_TRANSACTION_BLOB;
pub const PKCRM_TRANSACTION_BLOB = [*c]struct__KCRM_TRANSACTION_BLOB;
pub const PRKCRM_TRANSACTION_BLOB = [*c]struct__KCRM_TRANSACTION_BLOB;
pub const struct__KCRM_PROTOCOL_BLOB = extern struct {
    ProtocolId: CRM_PROTOCOL_ID,
    StaticInfoLength: ULONG,
    TransactionIdInfoLength: ULONG,
    Unused1: ULONG,
    Unused2: ULONG,
};
pub const KCRM_PROTOCOL_BLOB = struct__KCRM_PROTOCOL_BLOB;
pub const PKCRM_PROTOCOL_BLOB = [*c]struct__KCRM_PROTOCOL_BLOB;
pub const PRKCRM_PROTOCOL_BLOB = [*c]struct__KCRM_PROTOCOL_BLOB;
pub const TransactionOutcomeUndetermined = enum__TRANSACTION_OUTCOME.TransactionOutcomeUndetermined;
pub const TransactionOutcomeCommitted = enum__TRANSACTION_OUTCOME.TransactionOutcomeCommitted;
pub const TransactionOutcomeAborted = enum__TRANSACTION_OUTCOME.TransactionOutcomeAborted;
pub const enum__TRANSACTION_OUTCOME = extern enum {
    TransactionOutcomeUndetermined = 1,
    TransactionOutcomeCommitted = 2,
    TransactionOutcomeAborted = 3,
};
pub const TRANSACTION_OUTCOME = enum__TRANSACTION_OUTCOME;
pub const TransactionStateNormal = enum__TRANSACTION_STATE.TransactionStateNormal;
pub const TransactionStateIndoubt = enum__TRANSACTION_STATE.TransactionStateIndoubt;
pub const TransactionStateCommittedNotify = enum__TRANSACTION_STATE.TransactionStateCommittedNotify;
pub const enum__TRANSACTION_STATE = extern enum {
    TransactionStateNormal = 1,
    TransactionStateIndoubt = 2,
    TransactionStateCommittedNotify = 3,
};
pub const TRANSACTION_STATE = enum__TRANSACTION_STATE;
pub const struct__TRANSACTION_BASIC_INFORMATION = extern struct {
    TransactionId: GUID,
    State: DWORD,
    Outcome: DWORD,
};
pub const TRANSACTION_BASIC_INFORMATION = struct__TRANSACTION_BASIC_INFORMATION;
pub const PTRANSACTION_BASIC_INFORMATION = [*c]struct__TRANSACTION_BASIC_INFORMATION;
pub const struct__TRANSACTIONMANAGER_BASIC_INFORMATION = extern struct {
    TmIdentity: GUID,
    VirtualClock: LARGE_INTEGER,
};
pub const TRANSACTIONMANAGER_BASIC_INFORMATION = struct__TRANSACTIONMANAGER_BASIC_INFORMATION;
pub const PTRANSACTIONMANAGER_BASIC_INFORMATION = [*c]struct__TRANSACTIONMANAGER_BASIC_INFORMATION;
pub const struct__TRANSACTIONMANAGER_LOG_INFORMATION = extern struct {
    LogIdentity: GUID,
};
pub const TRANSACTIONMANAGER_LOG_INFORMATION = struct__TRANSACTIONMANAGER_LOG_INFORMATION;
pub const PTRANSACTIONMANAGER_LOG_INFORMATION = [*c]struct__TRANSACTIONMANAGER_LOG_INFORMATION;
pub const struct__TRANSACTIONMANAGER_LOGPATH_INFORMATION = extern struct {
    LogPathLength: DWORD,
    LogPath: [1]WCHAR,
};
pub const TRANSACTIONMANAGER_LOGPATH_INFORMATION = struct__TRANSACTIONMANAGER_LOGPATH_INFORMATION;
pub const PTRANSACTIONMANAGER_LOGPATH_INFORMATION = [*c]struct__TRANSACTIONMANAGER_LOGPATH_INFORMATION;
pub const struct__TRANSACTIONMANAGER_RECOVERY_INFORMATION = extern struct {
    LastRecoveredLsn: ULONGLONG,
};
pub const TRANSACTIONMANAGER_RECOVERY_INFORMATION = struct__TRANSACTIONMANAGER_RECOVERY_INFORMATION;
pub const PTRANSACTIONMANAGER_RECOVERY_INFORMATION = [*c]struct__TRANSACTIONMANAGER_RECOVERY_INFORMATION;
pub const struct__TRANSACTIONMANAGER_OLDEST_INFORMATION = extern struct {
    OldestTransactionGuid: GUID,
};
pub const TRANSACTIONMANAGER_OLDEST_INFORMATION = struct__TRANSACTIONMANAGER_OLDEST_INFORMATION;
pub const PTRANSACTIONMANAGER_OLDEST_INFORMATION = [*c]struct__TRANSACTIONMANAGER_OLDEST_INFORMATION;
pub const struct__TRANSACTION_PROPERTIES_INFORMATION = extern struct {
    IsolationLevel: DWORD,
    IsolationFlags: DWORD,
    Timeout: LARGE_INTEGER,
    Outcome: DWORD,
    DescriptionLength: DWORD,
    Description: [1]WCHAR,
};
pub const TRANSACTION_PROPERTIES_INFORMATION = struct__TRANSACTION_PROPERTIES_INFORMATION;
pub const PTRANSACTION_PROPERTIES_INFORMATION = [*c]struct__TRANSACTION_PROPERTIES_INFORMATION;
pub const struct__TRANSACTION_BIND_INFORMATION = extern struct {
    TmHandle: HANDLE,
};
pub const TRANSACTION_BIND_INFORMATION = struct__TRANSACTION_BIND_INFORMATION;
pub const PTRANSACTION_BIND_INFORMATION = [*c]struct__TRANSACTION_BIND_INFORMATION;
pub const struct__TRANSACTION_ENLISTMENT_PAIR = extern struct {
    EnlistmentId: GUID,
    ResourceManagerId: GUID,
};
pub const TRANSACTION_ENLISTMENT_PAIR = struct__TRANSACTION_ENLISTMENT_PAIR;
pub const PTRANSACTION_ENLISTMENT_PAIR = [*c]struct__TRANSACTION_ENLISTMENT_PAIR;
pub const struct__TRANSACTION_ENLISTMENTS_INFORMATION = extern struct {
    NumberOfEnlistments: DWORD,
    EnlistmentPair: [1]TRANSACTION_ENLISTMENT_PAIR,
};
pub const TRANSACTION_ENLISTMENTS_INFORMATION = struct__TRANSACTION_ENLISTMENTS_INFORMATION;
pub const PTRANSACTION_ENLISTMENTS_INFORMATION = [*c]struct__TRANSACTION_ENLISTMENTS_INFORMATION;
pub const struct__TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = extern struct {
    SuperiorEnlistmentPair: TRANSACTION_ENLISTMENT_PAIR,
};
pub const TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = struct__TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
pub const PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = [*c]struct__TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
pub const struct__RESOURCEMANAGER_BASIC_INFORMATION = extern struct {
    ResourceManagerId: GUID,
    DescriptionLength: DWORD,
    Description: [1]WCHAR,
};
pub const RESOURCEMANAGER_BASIC_INFORMATION = struct__RESOURCEMANAGER_BASIC_INFORMATION;
pub const PRESOURCEMANAGER_BASIC_INFORMATION = [*c]struct__RESOURCEMANAGER_BASIC_INFORMATION;
pub const struct__RESOURCEMANAGER_COMPLETION_INFORMATION = extern struct {
    IoCompletionPortHandle: HANDLE,
    CompletionKey: ULONG_PTR,
};
pub const RESOURCEMANAGER_COMPLETION_INFORMATION = struct__RESOURCEMANAGER_COMPLETION_INFORMATION;
pub const PRESOURCEMANAGER_COMPLETION_INFORMATION = [*c]struct__RESOURCEMANAGER_COMPLETION_INFORMATION;
pub const TransactionBasicInformation = enum__TRANSACTION_INFORMATION_CLASS.TransactionBasicInformation;
pub const TransactionPropertiesInformation = enum__TRANSACTION_INFORMATION_CLASS.TransactionPropertiesInformation;
pub const TransactionEnlistmentInformation = enum__TRANSACTION_INFORMATION_CLASS.TransactionEnlistmentInformation;
pub const TransactionSuperiorEnlistmentInformation = enum__TRANSACTION_INFORMATION_CLASS.TransactionSuperiorEnlistmentInformation;
pub const TransactionBindInformation = enum__TRANSACTION_INFORMATION_CLASS.TransactionBindInformation;
pub const TransactionDTCPrivateInformation = enum__TRANSACTION_INFORMATION_CLASS.TransactionDTCPrivateInformation;
pub const enum__TRANSACTION_INFORMATION_CLASS = extern enum {
    TransactionBasicInformation,
    TransactionPropertiesInformation,
    TransactionEnlistmentInformation,
    TransactionSuperiorEnlistmentInformation,
    TransactionBindInformation,
    TransactionDTCPrivateInformation,
};
pub const TRANSACTION_INFORMATION_CLASS = enum__TRANSACTION_INFORMATION_CLASS;
pub const TransactionManagerBasicInformation = enum__TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerBasicInformation;
pub const TransactionManagerLogInformation = enum__TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerLogInformation;
pub const TransactionManagerLogPathInformation = enum__TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerLogPathInformation;
pub const TransactionManagerRecoveryInformation = enum__TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerRecoveryInformation;
pub const TransactionManagerOnlineProbeInformation = enum__TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerOnlineProbeInformation;
pub const TransactionManagerOldestTransactionInformation = enum__TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerOldestTransactionInformation;
pub const enum__TRANSACTIONMANAGER_INFORMATION_CLASS = extern enum {
    TransactionManagerBasicInformation = 0,
    TransactionManagerLogInformation = 1,
    TransactionManagerLogPathInformation = 2,
    TransactionManagerRecoveryInformation = 4,
    TransactionManagerOnlineProbeInformation = 3,
    TransactionManagerOldestTransactionInformation = 5,
};
pub const TRANSACTIONMANAGER_INFORMATION_CLASS = enum__TRANSACTIONMANAGER_INFORMATION_CLASS;
pub const ResourceManagerBasicInformation = enum__RESOURCEMANAGER_INFORMATION_CLASS.ResourceManagerBasicInformation;
pub const ResourceManagerCompletionInformation = enum__RESOURCEMANAGER_INFORMATION_CLASS.ResourceManagerCompletionInformation;
pub const enum__RESOURCEMANAGER_INFORMATION_CLASS = extern enum {
    ResourceManagerBasicInformation,
    ResourceManagerCompletionInformation,
};
pub const RESOURCEMANAGER_INFORMATION_CLASS = enum__RESOURCEMANAGER_INFORMATION_CLASS;
pub const struct__ENLISTMENT_BASIC_INFORMATION = extern struct {
    EnlistmentId: GUID,
    TransactionId: GUID,
    ResourceManagerId: GUID,
};
pub const ENLISTMENT_BASIC_INFORMATION = struct__ENLISTMENT_BASIC_INFORMATION;
pub const PENLISTMENT_BASIC_INFORMATION = [*c]struct__ENLISTMENT_BASIC_INFORMATION;
pub const struct__ENLISTMENT_CRM_INFORMATION = extern struct {
    CrmTransactionManagerId: GUID,
    CrmResourceManagerId: GUID,
    CrmEnlistmentId: GUID,
};
pub const ENLISTMENT_CRM_INFORMATION = struct__ENLISTMENT_CRM_INFORMATION;
pub const PENLISTMENT_CRM_INFORMATION = [*c]struct__ENLISTMENT_CRM_INFORMATION;
pub const EnlistmentBasicInformation = enum__ENLISTMENT_INFORMATION_CLASS.EnlistmentBasicInformation;
pub const EnlistmentRecoveryInformation = enum__ENLISTMENT_INFORMATION_CLASS.EnlistmentRecoveryInformation;
pub const EnlistmentCrmInformation = enum__ENLISTMENT_INFORMATION_CLASS.EnlistmentCrmInformation;
pub const enum__ENLISTMENT_INFORMATION_CLASS = extern enum {
    EnlistmentBasicInformation,
    EnlistmentRecoveryInformation,
    EnlistmentCrmInformation,
};
pub const ENLISTMENT_INFORMATION_CLASS = enum__ENLISTMENT_INFORMATION_CLASS;
pub const struct__TRANSACTION_LIST_ENTRY = extern struct {
    UOW: UOW,
};
pub const TRANSACTION_LIST_ENTRY = struct__TRANSACTION_LIST_ENTRY;
pub const PTRANSACTION_LIST_ENTRY = [*c]struct__TRANSACTION_LIST_ENTRY;
pub const struct__TRANSACTION_LIST_INFORMATION = extern struct {
    NumberOfTransactions: DWORD,
    TransactionInformation: [1]TRANSACTION_LIST_ENTRY,
};
pub const TRANSACTION_LIST_INFORMATION = struct__TRANSACTION_LIST_INFORMATION;
pub const PTRANSACTION_LIST_INFORMATION = [*c]struct__TRANSACTION_LIST_INFORMATION;
pub const KTMOBJECT_TRANSACTION = enum__KTMOBJECT_TYPE.KTMOBJECT_TRANSACTION;
pub const KTMOBJECT_TRANSACTION_MANAGER = enum__KTMOBJECT_TYPE.KTMOBJECT_TRANSACTION_MANAGER;
pub const KTMOBJECT_RESOURCE_MANAGER = enum__KTMOBJECT_TYPE.KTMOBJECT_RESOURCE_MANAGER;
pub const KTMOBJECT_ENLISTMENT = enum__KTMOBJECT_TYPE.KTMOBJECT_ENLISTMENT;
pub const KTMOBJECT_INVALID = enum__KTMOBJECT_TYPE.KTMOBJECT_INVALID;
pub const enum__KTMOBJECT_TYPE = extern enum {
    KTMOBJECT_TRANSACTION,
    KTMOBJECT_TRANSACTION_MANAGER,
    KTMOBJECT_RESOURCE_MANAGER,
    KTMOBJECT_ENLISTMENT,
    KTMOBJECT_INVALID,
};
pub const KTMOBJECT_TYPE = enum__KTMOBJECT_TYPE;
pub const PKTMOBJECT_TYPE = [*c]enum__KTMOBJECT_TYPE;
pub const struct__KTMOBJECT_CURSOR = extern struct {
    LastQuery: GUID,
    ObjectIdCount: DWORD,
    ObjectIds: [1]GUID,
};
pub const KTMOBJECT_CURSOR = struct__KTMOBJECT_CURSOR;
pub const PKTMOBJECT_CURSOR = [*c]struct__KTMOBJECT_CURSOR;
pub const TP_VERSION = DWORD;
pub const PTP_VERSION = [*c]DWORD;
pub const struct__TP_CALLBACK_INSTANCE = @OpaqueType();
pub const TP_CALLBACK_INSTANCE = struct__TP_CALLBACK_INSTANCE;
pub const PTP_CALLBACK_INSTANCE = ?*struct__TP_CALLBACK_INSTANCE;
pub const PTP_SIMPLE_CALLBACK = ?fn (PTP_CALLBACK_INSTANCE, PVOID) callconv(.C) void;
pub const struct__TP_POOL = @OpaqueType();
pub const TP_POOL = struct__TP_POOL;
pub const PTP_POOL = ?*struct__TP_POOL;
pub const TP_CALLBACK_PRIORITY_HIGH = enum__TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_HIGH;
pub const TP_CALLBACK_PRIORITY_NORMAL = enum__TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_NORMAL;
pub const TP_CALLBACK_PRIORITY_LOW = enum__TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_LOW;
pub const TP_CALLBACK_PRIORITY_INVALID = enum__TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_INVALID;
pub const TP_CALLBACK_PRIORITY_COUNT = enum__TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_COUNT;
pub const enum__TP_CALLBACK_PRIORITY = extern enum {
    TP_CALLBACK_PRIORITY_HIGH = 0,
    TP_CALLBACK_PRIORITY_NORMAL = 1,
    TP_CALLBACK_PRIORITY_LOW = 2,
    TP_CALLBACK_PRIORITY_INVALID = 3,
    TP_CALLBACK_PRIORITY_COUNT = 3,
};
pub const TP_CALLBACK_PRIORITY = enum__TP_CALLBACK_PRIORITY;
pub const struct__TP_POOL_STACK_INFORMATION = extern struct {
    StackReserve: SIZE_T,
    StackCommit: SIZE_T,
};
pub const TP_POOL_STACK_INFORMATION = struct__TP_POOL_STACK_INFORMATION;
pub const PTP_POOL_STACK_INFORMATION = [*c]struct__TP_POOL_STACK_INFORMATION;
pub const struct__TP_CLEANUP_GROUP = @OpaqueType();
pub const TP_CLEANUP_GROUP = struct__TP_CLEANUP_GROUP;
pub const PTP_CLEANUP_GROUP = ?*struct__TP_CLEANUP_GROUP;
pub const PTP_CLEANUP_GROUP_CANCEL_CALLBACK = ?fn (PVOID, PVOID) callconv(.C) void;
pub const struct__ACTIVATION_CONTEXT = @OpaqueType();
pub const struct__TP_CALLBACK_ENVIRON_V3 = extern struct {
    Version: TP_VERSION,
    Pool: PTP_POOL,
    CleanupGroup: PTP_CLEANUP_GROUP,
    CleanupGroupCancelCallback: PTP_CLEANUP_GROUP_CANCEL_CALLBACK,
    RaceDll: PVOID,
    ActivationContext: ?*struct__ACTIVATION_CONTEXT,
    FinalizationCallback: PTP_SIMPLE_CALLBACK,
    u: extern union {
        Flags: DWORD,
        s: @OpaqueType(),
    },
    CallbackPriority: TP_CALLBACK_PRIORITY,
    Size: DWORD,
};
pub const TP_CALLBACK_ENVIRON_V3 = struct__TP_CALLBACK_ENVIRON_V3;
pub const TP_CALLBACK_ENVIRON = TP_CALLBACK_ENVIRON_V3;
pub const PTP_CALLBACK_ENVIRON = [*c]TP_CALLBACK_ENVIRON_V3;
pub fn TpInitializeCallbackEnviron(CallbackEnviron: PTP_CALLBACK_ENVIRON) void {
    CallbackEnviron.?.Version = TP_VERSION(3);
    CallbackEnviron.?.Pool = null;
    CallbackEnviron.?.CleanupGroup = null;
    CallbackEnviron.?.CleanupGroupCancelCallback = null;
    CallbackEnviron.?.RaceDll = (?*c_void)(0);
    CallbackEnviron.?.ActivationContext = null;
    CallbackEnviron.?.FinalizationCallback = null;
    CallbackEnviron.?.u.Flags = DWORD(0);
    CallbackEnviron.?.CallbackPriority = TP_CALLBACK_PRIORITY(TP_CALLBACK_PRIORITY_NORMAL);
    CallbackEnviron.?.Size = DWORD(@sizeOf(TP_CALLBACK_ENVIRON));
}
pub fn TpSetCallbackThreadpool(CallbackEnviron: PTP_CALLBACK_ENVIRON, Pool: PTP_POOL) void {
    CallbackEnviron.?.Pool = Pool;
}
pub fn TpSetCallbackCleanupGroup(CallbackEnviron: PTP_CALLBACK_ENVIRON, CleanupGroup: PTP_CLEANUP_GROUP, CleanupGroupCancelCallback: PTP_CLEANUP_GROUP_CANCEL_CALLBACK) void {
    CallbackEnviron.?.CleanupGroup = CleanupGroup;
    CallbackEnviron.?.CleanupGroupCancelCallback = CleanupGroupCancelCallback;
}
pub fn TpSetCallbackActivationContext(CallbackEnviron: PTP_CALLBACK_ENVIRON, ActivationContext: ?*struct__ACTIVATION_CONTEXT) void {
    CallbackEnviron.?.ActivationContext = ActivationContext;
}
pub fn TpSetCallbackNoActivationContext(CallbackEnviron: PTP_CALLBACK_ENVIRON) void {
    CallbackEnviron.?.ActivationContext = (?*struct__ACTIVATION_CONTEXT)(LONG_PTR(-1));
}
pub fn TpSetCallbackLongFunction(CallbackEnviron: PTP_CALLBACK_ENVIRON) void {
    CallbackEnviron.?.u.s.LongFunction = DWORD(1);
}
pub fn TpSetCallbackRaceWithDll(CallbackEnviron: PTP_CALLBACK_ENVIRON, DllHandle: PVOID) void {
    CallbackEnviron.?.RaceDll = DllHandle;
}
pub fn TpSetCallbackFinalizationCallback(CallbackEnviron: PTP_CALLBACK_ENVIRON, FinalizationCallback: PTP_SIMPLE_CALLBACK) void {
    CallbackEnviron.?.FinalizationCallback = FinalizationCallback;
}
pub fn TpSetCallbackPriority(CallbackEnviron: PTP_CALLBACK_ENVIRON, Priority: TP_CALLBACK_PRIORITY) void {
    CallbackEnviron.?.CallbackPriority = Priority;
}
pub fn TpSetCallbackPersistent(CallbackEnviron: PTP_CALLBACK_ENVIRON) void {
    CallbackEnviron.?.u.s.Persistent = DWORD(1);
}
pub fn TpDestroyCallbackEnviron(CallbackEnviron: PTP_CALLBACK_ENVIRON) void {
    CallbackEnviron;
}
pub const struct__TP_WORK = @OpaqueType();
pub const TP_WORK = struct__TP_WORK;
pub const PTP_WORK = ?*struct__TP_WORK;
pub const PTP_WORK_CALLBACK = ?fn (PTP_CALLBACK_INSTANCE, PVOID, PTP_WORK) callconv(.C) void;
pub const struct__TP_TIMER = @OpaqueType();
pub const TP_TIMER = struct__TP_TIMER;
pub const PTP_TIMER = ?*struct__TP_TIMER;
pub const PTP_TIMER_CALLBACK = ?fn (PTP_CALLBACK_INSTANCE, PVOID, PTP_TIMER) callconv(.C) void;
pub const TP_WAIT_RESULT = DWORD;
pub const struct__TP_WAIT = @OpaqueType();
pub const TP_WAIT = struct__TP_WAIT;
pub const PTP_WAIT = ?*struct__TP_WAIT;
pub const PTP_WAIT_CALLBACK = ?fn (PTP_CALLBACK_INSTANCE, PVOID, PTP_WAIT, TP_WAIT_RESULT) callconv(.C) void;
pub const struct__TP_IO = @OpaqueType();
pub const TP_IO = struct__TP_IO;
pub const PTP_IO = ?*struct__TP_IO;
pub const struct__TEB = @OpaqueType();
pub fn GetFiberData() PVOID {
    return @ptrCast([*c]PVOID, @alignCast(@alignOf(PVOID), GetCurrentFiber())).?.*;
}
pub const WPARAM = UINT_PTR;
pub const LPARAM = LONG_PTR;
pub const LRESULT = LONG_PTR;
pub const SPHANDLE = [*c]HANDLE;
pub const LPHANDLE = [*c]HANDLE;
pub const HGLOBAL = HANDLE;
pub const HLOCAL = HANDLE;
pub const GLOBALHANDLE = HANDLE;
pub const LOCALHANDLE = HANDLE;
pub const FARPROC = [*c]fn () callconv(.C) INT_PTR;
pub const NEARPROC = [*c]fn () callconv(.C) INT_PTR;
pub const PROC = [*c]fn () callconv(.C) INT_PTR;
pub const ATOM = WORD;
pub const struct_HKEY__ = extern struct {
    unused: c_int,
};
pub const HKEY = [*c]struct_HKEY__;
pub const PHKEY = [*c]HKEY;
pub const struct_HMETAFILE__ = extern struct {
    unused: c_int,
};
pub const HMETAFILE = [*c]struct_HMETAFILE__;
pub const struct_HINSTANCE__ = extern struct {
    unused: c_int,
};
pub const HINSTANCE = [*c]struct_HINSTANCE__;
pub const HMODULE = HINSTANCE;
pub const struct_HRGN__ = extern struct {
    unused: c_int,
};
pub const HRGN = [*c]struct_HRGN__;
pub const struct_HRSRC__ = extern struct {
    unused: c_int,
};
pub const HRSRC = [*c]struct_HRSRC__;
pub const struct_HSPRITE__ = extern struct {
    unused: c_int,
};
pub const HSPRITE = [*c]struct_HSPRITE__;
pub const struct_HLSURF__ = extern struct {
    unused: c_int,
};
pub const HLSURF = [*c]struct_HLSURF__;
pub const struct_HSTR__ = extern struct {
    unused: c_int,
};
pub const HSTR = [*c]struct_HSTR__;
pub const struct_HTASK__ = extern struct {
    unused: c_int,
};
pub const HTASK = [*c]struct_HTASK__;
pub const struct_HWINSTA__ = extern struct {
    unused: c_int,
};
pub const HWINSTA = [*c]struct_HWINSTA__;
pub const struct_HKL__ = extern struct {
    unused: c_int,
};
pub const HKL = [*c]struct_HKL__;
pub const HFILE = c_int;
pub const struct__FILETIME = extern struct {
    dwLowDateTime: DWORD,
    dwHighDateTime: DWORD,
};
pub const FILETIME = struct__FILETIME;
pub const PFILETIME = [*c]struct__FILETIME;
pub const LPFILETIME = [*c]struct__FILETIME;
pub const struct_HWND__ = extern struct {
    unused: c_int,
};
pub const HWND = [*c]struct_HWND__;
pub const struct_HHOOK__ = extern struct {
    unused: c_int,
};
pub const HHOOK = [*c]struct_HHOOK__;
pub const HGDIOBJ = ?*c_void;
pub const struct_HACCEL__ = extern struct {
    unused: c_int,
};
pub const HACCEL = [*c]struct_HACCEL__;
pub const struct_HBITMAP__ = extern struct {
    unused: c_int,
};
pub const HBITMAP = [*c]struct_HBITMAP__;
pub const struct_HBRUSH__ = extern struct {
    unused: c_int,
};
pub const HBRUSH = [*c]struct_HBRUSH__;
pub const struct_HCOLORSPACE__ = extern struct {
    unused: c_int,
};
pub const HCOLORSPACE = [*c]struct_HCOLORSPACE__;
pub const struct_HDC__ = extern struct {
    unused: c_int,
};
pub const HDC = [*c]struct_HDC__;
pub const struct_HGLRC__ = extern struct {
    unused: c_int,
};
pub const HGLRC = [*c]struct_HGLRC__;
pub const struct_HDESK__ = extern struct {
    unused: c_int,
};
pub const HDESK = [*c]struct_HDESK__;
pub const struct_HENHMETAFILE__ = extern struct {
    unused: c_int,
};
pub const HENHMETAFILE = [*c]struct_HENHMETAFILE__;
pub const struct_HFONT__ = extern struct {
    unused: c_int,
};
pub const HFONT = [*c]struct_HFONT__;
pub const struct_HICON__ = extern struct {
    unused: i8,
};
pub const HICON = [*c]struct_HICON__;
pub const struct_HMENU__ = extern struct {
    unused: c_int,
};
pub const HMENU = [*c]struct_HMENU__;
pub const struct_HPALETTE__ = extern struct {
    unused: c_int,
};
pub const HPALETTE = [*c]struct_HPALETTE__;
pub const struct_HPEN__ = extern struct {
    unused: c_int,
};
pub const HPEN = [*c]struct_HPEN__;
pub const struct_HWINEVENTHOOK__ = extern struct {
    unused: c_int,
};
pub const HWINEVENTHOOK = [*c]struct_HWINEVENTHOOK__;
pub const struct_HMONITOR__ = extern struct {
    unused: c_int,
};
pub const HMONITOR = [*c]struct_HMONITOR__;
pub const struct_HUMPD__ = extern struct {
    unused: c_int,
};
pub const HUMPD = [*c]struct_HUMPD__;
pub const HCURSOR = HICON;
pub const COLORREF = DWORD;
pub const LPCOLORREF = [*c]DWORD;
pub const struct_tagRECT = extern struct {
    left: LONG,
    top: LONG,
    right: LONG,
    bottom: LONG,
};
pub const RECT = struct_tagRECT;
pub const PRECT = [*c]struct_tagRECT;
pub const NPRECT = [*c]struct_tagRECT;
pub const LPRECT = [*c]struct_tagRECT;
pub const LPCRECT = [*c]const RECT;
pub const struct__RECTL = extern struct {
    left: LONG,
    top: LONG,
    right: LONG,
    bottom: LONG,
};
pub const RECTL = struct__RECTL;
pub const PRECTL = [*c]struct__RECTL;
pub const LPRECTL = [*c]struct__RECTL;
pub const LPCRECTL = [*c]const RECTL;
pub const struct_tagPOINT = extern struct {
    x: LONG,
    y: LONG,
};
pub const POINT = struct_tagPOINT;
pub const PPOINT = [*c]struct_tagPOINT;
pub const NPPOINT = [*c]struct_tagPOINT;
pub const LPPOINT = [*c]struct_tagPOINT;
pub const struct__POINTL = extern struct {
    x: LONG,
    y: LONG,
};
pub const POINTL = struct__POINTL;
pub const PPOINTL = [*c]struct__POINTL;
pub const struct_tagSIZE = extern struct {
    cx: LONG,
    cy: LONG,
};
pub const SIZE = struct_tagSIZE;
pub const PSIZE = [*c]struct_tagSIZE;
pub const LPSIZE = [*c]struct_tagSIZE;
pub const SIZEL = SIZE;
pub const PSIZEL = [*c]SIZE;
pub const LPSIZEL = [*c]SIZE;
pub const struct_tagPOINTS = extern struct {
    x: SHORT,
    y: SHORT,
};
pub const POINTS = struct_tagPOINTS;
pub const PPOINTS = [*c]struct_tagPOINTS;
pub const LPPOINTS = [*c]struct_tagPOINTS;
pub const struct_DPI_AWARENESS_CONTEXT__ = extern struct {
    unused: c_int,
};
pub const DPI_AWARENESS_CONTEXT = [*c]struct_DPI_AWARENESS_CONTEXT__;
pub const DPI_AWARENESS_INVALID = enum_DPI_AWARENESS._INVALID;
pub const DPI_AWARENESS_UNAWARE = enum_DPI_AWARENESS._UNAWARE;
pub const DPI_AWARENESS_SYSTEM_AWARE = enum_DPI_AWARENESS._SYSTEM_AWARE;
pub const DPI_AWARENESS_PER_MONITOR_AWARE = enum_DPI_AWARENESS._PER_MONITOR_AWARE;
pub const enum_DPI_AWARENESS = extern enum {
    _INVALID = -1,
    _UNAWARE = 0,
    _SYSTEM_AWARE = 1,
    _PER_MONITOR_AWARE = 2,
};
pub const DPI_AWARENESS = enum_DPI_AWARENESS;
pub const DPI_HOSTING_BEHAVIOR_INVALID = enum_DPI_HOSTING_BEHAVIOR._INVALID;
pub const DPI_HOSTING_BEHAVIOR_DEFAULT = enum_DPI_HOSTING_BEHAVIOR._DEFAULT;
pub const DPI_HOSTING_BEHAVIOR_MIXED = enum_DPI_HOSTING_BEHAVIOR._MIXED;
pub const enum_DPI_HOSTING_BEHAVIOR = extern enum {
    _INVALID = -1,
    _DEFAULT = 0,
    _MIXED = 1,
};
pub const DPI_HOSTING_BEHAVIOR = enum_DPI_HOSTING_BEHAVIOR;
pub const struct__SECURITY_ATTRIBUTES = extern struct {
    nLength: DWORD,
    lpSecurityDescriptor: LPVOID,
    bInheritHandle: BOOL,
};
pub const SECURITY_ATTRIBUTES = struct__SECURITY_ATTRIBUTES;
pub const PSECURITY_ATTRIBUTES = [*c]struct__SECURITY_ATTRIBUTES;
pub const LPSECURITY_ATTRIBUTES = [*c]struct__SECURITY_ATTRIBUTES;
pub const struct__OVERLAPPED = extern struct {
    Internal: ULONG_PTR,
    InternalHigh: ULONG_PTR,
    @"": extern union {
        @"": extern struct {
            Offset: DWORD,
            OffsetHigh: DWORD,
        },
        Pointer: PVOID,
    },
    hEvent: HANDLE,
};
pub const OVERLAPPED = struct__OVERLAPPED;
pub const LPOVERLAPPED = [*c]struct__OVERLAPPED;
pub const struct__OVERLAPPED_ENTRY = extern struct {
    lpCompletionKey: ULONG_PTR,
    lpOverlapped: LPOVERLAPPED,
    Internal: ULONG_PTR,
    dwNumberOfBytesTransferred: DWORD,
};
pub const OVERLAPPED_ENTRY = struct__OVERLAPPED_ENTRY;
pub const LPOVERLAPPED_ENTRY = [*c]struct__OVERLAPPED_ENTRY;
pub const struct__SYSTEMTIME = extern struct {
    wYear: WORD,
    wMonth: WORD,
    wDayOfWeek: WORD,
    wDay: WORD,
    wHour: WORD,
    wMinute: WORD,
    wSecond: WORD,
    wMilliseconds: WORD,
};
pub const SYSTEMTIME = struct__SYSTEMTIME;
pub const PSYSTEMTIME = [*c]struct__SYSTEMTIME;
pub const LPSYSTEMTIME = [*c]struct__SYSTEMTIME;
pub const struct__WIN32_FIND_DATAA = extern struct {
    dwFileAttributes: DWORD,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    nFileSizeHigh: DWORD,
    nFileSizeLow: DWORD,
    dwReserved0: DWORD,
    dwReserved1: DWORD,
    cFileName: [260]CHAR,
    cAlternateFileName: [14]CHAR,
};
pub const WIN32_FIND_DATAA = struct__WIN32_FIND_DATAA;
pub const PWIN32_FIND_DATAA = [*c]struct__WIN32_FIND_DATAA;
pub const LPWIN32_FIND_DATAA = [*c]struct__WIN32_FIND_DATAA;
pub const struct__WIN32_FIND_DATAW = extern struct {
    dwFileAttributes: DWORD,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    nFileSizeHigh: DWORD,
    nFileSizeLow: DWORD,
    dwReserved0: DWORD,
    dwReserved1: DWORD,
    cFileName: [260]WCHAR,
    cAlternateFileName: [14]WCHAR,
};
pub const WIN32_FIND_DATAW = struct__WIN32_FIND_DATAW;
pub const PWIN32_FIND_DATAW = [*c]struct__WIN32_FIND_DATAW;
pub const LPWIN32_FIND_DATAW = [*c]struct__WIN32_FIND_DATAW;
pub const WIN32_FIND_DATA = WIN32_FIND_DATAA;
pub const PWIN32_FIND_DATA = PWIN32_FIND_DATAA;
pub const LPWIN32_FIND_DATA = LPWIN32_FIND_DATAA;
pub const FindExInfoStandard = enum__FINDEX_INFO_LEVELS.FindExInfoStandard;
pub const FindExInfoBasic = enum__FINDEX_INFO_LEVELS.FindExInfoBasic;
pub const FindExInfoMaxInfoLevel = enum__FINDEX_INFO_LEVELS.FindExInfoMaxInfoLevel;
pub const enum__FINDEX_INFO_LEVELS = extern enum {
    FindExInfoStandard,
    FindExInfoBasic,
    FindExInfoMaxInfoLevel,
};
pub const FINDEX_INFO_LEVELS = enum__FINDEX_INFO_LEVELS;
pub const FindExSearchNameMatch = enum__FINDEX_SEARCH_OPS.FindExSearchNameMatch;
pub const FindExSearchLimitToDirectories = enum__FINDEX_SEARCH_OPS.FindExSearchLimitToDirectories;
pub const FindExSearchLimitToDevices = enum__FINDEX_SEARCH_OPS.FindExSearchLimitToDevices;
pub const FindExSearchMaxSearchOp = enum__FINDEX_SEARCH_OPS.FindExSearchMaxSearchOp;
pub const enum__FINDEX_SEARCH_OPS = extern enum {
    FindExSearchNameMatch,
    FindExSearchLimitToDirectories,
    FindExSearchLimitToDevices,
    FindExSearchMaxSearchOp,
};
pub const FINDEX_SEARCH_OPS = enum__FINDEX_SEARCH_OPS;
pub const ReadDirectoryNotifyInformation = enum__READ_DIRECTORY_NOTIFY_INFORMATION_CLASS.ReadDirectoryNotifyInformation;
pub const ReadDirectoryNotifyExtendedInformation = enum__READ_DIRECTORY_NOTIFY_INFORMATION_CLASS.ReadDirectoryNotifyExtendedInformation;
pub const enum__READ_DIRECTORY_NOTIFY_INFORMATION_CLASS = extern enum {
    ReadDirectoryNotifyInformation = 1,
    ReadDirectoryNotifyExtendedInformation = 2,
};
pub const READ_DIRECTORY_NOTIFY_INFORMATION_CLASS = enum__READ_DIRECTORY_NOTIFY_INFORMATION_CLASS;
pub const PREAD_DIRECTORY_NOTIFY_INFORMATION_CLASS = [*c]enum__READ_DIRECTORY_NOTIFY_INFORMATION_CLASS;
pub const GetFileExInfoStandard = enum__GET_FILEEX_INFO_LEVELS.GetFileExInfoStandard;
pub const GetFileExMaxInfoLevel = enum__GET_FILEEX_INFO_LEVELS.GetFileExMaxInfoLevel;
pub const enum__GET_FILEEX_INFO_LEVELS = extern enum {
    GetFileExInfoStandard,
    GetFileExMaxInfoLevel,
};
pub const GET_FILEEX_INFO_LEVELS = enum__GET_FILEEX_INFO_LEVELS;
pub const FileBasicInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileBasicInfo;
pub const FileStandardInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileStandardInfo;
pub const FileNameInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileNameInfo;
pub const FileRenameInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileRenameInfo;
pub const FileDispositionInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileDispositionInfo;
pub const FileAllocationInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileAllocationInfo;
pub const FileEndOfFileInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileEndOfFileInfo;
pub const FileStreamInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileStreamInfo;
pub const FileCompressionInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileCompressionInfo;
pub const FileAttributeTagInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileAttributeTagInfo;
pub const FileIdBothDirectoryInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileIdBothDirectoryInfo;
pub const FileIdBothDirectoryRestartInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileIdBothDirectoryRestartInfo;
pub const FileIoPriorityHintInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileIoPriorityHintInfo;
pub const FileRemoteProtocolInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileRemoteProtocolInfo;
pub const FileFullDirectoryInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileFullDirectoryInfo;
pub const FileFullDirectoryRestartInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileFullDirectoryRestartInfo;
pub const FileStorageInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileStorageInfo;
pub const FileAlignmentInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileAlignmentInfo;
pub const FileIdInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileIdInfo;
pub const FileIdExtdDirectoryInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileIdExtdDirectoryInfo;
pub const FileIdExtdDirectoryRestartInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileIdExtdDirectoryRestartInfo;
pub const FileDispositionInfoEx = enum__FILE_INFO_BY_HANDLE_CLASS.FileDispositionInfoEx;
pub const FileRenameInfoEx = enum__FILE_INFO_BY_HANDLE_CLASS.FileRenameInfoEx;
pub const FileCaseSensitiveInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileCaseSensitiveInfo;
pub const FileNormalizedNameInfo = enum__FILE_INFO_BY_HANDLE_CLASS.FileNormalizedNameInfo;
pub const MaximumFileInfoByHandleClass = enum__FILE_INFO_BY_HANDLE_CLASS.MaximumFileInfoByHandleClass;
pub const enum__FILE_INFO_BY_HANDLE_CLASS = extern enum {
    FileBasicInfo,
    FileStandardInfo,
    FileNameInfo,
    FileRenameInfo,
    FileDispositionInfo,
    FileAllocationInfo,
    FileEndOfFileInfo,
    FileStreamInfo,
    FileCompressionInfo,
    FileAttributeTagInfo,
    FileIdBothDirectoryInfo,
    FileIdBothDirectoryRestartInfo,
    FileIoPriorityHintInfo,
    FileRemoteProtocolInfo,
    FileFullDirectoryInfo,
    FileFullDirectoryRestartInfo,
    FileStorageInfo,
    FileAlignmentInfo,
    FileIdInfo,
    FileIdExtdDirectoryInfo,
    FileIdExtdDirectoryRestartInfo,
    FileDispositionInfoEx,
    FileRenameInfoEx,
    FileCaseSensitiveInfo,
    FileNormalizedNameInfo,
    MaximumFileInfoByHandleClass,
};
pub const FILE_INFO_BY_HANDLE_CLASS = enum__FILE_INFO_BY_HANDLE_CLASS;
pub const PFILE_INFO_BY_HANDLE_CLASS = [*c]enum__FILE_INFO_BY_HANDLE_CLASS;
pub const CRITICAL_SECTION = RTL_CRITICAL_SECTION;
pub const PCRITICAL_SECTION = PRTL_CRITICAL_SECTION;
pub const LPCRITICAL_SECTION = PRTL_CRITICAL_SECTION;
pub const CRITICAL_SECTION_DEBUG = RTL_CRITICAL_SECTION_DEBUG;
pub const PCRITICAL_SECTION_DEBUG = PRTL_CRITICAL_SECTION_DEBUG;
pub const LPCRITICAL_SECTION_DEBUG = PRTL_CRITICAL_SECTION_DEBUG;
pub const LPOVERLAPPED_COMPLETION_ROUTINE = ?fn (DWORD, DWORD, LPOVERLAPPED) callconv(.C) void;
pub const struct__PROCESS_HEAP_ENTRY = extern struct {
    lpData: PVOID,
    cbData: DWORD,
    cbOverhead: BYTE,
    iRegionIndex: BYTE,
    wFlags: WORD,
    @"": extern union {
        Block: extern struct {
            hMem: HANDLE,
            dwReserved: [3]DWORD,
        },
        Region: extern struct {
            dwCommittedSize: DWORD,
            dwUnCommittedSize: DWORD,
            lpFirstBlock: LPVOID,
            lpLastBlock: LPVOID,
        },
    },
};
pub const PROCESS_HEAP_ENTRY = struct__PROCESS_HEAP_ENTRY;
pub const LPPROCESS_HEAP_ENTRY = [*c]struct__PROCESS_HEAP_ENTRY;
pub const PPROCESS_HEAP_ENTRY = [*c]struct__PROCESS_HEAP_ENTRY;
pub const struct__REASON_CONTEXT = extern struct {
    Version: ULONG,
    Flags: DWORD,
    Reason: extern union {
        Detailed: extern struct {
            LocalizedReasonModule: HMODULE,
            LocalizedReasonId: ULONG,
            ReasonStringCount: ULONG,
            ReasonStrings: [*c]LPWSTR,
        },
        SimpleReasonString: LPWSTR,
    },
};
pub const REASON_CONTEXT = struct__REASON_CONTEXT;
pub const PREASON_CONTEXT = [*c]struct__REASON_CONTEXT;
pub const PTHREAD_START_ROUTINE = ?fn (LPVOID) callconv(.C) DWORD;
pub const LPTHREAD_START_ROUTINE = PTHREAD_START_ROUTINE;
pub const PENCLAVE_ROUTINE = ?fn (LPVOID) callconv(.C) LPVOID;
pub const LPENCLAVE_ROUTINE = PENCLAVE_ROUTINE;
pub const struct__EXCEPTION_DEBUG_INFO = extern struct {
    ExceptionRecord: EXCEPTION_RECORD,
    dwFirstChance: DWORD,
};
pub const EXCEPTION_DEBUG_INFO = struct__EXCEPTION_DEBUG_INFO;
pub const LPEXCEPTION_DEBUG_INFO = [*c]struct__EXCEPTION_DEBUG_INFO;
pub const struct__CREATE_THREAD_DEBUG_INFO = extern struct {
    hThread: HANDLE,
    lpThreadLocalBase: LPVOID,
    lpStartAddress: LPTHREAD_START_ROUTINE,
};
pub const CREATE_THREAD_DEBUG_INFO = struct__CREATE_THREAD_DEBUG_INFO;
pub const LPCREATE_THREAD_DEBUG_INFO = [*c]struct__CREATE_THREAD_DEBUG_INFO;
pub const struct__CREATE_PROCESS_DEBUG_INFO = extern struct {
    hFile: HANDLE,
    hProcess: HANDLE,
    hThread: HANDLE,
    lpBaseOfImage: LPVOID,
    dwDebugInfoFileOffset: DWORD,
    nDebugInfoSize: DWORD,
    lpThreadLocalBase: LPVOID,
    lpStartAddress: LPTHREAD_START_ROUTINE,
    lpImageName: LPVOID,
    fUnicode: WORD,
};
pub const CREATE_PROCESS_DEBUG_INFO = struct__CREATE_PROCESS_DEBUG_INFO;
pub const LPCREATE_PROCESS_DEBUG_INFO = [*c]struct__CREATE_PROCESS_DEBUG_INFO;
pub const struct__EXIT_THREAD_DEBUG_INFO = extern struct {
    dwExitCode: DWORD,
};
pub const EXIT_THREAD_DEBUG_INFO = struct__EXIT_THREAD_DEBUG_INFO;
pub const LPEXIT_THREAD_DEBUG_INFO = [*c]struct__EXIT_THREAD_DEBUG_INFO;
pub const struct__EXIT_PROCESS_DEBUG_INFO = extern struct {
    dwExitCode: DWORD,
};
pub const EXIT_PROCESS_DEBUG_INFO = struct__EXIT_PROCESS_DEBUG_INFO;
pub const LPEXIT_PROCESS_DEBUG_INFO = [*c]struct__EXIT_PROCESS_DEBUG_INFO;
pub const struct__LOAD_DLL_DEBUG_INFO = extern struct {
    hFile: HANDLE,
    lpBaseOfDll: LPVOID,
    dwDebugInfoFileOffset: DWORD,
    nDebugInfoSize: DWORD,
    lpImageName: LPVOID,
    fUnicode: WORD,
};
pub const LOAD_DLL_DEBUG_INFO = struct__LOAD_DLL_DEBUG_INFO;
pub const LPLOAD_DLL_DEBUG_INFO = [*c]struct__LOAD_DLL_DEBUG_INFO;
pub const struct__UNLOAD_DLL_DEBUG_INFO = extern struct {
    lpBaseOfDll: LPVOID,
};
pub const UNLOAD_DLL_DEBUG_INFO = struct__UNLOAD_DLL_DEBUG_INFO;
pub const LPUNLOAD_DLL_DEBUG_INFO = [*c]struct__UNLOAD_DLL_DEBUG_INFO;
pub const struct__OUTPUT_DEBUG_STRING_INFO = extern struct {
    lpDebugStringData: LPSTR,
    fUnicode: WORD,
    nDebugStringLength: WORD,
};
pub const OUTPUT_DEBUG_STRING_INFO = struct__OUTPUT_DEBUG_STRING_INFO;
pub const LPOUTPUT_DEBUG_STRING_INFO = [*c]struct__OUTPUT_DEBUG_STRING_INFO;
pub const struct__RIP_INFO = extern struct {
    dwError: DWORD,
    dwType: DWORD,
};
pub const RIP_INFO = struct__RIP_INFO;
pub const LPRIP_INFO = [*c]struct__RIP_INFO;
pub const struct__DEBUG_EVENT = extern struct {
    dwDebugEventCode: DWORD,
    dwProcessId: DWORD,
    dwThreadId: DWORD,
    u: extern union {
        Exception: EXCEPTION_DEBUG_INFO,
        CreateThread: CREATE_THREAD_DEBUG_INFO,
        CreateProcessInfo: CREATE_PROCESS_DEBUG_INFO,
        ExitThread: EXIT_THREAD_DEBUG_INFO,
        ExitProcess: EXIT_PROCESS_DEBUG_INFO,
        LoadDll: LOAD_DLL_DEBUG_INFO,
        UnloadDll: UNLOAD_DLL_DEBUG_INFO,
        DebugString: OUTPUT_DEBUG_STRING_INFO,
        RipInfo: RIP_INFO,
    },
};
pub const DEBUG_EVENT = struct__DEBUG_EVENT;
pub const LPDEBUG_EVENT = [*c]struct__DEBUG_EVENT;
pub const LPCONTEXT = PCONTEXT;
pub extern "kernel32" fn IsApiSetImplemented(Contract: PCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetEnvironmentStringsW(NewEnvironment: LPWCH) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetStdHandle(nStdHandle: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn SetStdHandle(nStdHandle: DWORD, hHandle: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetStdHandleEx(nStdHandle: DWORD, hHandle: HANDLE, phPrevValue: PHANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCommandLineA() callconv(.Stdcall) LPSTR;
pub extern "kernel32" fn GetCommandLineW() callconv(.Stdcall) LPWSTR;
pub extern "kernel32" fn GetEnvironmentStrings() callconv(.Stdcall) LPCH;
pub extern "kernel32" fn GetEnvironmentStringsW() callconv(.Stdcall) LPWCH;
pub extern "kernel32" fn FreeEnvironmentStringsA(penv: LPCH) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FreeEnvironmentStringsW(penv: LPWCH) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetEnvironmentVariableA(lpName: LPCSTR, lpBuffer: LPSTR, nSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetEnvironmentVariableW(lpName: LPCWSTR, lpBuffer: LPWSTR, nSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SetEnvironmentVariableA(lpName: LPCSTR, lpValue: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetEnvironmentVariableW(lpName: LPCWSTR, lpValue: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ExpandEnvironmentStringsA(lpSrc: LPCSTR, lpDst: LPSTR, nSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn ExpandEnvironmentStringsW(lpSrc: LPCWSTR, lpDst: LPWSTR, nSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SetCurrentDirectoryA(lpPathName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetCurrentDirectoryW(lpPathName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCurrentDirectoryA(nBufferLength: DWORD, lpBuffer: LPSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetCurrentDirectoryW(nBufferLength: DWORD, lpBuffer: LPWSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SearchPathW(lpPath: LPCWSTR, lpFileName: LPCWSTR, lpExtension: LPCWSTR, nBufferLength: DWORD, lpBuffer: LPWSTR, lpFilePart: [*c]LPWSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SearchPathA(lpPath: LPCSTR, lpFileName: LPCSTR, lpExtension: LPCSTR, nBufferLength: DWORD, lpBuffer: LPSTR, lpFilePart: [*c]LPSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn NeedCurrentDirectoryForExePathA(ExeName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn NeedCurrentDirectoryForExePathW(ExeName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CompareFileTime(lpFileTime1: [*c]const FILETIME, lpFileTime2: [*c]const FILETIME) callconv(.Stdcall) LONG;
pub extern "kernel32" fn CreateDirectoryA(lpPathName: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateDirectoryW(lpPathName: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateFileA(lpFileName: LPCSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD, dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateFileW(lpFileName: LPCWSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD, dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn DefineDosDeviceW(dwFlags: DWORD, lpDeviceName: LPCWSTR, lpTargetPath: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeleteFileA(lpFileName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeleteFileW(lpFileName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeleteVolumeMountPointW(lpszVolumeMountPoint: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FileTimeToLocalFileTime(lpFileTime: [*c]const FILETIME, lpLocalFileTime: LPFILETIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindClose(hFindFile: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindCloseChangeNotification(hChangeHandle: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindFirstChangeNotificationA(lpPathName: LPCSTR, bWatchSubtree: BOOL, dwNotifyFilter: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn FindFirstChangeNotificationW(lpPathName: LPCWSTR, bWatchSubtree: BOOL, dwNotifyFilter: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn FindFirstFileA(lpFileName: LPCSTR, lpFindFileData: LPWIN32_FIND_DATAA) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn FindFirstFileW(lpFileName: LPCWSTR, lpFindFileData: LPWIN32_FIND_DATAW) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn FindFirstFileExA(lpFileName: LPCSTR, fInfoLevelId: FINDEX_INFO_LEVELS, lpFindFileData: LPVOID, fSearchOp: FINDEX_SEARCH_OPS, lpSearchFilter: LPVOID, dwAdditionalFlags: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn FindFirstFileExW(lpFileName: LPCWSTR, fInfoLevelId: FINDEX_INFO_LEVELS, lpFindFileData: LPVOID, fSearchOp: FINDEX_SEARCH_OPS, lpSearchFilter: LPVOID, dwAdditionalFlags: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn FindFirstVolumeW(lpszVolumeName: LPWSTR, cchBufferLength: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn FindNextChangeNotification(hChangeHandle: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindNextFileA(hFindFile: HANDLE, lpFindFileData: LPWIN32_FIND_DATAA) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindNextFileW(hFindFile: HANDLE, lpFindFileData: LPWIN32_FIND_DATAW) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindNextVolumeW(hFindVolume: HANDLE, lpszVolumeName: LPWSTR, cchBufferLength: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindVolumeClose(hFindVolume: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FlushFileBuffers(hFile: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetDiskFreeSpaceA(lpRootPathName: LPCSTR, lpSectorsPerCluster: LPDWORD, lpBytesPerSector: LPDWORD, lpNumberOfFreeClusters: LPDWORD, lpTotalNumberOfClusters: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetDiskFreeSpaceW(lpRootPathName: LPCWSTR, lpSectorsPerCluster: LPDWORD, lpBytesPerSector: LPDWORD, lpNumberOfFreeClusters: LPDWORD, lpTotalNumberOfClusters: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetDiskFreeSpaceExA(lpDirectoryName: LPCSTR, lpFreeBytesAvailableToCaller: PULARGE_INTEGER, lpTotalNumberOfBytes: PULARGE_INTEGER, lpTotalNumberOfFreeBytes: PULARGE_INTEGER) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetDiskFreeSpaceExW(lpDirectoryName: LPCWSTR, lpFreeBytesAvailableToCaller: PULARGE_INTEGER, lpTotalNumberOfBytes: PULARGE_INTEGER, lpTotalNumberOfFreeBytes: PULARGE_INTEGER) callconv(.Stdcall) BOOL;
pub const struct_DISK_SPACE_INFORMATION = extern struct {
    ActualTotalAllocationUnits: ULONGLONG,
    ActualAvailableAllocationUnits: ULONGLONG,
    ActualPoolUnavailableAllocationUnits: ULONGLONG,
    CallerTotalAllocationUnits: ULONGLONG,
    CallerAvailableAllocationUnits: ULONGLONG,
    CallerPoolUnavailableAllocationUnits: ULONGLONG,
    UsedAllocationUnits: ULONGLONG,
    TotalReservedAllocationUnits: ULONGLONG,
    VolumeStorageReserveAllocationUnits: ULONGLONG,
    AvailableCommittedAllocationUnits: ULONGLONG,
    PoolAvailableAllocationUnits: ULONGLONG,
    SectorsPerAllocationUnit: DWORD,
    BytesPerSector: DWORD,
};
pub const DISK_SPACE_INFORMATION = struct_DISK_SPACE_INFORMATION;
pub extern "kernel32" fn GetDiskSpaceInformationA(rootPath: LPCSTR, diskSpaceInfo: [*c]DISK_SPACE_INFORMATION) callconv(.Stdcall) HRESULT;
pub extern "kernel32" fn GetDiskSpaceInformationW(rootPath: LPCWSTR, diskSpaceInfo: [*c]DISK_SPACE_INFORMATION) callconv(.Stdcall) HRESULT;
pub extern "kernel32" fn GetDriveTypeA(lpRootPathName: LPCSTR) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetDriveTypeW(lpRootPathName: LPCWSTR) callconv(.Stdcall) UINT;
pub const struct__WIN32_FILE_ATTRIBUTE_DATA = extern struct {
    dwFileAttributes: DWORD,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    nFileSizeHigh: DWORD,
    nFileSizeLow: DWORD,
};
pub const WIN32_FILE_ATTRIBUTE_DATA = struct__WIN32_FILE_ATTRIBUTE_DATA;
pub const LPWIN32_FILE_ATTRIBUTE_DATA = [*c]struct__WIN32_FILE_ATTRIBUTE_DATA;
pub extern "kernel32" fn GetFileAttributesA(lpFileName: LPCSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetFileAttributesW(lpFileName: LPCWSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetFileAttributesExA(lpFileName: LPCSTR, fInfoLevelId: GET_FILEEX_INFO_LEVELS, lpFileInformation: LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetFileAttributesExW(lpFileName: LPCWSTR, fInfoLevelId: GET_FILEEX_INFO_LEVELS, lpFileInformation: LPVOID) callconv(.Stdcall) BOOL;
pub const struct__BY_HANDLE_FILE_INFORMATION = extern struct {
    dwFileAttributes: DWORD,
    ftCreationTime: FILETIME,
    ftLastAccessTime: FILETIME,
    ftLastWriteTime: FILETIME,
    dwVolumeSerialNumber: DWORD,
    nFileSizeHigh: DWORD,
    nFileSizeLow: DWORD,
    nNumberOfLinks: DWORD,
    nFileIndexHigh: DWORD,
    nFileIndexLow: DWORD,
};
pub const BY_HANDLE_FILE_INFORMATION = struct__BY_HANDLE_FILE_INFORMATION;
pub const PBY_HANDLE_FILE_INFORMATION = [*c]struct__BY_HANDLE_FILE_INFORMATION;
pub const LPBY_HANDLE_FILE_INFORMATION = [*c]struct__BY_HANDLE_FILE_INFORMATION;
pub extern "kernel32" fn GetFileInformationByHandle(hFile: HANDLE, lpFileInformation: LPBY_HANDLE_FILE_INFORMATION) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetFileSize(hFile: HANDLE, lpFileSizeHigh: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetFileSizeEx(hFile: HANDLE, lpFileSize: PLARGE_INTEGER) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetFileType(hFile: HANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetFinalPathNameByHandleA(hFile: HANDLE, lpszFilePath: LPSTR, cchFilePath: DWORD, dwFlags: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetFinalPathNameByHandleW(hFile: HANDLE, lpszFilePath: LPWSTR, cchFilePath: DWORD, dwFlags: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetFileTime(hFile: HANDLE, lpCreationTime: LPFILETIME, lpLastAccessTime: LPFILETIME, lpLastWriteTime: LPFILETIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetFullPathNameW(lpFileName: LPCWSTR, nBufferLength: DWORD, lpBuffer: LPWSTR, lpFilePart: [*c]LPWSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetFullPathNameA(lpFileName: LPCSTR, nBufferLength: DWORD, lpBuffer: LPSTR, lpFilePart: [*c]LPSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetLogicalDrives() callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetLogicalDriveStringsW(nBufferLength: DWORD, lpBuffer: LPWSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetLongPathNameA(lpszShortPath: LPCSTR, lpszLongPath: LPSTR, cchBuffer: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetLongPathNameW(lpszShortPath: LPCWSTR, lpszLongPath: LPWSTR, cchBuffer: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetShortPathNameW(lpszLongPath: LPCWSTR, lpszShortPath: LPWSTR, cchBuffer: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetTempFileNameW(lpPathName: LPCWSTR, lpPrefixString: LPCWSTR, uUnique: UINT, lpTempFileName: LPWSTR) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetVolumeInformationByHandleW(hFile: HANDLE, lpVolumeNameBuffer: LPWSTR, nVolumeNameSize: DWORD, lpVolumeSerialNumber: LPDWORD, lpMaximumComponentLength: LPDWORD, lpFileSystemFlags: LPDWORD, lpFileSystemNameBuffer: LPWSTR, nFileSystemNameSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetVolumeInformationW(lpRootPathName: LPCWSTR, lpVolumeNameBuffer: LPWSTR, nVolumeNameSize: DWORD, lpVolumeSerialNumber: LPDWORD, lpMaximumComponentLength: LPDWORD, lpFileSystemFlags: LPDWORD, lpFileSystemNameBuffer: LPWSTR, nFileSystemNameSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetVolumePathNameW(lpszFileName: LPCWSTR, lpszVolumePathName: LPWSTR, cchBufferLength: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn LocalFileTimeToFileTime(lpLocalFileTime: [*c]const FILETIME, lpFileTime: LPFILETIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn LockFile(hFile: HANDLE, dwFileOffsetLow: DWORD, dwFileOffsetHigh: DWORD, nNumberOfBytesToLockLow: DWORD, nNumberOfBytesToLockHigh: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn LockFileEx(hFile: HANDLE, dwFlags: DWORD, dwReserved: DWORD, nNumberOfBytesToLockLow: DWORD, nNumberOfBytesToLockHigh: DWORD, lpOverlapped: LPOVERLAPPED) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn QueryDosDeviceW(lpDeviceName: LPCWSTR, lpTargetPath: LPWSTR, ucchMax: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn ReadFile(hFile: HANDLE, lpBuffer: LPVOID, nNumberOfBytesToRead: DWORD, lpNumberOfBytesRead: LPDWORD, lpOverlapped: LPOVERLAPPED) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ReadFileEx(hFile: HANDLE, lpBuffer: LPVOID, nNumberOfBytesToRead: DWORD, lpOverlapped: LPOVERLAPPED, lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ReadFileScatter(hFile: HANDLE, aSegmentArray: [*c]FILE_SEGMENT_ELEMENT, nNumberOfBytesToRead: DWORD, lpReserved: LPDWORD, lpOverlapped: LPOVERLAPPED) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn RemoveDirectoryA(lpPathName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn RemoveDirectoryW(lpPathName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetEndOfFile(hFile: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetFileAttributesA(lpFileName: LPCSTR, dwFileAttributes: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetFileAttributesW(lpFileName: LPCWSTR, dwFileAttributes: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetFileInformationByHandle(hFile: HANDLE, FileInformationClass: FILE_INFO_BY_HANDLE_CLASS, lpFileInformation: LPVOID, dwBufferSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetFilePointer(hFile: HANDLE, lDistanceToMove: LONG, lpDistanceToMoveHigh: PLONG, dwMoveMethod: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SetFilePointerEx(hFile: HANDLE, liDistanceToMove: LARGE_INTEGER, lpNewFilePointer: PLARGE_INTEGER, dwMoveMethod: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetFileTime(hFile: HANDLE, lpCreationTime: [*c]const FILETIME, lpLastAccessTime: [*c]const FILETIME, lpLastWriteTime: [*c]const FILETIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetFileValidData(hFile: HANDLE, ValidDataLength: LONGLONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn UnlockFile(hFile: HANDLE, dwFileOffsetLow: DWORD, dwFileOffsetHigh: DWORD, nNumberOfBytesToUnlockLow: DWORD, nNumberOfBytesToUnlockHigh: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn UnlockFileEx(hFile: HANDLE, dwReserved: DWORD, nNumberOfBytesToUnlockLow: DWORD, nNumberOfBytesToUnlockHigh: DWORD, lpOverlapped: LPOVERLAPPED) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WriteFile(hFile: HANDLE, lpBuffer: LPCVOID, nNumberOfBytesToWrite: DWORD, lpNumberOfBytesWritten: LPDWORD, lpOverlapped: LPOVERLAPPED) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WriteFileEx(hFile: HANDLE, lpBuffer: LPCVOID, nNumberOfBytesToWrite: DWORD, lpOverlapped: LPOVERLAPPED, lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WriteFileGather(hFile: HANDLE, aSegmentArray: [*c]FILE_SEGMENT_ELEMENT, nNumberOfBytesToWrite: DWORD, lpReserved: LPDWORD, lpOverlapped: LPOVERLAPPED) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetTempPathW(nBufferLength: DWORD, lpBuffer: LPWSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetVolumeNameForVolumeMountPointW(lpszVolumeMountPoint: LPCWSTR, lpszVolumeName: LPWSTR, cchBufferLength: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetVolumePathNamesForVolumeNameW(lpszVolumeName: LPCWSTR, lpszVolumePathNames: LPWCH, cchBufferLength: DWORD, lpcchReturnLength: PDWORD) callconv(.Stdcall) BOOL;
pub const struct__CREATEFILE2_EXTENDED_PARAMETERS = extern struct {
    dwSize: DWORD,
    dwFileAttributes: DWORD,
    dwFileFlags: DWORD,
    dwSecurityQosFlags: DWORD,
    lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    hTemplateFile: HANDLE,
};
pub const CREATEFILE2_EXTENDED_PARAMETERS = struct__CREATEFILE2_EXTENDED_PARAMETERS;
pub const PCREATEFILE2_EXTENDED_PARAMETERS = [*c]struct__CREATEFILE2_EXTENDED_PARAMETERS;
pub const LPCREATEFILE2_EXTENDED_PARAMETERS = [*c]struct__CREATEFILE2_EXTENDED_PARAMETERS;
pub extern "kernel32" fn CreateFile2(lpFileName: LPCWSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, dwCreationDisposition: DWORD, pCreateExParams: LPCREATEFILE2_EXTENDED_PARAMETERS) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn SetFileIoOverlappedRange(FileHandle: HANDLE, OverlappedRangeStart: PUCHAR, Length: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCompressedFileSizeA(lpFileName: LPCSTR, lpFileSizeHigh: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetCompressedFileSizeW(lpFileName: LPCWSTR, lpFileSizeHigh: LPDWORD) callconv(.Stdcall) DWORD;
pub const FindStreamInfoStandard = enum__STREAM_INFO_LEVELS.FindStreamInfoStandard;
pub const FindStreamInfoMaxInfoLevel = enum__STREAM_INFO_LEVELS.FindStreamInfoMaxInfoLevel;
pub const enum__STREAM_INFO_LEVELS = extern enum {
    FindStreamInfoStandard,
    FindStreamInfoMaxInfoLevel,
};
pub const STREAM_INFO_LEVELS = enum__STREAM_INFO_LEVELS;
pub const struct__WIN32_FIND_STREAM_DATA = extern struct {
    StreamSize: LARGE_INTEGER,
    cStreamName: [296]WCHAR,
};
pub const WIN32_FIND_STREAM_DATA = struct__WIN32_FIND_STREAM_DATA;
pub const PWIN32_FIND_STREAM_DATA = [*c]struct__WIN32_FIND_STREAM_DATA;
pub extern "kernel32" fn FindFirstStreamW(lpFileName: LPCWSTR, InfoLevel: STREAM_INFO_LEVELS, lpFindStreamData: LPVOID, dwFlags: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn FindNextStreamW(hFindStream: HANDLE, lpFindStreamData: LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AreFileApisANSI() callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetTempPathA(nBufferLength: DWORD, lpBuffer: LPSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn FindFirstFileNameW(lpFileName: LPCWSTR, dwFlags: DWORD, StringLength: LPDWORD, LinkName: PWSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn FindNextFileNameW(hFindStream: HANDLE, StringLength: LPDWORD, LinkName: PWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetVolumeInformationA(lpRootPathName: LPCSTR, lpVolumeNameBuffer: LPSTR, nVolumeNameSize: DWORD, lpVolumeSerialNumber: LPDWORD, lpMaximumComponentLength: LPDWORD, lpFileSystemFlags: LPDWORD, lpFileSystemNameBuffer: LPSTR, nFileSystemNameSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetTempFileNameA(lpPathName: LPCSTR, lpPrefixString: LPCSTR, uUnique: UINT, lpTempFileName: LPSTR) callconv(.Stdcall) UINT;
pub extern "kernel32" fn SetFileApisToOEM() callconv(.Stdcall) void;
pub extern "kernel32" fn SetFileApisToANSI() callconv(.Stdcall) void;
pub extern "kernel32" fn CopyFileFromAppW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, bFailIfExists: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateDirectoryFromAppW(lpPathName: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateFileFromAppW(lpFileName: LPCWSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD, dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateFile2FromAppW(lpFileName: LPCWSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, dwCreationDisposition: DWORD, pCreateExParams: LPCREATEFILE2_EXTENDED_PARAMETERS) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn DeleteFileFromAppW(lpFileName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindFirstFileExFromAppW(lpFileName: LPCWSTR, fInfoLevelId: FINDEX_INFO_LEVELS, lpFindFileData: LPVOID, fSearchOp: FINDEX_SEARCH_OPS, lpSearchFilter: LPVOID, dwAdditionalFlags: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn GetFileAttributesExFromAppW(lpFileName: LPCWSTR, fInfoLevelId: GET_FILEEX_INFO_LEVELS, lpFileInformation: LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn MoveFileFromAppW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn RemoveDirectoryFromAppW(lpPathName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ReplaceFileFromAppW(lpReplacedFileName: LPCWSTR, lpReplacementFileName: LPCWSTR, lpBackupFileName: LPCWSTR, dwReplaceFlags: DWORD, lpExclude: LPVOID, lpReserved: LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetFileAttributesFromAppW(lpFileName: LPCWSTR, dwFileAttributes: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsDebuggerPresent() callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DebugBreak() callconv(.Stdcall) void;
pub extern "kernel32" fn OutputDebugStringA(lpOutputString: LPCSTR) callconv(.Stdcall) void;
pub extern "kernel32" fn OutputDebugStringW(lpOutputString: LPCWSTR) callconv(.Stdcall) void;
pub extern "kernel32" fn ContinueDebugEvent(dwProcessId: DWORD, dwThreadId: DWORD, dwContinueStatus: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WaitForDebugEvent(lpDebugEvent: LPDEBUG_EVENT, dwMilliseconds: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DebugActiveProcess(dwProcessId: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DebugActiveProcessStop(dwProcessId: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CheckRemoteDebuggerPresent(hProcess: HANDLE, pbDebuggerPresent: PBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WaitForDebugEventEx(lpDebugEvent: LPDEBUG_EVENT, dwMilliseconds: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EncodePointer(Ptr: PVOID) callconv(.Stdcall) PVOID;
pub extern "kernel32" fn DecodePointer(Ptr: PVOID) callconv(.Stdcall) PVOID;
pub extern "kernel32" fn EncodeSystemPointer(Ptr: PVOID) callconv(.Stdcall) PVOID;
pub extern "kernel32" fn DecodeSystemPointer(Ptr: PVOID) callconv(.Stdcall) PVOID;
pub extern "kernel32" fn EncodeRemotePointer(ProcessHandle: HANDLE, Ptr: PVOID, EncodedPtr: [*c]PVOID) callconv(.Stdcall) HRESULT;
pub extern "kernel32" fn DecodeRemotePointer(ProcessHandle: HANDLE, Ptr: PVOID, DecodedPtr: [*c]PVOID) callconv(.Stdcall) HRESULT;
pub extern "kernel32" fn Beep(dwFreq: DWORD, dwDuration: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CloseHandle(hObject: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DuplicateHandle(hSourceProcessHandle: HANDLE, hSourceHandle: HANDLE, hTargetProcessHandle: HANDLE, lpTargetHandle: LPHANDLE, dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwOptions: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CompareObjectHandles(hFirstObjectHandle: HANDLE, hSecondObjectHandle: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetHandleInformation(hObject: HANDLE, lpdwFlags: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetHandleInformation(hObject: HANDLE, dwMask: DWORD, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub const PTOP_LEVEL_EXCEPTION_FILTER = ?fn ([*c]struct__EXCEPTION_POINTERS) callconv(.C) LONG;
pub const LPTOP_LEVEL_EXCEPTION_FILTER = PTOP_LEVEL_EXCEPTION_FILTER;
pub extern "kernel32" fn RaiseException(dwExceptionCode: DWORD, dwExceptionFlags: DWORD, nNumberOfArguments: DWORD, lpArguments: [*c]const ULONG_PTR) callconv(.Stdcall) void;
pub extern "kernel32" fn UnhandledExceptionFilter(ExceptionInfo: [*c]struct__EXCEPTION_POINTERS) callconv(.Stdcall) LONG;
pub extern "kernel32" fn SetUnhandledExceptionFilter(lpTopLevelExceptionFilter: LPTOP_LEVEL_EXCEPTION_FILTER) callconv(.Stdcall) LPTOP_LEVEL_EXCEPTION_FILTER;
pub extern "kernel32" fn GetLastError() callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SetLastError(dwErrCode: DWORD) callconv(.Stdcall) void;
pub extern "kernel32" fn GetErrorMode() callconv(.Stdcall) UINT;
pub extern "kernel32" fn SetErrorMode(uMode: UINT) callconv(.Stdcall) UINT;
pub extern "kernel32" fn AddVectoredExceptionHandler(First: ULONG, Handler: PVECTORED_EXCEPTION_HANDLER) callconv(.Stdcall) PVOID;
pub extern "kernel32" fn RemoveVectoredExceptionHandler(Handle: PVOID) callconv(.Stdcall) ULONG;
pub extern "kernel32" fn AddVectoredContinueHandler(First: ULONG, Handler: PVECTORED_EXCEPTION_HANDLER) callconv(.Stdcall) PVOID;
pub extern "kernel32" fn RemoveVectoredContinueHandler(Handle: PVOID) callconv(.Stdcall) ULONG;
pub extern "kernel32" fn RaiseFailFastException(pExceptionRecord: PEXCEPTION_RECORD, pContextRecord: PCONTEXT, dwFlags: DWORD) callconv(.Stdcall) void;
pub extern "kernel32" fn FatalAppExitA(uAction: UINT, lpMessageText: LPCSTR) callconv(.Stdcall) void;
pub extern "kernel32" fn FatalAppExitW(uAction: UINT, lpMessageText: LPCWSTR) callconv(.Stdcall) void;
pub extern "kernel32" fn GetThreadErrorMode() callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SetThreadErrorMode(dwNewMode: DWORD, lpOldMode: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn TerminateProcessOnMemoryExhaustion(FailedAllocationSize: SIZE_T) callconv(.Stdcall) void;
pub extern "kernel32" fn FlsAlloc(lpCallback: PFLS_CALLBACK_FUNCTION) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn FlsGetValue(dwFlsIndex: DWORD) callconv(.Stdcall) PVOID;
pub extern "kernel32" fn FlsSetValue(dwFlsIndex: DWORD, lpFlsData: PVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FlsFree(dwFlsIndex: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsThreadAFiber() callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreatePipe(hReadPipe: PHANDLE, hWritePipe: PHANDLE, lpPipeAttributes: LPSECURITY_ATTRIBUTES, nSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ConnectNamedPipe(hNamedPipe: HANDLE, lpOverlapped: LPOVERLAPPED) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DisconnectNamedPipe(hNamedPipe: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetNamedPipeHandleState(hNamedPipe: HANDLE, lpMode: LPDWORD, lpMaxCollectionCount: LPDWORD, lpCollectDataTimeout: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn PeekNamedPipe(hNamedPipe: HANDLE, lpBuffer: LPVOID, nBufferSize: DWORD, lpBytesRead: LPDWORD, lpTotalBytesAvail: LPDWORD, lpBytesLeftThisMessage: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn TransactNamedPipe(hNamedPipe: HANDLE, lpInBuffer: LPVOID, nInBufferSize: DWORD, lpOutBuffer: LPVOID, nOutBufferSize: DWORD, lpBytesRead: LPDWORD, lpOverlapped: LPOVERLAPPED) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateNamedPipeW(lpName: LPCWSTR, dwOpenMode: DWORD, dwPipeMode: DWORD, nMaxInstances: DWORD, nOutBufferSize: DWORD, nInBufferSize: DWORD, nDefaultTimeOut: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn WaitNamedPipeW(lpNamedPipeName: LPCWSTR, nTimeOut: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNamedPipeClientComputerNameW(Pipe: HANDLE, ClientComputerName: LPWSTR, ClientComputerNameLength: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ImpersonateNamedPipeClient(hNamedPipe: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNamedPipeInfo(hNamedPipe: HANDLE, lpFlags: LPDWORD, lpOutBufferSize: LPDWORD, lpInBufferSize: LPDWORD, lpMaxInstances: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNamedPipeHandleStateW(hNamedPipe: HANDLE, lpState: LPDWORD, lpCurInstances: LPDWORD, lpMaxCollectionCount: LPDWORD, lpCollectDataTimeout: LPDWORD, lpUserName: LPWSTR, nMaxUserNameSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CallNamedPipeW(lpNamedPipeName: LPCWSTR, lpInBuffer: LPVOID, nInBufferSize: DWORD, lpOutBuffer: LPVOID, nOutBufferSize: DWORD, lpBytesRead: LPDWORD, nTimeOut: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn QueryPerformanceCounter(lpPerformanceCount: [*c]LARGE_INTEGER) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn QueryPerformanceFrequency(lpFrequency: [*c]LARGE_INTEGER) callconv(.Stdcall) BOOL;
pub const struct__HEAP_SUMMARY = extern struct {
    cb: DWORD,
    cbAllocated: SIZE_T,
    cbCommitted: SIZE_T,
    cbReserved: SIZE_T,
    cbMaxReserve: SIZE_T,
};
pub const HEAP_SUMMARY = struct__HEAP_SUMMARY;
pub const PHEAP_SUMMARY = [*c]struct__HEAP_SUMMARY;
pub const LPHEAP_SUMMARY = PHEAP_SUMMARY;
pub extern "kernel32" fn HeapCreate(flOptions: DWORD, dwInitialSize: SIZE_T, dwMaximumSize: SIZE_T) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn HeapDestroy(hHeap: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn HeapAlloc(hHeap: HANDLE, dwFlags: DWORD, dwBytes: SIZE_T) callconv(.Stdcall) LPVOID;
pub extern "kernel32" fn HeapReAlloc(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID, dwBytes: SIZE_T) callconv(.Stdcall) LPVOID;
pub extern "kernel32" fn HeapFree(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn HeapSize(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPCVOID) callconv(.Stdcall) SIZE_T;
pub extern "kernel32" fn GetProcessHeap() callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn HeapCompact(hHeap: HANDLE, dwFlags: DWORD) callconv(.Stdcall) SIZE_T;
pub extern "kernel32" fn HeapSetInformation(HeapHandle: HANDLE, HeapInformationClass: HEAP_INFORMATION_CLASS, HeapInformation: PVOID, HeapInformationLength: SIZE_T) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn HeapValidate(hHeap: HANDLE, dwFlags: DWORD, lpMem: LPCVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn HeapSummary(hHeap: HANDLE, dwFlags: DWORD, lpSummary: LPHEAP_SUMMARY) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetProcessHeaps(NumberOfHeaps: DWORD, ProcessHeaps: PHANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn HeapLock(hHeap: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn HeapUnlock(hHeap: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn HeapWalk(hHeap: HANDLE, lpEntry: LPPROCESS_HEAP_ENTRY) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn HeapQueryInformation(HeapHandle: HANDLE, HeapInformationClass: HEAP_INFORMATION_CLASS, HeapInformation: PVOID, HeapInformationLength: SIZE_T, ReturnLength: PSIZE_T) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateIoCompletionPort(FileHandle: HANDLE, ExistingCompletionPort: HANDLE, CompletionKey: ULONG_PTR, NumberOfConcurrentThreads: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn GetQueuedCompletionStatus(CompletionPort: HANDLE, lpNumberOfBytesTransferred: LPDWORD, lpCompletionKey: PULONG_PTR, lpOverlapped: [*c]LPOVERLAPPED, dwMilliseconds: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetQueuedCompletionStatusEx(CompletionPort: HANDLE, lpCompletionPortEntries: LPOVERLAPPED_ENTRY, ulCount: ULONG, ulNumEntriesRemoved: PULONG, dwMilliseconds: DWORD, fAlertable: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn PostQueuedCompletionStatus(CompletionPort: HANDLE, dwNumberOfBytesTransferred: DWORD, dwCompletionKey: ULONG_PTR, lpOverlapped: LPOVERLAPPED) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeviceIoControl(hDevice: HANDLE, dwIoControlCode: DWORD, lpInBuffer: LPVOID, nInBufferSize: DWORD, lpOutBuffer: LPVOID, nOutBufferSize: DWORD, lpBytesReturned: LPDWORD, lpOverlapped: LPOVERLAPPED) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetOverlappedResult(hFile: HANDLE, lpOverlapped: LPOVERLAPPED, lpNumberOfBytesTransferred: LPDWORD, bWait: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CancelIoEx(hFile: HANDLE, lpOverlapped: LPOVERLAPPED) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CancelIo(hFile: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetOverlappedResultEx(hFile: HANDLE, lpOverlapped: LPOVERLAPPED, lpNumberOfBytesTransferred: LPDWORD, dwMilliseconds: DWORD, bAlertable: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CancelSynchronousIo(hThread: HANDLE) callconv(.Stdcall) BOOL;
pub const SRWLOCK = RTL_SRWLOCK;
pub const PSRWLOCK = [*c]RTL_SRWLOCK;
pub extern "kernel32" fn InitializeSRWLock(SRWLock: PSRWLOCK) callconv(.Stdcall) void;
pub extern "kernel32" fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK) callconv(.Stdcall) void;
pub extern "kernel32" fn ReleaseSRWLockShared(SRWLock: PSRWLOCK) callconv(.Stdcall) void;
pub extern "kernel32" fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK) callconv(.Stdcall) void;
pub extern "kernel32" fn AcquireSRWLockShared(SRWLock: PSRWLOCK) callconv(.Stdcall) void;
pub extern "kernel32" fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) callconv(.Stdcall) BOOLEAN;
pub extern "kernel32" fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) callconv(.Stdcall) BOOLEAN;
pub extern "kernel32" fn InitializeCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) callconv(.Stdcall) void;
pub extern "kernel32" fn EnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) callconv(.Stdcall) void;
pub extern "kernel32" fn LeaveCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) callconv(.Stdcall) void;
pub extern "kernel32" fn InitializeCriticalSectionAndSpinCount(lpCriticalSection: LPCRITICAL_SECTION, dwSpinCount: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn InitializeCriticalSectionEx(lpCriticalSection: LPCRITICAL_SECTION, dwSpinCount: DWORD, Flags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetCriticalSectionSpinCount(lpCriticalSection: LPCRITICAL_SECTION, dwSpinCount: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn TryEnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeleteCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) callconv(.Stdcall) void;
pub const INIT_ONCE = RTL_RUN_ONCE;
pub const PINIT_ONCE = PRTL_RUN_ONCE;
pub const LPINIT_ONCE = PRTL_RUN_ONCE;
pub const PINIT_ONCE_FN = ?fn (PINIT_ONCE, PVOID, [*c]PVOID) callconv(.C) BOOL;
pub extern "kernel32" fn InitOnceInitialize(InitOnce: PINIT_ONCE) callconv(.Stdcall) void;
pub extern "kernel32" fn InitOnceExecuteOnce(InitOnce: PINIT_ONCE, InitFn: PINIT_ONCE_FN, Parameter: PVOID, Context: [*c]LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn InitOnceBeginInitialize(lpInitOnce: LPINIT_ONCE, dwFlags: DWORD, fPending: PBOOL, lpContext: [*c]LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn InitOnceComplete(lpInitOnce: LPINIT_ONCE, dwFlags: DWORD, lpContext: LPVOID) callconv(.Stdcall) BOOL;
pub const CONDITION_VARIABLE = RTL_CONDITION_VARIABLE;
pub const PCONDITION_VARIABLE = [*c]RTL_CONDITION_VARIABLE;
pub extern "kernel32" fn InitializeConditionVariable(ConditionVariable: PCONDITION_VARIABLE) callconv(.Stdcall) void;
pub extern "kernel32" fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE) callconv(.Stdcall) void;
pub extern "kernel32" fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE) callconv(.Stdcall) void;
pub extern "kernel32" fn SleepConditionVariableCS(ConditionVariable: PCONDITION_VARIABLE, CriticalSection: PCRITICAL_SECTION, dwMilliseconds: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SleepConditionVariableSRW(ConditionVariable: PCONDITION_VARIABLE, SRWLock: PSRWLOCK, dwMilliseconds: DWORD, Flags: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetEvent(hEvent: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ResetEvent(hEvent: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ReleaseSemaphore(hSemaphore: HANDLE, lReleaseCount: LONG, lpPreviousCount: LPLONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ReleaseMutex(hMutex: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SleepEx(dwMilliseconds: DWORD, bAlertable: BOOL) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn WaitForSingleObjectEx(hHandle: HANDLE, dwMilliseconds: DWORD, bAlertable: BOOL) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn WaitForMultipleObjectsEx(nCount: DWORD, lpHandles: [*c]const HANDLE, bWaitAll: BOOL, dwMilliseconds: DWORD, bAlertable: BOOL) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn CreateMutexA(lpMutexAttributes: LPSECURITY_ATTRIBUTES, bInitialOwner: BOOL, lpName: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateMutexW(lpMutexAttributes: LPSECURITY_ATTRIBUTES, bInitialOwner: BOOL, lpName: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn OpenMutexW(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateEventA(lpEventAttributes: LPSECURITY_ATTRIBUTES, bManualReset: BOOL, bInitialState: BOOL, lpName: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateEventW(lpEventAttributes: LPSECURITY_ATTRIBUTES, bManualReset: BOOL, bInitialState: BOOL, lpName: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn OpenEventA(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn OpenEventW(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn OpenSemaphoreW(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCWSTR) callconv(.Stdcall) HANDLE;
pub const PTIMERAPCROUTINE = ?fn (LPVOID, DWORD, DWORD) callconv(.C) void;
pub extern "kernel32" fn OpenWaitableTimerW(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpTimerName: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn SetWaitableTimerEx(hTimer: HANDLE, lpDueTime: [*c]const LARGE_INTEGER, lPeriod: LONG, pfnCompletionRoutine: PTIMERAPCROUTINE, lpArgToCompletionRoutine: LPVOID, WakeContext: PREASON_CONTEXT, TolerableDelay: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetWaitableTimer(hTimer: HANDLE, lpDueTime: [*c]const LARGE_INTEGER, lPeriod: LONG, pfnCompletionRoutine: PTIMERAPCROUTINE, lpArgToCompletionRoutine: LPVOID, fResume: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CancelWaitableTimer(hTimer: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateMutexExA(lpMutexAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCSTR, dwFlags: DWORD, dwDesiredAccess: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateMutexExW(lpMutexAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCWSTR, dwFlags: DWORD, dwDesiredAccess: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateEventExA(lpEventAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCSTR, dwFlags: DWORD, dwDesiredAccess: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateEventExW(lpEventAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCWSTR, dwFlags: DWORD, dwDesiredAccess: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateSemaphoreExW(lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES, lInitialCount: LONG, lMaximumCount: LONG, lpName: LPCWSTR, dwFlags: DWORD, dwDesiredAccess: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateWaitableTimerExW(lpTimerAttributes: LPSECURITY_ATTRIBUTES, lpTimerName: LPCWSTR, dwFlags: DWORD, dwDesiredAccess: DWORD) callconv(.Stdcall) HANDLE;
pub const SYNCHRONIZATION_BARRIER = RTL_BARRIER;
pub const PSYNCHRONIZATION_BARRIER = PRTL_BARRIER;
pub const LPSYNCHRONIZATION_BARRIER = PRTL_BARRIER;
pub extern "kernel32" fn EnterSynchronizationBarrier(lpBarrier: LPSYNCHRONIZATION_BARRIER, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn InitializeSynchronizationBarrier(lpBarrier: LPSYNCHRONIZATION_BARRIER, lTotalThreads: LONG, lSpinCount: LONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeleteSynchronizationBarrier(lpBarrier: LPSYNCHRONIZATION_BARRIER) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn Sleep(dwMilliseconds: DWORD) callconv(.Stdcall) void;
pub extern "kernel32" fn WaitOnAddress(Address: ?*volatile c_void, CompareAddress: PVOID, AddressSize: SIZE_T, dwMilliseconds: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WakeByAddressSingle(Address: PVOID) callconv(.Stdcall) void;
pub extern "kernel32" fn WakeByAddressAll(Address: PVOID) callconv(.Stdcall) void;
pub extern "kernel32" fn SignalObjectAndWait(hObjectToSignal: HANDLE, hObjectToWaitOn: HANDLE, dwMilliseconds: DWORD, bAlertable: BOOL) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn WaitForMultipleObjects(nCount: DWORD, lpHandles: [*c]const HANDLE, bWaitAll: BOOL, dwMilliseconds: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn CreateSemaphoreW(lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES, lInitialCount: LONG, lMaximumCount: LONG, lpName: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateWaitableTimerW(lpTimerAttributes: LPSECURITY_ATTRIBUTES, bManualReset: BOOL, lpTimerName: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn InitializeSListHead(ListHead: PSLIST_HEADER) callconv(.Stdcall) void;
pub extern "kernel32" fn InterlockedPopEntrySList(ListHead: PSLIST_HEADER) callconv(.Stdcall) PSLIST_ENTRY;
pub extern "kernel32" fn InterlockedPushEntrySList(ListHead: PSLIST_HEADER, ListEntry: PSLIST_ENTRY) callconv(.Stdcall) PSLIST_ENTRY;
pub extern "kernel32" fn InterlockedPushListSListEx(ListHead: PSLIST_HEADER, List: PSLIST_ENTRY, ListEnd: PSLIST_ENTRY, Count: ULONG) callconv(.Stdcall) PSLIST_ENTRY;
pub extern "kernel32" fn InterlockedFlushSList(ListHead: PSLIST_HEADER) callconv(.Stdcall) PSLIST_ENTRY;
pub extern "kernel32" fn QueryDepthSList(ListHead: PSLIST_HEADER) callconv(.Stdcall) USHORT;
pub const struct__PROCESS_INFORMATION = extern struct {
    hProcess: HANDLE,
    hThread: HANDLE,
    dwProcessId: DWORD,
    dwThreadId: DWORD,
};
pub const PROCESS_INFORMATION = struct__PROCESS_INFORMATION;
pub const PPROCESS_INFORMATION = [*c]struct__PROCESS_INFORMATION;
pub const LPPROCESS_INFORMATION = [*c]struct__PROCESS_INFORMATION;
pub const struct__STARTUPINFOA = extern struct {
    cb: DWORD,
    lpReserved: LPSTR,
    lpDesktop: LPSTR,
    lpTitle: LPSTR,
    dwX: DWORD,
    dwY: DWORD,
    dwXSize: DWORD,
    dwYSize: DWORD,
    dwXCountChars: DWORD,
    dwYCountChars: DWORD,
    dwFillAttribute: DWORD,
    dwFlags: DWORD,
    wShowWindow: WORD,
    cbReserved2: WORD,
    lpReserved2: LPBYTE,
    hStdInput: HANDLE,
    hStdOutput: HANDLE,
    hStdError: HANDLE,
};
pub const STARTUPINFOA = struct__STARTUPINFOA;
pub const LPSTARTUPINFOA = [*c]struct__STARTUPINFOA;
pub const struct__STARTUPINFOW = extern struct {
    cb: DWORD,
    lpReserved: LPWSTR,
    lpDesktop: LPWSTR,
    lpTitle: LPWSTR,
    dwX: DWORD,
    dwY: DWORD,
    dwXSize: DWORD,
    dwYSize: DWORD,
    dwXCountChars: DWORD,
    dwYCountChars: DWORD,
    dwFillAttribute: DWORD,
    dwFlags: DWORD,
    wShowWindow: WORD,
    cbReserved2: WORD,
    lpReserved2: LPBYTE,
    hStdInput: HANDLE,
    hStdOutput: HANDLE,
    hStdError: HANDLE,
};
pub const STARTUPINFOW = struct__STARTUPINFOW;
pub const LPSTARTUPINFOW = [*c]struct__STARTUPINFOW;
pub const STARTUPINFO = STARTUPINFOA;
pub const LPSTARTUPINFO = LPSTARTUPINFOA;
pub extern "kernel32" fn QueueUserAPC(pfnAPC: PAPCFUNC, hThread: HANDLE, dwData: ULONG_PTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetProcessTimes(hProcess: HANDLE, lpCreationTime: LPFILETIME, lpExitTime: LPFILETIME, lpKernelTime: LPFILETIME, lpUserTime: LPFILETIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCurrentProcess() callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn GetCurrentProcessId() callconv(.Stdcall) DWORD;
pub extern "kernel32" fn ExitProcess(uExitCode: UINT) callconv(.Stdcall) noreturn;
pub extern "kernel32" fn TerminateProcess(hProcess: HANDLE, uExitCode: UINT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetExitCodeProcess(hProcess: HANDLE, lpExitCode: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SwitchToThread() callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateThread(lpThreadAttributes: LPSECURITY_ATTRIBUTES, dwStackSize: SIZE_T, lpStartAddress: LPTHREAD_START_ROUTINE, lpParameter: LPVOID, dwCreationFlags: DWORD, lpThreadId: LPDWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateRemoteThread(hProcess: HANDLE, lpThreadAttributes: LPSECURITY_ATTRIBUTES, dwStackSize: SIZE_T, lpStartAddress: LPTHREAD_START_ROUTINE, lpParameter: LPVOID, dwCreationFlags: DWORD, lpThreadId: LPDWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn GetCurrentThread() callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn GetCurrentThreadId() callconv(.Stdcall) DWORD;
pub extern "kernel32" fn OpenThread(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwThreadId: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn SetThreadPriority(hThread: HANDLE, nPriority: c_int) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetThreadPriorityBoost(hThread: HANDLE, bDisablePriorityBoost: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetThreadPriorityBoost(hThread: HANDLE, pDisablePriorityBoost: PBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetThreadPriority(hThread: HANDLE) callconv(.Stdcall) c_int;
pub extern "kernel32" fn ExitThread(dwExitCode: DWORD) callconv(.Stdcall) noreturn;
pub extern "kernel32" fn TerminateThread(hThread: HANDLE, dwExitCode: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetExitCodeThread(hThread: HANDLE, lpExitCode: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SuspendThread(hThread: HANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn ResumeThread(hThread: HANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn TlsAlloc() callconv(.Stdcall) DWORD;
pub extern "kernel32" fn TlsGetValue(dwTlsIndex: DWORD) callconv(.Stdcall) LPVOID;
pub extern "kernel32" fn TlsSetValue(dwTlsIndex: DWORD, lpTlsValue: LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn TlsFree(dwTlsIndex: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateProcessA(lpApplicationName: LPCSTR, lpCommandLine: LPSTR, lpProcessAttributes: LPSECURITY_ATTRIBUTES, lpThreadAttributes: LPSECURITY_ATTRIBUTES, bInheritHandles: BOOL, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCSTR, lpStartupInfo: LPSTARTUPINFOA, lpProcessInformation: LPPROCESS_INFORMATION) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateProcessW(lpApplicationName: LPCWSTR, lpCommandLine: LPWSTR, lpProcessAttributes: LPSECURITY_ATTRIBUTES, lpThreadAttributes: LPSECURITY_ATTRIBUTES, bInheritHandles: BOOL, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCWSTR, lpStartupInfo: LPSTARTUPINFOW, lpProcessInformation: LPPROCESS_INFORMATION) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetProcessShutdownParameters(dwLevel: DWORD, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetProcessVersion(ProcessId: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetStartupInfoW(lpStartupInfo: LPSTARTUPINFOW) callconv(.Stdcall) void;
pub extern "advapi32" fn CreateProcessAsUserW(hToken: HANDLE, lpApplicationName: LPCWSTR, lpCommandLine: LPWSTR, lpProcessAttributes: LPSECURITY_ATTRIBUTES, lpThreadAttributes: LPSECURITY_ATTRIBUTES, bInheritHandles: BOOL, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCWSTR, lpStartupInfo: LPSTARTUPINFOW, lpProcessInformation: LPPROCESS_INFORMATION) callconv(.Stdcall) BOOL;
pub fn GetCurrentProcessToken() HANDLE {
    return HANDLE(LONG_PTR(-4));
}
pub fn GetCurrentThreadToken() HANDLE {
    return HANDLE(LONG_PTR(-5));
}
pub fn GetCurrentThreadEffectiveToken() HANDLE {
    return HANDLE(LONG_PTR(-6));
}
pub extern "advapi32" fn SetThreadToken(Thread: PHANDLE, Token: HANDLE) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn OpenProcessToken(ProcessHandle: HANDLE, DesiredAccess: DWORD, TokenHandle: PHANDLE) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn OpenThreadToken(ThreadHandle: HANDLE, DesiredAccess: DWORD, OpenAsSelf: BOOL, TokenHandle: PHANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetPriorityClass(hProcess: HANDLE, dwPriorityClass: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetPriorityClass(hProcess: HANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SetThreadStackGuarantee(StackSizeInBytes: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ProcessIdToSessionId(dwProcessId: DWORD, pSessionId: [*c]DWORD) callconv(.Stdcall) BOOL;
pub const struct__PROC_THREAD_ATTRIBUTE_LIST = @OpaqueType();
pub const PPROC_THREAD_ATTRIBUTE_LIST = ?*struct__PROC_THREAD_ATTRIBUTE_LIST;
pub const LPPROC_THREAD_ATTRIBUTE_LIST = ?*struct__PROC_THREAD_ATTRIBUTE_LIST;
pub extern "kernel32" fn GetProcessId(Process: HANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetThreadId(Thread: HANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn FlushProcessWriteBuffers() callconv(.Stdcall) void;
pub extern "kernel32" fn GetProcessIdOfThread(Thread: HANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn InitializeProcThreadAttributeList(lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST, dwAttributeCount: DWORD, dwFlags: DWORD, lpSize: PSIZE_T) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeleteProcThreadAttributeList(lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST) callconv(.Stdcall) void;
pub extern "kernel32" fn SetProcessAffinityUpdateMode(hProcess: HANDLE, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn QueryProcessAffinityUpdateMode(hProcess: HANDLE, lpdwFlags: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn UpdateProcThreadAttribute(lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST, dwFlags: DWORD, Attribute: DWORD_PTR, lpValue: PVOID, cbSize: SIZE_T, lpPreviousValue: PVOID, lpReturnSize: PSIZE_T) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateRemoteThreadEx(hProcess: HANDLE, lpThreadAttributes: LPSECURITY_ATTRIBUTES, dwStackSize: SIZE_T, lpStartAddress: LPTHREAD_START_ROUTINE, lpParameter: LPVOID, dwCreationFlags: DWORD, lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST, lpThreadId: LPDWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn GetCurrentThreadStackLimits(LowLimit: PULONG_PTR, HighLimit: PULONG_PTR) callconv(.Stdcall) void;
pub extern "kernel32" fn GetThreadContext(hThread: HANDLE, lpContext: LPCONTEXT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetProcessMitigationPolicy(hProcess: HANDLE, MitigationPolicy: PROCESS_MITIGATION_POLICY, lpBuffer: PVOID, dwLength: SIZE_T) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetThreadContext(hThread: HANDLE, lpContext: [*c]const CONTEXT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetProcessMitigationPolicy(MitigationPolicy: PROCESS_MITIGATION_POLICY, lpBuffer: PVOID, dwLength: SIZE_T) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FlushInstructionCache(hProcess: HANDLE, lpBaseAddress: LPCVOID, dwSize: SIZE_T) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetThreadTimes(hThread: HANDLE, lpCreationTime: LPFILETIME, lpExitTime: LPFILETIME, lpKernelTime: LPFILETIME, lpUserTime: LPFILETIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn OpenProcess(dwDesiredAccess: DWORD, bInheritHandle: BOOL, dwProcessId: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn IsProcessorFeaturePresent(ProcessorFeature: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetProcessHandleCount(hProcess: HANDLE, pdwHandleCount: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCurrentProcessorNumber() callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SetThreadIdealProcessorEx(hThread: HANDLE, lpIdealProcessor: PPROCESSOR_NUMBER, lpPreviousIdealProcessor: PPROCESSOR_NUMBER) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetThreadIdealProcessorEx(hThread: HANDLE, lpIdealProcessor: PPROCESSOR_NUMBER) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCurrentProcessorNumberEx(ProcNumber: PPROCESSOR_NUMBER) callconv(.Stdcall) void;
pub extern "kernel32" fn GetProcessPriorityBoost(hProcess: HANDLE, pDisablePriorityBoost: PBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetProcessPriorityBoost(hProcess: HANDLE, bDisablePriorityBoost: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetThreadIOPendingFlag(hThread: HANDLE, lpIOIsPending: PBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetSystemTimes(lpIdleTime: PFILETIME, lpKernelTime: PFILETIME, lpUserTime: PFILETIME) callconv(.Stdcall) BOOL;
pub const ThreadMemoryPriority = enum__THREAD_INFORMATION_CLASS.ThreadMemoryPriority;
pub const ThreadAbsoluteCpuPriority = enum__THREAD_INFORMATION_CLASS.ThreadAbsoluteCpuPriority;
pub const ThreadDynamicCodePolicy = enum__THREAD_INFORMATION_CLASS.ThreadDynamicCodePolicy;
pub const ThreadPowerThrottling = enum__THREAD_INFORMATION_CLASS.ThreadPowerThrottling;
pub const ThreadInformationClassMax = enum__THREAD_INFORMATION_CLASS.ThreadInformationClassMax;
pub const enum__THREAD_INFORMATION_CLASS = extern enum {
    ThreadMemoryPriority,
    ThreadAbsoluteCpuPriority,
    ThreadDynamicCodePolicy,
    ThreadPowerThrottling,
    ThreadInformationClassMax,
};
pub const THREAD_INFORMATION_CLASS = enum__THREAD_INFORMATION_CLASS;
pub const struct__MEMORY_PRIORITY_INFORMATION = extern struct {
    MemoryPriority: ULONG,
};
pub const MEMORY_PRIORITY_INFORMATION = struct__MEMORY_PRIORITY_INFORMATION;
pub const PMEMORY_PRIORITY_INFORMATION = [*c]struct__MEMORY_PRIORITY_INFORMATION;
pub extern "kernel32" fn GetThreadInformation(hThread: HANDLE, ThreadInformationClass: THREAD_INFORMATION_CLASS, ThreadInformation: LPVOID, ThreadInformationSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetThreadInformation(hThread: HANDLE, ThreadInformationClass: THREAD_INFORMATION_CLASS, ThreadInformation: LPVOID, ThreadInformationSize: DWORD) callconv(.Stdcall) BOOL;
pub const struct__THREAD_POWER_THROTTLING_STATE = extern struct {
    Version: ULONG,
    ControlMask: ULONG,
    StateMask: ULONG,
};
pub const THREAD_POWER_THROTTLING_STATE = struct__THREAD_POWER_THROTTLING_STATE;
pub extern "kernel32" fn IsProcessCritical(hProcess: HANDLE, Critical: PBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetProtectedPolicy(PolicyGuid: LPCGUID, PolicyValue: ULONG_PTR, OldPolicyValue: PULONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn QueryProtectedPolicy(PolicyGuid: LPCGUID, PolicyValue: PULONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetThreadIdealProcessor(hThread: HANDLE, dwIdealProcessor: DWORD) callconv(.Stdcall) DWORD;
pub const ProcessMemoryPriority = enum__PROCESS_INFORMATION_CLASS.ProcessMemoryPriority;
pub const ProcessMemoryExhaustionInfo = enum__PROCESS_INFORMATION_CLASS.ProcessMemoryExhaustionInfo;
pub const ProcessAppMemoryInfo = enum__PROCESS_INFORMATION_CLASS.ProcessAppMemoryInfo;
pub const ProcessInPrivateInfo = enum__PROCESS_INFORMATION_CLASS.ProcessInPrivateInfo;
pub const ProcessPowerThrottling = enum__PROCESS_INFORMATION_CLASS.ProcessPowerThrottling;
pub const ProcessReservedValue1 = enum__PROCESS_INFORMATION_CLASS.ProcessReservedValue1;
pub const ProcessTelemetryCoverageInfo = enum__PROCESS_INFORMATION_CLASS.ProcessTelemetryCoverageInfo;
pub const ProcessProtectionLevelInfo = enum__PROCESS_INFORMATION_CLASS.ProcessProtectionLevelInfo;
pub const ProcessLeapSecondInfo = enum__PROCESS_INFORMATION_CLASS.ProcessLeapSecondInfo;
pub const ProcessInformationClassMax = enum__PROCESS_INFORMATION_CLASS.ProcessInformationClassMax;
pub const enum__PROCESS_INFORMATION_CLASS = extern enum {
    ProcessMemoryPriority,
    ProcessMemoryExhaustionInfo,
    ProcessAppMemoryInfo,
    ProcessInPrivateInfo,
    ProcessPowerThrottling,
    ProcessReservedValue1,
    ProcessTelemetryCoverageInfo,
    ProcessProtectionLevelInfo,
    ProcessLeapSecondInfo,
    ProcessInformationClassMax,
};
pub const PROCESS_INFORMATION_CLASS = enum__PROCESS_INFORMATION_CLASS;
pub const struct__APP_MEMORY_INFORMATION = extern struct {
    AvailableCommit: ULONG64,
    PrivateCommitUsage: ULONG64,
    PeakPrivateCommitUsage: ULONG64,
    TotalCommitUsage: ULONG64,
};
pub const APP_MEMORY_INFORMATION = struct__APP_MEMORY_INFORMATION;
pub const PAPP_MEMORY_INFORMATION = [*c]struct__APP_MEMORY_INFORMATION;
pub const PMETypeFailFastOnCommitFailure = enum__PROCESS_MEMORY_EXHAUSTION_TYPE.PMETypeFailFastOnCommitFailure;
pub const PMETypeMax = enum__PROCESS_MEMORY_EXHAUSTION_TYPE.PMETypeMax;
pub const enum__PROCESS_MEMORY_EXHAUSTION_TYPE = extern enum {
    PMETypeFailFastOnCommitFailure,
    PMETypeMax,
};
pub const PROCESS_MEMORY_EXHAUSTION_TYPE = enum__PROCESS_MEMORY_EXHAUSTION_TYPE;
pub const PPROCESS_MEMORY_EXHAUSTION_TYPE = [*c]enum__PROCESS_MEMORY_EXHAUSTION_TYPE;
pub const struct__PROCESS_MEMORY_EXHAUSTION_INFO = extern struct {
    Version: USHORT,
    Reserved: USHORT,
    Type: PROCESS_MEMORY_EXHAUSTION_TYPE,
    Value: ULONG_PTR,
};
pub const PROCESS_MEMORY_EXHAUSTION_INFO = struct__PROCESS_MEMORY_EXHAUSTION_INFO;
pub const PPROCESS_MEMORY_EXHAUSTION_INFO = [*c]struct__PROCESS_MEMORY_EXHAUSTION_INFO;
pub const struct__PROCESS_POWER_THROTTLING_STATE = extern struct {
    Version: ULONG,
    ControlMask: ULONG,
    StateMask: ULONG,
};
pub const PROCESS_POWER_THROTTLING_STATE = struct__PROCESS_POWER_THROTTLING_STATE;
pub const PPROCESS_POWER_THROTTLING_STATE = [*c]struct__PROCESS_POWER_THROTTLING_STATE;
pub const struct_PROCESS_PROTECTION_LEVEL_INFORMATION = extern struct {
    ProtectionLevel: DWORD,
};
pub const PROCESS_PROTECTION_LEVEL_INFORMATION = struct_PROCESS_PROTECTION_LEVEL_INFORMATION;
pub const struct__PROCESS_LEAP_SECOND_INFO = extern struct {
    Flags: ULONG,
    Reserved: ULONG,
};
pub const PROCESS_LEAP_SECOND_INFO = struct__PROCESS_LEAP_SECOND_INFO;
pub const PPROCESS_LEAP_SECOND_INFO = [*c]struct__PROCESS_LEAP_SECOND_INFO;
pub extern "kernel32" fn SetProcessInformation(hProcess: HANDLE, ProcessInformationClass: PROCESS_INFORMATION_CLASS, ProcessInformation: LPVOID, ProcessInformationSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetProcessInformation(hProcess: HANDLE, ProcessInformationClass: PROCESS_INFORMATION_CLASS, ProcessInformation: LPVOID, ProcessInformationSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetSystemCpuSetInformation(Information: PSYSTEM_CPU_SET_INFORMATION, BufferLength: ULONG, ReturnedLength: PULONG, Process: HANDLE, Flags: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetProcessDefaultCpuSets(Process: HANDLE, CpuSetIds: PULONG, CpuSetIdCount: ULONG, RequiredIdCount: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetProcessDefaultCpuSets(Process: HANDLE, CpuSetIds: [*c]const ULONG, CpuSetIdCount: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetThreadSelectedCpuSets(Thread: HANDLE, CpuSetIds: PULONG, CpuSetIdCount: ULONG, RequiredIdCount: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetThreadSelectedCpuSets(Thread: HANDLE, CpuSetIds: [*c]const ULONG, CpuSetIdCount: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateProcessAsUserA(hToken: HANDLE, lpApplicationName: LPCSTR, lpCommandLine: LPSTR, lpProcessAttributes: LPSECURITY_ATTRIBUTES, lpThreadAttributes: LPSECURITY_ATTRIBUTES, bInheritHandles: BOOL, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCSTR, lpStartupInfo: LPSTARTUPINFOA, lpProcessInformation: LPPROCESS_INFORMATION) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetProcessShutdownParameters(lpdwLevel: LPDWORD, lpdwFlags: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetThreadDescription(hThread: HANDLE, lpThreadDescription: PCWSTR) callconv(.Stdcall) HRESULT;
pub extern "kernel32" fn GetThreadDescription(hThread: HANDLE, ppszThreadDescription: [*c]PWSTR) callconv(.Stdcall) HRESULT;
pub const struct__SYSTEM_INFO = extern struct {
    @"": extern union {
        dwOemId: DWORD,
        @"": extern struct {
            wProcessorArchitecture: WORD,
            wReserved: WORD,
        },
    },
    dwPageSize: DWORD,
    lpMinimumApplicationAddress: LPVOID,
    lpMaximumApplicationAddress: LPVOID,
    dwActiveProcessorMask: DWORD_PTR,
    dwNumberOfProcessors: DWORD,
    dwProcessorType: DWORD,
    dwAllocationGranularity: DWORD,
    wProcessorLevel: WORD,
    wProcessorRevision: WORD,
};
pub const SYSTEM_INFO = struct__SYSTEM_INFO;
pub const LPSYSTEM_INFO = [*c]struct__SYSTEM_INFO;
pub const struct__MEMORYSTATUSEX = extern struct {
    dwLength: DWORD,
    dwMemoryLoad: DWORD,
    ullTotalPhys: DWORDLONG,
    ullAvailPhys: DWORDLONG,
    ullTotalPageFile: DWORDLONG,
    ullAvailPageFile: DWORDLONG,
    ullTotalVirtual: DWORDLONG,
    ullAvailVirtual: DWORDLONG,
    ullAvailExtendedVirtual: DWORDLONG,
};
pub const MEMORYSTATUSEX = struct__MEMORYSTATUSEX;
pub const LPMEMORYSTATUSEX = [*c]struct__MEMORYSTATUSEX;
pub extern "kernel32" fn GlobalMemoryStatusEx(lpBuffer: LPMEMORYSTATUSEX) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetSystemInfo(lpSystemInfo: LPSYSTEM_INFO) callconv(.Stdcall) void;
pub extern "kernel32" fn GetSystemTime(lpSystemTime: LPSYSTEMTIME) callconv(.Stdcall) void;
pub extern "kernel32" fn GetSystemTimeAsFileTime(lpSystemTimeAsFileTime: LPFILETIME) callconv(.Stdcall) void;
pub extern "kernel32" fn GetLocalTime(lpSystemTime: LPSYSTEMTIME) callconv(.Stdcall) void;
pub extern "kernel32" fn GetSystemLeapSecondInformation(Enabled: PBOOL, Flags: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetVersion() callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SetLocalTime(lpSystemTime: [*c]const SYSTEMTIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetTickCount() callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetTickCount64() callconv(.Stdcall) ULONGLONG;
pub extern "kernel32" fn GetSystemTimeAdjustment(lpTimeAdjustment: PDWORD, lpTimeIncrement: PDWORD, lpTimeAdjustmentDisabled: PBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetSystemTimeAdjustmentPrecise(lpTimeAdjustment: PDWORD64, lpTimeIncrement: PDWORD64, lpTimeAdjustmentDisabled: PBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetSystemDirectoryA(lpBuffer: LPSTR, uSize: UINT) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetSystemDirectoryW(lpBuffer: LPWSTR, uSize: UINT) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetWindowsDirectoryA(lpBuffer: LPSTR, uSize: UINT) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetWindowsDirectoryW(lpBuffer: LPWSTR, uSize: UINT) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetSystemWindowsDirectoryA(lpBuffer: LPSTR, uSize: UINT) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetSystemWindowsDirectoryW(lpBuffer: LPWSTR, uSize: UINT) callconv(.Stdcall) UINT;
pub const ComputerNameNetBIOS = enum__COMPUTER_NAME_FORMAT.ComputerNameNetBIOS;
pub const ComputerNameDnsHostname = enum__COMPUTER_NAME_FORMAT.ComputerNameDnsHostname;
pub const ComputerNameDnsDomain = enum__COMPUTER_NAME_FORMAT.ComputerNameDnsDomain;
pub const ComputerNameDnsFullyQualified = enum__COMPUTER_NAME_FORMAT.ComputerNameDnsFullyQualified;
pub const ComputerNamePhysicalNetBIOS = enum__COMPUTER_NAME_FORMAT.ComputerNamePhysicalNetBIOS;
pub const ComputerNamePhysicalDnsHostname = enum__COMPUTER_NAME_FORMAT.ComputerNamePhysicalDnsHostname;
pub const ComputerNamePhysicalDnsDomain = enum__COMPUTER_NAME_FORMAT.ComputerNamePhysicalDnsDomain;
pub const ComputerNamePhysicalDnsFullyQualified = enum__COMPUTER_NAME_FORMAT.ComputerNamePhysicalDnsFullyQualified;
pub const ComputerNameMax = enum__COMPUTER_NAME_FORMAT.ComputerNameMax;
pub const enum__COMPUTER_NAME_FORMAT = extern enum {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax,
};
pub const COMPUTER_NAME_FORMAT = enum__COMPUTER_NAME_FORMAT;
pub extern "kernel32" fn GetComputerNameExA(NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPSTR, nSize: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetComputerNameExW(NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPWSTR, nSize: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetComputerNameExW(NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetSystemTime(lpSystemTime: [*c]const SYSTEMTIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetVersionExA(lpVersionInformation: LPOSVERSIONINFOA) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetVersionExW(lpVersionInformation: LPOSVERSIONINFOW) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetLogicalProcessorInformation(Buffer: PSYSTEM_LOGICAL_PROCESSOR_INFORMATION, ReturnedLength: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetLogicalProcessorInformationEx(RelationshipType: LOGICAL_PROCESSOR_RELATIONSHIP, Buffer: PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, ReturnedLength: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNativeSystemInfo(lpSystemInfo: LPSYSTEM_INFO) callconv(.Stdcall) void;
pub extern "kernel32" fn GetSystemTimePreciseAsFileTime(lpSystemTimeAsFileTime: LPFILETIME) callconv(.Stdcall) void;
pub extern "kernel32" fn GetProductInfo(dwOSMajorVersion: DWORD, dwOSMinorVersion: DWORD, dwSpMajorVersion: DWORD, dwSpMinorVersion: DWORD, pdwReturnedProductType: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetOsSafeBootMode(Flags: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumSystemFirmwareTables(FirmwareTableProviderSignature: DWORD, pFirmwareTableEnumBuffer: PVOID, BufferSize: DWORD) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetSystemFirmwareTable(FirmwareTableProviderSignature: DWORD, FirmwareTableID: DWORD, pFirmwareTableBuffer: PVOID, BufferSize: DWORD) callconv(.Stdcall) UINT;
pub extern "kernel32" fn DnsHostnameToComputerNameExW(Hostname: LPCWSTR, ComputerName: LPWSTR, nSize: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetPhysicallyInstalledSystemMemory(TotalMemoryInKilobytes: PULONGLONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetComputerNameEx2W(NameType: COMPUTER_NAME_FORMAT, Flags: DWORD, lpBuffer: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetSystemTimeAdjustment(dwTimeAdjustment: DWORD, bTimeAdjustmentDisabled: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetSystemTimeAdjustmentPrecise(dwTimeAdjustment: DWORD64, bTimeAdjustmentDisabled: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn InstallELAMCertificateInfo(ELAMFile: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetProcessorSystemCycleTime(Group: USHORT, Buffer: PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION, ReturnedLength: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetOsManufacturingMode(pbEnabled: PBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetIntegratedDisplaySize(sizeInInches: [*c]f64) callconv(.Stdcall) HRESULT;
pub extern "kernel32" fn SetComputerNameA(lpComputerName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetComputerNameW(lpComputerName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetComputerNameExA(NameType: COMPUTER_NAME_FORMAT, lpBuffer: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn VirtualAlloc(lpAddress: LPVOID, dwSize: SIZE_T, flAllocationType: DWORD, flProtect: DWORD) callconv(.Stdcall) LPVOID;
pub extern "kernel32" fn VirtualProtect(lpAddress: LPVOID, dwSize: SIZE_T, flNewProtect: DWORD, lpflOldProtect: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn VirtualFree(lpAddress: LPVOID, dwSize: SIZE_T, dwFreeType: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn VirtualQuery(lpAddress: LPCVOID, lpBuffer: PMEMORY_BASIC_INFORMATION, dwLength: SIZE_T) callconv(.Stdcall) SIZE_T;
pub extern "kernel32" fn VirtualAllocEx(hProcess: HANDLE, lpAddress: LPVOID, dwSize: SIZE_T, flAllocationType: DWORD, flProtect: DWORD) callconv(.Stdcall) LPVOID;
pub extern "kernel32" fn VirtualProtectEx(hProcess: HANDLE, lpAddress: LPVOID, dwSize: SIZE_T, flNewProtect: DWORD, lpflOldProtect: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn VirtualQueryEx(hProcess: HANDLE, lpAddress: LPCVOID, lpBuffer: PMEMORY_BASIC_INFORMATION, dwLength: SIZE_T) callconv(.Stdcall) SIZE_T;
pub extern "kernel32" fn ReadProcessMemory(hProcess: HANDLE, lpBaseAddress: LPCVOID, lpBuffer: LPVOID, nSize: SIZE_T, lpNumberOfBytesRead: [*c]SIZE_T) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WriteProcessMemory(hProcess: HANDLE, lpBaseAddress: LPVOID, lpBuffer: LPCVOID, nSize: SIZE_T, lpNumberOfBytesWritten: [*c]SIZE_T) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateFileMappingW(hFile: HANDLE, lpFileMappingAttributes: LPSECURITY_ATTRIBUTES, flProtect: DWORD, dwMaximumSizeHigh: DWORD, dwMaximumSizeLow: DWORD, lpName: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn OpenFileMappingW(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn MapViewOfFile(hFileMappingObject: HANDLE, dwDesiredAccess: DWORD, dwFileOffsetHigh: DWORD, dwFileOffsetLow: DWORD, dwNumberOfBytesToMap: SIZE_T) callconv(.Stdcall) LPVOID;
pub extern "kernel32" fn MapViewOfFileEx(hFileMappingObject: HANDLE, dwDesiredAccess: DWORD, dwFileOffsetHigh: DWORD, dwFileOffsetLow: DWORD, dwNumberOfBytesToMap: SIZE_T, lpBaseAddress: LPVOID) callconv(.Stdcall) LPVOID;
pub extern "kernel32" fn VirtualFreeEx(hProcess: HANDLE, lpAddress: LPVOID, dwSize: SIZE_T, dwFreeType: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FlushViewOfFile(lpBaseAddress: LPCVOID, dwNumberOfBytesToFlush: SIZE_T) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn UnmapViewOfFile(lpBaseAddress: LPCVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetLargePageMinimum() callconv(.Stdcall) SIZE_T;
pub extern "kernel32" fn GetProcessWorkingSetSizeEx(hProcess: HANDLE, lpMinimumWorkingSetSize: PSIZE_T, lpMaximumWorkingSetSize: PSIZE_T, Flags: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetProcessWorkingSetSizeEx(hProcess: HANDLE, dwMinimumWorkingSetSize: SIZE_T, dwMaximumWorkingSetSize: SIZE_T, Flags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn VirtualLock(lpAddress: LPVOID, dwSize: SIZE_T) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn VirtualUnlock(lpAddress: LPVOID, dwSize: SIZE_T) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetWriteWatch(dwFlags: DWORD, lpBaseAddress: PVOID, dwRegionSize: SIZE_T, lpAddresses: [*c]PVOID, lpdwCount: [*c]ULONG_PTR, lpdwGranularity: LPDWORD) callconv(.Stdcall) UINT;
pub extern "kernel32" fn ResetWriteWatch(lpBaseAddress: LPVOID, dwRegionSize: SIZE_T) callconv(.Stdcall) UINT;
pub const LowMemoryResourceNotification = enum__MEMORY_RESOURCE_NOTIFICATION_TYPE.LowMemoryResourceNotification;
pub const HighMemoryResourceNotification = enum__MEMORY_RESOURCE_NOTIFICATION_TYPE.HighMemoryResourceNotification;
pub const enum__MEMORY_RESOURCE_NOTIFICATION_TYPE = extern enum {
    LowMemoryResourceNotification,
    HighMemoryResourceNotification,
};
pub const MEMORY_RESOURCE_NOTIFICATION_TYPE = enum__MEMORY_RESOURCE_NOTIFICATION_TYPE;
pub extern "kernel32" fn CreateMemoryResourceNotification(NotificationType: MEMORY_RESOURCE_NOTIFICATION_TYPE) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn QueryMemoryResourceNotification(ResourceNotificationHandle: HANDLE, ResourceState: PBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetSystemFileCacheSize(lpMinimumFileCacheSize: PSIZE_T, lpMaximumFileCacheSize: PSIZE_T, lpFlags: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetSystemFileCacheSize(MinimumFileCacheSize: SIZE_T, MaximumFileCacheSize: SIZE_T, Flags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateFileMappingNumaW(hFile: HANDLE, lpFileMappingAttributes: LPSECURITY_ATTRIBUTES, flProtect: DWORD, dwMaximumSizeHigh: DWORD, dwMaximumSizeLow: DWORD, lpName: LPCWSTR, nndPreferred: DWORD) callconv(.Stdcall) HANDLE;
pub const struct__WIN32_MEMORY_RANGE_ENTRY = extern struct {
    VirtualAddress: PVOID,
    NumberOfBytes: SIZE_T,
};
pub const WIN32_MEMORY_RANGE_ENTRY = struct__WIN32_MEMORY_RANGE_ENTRY;
pub const PWIN32_MEMORY_RANGE_ENTRY = [*c]struct__WIN32_MEMORY_RANGE_ENTRY;
pub extern "kernel32" fn PrefetchVirtualMemory(hProcess: HANDLE, NumberOfEntries: ULONG_PTR, VirtualAddresses: PWIN32_MEMORY_RANGE_ENTRY, Flags: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateFileMappingFromApp(hFile: HANDLE, SecurityAttributes: PSECURITY_ATTRIBUTES, PageProtection: ULONG, MaximumSize: ULONG64, Name: PCWSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn MapViewOfFileFromApp(hFileMappingObject: HANDLE, DesiredAccess: ULONG, FileOffset: ULONG64, NumberOfBytesToMap: SIZE_T) callconv(.Stdcall) PVOID;
pub extern "kernel32" fn UnmapViewOfFileEx(BaseAddress: PVOID, UnmapFlags: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AllocateUserPhysicalPages(hProcess: HANDLE, NumberOfPages: PULONG_PTR, PageArray: PULONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FreeUserPhysicalPages(hProcess: HANDLE, NumberOfPages: PULONG_PTR, PageArray: PULONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn MapUserPhysicalPages(VirtualAddress: PVOID, NumberOfPages: ULONG_PTR, PageArray: PULONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AllocateUserPhysicalPagesNuma(hProcess: HANDLE, NumberOfPages: PULONG_PTR, PageArray: PULONG_PTR, nndPreferred: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn VirtualAllocExNuma(hProcess: HANDLE, lpAddress: LPVOID, dwSize: SIZE_T, flAllocationType: DWORD, flProtect: DWORD, nndPreferred: DWORD) callconv(.Stdcall) LPVOID;
pub extern "kernel32" fn GetMemoryErrorHandlingCapabilities(Capabilities: PULONG) callconv(.Stdcall) BOOL;
pub const BAD_MEMORY_CALLBACK_ROUTINE = fn () callconv(.C) void;
pub const PBAD_MEMORY_CALLBACK_ROUTINE = [*c]BAD_MEMORY_CALLBACK_ROUTINE;
pub extern "kernel32" fn RegisterBadMemoryNotification(Callback: PBAD_MEMORY_CALLBACK_ROUTINE) callconv(.Stdcall) PVOID;
pub extern "kernel32" fn UnregisterBadMemoryNotification(RegistrationHandle: PVOID) callconv(.Stdcall) BOOL;
pub const VmOfferPriorityVeryLow = enum_OFFER_PRIORITY.VmOfferPriorityVeryLow;
pub const VmOfferPriorityLow = enum_OFFER_PRIORITY.VmOfferPriorityLow;
pub const VmOfferPriorityBelowNormal = enum_OFFER_PRIORITY.VmOfferPriorityBelowNormal;
pub const VmOfferPriorityNormal = enum_OFFER_PRIORITY.VmOfferPriorityNormal;
pub const enum_OFFER_PRIORITY = extern enum {
    VmOfferPriorityVeryLow = 1,
    VmOfferPriorityLow = 2,
    VmOfferPriorityBelowNormal = 3,
    VmOfferPriorityNormal = 4,
};
pub const OFFER_PRIORITY = enum_OFFER_PRIORITY;
pub extern "kernel32" fn OfferVirtualMemory(VirtualAddress: PVOID, Size: SIZE_T, Priority: OFFER_PRIORITY) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn ReclaimVirtualMemory(VirtualAddress: ?*const c_void, Size: SIZE_T) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn DiscardVirtualMemory(VirtualAddress: PVOID, Size: SIZE_T) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SetProcessValidCallTargets(hProcess: HANDLE, VirtualAddress: PVOID, RegionSize: SIZE_T, NumberOfOffsets: ULONG, OffsetInformation: PCFG_CALL_TARGET_INFO) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetProcessValidCallTargetsForMappedView(Process: HANDLE, VirtualAddress: PVOID, RegionSize: SIZE_T, NumberOfOffsets: ULONG, OffsetInformation: PCFG_CALL_TARGET_INFO, Section: HANDLE, ExpectedFileOffset: ULONG64) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn VirtualAllocFromApp(BaseAddress: PVOID, Size: SIZE_T, AllocationType: ULONG, Protection: ULONG) callconv(.Stdcall) PVOID;
pub extern "kernel32" fn VirtualProtectFromApp(Address: PVOID, Size: SIZE_T, NewProtection: ULONG, OldProtection: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn OpenFileMappingFromApp(DesiredAccess: ULONG, InheritHandle: BOOL, Name: PCWSTR) callconv(.Stdcall) HANDLE;
pub const MemoryRegionInfo = enum_WIN32_MEMORY_INFORMATION_CLASS.MemoryRegionInfo;
pub const enum_WIN32_MEMORY_INFORMATION_CLASS = extern enum {
    MemoryRegionInfo,
};
pub const WIN32_MEMORY_INFORMATION_CLASS = enum_WIN32_MEMORY_INFORMATION_CLASS;
pub const struct_WIN32_MEMORY_REGION_INFORMATION = extern struct {
    AllocationBase: PVOID,
    AllocationProtect: ULONG,
    @"": extern union {
        Flags: ULONG,
        @"": @OpaqueType(),
    },
    RegionSize: SIZE_T,
    CommitSize: SIZE_T,
};
pub const WIN32_MEMORY_REGION_INFORMATION = struct_WIN32_MEMORY_REGION_INFORMATION;
pub extern "onecore" fn QueryVirtualMemoryInformation(Process: HANDLE, VirtualAddress: ?*const c_void, MemoryInformationClass: WIN32_MEMORY_INFORMATION_CLASS, MemoryInformation: PVOID, MemoryInformationSize: SIZE_T, ReturnSize: PSIZE_T) callconv(.Stdcall) BOOL;
pub extern "onecore" fn MapViewOfFileNuma2(FileMappingHandle: HANDLE, ProcessHandle: HANDLE, Offset: ULONG64, BaseAddress: PVOID, ViewSize: SIZE_T, AllocationType: ULONG, PageProtection: ULONG, PreferredNode: ULONG) callconv(.Stdcall) PVOID;
pub fn MapViewOfFile2(FileMappingHandle: HANDLE, ProcessHandle: HANDLE, Offset: ULONG64, BaseAddress: PVOID, ViewSize: SIZE_T, AllocationType: ULONG, PageProtection: ULONG) PVOID {
    return MapViewOfFileNuma2(FileMappingHandle, ProcessHandle, Offset, BaseAddress, ViewSize, AllocationType, PageProtection, DWORD(-1));
}
pub extern "kernel32" fn UnmapViewOfFile2(Process: HANDLE, BaseAddress: PVOID, UnmapFlags: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn VirtualUnlockEx(Process: HANDLE, Address: LPVOID, Size: SIZE_T) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn VirtualAlloc2(Process: HANDLE, BaseAddress: PVOID, Size: SIZE_T, AllocationType: ULONG, PageProtection: ULONG, ExtendedParameters: [*c]MEM_EXTENDED_PARAMETER, ParameterCount: ULONG) callconv(.Stdcall) PVOID;
pub extern "kernel32" fn MapViewOfFile3(FileMapping: HANDLE, Process: HANDLE, BaseAddress: PVOID, Offset: ULONG64, ViewSize: SIZE_T, AllocationType: ULONG, PageProtection: ULONG, ExtendedParameters: [*c]MEM_EXTENDED_PARAMETER, ParameterCount: ULONG) callconv(.Stdcall) PVOID;
pub extern "kernel32" fn VirtualAlloc2FromApp(Process: HANDLE, BaseAddress: PVOID, Size: SIZE_T, AllocationType: ULONG, PageProtection: ULONG, ExtendedParameters: [*c]MEM_EXTENDED_PARAMETER, ParameterCount: ULONG) callconv(.Stdcall) PVOID;
pub extern "kernel32" fn MapViewOfFile3FromApp(FileMapping: HANDLE, Process: HANDLE, BaseAddress: PVOID, Offset: ULONG64, ViewSize: SIZE_T, AllocationType: ULONG, PageProtection: ULONG, ExtendedParameters: [*c]MEM_EXTENDED_PARAMETER, ParameterCount: ULONG) callconv(.Stdcall) PVOID;
pub extern "kernel32" fn CreateFileMapping2(File: HANDLE, SecurityAttributes: [*c]SECURITY_ATTRIBUTES, DesiredAccess: ULONG, PageProtection: ULONG, AllocationAttributes: ULONG, MaximumSize: ULONG64, Name: PCWSTR, ExtendedParameters: [*c]MEM_EXTENDED_PARAMETER, ParameterCount: ULONG) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn IsEnclaveTypeSupported(flEnclaveType: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateEnclave(hProcess: HANDLE, lpAddress: LPVOID, dwSize: SIZE_T, dwInitialCommitment: SIZE_T, flEnclaveType: DWORD, lpEnclaveInformation: LPCVOID, dwInfoLength: DWORD, lpEnclaveError: LPDWORD) callconv(.Stdcall) LPVOID;
pub extern "kernel32" fn LoadEnclaveData(hProcess: HANDLE, lpAddress: LPVOID, lpBuffer: LPCVOID, nSize: SIZE_T, flProtect: DWORD, lpPageInformation: LPCVOID, dwInfoLength: DWORD, lpNumberOfBytesWritten: PSIZE_T, lpEnclaveError: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn InitializeEnclave(hProcess: HANDLE, lpAddress: LPVOID, lpEnclaveInformation: LPCVOID, dwInfoLength: DWORD, lpEnclaveError: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn LoadEnclaveImageA(lpEnclaveAddress: LPVOID, lpImageName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn LoadEnclaveImageW(lpEnclaveAddress: LPVOID, lpImageName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CallEnclave(lpRoutine: LPENCLAVE_ROUTINE, lpParameter: LPVOID, fWaitForThread: BOOL, lpReturnValue: [*c]LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn TerminateEnclave(lpAddress: LPVOID, fWait: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeleteEnclave(lpAddress: LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn QueueUserWorkItem(Function: LPTHREAD_START_ROUTINE, Context: PVOID, Flags: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn UnregisterWaitEx(WaitHandle: HANDLE, CompletionEvent: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateTimerQueue() callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateTimerQueueTimer(phNewTimer: PHANDLE, TimerQueue: HANDLE, Callback: WAITORTIMERCALLBACK, Parameter: PVOID, DueTime: DWORD, Period: DWORD, Flags: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ChangeTimerQueueTimer(TimerQueue: HANDLE, Timer: HANDLE, DueTime: ULONG, Period: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeleteTimerQueueTimer(TimerQueue: HANDLE, Timer: HANDLE, CompletionEvent: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeleteTimerQueueEx(TimerQueue: HANDLE, CompletionEvent: HANDLE) callconv(.Stdcall) BOOL;
pub const PTP_WIN32_IO_CALLBACK = ?fn (PTP_CALLBACK_INSTANCE, PVOID, PVOID, ULONG, ULONG_PTR, PTP_IO) callconv(.C) void;
pub extern "kernel32" fn CreateThreadpool(reserved: PVOID) callconv(.Stdcall) PTP_POOL;
pub extern "kernel32" fn SetThreadpoolThreadMaximum(ptpp: PTP_POOL, cthrdMost: DWORD) callconv(.Stdcall) void;
pub extern "kernel32" fn SetThreadpoolThreadMinimum(ptpp: PTP_POOL, cthrdMic: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetThreadpoolStackInformation(ptpp: PTP_POOL, ptpsi: PTP_POOL_STACK_INFORMATION) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn QueryThreadpoolStackInformation(ptpp: PTP_POOL, ptpsi: PTP_POOL_STACK_INFORMATION) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CloseThreadpool(ptpp: PTP_POOL) callconv(.Stdcall) void;
pub extern "kernel32" fn CreateThreadpoolCleanupGroup() callconv(.Stdcall) PTP_CLEANUP_GROUP;
pub extern "kernel32" fn CloseThreadpoolCleanupGroupMembers(ptpcg: PTP_CLEANUP_GROUP, fCancelPendingCallbacks: BOOL, pvCleanupContext: PVOID) callconv(.Stdcall) void;
pub extern "kernel32" fn CloseThreadpoolCleanupGroup(ptpcg: PTP_CLEANUP_GROUP) callconv(.Stdcall) void;
pub extern "kernel32" fn SetEventWhenCallbackReturns(pci: PTP_CALLBACK_INSTANCE, evt: HANDLE) callconv(.Stdcall) void;
pub extern "kernel32" fn ReleaseSemaphoreWhenCallbackReturns(pci: PTP_CALLBACK_INSTANCE, sem: HANDLE, crel: DWORD) callconv(.Stdcall) void;
pub extern "kernel32" fn ReleaseMutexWhenCallbackReturns(pci: PTP_CALLBACK_INSTANCE, mut: HANDLE) callconv(.Stdcall) void;
pub extern "kernel32" fn LeaveCriticalSectionWhenCallbackReturns(pci: PTP_CALLBACK_INSTANCE, pcs: PCRITICAL_SECTION) callconv(.Stdcall) void;
pub extern "kernel32" fn FreeLibraryWhenCallbackReturns(pci: PTP_CALLBACK_INSTANCE, mod: HMODULE) callconv(.Stdcall) void;
pub extern "kernel32" fn CallbackMayRunLong(pci: PTP_CALLBACK_INSTANCE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DisassociateCurrentThreadFromCallback(pci: PTP_CALLBACK_INSTANCE) callconv(.Stdcall) void;
pub extern "kernel32" fn TrySubmitThreadpoolCallback(pfns: PTP_SIMPLE_CALLBACK, pv: PVOID, pcbe: PTP_CALLBACK_ENVIRON) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateThreadpoolWork(pfnwk: PTP_WORK_CALLBACK, pv: PVOID, pcbe: PTP_CALLBACK_ENVIRON) callconv(.Stdcall) PTP_WORK;
pub extern "kernel32" fn SubmitThreadpoolWork(pwk: PTP_WORK) callconv(.Stdcall) void;
pub extern "kernel32" fn WaitForThreadpoolWorkCallbacks(pwk: PTP_WORK, fCancelPendingCallbacks: BOOL) callconv(.Stdcall) void;
pub extern "kernel32" fn CloseThreadpoolWork(pwk: PTP_WORK) callconv(.Stdcall) void;
pub extern "kernel32" fn CreateThreadpoolTimer(pfnti: PTP_TIMER_CALLBACK, pv: PVOID, pcbe: PTP_CALLBACK_ENVIRON) callconv(.Stdcall) PTP_TIMER;
pub extern "kernel32" fn SetThreadpoolTimer(pti: PTP_TIMER, pftDueTime: PFILETIME, msPeriod: DWORD, msWindowLength: DWORD) callconv(.Stdcall) void;
pub extern "kernel32" fn IsThreadpoolTimerSet(pti: PTP_TIMER) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WaitForThreadpoolTimerCallbacks(pti: PTP_TIMER, fCancelPendingCallbacks: BOOL) callconv(.Stdcall) void;
pub extern "kernel32" fn CloseThreadpoolTimer(pti: PTP_TIMER) callconv(.Stdcall) void;
pub extern "kernel32" fn CreateThreadpoolWait(pfnwa: PTP_WAIT_CALLBACK, pv: PVOID, pcbe: PTP_CALLBACK_ENVIRON) callconv(.Stdcall) PTP_WAIT;
pub extern "kernel32" fn SetThreadpoolWait(pwa: PTP_WAIT, h: HANDLE, pftTimeout: PFILETIME) callconv(.Stdcall) void;
pub extern "kernel32" fn WaitForThreadpoolWaitCallbacks(pwa: PTP_WAIT, fCancelPendingCallbacks: BOOL) callconv(.Stdcall) void;
pub extern "kernel32" fn CloseThreadpoolWait(pwa: PTP_WAIT) callconv(.Stdcall) void;
pub extern "kernel32" fn CreateThreadpoolIo(fl: HANDLE, pfnio: PTP_WIN32_IO_CALLBACK, pv: PVOID, pcbe: PTP_CALLBACK_ENVIRON) callconv(.Stdcall) PTP_IO;
pub extern "kernel32" fn StartThreadpoolIo(pio: PTP_IO) callconv(.Stdcall) void;
pub extern "kernel32" fn CancelThreadpoolIo(pio: PTP_IO) callconv(.Stdcall) void;
pub extern "kernel32" fn WaitForThreadpoolIoCallbacks(pio: PTP_IO, fCancelPendingCallbacks: BOOL) callconv(.Stdcall) void;
pub extern "kernel32" fn CloseThreadpoolIo(pio: PTP_IO) callconv(.Stdcall) void;
pub extern "kernel32" fn SetThreadpoolTimerEx(pti: PTP_TIMER, pftDueTime: PFILETIME, msPeriod: DWORD, msWindowLength: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetThreadpoolWaitEx(pwa: PTP_WAIT, h: HANDLE, pftTimeout: PFILETIME, Reserved: PVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsProcessInJob(ProcessHandle: HANDLE, JobHandle: HANDLE, Result: PBOOL) callconv(.Stdcall) BOOL;
pub const struct_JOBOBJECT_IO_RATE_CONTROL_INFORMATION = extern struct {
    MaxIops: LONG64,
    MaxBandwidth: LONG64,
    ReservationIops: LONG64,
    VolumeName: PCWSTR,
    BaseIoSize: ULONG,
    ControlFlags: ULONG,
};
pub const JOBOBJECT_IO_RATE_CONTROL_INFORMATION = struct_JOBOBJECT_IO_RATE_CONTROL_INFORMATION;
pub extern "kernel32" fn CreateJobObjectW(lpJobAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn FreeMemoryJobObject(Buffer: ?*c_void) callconv(.Stdcall) void;
pub extern "kernel32" fn OpenJobObjectW(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn AssignProcessToJobObject(hJob: HANDLE, hProcess: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn TerminateJobObject(hJob: HANDLE, uExitCode: UINT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetInformationJobObject(hJob: HANDLE, JobObjectInformationClass: JOBOBJECTINFOCLASS, lpJobObjectInformation: LPVOID, cbJobObjectInformationLength: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetIoRateControlInformationJobObject(hJob: HANDLE, IoRateControlInfo: [*c]JOBOBJECT_IO_RATE_CONTROL_INFORMATION) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn QueryInformationJobObject(hJob: HANDLE, JobObjectInformationClass: JOBOBJECTINFOCLASS, lpJobObjectInformation: LPVOID, cbJobObjectInformationLength: DWORD, lpReturnLength: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn QueryIoRateControlInformationJobObject(hJob: HANDLE, VolumeName: PCWSTR, InfoBlocks: [*c]([*c]JOBOBJECT_IO_RATE_CONTROL_INFORMATION), InfoBlockCount: [*c]ULONG) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn Wow64DisableWow64FsRedirection(OldValue: [*c]PVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn Wow64RevertWow64FsRedirection(OlValue: PVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsWow64Process(hProcess: HANDLE, Wow64Process: PBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetSystemWow64DirectoryA(lpBuffer: LPSTR, uSize: UINT) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetSystemWow64DirectoryW(lpBuffer: LPWSTR, uSize: UINT) callconv(.Stdcall) UINT;
pub extern "kernel32" fn Wow64SetThreadDefaultGuestMachine(Machine: USHORT) callconv(.Stdcall) USHORT;
pub extern "kernel32" fn IsWow64Process2(hProcess: HANDLE, pProcessMachine: [*c]USHORT, pNativeMachine: [*c]USHORT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetSystemWow64Directory2A(lpBuffer: LPSTR, uSize: UINT, ImageFileMachineType: WORD) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetSystemWow64Directory2W(lpBuffer: LPWSTR, uSize: UINT, ImageFileMachineType: WORD) callconv(.Stdcall) UINT;
pub extern "kernel32" fn IsWow64GuestMachineSupported(WowGuestMachine: USHORT, MachineIsSupported: [*c]BOOL) callconv(.Stdcall) HRESULT;
pub const struct_tagENUMUILANG = extern struct {
    NumOfEnumUILang: ULONG,
    SizeOfEnumUIBuffer: ULONG,
    pEnumUIBuffer: [*c]LANGID,
};
pub const ENUMUILANG = struct_tagENUMUILANG;
pub const PENUMUILANG = [*c]struct_tagENUMUILANG;
pub const ENUMRESLANGPROCA = ?fn (HMODULE, LPCSTR, LPCSTR, WORD, LONG_PTR) callconv(.C) BOOL;
pub const ENUMRESLANGPROCW = ?fn (HMODULE, LPCWSTR, LPCWSTR, WORD, LONG_PTR) callconv(.C) BOOL;
pub const ENUMRESNAMEPROCA = ?fn (HMODULE, LPCSTR, LPSTR, LONG_PTR) callconv(.C) BOOL;
pub const ENUMRESNAMEPROCW = ?fn (HMODULE, LPCWSTR, LPWSTR, LONG_PTR) callconv(.C) BOOL;
pub const ENUMRESTYPEPROCA = ?fn (HMODULE, LPSTR, LONG_PTR) callconv(.C) BOOL;
pub const ENUMRESTYPEPROCW = ?fn (HMODULE, LPWSTR, LONG_PTR) callconv(.C) BOOL;
pub extern "kernel32" fn DisableThreadLibraryCalls(hLibModule: HMODULE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindResourceExW(hModule: HMODULE, lpType: LPCWSTR, lpName: LPCWSTR, wLanguage: WORD) callconv(.Stdcall) HRSRC;
pub extern "kernel32" fn FindStringOrdinal(dwFindStringOrdinalFlags: DWORD, lpStringSource: LPCWSTR, cchSource: c_int, lpStringValue: LPCWSTR, cchValue: c_int, bIgnoreCase: BOOL) callconv(.Stdcall) c_int;
pub extern "kernel32" fn FreeLibrary(hLibModule: HMODULE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FreeLibraryAndExitThread(hLibModule: HMODULE, dwExitCode: DWORD) callconv(.Stdcall) noreturn;
pub extern "kernel32" fn FreeResource(hResData: HGLOBAL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetModuleFileNameA(hModule: HMODULE, lpFilename: LPSTR, nSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetModuleFileNameW(hModule: HMODULE, lpFilename: LPWSTR, nSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetModuleHandleA(lpModuleName: LPCSTR) callconv(.Stdcall) HMODULE;
pub extern "kernel32" fn GetModuleHandleW(lpModuleName: LPCWSTR) callconv(.Stdcall) HMODULE;
pub const PGET_MODULE_HANDLE_EXA = ?fn (DWORD, LPCSTR, [*c]HMODULE) callconv(.C) BOOL;
pub const PGET_MODULE_HANDLE_EXW = ?fn (DWORD, LPCWSTR, [*c]HMODULE) callconv(.C) BOOL;
pub extern "kernel32" fn GetModuleHandleExA(dwFlags: DWORD, lpModuleName: LPCSTR, phModule: [*c]HMODULE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetModuleHandleExW(dwFlags: DWORD, lpModuleName: LPCWSTR, phModule: [*c]HMODULE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) callconv(.Stdcall) FARPROC;
pub const struct__REDIRECTION_FUNCTION_DESCRIPTOR = extern struct {
    DllName: PCSTR,
    FunctionName: PCSTR,
    RedirectionTarget: PVOID,
};
pub const REDIRECTION_FUNCTION_DESCRIPTOR = struct__REDIRECTION_FUNCTION_DESCRIPTOR;
pub const PREDIRECTION_FUNCTION_DESCRIPTOR = [*c]struct__REDIRECTION_FUNCTION_DESCRIPTOR;
pub const PCREDIRECTION_FUNCTION_DESCRIPTOR = [*c]const REDIRECTION_FUNCTION_DESCRIPTOR;
pub const struct__REDIRECTION_DESCRIPTOR = extern struct {
    Version: ULONG,
    FunctionCount: ULONG,
    Redirections: PCREDIRECTION_FUNCTION_DESCRIPTOR,
};
pub const REDIRECTION_DESCRIPTOR = struct__REDIRECTION_DESCRIPTOR;
pub const PREDIRECTION_DESCRIPTOR = [*c]struct__REDIRECTION_DESCRIPTOR;
pub const PCREDIRECTION_DESCRIPTOR = [*c]const REDIRECTION_DESCRIPTOR;
pub extern "kernel32" fn LoadLibraryExA(lpLibFileName: LPCSTR, hFile: HANDLE, dwFlags: DWORD) callconv(.Stdcall) HMODULE;
pub extern "kernel32" fn LoadLibraryExW(lpLibFileName: LPCWSTR, hFile: HANDLE, dwFlags: DWORD) callconv(.Stdcall) HMODULE;
pub extern "kernel32" fn LoadResource(hModule: HMODULE, hResInfo: HRSRC) callconv(.Stdcall) HGLOBAL;
pub extern "kernel32" fn LoadStringA(hInstance: HINSTANCE, uID: UINT, lpBuffer: LPSTR, cchBufferMax: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn LoadStringW(hInstance: HINSTANCE, uID: UINT, lpBuffer: LPWSTR, cchBufferMax: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn LockResource(hResData: HGLOBAL) callconv(.Stdcall) LPVOID;
pub extern "kernel32" fn SizeofResource(hModule: HMODULE, hResInfo: HRSRC) callconv(.Stdcall) DWORD;
pub const DLL_DIRECTORY_COOKIE = PVOID;
pub const PDLL_DIRECTORY_COOKIE = [*c]PVOID;
pub extern "kernel32" fn AddDllDirectory(NewDirectory: PCWSTR) callconv(.Stdcall) DLL_DIRECTORY_COOKIE;
pub extern "kernel32" fn RemoveDllDirectory(Cookie: DLL_DIRECTORY_COOKIE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetDefaultDllDirectories(DirectoryFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumResourceLanguagesExA(hModule: HMODULE, lpType: LPCSTR, lpName: LPCSTR, lpEnumFunc: ENUMRESLANGPROCA, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumResourceLanguagesExW(hModule: HMODULE, lpType: LPCWSTR, lpName: LPCWSTR, lpEnumFunc: ENUMRESLANGPROCW, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumResourceNamesExA(hModule: HMODULE, lpType: LPCSTR, lpEnumFunc: ENUMRESNAMEPROCA, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumResourceNamesExW(hModule: HMODULE, lpType: LPCWSTR, lpEnumFunc: ENUMRESNAMEPROCW, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumResourceTypesExA(hModule: HMODULE, lpEnumFunc: ENUMRESTYPEPROCA, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumResourceTypesExW(hModule: HMODULE, lpEnumFunc: ENUMRESTYPEPROCW, lParam: LONG_PTR, dwFlags: DWORD, LangId: LANGID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindResourceW(hModule: HMODULE, lpName: LPCWSTR, lpType: LPCWSTR) callconv(.Stdcall) HRSRC;
pub extern "kernel32" fn LoadLibraryA(lpLibFileName: LPCSTR) callconv(.Stdcall) HMODULE;
pub extern "kernel32" fn LoadLibraryW(lpLibFileName: LPCWSTR) callconv(.Stdcall) HMODULE;
pub extern "kernel32" fn EnumResourceNamesW(hModule: HMODULE, lpType: LPCWSTR, lpEnumFunc: ENUMRESNAMEPROCW, lParam: LONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AccessCheck(pSecurityDescriptor: PSECURITY_DESCRIPTOR, ClientToken: HANDLE, DesiredAccess: DWORD, GenericMapping: PGENERIC_MAPPING, PrivilegeSet: PPRIVILEGE_SET, PrivilegeSetLength: LPDWORD, GrantedAccess: LPDWORD, AccessStatus: LPBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AccessCheckAndAuditAlarmW(SubsystemName: LPCWSTR, HandleId: LPVOID, ObjectTypeName: LPWSTR, ObjectName: LPWSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, DesiredAccess: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: BOOL, GrantedAccess: LPDWORD, AccessStatus: LPBOOL, pfGenerateOnClose: LPBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AccessCheckByType(pSecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, ClientToken: HANDLE, DesiredAccess: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, PrivilegeSet: PPRIVILEGE_SET, PrivilegeSetLength: LPDWORD, GrantedAccess: LPDWORD, AccessStatus: LPBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AccessCheckByTypeResultList(pSecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, ClientToken: HANDLE, DesiredAccess: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, PrivilegeSet: PPRIVILEGE_SET, PrivilegeSetLength: LPDWORD, GrantedAccessList: LPDWORD, AccessStatusList: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AccessCheckByTypeAndAuditAlarmW(SubsystemName: LPCWSTR, HandleId: LPVOID, ObjectTypeName: LPCWSTR, ObjectName: LPCWSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: BOOL, GrantedAccess: LPDWORD, AccessStatus: LPBOOL, pfGenerateOnClose: LPBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AccessCheckByTypeResultListAndAuditAlarmW(SubsystemName: LPCWSTR, HandleId: LPVOID, ObjectTypeName: LPCWSTR, ObjectName: LPCWSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: BOOL, GrantedAccessList: LPDWORD, AccessStatusList: LPDWORD, pfGenerateOnClose: LPBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AccessCheckByTypeResultListAndAuditAlarmByHandleW(SubsystemName: LPCWSTR, HandleId: LPVOID, ClientToken: HANDLE, ObjectTypeName: LPCWSTR, ObjectName: LPCWSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: BOOL, GrantedAccessList: LPDWORD, AccessStatusList: LPDWORD, pfGenerateOnClose: LPBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AddAccessAllowedAce(pAcl: PACL, dwAceRevision: DWORD, AccessMask: DWORD, pSid: PSID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AddAccessAllowedAceEx(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, pSid: PSID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AddAccessAllowedObjectAce(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, ObjectTypeGuid: [*c]GUID, InheritedObjectTypeGuid: [*c]GUID, pSid: PSID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AddAccessDeniedAce(pAcl: PACL, dwAceRevision: DWORD, AccessMask: DWORD, pSid: PSID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AddAccessDeniedAceEx(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, pSid: PSID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AddAccessDeniedObjectAce(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, ObjectTypeGuid: [*c]GUID, InheritedObjectTypeGuid: [*c]GUID, pSid: PSID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AddAce(pAcl: PACL, dwAceRevision: DWORD, dwStartingAceIndex: DWORD, pAceList: LPVOID, nAceListLength: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AddAuditAccessAce(pAcl: PACL, dwAceRevision: DWORD, dwAccessMask: DWORD, pSid: PSID, bAuditSuccess: BOOL, bAuditFailure: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AddAuditAccessAceEx(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, dwAccessMask: DWORD, pSid: PSID, bAuditSuccess: BOOL, bAuditFailure: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AddAuditAccessObjectAce(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, ObjectTypeGuid: [*c]GUID, InheritedObjectTypeGuid: [*c]GUID, pSid: PSID, bAuditSuccess: BOOL, bAuditFailure: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AddMandatoryAce(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, MandatoryPolicy: DWORD, pLabelSid: PSID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AddResourceAttributeAce(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, pSid: PSID, pAttributeInfo: PCLAIM_SECURITY_ATTRIBUTES_INFORMATION, pReturnLength: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AddScopedPolicyIDAce(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AccessMask: DWORD, pSid: PSID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AdjustTokenGroups(TokenHandle: HANDLE, ResetToDefault: BOOL, NewState: PTOKEN_GROUPS, BufferLength: DWORD, PreviousState: PTOKEN_GROUPS, ReturnLength: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AdjustTokenPrivileges(TokenHandle: HANDLE, DisableAllPrivileges: BOOL, NewState: PTOKEN_PRIVILEGES, BufferLength: DWORD, PreviousState: PTOKEN_PRIVILEGES, ReturnLength: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AllocateAndInitializeSid(pIdentifierAuthority: PSID_IDENTIFIER_AUTHORITY, nSubAuthorityCount: BYTE, nSubAuthority0: DWORD, nSubAuthority1: DWORD, nSubAuthority2: DWORD, nSubAuthority3: DWORD, nSubAuthority4: DWORD, nSubAuthority5: DWORD, nSubAuthority6: DWORD, nSubAuthority7: DWORD, pSid: [*c]PSID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AllocateLocallyUniqueId(Luid: PLUID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AreAllAccessesGranted(GrantedAccess: DWORD, DesiredAccess: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AreAnyAccessesGranted(GrantedAccess: DWORD, DesiredAccess: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CheckTokenMembership(TokenHandle: HANDLE, SidToCheck: PSID, IsMember: PBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CheckTokenCapability(TokenHandle: HANDLE, CapabilitySidToCheck: PSID, HasCapability: PBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetAppContainerAce(Acl: PACL, StartingAceIndex: DWORD, AppContainerAce: [*c]PVOID, AppContainerAceIndex: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CheckTokenMembershipEx(TokenHandle: HANDLE, SidToCheck: PSID, Flags: DWORD, IsMember: PBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ConvertToAutoInheritPrivateObjectSecurity(ParentDescriptor: PSECURITY_DESCRIPTOR, CurrentSecurityDescriptor: PSECURITY_DESCRIPTOR, NewSecurityDescriptor: [*c]PSECURITY_DESCRIPTOR, ObjectType: [*c]GUID, IsDirectoryObject: BOOLEAN, GenericMapping: PGENERIC_MAPPING) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CopySid(nDestinationSidLength: DWORD, pDestinationSid: PSID, pSourceSid: PSID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreatePrivateObjectSecurity(ParentDescriptor: PSECURITY_DESCRIPTOR, CreatorDescriptor: PSECURITY_DESCRIPTOR, NewDescriptor: [*c]PSECURITY_DESCRIPTOR, IsDirectoryObject: BOOL, Token: HANDLE, GenericMapping: PGENERIC_MAPPING) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreatePrivateObjectSecurityEx(ParentDescriptor: PSECURITY_DESCRIPTOR, CreatorDescriptor: PSECURITY_DESCRIPTOR, NewDescriptor: [*c]PSECURITY_DESCRIPTOR, ObjectType: [*c]GUID, IsContainerObject: BOOL, AutoInheritFlags: ULONG, Token: HANDLE, GenericMapping: PGENERIC_MAPPING) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreatePrivateObjectSecurityWithMultipleInheritance(ParentDescriptor: PSECURITY_DESCRIPTOR, CreatorDescriptor: PSECURITY_DESCRIPTOR, NewDescriptor: [*c]PSECURITY_DESCRIPTOR, ObjectTypes: [*c]([*c]GUID), GuidCount: ULONG, IsContainerObject: BOOL, AutoInheritFlags: ULONG, Token: HANDLE, GenericMapping: PGENERIC_MAPPING) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateRestrictedToken(ExistingTokenHandle: HANDLE, Flags: DWORD, DisableSidCount: DWORD, SidsToDisable: PSID_AND_ATTRIBUTES, DeletePrivilegeCount: DWORD, PrivilegesToDelete: PLUID_AND_ATTRIBUTES, RestrictedSidCount: DWORD, SidsToRestrict: PSID_AND_ATTRIBUTES, NewTokenHandle: PHANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateWellKnownSid(WellKnownSidType: WELL_KNOWN_SID_TYPE, DomainSid: PSID, pSid: PSID, cbSid: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EqualDomainSid(pSid1: PSID, pSid2: PSID, pfEqual: [*c]BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeleteAce(pAcl: PACL, dwAceIndex: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DestroyPrivateObjectSecurity(ObjectDescriptor: [*c]PSECURITY_DESCRIPTOR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DuplicateToken(ExistingTokenHandle: HANDLE, ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL, DuplicateTokenHandle: PHANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DuplicateTokenEx(hExistingToken: HANDLE, dwDesiredAccess: DWORD, lpTokenAttributes: LPSECURITY_ATTRIBUTES, ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL, TokenType_0: TOKEN_TYPE, phNewToken: PHANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EqualPrefixSid(pSid1: PSID, pSid2: PSID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EqualSid(pSid1: PSID, pSid2: PSID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindFirstFreeAce(pAcl: PACL, pAce: [*c]LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FreeSid(pSid: PSID) callconv(.Stdcall) PVOID;
pub extern "kernel32" fn GetAce(pAcl: PACL, dwAceIndex: DWORD, pAce: [*c]LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetAclInformation(pAcl: PACL, pAclInformation: LPVOID, nAclInformationLength: DWORD, dwAclInformationClass: ACL_INFORMATION_CLASS) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetFileSecurityW(lpFileName: LPCWSTR, RequestedInformation: SECURITY_INFORMATION, pSecurityDescriptor: PSECURITY_DESCRIPTOR, nLength: DWORD, lpnLengthNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetKernelObjectSecurity(Handle: HANDLE, RequestedInformation: SECURITY_INFORMATION, pSecurityDescriptor: PSECURITY_DESCRIPTOR, nLength: DWORD, lpnLengthNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetLengthSid(pSid: PSID) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetPrivateObjectSecurity(ObjectDescriptor: PSECURITY_DESCRIPTOR, SecurityInformation: SECURITY_INFORMATION, ResultantDescriptor: PSECURITY_DESCRIPTOR, DescriptorLength: DWORD, ReturnLength: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetSecurityDescriptorControl(pSecurityDescriptor: PSECURITY_DESCRIPTOR, pControl: PSECURITY_DESCRIPTOR_CONTROL, lpdwRevision: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetSecurityDescriptorDacl(pSecurityDescriptor: PSECURITY_DESCRIPTOR, lpbDaclPresent: LPBOOL, pDacl: [*c]PACL, lpbDaclDefaulted: LPBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetSecurityDescriptorGroup(pSecurityDescriptor: PSECURITY_DESCRIPTOR, pGroup: [*c]PSID, lpbGroupDefaulted: LPBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetSecurityDescriptorLength(pSecurityDescriptor: PSECURITY_DESCRIPTOR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetSecurityDescriptorOwner(pSecurityDescriptor: PSECURITY_DESCRIPTOR, pOwner: [*c]PSID, lpbOwnerDefaulted: LPBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetSecurityDescriptorRMControl(SecurityDescriptor: PSECURITY_DESCRIPTOR, RMControl: PUCHAR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetSecurityDescriptorSacl(pSecurityDescriptor: PSECURITY_DESCRIPTOR, lpbSaclPresent: LPBOOL, pSacl: [*c]PACL, lpbSaclDefaulted: LPBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetSidIdentifierAuthority(pSid: PSID) callconv(.Stdcall) PSID_IDENTIFIER_AUTHORITY;
pub extern "kernel32" fn GetSidLengthRequired(nSubAuthorityCount: UCHAR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetSidSubAuthority(pSid: PSID, nSubAuthority: DWORD) callconv(.Stdcall) PDWORD;
pub extern "kernel32" fn GetSidSubAuthorityCount(pSid: PSID) callconv(.Stdcall) PUCHAR;
pub extern "kernel32" fn GetTokenInformation(TokenHandle: HANDLE, TokenInformationClass: TOKEN_INFORMATION_CLASS, TokenInformation: LPVOID, TokenInformationLength: DWORD, ReturnLength: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetWindowsAccountDomainSid(pSid: PSID, pDomainSid: PSID, cbDomainSid: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ImpersonateAnonymousToken(ThreadHandle: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ImpersonateLoggedOnUser(hToken: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ImpersonateSelf(ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn InitializeAcl(pAcl: PACL, nAclLength: DWORD, dwAclRevision: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn InitializeSecurityDescriptor(pSecurityDescriptor: PSECURITY_DESCRIPTOR, dwRevision: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn InitializeSid(Sid: PSID, pIdentifierAuthority: PSID_IDENTIFIER_AUTHORITY, nSubAuthorityCount: BYTE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsTokenRestricted(TokenHandle: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsValidAcl(pAcl: PACL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsValidSecurityDescriptor(pSecurityDescriptor: PSECURITY_DESCRIPTOR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsValidSid(pSid: PSID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsWellKnownSid(pSid: PSID, WellKnownSidType: WELL_KNOWN_SID_TYPE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn MakeAbsoluteSD(pSelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR, pAbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR, lpdwAbsoluteSecurityDescriptorSize: LPDWORD, pDacl: PACL, lpdwDaclSize: LPDWORD, pSacl: PACL, lpdwSaclSize: LPDWORD, pOwner: PSID, lpdwOwnerSize: LPDWORD, pPrimaryGroup: PSID, lpdwPrimaryGroupSize: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn MakeSelfRelativeSD(pAbsoluteSecurityDescriptor: PSECURITY_DESCRIPTOR, pSelfRelativeSecurityDescriptor: PSECURITY_DESCRIPTOR, lpdwBufferLength: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn MapGenericMask(AccessMask: PDWORD, GenericMapping: PGENERIC_MAPPING) callconv(.Stdcall) void;
pub extern "kernel32" fn ObjectCloseAuditAlarmW(SubsystemName: LPCWSTR, HandleId: LPVOID, GenerateOnClose: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ObjectDeleteAuditAlarmW(SubsystemName: LPCWSTR, HandleId: LPVOID, GenerateOnClose: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ObjectOpenAuditAlarmW(SubsystemName: LPCWSTR, HandleId: LPVOID, ObjectTypeName: LPWSTR, ObjectName: LPWSTR, pSecurityDescriptor: PSECURITY_DESCRIPTOR, ClientToken: HANDLE, DesiredAccess: DWORD, GrantedAccess: DWORD, Privileges: PPRIVILEGE_SET, ObjectCreation: BOOL, AccessGranted: BOOL, GenerateOnClose: LPBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ObjectPrivilegeAuditAlarmW(SubsystemName: LPCWSTR, HandleId: LPVOID, ClientToken: HANDLE, DesiredAccess: DWORD, Privileges: PPRIVILEGE_SET, AccessGranted: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn PrivilegeCheck(ClientToken: HANDLE, RequiredPrivileges: PPRIVILEGE_SET, pfResult: LPBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn PrivilegedServiceAuditAlarmW(SubsystemName: LPCWSTR, ServiceName: LPCWSTR, ClientToken: HANDLE, Privileges: PPRIVILEGE_SET, AccessGranted: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn QuerySecurityAccessMask(SecurityInformation: SECURITY_INFORMATION, DesiredAccess: LPDWORD) callconv(.Stdcall) void;
pub extern "kernel32" fn RevertToSelf() callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetAclInformation(pAcl: PACL, pAclInformation: LPVOID, nAclInformationLength: DWORD, dwAclInformationClass: ACL_INFORMATION_CLASS) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetFileSecurityW(lpFileName: LPCWSTR, SecurityInformation: SECURITY_INFORMATION, pSecurityDescriptor: PSECURITY_DESCRIPTOR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetKernelObjectSecurity(Handle: HANDLE, SecurityInformation: SECURITY_INFORMATION, SecurityDescriptor: PSECURITY_DESCRIPTOR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetPrivateObjectSecurity(SecurityInformation: SECURITY_INFORMATION, ModificationDescriptor: PSECURITY_DESCRIPTOR, ObjectsSecurityDescriptor: [*c]PSECURITY_DESCRIPTOR, GenericMapping: PGENERIC_MAPPING, Token: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetPrivateObjectSecurityEx(SecurityInformation: SECURITY_INFORMATION, ModificationDescriptor: PSECURITY_DESCRIPTOR, ObjectsSecurityDescriptor: [*c]PSECURITY_DESCRIPTOR, AutoInheritFlags: ULONG, GenericMapping: PGENERIC_MAPPING, Token: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetSecurityAccessMask(SecurityInformation: SECURITY_INFORMATION, DesiredAccess: LPDWORD) callconv(.Stdcall) void;
pub extern "kernel32" fn SetSecurityDescriptorControl(pSecurityDescriptor: PSECURITY_DESCRIPTOR, ControlBitsOfInterest: SECURITY_DESCRIPTOR_CONTROL, ControlBitsToSet: SECURITY_DESCRIPTOR_CONTROL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetSecurityDescriptorDacl(pSecurityDescriptor: PSECURITY_DESCRIPTOR, bDaclPresent: BOOL, pDacl: PACL, bDaclDefaulted: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetSecurityDescriptorGroup(pSecurityDescriptor: PSECURITY_DESCRIPTOR, pGroup: PSID, bGroupDefaulted: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetSecurityDescriptorOwner(pSecurityDescriptor: PSECURITY_DESCRIPTOR, pOwner: PSID, bOwnerDefaulted: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetSecurityDescriptorRMControl(SecurityDescriptor: PSECURITY_DESCRIPTOR, RMControl: PUCHAR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SetSecurityDescriptorSacl(pSecurityDescriptor: PSECURITY_DESCRIPTOR, bSaclPresent: BOOL, pSacl: PACL, bSaclDefaulted: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetTokenInformation(TokenHandle: HANDLE, TokenInformationClass: TOKEN_INFORMATION_CLASS, TokenInformation: LPVOID, TokenInformationLength: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetCachedSigningLevel(SourceFiles: PHANDLE, SourceFileCount: ULONG, Flags: ULONG, TargetFile: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCachedSigningLevel(File: HANDLE, Flags: PULONG, SigningLevel: PULONG, Thumbprint: PUCHAR, ThumbprintSize: PULONG, ThumbprintAlgorithm: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CveEventWrite(CveId: PCWSTR, AdditionalDetails: PCWSTR) callconv(.Stdcall) LONG;
pub extern "kernel32" fn DeriveCapabilitySidsFromName(CapName: LPCWSTR, CapabilityGroupSids: [*c]([*c]PSID), CapabilityGroupSidCount: [*c]DWORD, CapabilitySids: [*c]([*c]PSID), CapabilitySidCount: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreatePrivateNamespaceW(lpPrivateNamespaceAttributes: LPSECURITY_ATTRIBUTES, lpBoundaryDescriptor: LPVOID, lpAliasPrefix: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn OpenPrivateNamespaceW(lpBoundaryDescriptor: LPVOID, lpAliasPrefix: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn ClosePrivateNamespace(Handle: HANDLE, Flags: ULONG) callconv(.Stdcall) BOOLEAN;
pub extern "kernel32" fn CreateBoundaryDescriptorW(Name: LPCWSTR, Flags: ULONG) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn AddSIDToBoundaryDescriptor(BoundaryDescriptor: [*c]HANDLE, RequiredSid: PSID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeleteBoundaryDescriptor(BoundaryDescriptor: HANDLE) callconv(.Stdcall) void;
pub extern "kernel32" fn GetNumaHighestNodeNumber(HighestNodeNumber: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNumaNodeProcessorMaskEx(Node: USHORT, ProcessorMask: PGROUP_AFFINITY) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNumaProximityNodeEx(ProximityId: ULONG, NodeNumber: PUSHORT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetProcessGroupAffinity(hProcess: HANDLE, GroupCount: PUSHORT, GroupArray: PUSHORT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetThreadGroupAffinity(hThread: HANDLE, GroupAffinity: PGROUP_AFFINITY) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetThreadGroupAffinity(hThread: HANDLE, GroupAffinity: [*c]const GROUP_AFFINITY, PreviousGroupAffinity: PGROUP_AFFINITY) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetAppContainerNamedObjectPath(Token: HANDLE, AppContainerSid: PSID, ObjectPathLength: ULONG, ObjectPath: LPWSTR, ReturnLength: PULONG) callconv(.Stdcall) BOOL;
pub extern "mincore" fn QueryThreadCycleTime(ThreadHandle: HANDLE, CycleTime: PULONG64) callconv(.Stdcall) BOOL;
pub extern "mincore" fn QueryProcessCycleTime(ProcessHandle: HANDLE, CycleTime: PULONG64) callconv(.Stdcall) BOOL;
pub extern "mincore" fn QueryIdleProcessorCycleTime(BufferLength: PULONG, ProcessorIdleCycleTime: PULONG64) callconv(.Stdcall) BOOL;
pub extern "mincore" fn QueryIdleProcessorCycleTimeEx(Group: USHORT, BufferLength: PULONG, ProcessorIdleCycleTime: PULONG64) callconv(.Stdcall) BOOL;
pub extern "mincore" fn QueryInterruptTimePrecise(lpInterruptTimePrecise: PULONGLONG) callconv(.Stdcall) void;
pub extern "mincore" fn QueryUnbiasedInterruptTimePrecise(lpUnbiasedInterruptTimePrecise: PULONGLONG) callconv(.Stdcall) void;
pub extern "mincore" fn QueryInterruptTime(lpInterruptTime: PULONGLONG) callconv(.Stdcall) void;
pub extern "mincore" fn QueryUnbiasedInterruptTime(UnbiasedTime: PULONGLONG) callconv(.Stdcall) BOOL;
pub extern "mincore" fn QueryAuxiliaryCounterFrequency(lpAuxiliaryCounterFrequency: PULONGLONG) callconv(.Stdcall) HRESULT;
pub extern "mincore" fn ConvertAuxiliaryCounterToPerformanceCounter(ullAuxiliaryCounterValue: ULONGLONG, lpPerformanceCounterValue: PULONGLONG, lpConversionError: PULONGLONG) callconv(.Stdcall) HRESULT;
pub extern "mincore" fn ConvertPerformanceCounterToAuxiliaryCounter(ullPerformanceCounterValue: ULONGLONG, lpAuxiliaryCounterValue: PULONGLONG, lpConversionError: PULONGLONG) callconv(.Stdcall) HRESULT;
pub const PFIBER_START_ROUTINE = ?fn (LPVOID) callconv(.C) void;
pub const LPFIBER_START_ROUTINE = PFIBER_START_ROUTINE;
pub const PFIBER_CALLOUT_ROUTINE = ?fn (LPVOID) callconv(.C) LPVOID;
pub const LPLDT_ENTRY = LPVOID;
pub const struct__COMMPROP = extern struct {
    wPacketLength: WORD,
    wPacketVersion: WORD,
    dwServiceMask: DWORD,
    dwReserved1: DWORD,
    dwMaxTxQueue: DWORD,
    dwMaxRxQueue: DWORD,
    dwMaxBaud: DWORD,
    dwProvSubType: DWORD,
    dwProvCapabilities: DWORD,
    dwSettableParams: DWORD,
    dwSettableBaud: DWORD,
    wSettableData: WORD,
    wSettableStopParity: WORD,
    dwCurrentTxQueue: DWORD,
    dwCurrentRxQueue: DWORD,
    dwProvSpec1: DWORD,
    dwProvSpec2: DWORD,
    wcProvChar: [1]WCHAR,
};
pub const COMMPROP = struct__COMMPROP;
pub const LPCOMMPROP = [*c]struct__COMMPROP;
pub const struct__COMSTAT = @OpaqueType();
pub const COMSTAT = struct__COMSTAT;
pub const LPCOMSTAT = ?*struct__COMSTAT;
pub const struct__DCB = @OpaqueType();
pub const DCB = struct__DCB;
pub const LPDCB = ?*struct__DCB;
pub const struct__COMMTIMEOUTS = extern struct {
    ReadIntervalTimeout: DWORD,
    ReadTotalTimeoutMultiplier: DWORD,
    ReadTotalTimeoutConstant: DWORD,
    WriteTotalTimeoutMultiplier: DWORD,
    WriteTotalTimeoutConstant: DWORD,
};
pub const COMMTIMEOUTS = struct__COMMTIMEOUTS;
pub const LPCOMMTIMEOUTS = [*c]struct__COMMTIMEOUTS;
pub const struct__COMMCONFIG = extern struct {
    dwSize: DWORD,
    wVersion: WORD,
    wReserved: WORD,
    dcb: DCB,
    dwProviderSubType: DWORD,
    dwProviderOffset: DWORD,
    dwProviderSize: DWORD,
    wcProviderData: [1]WCHAR,
};
pub const COMMCONFIG = struct__COMMCONFIG;
pub const LPCOMMCONFIG = [*c]struct__COMMCONFIG;
pub const struct__MEMORYSTATUS = extern struct {
    dwLength: DWORD,
    dwMemoryLoad: DWORD,
    dwTotalPhys: SIZE_T,
    dwAvailPhys: SIZE_T,
    dwTotalPageFile: SIZE_T,
    dwAvailPageFile: SIZE_T,
    dwTotalVirtual: SIZE_T,
    dwAvailVirtual: SIZE_T,
};
pub const MEMORYSTATUS = struct__MEMORYSTATUS;
pub const LPMEMORYSTATUS = [*c]struct__MEMORYSTATUS;
pub const struct__JIT_DEBUG_INFO = extern struct {
    dwSize: DWORD,
    dwProcessorArchitecture: DWORD,
    dwThreadID: DWORD,
    dwReserved0: DWORD,
    lpExceptionAddress: ULONG64,
    lpExceptionRecord: ULONG64,
    lpContextRecord: ULONG64,
};
pub const JIT_DEBUG_INFO = struct__JIT_DEBUG_INFO;
pub const LPJIT_DEBUG_INFO = [*c]struct__JIT_DEBUG_INFO;
pub const JIT_DEBUG_INFO32 = JIT_DEBUG_INFO;
pub const LPJIT_DEBUG_INFO32 = [*c]JIT_DEBUG_INFO;
pub const JIT_DEBUG_INFO64 = JIT_DEBUG_INFO;
pub const LPJIT_DEBUG_INFO64 = [*c]JIT_DEBUG_INFO;
pub const LPEXCEPTION_RECORD = PEXCEPTION_RECORD;
pub const LPEXCEPTION_POINTERS = PEXCEPTION_POINTERS;
pub const struct__OFSTRUCT = extern struct {
    cBytes: BYTE,
    fFixedDisk: BYTE,
    nErrCode: WORD,
    Reserved1: WORD,
    Reserved2: WORD,
    szPathName: [128]CHAR,
};
pub const OFSTRUCT = struct__OFSTRUCT;
pub const LPOFSTRUCT = [*c]struct__OFSTRUCT;
pub const POFSTRUCT = [*c]struct__OFSTRUCT;
pub extern fn WinMain(hInstance: HINSTANCE, hPrevInstance: HINSTANCE, lpCmdLine: LPSTR, nShowCmd: c_int) c_int;
pub extern fn wWinMain(hInstance: HINSTANCE, hPrevInstance: HINSTANCE, lpCmdLine: LPWSTR, nShowCmd: c_int) c_int;
pub extern "kernel32" fn GlobalAlloc(uFlags: UINT, dwBytes: SIZE_T) callconv(.Stdcall) HGLOBAL;
pub extern "kernel32" fn GlobalReAlloc(hMem: HGLOBAL, dwBytes: SIZE_T, uFlags: UINT) callconv(.Stdcall) HGLOBAL;
pub extern "kernel32" fn GlobalSize(hMem: HGLOBAL) callconv(.Stdcall) SIZE_T;
pub extern "kernel32" fn GlobalUnlock(hMem: HGLOBAL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GlobalLock(hMem: HGLOBAL) callconv(.Stdcall) LPVOID;
pub extern "kernel32" fn GlobalFlags(hMem: HGLOBAL) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GlobalHandle(pMem: LPCVOID) callconv(.Stdcall) HGLOBAL;
pub extern "kernel32" fn GlobalFree(hMem: HGLOBAL) callconv(.Stdcall) HGLOBAL;
pub extern "kernel32" fn GlobalCompact(dwMinFree: DWORD) callconv(.Stdcall) SIZE_T;
pub extern "kernel32" fn GlobalFix(hMem: HGLOBAL) callconv(.Stdcall) void;
pub extern "kernel32" fn GlobalUnfix(hMem: HGLOBAL) callconv(.Stdcall) void;
pub extern "kernel32" fn GlobalWire(hMem: HGLOBAL) callconv(.Stdcall) LPVOID;
pub extern "kernel32" fn GlobalUnWire(hMem: HGLOBAL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GlobalMemoryStatus(lpBuffer: LPMEMORYSTATUS) callconv(.Stdcall) void;
pub extern "kernel32" fn LocalAlloc(uFlags: UINT, uBytes: SIZE_T) callconv(.Stdcall) HLOCAL;
pub extern "kernel32" fn LocalReAlloc(hMem: HLOCAL, uBytes: SIZE_T, uFlags: UINT) callconv(.Stdcall) HLOCAL;
pub extern "kernel32" fn LocalLock(hMem: HLOCAL) callconv(.Stdcall) LPVOID;
pub extern "kernel32" fn LocalHandle(pMem: LPCVOID) callconv(.Stdcall) HLOCAL;
pub extern "kernel32" fn LocalUnlock(hMem: HLOCAL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn LocalSize(hMem: HLOCAL) callconv(.Stdcall) SIZE_T;
pub extern "kernel32" fn LocalFlags(hMem: HLOCAL) callconv(.Stdcall) UINT;
pub extern "kernel32" fn LocalFree(hMem: HLOCAL) callconv(.Stdcall) HLOCAL;
pub extern "kernel32" fn LocalShrink(hMem: HLOCAL, cbNewSize: UINT) callconv(.Stdcall) SIZE_T;
pub extern "kernel32" fn LocalCompact(uMinFree: UINT) callconv(.Stdcall) SIZE_T;
pub extern "kernel32" fn GetBinaryTypeA(lpApplicationName: LPCSTR, lpBinaryType: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetBinaryTypeW(lpApplicationName: LPCWSTR, lpBinaryType: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetShortPathNameA(lpszLongPath: LPCSTR, lpszShortPath: LPSTR, cchBuffer: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetLongPathNameTransactedA(lpszShortPath: LPCSTR, lpszLongPath: LPSTR, cchBuffer: DWORD, hTransaction: HANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetLongPathNameTransactedW(lpszShortPath: LPCWSTR, lpszLongPath: LPWSTR, cchBuffer: DWORD, hTransaction: HANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetProcessAffinityMask(hProcess: HANDLE, lpProcessAffinityMask: PDWORD_PTR, lpSystemAffinityMask: PDWORD_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetProcessAffinityMask(hProcess: HANDLE, dwProcessAffinityMask: DWORD_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetProcessIoCounters(hProcess: HANDLE, lpIoCounters: PIO_COUNTERS) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetProcessWorkingSetSize(hProcess: HANDLE, lpMinimumWorkingSetSize: PSIZE_T, lpMaximumWorkingSetSize: PSIZE_T) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetProcessWorkingSetSize(hProcess: HANDLE, dwMinimumWorkingSetSize: SIZE_T, dwMaximumWorkingSetSize: SIZE_T) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FatalExit(ExitCode: c_int) callconv(.Stdcall) void;
pub extern "kernel32" fn SetEnvironmentStringsA(NewEnvironment: LPCH) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SwitchToFiber(lpFiber: LPVOID) callconv(.Stdcall) void;
pub extern "kernel32" fn DeleteFiber(lpFiber: LPVOID) callconv(.Stdcall) void;
pub extern "kernel32" fn ConvertFiberToThread() callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateFiberEx(dwStackCommitSize: SIZE_T, dwStackReserveSize: SIZE_T, dwFlags: DWORD, lpStartAddress: LPFIBER_START_ROUTINE, lpParameter: LPVOID) callconv(.Stdcall) LPVOID;
pub extern "kernel32" fn ConvertThreadToFiberEx(lpParameter: LPVOID, dwFlags: DWORD) callconv(.Stdcall) LPVOID;
pub extern "kernel32" fn CreateFiber(dwStackSize: SIZE_T, lpStartAddress: LPFIBER_START_ROUTINE, lpParameter: LPVOID) callconv(.Stdcall) LPVOID;
pub extern "kernel32" fn ConvertThreadToFiber(lpParameter: LPVOID) callconv(.Stdcall) LPVOID;
pub const PUMS_CONTEXT = ?*c_void;
pub const PUMS_COMPLETION_LIST = ?*c_void;
pub const UMS_THREAD_INFO_CLASS = enum__RTL_UMS_THREAD_INFO_CLASS;
pub const PUMS_THREAD_INFO_CLASS = [*c]enum__RTL_UMS_THREAD_INFO_CLASS;
pub const UMS_SCHEDULER_REASON = enum__RTL_UMS_SCHEDULER_REASON;
pub const PUMS_SCHEDULER_ENTRY_POINT = PRTL_UMS_SCHEDULER_ENTRY_POINT;
pub const struct__UMS_SCHEDULER_STARTUP_INFO = extern struct {
    UmsVersion: ULONG,
    CompletionList: PUMS_COMPLETION_LIST,
    SchedulerProc: PUMS_SCHEDULER_ENTRY_POINT,
    SchedulerParam: PVOID,
};
pub const UMS_SCHEDULER_STARTUP_INFO = struct__UMS_SCHEDULER_STARTUP_INFO;
pub const PUMS_SCHEDULER_STARTUP_INFO = [*c]struct__UMS_SCHEDULER_STARTUP_INFO;
pub const struct__UMS_SYSTEM_THREAD_INFORMATION = extern struct {
    UmsVersion: ULONG,
    @"": extern union {
        @"": @OpaqueType(),
        ThreadUmsFlags: ULONG,
    },
};
pub const UMS_SYSTEM_THREAD_INFORMATION = struct__UMS_SYSTEM_THREAD_INFORMATION;
pub const PUMS_SYSTEM_THREAD_INFORMATION = [*c]struct__UMS_SYSTEM_THREAD_INFORMATION;
pub extern "kernel32" fn CreateUmsCompletionList(UmsCompletionList: [*c]PUMS_COMPLETION_LIST) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DequeueUmsCompletionListItems(UmsCompletionList: PUMS_COMPLETION_LIST, WaitTimeOut: DWORD, UmsThreadList: [*c]PUMS_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetUmsCompletionListEvent(UmsCompletionList: PUMS_COMPLETION_LIST, UmsCompletionEvent: PHANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ExecuteUmsThread(UmsThread: PUMS_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn UmsThreadYield(SchedulerParam: PVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeleteUmsCompletionList(UmsCompletionList: PUMS_COMPLETION_LIST) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCurrentUmsThread() callconv(.Stdcall) PUMS_CONTEXT;
pub extern "kernel32" fn GetNextUmsListItem(UmsContext: PUMS_CONTEXT) callconv(.Stdcall) PUMS_CONTEXT;
pub extern "kernel32" fn QueryUmsThreadInformation(UmsThread: PUMS_CONTEXT, UmsThreadInfoClass: UMS_THREAD_INFO_CLASS, UmsThreadInformation: PVOID, UmsThreadInformationLength: ULONG, ReturnLength: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetUmsThreadInformation(UmsThread: PUMS_CONTEXT, UmsThreadInfoClass: UMS_THREAD_INFO_CLASS, UmsThreadInformation: PVOID, UmsThreadInformationLength: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeleteUmsThreadContext(UmsThread: PUMS_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateUmsThreadContext(lpUmsThread: [*c]PUMS_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnterUmsSchedulingMode(SchedulerStartupInfo: PUMS_SCHEDULER_STARTUP_INFO) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetUmsSystemThreadInformation(ThreadHandle: HANDLE, SystemThreadInfo: PUMS_SYSTEM_THREAD_INFORMATION) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetThreadAffinityMask(hThread: HANDLE, dwThreadAffinityMask: DWORD_PTR) callconv(.Stdcall) DWORD_PTR;
pub extern "kernel32" fn SetProcessDEPPolicy(dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetProcessDEPPolicy(hProcess: HANDLE, lpFlags: LPDWORD, lpPermanent: PBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn RequestWakeupLatency(latency: LATENCY_TIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsSystemResumeAutomatic() callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetThreadSelectorEntry(hThread: HANDLE, dwSelector: DWORD, lpSelectorEntry: LPLDT_ENTRY) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetThreadExecutionState(esFlags: EXECUTION_STATE) callconv(.Stdcall) EXECUTION_STATE;
pub const POWER_REQUEST_CONTEXT = REASON_CONTEXT;
pub const PPOWER_REQUEST_CONTEXT = [*c]REASON_CONTEXT;
pub const LPPOWER_REQUEST_CONTEXT = [*c]REASON_CONTEXT;
pub extern "kernel32" fn PowerCreateRequest(Context: PREASON_CONTEXT) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn PowerSetRequest(PowerRequest: HANDLE, RequestType: POWER_REQUEST_TYPE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn PowerClearRequest(PowerRequest: HANDLE, RequestType: POWER_REQUEST_TYPE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetFileCompletionNotificationModes(FileHandle: HANDLE, Flags: UCHAR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn Wow64GetThreadContext(hThread: HANDLE, lpContext: PWOW64_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn Wow64SetThreadContext(hThread: HANDLE, lpContext: [*c]const WOW64_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn Wow64GetThreadSelectorEntry(hThread: HANDLE, dwSelector: DWORD, lpSelectorEntry: PWOW64_LDT_ENTRY) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn Wow64SuspendThread(hThread: HANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn DebugSetProcessKillOnExit(KillOnExit: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DebugBreakProcess(Process: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn PulseEvent(hEvent: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GlobalDeleteAtom(nAtom: ATOM) callconv(.Stdcall) ATOM;
pub extern "kernel32" fn InitAtomTable(nSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeleteAtom(nAtom: ATOM) callconv(.Stdcall) ATOM;
pub extern "kernel32" fn SetHandleCount(uNumber: UINT) callconv(.Stdcall) UINT;
pub extern "kernel32" fn RequestDeviceWakeup(hDevice: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CancelDeviceWakeupRequest(hDevice: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetDevicePowerState(hDevice: HANDLE, pfOn: [*c]BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetMessageWaitingIndicator(hMsgIndicator: HANDLE, ulMsgCount: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetFileShortNameA(hFile: HANDLE, lpShortName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetFileShortNameW(hFile: HANDLE, lpShortName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn LoadModule(lpModuleName: LPCSTR, lpParameterBlock: LPVOID) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn WinExec(lpCmdLine: LPCSTR, uCmdShow: UINT) callconv(.Stdcall) UINT;
pub extern "kernel32" fn ClearCommBreak(hFile: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ClearCommError(hFile: HANDLE, lpErrors: LPDWORD, lpStat: LPCOMSTAT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetupComm(hFile: HANDLE, dwInQueue: DWORD, dwOutQueue: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EscapeCommFunction(hFile: HANDLE, dwFunc: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCommConfig(hCommDev: HANDLE, lpCC: LPCOMMCONFIG, lpdwSize: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCommMask(hFile: HANDLE, lpEvtMask: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCommProperties(hFile: HANDLE, lpCommProp: LPCOMMPROP) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCommModemStatus(hFile: HANDLE, lpModemStat: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCommState(hFile: HANDLE, lpDCB: LPDCB) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCommTimeouts(hFile: HANDLE, lpCommTimeouts: LPCOMMTIMEOUTS) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn PurgeComm(hFile: HANDLE, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetCommBreak(hFile: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetCommConfig(hCommDev: HANDLE, lpCC: LPCOMMCONFIG, dwSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetCommMask(hFile: HANDLE, dwEvtMask: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetCommState(hFile: HANDLE, lpDCB: LPDCB) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetCommTimeouts(hFile: HANDLE, lpCommTimeouts: LPCOMMTIMEOUTS) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn TransmitCommChar(hFile: HANDLE, cChar: u8) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WaitCommEvent(hFile: HANDLE, lpEvtMask: LPDWORD, lpOverlapped: LPOVERLAPPED) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn OpenCommPort(uPortNumber: ULONG, dwDesiredAccess: DWORD, dwFlagsAndAttributes: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn GetCommPorts(lpPortNumbers: PULONG, uPortNumbersCount: ULONG, puPortNumbersFound: PULONG) callconv(.Stdcall) ULONG;
pub extern "kernel32" fn SetTapePosition(hDevice: HANDLE, dwPositionMethod: DWORD, dwPartition: DWORD, dwOffsetLow: DWORD, dwOffsetHigh: DWORD, bImmediate: BOOL) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetTapePosition(hDevice: HANDLE, dwPositionType: DWORD, lpdwPartition: LPDWORD, lpdwOffsetLow: LPDWORD, lpdwOffsetHigh: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn PrepareTape(hDevice: HANDLE, dwOperation: DWORD, bImmediate: BOOL) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn EraseTape(hDevice: HANDLE, dwEraseType: DWORD, bImmediate: BOOL) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn CreateTapePartition(hDevice: HANDLE, dwPartitionMethod: DWORD, dwCount: DWORD, dwSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn WriteTapemark(hDevice: HANDLE, dwTapemarkType: DWORD, dwTapemarkCount: DWORD, bImmediate: BOOL) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetTapeStatus(hDevice: HANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetTapeParameters(hDevice: HANDLE, dwOperation: DWORD, lpdwSize: LPDWORD, lpTapeInformation: LPVOID) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SetTapeParameters(hDevice: HANDLE, dwOperation: DWORD, lpTapeInformation: LPVOID) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn MulDiv(nNumber: c_int, nNumerator: c_int, nDenominator: c_int) callconv(.Stdcall) c_int;
pub const DEPPolicyAlwaysOff = enum__DEP_SYSTEM_POLICY_TYPE.DEPPolicyAlwaysOff;
pub const DEPPolicyAlwaysOn = enum__DEP_SYSTEM_POLICY_TYPE.DEPPolicyAlwaysOn;
pub const DEPPolicyOptIn = enum__DEP_SYSTEM_POLICY_TYPE.DEPPolicyOptIn;
pub const DEPPolicyOptOut = enum__DEP_SYSTEM_POLICY_TYPE.DEPPolicyOptOut;
pub const DEPTotalPolicyCount = enum__DEP_SYSTEM_POLICY_TYPE.DEPTotalPolicyCount;
pub const enum__DEP_SYSTEM_POLICY_TYPE = extern enum {
    DEPPolicyAlwaysOff = 0,
    DEPPolicyAlwaysOn = 1,
    DEPPolicyOptIn = 2,
    DEPPolicyOptOut = 3,
    DEPTotalPolicyCount = 4,
};
pub const DEP_SYSTEM_POLICY_TYPE = enum__DEP_SYSTEM_POLICY_TYPE;
pub extern "kernel32" fn GetSystemDEPPolicy() callconv(.Stdcall) DEP_SYSTEM_POLICY_TYPE;
pub extern "kernel32" fn GetSystemRegistryQuota(pdwQuotaAllowed: PDWORD, pdwQuotaUsed: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FileTimeToDosDateTime(lpFileTime: [*c]const FILETIME, lpFatDate: LPWORD, lpFatTime: LPWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DosDateTimeToFileTime(wFatDate: WORD, wFatTime: WORD, lpFileTime: LPFILETIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FormatMessageA(dwFlags: DWORD, lpSource: LPCVOID, dwMessageId: DWORD, dwLanguageId: DWORD, lpBuffer: LPSTR, nSize: DWORD, Arguments: [*c]va_list) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn FormatMessageW(dwFlags: DWORD, lpSource: LPCVOID, dwMessageId: DWORD, dwLanguageId: DWORD, lpBuffer: LPWSTR, nSize: DWORD, Arguments: [*c]va_list) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn CreateMailslotA(lpName: LPCSTR, nMaxMessageSize: DWORD, lReadTimeout: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateMailslotW(lpName: LPCWSTR, nMaxMessageSize: DWORD, lReadTimeout: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn GetMailslotInfo(hMailslot: HANDLE, lpMaxMessageSize: LPDWORD, lpNextSize: LPDWORD, lpMessageCount: LPDWORD, lpReadTimeout: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetMailslotInfo(hMailslot: HANDLE, lReadTimeout: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn EncryptFileA(lpFileName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn EncryptFileW(lpFileName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn DecryptFileA(lpFileName: LPCSTR, dwReserved: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn DecryptFileW(lpFileName: LPCWSTR, dwReserved: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn FileEncryptionStatusA(lpFileName: LPCSTR, lpStatus: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn FileEncryptionStatusW(lpFileName: LPCWSTR, lpStatus: LPDWORD) callconv(.Stdcall) BOOL;
pub const PFE_EXPORT_FUNC = ?fn (PBYTE, PVOID, ULONG) callconv(.C) DWORD;
pub const PFE_IMPORT_FUNC = ?fn (PBYTE, PVOID, PULONG) callconv(.C) DWORD;
pub extern "advapi32" fn OpenEncryptedFileRawA(lpFileName: LPCSTR, ulFlags: ULONG, pvContext: [*c]PVOID) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn OpenEncryptedFileRawW(lpFileName: LPCWSTR, ulFlags: ULONG, pvContext: [*c]PVOID) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn ReadEncryptedFileRaw(pfExportCallback: PFE_EXPORT_FUNC, pvCallbackContext: PVOID, pvContext: PVOID) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn WriteEncryptedFileRaw(pfImportCallback: PFE_IMPORT_FUNC, pvCallbackContext: PVOID, pvContext: PVOID) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn CloseEncryptedFileRaw(pvContext: PVOID) callconv(.Stdcall) void;
pub extern "kernel32" fn lstrcmpA(lpString1: LPCSTR, lpString2: LPCSTR) callconv(.Stdcall) c_int;
pub extern "kernel32" fn lstrcmpW(lpString1: LPCWSTR, lpString2: LPCWSTR) callconv(.Stdcall) c_int;
pub extern "kernel32" fn lstrcmpiA(lpString1: LPCSTR, lpString2: LPCSTR) callconv(.Stdcall) c_int;
pub extern "kernel32" fn lstrcmpiW(lpString1: LPCWSTR, lpString2: LPCWSTR) callconv(.Stdcall) c_int;
pub extern "kernel32" fn lstrcpynA(lpString1: LPSTR, lpString2: LPCSTR, iMaxLength: c_int) callconv(.Stdcall) LPSTR;
pub extern "kernel32" fn lstrcpynW(lpString1: LPWSTR, lpString2: LPCWSTR, iMaxLength: c_int) callconv(.Stdcall) LPWSTR;
pub extern "kernel32" fn lstrcpyA(lpString1: LPSTR, lpString2: LPCSTR) callconv(.Stdcall) LPSTR;
pub extern "kernel32" fn lstrcpyW(lpString1: LPWSTR, lpString2: LPCWSTR) callconv(.Stdcall) LPWSTR;
pub extern "kernel32" fn lstrcatA(lpString1: LPSTR, lpString2: LPCSTR) callconv(.Stdcall) LPSTR;
pub extern "kernel32" fn lstrcatW(lpString1: LPWSTR, lpString2: LPCWSTR) callconv(.Stdcall) LPWSTR;
pub extern "kernel32" fn lstrlenA(lpString: LPCSTR) callconv(.Stdcall) c_int;
pub extern "kernel32" fn lstrlenW(lpString: LPCWSTR) callconv(.Stdcall) c_int;
pub extern "kernel32" fn OpenFile(lpFileName: LPCSTR, lpReOpenBuff: LPOFSTRUCT, uStyle: UINT) callconv(.Stdcall) HFILE;
pub extern "kernel32" fn _lopen(lpPathName: LPCSTR, iReadWrite: c_int) callconv(.Stdcall) HFILE;
pub extern "kernel32" fn _lcreat(lpPathName: LPCSTR, iAttribute: c_int) callconv(.Stdcall) HFILE;
pub extern "kernel32" fn _lread(hFile: HFILE, lpBuffer: LPVOID, uBytes: UINT) callconv(.Stdcall) UINT;
pub extern "kernel32" fn _lwrite(hFile: HFILE, lpBuffer: LPCCH, uBytes: UINT) callconv(.Stdcall) UINT;
pub extern "kernel32" fn _hread(hFile: HFILE, lpBuffer: LPVOID, lBytes: c_long) callconv(.Stdcall) c_long;
pub extern "kernel32" fn _hwrite(hFile: HFILE, lpBuffer: LPCCH, lBytes: c_long) callconv(.Stdcall) c_long;
pub extern "kernel32" fn _lclose(hFile: HFILE) callconv(.Stdcall) HFILE;
pub extern "kernel32" fn _llseek(hFile: HFILE, lOffset: LONG, iOrigin: c_int) callconv(.Stdcall) LONG;
pub extern "kernel32" fn IsTextUnicode(lpv: ?*const c_void, iSize: c_int, lpiResult: LPINT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn BackupRead(hFile: HANDLE, lpBuffer: LPBYTE, nNumberOfBytesToRead: DWORD, lpNumberOfBytesRead: LPDWORD, bAbort: BOOL, bProcessSecurity: BOOL, lpContext: [*c]LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn BackupSeek(hFile: HANDLE, dwLowBytesToSeek: DWORD, dwHighBytesToSeek: DWORD, lpdwLowByteSeeked: LPDWORD, lpdwHighByteSeeked: LPDWORD, lpContext: [*c]LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn BackupWrite(hFile: HANDLE, lpBuffer: LPBYTE, nNumberOfBytesToWrite: DWORD, lpNumberOfBytesWritten: LPDWORD, bAbort: BOOL, bProcessSecurity: BOOL, lpContext: [*c]LPVOID) callconv(.Stdcall) BOOL;
pub const struct__WIN32_STREAM_ID = extern struct {
    dwStreamId: DWORD,
    dwStreamAttributes: DWORD,
    Size: LARGE_INTEGER,
    dwStreamNameSize: DWORD,
    cStreamName: [1]WCHAR,
};
pub const WIN32_STREAM_ID = struct__WIN32_STREAM_ID;
pub const LPWIN32_STREAM_ID = [*c]struct__WIN32_STREAM_ID;
pub const struct__STARTUPINFOEXA = extern struct {
    StartupInfo: STARTUPINFOA,
    lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
};
pub const STARTUPINFOEXA = struct__STARTUPINFOEXA;
pub const LPSTARTUPINFOEXA = [*c]struct__STARTUPINFOEXA;
pub const struct__STARTUPINFOEXW = extern struct {
    StartupInfo: STARTUPINFOW,
    lpAttributeList: LPPROC_THREAD_ATTRIBUTE_LIST,
};
pub const STARTUPINFOEXW = struct__STARTUPINFOEXW;
pub const LPSTARTUPINFOEXW = [*c]struct__STARTUPINFOEXW;
pub const STARTUPINFOEX = STARTUPINFOEXA;
pub const LPSTARTUPINFOEX = LPSTARTUPINFOEXA;
pub extern "onecore" fn OpenMutexA(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "onecore" fn CreateSemaphoreA(lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES, lInitialCount: LONG, lMaximumCount: LONG, lpName: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "onecore" fn OpenSemaphoreA(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "onecore" fn CreateWaitableTimerA(lpTimerAttributes: LPSECURITY_ATTRIBUTES, bManualReset: BOOL, lpTimerName: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "onecore" fn OpenWaitableTimerA(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpTimerName: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "onecore" fn CreateSemaphoreExA(lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES, lInitialCount: LONG, lMaximumCount: LONG, lpName: LPCSTR, dwFlags: DWORD, dwDesiredAccess: DWORD) callconv(.Stdcall) HANDLE;
pub extern "onecore" fn CreateWaitableTimerExA(lpTimerAttributes: LPSECURITY_ATTRIBUTES, lpTimerName: LPCSTR, dwFlags: DWORD, dwDesiredAccess: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateFileMappingA(hFile: HANDLE, lpFileMappingAttributes: LPSECURITY_ATTRIBUTES, flProtect: DWORD, dwMaximumSizeHigh: DWORD, dwMaximumSizeLow: DWORD, lpName: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateFileMappingNumaA(hFile: HANDLE, lpFileMappingAttributes: LPSECURITY_ATTRIBUTES, flProtect: DWORD, dwMaximumSizeHigh: DWORD, dwMaximumSizeLow: DWORD, lpName: LPCSTR, nndPreferred: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn OpenFileMappingA(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn GetLogicalDriveStringsA(nBufferLength: DWORD, lpBuffer: LPSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn LoadPackagedLibrary(lpwLibFileName: LPCWSTR, Reserved: DWORD) callconv(.Stdcall) HMODULE;
pub extern "kernel32" fn QueryFullProcessImageNameA(hProcess: HANDLE, dwFlags: DWORD, lpExeName: LPSTR, lpdwSize: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn QueryFullProcessImageNameW(hProcess: HANDLE, dwFlags: DWORD, lpExeName: LPWSTR, lpdwSize: PDWORD) callconv(.Stdcall) BOOL;
pub const ProcThreadAttributeParentProcess = enum__PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeParentProcess;
pub const ProcThreadAttributeHandleList = enum__PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeHandleList;
pub const ProcThreadAttributeGroupAffinity = enum__PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeGroupAffinity;
pub const ProcThreadAttributePreferredNode = enum__PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributePreferredNode;
pub const ProcThreadAttributeIdealProcessor = enum__PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeIdealProcessor;
pub const ProcThreadAttributeUmsThread = enum__PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeUmsThread;
pub const ProcThreadAttributeMitigationPolicy = enum__PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeMitigationPolicy;
pub const ProcThreadAttributeSecurityCapabilities = enum__PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeSecurityCapabilities;
pub const ProcThreadAttributeProtectionLevel = enum__PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeProtectionLevel;
pub const ProcThreadAttributeJobList = enum__PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeJobList;
pub const ProcThreadAttributeChildProcessPolicy = enum__PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeChildProcessPolicy;
pub const ProcThreadAttributeAllApplicationPackagesPolicy = enum__PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeAllApplicationPackagesPolicy;
pub const ProcThreadAttributeWin32kFilter = enum__PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeWin32kFilter;
pub const ProcThreadAttributeSafeOpenPromptOriginClaim = enum__PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeSafeOpenPromptOriginClaim;
pub const ProcThreadAttributeDesktopAppPolicy = enum__PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeDesktopAppPolicy;
pub const ProcThreadAttributePseudoConsole = enum__PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributePseudoConsole;
pub const enum__PROC_THREAD_ATTRIBUTE_NUM = extern enum {
    ProcThreadAttributeParentProcess = 0,
    ProcThreadAttributeHandleList = 2,
    ProcThreadAttributeGroupAffinity = 3,
    ProcThreadAttributePreferredNode = 4,
    ProcThreadAttributeIdealProcessor = 5,
    ProcThreadAttributeUmsThread = 6,
    ProcThreadAttributeMitigationPolicy = 7,
    ProcThreadAttributeSecurityCapabilities = 9,
    ProcThreadAttributeProtectionLevel = 11,
    ProcThreadAttributeJobList = 13,
    ProcThreadAttributeChildProcessPolicy = 14,
    ProcThreadAttributeAllApplicationPackagesPolicy = 15,
    ProcThreadAttributeWin32kFilter = 16,
    ProcThreadAttributeSafeOpenPromptOriginClaim = 17,
    ProcThreadAttributeDesktopAppPolicy = 18,
    ProcThreadAttributePseudoConsole = 22,
};
pub const PROC_THREAD_ATTRIBUTE_NUM = enum__PROC_THREAD_ATTRIBUTE_NUM;
pub extern "kernel32" fn GetStartupInfoA(lpStartupInfo: LPSTARTUPINFOA) callconv(.Stdcall) void;
pub extern "kernel32" fn GetFirmwareEnvironmentVariableA(lpName: LPCSTR, lpGuid: LPCSTR, pBuffer: PVOID, nSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetFirmwareEnvironmentVariableW(lpName: LPCWSTR, lpGuid: LPCWSTR, pBuffer: PVOID, nSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetFirmwareEnvironmentVariableExA(lpName: LPCSTR, lpGuid: LPCSTR, pBuffer: PVOID, nSize: DWORD, pdwAttribubutes: PDWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetFirmwareEnvironmentVariableExW(lpName: LPCWSTR, lpGuid: LPCWSTR, pBuffer: PVOID, nSize: DWORD, pdwAttribubutes: PDWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SetFirmwareEnvironmentVariableA(lpName: LPCSTR, lpGuid: LPCSTR, pValue: PVOID, nSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetFirmwareEnvironmentVariableW(lpName: LPCWSTR, lpGuid: LPCWSTR, pValue: PVOID, nSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetFirmwareEnvironmentVariableExA(lpName: LPCSTR, lpGuid: LPCSTR, pValue: PVOID, nSize: DWORD, dwAttributes: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetFirmwareEnvironmentVariableExW(lpName: LPCWSTR, lpGuid: LPCWSTR, pValue: PVOID, nSize: DWORD, dwAttributes: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetFirmwareType(FirmwareType: PFIRMWARE_TYPE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsNativeVhdBoot(NativeVhdBoot: PBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindResourceA(hModule: HMODULE, lpName: LPCSTR, lpType: LPCSTR) callconv(.Stdcall) HRSRC;
pub extern "kernel32" fn FindResourceExA(hModule: HMODULE, lpType: LPCSTR, lpName: LPCSTR, wLanguage: WORD) callconv(.Stdcall) HRSRC;
pub extern "kernel32" fn EnumResourceTypesA(hModule: HMODULE, lpEnumFunc: ENUMRESTYPEPROCA, lParam: LONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumResourceTypesW(hModule: HMODULE, lpEnumFunc: ENUMRESTYPEPROCW, lParam: LONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumResourceNamesA(hModule: HMODULE, lpType: LPCSTR, lpEnumFunc: ENUMRESNAMEPROCA, lParam: LONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumResourceLanguagesA(hModule: HMODULE, lpType: LPCSTR, lpName: LPCSTR, lpEnumFunc: ENUMRESLANGPROCA, lParam: LONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumResourceLanguagesW(hModule: HMODULE, lpType: LPCWSTR, lpName: LPCWSTR, lpEnumFunc: ENUMRESLANGPROCW, lParam: LONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn BeginUpdateResourceA(pFileName: LPCSTR, bDeleteExistingResources: BOOL) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn BeginUpdateResourceW(pFileName: LPCWSTR, bDeleteExistingResources: BOOL) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn UpdateResourceA(hUpdate: HANDLE, lpType: LPCSTR, lpName: LPCSTR, wLanguage: WORD, lpData: LPVOID, cb: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn UpdateResourceW(hUpdate: HANDLE, lpType: LPCWSTR, lpName: LPCWSTR, wLanguage: WORD, lpData: LPVOID, cb: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EndUpdateResourceA(hUpdate: HANDLE, fDiscard: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EndUpdateResourceW(hUpdate: HANDLE, fDiscard: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GlobalAddAtomA(lpString: LPCSTR) callconv(.Stdcall) ATOM;
pub extern "kernel32" fn GlobalAddAtomW(lpString: LPCWSTR) callconv(.Stdcall) ATOM;
pub extern "kernel32" fn GlobalAddAtomExA(lpString: LPCSTR, Flags: DWORD) callconv(.Stdcall) ATOM;
pub extern "kernel32" fn GlobalAddAtomExW(lpString: LPCWSTR, Flags: DWORD) callconv(.Stdcall) ATOM;
pub extern "kernel32" fn GlobalFindAtomA(lpString: LPCSTR) callconv(.Stdcall) ATOM;
pub extern "kernel32" fn GlobalFindAtomW(lpString: LPCWSTR) callconv(.Stdcall) ATOM;
pub extern "kernel32" fn GlobalGetAtomNameA(nAtom: ATOM, lpBuffer: LPSTR, nSize: c_int) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GlobalGetAtomNameW(nAtom: ATOM, lpBuffer: LPWSTR, nSize: c_int) callconv(.Stdcall) UINT;
pub extern "kernel32" fn AddAtomA(lpString: LPCSTR) callconv(.Stdcall) ATOM;
pub extern "kernel32" fn AddAtomW(lpString: LPCWSTR) callconv(.Stdcall) ATOM;
pub extern "kernel32" fn FindAtomA(lpString: LPCSTR) callconv(.Stdcall) ATOM;
pub extern "kernel32" fn FindAtomW(lpString: LPCWSTR) callconv(.Stdcall) ATOM;
pub extern "kernel32" fn GetAtomNameA(nAtom: ATOM, lpBuffer: LPSTR, nSize: c_int) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetAtomNameW(nAtom: ATOM, lpBuffer: LPWSTR, nSize: c_int) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetProfileIntA(lpAppName: LPCSTR, lpKeyName: LPCSTR, nDefault: INT) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetProfileIntW(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, nDefault: INT) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetProfileStringA(lpAppName: LPCSTR, lpKeyName: LPCSTR, lpDefault: LPCSTR, lpReturnedString: LPSTR, nSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetProfileStringW(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, lpDefault: LPCWSTR, lpReturnedString: LPWSTR, nSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn WriteProfileStringA(lpAppName: LPCSTR, lpKeyName: LPCSTR, lpString: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WriteProfileStringW(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, lpString: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetProfileSectionA(lpAppName: LPCSTR, lpReturnedString: LPSTR, nSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetProfileSectionW(lpAppName: LPCWSTR, lpReturnedString: LPWSTR, nSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn WriteProfileSectionA(lpAppName: LPCSTR, lpString: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WriteProfileSectionW(lpAppName: LPCWSTR, lpString: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetPrivateProfileIntA(lpAppName: LPCSTR, lpKeyName: LPCSTR, nDefault: INT, lpFileName: LPCSTR) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetPrivateProfileIntW(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, nDefault: INT, lpFileName: LPCWSTR) callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetPrivateProfileStringA(lpAppName: LPCSTR, lpKeyName: LPCSTR, lpDefault: LPCSTR, lpReturnedString: LPSTR, nSize: DWORD, lpFileName: LPCSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetPrivateProfileStringW(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, lpDefault: LPCWSTR, lpReturnedString: LPWSTR, nSize: DWORD, lpFileName: LPCWSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn WritePrivateProfileStringA(lpAppName: LPCSTR, lpKeyName: LPCSTR, lpString: LPCSTR, lpFileName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WritePrivateProfileStringW(lpAppName: LPCWSTR, lpKeyName: LPCWSTR, lpString: LPCWSTR, lpFileName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetPrivateProfileSectionA(lpAppName: LPCSTR, lpReturnedString: LPSTR, nSize: DWORD, lpFileName: LPCSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetPrivateProfileSectionW(lpAppName: LPCWSTR, lpReturnedString: LPWSTR, nSize: DWORD, lpFileName: LPCWSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn WritePrivateProfileSectionA(lpAppName: LPCSTR, lpString: LPCSTR, lpFileName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WritePrivateProfileSectionW(lpAppName: LPCWSTR, lpString: LPCWSTR, lpFileName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetPrivateProfileSectionNamesA(lpszReturnBuffer: LPSTR, nSize: DWORD, lpFileName: LPCSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetPrivateProfileSectionNamesW(lpszReturnBuffer: LPWSTR, nSize: DWORD, lpFileName: LPCWSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetPrivateProfileStructA(lpszSection: LPCSTR, lpszKey: LPCSTR, lpStruct: LPVOID, uSizeStruct: UINT, szFile: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetPrivateProfileStructW(lpszSection: LPCWSTR, lpszKey: LPCWSTR, lpStruct: LPVOID, uSizeStruct: UINT, szFile: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WritePrivateProfileStructA(lpszSection: LPCSTR, lpszKey: LPCSTR, lpStruct: LPVOID, uSizeStruct: UINT, szFile: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WritePrivateProfileStructW(lpszSection: LPCWSTR, lpszKey: LPCWSTR, lpStruct: LPVOID, uSizeStruct: UINT, szFile: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn Wow64EnableWow64FsRedirection(Wow64FsEnableRedirection: BOOLEAN) callconv(.Stdcall) BOOLEAN;
pub const PGET_SYSTEM_WOW64_DIRECTORY_A = ?fn (LPSTR, UINT) callconv(.C) UINT;
pub const PGET_SYSTEM_WOW64_DIRECTORY_W = ?fn (LPWSTR, UINT) callconv(.C) UINT;
pub extern "kernel32" fn SetDllDirectoryA(lpPathName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetDllDirectoryW(lpPathName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetDllDirectoryA(nBufferLength: DWORD, lpBuffer: LPSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetDllDirectoryW(nBufferLength: DWORD, lpBuffer: LPWSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SetSearchPathMode(Flags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateDirectoryExA(lpTemplateDirectory: LPCSTR, lpNewDirectory: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateDirectoryExW(lpTemplateDirectory: LPCWSTR, lpNewDirectory: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateDirectoryTransactedA(lpTemplateDirectory: LPCSTR, lpNewDirectory: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, hTransaction: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateDirectoryTransactedW(lpTemplateDirectory: LPCWSTR, lpNewDirectory: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, hTransaction: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn RemoveDirectoryTransactedA(lpPathName: LPCSTR, hTransaction: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn RemoveDirectoryTransactedW(lpPathName: LPCWSTR, hTransaction: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetFullPathNameTransactedA(lpFileName: LPCSTR, nBufferLength: DWORD, lpBuffer: LPSTR, lpFilePart: [*c]LPSTR, hTransaction: HANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetFullPathNameTransactedW(lpFileName: LPCWSTR, nBufferLength: DWORD, lpBuffer: LPWSTR, lpFilePart: [*c]LPWSTR, hTransaction: HANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn DefineDosDeviceA(dwFlags: DWORD, lpDeviceName: LPCSTR, lpTargetPath: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn QueryDosDeviceA(lpDeviceName: LPCSTR, lpTargetPath: LPSTR, ucchMax: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn CreateFileTransactedA(lpFileName: LPCSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD, dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE, hTransaction: HANDLE, pusMiniVersion: PUSHORT, lpExtendedParameter: PVOID) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateFileTransactedW(lpFileName: LPCWSTR, dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwCreationDisposition: DWORD, dwFlagsAndAttributes: DWORD, hTemplateFile: HANDLE, hTransaction: HANDLE, pusMiniVersion: PUSHORT, lpExtendedParameter: PVOID) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn ReOpenFile(hOriginalFile: HANDLE, dwDesiredAccess: DWORD, dwShareMode: DWORD, dwFlagsAndAttributes: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn SetFileAttributesTransactedA(lpFileName: LPCSTR, dwFileAttributes: DWORD, hTransaction: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetFileAttributesTransactedW(lpFileName: LPCWSTR, dwFileAttributes: DWORD, hTransaction: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetFileAttributesTransactedA(lpFileName: LPCSTR, fInfoLevelId: GET_FILEEX_INFO_LEVELS, lpFileInformation: LPVOID, hTransaction: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetFileAttributesTransactedW(lpFileName: LPCWSTR, fInfoLevelId: GET_FILEEX_INFO_LEVELS, lpFileInformation: LPVOID, hTransaction: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCompressedFileSizeTransactedA(lpFileName: LPCSTR, lpFileSizeHigh: LPDWORD, hTransaction: HANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetCompressedFileSizeTransactedW(lpFileName: LPCWSTR, lpFileSizeHigh: LPDWORD, hTransaction: HANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn DeleteFileTransactedA(lpFileName: LPCSTR, hTransaction: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeleteFileTransactedW(lpFileName: LPCWSTR, hTransaction: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CheckNameLegalDOS8Dot3A(lpName: LPCSTR, lpOemName: LPSTR, OemNameSize: DWORD, pbNameContainsSpaces: PBOOL, pbNameLegal: PBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CheckNameLegalDOS8Dot3W(lpName: LPCWSTR, lpOemName: LPSTR, OemNameSize: DWORD, pbNameContainsSpaces: PBOOL, pbNameLegal: PBOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindFirstFileTransactedA(lpFileName: LPCSTR, fInfoLevelId: FINDEX_INFO_LEVELS, lpFindFileData: LPVOID, fSearchOp: FINDEX_SEARCH_OPS, lpSearchFilter: LPVOID, dwAdditionalFlags: DWORD, hTransaction: HANDLE) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn FindFirstFileTransactedW(lpFileName: LPCWSTR, fInfoLevelId: FINDEX_INFO_LEVELS, lpFindFileData: LPVOID, fSearchOp: FINDEX_SEARCH_OPS, lpSearchFilter: LPVOID, dwAdditionalFlags: DWORD, hTransaction: HANDLE) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CopyFileA(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, bFailIfExists: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CopyFileW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, bFailIfExists: BOOL) callconv(.Stdcall) BOOL;
pub const LPPROGRESS_ROUTINE = ?fn (LARGE_INTEGER, LARGE_INTEGER, LARGE_INTEGER, LARGE_INTEGER, DWORD, DWORD, HANDLE, HANDLE, LPVOID) callconv(.C) DWORD;
pub extern "kernel32" fn CopyFileExA(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, pbCancel: LPBOOL, dwCopyFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CopyFileExW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, pbCancel: LPBOOL, dwCopyFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CopyFileTransactedA(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, pbCancel: LPBOOL, dwCopyFlags: DWORD, hTransaction: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CopyFileTransactedW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, pbCancel: LPBOOL, dwCopyFlags: DWORD, hTransaction: HANDLE) callconv(.Stdcall) BOOL;
pub const COPYFILE2_CALLBACK_NONE = enum__COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_NONE;
pub const COPYFILE2_CALLBACK_CHUNK_STARTED = enum__COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_CHUNK_STARTED;
pub const COPYFILE2_CALLBACK_CHUNK_FINISHED = enum__COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_CHUNK_FINISHED;
pub const COPYFILE2_CALLBACK_STREAM_STARTED = enum__COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_STREAM_STARTED;
pub const COPYFILE2_CALLBACK_STREAM_FINISHED = enum__COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_STREAM_FINISHED;
pub const COPYFILE2_CALLBACK_POLL_CONTINUE = enum__COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_POLL_CONTINUE;
pub const COPYFILE2_CALLBACK_ERROR = enum__COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_ERROR;
pub const COPYFILE2_CALLBACK_MAX = enum__COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_MAX;
pub const enum__COPYFILE2_MESSAGE_TYPE = extern enum {
    COPYFILE2_CALLBACK_NONE = 0,
    COPYFILE2_CALLBACK_CHUNK_STARTED = 1,
    COPYFILE2_CALLBACK_CHUNK_FINISHED = 2,
    COPYFILE2_CALLBACK_STREAM_STARTED = 3,
    COPYFILE2_CALLBACK_STREAM_FINISHED = 4,
    COPYFILE2_CALLBACK_POLL_CONTINUE = 5,
    COPYFILE2_CALLBACK_ERROR = 6,
    COPYFILE2_CALLBACK_MAX = 7,
};
pub const COPYFILE2_MESSAGE_TYPE = enum__COPYFILE2_MESSAGE_TYPE;
pub const COPYFILE2_PROGRESS_CONTINUE = enum__COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_CONTINUE;
pub const COPYFILE2_PROGRESS_CANCEL = enum__COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_CANCEL;
pub const COPYFILE2_PROGRESS_STOP = enum__COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_STOP;
pub const COPYFILE2_PROGRESS_QUIET = enum__COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_QUIET;
pub const COPYFILE2_PROGRESS_PAUSE = enum__COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_PAUSE;
pub const enum__COPYFILE2_MESSAGE_ACTION = extern enum {
    COPYFILE2_PROGRESS_CONTINUE = 0,
    COPYFILE2_PROGRESS_CANCEL = 1,
    COPYFILE2_PROGRESS_STOP = 2,
    COPYFILE2_PROGRESS_QUIET = 3,
    COPYFILE2_PROGRESS_PAUSE = 4,
};
pub const COPYFILE2_MESSAGE_ACTION = enum__COPYFILE2_MESSAGE_ACTION;
pub const COPYFILE2_PHASE_NONE = enum__COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_NONE;
pub const COPYFILE2_PHASE_PREPARE_SOURCE = enum__COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_PREPARE_SOURCE;
pub const COPYFILE2_PHASE_PREPARE_DEST = enum__COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_PREPARE_DEST;
pub const COPYFILE2_PHASE_READ_SOURCE = enum__COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_READ_SOURCE;
pub const COPYFILE2_PHASE_WRITE_DESTINATION = enum__COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_WRITE_DESTINATION;
pub const COPYFILE2_PHASE_SERVER_COPY = enum__COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_SERVER_COPY;
pub const COPYFILE2_PHASE_NAMEGRAFT_COPY = enum__COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_NAMEGRAFT_COPY;
pub const COPYFILE2_PHASE_MAX = enum__COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_MAX;
pub const enum__COPYFILE2_COPY_PHASE = extern enum {
    COPYFILE2_PHASE_NONE = 0,
    COPYFILE2_PHASE_PREPARE_SOURCE = 1,
    COPYFILE2_PHASE_PREPARE_DEST = 2,
    COPYFILE2_PHASE_READ_SOURCE = 3,
    COPYFILE2_PHASE_WRITE_DESTINATION = 4,
    COPYFILE2_PHASE_SERVER_COPY = 5,
    COPYFILE2_PHASE_NAMEGRAFT_COPY = 6,
    COPYFILE2_PHASE_MAX = 7,
};
pub const COPYFILE2_COPY_PHASE = enum__COPYFILE2_COPY_PHASE;
pub const struct_COPYFILE2_MESSAGE = extern struct {
    Type: COPYFILE2_MESSAGE_TYPE,
    dwPadding: DWORD,
    Info: extern union {
        ChunkStarted: extern struct {
            dwStreamNumber: DWORD,
            dwReserved: DWORD,
            hSourceFile: HANDLE,
            hDestinationFile: HANDLE,
            uliChunkNumber: ULARGE_INTEGER,
            uliChunkSize: ULARGE_INTEGER,
            uliStreamSize: ULARGE_INTEGER,
            uliTotalFileSize: ULARGE_INTEGER,
        },
        ChunkFinished: extern struct {
            dwStreamNumber: DWORD,
            dwFlags: DWORD,
            hSourceFile: HANDLE,
            hDestinationFile: HANDLE,
            uliChunkNumber: ULARGE_INTEGER,
            uliChunkSize: ULARGE_INTEGER,
            uliStreamSize: ULARGE_INTEGER,
            uliStreamBytesTransferred: ULARGE_INTEGER,
            uliTotalFileSize: ULARGE_INTEGER,
            uliTotalBytesTransferred: ULARGE_INTEGER,
        },
        StreamStarted: extern struct {
            dwStreamNumber: DWORD,
            dwReserved: DWORD,
            hSourceFile: HANDLE,
            hDestinationFile: HANDLE,
            uliStreamSize: ULARGE_INTEGER,
            uliTotalFileSize: ULARGE_INTEGER,
        },
        StreamFinished: extern struct {
            dwStreamNumber: DWORD,
            dwReserved: DWORD,
            hSourceFile: HANDLE,
            hDestinationFile: HANDLE,
            uliStreamSize: ULARGE_INTEGER,
            uliStreamBytesTransferred: ULARGE_INTEGER,
            uliTotalFileSize: ULARGE_INTEGER,
            uliTotalBytesTransferred: ULARGE_INTEGER,
        },
        PollContinue: extern struct {
            dwReserved: DWORD,
        },
        Error: extern struct {
            CopyPhase: COPYFILE2_COPY_PHASE,
            dwStreamNumber: DWORD,
            hrFailure: HRESULT,
            dwReserved: DWORD,
            uliChunkNumber: ULARGE_INTEGER,
            uliStreamSize: ULARGE_INTEGER,
            uliStreamBytesTransferred: ULARGE_INTEGER,
            uliTotalFileSize: ULARGE_INTEGER,
            uliTotalBytesTransferred: ULARGE_INTEGER,
        },
    },
};
pub const COPYFILE2_MESSAGE = struct_COPYFILE2_MESSAGE;
pub const PCOPYFILE2_PROGRESS_ROUTINE = ?fn ([*c]const COPYFILE2_MESSAGE, PVOID) callconv(.C) COPYFILE2_MESSAGE_ACTION;
pub const struct_COPYFILE2_EXTENDED_PARAMETERS = extern struct {
    dwSize: DWORD,
    dwCopyFlags: DWORD,
    pfCancel: [*c]BOOL,
    pProgressRoutine: PCOPYFILE2_PROGRESS_ROUTINE,
    pvCallbackContext: PVOID,
};
pub const COPYFILE2_EXTENDED_PARAMETERS = struct_COPYFILE2_EXTENDED_PARAMETERS;
pub extern "kernel32" fn CopyFile2(pwszExistingFileName: PCWSTR, pwszNewFileName: PCWSTR, pExtendedParameters: [*c]COPYFILE2_EXTENDED_PARAMETERS) callconv(.Stdcall) HRESULT;
pub extern "kernel32" fn MoveFileA(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn MoveFileW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn MoveFileExA(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn MoveFileExW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn MoveFileWithProgressA(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn MoveFileWithProgressW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn MoveFileTransactedA(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, dwFlags: DWORD, hTransaction: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn MoveFileTransactedW(lpExistingFileName: LPCWSTR, lpNewFileName: LPCWSTR, lpProgressRoutine: LPPROGRESS_ROUTINE, lpData: LPVOID, dwFlags: DWORD, hTransaction: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ReplaceFileA(lpReplacedFileName: LPCSTR, lpReplacementFileName: LPCSTR, lpBackupFileName: LPCSTR, dwReplaceFlags: DWORD, lpExclude: LPVOID, lpReserved: LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ReplaceFileW(lpReplacedFileName: LPCWSTR, lpReplacementFileName: LPCWSTR, lpBackupFileName: LPCWSTR, dwReplaceFlags: DWORD, lpExclude: LPVOID, lpReserved: LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateHardLinkA(lpFileName: LPCSTR, lpExistingFileName: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateHardLinkW(lpFileName: LPCWSTR, lpExistingFileName: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateHardLinkTransactedA(lpFileName: LPCSTR, lpExistingFileName: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, hTransaction: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateHardLinkTransactedW(lpFileName: LPCWSTR, lpExistingFileName: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, hTransaction: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindFirstStreamTransactedW(lpFileName: LPCWSTR, InfoLevel: STREAM_INFO_LEVELS, lpFindStreamData: LPVOID, dwFlags: DWORD, hTransaction: HANDLE) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn FindFirstFileNameTransactedW(lpFileName: LPCWSTR, dwFlags: DWORD, StringLength: LPDWORD, LinkName: PWSTR, hTransaction: HANDLE) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateNamedPipeA(lpName: LPCSTR, dwOpenMode: DWORD, dwPipeMode: DWORD, nMaxInstances: DWORD, nOutBufferSize: DWORD, nInBufferSize: DWORD, nDefaultTimeOut: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn GetNamedPipeHandleStateA(hNamedPipe: HANDLE, lpState: LPDWORD, lpCurInstances: LPDWORD, lpMaxCollectionCount: LPDWORD, lpCollectDataTimeout: LPDWORD, lpUserName: LPSTR, nMaxUserNameSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CallNamedPipeA(lpNamedPipeName: LPCSTR, lpInBuffer: LPVOID, nInBufferSize: DWORD, lpOutBuffer: LPVOID, nOutBufferSize: DWORD, lpBytesRead: LPDWORD, nTimeOut: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WaitNamedPipeA(lpNamedPipeName: LPCSTR, nTimeOut: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNamedPipeClientComputerNameA(Pipe: HANDLE, ClientComputerName: LPSTR, ClientComputerNameLength: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNamedPipeClientProcessId(Pipe: HANDLE, ClientProcessId: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNamedPipeClientSessionId(Pipe: HANDLE, ClientSessionId: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNamedPipeServerProcessId(Pipe: HANDLE, ServerProcessId: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNamedPipeServerSessionId(Pipe: HANDLE, ServerSessionId: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetVolumeLabelA(lpRootPathName: LPCSTR, lpVolumeName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetVolumeLabelW(lpRootPathName: LPCWSTR, lpVolumeName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetFileBandwidthReservation(hFile: HANDLE, nPeriodMilliseconds: DWORD, nBytesPerPeriod: DWORD, bDiscardable: BOOL, lpTransferSize: LPDWORD, lpNumOutstandingRequests: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetFileBandwidthReservation(hFile: HANDLE, lpPeriodMilliseconds: LPDWORD, lpBytesPerPeriod: LPDWORD, pDiscardable: LPBOOL, lpTransferSize: LPDWORD, lpNumOutstandingRequests: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn ClearEventLogA(hEventLog: HANDLE, lpBackupFileName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn ClearEventLogW(hEventLog: HANDLE, lpBackupFileName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn BackupEventLogA(hEventLog: HANDLE, lpBackupFileName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn BackupEventLogW(hEventLog: HANDLE, lpBackupFileName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CloseEventLog(hEventLog: HANDLE) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn DeregisterEventSource(hEventLog: HANDLE) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn NotifyChangeEventLog(hEventLog: HANDLE, hEvent: HANDLE) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn GetNumberOfEventLogRecords(hEventLog: HANDLE, NumberOfRecords: PDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn GetOldestEventLogRecord(hEventLog: HANDLE, OldestRecord: PDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn OpenEventLogA(lpUNCServerName: LPCSTR, lpSourceName: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "advapi32" fn OpenEventLogW(lpUNCServerName: LPCWSTR, lpSourceName: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "advapi32" fn RegisterEventSourceA(lpUNCServerName: LPCSTR, lpSourceName: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "advapi32" fn RegisterEventSourceW(lpUNCServerName: LPCWSTR, lpSourceName: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "advapi32" fn OpenBackupEventLogA(lpUNCServerName: LPCSTR, lpFileName: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "advapi32" fn OpenBackupEventLogW(lpUNCServerName: LPCWSTR, lpFileName: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "advapi32" fn ReadEventLogA(hEventLog: HANDLE, dwReadFlags: DWORD, dwRecordOffset: DWORD, lpBuffer: LPVOID, nNumberOfBytesToRead: DWORD, pnBytesRead: [*c]DWORD, pnMinNumberOfBytesNeeded: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn ReadEventLogW(hEventLog: HANDLE, dwReadFlags: DWORD, dwRecordOffset: DWORD, lpBuffer: LPVOID, nNumberOfBytesToRead: DWORD, pnBytesRead: [*c]DWORD, pnMinNumberOfBytesNeeded: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn ReportEventA(hEventLog: HANDLE, wType: WORD, wCategory: WORD, dwEventID: DWORD, lpUserSid: PSID, wNumStrings: WORD, dwDataSize: DWORD, lpStrings: [*c]LPCSTR, lpRawData: LPVOID) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn ReportEventW(hEventLog: HANDLE, wType: WORD, wCategory: WORD, dwEventID: DWORD, lpUserSid: PSID, wNumStrings: WORD, dwDataSize: DWORD, lpStrings: [*c]LPCWSTR, lpRawData: LPVOID) callconv(.Stdcall) BOOL;
pub const struct__EVENTLOG_FULL_INFORMATION = extern struct {
    dwFull: DWORD,
};
pub const EVENTLOG_FULL_INFORMATION = struct__EVENTLOG_FULL_INFORMATION;
pub const LPEVENTLOG_FULL_INFORMATION = [*c]struct__EVENTLOG_FULL_INFORMATION;
pub extern "advapi32" fn GetEventLogInformation(hEventLog: HANDLE, dwInfoLevel: DWORD, lpBuffer: LPVOID, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub const OPERATION_ID = ULONG;
pub const struct__OPERATION_START_PARAMETERS = extern struct {
    Version: ULONG,
    OperationId: OPERATION_ID,
    Flags: ULONG,
};
pub const OPERATION_START_PARAMETERS = struct__OPERATION_START_PARAMETERS;
pub const POPERATION_START_PARAMETERS = [*c]struct__OPERATION_START_PARAMETERS;
pub const struct__OPERATION_END_PARAMETERS = extern struct {
    Version: ULONG,
    OperationId: OPERATION_ID,
    Flags: ULONG,
};
pub const OPERATION_END_PARAMETERS = struct__OPERATION_END_PARAMETERS;
pub const POPERATION_END_PARAMETERS = [*c]struct__OPERATION_END_PARAMETERS;
pub extern "advapi32" fn OperationStart(OperationStartParams: [*c]OPERATION_START_PARAMETERS) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn OperationEnd(OperationEndParams: [*c]OPERATION_END_PARAMETERS) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn AccessCheckAndAuditAlarmA(SubsystemName: LPCSTR, HandleId: LPVOID, ObjectTypeName: LPSTR, ObjectName: LPSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, DesiredAccess: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: BOOL, GrantedAccess: LPDWORD, AccessStatus: LPBOOL, pfGenerateOnClose: LPBOOL) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn AccessCheckByTypeAndAuditAlarmA(SubsystemName: LPCSTR, HandleId: LPVOID, ObjectTypeName: LPCSTR, ObjectName: LPCSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: BOOL, GrantedAccess: LPDWORD, AccessStatus: LPBOOL, pfGenerateOnClose: LPBOOL) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn AccessCheckByTypeResultListAndAuditAlarmA(SubsystemName: LPCSTR, HandleId: LPVOID, ObjectTypeName: LPCSTR, ObjectName: LPCSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: BOOL, GrantedAccess: LPDWORD, AccessStatusList: LPDWORD, pfGenerateOnClose: LPBOOL) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn AccessCheckByTypeResultListAndAuditAlarmByHandleA(SubsystemName: LPCSTR, HandleId: LPVOID, ClientToken: HANDLE, ObjectTypeName: LPCSTR, ObjectName: LPCSTR, SecurityDescriptor: PSECURITY_DESCRIPTOR, PrincipalSelfSid: PSID, DesiredAccess: DWORD, AuditType: AUDIT_EVENT_TYPE, Flags: DWORD, ObjectTypeList: POBJECT_TYPE_LIST, ObjectTypeListLength: DWORD, GenericMapping: PGENERIC_MAPPING, ObjectCreation: BOOL, GrantedAccess: LPDWORD, AccessStatusList: LPDWORD, pfGenerateOnClose: LPBOOL) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn ObjectOpenAuditAlarmA(SubsystemName: LPCSTR, HandleId: LPVOID, ObjectTypeName: LPSTR, ObjectName: LPSTR, pSecurityDescriptor: PSECURITY_DESCRIPTOR, ClientToken: HANDLE, DesiredAccess: DWORD, GrantedAccess: DWORD, Privileges: PPRIVILEGE_SET, ObjectCreation: BOOL, AccessGranted: BOOL, GenerateOnClose: LPBOOL) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn ObjectPrivilegeAuditAlarmA(SubsystemName: LPCSTR, HandleId: LPVOID, ClientToken: HANDLE, DesiredAccess: DWORD, Privileges: PPRIVILEGE_SET, AccessGranted: BOOL) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn ObjectCloseAuditAlarmA(SubsystemName: LPCSTR, HandleId: LPVOID, GenerateOnClose: BOOL) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn ObjectDeleteAuditAlarmA(SubsystemName: LPCSTR, HandleId: LPVOID, GenerateOnClose: BOOL) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn PrivilegedServiceAuditAlarmA(SubsystemName: LPCSTR, ServiceName: LPCSTR, ClientToken: HANDLE, Privileges: PPRIVILEGE_SET, AccessGranted: BOOL) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn AddConditionalAce(pAcl: PACL, dwAceRevision: DWORD, AceFlags: DWORD, AceType: UCHAR, AccessMask: DWORD, pSid: PSID, ConditionStr: PWCHAR, ReturnLength: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn SetFileSecurityA(lpFileName: LPCSTR, SecurityInformation: SECURITY_INFORMATION, pSecurityDescriptor: PSECURITY_DESCRIPTOR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn GetFileSecurityA(lpFileName: LPCSTR, RequestedInformation: SECURITY_INFORMATION, pSecurityDescriptor: PSECURITY_DESCRIPTOR, nLength: DWORD, lpnLengthNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn ReadDirectoryChangesW(hDirectory: HANDLE, lpBuffer: LPVOID, nBufferLength: DWORD, bWatchSubtree: BOOL, dwNotifyFilter: DWORD, lpBytesReturned: LPDWORD, lpOverlapped: LPOVERLAPPED, lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn ReadDirectoryChangesExW(hDirectory: HANDLE, lpBuffer: LPVOID, nBufferLength: DWORD, bWatchSubtree: BOOL, dwNotifyFilter: DWORD, lpBytesReturned: LPDWORD, lpOverlapped: LPOVERLAPPED, lpCompletionRoutine: LPOVERLAPPED_COMPLETION_ROUTINE, ReadDirectoryNotifyInformationClass: READ_DIRECTORY_NOTIFY_INFORMATION_CLASS) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn MapViewOfFileExNuma(hFileMappingObject: HANDLE, dwDesiredAccess: DWORD, dwFileOffsetHigh: DWORD, dwFileOffsetLow: DWORD, dwNumberOfBytesToMap: SIZE_T, lpBaseAddress: LPVOID, nndPreferred: DWORD) callconv(.Stdcall) LPVOID;
pub extern "advapi32" fn IsBadReadPtr(lp: ?*const c_void, ucb: UINT_PTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn IsBadWritePtr(lp: LPVOID, ucb: UINT_PTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn IsBadHugeReadPtr(lp: ?*const c_void, ucb: UINT_PTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn IsBadHugeWritePtr(lp: LPVOID, ucb: UINT_PTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn IsBadCodePtr(lpfn: FARPROC) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn IsBadStringPtrA(lpsz: LPCSTR, ucchMax: UINT_PTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn IsBadStringPtrW(lpsz: LPCWSTR, ucchMax: UINT_PTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn LookupAccountSidA(lpSystemName: LPCSTR, Sid: PSID, Name: LPSTR, cchName: LPDWORD, ReferencedDomainName: LPSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn LookupAccountSidW(lpSystemName: LPCWSTR, Sid: PSID, Name: LPWSTR, cchName: LPDWORD, ReferencedDomainName: LPWSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn LookupAccountNameA(lpSystemName: LPCSTR, lpAccountName: LPCSTR, Sid: PSID, cbSid: LPDWORD, ReferencedDomainName: LPSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn LookupAccountNameW(lpSystemName: LPCWSTR, lpAccountName: LPCWSTR, Sid: PSID, cbSid: LPDWORD, ReferencedDomainName: LPWSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn LookupAccountNameLocalA(lpAccountName: LPCSTR, Sid: PSID, cbSid: LPDWORD, ReferencedDomainName: LPSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn LookupAccountNameLocalW(lpAccountName: LPCWSTR, Sid: PSID, cbSid: LPDWORD, ReferencedDomainName: LPWSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn LookupAccountSidLocalA(Sid: PSID, Name: LPSTR, cchName: LPDWORD, ReferencedDomainName: LPSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn LookupAccountSidLocalW(Sid: PSID, Name: LPWSTR, cchName: LPDWORD, ReferencedDomainName: LPWSTR, cchReferencedDomainName: LPDWORD, peUse: PSID_NAME_USE) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn LookupPrivilegeValueA(lpSystemName: LPCSTR, lpName: LPCSTR, lpLuid: PLUID) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn LookupPrivilegeValueW(lpSystemName: LPCWSTR, lpName: LPCWSTR, lpLuid: PLUID) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn LookupPrivilegeNameA(lpSystemName: LPCSTR, lpLuid: PLUID, lpName: LPSTR, cchName: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn LookupPrivilegeNameW(lpSystemName: LPCWSTR, lpLuid: PLUID, lpName: LPWSTR, cchName: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn LookupPrivilegeDisplayNameA(lpSystemName: LPCSTR, lpName: LPCSTR, lpDisplayName: LPSTR, cchDisplayName: LPDWORD, lpLanguageId: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn LookupPrivilegeDisplayNameW(lpSystemName: LPCWSTR, lpName: LPCWSTR, lpDisplayName: LPWSTR, cchDisplayName: LPDWORD, lpLanguageId: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn BuildCommDCBA(lpDef: LPCSTR, lpDCB: LPDCB) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn BuildCommDCBW(lpDef: LPCWSTR, lpDCB: LPDCB) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn BuildCommDCBAndTimeoutsA(lpDef: LPCSTR, lpDCB: LPDCB, lpCommTimeouts: LPCOMMTIMEOUTS) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn BuildCommDCBAndTimeoutsW(lpDef: LPCWSTR, lpDCB: LPDCB, lpCommTimeouts: LPCOMMTIMEOUTS) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CommConfigDialogA(lpszName: LPCSTR, hWnd: HWND, lpCC: LPCOMMCONFIG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CommConfigDialogW(lpszName: LPCWSTR, hWnd: HWND, lpCC: LPCOMMCONFIG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetDefaultCommConfigA(lpszName: LPCSTR, lpCC: LPCOMMCONFIG, lpdwSize: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetDefaultCommConfigW(lpszName: LPCWSTR, lpCC: LPCOMMCONFIG, lpdwSize: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetDefaultCommConfigA(lpszName: LPCSTR, lpCC: LPCOMMCONFIG, dwSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetDefaultCommConfigW(lpszName: LPCWSTR, lpCC: LPCOMMCONFIG, dwSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetComputerNameA(lpBuffer: LPSTR, nSize: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetComputerNameW(lpBuffer: LPWSTR, nSize: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DnsHostnameToComputerNameA(Hostname: LPCSTR, ComputerName: LPSTR, nSize: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DnsHostnameToComputerNameW(Hostname: LPCWSTR, ComputerName: LPWSTR, nSize: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetUserNameA(lpBuffer: LPSTR, pcbBuffer: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetUserNameW(lpBuffer: LPWSTR, pcbBuffer: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn LogonUserA(lpszUsername: LPCSTR, lpszDomain: LPCSTR, lpszPassword: LPCSTR, dwLogonType: DWORD, dwLogonProvider: DWORD, phToken: PHANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn LogonUserW(lpszUsername: LPCWSTR, lpszDomain: LPCWSTR, lpszPassword: LPCWSTR, dwLogonType: DWORD, dwLogonProvider: DWORD, phToken: PHANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn LogonUserExA(lpszUsername: LPCSTR, lpszDomain: LPCSTR, lpszPassword: LPCSTR, dwLogonType: DWORD, dwLogonProvider: DWORD, phToken: PHANDLE, ppLogonSid: [*c]PSID, ppProfileBuffer: [*c]PVOID, pdwProfileLength: LPDWORD, pQuotaLimits: PQUOTA_LIMITS) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn LogonUserExW(lpszUsername: LPCWSTR, lpszDomain: LPCWSTR, lpszPassword: LPCWSTR, dwLogonType: DWORD, dwLogonProvider: DWORD, phToken: PHANDLE, ppLogonSid: [*c]PSID, ppProfileBuffer: [*c]PVOID, pdwProfileLength: LPDWORD, pQuotaLimits: PQUOTA_LIMITS) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateProcessWithLogonW(lpUsername: LPCWSTR, lpDomain: LPCWSTR, lpPassword: LPCWSTR, dwLogonFlags: DWORD, lpApplicationName: LPCWSTR, lpCommandLine: LPWSTR, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCWSTR, lpStartupInfo: LPSTARTUPINFOW, lpProcessInformation: LPPROCESS_INFORMATION) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateProcessWithTokenW(hToken: HANDLE, dwLogonFlags: DWORD, lpApplicationName: LPCWSTR, lpCommandLine: LPWSTR, dwCreationFlags: DWORD, lpEnvironment: LPVOID, lpCurrentDirectory: LPCWSTR, lpStartupInfo: LPSTARTUPINFOW, lpProcessInformation: LPPROCESS_INFORMATION) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsTokenUntrusted(TokenHandle: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn RegisterWaitForSingleObject(phNewWaitObject: PHANDLE, hObject: HANDLE, Callback: WAITORTIMERCALLBACK, Context: PVOID, dwMilliseconds: ULONG, dwFlags: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn UnregisterWait(WaitHandle: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn BindIoCompletionCallback(FileHandle: HANDLE, Function: LPOVERLAPPED_COMPLETION_ROUTINE, Flags: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetTimerQueueTimer(TimerQueue: HANDLE, Callback: WAITORTIMERCALLBACK, Parameter: PVOID, DueTime: DWORD, Period: DWORD, PreferIo: BOOL) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CancelTimerQueueTimer(TimerQueue: HANDLE, Timer: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeleteTimerQueue(TimerQueue: HANDLE) callconv(.Stdcall) BOOL;
pub fn InitializeThreadpoolEnvironment(pcbe: PTP_CALLBACK_ENVIRON) void {
    TpInitializeCallbackEnviron(pcbe);
}
pub fn SetThreadpoolCallbackPool(pcbe: PTP_CALLBACK_ENVIRON, ptpp: PTP_POOL) void {
    TpSetCallbackThreadpool(pcbe, ptpp);
}
pub fn SetThreadpoolCallbackCleanupGroup(pcbe: PTP_CALLBACK_ENVIRON, ptpcg: PTP_CLEANUP_GROUP, pfng: PTP_CLEANUP_GROUP_CANCEL_CALLBACK) void {
    TpSetCallbackCleanupGroup(pcbe, ptpcg, pfng);
}
pub fn SetThreadpoolCallbackRunsLong(pcbe: PTP_CALLBACK_ENVIRON) void {
    TpSetCallbackLongFunction(pcbe);
}
pub fn SetThreadpoolCallbackLibrary(pcbe: PTP_CALLBACK_ENVIRON, mod: PVOID) void {
    TpSetCallbackRaceWithDll(pcbe, mod);
}
pub fn SetThreadpoolCallbackPriority(pcbe: PTP_CALLBACK_ENVIRON, Priority: TP_CALLBACK_PRIORITY) void {
    TpSetCallbackPriority(pcbe, Priority);
}
pub fn DestroyThreadpoolEnvironment(pcbe: PTP_CALLBACK_ENVIRON) void {
    TpDestroyCallbackEnviron(pcbe);
}
pub fn SetThreadpoolCallbackPersistent(pcbe: PTP_CALLBACK_ENVIRON) void {
    TpSetCallbackPersistent(pcbe);
}
pub extern "kernel32" fn CreatePrivateNamespaceA(lpPrivateNamespaceAttributes: LPSECURITY_ATTRIBUTES, lpBoundaryDescriptor: LPVOID, lpAliasPrefix: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn OpenPrivateNamespaceA(lpBoundaryDescriptor: LPVOID, lpAliasPrefix: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateBoundaryDescriptorA(Name: LPCSTR, Flags: ULONG) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn AddIntegrityLabelToBoundaryDescriptor(BoundaryDescriptor: [*c]HANDLE, IntegrityLabel: PSID) callconv(.Stdcall) BOOL;
pub const struct_tagHW_PROFILE_INFOA = extern struct {
    dwDockInfo: DWORD,
    szHwProfileGuid: [39]CHAR,
    szHwProfileName: [80]CHAR,
};
pub const HW_PROFILE_INFOA = struct_tagHW_PROFILE_INFOA;
pub const LPHW_PROFILE_INFOA = [*c]struct_tagHW_PROFILE_INFOA;
pub const struct_tagHW_PROFILE_INFOW = extern struct {
    dwDockInfo: DWORD,
    szHwProfileGuid: [39]WCHAR,
    szHwProfileName: [80]WCHAR,
};
pub const HW_PROFILE_INFOW = struct_tagHW_PROFILE_INFOW;
pub const LPHW_PROFILE_INFOW = [*c]struct_tagHW_PROFILE_INFOW;
pub const HW_PROFILE_INFO = HW_PROFILE_INFOA;
pub const LPHW_PROFILE_INFO = LPHW_PROFILE_INFOA;
pub extern "advapi32" fn GetCurrentHwProfileA(lpHwProfileInfo: LPHW_PROFILE_INFOA) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn GetCurrentHwProfileW(lpHwProfileInfo: LPHW_PROFILE_INFOW) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn VerifyVersionInfoA(lpVersionInformation: LPOSVERSIONINFOEXA, dwTypeMask: DWORD, dwlConditionMask: DWORDLONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn VerifyVersionInfoW(lpVersionInformation: LPOSVERSIONINFOEXW, dwTypeMask: DWORD, dwlConditionMask: DWORDLONG) callconv(.Stdcall) BOOL;
pub fn HRESULT_FROM_WIN32(x: c_ulong) HRESULT {
    return if (HRESULT(x) <= @as(c_long, 0)) HRESULT(x) else HRESULT(((x & @as(c_ulong, 65535)) | @as(c_ulong, 7 << @import("std").math.Log2Int(c_int)(16))) | @as(c_ulong, 2147483648));
}
pub const struct__TIME_ZONE_INFORMATION = extern struct {
    Bias: LONG,
    StandardName: [32]WCHAR,
    StandardDate: SYSTEMTIME,
    StandardBias: LONG,
    DaylightName: [32]WCHAR,
    DaylightDate: SYSTEMTIME,
    DaylightBias: LONG,
};
pub const TIME_ZONE_INFORMATION = struct__TIME_ZONE_INFORMATION;
pub const PTIME_ZONE_INFORMATION = [*c]struct__TIME_ZONE_INFORMATION;
pub const LPTIME_ZONE_INFORMATION = [*c]struct__TIME_ZONE_INFORMATION;
pub const struct__TIME_DYNAMIC_ZONE_INFORMATION = extern struct {
    Bias: LONG,
    StandardName: [32]WCHAR,
    StandardDate: SYSTEMTIME,
    StandardBias: LONG,
    DaylightName: [32]WCHAR,
    DaylightDate: SYSTEMTIME,
    DaylightBias: LONG,
    TimeZoneKeyName: [128]WCHAR,
    DynamicDaylightTimeDisabled: BOOLEAN,
};
pub const DYNAMIC_TIME_ZONE_INFORMATION = struct__TIME_DYNAMIC_ZONE_INFORMATION;
pub const PDYNAMIC_TIME_ZONE_INFORMATION = [*c]struct__TIME_DYNAMIC_ZONE_INFORMATION;
pub extern "kernel32" fn SystemTimeToTzSpecificLocalTime(lpTimeZoneInformation: [*c]const TIME_ZONE_INFORMATION, lpUniversalTime: [*c]const SYSTEMTIME, lpLocalTime: LPSYSTEMTIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn TzSpecificLocalTimeToSystemTime(lpTimeZoneInformation: [*c]const TIME_ZONE_INFORMATION, lpLocalTime: [*c]const SYSTEMTIME, lpUniversalTime: LPSYSTEMTIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FileTimeToSystemTime(lpFileTime: [*c]const FILETIME, lpSystemTime: LPSYSTEMTIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SystemTimeToFileTime(lpSystemTime: [*c]const SYSTEMTIME, lpFileTime: LPFILETIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetTimeZoneInformation(lpTimeZoneInformation: LPTIME_ZONE_INFORMATION) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SetTimeZoneInformation(lpTimeZoneInformation: [*c]const TIME_ZONE_INFORMATION) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetDynamicTimeZoneInformation(lpTimeZoneInformation: [*c]const DYNAMIC_TIME_ZONE_INFORMATION) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetDynamicTimeZoneInformation(pTimeZoneInformation: PDYNAMIC_TIME_ZONE_INFORMATION) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetTimeZoneInformationForYear(wYear: USHORT, pdtzi: PDYNAMIC_TIME_ZONE_INFORMATION, ptzi: LPTIME_ZONE_INFORMATION) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumDynamicTimeZoneInformation(dwIndex: DWORD, lpTimeZoneInformation: PDYNAMIC_TIME_ZONE_INFORMATION) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetDynamicTimeZoneInformationEffectiveYears(lpTimeZoneInformation: PDYNAMIC_TIME_ZONE_INFORMATION, FirstYear: LPDWORD, LastYear: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SystemTimeToTzSpecificLocalTimeEx(lpTimeZoneInformation: [*c]const DYNAMIC_TIME_ZONE_INFORMATION, lpUniversalTime: [*c]const SYSTEMTIME, lpLocalTime: LPSYSTEMTIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn TzSpecificLocalTimeToSystemTimeEx(lpTimeZoneInformation: [*c]const DYNAMIC_TIME_ZONE_INFORMATION, lpLocalTime: [*c]const SYSTEMTIME, lpUniversalTime: LPSYSTEMTIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn LocalFileTimeToLocalSystemTime(timeZoneInformation: [*c]const TIME_ZONE_INFORMATION, localFileTime: [*c]const FILETIME, localSystemTime: [*c]SYSTEMTIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn LocalSystemTimeToLocalFileTime(timeZoneInformation: [*c]const TIME_ZONE_INFORMATION, localSystemTime: [*c]const SYSTEMTIME, localFileTime: [*c]FILETIME) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetSystemPowerState(fSuspend: BOOL, fForce: BOOL) callconv(.Stdcall) BOOL;
pub const struct__SYSTEM_POWER_STATUS = extern struct {
    ACLineStatus: BYTE,
    BatteryFlag: BYTE,
    BatteryLifePercent: BYTE,
    SystemStatusFlag: BYTE,
    BatteryLifeTime: DWORD,
    BatteryFullLifeTime: DWORD,
};
pub const SYSTEM_POWER_STATUS = struct__SYSTEM_POWER_STATUS;
pub const LPSYSTEM_POWER_STATUS = [*c]struct__SYSTEM_POWER_STATUS;
pub extern "kernel32" fn GetSystemPowerStatus(lpSystemPowerStatus: LPSYSTEM_POWER_STATUS) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn MapUserPhysicalPagesScatter(VirtualAddresses: [*c]PVOID, NumberOfPages: ULONG_PTR, PageArray: PULONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateJobObjectA(lpJobAttributes: LPSECURITY_ATTRIBUTES, lpName: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn OpenJobObjectA(dwDesiredAccess: DWORD, bInheritHandle: BOOL, lpName: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateJobSet(NumJob: ULONG, UserJobSet: PJOB_SET_ARRAY, Flags: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindFirstVolumeA(lpszVolumeName: LPSTR, cchBufferLength: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn FindNextVolumeA(hFindVolume: HANDLE, lpszVolumeName: LPSTR, cchBufferLength: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindFirstVolumeMountPointA(lpszRootPathName: LPCSTR, lpszVolumeMountPoint: LPSTR, cchBufferLength: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn FindFirstVolumeMountPointW(lpszRootPathName: LPCWSTR, lpszVolumeMountPoint: LPWSTR, cchBufferLength: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn FindNextVolumeMountPointA(hFindVolumeMountPoint: HANDLE, lpszVolumeMountPoint: LPSTR, cchBufferLength: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindNextVolumeMountPointW(hFindVolumeMountPoint: HANDLE, lpszVolumeMountPoint: LPWSTR, cchBufferLength: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindVolumeMountPointClose(hFindVolumeMountPoint: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetVolumeMountPointA(lpszVolumeMountPoint: LPCSTR, lpszVolumeName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetVolumeMountPointW(lpszVolumeMountPoint: LPCWSTR, lpszVolumeName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeleteVolumeMountPointA(lpszVolumeMountPoint: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetVolumeNameForVolumeMountPointA(lpszVolumeMountPoint: LPCSTR, lpszVolumeName: LPSTR, cchBufferLength: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetVolumePathNameA(lpszFileName: LPCSTR, lpszVolumePathName: LPSTR, cchBufferLength: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetVolumePathNamesForVolumeNameA(lpszVolumeName: LPCSTR, lpszVolumePathNames: LPCH, cchBufferLength: DWORD, lpcchReturnLength: PDWORD) callconv(.Stdcall) BOOL;
pub const struct_tagACTCTXA = extern struct {
    cbSize: ULONG,
    dwFlags: DWORD,
    lpSource: LPCSTR,
    wProcessorArchitecture: USHORT,
    wLangId: LANGID,
    lpAssemblyDirectory: LPCSTR,
    lpResourceName: LPCSTR,
    lpApplicationName: LPCSTR,
    hModule: HMODULE,
};
pub const ACTCTXA = struct_tagACTCTXA;
pub const PACTCTXA = [*c]struct_tagACTCTXA;
pub const struct_tagACTCTXW = extern struct {
    cbSize: ULONG,
    dwFlags: DWORD,
    lpSource: LPCWSTR,
    wProcessorArchitecture: USHORT,
    wLangId: LANGID,
    lpAssemblyDirectory: LPCWSTR,
    lpResourceName: LPCWSTR,
    lpApplicationName: LPCWSTR,
    hModule: HMODULE,
};
pub const ACTCTXW = struct_tagACTCTXW;
pub const PACTCTXW = [*c]struct_tagACTCTXW;
pub const ACTCTX = ACTCTXA;
pub const PACTCTX = PACTCTXA;
pub const PCACTCTXA = [*c]const ACTCTXA;
pub const PCACTCTXW = [*c]const ACTCTXW;
pub const PCACTCTX = PCACTCTXA;
pub extern "kernel32" fn CreateActCtxA(pActCtx: PCACTCTXA) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateActCtxW(pActCtx: PCACTCTXW) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn AddRefActCtx(hActCtx: HANDLE) callconv(.Stdcall) void;
pub extern "kernel32" fn ReleaseActCtx(hActCtx: HANDLE) callconv(.Stdcall) void;
pub extern "kernel32" fn ZombifyActCtx(hActCtx: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ActivateActCtx(hActCtx: HANDLE, lpCookie: [*c]ULONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn DeactivateActCtx(dwFlags: DWORD, ulCookie: ULONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCurrentActCtx(lphActCtx: [*c]HANDLE) callconv(.Stdcall) BOOL;
pub const struct_tagACTCTX_SECTION_KEYED_DATA_2600 = extern struct {
    cbSize: ULONG,
    ulDataFormatVersion: ULONG,
    lpData: PVOID,
    ulLength: ULONG,
    lpSectionGlobalData: PVOID,
    ulSectionGlobalDataLength: ULONG,
    lpSectionBase: PVOID,
    ulSectionTotalLength: ULONG,
    hActCtx: HANDLE,
    ulAssemblyRosterIndex: ULONG,
};
pub const ACTCTX_SECTION_KEYED_DATA_2600 = struct_tagACTCTX_SECTION_KEYED_DATA_2600;
pub const PACTCTX_SECTION_KEYED_DATA_2600 = [*c]struct_tagACTCTX_SECTION_KEYED_DATA_2600;
pub const PCACTCTX_SECTION_KEYED_DATA_2600 = [*c]const ACTCTX_SECTION_KEYED_DATA_2600;
pub const struct_tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = extern struct {
    lpInformation: PVOID,
    lpSectionBase: PVOID,
    ulSectionLength: ULONG,
    lpSectionGlobalDataBase: PVOID,
    ulSectionGlobalDataLength: ULONG,
};
pub const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = struct_tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
pub const PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = [*c]struct_tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
pub const PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = [*c]const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
pub const struct_tagACTCTX_SECTION_KEYED_DATA = extern struct {
    cbSize: ULONG,
    ulDataFormatVersion: ULONG,
    lpData: PVOID,
    ulLength: ULONG,
    lpSectionGlobalData: PVOID,
    ulSectionGlobalDataLength: ULONG,
    lpSectionBase: PVOID,
    ulSectionTotalLength: ULONG,
    hActCtx: HANDLE,
    ulAssemblyRosterIndex: ULONG,
    ulFlags: ULONG,
    AssemblyMetadata: ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA,
};
pub const ACTCTX_SECTION_KEYED_DATA = struct_tagACTCTX_SECTION_KEYED_DATA;
pub const PACTCTX_SECTION_KEYED_DATA = [*c]struct_tagACTCTX_SECTION_KEYED_DATA;
pub const PCACTCTX_SECTION_KEYED_DATA = [*c]const ACTCTX_SECTION_KEYED_DATA;
pub extern "kernel32" fn FindActCtxSectionStringA(dwFlags: DWORD, lpExtensionGuid: [*c]const GUID, ulSectionId: ULONG, lpStringToFind: LPCSTR, ReturnedData: PACTCTX_SECTION_KEYED_DATA) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindActCtxSectionStringW(dwFlags: DWORD, lpExtensionGuid: [*c]const GUID, ulSectionId: ULONG, lpStringToFind: LPCWSTR, ReturnedData: PACTCTX_SECTION_KEYED_DATA) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FindActCtxSectionGuid(dwFlags: DWORD, lpExtensionGuid: [*c]const GUID, ulSectionId: ULONG, lpGuidToFind: [*c]const GUID, ReturnedData: PACTCTX_SECTION_KEYED_DATA) callconv(.Stdcall) BOOL;
pub const struct__ACTIVATION_CONTEXT_BASIC_INFORMATION = extern struct {
    hActCtx: HANDLE,
    dwFlags: DWORD,
};
pub const ACTIVATION_CONTEXT_BASIC_INFORMATION = struct__ACTIVATION_CONTEXT_BASIC_INFORMATION;
pub const PACTIVATION_CONTEXT_BASIC_INFORMATION = [*c]struct__ACTIVATION_CONTEXT_BASIC_INFORMATION;
pub const PCACTIVATION_CONTEXT_BASIC_INFORMATION = [*c]const struct__ACTIVATION_CONTEXT_BASIC_INFORMATION;
pub extern "kernel32" fn QueryActCtxW(dwFlags: DWORD, hActCtx: HANDLE, pvSubInstance: PVOID, ulInfoClass: ULONG, pvBuffer: PVOID, cbBuffer: SIZE_T, pcbWrittenOrRequired: [*c]SIZE_T) callconv(.Stdcall) BOOL;
pub const PQUERYACTCTXW_FUNC = ?fn (DWORD, HANDLE, PVOID, ULONG, PVOID, SIZE_T, [*c]SIZE_T) callconv(.C) BOOL;
pub extern "kernel32" fn WTSGetActiveConsoleSessionId() callconv(.Stdcall) DWORD;
pub extern "kernel32" fn WTSGetServiceSessionId() callconv(.Stdcall) DWORD;
pub extern "kernel32" fn WTSIsServerContainer() callconv(.Stdcall) BOOLEAN;
pub extern "kernel32" fn GetActiveProcessorGroupCount() callconv(.Stdcall) WORD;
pub extern "kernel32" fn GetMaximumProcessorGroupCount() callconv(.Stdcall) WORD;
pub extern "kernel32" fn GetActiveProcessorCount(GroupNumber: WORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetMaximumProcessorCount(GroupNumber: WORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetNumaProcessorNode(Processor: UCHAR, NodeNumber: PUCHAR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNumaNodeNumberFromHandle(hFile: HANDLE, NodeNumber: PUSHORT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNumaProcessorNodeEx(Processor: PPROCESSOR_NUMBER, NodeNumber: PUSHORT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNumaNodeProcessorMask(Node: UCHAR, ProcessorMask: PULONGLONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNumaAvailableMemoryNode(Node: UCHAR, AvailableBytes: PULONGLONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNumaAvailableMemoryNodeEx(Node: USHORT, AvailableBytes: PULONGLONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNumaProximityNode(ProximityId: ULONG, NodeNumber: PUCHAR) callconv(.Stdcall) BOOL;
pub const APPLICATION_RECOVERY_CALLBACK = ?fn (PVOID) callconv(.C) DWORD;
pub extern "kernel32" fn RegisterApplicationRecoveryCallback(pRecoveyCallback: APPLICATION_RECOVERY_CALLBACK, pvParameter: PVOID, dwPingInterval: DWORD, dwFlags: DWORD) callconv(.Stdcall) HRESULT;
pub extern "kernel32" fn UnregisterApplicationRecoveryCallback() callconv(.Stdcall) HRESULT;
pub extern "kernel32" fn RegisterApplicationRestart(pwzCommandline: PCWSTR, dwFlags: DWORD) callconv(.Stdcall) HRESULT;
pub extern "kernel32" fn UnregisterApplicationRestart() callconv(.Stdcall) HRESULT;
pub extern "kernel32" fn GetApplicationRecoveryCallback(hProcess: HANDLE, pRecoveryCallback: [*c]APPLICATION_RECOVERY_CALLBACK, ppvParameter: [*c]PVOID, pdwPingInterval: PDWORD, pdwFlags: PDWORD) callconv(.Stdcall) HRESULT;
pub extern "kernel32" fn GetApplicationRestartSettings(hProcess: HANDLE, pwzCommandline: PWSTR, pcchSize: PDWORD, pdwFlags: PDWORD) callconv(.Stdcall) HRESULT;
pub extern "kernel32" fn ApplicationRecoveryInProgress(pbCancelled: PBOOL) callconv(.Stdcall) HRESULT;
pub extern "kernel32" fn ApplicationRecoveryFinished(bSuccess: BOOL) callconv(.Stdcall) void;
pub const struct__FILE_BASIC_INFO = extern struct {
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    FileAttributes: DWORD,
};
pub const FILE_BASIC_INFO = struct__FILE_BASIC_INFO;
pub const PFILE_BASIC_INFO = [*c]struct__FILE_BASIC_INFO;
pub const struct__FILE_STANDARD_INFO = extern struct {
    AllocationSize: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    NumberOfLinks: DWORD,
    DeletePending: BOOLEAN,
    Directory: BOOLEAN,
};
pub const FILE_STANDARD_INFO = struct__FILE_STANDARD_INFO;
pub const PFILE_STANDARD_INFO = [*c]struct__FILE_STANDARD_INFO;
pub const struct__FILE_NAME_INFO = extern struct {
    FileNameLength: DWORD,
    FileName: [1]WCHAR,
};
pub const FILE_NAME_INFO = struct__FILE_NAME_INFO;
pub const PFILE_NAME_INFO = [*c]struct__FILE_NAME_INFO;
pub const struct__FILE_CASE_SENSITIVE_INFO = extern struct {
    Flags: ULONG,
};
pub const FILE_CASE_SENSITIVE_INFO = struct__FILE_CASE_SENSITIVE_INFO;
pub const PFILE_CASE_SENSITIVE_INFO = [*c]struct__FILE_CASE_SENSITIVE_INFO;
pub const struct__FILE_RENAME_INFO = extern struct {
    @"": extern union {
        ReplaceIfExists: BOOLEAN,
        Flags: DWORD,
    },
    RootDirectory: HANDLE,
    FileNameLength: DWORD,
    FileName: [1]WCHAR,
};
pub const FILE_RENAME_INFO = struct__FILE_RENAME_INFO;
pub const PFILE_RENAME_INFO = [*c]struct__FILE_RENAME_INFO;
pub const struct__FILE_ALLOCATION_INFO = extern struct {
    AllocationSize: LARGE_INTEGER,
};
pub const FILE_ALLOCATION_INFO = struct__FILE_ALLOCATION_INFO;
pub const PFILE_ALLOCATION_INFO = [*c]struct__FILE_ALLOCATION_INFO;
pub const struct__FILE_END_OF_FILE_INFO = extern struct {
    EndOfFile: LARGE_INTEGER,
};
pub const FILE_END_OF_FILE_INFO = struct__FILE_END_OF_FILE_INFO;
pub const PFILE_END_OF_FILE_INFO = [*c]struct__FILE_END_OF_FILE_INFO;
pub const struct__FILE_STREAM_INFO = extern struct {
    NextEntryOffset: DWORD,
    StreamNameLength: DWORD,
    StreamSize: LARGE_INTEGER,
    StreamAllocationSize: LARGE_INTEGER,
    StreamName: [1]WCHAR,
};
pub const FILE_STREAM_INFO = struct__FILE_STREAM_INFO;
pub const PFILE_STREAM_INFO = [*c]struct__FILE_STREAM_INFO;
pub const struct__FILE_COMPRESSION_INFO = extern struct {
    CompressedFileSize: LARGE_INTEGER,
    CompressionFormat: WORD,
    CompressionUnitShift: UCHAR,
    ChunkShift: UCHAR,
    ClusterShift: UCHAR,
    Reserved: [3]UCHAR,
};
pub const FILE_COMPRESSION_INFO = struct__FILE_COMPRESSION_INFO;
pub const PFILE_COMPRESSION_INFO = [*c]struct__FILE_COMPRESSION_INFO;
pub const struct__FILE_ATTRIBUTE_TAG_INFO = extern struct {
    FileAttributes: DWORD,
    ReparseTag: DWORD,
};
pub const FILE_ATTRIBUTE_TAG_INFO = struct__FILE_ATTRIBUTE_TAG_INFO;
pub const PFILE_ATTRIBUTE_TAG_INFO = [*c]struct__FILE_ATTRIBUTE_TAG_INFO;
pub const struct__FILE_DISPOSITION_INFO = extern struct {
    DeleteFileA: BOOLEAN,
};
pub const FILE_DISPOSITION_INFO = struct__FILE_DISPOSITION_INFO;
pub const PFILE_DISPOSITION_INFO = [*c]struct__FILE_DISPOSITION_INFO;
pub const struct__FILE_DISPOSITION_INFO_EX = extern struct {
    Flags: DWORD,
};
pub const FILE_DISPOSITION_INFO_EX = struct__FILE_DISPOSITION_INFO_EX;
pub const PFILE_DISPOSITION_INFO_EX = [*c]struct__FILE_DISPOSITION_INFO_EX;
pub const struct__FILE_ID_BOTH_DIR_INFO = extern struct {
    NextEntryOffset: DWORD,
    FileIndex: DWORD,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: DWORD,
    FileNameLength: DWORD,
    EaSize: DWORD,
    ShortNameLength: CCHAR,
    ShortName: [12]WCHAR,
    FileId: LARGE_INTEGER,
    FileName: [1]WCHAR,
};
pub const FILE_ID_BOTH_DIR_INFO = struct__FILE_ID_BOTH_DIR_INFO;
pub const PFILE_ID_BOTH_DIR_INFO = [*c]struct__FILE_ID_BOTH_DIR_INFO;
pub const struct__FILE_FULL_DIR_INFO = extern struct {
    NextEntryOffset: ULONG,
    FileIndex: ULONG,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: ULONG,
    FileNameLength: ULONG,
    EaSize: ULONG,
    FileName: [1]WCHAR,
};
pub const FILE_FULL_DIR_INFO = struct__FILE_FULL_DIR_INFO;
pub const PFILE_FULL_DIR_INFO = [*c]struct__FILE_FULL_DIR_INFO;
pub const IoPriorityHintVeryLow = enum__PRIORITY_HINT.IoPriorityHintVeryLow;
pub const IoPriorityHintLow = enum__PRIORITY_HINT.IoPriorityHintLow;
pub const IoPriorityHintNormal = enum__PRIORITY_HINT.IoPriorityHintNormal;
pub const MaximumIoPriorityHintType = enum__PRIORITY_HINT.MaximumIoPriorityHintType;
pub const enum__PRIORITY_HINT = extern enum {
    IoPriorityHintVeryLow = 0,
    IoPriorityHintLow = 1,
    IoPriorityHintNormal = 2,
    MaximumIoPriorityHintType = 3,
};
pub const PRIORITY_HINT = enum__PRIORITY_HINT;
pub const struct__FILE_IO_PRIORITY_HINT_INFO = extern struct {
    PriorityHint: PRIORITY_HINT,
};
pub const FILE_IO_PRIORITY_HINT_INFO = struct__FILE_IO_PRIORITY_HINT_INFO;
pub const PFILE_IO_PRIORITY_HINT_INFO = [*c]struct__FILE_IO_PRIORITY_HINT_INFO;
pub const struct__FILE_ALIGNMENT_INFO = extern struct {
    AlignmentRequirement: ULONG,
};
pub const FILE_ALIGNMENT_INFO = struct__FILE_ALIGNMENT_INFO;
pub const PFILE_ALIGNMENT_INFO = [*c]struct__FILE_ALIGNMENT_INFO;
pub const struct__FILE_STORAGE_INFO = extern struct {
    LogicalBytesPerSector: ULONG,
    PhysicalBytesPerSectorForAtomicity: ULONG,
    PhysicalBytesPerSectorForPerformance: ULONG,
    FileSystemEffectivePhysicalBytesPerSectorForAtomicity: ULONG,
    Flags: ULONG,
    ByteOffsetForSectorAlignment: ULONG,
    ByteOffsetForPartitionAlignment: ULONG,
};
pub const FILE_STORAGE_INFO = struct__FILE_STORAGE_INFO;
pub const PFILE_STORAGE_INFO = [*c]struct__FILE_STORAGE_INFO;
pub const struct__FILE_ID_INFO = extern struct {
    VolumeSerialNumber: ULONGLONG,
    FileId: FILE_ID_128,
};
pub const FILE_ID_INFO = struct__FILE_ID_INFO;
pub const PFILE_ID_INFO = [*c]struct__FILE_ID_INFO;
pub const struct__FILE_ID_EXTD_DIR_INFO = extern struct {
    NextEntryOffset: ULONG,
    FileIndex: ULONG,
    CreationTime: LARGE_INTEGER,
    LastAccessTime: LARGE_INTEGER,
    LastWriteTime: LARGE_INTEGER,
    ChangeTime: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    AllocationSize: LARGE_INTEGER,
    FileAttributes: ULONG,
    FileNameLength: ULONG,
    EaSize: ULONG,
    ReparsePointTag: ULONG,
    FileId: FILE_ID_128,
    FileName: [1]WCHAR,
};
pub const FILE_ID_EXTD_DIR_INFO = struct__FILE_ID_EXTD_DIR_INFO;
pub const PFILE_ID_EXTD_DIR_INFO = [*c]struct__FILE_ID_EXTD_DIR_INFO;
pub const struct__FILE_REMOTE_PROTOCOL_INFO = extern struct {
    StructureVersion: USHORT,
    StructureSize: USHORT,
    Protocol: ULONG,
    ProtocolMajorVersion: USHORT,
    ProtocolMinorVersion: USHORT,
    ProtocolRevision: USHORT,
    Reserved: USHORT,
    Flags: ULONG,
    GenericReserved: extern struct {
        Reserved: [8]ULONG,
    },
    ProtocolSpecific: extern union {
        Smb2: extern struct {
            Server: extern struct {
                Capabilities: ULONG,
            },
            Share: extern struct {
                Capabilities: ULONG,
                CachingFlags: ULONG,
            },
        },
        Reserved: [16]ULONG,
    },
};
pub const FILE_REMOTE_PROTOCOL_INFO = struct__FILE_REMOTE_PROTOCOL_INFO;
pub const PFILE_REMOTE_PROTOCOL_INFO = [*c]struct__FILE_REMOTE_PROTOCOL_INFO;
pub extern "kernel32" fn GetFileInformationByHandleEx(hFile: HANDLE, FileInformationClass: FILE_INFO_BY_HANDLE_CLASS, lpFileInformation: LPVOID, dwBufferSize: DWORD) callconv(.Stdcall) BOOL;
pub const FileIdType = enum__FILE_ID_TYPE.FileIdType;
pub const ObjectIdType = enum__FILE_ID_TYPE.ObjectIdType;
pub const ExtendedFileIdType = enum__FILE_ID_TYPE.ExtendedFileIdType;
pub const MaximumFileIdType = enum__FILE_ID_TYPE.MaximumFileIdType;
pub const enum__FILE_ID_TYPE = extern enum {
    FileIdType,
    ObjectIdType,
    ExtendedFileIdType,
    MaximumFileIdType,
};
pub const FILE_ID_TYPE = enum__FILE_ID_TYPE;
pub const PFILE_ID_TYPE = [*c]enum__FILE_ID_TYPE;
pub const struct_FILE_ID_DESCRIPTOR = extern struct {
    dwSize: DWORD,
    Type: FILE_ID_TYPE,
    @"": extern union {
        FileId: LARGE_INTEGER,
        ObjectId: GUID,
        ExtendedFileId: FILE_ID_128,
    },
};
pub const FILE_ID_DESCRIPTOR = struct_FILE_ID_DESCRIPTOR;
pub const LPFILE_ID_DESCRIPTOR = [*c]struct_FILE_ID_DESCRIPTOR;
pub extern "kernel32" fn OpenFileById(hVolumeHint: HANDLE, lpFileId: LPFILE_ID_DESCRIPTOR, dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, dwFlagsAndAttributes: DWORD) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn CreateSymbolicLinkA(lpSymlinkFileName: LPCSTR, lpTargetFileName: LPCSTR, dwFlags: DWORD) callconv(.Stdcall) BOOLEAN;
pub extern "kernel32" fn CreateSymbolicLinkW(lpSymlinkFileName: LPCWSTR, lpTargetFileName: LPCWSTR, dwFlags: DWORD) callconv(.Stdcall) BOOLEAN;
pub extern "kernel32" fn QueryActCtxSettingsW(dwFlags: DWORD, hActCtx: HANDLE, settingsNameSpace: PCWSTR, settingName: PCWSTR, pvBuffer: PWSTR, dwBuffer: SIZE_T, pdwWrittenOrRequired: [*c]SIZE_T) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateSymbolicLinkTransactedA(lpSymlinkFileName: LPCSTR, lpTargetFileName: LPCSTR, dwFlags: DWORD, hTransaction: HANDLE) callconv(.Stdcall) BOOLEAN;
pub extern "kernel32" fn CreateSymbolicLinkTransactedW(lpSymlinkFileName: LPCWSTR, lpTargetFileName: LPCWSTR, dwFlags: DWORD, hTransaction: HANDLE) callconv(.Stdcall) BOOLEAN;
pub extern "kernel32" fn ReplacePartitionUnit(TargetPartition: PWSTR, SparePartition: PWSTR, Flags: ULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AddSecureMemoryCacheCallback(pfnCallBack: PSECURE_MEMORY_CACHE_CALLBACK) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn RemoveSecureMemoryCacheCallback(pfnCallBack: PSECURE_MEMORY_CACHE_CALLBACK) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CopyContext(Destination: PCONTEXT, ContextFlags: DWORD, Source: PCONTEXT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn InitializeContext(Buffer: PVOID, ContextFlags: DWORD, Context: [*c]PCONTEXT, ContextLength: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn InitializeContext2(Buffer: PVOID, ContextFlags: DWORD, Context: [*c]PCONTEXT, ContextLength: PDWORD, XStateCompactionMask: ULONG64) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetEnabledXStateFeatures() callconv(.Stdcall) DWORD64;
pub extern "kernel32" fn GetXStateFeaturesMask(Context: PCONTEXT, FeatureMask: PDWORD64) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn LocateXStateFeature(Context: PCONTEXT, FeatureId: DWORD, Length: PDWORD) callconv(.Stdcall) PVOID;
pub extern "kernel32" fn SetXStateFeaturesMask(Context: PCONTEXT, FeatureMask: DWORD64) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnableThreadProfiling(ThreadHandle: HANDLE, Flags: DWORD, HardwareCounters: DWORD64, PerformanceDataHandle: [*c]HANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn DisableThreadProfiling(PerformanceDataHandle: HANDLE) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn QueryThreadProfiling(ThreadHandle: HANDLE, Enabled: PBOOLEAN) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn ReadThreadProfilingData(PerformanceDataHandle: HANDLE, Flags: DWORD, PerformanceData: PPERFORMANCE_DATA) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn RaiseCustomSystemEventTrigger(CustomSystemEventTriggerConfig: PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG) callconv(.Stdcall) DWORD;
pub const struct__DRAWPATRECT = extern struct {
    ptPosition: POINT,
    ptSize: POINT,
    wStyle: WORD,
    wPattern: WORD,
};
pub const DRAWPATRECT = struct__DRAWPATRECT;
pub const PDRAWPATRECT = [*c]struct__DRAWPATRECT;
pub const struct__PSINJECTDATA = extern struct {
    DataBytes: DWORD,
    InjectionPoint: WORD,
    PageNumber: WORD,
};
pub const PSINJECTDATA = struct__PSINJECTDATA;
pub const PPSINJECTDATA = [*c]struct__PSINJECTDATA;
pub const struct__PSFEATURE_OUTPUT = extern struct {
    bPageIndependent: BOOL,
    bSetPageDevice: BOOL,
};
pub const PSFEATURE_OUTPUT = struct__PSFEATURE_OUTPUT;
pub const PPSFEATURE_OUTPUT = [*c]struct__PSFEATURE_OUTPUT;
pub const struct__PSFEATURE_CUSTPAPER = extern struct {
    lOrientation: LONG,
    lWidth: LONG,
    lHeight: LONG,
    lWidthOffset: LONG,
    lHeightOffset: LONG,
};
pub const PSFEATURE_CUSTPAPER = struct__PSFEATURE_CUSTPAPER;
pub const PPSFEATURE_CUSTPAPER = [*c]struct__PSFEATURE_CUSTPAPER;
pub const struct_tagXFORM = extern struct {
    eM11: FLOAT,
    eM12: FLOAT,
    eM21: FLOAT,
    eM22: FLOAT,
    eDx: FLOAT,
    eDy: FLOAT,
};
pub const XFORM = struct_tagXFORM;
pub const PXFORM = [*c]struct_tagXFORM;
pub const LPXFORM = [*c]struct_tagXFORM;
pub const struct_tagBITMAP = extern struct {
    bmType: LONG,
    bmWidth: LONG,
    bmHeight: LONG,
    bmWidthBytes: LONG,
    bmPlanes: WORD,
    bmBitsPixel: WORD,
    bmBits: LPVOID,
};
pub const BITMAP = struct_tagBITMAP;
pub const PBITMAP = [*c]struct_tagBITMAP;
pub const NPBITMAP = [*c]struct_tagBITMAP;
pub const LPBITMAP = [*c]struct_tagBITMAP;
pub const struct_tagRGBTRIPLE = extern struct {
    rgbtBlue: BYTE,
    rgbtGreen: BYTE,
    rgbtRed: BYTE,
};
pub const RGBTRIPLE = struct_tagRGBTRIPLE;
pub const PRGBTRIPLE = [*c]struct_tagRGBTRIPLE;
pub const NPRGBTRIPLE = [*c]struct_tagRGBTRIPLE;
pub const LPRGBTRIPLE = [*c]struct_tagRGBTRIPLE;
pub const struct_tagRGBQUAD = extern struct {
    rgbBlue: BYTE,
    rgbGreen: BYTE,
    rgbRed: BYTE,
    rgbReserved: BYTE,
};
pub const RGBQUAD = struct_tagRGBQUAD;
pub const LPRGBQUAD = [*c]RGBQUAD;
pub const LCSCSTYPE = LONG;
pub const LCSGAMUTMATCH = LONG;
pub const FXPT16DOT16 = c_long;
pub const LPFXPT16DOT16 = [*c]c_long;
pub const FXPT2DOT30 = c_long;
pub const LPFXPT2DOT30 = [*c]c_long;
pub const struct_tagCIEXYZ = extern struct {
    ciexyzX: FXPT2DOT30,
    ciexyzY: FXPT2DOT30,
    ciexyzZ: FXPT2DOT30,
};
pub const CIEXYZ = struct_tagCIEXYZ;
pub const LPCIEXYZ = [*c]CIEXYZ;
pub const struct_tagICEXYZTRIPLE = extern struct {
    ciexyzRed: CIEXYZ,
    ciexyzGreen: CIEXYZ,
    ciexyzBlue: CIEXYZ,
};
pub const CIEXYZTRIPLE = struct_tagICEXYZTRIPLE;
pub const LPCIEXYZTRIPLE = [*c]CIEXYZTRIPLE;
pub const struct_tagLOGCOLORSPACEA = extern struct {
    lcsSignature: DWORD,
    lcsVersion: DWORD,
    lcsSize: DWORD,
    lcsCSType: LCSCSTYPE,
    lcsIntent: LCSGAMUTMATCH,
    lcsEndpoints: CIEXYZTRIPLE,
    lcsGammaRed: DWORD,
    lcsGammaGreen: DWORD,
    lcsGammaBlue: DWORD,
    lcsFilename: [260]CHAR,
};
pub const LOGCOLORSPACEA = struct_tagLOGCOLORSPACEA;
pub const LPLOGCOLORSPACEA = [*c]struct_tagLOGCOLORSPACEA;
pub const struct_tagLOGCOLORSPACEW = extern struct {
    lcsSignature: DWORD,
    lcsVersion: DWORD,
    lcsSize: DWORD,
    lcsCSType: LCSCSTYPE,
    lcsIntent: LCSGAMUTMATCH,
    lcsEndpoints: CIEXYZTRIPLE,
    lcsGammaRed: DWORD,
    lcsGammaGreen: DWORD,
    lcsGammaBlue: DWORD,
    lcsFilename: [260]WCHAR,
};
pub const LOGCOLORSPACEW = struct_tagLOGCOLORSPACEW;
pub const LPLOGCOLORSPACEW = [*c]struct_tagLOGCOLORSPACEW;
pub const LOGCOLORSPACE = LOGCOLORSPACEA;
pub const LPLOGCOLORSPACE = LPLOGCOLORSPACEA;
pub const struct_tagBITMAPCOREHEADER = extern struct {
    bcSize: DWORD,
    bcWidth: WORD,
    bcHeight: WORD,
    bcPlanes: WORD,
    bcBitCount: WORD,
};
pub const BITMAPCOREHEADER = struct_tagBITMAPCOREHEADER;
pub const LPBITMAPCOREHEADER = [*c]struct_tagBITMAPCOREHEADER;
pub const PBITMAPCOREHEADER = [*c]struct_tagBITMAPCOREHEADER;
pub const struct_tagBITMAPINFOHEADER = extern struct {
    biSize: DWORD,
    biWidth: LONG,
    biHeight: LONG,
    biPlanes: WORD,
    biBitCount: WORD,
    biCompression: DWORD,
    biSizeImage: DWORD,
    biXPelsPerMeter: LONG,
    biYPelsPerMeter: LONG,
    biClrUsed: DWORD,
    biClrImportant: DWORD,
};
pub const BITMAPINFOHEADER = struct_tagBITMAPINFOHEADER;
pub const LPBITMAPINFOHEADER = [*c]struct_tagBITMAPINFOHEADER;
pub const PBITMAPINFOHEADER = [*c]struct_tagBITMAPINFOHEADER;
pub const BITMAPV4HEADER = extern struct {
    bV4Size: DWORD,
    bV4Width: LONG,
    bV4Height: LONG,
    bV4Planes: WORD,
    bV4BitCount: WORD,
    bV4V4Compression: DWORD,
    bV4SizeImage: DWORD,
    bV4XPelsPerMeter: LONG,
    bV4YPelsPerMeter: LONG,
    bV4ClrUsed: DWORD,
    bV4ClrImportant: DWORD,
    bV4RedMask: DWORD,
    bV4GreenMask: DWORD,
    bV4BlueMask: DWORD,
    bV4AlphaMask: DWORD,
    bV4CSType: DWORD,
    bV4Endpoints: CIEXYZTRIPLE,
    bV4GammaRed: DWORD,
    bV4GammaGreen: DWORD,
    bV4GammaBlue: DWORD,
};
pub const LPBITMAPV4HEADER = [*c]extern struct {
    bV4Size: DWORD,
    bV4Width: LONG,
    bV4Height: LONG,
    bV4Planes: WORD,
    bV4BitCount: WORD,
    bV4V4Compression: DWORD,
    bV4SizeImage: DWORD,
    bV4XPelsPerMeter: LONG,
    bV4YPelsPerMeter: LONG,
    bV4ClrUsed: DWORD,
    bV4ClrImportant: DWORD,
    bV4RedMask: DWORD,
    bV4GreenMask: DWORD,
    bV4BlueMask: DWORD,
    bV4AlphaMask: DWORD,
    bV4CSType: DWORD,
    bV4Endpoints: CIEXYZTRIPLE,
    bV4GammaRed: DWORD,
    bV4GammaGreen: DWORD,
    bV4GammaBlue: DWORD,
};
pub const PBITMAPV4HEADER = [*c]extern struct {
    bV4Size: DWORD,
    bV4Width: LONG,
    bV4Height: LONG,
    bV4Planes: WORD,
    bV4BitCount: WORD,
    bV4V4Compression: DWORD,
    bV4SizeImage: DWORD,
    bV4XPelsPerMeter: LONG,
    bV4YPelsPerMeter: LONG,
    bV4ClrUsed: DWORD,
    bV4ClrImportant: DWORD,
    bV4RedMask: DWORD,
    bV4GreenMask: DWORD,
    bV4BlueMask: DWORD,
    bV4AlphaMask: DWORD,
    bV4CSType: DWORD,
    bV4Endpoints: CIEXYZTRIPLE,
    bV4GammaRed: DWORD,
    bV4GammaGreen: DWORD,
    bV4GammaBlue: DWORD,
};
pub const BITMAPV5HEADER = extern struct {
    bV5Size: DWORD,
    bV5Width: LONG,
    bV5Height: LONG,
    bV5Planes: WORD,
    bV5BitCount: WORD,
    bV5Compression: DWORD,
    bV5SizeImage: DWORD,
    bV5XPelsPerMeter: LONG,
    bV5YPelsPerMeter: LONG,
    bV5ClrUsed: DWORD,
    bV5ClrImportant: DWORD,
    bV5RedMask: DWORD,
    bV5GreenMask: DWORD,
    bV5BlueMask: DWORD,
    bV5AlphaMask: DWORD,
    bV5CSType: DWORD,
    bV5Endpoints: CIEXYZTRIPLE,
    bV5GammaRed: DWORD,
    bV5GammaGreen: DWORD,
    bV5GammaBlue: DWORD,
    bV5Intent: DWORD,
    bV5ProfileData: DWORD,
    bV5ProfileSize: DWORD,
    bV5Reserved: DWORD,
};
pub const LPBITMAPV5HEADER = [*c]extern struct {
    bV5Size: DWORD,
    bV5Width: LONG,
    bV5Height: LONG,
    bV5Planes: WORD,
    bV5BitCount: WORD,
    bV5Compression: DWORD,
    bV5SizeImage: DWORD,
    bV5XPelsPerMeter: LONG,
    bV5YPelsPerMeter: LONG,
    bV5ClrUsed: DWORD,
    bV5ClrImportant: DWORD,
    bV5RedMask: DWORD,
    bV5GreenMask: DWORD,
    bV5BlueMask: DWORD,
    bV5AlphaMask: DWORD,
    bV5CSType: DWORD,
    bV5Endpoints: CIEXYZTRIPLE,
    bV5GammaRed: DWORD,
    bV5GammaGreen: DWORD,
    bV5GammaBlue: DWORD,
    bV5Intent: DWORD,
    bV5ProfileData: DWORD,
    bV5ProfileSize: DWORD,
    bV5Reserved: DWORD,
};
pub const PBITMAPV5HEADER = [*c]extern struct {
    bV5Size: DWORD,
    bV5Width: LONG,
    bV5Height: LONG,
    bV5Planes: WORD,
    bV5BitCount: WORD,
    bV5Compression: DWORD,
    bV5SizeImage: DWORD,
    bV5XPelsPerMeter: LONG,
    bV5YPelsPerMeter: LONG,
    bV5ClrUsed: DWORD,
    bV5ClrImportant: DWORD,
    bV5RedMask: DWORD,
    bV5GreenMask: DWORD,
    bV5BlueMask: DWORD,
    bV5AlphaMask: DWORD,
    bV5CSType: DWORD,
    bV5Endpoints: CIEXYZTRIPLE,
    bV5GammaRed: DWORD,
    bV5GammaGreen: DWORD,
    bV5GammaBlue: DWORD,
    bV5Intent: DWORD,
    bV5ProfileData: DWORD,
    bV5ProfileSize: DWORD,
    bV5Reserved: DWORD,
};
pub const struct_tagBITMAPINFO = extern struct {
    bmiHeader: BITMAPINFOHEADER,
    bmiColors: [1]RGBQUAD,
};
pub const BITMAPINFO = struct_tagBITMAPINFO;
pub const LPBITMAPINFO = [*c]struct_tagBITMAPINFO;
pub const PBITMAPINFO = [*c]struct_tagBITMAPINFO;
pub const struct_tagBITMAPCOREINFO = extern struct {
    bmciHeader: BITMAPCOREHEADER,
    bmciColors: [1]RGBTRIPLE,
};
pub const BITMAPCOREINFO = struct_tagBITMAPCOREINFO;
pub const LPBITMAPCOREINFO = [*c]struct_tagBITMAPCOREINFO;
pub const PBITMAPCOREINFO = [*c]struct_tagBITMAPCOREINFO;
pub const struct_tagBITMAPFILEHEADER = extern struct {
    bfType: WORD,
    bfSize: DWORD,
    bfReserved1: WORD,
    bfReserved2: WORD,
    bfOffBits: DWORD,
};
pub const BITMAPFILEHEADER = struct_tagBITMAPFILEHEADER;
pub const LPBITMAPFILEHEADER = [*c]struct_tagBITMAPFILEHEADER;
pub const PBITMAPFILEHEADER = [*c]struct_tagBITMAPFILEHEADER;
pub const struct_tagFONTSIGNATURE = extern struct {
    fsUsb: [4]DWORD,
    fsCsb: [2]DWORD,
};
pub const FONTSIGNATURE = struct_tagFONTSIGNATURE;
pub const PFONTSIGNATURE = [*c]struct_tagFONTSIGNATURE;
pub const LPFONTSIGNATURE = [*c]struct_tagFONTSIGNATURE;
pub const struct_tagCHARSETINFO = extern struct {
    ciCharset: UINT,
    ciACP: UINT,
    fs: FONTSIGNATURE,
};
pub const CHARSETINFO = struct_tagCHARSETINFO;
pub const PCHARSETINFO = [*c]struct_tagCHARSETINFO;
pub const NPCHARSETINFO = [*c]struct_tagCHARSETINFO;
pub const LPCHARSETINFO = [*c]struct_tagCHARSETINFO;
pub const struct_tagLOCALESIGNATURE = extern struct {
    lsUsb: [4]DWORD,
    lsCsbDefault: [2]DWORD,
    lsCsbSupported: [2]DWORD,
};
pub const LOCALESIGNATURE = struct_tagLOCALESIGNATURE;
pub const PLOCALESIGNATURE = [*c]struct_tagLOCALESIGNATURE;
pub const LPLOCALESIGNATURE = [*c]struct_tagLOCALESIGNATURE;
pub const struct_tagHANDLETABLE = extern struct {
    objectHandle: [1]HGDIOBJ,
};
pub const HANDLETABLE = struct_tagHANDLETABLE;
pub const PHANDLETABLE = [*c]struct_tagHANDLETABLE;
pub const LPHANDLETABLE = [*c]struct_tagHANDLETABLE;
pub const struct_tagMETARECORD = extern struct {
    rdSize: DWORD,
    rdFunction: WORD,
    rdParm: [1]WORD,
};
pub const METARECORD = struct_tagMETARECORD;
pub const PMETARECORD = [*c]struct_tagMETARECORD;
pub const LPMETARECORD = [*c]struct_tagMETARECORD;
pub const struct_tagMETAFILEPICT = extern struct {
    mm: LONG,
    xExt: LONG,
    yExt: LONG,
    hMF: HMETAFILE,
};
pub const METAFILEPICT = struct_tagMETAFILEPICT;
pub const LPMETAFILEPICT = [*c]struct_tagMETAFILEPICT;
pub const struct_tagMETAHEADER = extern struct {
    mtType: WORD,
    mtHeaderSize: WORD,
    mtVersion: WORD,
    mtSize: DWORD,
    mtNoObjects: WORD,
    mtMaxRecord: DWORD,
    mtNoParameters: WORD,
};
pub const METAHEADER = struct_tagMETAHEADER;
pub const PMETAHEADER = [*c]struct_tagMETAHEADER;
pub const LPMETAHEADER = [*c]struct_tagMETAHEADER;
pub const struct_tagENHMETARECORD = extern struct {
    iType: DWORD,
    nSize: DWORD,
    dParm: [1]DWORD,
};
pub const ENHMETARECORD = struct_tagENHMETARECORD;
pub const PENHMETARECORD = [*c]struct_tagENHMETARECORD;
pub const LPENHMETARECORD = [*c]struct_tagENHMETARECORD;
pub const struct_tagENHMETAHEADER = extern struct {
    iType: DWORD,
    nSize: DWORD,
    rclBounds: RECTL,
    rclFrame: RECTL,
    dSignature: DWORD,
    nVersion: DWORD,
    nBytes: DWORD,
    nRecords: DWORD,
    nHandles: WORD,
    sReserved: WORD,
    nDescription: DWORD,
    offDescription: DWORD,
    nPalEntries: DWORD,
    szlDevice: SIZEL,
    szlMillimeters: SIZEL,
    cbPixelFormat: DWORD,
    offPixelFormat: DWORD,
    bOpenGL: DWORD,
    szlMicrometers: SIZEL,
};
pub const ENHMETAHEADER = struct_tagENHMETAHEADER;
pub const PENHMETAHEADER = [*c]struct_tagENHMETAHEADER;
pub const LPENHMETAHEADER = [*c]struct_tagENHMETAHEADER;
pub const BCHAR = BYTE;
pub const struct_tagTEXTMETRICA = extern struct {
    tmHeight: LONG,
    tmAscent: LONG,
    tmDescent: LONG,
    tmInternalLeading: LONG,
    tmExternalLeading: LONG,
    tmAveCharWidth: LONG,
    tmMaxCharWidth: LONG,
    tmWeight: LONG,
    tmOverhang: LONG,
    tmDigitizedAspectX: LONG,
    tmDigitizedAspectY: LONG,
    tmFirstChar: BYTE,
    tmLastChar: BYTE,
    tmDefaultChar: BYTE,
    tmBreakChar: BYTE,
    tmItalic: BYTE,
    tmUnderlined: BYTE,
    tmStruckOut: BYTE,
    tmPitchAndFamily: BYTE,
    tmCharSet: BYTE,
};
pub const TEXTMETRICA = struct_tagTEXTMETRICA;
pub const PTEXTMETRICA = [*c]struct_tagTEXTMETRICA;
pub const NPTEXTMETRICA = [*c]struct_tagTEXTMETRICA;
pub const LPTEXTMETRICA = [*c]struct_tagTEXTMETRICA;
pub const struct_tagTEXTMETRICW = extern struct {
    tmHeight: LONG,
    tmAscent: LONG,
    tmDescent: LONG,
    tmInternalLeading: LONG,
    tmExternalLeading: LONG,
    tmAveCharWidth: LONG,
    tmMaxCharWidth: LONG,
    tmWeight: LONG,
    tmOverhang: LONG,
    tmDigitizedAspectX: LONG,
    tmDigitizedAspectY: LONG,
    tmFirstChar: WCHAR,
    tmLastChar: WCHAR,
    tmDefaultChar: WCHAR,
    tmBreakChar: WCHAR,
    tmItalic: BYTE,
    tmUnderlined: BYTE,
    tmStruckOut: BYTE,
    tmPitchAndFamily: BYTE,
    tmCharSet: BYTE,
};
pub const TEXTMETRICW = struct_tagTEXTMETRICW;
pub const PTEXTMETRICW = [*c]struct_tagTEXTMETRICW;
pub const NPTEXTMETRICW = [*c]struct_tagTEXTMETRICW;
pub const LPTEXTMETRICW = [*c]struct_tagTEXTMETRICW;
pub const TEXTMETRIC = TEXTMETRICA;
pub const PTEXTMETRIC = PTEXTMETRICA;
pub const NPTEXTMETRIC = NPTEXTMETRICA;
pub const LPTEXTMETRIC = LPTEXTMETRICA;
pub const struct_tagNEWTEXTMETRICA = extern struct {
    tmHeight: LONG,
    tmAscent: LONG,
    tmDescent: LONG,
    tmInternalLeading: LONG,
    tmExternalLeading: LONG,
    tmAveCharWidth: LONG,
    tmMaxCharWidth: LONG,
    tmWeight: LONG,
    tmOverhang: LONG,
    tmDigitizedAspectX: LONG,
    tmDigitizedAspectY: LONG,
    tmFirstChar: BYTE,
    tmLastChar: BYTE,
    tmDefaultChar: BYTE,
    tmBreakChar: BYTE,
    tmItalic: BYTE,
    tmUnderlined: BYTE,
    tmStruckOut: BYTE,
    tmPitchAndFamily: BYTE,
    tmCharSet: BYTE,
    ntmFlags: DWORD,
    ntmSizeEM: UINT,
    ntmCellHeight: UINT,
    ntmAvgWidth: UINT,
};
pub const NEWTEXTMETRICA = struct_tagNEWTEXTMETRICA;
pub const PNEWTEXTMETRICA = [*c]struct_tagNEWTEXTMETRICA;
pub const NPNEWTEXTMETRICA = [*c]struct_tagNEWTEXTMETRICA;
pub const LPNEWTEXTMETRICA = [*c]struct_tagNEWTEXTMETRICA;
pub const struct_tagNEWTEXTMETRICW = extern struct {
    tmHeight: LONG,
    tmAscent: LONG,
    tmDescent: LONG,
    tmInternalLeading: LONG,
    tmExternalLeading: LONG,
    tmAveCharWidth: LONG,
    tmMaxCharWidth: LONG,
    tmWeight: LONG,
    tmOverhang: LONG,
    tmDigitizedAspectX: LONG,
    tmDigitizedAspectY: LONG,
    tmFirstChar: WCHAR,
    tmLastChar: WCHAR,
    tmDefaultChar: WCHAR,
    tmBreakChar: WCHAR,
    tmItalic: BYTE,
    tmUnderlined: BYTE,
    tmStruckOut: BYTE,
    tmPitchAndFamily: BYTE,
    tmCharSet: BYTE,
    ntmFlags: DWORD,
    ntmSizeEM: UINT,
    ntmCellHeight: UINT,
    ntmAvgWidth: UINT,
};
pub const NEWTEXTMETRICW = struct_tagNEWTEXTMETRICW;
pub const PNEWTEXTMETRICW = [*c]struct_tagNEWTEXTMETRICW;
pub const NPNEWTEXTMETRICW = [*c]struct_tagNEWTEXTMETRICW;
pub const LPNEWTEXTMETRICW = [*c]struct_tagNEWTEXTMETRICW;
pub const NEWTEXTMETRIC = NEWTEXTMETRICA;
pub const PNEWTEXTMETRIC = PNEWTEXTMETRICA;
pub const NPNEWTEXTMETRIC = NPNEWTEXTMETRICA;
pub const LPNEWTEXTMETRIC = LPNEWTEXTMETRICA;
pub const struct_tagNEWTEXTMETRICEXA = extern struct {
    ntmTm: NEWTEXTMETRICA,
    ntmFontSig: FONTSIGNATURE,
};
pub const NEWTEXTMETRICEXA = struct_tagNEWTEXTMETRICEXA;
pub const struct_tagNEWTEXTMETRICEXW = extern struct {
    ntmTm: NEWTEXTMETRICW,
    ntmFontSig: FONTSIGNATURE,
};
pub const NEWTEXTMETRICEXW = struct_tagNEWTEXTMETRICEXW;
pub const NEWTEXTMETRICEX = NEWTEXTMETRICEXA;
pub const struct_tagPELARRAY = extern struct {
    paXCount: LONG,
    paYCount: LONG,
    paXExt: LONG,
    paYExt: LONG,
    paRGBs: BYTE,
};
pub const PELARRAY = struct_tagPELARRAY;
pub const PPELARRAY = [*c]struct_tagPELARRAY;
pub const NPPELARRAY = [*c]struct_tagPELARRAY;
pub const LPPELARRAY = [*c]struct_tagPELARRAY;
pub const struct_tagLOGBRUSH = extern struct {
    lbStyle: UINT,
    lbColor: COLORREF,
    lbHatch: ULONG_PTR,
};
pub const LOGBRUSH = struct_tagLOGBRUSH;
pub const PLOGBRUSH = [*c]struct_tagLOGBRUSH;
pub const NPLOGBRUSH = [*c]struct_tagLOGBRUSH;
pub const LPLOGBRUSH = [*c]struct_tagLOGBRUSH;
pub const struct_tagLOGBRUSH32 = extern struct {
    lbStyle: UINT,
    lbColor: COLORREF,
    lbHatch: ULONG,
};
pub const LOGBRUSH32 = struct_tagLOGBRUSH32;
pub const PLOGBRUSH32 = [*c]struct_tagLOGBRUSH32;
pub const NPLOGBRUSH32 = [*c]struct_tagLOGBRUSH32;
pub const LPLOGBRUSH32 = [*c]struct_tagLOGBRUSH32;
pub const PATTERN = LOGBRUSH;
pub const PPATTERN = [*c]PATTERN;
pub const NPPATTERN = [*c]PATTERN;
pub const LPPATTERN = [*c]PATTERN;
pub const struct_tagLOGPEN = extern struct {
    lopnStyle: UINT,
    lopnWidth: POINT,
    lopnColor: COLORREF,
};
pub const LOGPEN = struct_tagLOGPEN;
pub const PLOGPEN = [*c]struct_tagLOGPEN;
pub const NPLOGPEN = [*c]struct_tagLOGPEN;
pub const LPLOGPEN = [*c]struct_tagLOGPEN;
pub const struct_tagEXTLOGPEN = extern struct {
    elpPenStyle: DWORD,
    elpWidth: DWORD,
    elpBrushStyle: UINT,
    elpColor: COLORREF,
    elpHatch: ULONG_PTR,
    elpNumEntries: DWORD,
    elpStyleEntry: [1]DWORD,
};
pub const EXTLOGPEN = struct_tagEXTLOGPEN;
pub const PEXTLOGPEN = [*c]struct_tagEXTLOGPEN;
pub const NPEXTLOGPEN = [*c]struct_tagEXTLOGPEN;
pub const LPEXTLOGPEN = [*c]struct_tagEXTLOGPEN;
pub const struct_tagEXTLOGPEN32 = extern struct {
    elpPenStyle: DWORD,
    elpWidth: DWORD,
    elpBrushStyle: UINT,
    elpColor: COLORREF,
    elpHatch: ULONG,
    elpNumEntries: DWORD,
    elpStyleEntry: [1]DWORD,
};
pub const EXTLOGPEN32 = struct_tagEXTLOGPEN32;
pub const PEXTLOGPEN32 = [*c]struct_tagEXTLOGPEN32;
pub const NPEXTLOGPEN32 = [*c]struct_tagEXTLOGPEN32;
pub const LPEXTLOGPEN32 = [*c]struct_tagEXTLOGPEN32;
pub const struct_tagPALETTEENTRY = extern struct {
    peRed: BYTE,
    peGreen: BYTE,
    peBlue: BYTE,
    peFlags: BYTE,
};
pub const PALETTEENTRY = struct_tagPALETTEENTRY;
pub const PPALETTEENTRY = [*c]struct_tagPALETTEENTRY;
pub const LPPALETTEENTRY = [*c]struct_tagPALETTEENTRY;
pub const struct_tagLOGPALETTE = extern struct {
    palVersion: WORD,
    palNumEntries: WORD,
    palPalEntry: [1]PALETTEENTRY,
};
pub const LOGPALETTE = struct_tagLOGPALETTE;
pub const PLOGPALETTE = [*c]struct_tagLOGPALETTE;
pub const NPLOGPALETTE = [*c]struct_tagLOGPALETTE;
pub const LPLOGPALETTE = [*c]struct_tagLOGPALETTE;
pub const struct_tagLOGFONTA = extern struct {
    lfHeight: LONG,
    lfWidth: LONG,
    lfEscapement: LONG,
    lfOrientation: LONG,
    lfWeight: LONG,
    lfItalic: BYTE,
    lfUnderline: BYTE,
    lfStrikeOut: BYTE,
    lfCharSet: BYTE,
    lfOutPrecision: BYTE,
    lfClipPrecision: BYTE,
    lfQuality: BYTE,
    lfPitchAndFamily: BYTE,
    lfFaceName: [32]CHAR,
};
pub const LOGFONTA = struct_tagLOGFONTA;
pub const PLOGFONTA = [*c]struct_tagLOGFONTA;
pub const NPLOGFONTA = [*c]struct_tagLOGFONTA;
pub const LPLOGFONTA = [*c]struct_tagLOGFONTA;
pub const struct_tagLOGFONTW = extern struct {
    lfHeight: LONG,
    lfWidth: LONG,
    lfEscapement: LONG,
    lfOrientation: LONG,
    lfWeight: LONG,
    lfItalic: BYTE,
    lfUnderline: BYTE,
    lfStrikeOut: BYTE,
    lfCharSet: BYTE,
    lfOutPrecision: BYTE,
    lfClipPrecision: BYTE,
    lfQuality: BYTE,
    lfPitchAndFamily: BYTE,
    lfFaceName: [32]WCHAR,
};
pub const LOGFONTW = struct_tagLOGFONTW;
pub const PLOGFONTW = [*c]struct_tagLOGFONTW;
pub const NPLOGFONTW = [*c]struct_tagLOGFONTW;
pub const LPLOGFONTW = [*c]struct_tagLOGFONTW;
pub const LOGFONT = LOGFONTA;
pub const PLOGFONT = PLOGFONTA;
pub const NPLOGFONT = NPLOGFONTA;
pub const LPLOGFONT = LPLOGFONTA;
pub const struct_tagENUMLOGFONTA = extern struct {
    elfLogFont: LOGFONTA,
    elfFullName: [64]BYTE,
    elfStyle: [32]BYTE,
};
pub const ENUMLOGFONTA = struct_tagENUMLOGFONTA;
pub const LPENUMLOGFONTA = [*c]struct_tagENUMLOGFONTA;
pub const struct_tagENUMLOGFONTW = extern struct {
    elfLogFont: LOGFONTW,
    elfFullName: [64]WCHAR,
    elfStyle: [32]WCHAR,
};
pub const ENUMLOGFONTW = struct_tagENUMLOGFONTW;
pub const LPENUMLOGFONTW = [*c]struct_tagENUMLOGFONTW;
pub const ENUMLOGFONT = ENUMLOGFONTA;
pub const LPENUMLOGFONT = LPENUMLOGFONTA;
pub const struct_tagENUMLOGFONTEXA = extern struct {
    elfLogFont: LOGFONTA,
    elfFullName: [64]BYTE,
    elfStyle: [32]BYTE,
    elfScript: [32]BYTE,
};
pub const ENUMLOGFONTEXA = struct_tagENUMLOGFONTEXA;
pub const LPENUMLOGFONTEXA = [*c]struct_tagENUMLOGFONTEXA;
pub const struct_tagENUMLOGFONTEXW = extern struct {
    elfLogFont: LOGFONTW,
    elfFullName: [64]WCHAR,
    elfStyle: [32]WCHAR,
    elfScript: [32]WCHAR,
};
pub const ENUMLOGFONTEXW = struct_tagENUMLOGFONTEXW;
pub const LPENUMLOGFONTEXW = [*c]struct_tagENUMLOGFONTEXW;
pub const ENUMLOGFONTEX = ENUMLOGFONTEXA;
pub const LPENUMLOGFONTEX = LPENUMLOGFONTEXA;
pub const struct_tagPANOSE = extern struct {
    bFamilyType: BYTE,
    bSerifStyle: BYTE,
    bWeight: BYTE,
    bProportion: BYTE,
    bContrast: BYTE,
    bStrokeVariation: BYTE,
    bArmStyle: BYTE,
    bLetterform: BYTE,
    bMidline: BYTE,
    bXHeight: BYTE,
};
pub const PANOSE = struct_tagPANOSE;
pub const LPPANOSE = [*c]struct_tagPANOSE;
pub const struct_tagEXTLOGFONTA = extern struct {
    elfLogFont: LOGFONTA,
    elfFullName: [64]BYTE,
    elfStyle: [32]BYTE,
    elfVersion: DWORD,
    elfStyleSize: DWORD,
    elfMatch: DWORD,
    elfReserved: DWORD,
    elfVendorId: [4]BYTE,
    elfCulture: DWORD,
    elfPanose: PANOSE,
};
pub const EXTLOGFONTA = struct_tagEXTLOGFONTA;
pub const PEXTLOGFONTA = [*c]struct_tagEXTLOGFONTA;
pub const NPEXTLOGFONTA = [*c]struct_tagEXTLOGFONTA;
pub const LPEXTLOGFONTA = [*c]struct_tagEXTLOGFONTA;
pub const struct_tagEXTLOGFONTW = extern struct {
    elfLogFont: LOGFONTW,
    elfFullName: [64]WCHAR,
    elfStyle: [32]WCHAR,
    elfVersion: DWORD,
    elfStyleSize: DWORD,
    elfMatch: DWORD,
    elfReserved: DWORD,
    elfVendorId: [4]BYTE,
    elfCulture: DWORD,
    elfPanose: PANOSE,
};
pub const EXTLOGFONTW = struct_tagEXTLOGFONTW;
pub const PEXTLOGFONTW = [*c]struct_tagEXTLOGFONTW;
pub const NPEXTLOGFONTW = [*c]struct_tagEXTLOGFONTW;
pub const LPEXTLOGFONTW = [*c]struct_tagEXTLOGFONTW;
pub const EXTLOGFONT = EXTLOGFONTA;
pub const PEXTLOGFONT = PEXTLOGFONTA;
pub const NPEXTLOGFONT = NPEXTLOGFONTA;
pub const LPEXTLOGFONT = LPEXTLOGFONTA;
pub const struct__devicemodeA = extern struct {
    dmDeviceName: [32]BYTE,
    dmSpecVersion: WORD,
    dmDriverVersion: WORD,
    dmSize: WORD,
    dmDriverExtra: WORD,
    dmFields: DWORD,
    @"": extern union {
        @"": extern struct {
            dmOrientation: c_short,
            dmPaperSize: c_short,
            dmPaperLength: c_short,
            dmPaperWidth: c_short,
            dmScale: c_short,
            dmCopies: c_short,
            dmDefaultSource: c_short,
            dmPrintQuality: c_short,
        },
        @"": extern struct {
            dmPosition: POINTL,
            dmDisplayOrientation: DWORD,
            dmDisplayFixedOutput: DWORD,
        },
    },
    dmColor: c_short,
    dmDuplex: c_short,
    dmYResolution: c_short,
    dmTTOption: c_short,
    dmCollate: c_short,
    dmFormName: [32]BYTE,
    dmLogPixels: WORD,
    dmBitsPerPel: DWORD,
    dmPelsWidth: DWORD,
    dmPelsHeight: DWORD,
    @"": extern union {
        dmDisplayFlags: DWORD,
        dmNup: DWORD,
    },
    dmDisplayFrequency: DWORD,
    dmICMMethod: DWORD,
    dmICMIntent: DWORD,
    dmMediaType: DWORD,
    dmDitherType: DWORD,
    dmReserved1: DWORD,
    dmReserved2: DWORD,
    dmPanningWidth: DWORD,
    dmPanningHeight: DWORD,
};
pub const DEVMODEA = struct__devicemodeA;
pub const PDEVMODEA = [*c]struct__devicemodeA;
pub const NPDEVMODEA = [*c]struct__devicemodeA;
pub const LPDEVMODEA = [*c]struct__devicemodeA;
pub const struct__devicemodeW = extern struct {
    dmDeviceName: [32]WCHAR,
    dmSpecVersion: WORD,
    dmDriverVersion: WORD,
    dmSize: WORD,
    dmDriverExtra: WORD,
    dmFields: DWORD,
    @"": extern union {
        @"": extern struct {
            dmOrientation: c_short,
            dmPaperSize: c_short,
            dmPaperLength: c_short,
            dmPaperWidth: c_short,
            dmScale: c_short,
            dmCopies: c_short,
            dmDefaultSource: c_short,
            dmPrintQuality: c_short,
        },
        @"": extern struct {
            dmPosition: POINTL,
            dmDisplayOrientation: DWORD,
            dmDisplayFixedOutput: DWORD,
        },
    },
    dmColor: c_short,
    dmDuplex: c_short,
    dmYResolution: c_short,
    dmTTOption: c_short,
    dmCollate: c_short,
    dmFormName: [32]WCHAR,
    dmLogPixels: WORD,
    dmBitsPerPel: DWORD,
    dmPelsWidth: DWORD,
    dmPelsHeight: DWORD,
    @"": extern union {
        dmDisplayFlags: DWORD,
        dmNup: DWORD,
    },
    dmDisplayFrequency: DWORD,
    dmICMMethod: DWORD,
    dmICMIntent: DWORD,
    dmMediaType: DWORD,
    dmDitherType: DWORD,
    dmReserved1: DWORD,
    dmReserved2: DWORD,
    dmPanningWidth: DWORD,
    dmPanningHeight: DWORD,
};
pub const DEVMODEW = struct__devicemodeW;
pub const PDEVMODEW = [*c]struct__devicemodeW;
pub const NPDEVMODEW = [*c]struct__devicemodeW;
pub const LPDEVMODEW = [*c]struct__devicemodeW;
pub const DEVMODE = DEVMODEA;
pub const PDEVMODE = PDEVMODEA;
pub const NPDEVMODE = NPDEVMODEA;
pub const LPDEVMODE = LPDEVMODEA;
pub const struct__DISPLAY_DEVICEA = extern struct {
    cb: DWORD,
    DeviceName: [32]CHAR,
    DeviceString: [128]CHAR,
    StateFlags: DWORD,
    DeviceID: [128]CHAR,
    DeviceKey: [128]CHAR,
};
pub const DISPLAY_DEVICEA = struct__DISPLAY_DEVICEA;
pub const PDISPLAY_DEVICEA = [*c]struct__DISPLAY_DEVICEA;
pub const LPDISPLAY_DEVICEA = [*c]struct__DISPLAY_DEVICEA;
pub const struct__DISPLAY_DEVICEW = extern struct {
    cb: DWORD,
    DeviceName: [32]WCHAR,
    DeviceString: [128]WCHAR,
    StateFlags: DWORD,
    DeviceID: [128]WCHAR,
    DeviceKey: [128]WCHAR,
};
pub const DISPLAY_DEVICEW = struct__DISPLAY_DEVICEW;
pub const PDISPLAY_DEVICEW = [*c]struct__DISPLAY_DEVICEW;
pub const LPDISPLAY_DEVICEW = [*c]struct__DISPLAY_DEVICEW;
pub const DISPLAY_DEVICE = DISPLAY_DEVICEA;
pub const PDISPLAY_DEVICE = PDISPLAY_DEVICEA;
pub const LPDISPLAY_DEVICE = LPDISPLAY_DEVICEA;
pub const struct_DISPLAYCONFIG_RATIONAL = extern struct {
    Numerator: UINT32,
    Denominator: UINT32,
};
pub const DISPLAYCONFIG_RATIONAL = struct_DISPLAYCONFIG_RATIONAL;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER = -1;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 = 0;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO = 1;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO = 2;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO = 3;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI = 4;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI = 5;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS = 6;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN = 8;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI = 9;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL = 10;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED = 11;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL = 12;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED = 13;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE = 14;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST = 15;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED = 16;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL = 17;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL = -2147483648;
pub const DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32 = -1;
pub const DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY = extern enum {
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER = -1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 = 0,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO = 1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO = 2,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO = 3,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI = 4,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI = 5,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS = 6,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN = 8,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI = 9,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL = 10,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED = 11,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL = 12,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED = 13,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE = 14,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST = 15,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED = 16,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL = 17,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL = -2147483648,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32 = -1,
};
pub const DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0;
pub const DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1;
pub const DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2;
pub const DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = 2;
pub const DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 3;
pub const DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = -1;
pub const DISPLAYCONFIG_SCANLINE_ORDERING = extern enum {
    DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0,
    DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = 2,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 3,
    DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = -1,
};
pub const struct_DISPLAYCONFIG_2DREGION = extern struct {
    cx: UINT32,
    cy: UINT32,
};
pub const DISPLAYCONFIG_2DREGION = struct_DISPLAYCONFIG_2DREGION;
pub const struct_DISPLAYCONFIG_VIDEO_SIGNAL_INFO = extern struct {
    pixelRate: UINT64,
    hSyncFreq: DISPLAYCONFIG_RATIONAL,
    vSyncFreq: DISPLAYCONFIG_RATIONAL,
    activeSize: DISPLAYCONFIG_2DREGION,
    totalSize: DISPLAYCONFIG_2DREGION,
    @"": extern union {
        AdditionalSignalInfo: @OpaqueType(),
        videoStandard: UINT32,
    },
    scanLineOrdering: DISPLAYCONFIG_SCANLINE_ORDERING,
};
pub const DISPLAYCONFIG_VIDEO_SIGNAL_INFO = struct_DISPLAYCONFIG_VIDEO_SIGNAL_INFO;
pub const DISPLAYCONFIG_SCALING_IDENTITY = 1;
pub const DISPLAYCONFIG_SCALING_CENTERED = 2;
pub const DISPLAYCONFIG_SCALING_STRETCHED = 3;
pub const DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX = 4;
pub const DISPLAYCONFIG_SCALING_CUSTOM = 5;
pub const DISPLAYCONFIG_SCALING_PREFERRED = 128;
pub const DISPLAYCONFIG_SCALING_FORCE_UINT32 = -1;
pub const DISPLAYCONFIG_SCALING = extern enum {
    DISPLAYCONFIG_SCALING_IDENTITY = 1,
    DISPLAYCONFIG_SCALING_CENTERED = 2,
    DISPLAYCONFIG_SCALING_STRETCHED = 3,
    DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX = 4,
    DISPLAYCONFIG_SCALING_CUSTOM = 5,
    DISPLAYCONFIG_SCALING_PREFERRED = 128,
    DISPLAYCONFIG_SCALING_FORCE_UINT32 = -1,
};
pub const DISPLAYCONFIG_ROTATION_IDENTITY = 1;
pub const DISPLAYCONFIG_ROTATION_ROTATE90 = 2;
pub const DISPLAYCONFIG_ROTATION_ROTATE180 = 3;
pub const DISPLAYCONFIG_ROTATION_ROTATE270 = 4;
pub const DISPLAYCONFIG_ROTATION_FORCE_UINT32 = -1;
pub const DISPLAYCONFIG_ROTATION = extern enum {
    DISPLAYCONFIG_ROTATION_IDENTITY = 1,
    DISPLAYCONFIG_ROTATION_ROTATE90 = 2,
    DISPLAYCONFIG_ROTATION_ROTATE180 = 3,
    DISPLAYCONFIG_ROTATION_ROTATE270 = 4,
    DISPLAYCONFIG_ROTATION_FORCE_UINT32 = -1,
};
pub const DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = 1;
pub const DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = 2;
pub const DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE = 3;
pub const DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = -1;
pub const DISPLAYCONFIG_MODE_INFO_TYPE = extern enum {
    DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = 1,
    DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = 2,
    DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE = 3,
    DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = -1,
};
pub const DISPLAYCONFIG_PIXELFORMAT_8BPP = 1;
pub const DISPLAYCONFIG_PIXELFORMAT_16BPP = 2;
pub const DISPLAYCONFIG_PIXELFORMAT_24BPP = 3;
pub const DISPLAYCONFIG_PIXELFORMAT_32BPP = 4;
pub const DISPLAYCONFIG_PIXELFORMAT_NONGDI = 5;
pub const DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32 = -1;
pub const DISPLAYCONFIG_PIXELFORMAT = extern enum {
    DISPLAYCONFIG_PIXELFORMAT_8BPP = 1,
    DISPLAYCONFIG_PIXELFORMAT_16BPP = 2,
    DISPLAYCONFIG_PIXELFORMAT_24BPP = 3,
    DISPLAYCONFIG_PIXELFORMAT_32BPP = 4,
    DISPLAYCONFIG_PIXELFORMAT_NONGDI = 5,
    DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32 = -1,
};
pub const struct_DISPLAYCONFIG_SOURCE_MODE = extern struct {
    width: UINT32,
    height: UINT32,
    pixelFormat: DISPLAYCONFIG_PIXELFORMAT,
    position: POINTL,
};
pub const DISPLAYCONFIG_SOURCE_MODE = struct_DISPLAYCONFIG_SOURCE_MODE;
pub const struct_DISPLAYCONFIG_TARGET_MODE = extern struct {
    targetVideoSignalInfo: DISPLAYCONFIG_VIDEO_SIGNAL_INFO,
};
pub const DISPLAYCONFIG_TARGET_MODE = struct_DISPLAYCONFIG_TARGET_MODE;
pub const struct_DISPLAYCONFIG_DESKTOP_IMAGE_INFO = extern struct {
    PathSourceSize: POINTL,
    DesktopImageRegion: RECTL,
    DesktopImageClip: RECTL,
};
pub const DISPLAYCONFIG_DESKTOP_IMAGE_INFO = struct_DISPLAYCONFIG_DESKTOP_IMAGE_INFO;
pub const struct_DISPLAYCONFIG_MODE_INFO = extern struct {
    infoType: DISPLAYCONFIG_MODE_INFO_TYPE,
    id: UINT32,
    adapterId: LUID,
    @"": extern union {
        targetMode: DISPLAYCONFIG_TARGET_MODE,
        sourceMode: DISPLAYCONFIG_SOURCE_MODE,
        desktopImageInfo: DISPLAYCONFIG_DESKTOP_IMAGE_INFO,
    },
};
pub const DISPLAYCONFIG_MODE_INFO = struct_DISPLAYCONFIG_MODE_INFO;
pub const struct_DISPLAYCONFIG_PATH_SOURCE_INFO = extern struct {
    adapterId: LUID,
    id: UINT32,
    @"": extern union {
        modeInfoIdx: UINT32,
        @"": @OpaqueType(),
    },
    statusFlags: UINT32,
};
pub const DISPLAYCONFIG_PATH_SOURCE_INFO = struct_DISPLAYCONFIG_PATH_SOURCE_INFO;
pub const struct_DISPLAYCONFIG_PATH_TARGET_INFO = extern struct {
    adapterId: LUID,
    id: UINT32,
    @"": extern union {
        modeInfoIdx: UINT32,
        @"": @OpaqueType(),
    },
    outputTechnology: DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY,
    rotation: DISPLAYCONFIG_ROTATION,
    scaling: DISPLAYCONFIG_SCALING,
    refreshRate: DISPLAYCONFIG_RATIONAL,
    scanLineOrdering: DISPLAYCONFIG_SCANLINE_ORDERING,
    targetAvailable: BOOL,
    statusFlags: UINT32,
};
pub const DISPLAYCONFIG_PATH_TARGET_INFO = struct_DISPLAYCONFIG_PATH_TARGET_INFO;
pub const struct_DISPLAYCONFIG_PATH_INFO = extern struct {
    sourceInfo: DISPLAYCONFIG_PATH_SOURCE_INFO,
    targetInfo: DISPLAYCONFIG_PATH_TARGET_INFO,
    flags: UINT32,
};
pub const DISPLAYCONFIG_PATH_INFO = struct_DISPLAYCONFIG_PATH_INFO;
pub const DISPLAYCONFIG_TOPOLOGY_INTERNAL = enum_DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_INTERNAL;
pub const DISPLAYCONFIG_TOPOLOGY_CLONE = enum_DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_CLONE;
pub const DISPLAYCONFIG_TOPOLOGY_EXTEND = enum_DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_EXTEND;
pub const DISPLAYCONFIG_TOPOLOGY_EXTERNAL = enum_DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_EXTERNAL;
pub const DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32 = enum_DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32;
pub const enum_DISPLAYCONFIG_TOPOLOGY_ID = extern enum {
    DISPLAYCONFIG_TOPOLOGY_INTERNAL = 1,
    DISPLAYCONFIG_TOPOLOGY_CLONE = 2,
    DISPLAYCONFIG_TOPOLOGY_EXTEND = 4,
    DISPLAYCONFIG_TOPOLOGY_EXTERNAL = 8,
    DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32 = -1,
};
pub const DISPLAYCONFIG_TOPOLOGY_ID = enum_DISPLAYCONFIG_TOPOLOGY_ID;
pub const DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = 1;
pub const DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = 2;
pub const DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE = 3;
pub const DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME = 4;
pub const DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE = 5;
pub const DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE = 6;
pub const DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION = 7;
pub const DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION = 8;
pub const DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO = 9;
pub const DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE = 10;
pub const DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL = 11;
pub const DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32 = -1;
pub const DISPLAYCONFIG_DEVICE_INFO_TYPE = extern enum {
    DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = 1,
    DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = 2,
    DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE = 3,
    DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME = 4,
    DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE = 5,
    DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE = 6,
    DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION = 7,
    DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION = 8,
    DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO = 9,
    DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE = 10,
    DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL = 11,
    DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32 = -1,
};
pub const struct_DISPLAYCONFIG_DEVICE_INFO_HEADER = extern struct {
    type: DISPLAYCONFIG_DEVICE_INFO_TYPE,
    size: UINT32,
    adapterId: LUID,
    id: UINT32,
};
pub const DISPLAYCONFIG_DEVICE_INFO_HEADER = struct_DISPLAYCONFIG_DEVICE_INFO_HEADER;
pub const struct_DISPLAYCONFIG_SOURCE_DEVICE_NAME = extern struct {
    header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    viewGdiDeviceName: [32]WCHAR,
};
pub const DISPLAYCONFIG_SOURCE_DEVICE_NAME = struct_DISPLAYCONFIG_SOURCE_DEVICE_NAME;
pub const struct_DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS = extern struct {
    @"": extern union {
        @"": @OpaqueType(),
        value: UINT32,
    },
};
pub const DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS = struct_DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS;
pub const struct_DISPLAYCONFIG_TARGET_DEVICE_NAME = extern struct {
    header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    flags: DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS,
    outputTechnology: DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY,
    edidManufactureId: UINT16,
    edidProductCodeId: UINT16,
    connectorInstance: UINT32,
    monitorFriendlyDeviceName: [64]WCHAR,
    monitorDevicePath: [128]WCHAR,
};
pub const DISPLAYCONFIG_TARGET_DEVICE_NAME = struct_DISPLAYCONFIG_TARGET_DEVICE_NAME;
pub const struct_DISPLAYCONFIG_TARGET_PREFERRED_MODE = extern struct {
    header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    width: UINT32,
    height: UINT32,
    targetMode: DISPLAYCONFIG_TARGET_MODE,
};
pub const DISPLAYCONFIG_TARGET_PREFERRED_MODE = struct_DISPLAYCONFIG_TARGET_PREFERRED_MODE;
pub const struct_DISPLAYCONFIG_ADAPTER_NAME = extern struct {
    header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    adapterDevicePath: [128]WCHAR,
};
pub const DISPLAYCONFIG_ADAPTER_NAME = struct_DISPLAYCONFIG_ADAPTER_NAME;
pub const struct_DISPLAYCONFIG_TARGET_BASE_TYPE = extern struct {
    header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    baseOutputTechnology: DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY,
};
pub const DISPLAYCONFIG_TARGET_BASE_TYPE = struct_DISPLAYCONFIG_TARGET_BASE_TYPE;
pub const struct_DISPLAYCONFIG_SET_TARGET_PERSISTENCE = extern struct {
    header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    @"": extern union {
        @"": @OpaqueType(),
        value: UINT32,
    },
};
pub const DISPLAYCONFIG_SET_TARGET_PERSISTENCE = struct_DISPLAYCONFIG_SET_TARGET_PERSISTENCE;
pub const struct_DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION = extern struct {
    header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    @"": extern union {
        @"": @OpaqueType(),
        value: UINT32,
    },
};
pub const DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION = struct_DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION;
pub const DISPLAYCONFIG_COLOR_ENCODING_RGB = enum__DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_RGB;
pub const DISPLAYCONFIG_COLOR_ENCODING_YCBCR444 = enum__DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_YCBCR444;
pub const DISPLAYCONFIG_COLOR_ENCODING_YCBCR422 = enum__DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_YCBCR422;
pub const DISPLAYCONFIG_COLOR_ENCODING_YCBCR420 = enum__DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_YCBCR420;
pub const DISPLAYCONFIG_COLOR_ENCODING_INTENSITY = enum__DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_INTENSITY;
pub const DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32 = enum__DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32;
pub const enum__DISPLAYCONFIG_COLOR_ENCODING = extern enum {
    DISPLAYCONFIG_COLOR_ENCODING_RGB = 0,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR444 = 1,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR422 = 2,
    DISPLAYCONFIG_COLOR_ENCODING_YCBCR420 = 3,
    DISPLAYCONFIG_COLOR_ENCODING_INTENSITY = 4,
    DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32 = -1,
};
pub const DISPLAYCONFIG_COLOR_ENCODING = enum__DISPLAYCONFIG_COLOR_ENCODING;
pub const struct__DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO = extern struct {
    header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    @"": extern union {
        @"": @OpaqueType(),
        value: UINT32,
    },
    colorEncoding: DISPLAYCONFIG_COLOR_ENCODING,
    bitsPerColorChannel: UINT32,
};
pub const DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO = struct__DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO;
pub const struct__DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE = extern struct {
    header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    @"": extern union {
        @"": @OpaqueType(),
        value: UINT32,
    },
};
pub const DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE = struct__DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE;
pub const struct__DISPLAYCONFIG_SDR_WHITE_LEVEL = extern struct {
    header: DISPLAYCONFIG_DEVICE_INFO_HEADER,
    SDRWhiteLevel: ULONG,
};
pub const DISPLAYCONFIG_SDR_WHITE_LEVEL = struct__DISPLAYCONFIG_SDR_WHITE_LEVEL;
pub const struct__RGNDATAHEADER = extern struct {
    dwSize: DWORD,
    iType: DWORD,
    nCount: DWORD,
    nRgnSize: DWORD,
    rcBound: RECT,
};
pub const RGNDATAHEADER = struct__RGNDATAHEADER;
pub const PRGNDATAHEADER = [*c]struct__RGNDATAHEADER;
pub const struct__RGNDATA = extern struct {
    rdh: RGNDATAHEADER,
    Buffer: [1]u8,
};
pub const RGNDATA = struct__RGNDATA;
pub const PRGNDATA = [*c]struct__RGNDATA;
pub const NPRGNDATA = [*c]struct__RGNDATA;
pub const LPRGNDATA = [*c]struct__RGNDATA;
pub const struct__ABC = extern struct {
    abcA: c_int,
    abcB: UINT,
    abcC: c_int,
};
pub const ABC = struct__ABC;
pub const PABC = [*c]struct__ABC;
pub const NPABC = [*c]struct__ABC;
pub const LPABC = [*c]struct__ABC;
pub const struct__ABCFLOAT = extern struct {
    abcfA: FLOAT,
    abcfB: FLOAT,
    abcfC: FLOAT,
};
pub const ABCFLOAT = struct__ABCFLOAT;
pub const PABCFLOAT = [*c]struct__ABCFLOAT;
pub const NPABCFLOAT = [*c]struct__ABCFLOAT;
pub const LPABCFLOAT = [*c]struct__ABCFLOAT;
pub const struct__OUTLINETEXTMETRICA = extern struct {
    otmSize: UINT,
    otmTextMetrics: TEXTMETRICA,
    otmFiller: BYTE,
    otmPanoseNumber: PANOSE,
    otmfsSelection: UINT,
    otmfsType: UINT,
    otmsCharSlopeRise: c_int,
    otmsCharSlopeRun: c_int,
    otmItalicAngle: c_int,
    otmEMSquare: UINT,
    otmAscent: c_int,
    otmDescent: c_int,
    otmLineGap: UINT,
    otmsCapEmHeight: UINT,
    otmsXHeight: UINT,
    otmrcFontBox: RECT,
    otmMacAscent: c_int,
    otmMacDescent: c_int,
    otmMacLineGap: UINT,
    otmusMinimumPPEM: UINT,
    otmptSubscriptSize: POINT,
    otmptSubscriptOffset: POINT,
    otmptSuperscriptSize: POINT,
    otmptSuperscriptOffset: POINT,
    otmsStrikeoutSize: UINT,
    otmsStrikeoutPosition: c_int,
    otmsUnderscoreSize: c_int,
    otmsUnderscorePosition: c_int,
    otmpFamilyName: PSTR,
    otmpFaceName: PSTR,
    otmpStyleName: PSTR,
    otmpFullName: PSTR,
};
pub const OUTLINETEXTMETRICA = struct__OUTLINETEXTMETRICA;
pub const POUTLINETEXTMETRICA = [*c]struct__OUTLINETEXTMETRICA;
pub const NPOUTLINETEXTMETRICA = [*c]struct__OUTLINETEXTMETRICA;
pub const LPOUTLINETEXTMETRICA = [*c]struct__OUTLINETEXTMETRICA;
pub const struct__OUTLINETEXTMETRICW = extern struct {
    otmSize: UINT,
    otmTextMetrics: TEXTMETRICW,
    otmFiller: BYTE,
    otmPanoseNumber: PANOSE,
    otmfsSelection: UINT,
    otmfsType: UINT,
    otmsCharSlopeRise: c_int,
    otmsCharSlopeRun: c_int,
    otmItalicAngle: c_int,
    otmEMSquare: UINT,
    otmAscent: c_int,
    otmDescent: c_int,
    otmLineGap: UINT,
    otmsCapEmHeight: UINT,
    otmsXHeight: UINT,
    otmrcFontBox: RECT,
    otmMacAscent: c_int,
    otmMacDescent: c_int,
    otmMacLineGap: UINT,
    otmusMinimumPPEM: UINT,
    otmptSubscriptSize: POINT,
    otmptSubscriptOffset: POINT,
    otmptSuperscriptSize: POINT,
    otmptSuperscriptOffset: POINT,
    otmsStrikeoutSize: UINT,
    otmsStrikeoutPosition: c_int,
    otmsUnderscoreSize: c_int,
    otmsUnderscorePosition: c_int,
    otmpFamilyName: PSTR,
    otmpFaceName: PSTR,
    otmpStyleName: PSTR,
    otmpFullName: PSTR,
};
pub const OUTLINETEXTMETRICW = struct__OUTLINETEXTMETRICW;
pub const POUTLINETEXTMETRICW = [*c]struct__OUTLINETEXTMETRICW;
pub const NPOUTLINETEXTMETRICW = [*c]struct__OUTLINETEXTMETRICW;
pub const LPOUTLINETEXTMETRICW = [*c]struct__OUTLINETEXTMETRICW;
pub const OUTLINETEXTMETRIC = OUTLINETEXTMETRICA;
pub const POUTLINETEXTMETRIC = POUTLINETEXTMETRICA;
pub const NPOUTLINETEXTMETRIC = NPOUTLINETEXTMETRICA;
pub const LPOUTLINETEXTMETRIC = LPOUTLINETEXTMETRICA;
pub const struct_tagPOLYTEXTA = extern struct {
    x: c_int,
    y: c_int,
    n: UINT,
    lpstr: LPCSTR,
    uiFlags: UINT,
    rcl: RECT,
    pdx: [*c]c_int,
};
pub const POLYTEXTA = struct_tagPOLYTEXTA;
pub const PPOLYTEXTA = [*c]struct_tagPOLYTEXTA;
pub const NPPOLYTEXTA = [*c]struct_tagPOLYTEXTA;
pub const LPPOLYTEXTA = [*c]struct_tagPOLYTEXTA;
pub const struct_tagPOLYTEXTW = extern struct {
    x: c_int,
    y: c_int,
    n: UINT,
    lpstr: LPCWSTR,
    uiFlags: UINT,
    rcl: RECT,
    pdx: [*c]c_int,
};
pub const POLYTEXTW = struct_tagPOLYTEXTW;
pub const PPOLYTEXTW = [*c]struct_tagPOLYTEXTW;
pub const NPPOLYTEXTW = [*c]struct_tagPOLYTEXTW;
pub const LPPOLYTEXTW = [*c]struct_tagPOLYTEXTW;
pub const POLYTEXT = POLYTEXTA;
pub const PPOLYTEXT = PPOLYTEXTA;
pub const NPPOLYTEXT = NPPOLYTEXTA;
pub const LPPOLYTEXT = LPPOLYTEXTA;
pub const struct__FIXED = extern struct {
    fract: WORD,
    value: c_short,
};
pub const FIXED = struct__FIXED;
pub const struct__MAT2 = extern struct {
    eM11: FIXED,
    eM12: FIXED,
    eM21: FIXED,
    eM22: FIXED,
};
pub const MAT2 = struct__MAT2;
pub const LPMAT2 = [*c]struct__MAT2;
pub const struct__GLYPHMETRICS = extern struct {
    gmBlackBoxX: UINT,
    gmBlackBoxY: UINT,
    gmptGlyphOrigin: POINT,
    gmCellIncX: c_short,
    gmCellIncY: c_short,
};
pub const GLYPHMETRICS = struct__GLYPHMETRICS;
pub const LPGLYPHMETRICS = [*c]struct__GLYPHMETRICS;
pub const struct_tagPOINTFX = extern struct {
    x: FIXED,
    y: FIXED,
};
pub const POINTFX = struct_tagPOINTFX;
pub const LPPOINTFX = [*c]struct_tagPOINTFX;
pub const struct_tagTTPOLYCURVE = extern struct {
    wType: WORD,
    cpfx: WORD,
    apfx: [1]POINTFX,
};
pub const TTPOLYCURVE = struct_tagTTPOLYCURVE;
pub const LPTTPOLYCURVE = [*c]struct_tagTTPOLYCURVE;
pub const struct_tagTTPOLYGONHEADER = extern struct {
    cb: DWORD,
    dwType: DWORD,
    pfxStart: POINTFX,
};
pub const TTPOLYGONHEADER = struct_tagTTPOLYGONHEADER;
pub const LPTTPOLYGONHEADER = [*c]struct_tagTTPOLYGONHEADER;
pub const struct_tagGCP_RESULTSA = extern struct {
    lStructSize: DWORD,
    lpOutString: LPSTR,
    lpOrder: [*c]UINT,
    lpDx: [*c]c_int,
    lpCaretPos: [*c]c_int,
    lpClass: LPSTR,
    lpGlyphs: LPWSTR,
    nGlyphs: UINT,
    nMaxFit: c_int,
};
pub const GCP_RESULTSA = struct_tagGCP_RESULTSA;
pub const LPGCP_RESULTSA = [*c]struct_tagGCP_RESULTSA;
pub const struct_tagGCP_RESULTSW = extern struct {
    lStructSize: DWORD,
    lpOutString: LPWSTR,
    lpOrder: [*c]UINT,
    lpDx: [*c]c_int,
    lpCaretPos: [*c]c_int,
    lpClass: LPSTR,
    lpGlyphs: LPWSTR,
    nGlyphs: UINT,
    nMaxFit: c_int,
};
pub const GCP_RESULTSW = struct_tagGCP_RESULTSW;
pub const LPGCP_RESULTSW = [*c]struct_tagGCP_RESULTSW;
pub const GCP_RESULTS = GCP_RESULTSA;
pub const LPGCP_RESULTS = LPGCP_RESULTSA;
pub const struct__RASTERIZER_STATUS = extern struct {
    nSize: c_short,
    wFlags: c_short,
    nLanguageID: c_short,
};
pub const RASTERIZER_STATUS = struct__RASTERIZER_STATUS;
pub const LPRASTERIZER_STATUS = [*c]struct__RASTERIZER_STATUS;
pub const struct_tagPIXELFORMATDESCRIPTOR = extern struct {
    nSize: WORD,
    nVersion: WORD,
    dwFlags: DWORD,
    iPixelType: BYTE,
    cColorBits: BYTE,
    cRedBits: BYTE,
    cRedShift: BYTE,
    cGreenBits: BYTE,
    cGreenShift: BYTE,
    cBlueBits: BYTE,
    cBlueShift: BYTE,
    cAlphaBits: BYTE,
    cAlphaShift: BYTE,
    cAccumBits: BYTE,
    cAccumRedBits: BYTE,
    cAccumGreenBits: BYTE,
    cAccumBlueBits: BYTE,
    cAccumAlphaBits: BYTE,
    cDepthBits: BYTE,
    cStencilBits: BYTE,
    cAuxBuffers: BYTE,
    iLayerType: BYTE,
    bReserved: BYTE,
    dwLayerMask: DWORD,
    dwVisibleMask: DWORD,
    dwDamageMask: DWORD,
};
pub const PIXELFORMATDESCRIPTOR = struct_tagPIXELFORMATDESCRIPTOR;
pub const PPIXELFORMATDESCRIPTOR = [*c]struct_tagPIXELFORMATDESCRIPTOR;
pub const LPPIXELFORMATDESCRIPTOR = [*c]struct_tagPIXELFORMATDESCRIPTOR;
pub const OLDFONTENUMPROCA = ?fn ([*c]const LOGFONTA, [*c]const TEXTMETRICA, DWORD, LPARAM) callconv(.C) c_int;
pub const OLDFONTENUMPROCW = ?fn ([*c]const LOGFONTW, [*c]const TEXTMETRICW, DWORD, LPARAM) callconv(.C) c_int;
pub const FONTENUMPROCA = OLDFONTENUMPROCA;
pub const FONTENUMPROCW = OLDFONTENUMPROCW;
pub const FONTENUMPROC = FONTENUMPROCA;
pub const GOBJENUMPROC = ?fn (LPVOID, LPARAM) callconv(.C) c_int;
pub const LINEDDAPROC = ?fn (c_int, c_int, LPARAM) callconv(.C) void;
pub extern "gdi32" fn AddFontResourceA(arg0: LPCSTR) callconv(.Stdcall) c_int;
pub extern "gdi32" fn AddFontResourceW(arg0: LPCWSTR) callconv(.Stdcall) c_int;
pub extern "gdi32" fn AnimatePalette(hPal: HPALETTE, iStartIndex: UINT, cEntries: UINT, ppe: [*c]const PALETTEENTRY) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn Arc(hdc: HDC, x1: c_int, y1: c_int, x2: c_int, y2: c_int, x3: c_int, y3: c_int, x4: c_int, y4: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn BitBlt(hdc: HDC, x: c_int, y: c_int, cx: c_int, cy: c_int, hdcSrc: HDC, x1: c_int, y1: c_int, rop: DWORD) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn CancelDC(hdc: HDC) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn Chord(hdc: HDC, x1: c_int, y1: c_int, x2: c_int, y2: c_int, x3: c_int, y3: c_int, x4: c_int, y4: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn ChoosePixelFormat(hdc: HDC, ppfd: [*c]const PIXELFORMATDESCRIPTOR) callconv(.Stdcall) c_int;
pub extern "gdi32" fn CloseMetaFile(hdc: HDC) callconv(.Stdcall) HMETAFILE;
pub extern "gdi32" fn CombineRgn(hrgnDst: HRGN, hrgnSrc1: HRGN, hrgnSrc2: HRGN, iMode: c_int) callconv(.Stdcall) c_int;
pub extern "gdi32" fn CopyMetaFileA(arg0: HMETAFILE, arg1: LPCSTR) callconv(.Stdcall) HMETAFILE;
pub extern "gdi32" fn CopyMetaFileW(arg0: HMETAFILE, arg1: LPCWSTR) callconv(.Stdcall) HMETAFILE;
pub extern "gdi32" fn CreateBitmap(nWidth: c_int, nHeight: c_int, nPlanes: UINT, nBitCount: UINT, lpBits: ?*const c_void) callconv(.Stdcall) HBITMAP;
pub extern "gdi32" fn CreateBitmapIndirect(pbm: [*c]const BITMAP) callconv(.Stdcall) HBITMAP;
pub extern "gdi32" fn CreateBrushIndirect(plbrush: [*c]const LOGBRUSH) callconv(.Stdcall) HBRUSH;
pub extern "gdi32" fn CreateCompatibleBitmap(hdc: HDC, cx: c_int, cy: c_int) callconv(.Stdcall) HBITMAP;
pub extern "gdi32" fn CreateDiscardableBitmap(hdc: HDC, cx: c_int, cy: c_int) callconv(.Stdcall) HBITMAP;
pub extern "gdi32" fn CreateCompatibleDC(hdc: HDC) callconv(.Stdcall) HDC;
pub extern "gdi32" fn CreateDCA(pwszDriver: LPCSTR, pwszDevice: LPCSTR, pszPort: LPCSTR, pdm: [*c]const DEVMODEA) callconv(.Stdcall) HDC;
pub extern "gdi32" fn CreateDCW(pwszDriver: LPCWSTR, pwszDevice: LPCWSTR, pszPort: LPCWSTR, pdm: [*c]const DEVMODEW) callconv(.Stdcall) HDC;
pub extern "gdi32" fn CreateDIBitmap(hdc: HDC, pbmih: [*c]const BITMAPINFOHEADER, flInit: DWORD, pjBits: ?*const c_void, pbmi: [*c]const BITMAPINFO, iUsage: UINT) callconv(.Stdcall) HBITMAP;
pub extern "gdi32" fn CreateDIBPatternBrush(h: HGLOBAL, iUsage: UINT) callconv(.Stdcall) HBRUSH;
pub extern "gdi32" fn CreateDIBPatternBrushPt(lpPackedDIB: ?*const c_void, iUsage: UINT) callconv(.Stdcall) HBRUSH;
pub extern "gdi32" fn CreateEllipticRgn(x1: c_int, y1: c_int, x2: c_int, y2: c_int) callconv(.Stdcall) HRGN;
pub extern "gdi32" fn CreateEllipticRgnIndirect(lprect: [*c]const RECT) callconv(.Stdcall) HRGN;
pub extern "gdi32" fn CreateFontIndirectA(lplf: [*c]const LOGFONTA) callconv(.Stdcall) HFONT;
pub extern "gdi32" fn CreateFontIndirectW(lplf: [*c]const LOGFONTW) callconv(.Stdcall) HFONT;
pub extern "gdi32" fn CreateFontA(cHeight: c_int, cWidth: c_int, cEscapement: c_int, cOrientation: c_int, cWeight: c_int, bItalic: DWORD, bUnderline: DWORD, bStrikeOut: DWORD, iCharSet: DWORD, iOutPrecision: DWORD, iClipPrecision: DWORD, iQuality: DWORD, iPitchAndFamily: DWORD, pszFaceName: LPCSTR) callconv(.Stdcall) HFONT;
pub extern "gdi32" fn CreateFontW(cHeight: c_int, cWidth: c_int, cEscapement: c_int, cOrientation: c_int, cWeight: c_int, bItalic: DWORD, bUnderline: DWORD, bStrikeOut: DWORD, iCharSet: DWORD, iOutPrecision: DWORD, iClipPrecision: DWORD, iQuality: DWORD, iPitchAndFamily: DWORD, pszFaceName: LPCWSTR) callconv(.Stdcall) HFONT;
pub extern "gdi32" fn CreateHatchBrush(iHatch: c_int, color: COLORREF) callconv(.Stdcall) HBRUSH;
pub extern "gdi32" fn CreateICA(pszDriver: LPCSTR, pszDevice: LPCSTR, pszPort: LPCSTR, pdm: [*c]const DEVMODEA) callconv(.Stdcall) HDC;
pub extern "gdi32" fn CreateICW(pszDriver: LPCWSTR, pszDevice: LPCWSTR, pszPort: LPCWSTR, pdm: [*c]const DEVMODEW) callconv(.Stdcall) HDC;
pub extern "gdi32" fn CreateMetaFileA(pszFile: LPCSTR) callconv(.Stdcall) HDC;
pub extern "gdi32" fn CreateMetaFileW(pszFile: LPCWSTR) callconv(.Stdcall) HDC;
pub extern "gdi32" fn CreatePalette(plpal: [*c]const LOGPALETTE) callconv(.Stdcall) HPALETTE;
pub extern "gdi32" fn CreatePen(iStyle: c_int, cWidth: c_int, color: COLORREF) callconv(.Stdcall) HPEN;
pub extern "gdi32" fn CreatePenIndirect(plpen: [*c]const LOGPEN) callconv(.Stdcall) HPEN;
pub extern "gdi32" fn CreatePolyPolygonRgn(pptl: [*c]const POINT, pc: [*c]const INT, cPoly: c_int, iMode: c_int) callconv(.Stdcall) HRGN;
pub extern "gdi32" fn CreatePatternBrush(hbm: HBITMAP) callconv(.Stdcall) HBRUSH;
pub extern "gdi32" fn CreateRectRgn(x1: c_int, y1: c_int, x2: c_int, y2: c_int) callconv(.Stdcall) HRGN;
pub extern "gdi32" fn CreateRectRgnIndirect(lprect: [*c]const RECT) callconv(.Stdcall) HRGN;
pub extern "gdi32" fn CreateRoundRectRgn(x1: c_int, y1: c_int, x2: c_int, y2: c_int, w: c_int, h: c_int) callconv(.Stdcall) HRGN;
pub extern "gdi32" fn CreateScalableFontResourceA(fdwHidden: DWORD, lpszFont: LPCSTR, lpszFile: LPCSTR, lpszPath: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn CreateScalableFontResourceW(fdwHidden: DWORD, lpszFont: LPCWSTR, lpszFile: LPCWSTR, lpszPath: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn CreateSolidBrush(color: COLORREF) callconv(.Stdcall) HBRUSH;
pub extern "gdi32" fn DeleteDC(hdc: HDC) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn DeleteMetaFile(hmf: HMETAFILE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn DeleteObject(ho: HGDIOBJ) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn DescribePixelFormat(hdc: HDC, iPixelFormat: c_int, nBytes: UINT, ppfd: LPPIXELFORMATDESCRIPTOR) callconv(.Stdcall) c_int;
pub const LPFNDEVMODE = ?fn (HWND, HMODULE, LPDEVMODE, LPSTR, LPSTR, LPDEVMODE, LPSTR, UINT) callconv(.C) UINT;
pub const LPFNDEVCAPS = ?fn (LPSTR, LPSTR, UINT, LPSTR, LPDEVMODE) callconv(.C) DWORD;
pub extern "gdi32" fn DeviceCapabilitiesA(pDevice: LPCSTR, pPort: LPCSTR, fwCapability: WORD, pOutput: LPSTR, pDevMode: [*c]const DEVMODEA) callconv(.Stdcall) c_int;
pub extern "gdi32" fn DeviceCapabilitiesW(pDevice: LPCWSTR, pPort: LPCWSTR, fwCapability: WORD, pOutput: LPWSTR, pDevMode: [*c]const DEVMODEW) callconv(.Stdcall) c_int;
pub extern "gdi32" fn DrawEscape(hdc: HDC, iEscape: c_int, cjIn: c_int, lpIn: LPCSTR) callconv(.Stdcall) c_int;
pub extern "gdi32" fn Ellipse(hdc: HDC, left: c_int, top: c_int, right: c_int, bottom: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn EnumFontFamiliesExA(hdc: HDC, lpLogfont: LPLOGFONTA, lpProc: FONTENUMPROCA, lParam: LPARAM, dwFlags: DWORD) callconv(.Stdcall) c_int;
pub extern "gdi32" fn EnumFontFamiliesExW(hdc: HDC, lpLogfont: LPLOGFONTW, lpProc: FONTENUMPROCW, lParam: LPARAM, dwFlags: DWORD) callconv(.Stdcall) c_int;
pub extern "gdi32" fn EnumFontFamiliesA(hdc: HDC, lpLogfont: LPCSTR, lpProc: FONTENUMPROCA, lParam: LPARAM) callconv(.Stdcall) c_int;
pub extern "gdi32" fn EnumFontFamiliesW(hdc: HDC, lpLogfont: LPCWSTR, lpProc: FONTENUMPROCW, lParam: LPARAM) callconv(.Stdcall) c_int;
pub extern "gdi32" fn EnumFontsA(hdc: HDC, lpLogfont: LPCSTR, lpProc: FONTENUMPROCA, lParam: LPARAM) callconv(.Stdcall) c_int;
pub extern "gdi32" fn EnumFontsW(hdc: HDC, lpLogfont: LPCWSTR, lpProc: FONTENUMPROCW, lParam: LPARAM) callconv(.Stdcall) c_int;
pub extern "gdi32" fn EnumObjects(hdc: HDC, nType: c_int, lpFunc: GOBJENUMPROC, lParam: LPARAM) callconv(.Stdcall) c_int;
pub extern "gdi32" fn EqualRgn(hrgn1: HRGN, hrgn2: HRGN) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn Escape(hdc: HDC, iEscape: c_int, cjIn: c_int, pvIn: LPCSTR, pvOut: LPVOID) callconv(.Stdcall) c_int;
pub extern "gdi32" fn ExtEscape(hdc: HDC, iEscape: c_int, cjInput: c_int, lpInData: LPCSTR, cjOutput: c_int, lpOutData: LPSTR) callconv(.Stdcall) c_int;
pub extern "gdi32" fn ExcludeClipRect(hdc: HDC, left: c_int, top: c_int, right: c_int, bottom: c_int) callconv(.Stdcall) c_int;
pub extern "gdi32" fn ExtCreateRegion(lpx: [*c]const XFORM, nCount: DWORD, lpData: [*c]const RGNDATA) callconv(.Stdcall) HRGN;
pub extern "gdi32" fn ExtFloodFill(hdc: HDC, x: c_int, y: c_int, color: COLORREF, type_0: UINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn FillRgn(hdc: HDC, hrgn: HRGN, hbr: HBRUSH) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn FloodFill(hdc: HDC, x: c_int, y: c_int, color: COLORREF) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn FrameRgn(hdc: HDC, hrgn: HRGN, hbr: HBRUSH, w: c_int, h: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetROP2(hdc: HDC) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetAspectRatioFilterEx(hdc: HDC, lpsize: LPSIZE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetBkColor(hdc: HDC) callconv(.Stdcall) COLORREF;
pub extern "gdi32" fn GetDCBrushColor(hdc: HDC) callconv(.Stdcall) COLORREF;
pub extern "gdi32" fn GetDCPenColor(hdc: HDC) callconv(.Stdcall) COLORREF;
pub extern "gdi32" fn GetBkMode(hdc: HDC) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetBitmapBits(hbit: HBITMAP, cb: LONG, lpvBits: LPVOID) callconv(.Stdcall) LONG;
pub extern "gdi32" fn GetBitmapDimensionEx(hbit: HBITMAP, lpsize: LPSIZE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetBoundsRect(hdc: HDC, lprect: LPRECT, flags: UINT) callconv(.Stdcall) UINT;
pub extern "gdi32" fn GetBrushOrgEx(hdc: HDC, lppt: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetCharWidthA(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: LPINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetCharWidthW(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: LPINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetCharWidth32A(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: LPINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetCharWidth32W(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: LPINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetCharWidthFloatA(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: PFLOAT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetCharWidthFloatW(hdc: HDC, iFirst: UINT, iLast: UINT, lpBuffer: PFLOAT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetCharABCWidthsA(hdc: HDC, wFirst: UINT, wLast: UINT, lpABC: LPABC) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetCharABCWidthsW(hdc: HDC, wFirst: UINT, wLast: UINT, lpABC: LPABC) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetCharABCWidthsFloatA(hdc: HDC, iFirst: UINT, iLast: UINT, lpABC: LPABCFLOAT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetCharABCWidthsFloatW(hdc: HDC, iFirst: UINT, iLast: UINT, lpABC: LPABCFLOAT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetClipBox(hdc: HDC, lprect: LPRECT) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetClipRgn(hdc: HDC, hrgn: HRGN) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetMetaRgn(hdc: HDC, hrgn: HRGN) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetCurrentObject(hdc: HDC, type_0: UINT) callconv(.Stdcall) HGDIOBJ;
pub extern "gdi32" fn GetCurrentPositionEx(hdc: HDC, lppt: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetDeviceCaps(hdc: HDC, index: c_int) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetDIBits(hdc: HDC, hbm: HBITMAP, start: UINT, cLines: UINT, lpvBits: LPVOID, lpbmi: LPBITMAPINFO, usage: UINT) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetFontData(hdc: HDC, dwTable: DWORD, dwOffset: DWORD, pvBuffer: PVOID, cjBuffer: DWORD) callconv(.Stdcall) DWORD;
pub extern "gdi32" fn GetGlyphOutlineA(hdc: HDC, uChar: UINT, fuFormat: UINT, lpgm: LPGLYPHMETRICS, cjBuffer: DWORD, pvBuffer: LPVOID, lpmat2: [*c]const MAT2) callconv(.Stdcall) DWORD;
pub extern "gdi32" fn GetGlyphOutlineW(hdc: HDC, uChar: UINT, fuFormat: UINT, lpgm: LPGLYPHMETRICS, cjBuffer: DWORD, pvBuffer: LPVOID, lpmat2: [*c]const MAT2) callconv(.Stdcall) DWORD;
pub extern "gdi32" fn GetGraphicsMode(hdc: HDC) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetMapMode(hdc: HDC) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetMetaFileBitsEx(hMF: HMETAFILE, cbBuffer: UINT, lpData: LPVOID) callconv(.Stdcall) UINT;
pub extern "gdi32" fn GetMetaFileA(lpName: LPCSTR) callconv(.Stdcall) HMETAFILE;
pub extern "gdi32" fn GetMetaFileW(lpName: LPCWSTR) callconv(.Stdcall) HMETAFILE;
pub extern "gdi32" fn GetNearestColor(hdc: HDC, color: COLORREF) callconv(.Stdcall) COLORREF;
pub extern "gdi32" fn GetNearestPaletteIndex(h: HPALETTE, color: COLORREF) callconv(.Stdcall) UINT;
pub extern "gdi32" fn GetObjectType(h: HGDIOBJ) callconv(.Stdcall) DWORD;
pub extern "gdi32" fn GetOutlineTextMetricsA(hdc: HDC, cjCopy: UINT, potm: LPOUTLINETEXTMETRICA) callconv(.Stdcall) UINT;
pub extern "gdi32" fn GetOutlineTextMetricsW(hdc: HDC, cjCopy: UINT, potm: LPOUTLINETEXTMETRICW) callconv(.Stdcall) UINT;
pub extern "gdi32" fn GetPaletteEntries(hpal: HPALETTE, iStart: UINT, cEntries: UINT, pPalEntries: LPPALETTEENTRY) callconv(.Stdcall) UINT;
pub extern "gdi32" fn GetPixel(hdc: HDC, x: c_int, y: c_int) callconv(.Stdcall) COLORREF;
pub extern "gdi32" fn GetPixelFormat(hdc: HDC) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetPolyFillMode(hdc: HDC) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetRasterizerCaps(lpraststat: LPRASTERIZER_STATUS, cjBytes: UINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetRandomRgn(hdc: HDC, hrgn: HRGN, i: INT) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetRegionData(hrgn: HRGN, nCount: DWORD, lpRgnData: LPRGNDATA) callconv(.Stdcall) DWORD;
pub extern "gdi32" fn GetRgnBox(hrgn: HRGN, lprc: LPRECT) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetStockObject(i: c_int) callconv(.Stdcall) HGDIOBJ;
pub extern "gdi32" fn GetStretchBltMode(hdc: HDC) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetSystemPaletteEntries(hdc: HDC, iStart: UINT, cEntries: UINT, pPalEntries: LPPALETTEENTRY) callconv(.Stdcall) UINT;
pub extern "gdi32" fn GetSystemPaletteUse(hdc: HDC) callconv(.Stdcall) UINT;
pub extern "gdi32" fn GetTextCharacterExtra(hdc: HDC) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetTextAlign(hdc: HDC) callconv(.Stdcall) UINT;
pub extern "gdi32" fn GetTextColor(hdc: HDC) callconv(.Stdcall) COLORREF;
pub extern "gdi32" fn GetTextExtentPointA(hdc: HDC, lpString: LPCSTR, c: c_int, lpsz: LPSIZE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetTextExtentPointW(hdc: HDC, lpString: LPCWSTR, c: c_int, lpsz: LPSIZE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetTextExtentPoint32A(hdc: HDC, lpString: LPCSTR, c: c_int, psizl: LPSIZE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetTextExtentPoint32W(hdc: HDC, lpString: LPCWSTR, c: c_int, psizl: LPSIZE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetTextExtentExPointA(hdc: HDC, lpszString: LPCSTR, cchString: c_int, nMaxExtent: c_int, lpnFit: LPINT, lpnDx: LPINT, lpSize: LPSIZE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetTextExtentExPointW(hdc: HDC, lpszString: LPCWSTR, cchString: c_int, nMaxExtent: c_int, lpnFit: LPINT, lpnDx: LPINT, lpSize: LPSIZE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetTextCharset(hdc: HDC) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetTextCharsetInfo(hdc: HDC, lpSig: LPFONTSIGNATURE, dwFlags: DWORD) callconv(.Stdcall) c_int;
pub extern "gdi32" fn TranslateCharsetInfo(lpSrc: [*c]DWORD, lpCs: LPCHARSETINFO, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetFontLanguageInfo(hdc: HDC) callconv(.Stdcall) DWORD;
pub extern "gdi32" fn GetCharacterPlacementA(hdc: HDC, lpString: LPCSTR, nCount: c_int, nMexExtent: c_int, lpResults: LPGCP_RESULTSA, dwFlags: DWORD) callconv(.Stdcall) DWORD;
pub extern "gdi32" fn GetCharacterPlacementW(hdc: HDC, lpString: LPCWSTR, nCount: c_int, nMexExtent: c_int, lpResults: LPGCP_RESULTSW, dwFlags: DWORD) callconv(.Stdcall) DWORD;
pub const struct_tagWCRANGE = extern struct {
    wcLow: WCHAR,
    cGlyphs: USHORT,
};
pub const WCRANGE = struct_tagWCRANGE;
pub const PWCRANGE = [*c]struct_tagWCRANGE;
pub const LPWCRANGE = [*c]struct_tagWCRANGE;
pub const struct_tagGLYPHSET = extern struct {
    cbThis: DWORD,
    flAccel: DWORD,
    cGlyphsSupported: DWORD,
    cRanges: DWORD,
    ranges: [1]WCRANGE,
};
pub const GLYPHSET = struct_tagGLYPHSET;
pub const PGLYPHSET = [*c]struct_tagGLYPHSET;
pub const LPGLYPHSET = [*c]struct_tagGLYPHSET;
pub extern "gdi32" fn GetFontUnicodeRanges(hdc: HDC, lpgs: LPGLYPHSET) callconv(.Stdcall) DWORD;
pub extern "gdi32" fn GetGlyphIndicesA(hdc: HDC, lpstr: LPCSTR, c: c_int, pgi: LPWORD, fl: DWORD) callconv(.Stdcall) DWORD;
pub extern "gdi32" fn GetGlyphIndicesW(hdc: HDC, lpstr: LPCWSTR, c: c_int, pgi: LPWORD, fl: DWORD) callconv(.Stdcall) DWORD;
pub extern "gdi32" fn GetTextExtentPointI(hdc: HDC, pgiIn: LPWORD, cgi: c_int, psize: LPSIZE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetTextExtentExPointI(hdc: HDC, lpwszString: LPWORD, cwchString: c_int, nMaxExtent: c_int, lpnFit: LPINT, lpnDx: LPINT, lpSize: LPSIZE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetCharWidthI(hdc: HDC, giFirst: UINT, cgi: UINT, pgi: LPWORD, piWidths: LPINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetCharABCWidthsI(hdc: HDC, giFirst: UINT, cgi: UINT, pgi: LPWORD, pabc: LPABC) callconv(.Stdcall) BOOL;
pub const struct_tagDESIGNVECTOR = extern struct {
    dvReserved: DWORD,
    dvNumAxes: DWORD,
    dvValues: [16]LONG,
};
pub const DESIGNVECTOR = struct_tagDESIGNVECTOR;
pub const PDESIGNVECTOR = [*c]struct_tagDESIGNVECTOR;
pub const LPDESIGNVECTOR = [*c]struct_tagDESIGNVECTOR;
pub extern "gdi32" fn AddFontResourceExA(name: LPCSTR, fl: DWORD, res: PVOID) callconv(.Stdcall) c_int;
pub extern "gdi32" fn AddFontResourceExW(name: LPCWSTR, fl: DWORD, res: PVOID) callconv(.Stdcall) c_int;
pub extern "gdi32" fn RemoveFontResourceExA(name: LPCSTR, fl: DWORD, pdv: PVOID) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn RemoveFontResourceExW(name: LPCWSTR, fl: DWORD, pdv: PVOID) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn AddFontMemResourceEx(pFileView: PVOID, cjSize: DWORD, pvResrved: PVOID, pNumFonts: [*c]DWORD) callconv(.Stdcall) HANDLE;
pub extern "gdi32" fn RemoveFontMemResourceEx(h: HANDLE) callconv(.Stdcall) BOOL;
pub const struct_tagAXISINFOA = extern struct {
    axMinValue: LONG,
    axMaxValue: LONG,
    axAxisName: [16]BYTE,
};
pub const AXISINFOA = struct_tagAXISINFOA;
pub const PAXISINFOA = [*c]struct_tagAXISINFOA;
pub const LPAXISINFOA = [*c]struct_tagAXISINFOA;
pub const struct_tagAXISINFOW = extern struct {
    axMinValue: LONG,
    axMaxValue: LONG,
    axAxisName: [16]WCHAR,
};
pub const AXISINFOW = struct_tagAXISINFOW;
pub const PAXISINFOW = [*c]struct_tagAXISINFOW;
pub const LPAXISINFOW = [*c]struct_tagAXISINFOW;
pub const AXISINFO = AXISINFOA;
pub const PAXISINFO = PAXISINFOA;
pub const LPAXISINFO = LPAXISINFOA;
pub const struct_tagAXESLISTA = extern struct {
    axlReserved: DWORD,
    axlNumAxes: DWORD,
    axlAxisInfo: [16]AXISINFOA,
};
pub const AXESLISTA = struct_tagAXESLISTA;
pub const PAXESLISTA = [*c]struct_tagAXESLISTA;
pub const LPAXESLISTA = [*c]struct_tagAXESLISTA;
pub const struct_tagAXESLISTW = extern struct {
    axlReserved: DWORD,
    axlNumAxes: DWORD,
    axlAxisInfo: [16]AXISINFOW,
};
pub const AXESLISTW = struct_tagAXESLISTW;
pub const PAXESLISTW = [*c]struct_tagAXESLISTW;
pub const LPAXESLISTW = [*c]struct_tagAXESLISTW;
pub const AXESLIST = AXESLISTA;
pub const PAXESLIST = PAXESLISTA;
pub const LPAXESLIST = LPAXESLISTA;
pub const struct_tagENUMLOGFONTEXDVA = extern struct {
    elfEnumLogfontEx: ENUMLOGFONTEXA,
    elfDesignVector: DESIGNVECTOR,
};
pub const ENUMLOGFONTEXDVA = struct_tagENUMLOGFONTEXDVA;
pub const PENUMLOGFONTEXDVA = [*c]struct_tagENUMLOGFONTEXDVA;
pub const LPENUMLOGFONTEXDVA = [*c]struct_tagENUMLOGFONTEXDVA;
pub const struct_tagENUMLOGFONTEXDVW = extern struct {
    elfEnumLogfontEx: ENUMLOGFONTEXW,
    elfDesignVector: DESIGNVECTOR,
};
pub const ENUMLOGFONTEXDVW = struct_tagENUMLOGFONTEXDVW;
pub const PENUMLOGFONTEXDVW = [*c]struct_tagENUMLOGFONTEXDVW;
pub const LPENUMLOGFONTEXDVW = [*c]struct_tagENUMLOGFONTEXDVW;
pub const ENUMLOGFONTEXDV = ENUMLOGFONTEXDVA;
pub const PENUMLOGFONTEXDV = PENUMLOGFONTEXDVA;
pub const LPENUMLOGFONTEXDV = LPENUMLOGFONTEXDVA;
pub extern "gdi32" fn CreateFontIndirectExA(arg0: [*c]const ENUMLOGFONTEXDVA) callconv(.Stdcall) HFONT;
pub extern "gdi32" fn CreateFontIndirectExW(arg0: [*c]const ENUMLOGFONTEXDVW) callconv(.Stdcall) HFONT;
pub const struct_tagENUMTEXTMETRICA = extern struct {
    etmNewTextMetricEx: NEWTEXTMETRICEXA,
    etmAxesList: AXESLISTA,
};
pub const ENUMTEXTMETRICA = struct_tagENUMTEXTMETRICA;
pub const PENUMTEXTMETRICA = [*c]struct_tagENUMTEXTMETRICA;
pub const LPENUMTEXTMETRICA = [*c]struct_tagENUMTEXTMETRICA;
pub const struct_tagENUMTEXTMETRICW = extern struct {
    etmNewTextMetricEx: NEWTEXTMETRICEXW,
    etmAxesList: AXESLISTW,
};
pub const ENUMTEXTMETRICW = struct_tagENUMTEXTMETRICW;
pub const PENUMTEXTMETRICW = [*c]struct_tagENUMTEXTMETRICW;
pub const LPENUMTEXTMETRICW = [*c]struct_tagENUMTEXTMETRICW;
pub const ENUMTEXTMETRIC = ENUMTEXTMETRICA;
pub const PENUMTEXTMETRIC = PENUMTEXTMETRICA;
pub const LPENUMTEXTMETRIC = LPENUMTEXTMETRICA;
pub extern "gdi32" fn GetViewportExtEx(hdc: HDC, lpsize: LPSIZE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetViewportOrgEx(hdc: HDC, lppoint: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetWindowExtEx(hdc: HDC, lpsize: LPSIZE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetWindowOrgEx(hdc: HDC, lppoint: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn IntersectClipRect(hdc: HDC, left: c_int, top: c_int, right: c_int, bottom: c_int) callconv(.Stdcall) c_int;
pub extern "gdi32" fn InvertRgn(hdc: HDC, hrgn: HRGN) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn LineDDA(xStart: c_int, yStart: c_int, xEnd: c_int, yEnd: c_int, lpProc: LINEDDAPROC, data: LPARAM) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn LineTo(hdc: HDC, x: c_int, y: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn MaskBlt(hdcDest: HDC, xDest: c_int, yDest: c_int, width: c_int, height: c_int, hdcSrc: HDC, xSrc: c_int, ySrc: c_int, hbmMask: HBITMAP, xMask: c_int, yMask: c_int, rop: DWORD) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn PlgBlt(hdcDest: HDC, lpPoint: [*c]const POINT, hdcSrc: HDC, xSrc: c_int, ySrc: c_int, width: c_int, height: c_int, hbmMask: HBITMAP, xMask: c_int, yMask: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn OffsetClipRgn(hdc: HDC, x: c_int, y: c_int) callconv(.Stdcall) c_int;
pub extern "gdi32" fn OffsetRgn(hrgn: HRGN, x: c_int, y: c_int) callconv(.Stdcall) c_int;
pub extern "gdi32" fn PatBlt(hdc: HDC, x: c_int, y: c_int, w: c_int, h: c_int, rop: DWORD) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn Pie(hdc: HDC, left: c_int, top: c_int, right: c_int, bottom: c_int, xr1: c_int, yr1: c_int, xr2: c_int, yr2: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn PlayMetaFile(hdc: HDC, hmf: HMETAFILE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn PaintRgn(hdc: HDC, hrgn: HRGN) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn PolyPolygon(hdc: HDC, apt: [*c]const POINT, asz: [*c]const INT, csz: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn PtInRegion(hrgn: HRGN, x: c_int, y: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn PtVisible(hdc: HDC, x: c_int, y: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn RectInRegion(hrgn: HRGN, lprect: [*c]const RECT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn RectVisible(hdc: HDC, lprect: [*c]const RECT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn Rectangle(hdc: HDC, left: c_int, top: c_int, right: c_int, bottom: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn RestoreDC(hdc: HDC, nSavedDC: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn ResetDCA(hdc: HDC, lpdm: [*c]const DEVMODEA) callconv(.Stdcall) HDC;
pub extern "gdi32" fn ResetDCW(hdc: HDC, lpdm: [*c]const DEVMODEW) callconv(.Stdcall) HDC;
pub extern "gdi32" fn RealizePalette(hdc: HDC) callconv(.Stdcall) UINT;
pub extern "gdi32" fn RemoveFontResourceA(lpFileName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn RemoveFontResourceW(lpFileName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn RoundRect(hdc: HDC, left: c_int, top: c_int, right: c_int, bottom: c_int, width: c_int, height: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn ResizePalette(hpal: HPALETTE, n: UINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SaveDC(hdc: HDC) callconv(.Stdcall) c_int;
pub extern "gdi32" fn SelectClipRgn(hdc: HDC, hrgn: HRGN) callconv(.Stdcall) c_int;
pub extern "gdi32" fn ExtSelectClipRgn(hdc: HDC, hrgn: HRGN, mode: c_int) callconv(.Stdcall) c_int;
pub extern "gdi32" fn SetMetaRgn(hdc: HDC) callconv(.Stdcall) c_int;
pub extern "gdi32" fn SelectObject(hdc: HDC, h: HGDIOBJ) callconv(.Stdcall) HGDIOBJ;
pub extern "gdi32" fn SelectPalette(hdc: HDC, hPal: HPALETTE, bForceBkgd: BOOL) callconv(.Stdcall) HPALETTE;
pub extern "gdi32" fn SetBkColor(hdc: HDC, color: COLORREF) callconv(.Stdcall) COLORREF;
pub extern "gdi32" fn SetDCBrushColor(hdc: HDC, color: COLORREF) callconv(.Stdcall) COLORREF;
pub extern "gdi32" fn SetDCPenColor(hdc: HDC, color: COLORREF) callconv(.Stdcall) COLORREF;
pub extern "gdi32" fn SetBkMode(hdc: HDC, mode: c_int) callconv(.Stdcall) c_int;
pub extern "gdi32" fn SetBitmapBits(hbm: HBITMAP, cb: DWORD, pvBits: ?*const c_void) callconv(.Stdcall) LONG;
pub extern "gdi32" fn SetBoundsRect(hdc: HDC, lprect: [*c]const RECT, flags: UINT) callconv(.Stdcall) UINT;
pub extern "gdi32" fn SetDIBits(hdc: HDC, hbm: HBITMAP, start: UINT, cLines: UINT, lpBits: ?*const c_void, lpbmi: [*c]const BITMAPINFO, ColorUse: UINT) callconv(.Stdcall) c_int;
pub extern "gdi32" fn SetDIBitsToDevice(hdc: HDC, xDest: c_int, yDest: c_int, w: DWORD, h: DWORD, xSrc: c_int, ySrc: c_int, StartScan: UINT, cLines: UINT, lpvBits: ?*const c_void, lpbmi: [*c]const BITMAPINFO, ColorUse: UINT) callconv(.Stdcall) c_int;
pub extern "gdi32" fn SetMapperFlags(hdc: HDC, flags: DWORD) callconv(.Stdcall) DWORD;
pub extern "gdi32" fn SetGraphicsMode(hdc: HDC, iMode: c_int) callconv(.Stdcall) c_int;
pub extern "gdi32" fn SetMapMode(hdc: HDC, iMode: c_int) callconv(.Stdcall) c_int;
pub extern "gdi32" fn SetLayout(hdc: HDC, l: DWORD) callconv(.Stdcall) DWORD;
pub extern "gdi32" fn GetLayout(hdc: HDC) callconv(.Stdcall) DWORD;
pub extern "gdi32" fn SetMetaFileBitsEx(cbBuffer: UINT, lpData: [*c]const BYTE) callconv(.Stdcall) HMETAFILE;
pub extern "gdi32" fn SetPaletteEntries(hpal: HPALETTE, iStart: UINT, cEntries: UINT, pPalEntries: [*c]const PALETTEENTRY) callconv(.Stdcall) UINT;
pub extern "gdi32" fn SetPixel(hdc: HDC, x: c_int, y: c_int, color: COLORREF) callconv(.Stdcall) COLORREF;
pub extern "gdi32" fn SetPixelV(hdc: HDC, x: c_int, y: c_int, color: COLORREF) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SetPixelFormat(hdc: HDC, format: c_int, ppfd: [*c]const PIXELFORMATDESCRIPTOR) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SetPolyFillMode(hdc: HDC, mode: c_int) callconv(.Stdcall) c_int;
pub extern "gdi32" fn StretchBlt(hdcDest: HDC, xDest: c_int, yDest: c_int, wDest: c_int, hDest: c_int, hdcSrc: HDC, xSrc: c_int, ySrc: c_int, wSrc: c_int, hSrc: c_int, rop: DWORD) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SetRectRgn(hrgn: HRGN, left: c_int, top: c_int, right: c_int, bottom: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn StretchDIBits(hdc: HDC, xDest: c_int, yDest: c_int, DestWidth: c_int, DestHeight: c_int, xSrc: c_int, ySrc: c_int, SrcWidth: c_int, SrcHeight: c_int, lpBits: ?*const c_void, lpbmi: [*c]const BITMAPINFO, iUsage: UINT, rop: DWORD) callconv(.Stdcall) c_int;
pub extern "gdi32" fn SetROP2(hdc: HDC, rop2: c_int) callconv(.Stdcall) c_int;
pub extern "gdi32" fn SetStretchBltMode(hdc: HDC, mode: c_int) callconv(.Stdcall) c_int;
pub extern "gdi32" fn SetSystemPaletteUse(hdc: HDC, @"use": UINT) callconv(.Stdcall) UINT;
pub extern "gdi32" fn SetTextCharacterExtra(hdc: HDC, extra: c_int) callconv(.Stdcall) c_int;
pub extern "gdi32" fn SetTextColor(hdc: HDC, color: COLORREF) callconv(.Stdcall) COLORREF;
pub extern "gdi32" fn SetTextAlign(hdc: HDC, @"align": UINT) callconv(.Stdcall) UINT;
pub extern "gdi32" fn SetTextJustification(hdc: HDC, extra: c_int, count: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn UpdateColors(hdc: HDC) callconv(.Stdcall) BOOL;
pub const COLOR16 = USHORT;
pub const struct__TRIVERTEX = extern struct {
    x: LONG,
    y: LONG,
    Red: COLOR16,
    Green: COLOR16,
    Blue: COLOR16,
    Alpha: COLOR16,
};
pub const TRIVERTEX = struct__TRIVERTEX;
pub const PTRIVERTEX = [*c]struct__TRIVERTEX;
pub const LPTRIVERTEX = [*c]struct__TRIVERTEX;
pub const struct__GRADIENT_TRIANGLE = extern struct {
    Vertex1: ULONG,
    Vertex2: ULONG,
    Vertex3: ULONG,
};
pub const GRADIENT_TRIANGLE = struct__GRADIENT_TRIANGLE;
pub const PGRADIENT_TRIANGLE = [*c]struct__GRADIENT_TRIANGLE;
pub const LPGRADIENT_TRIANGLE = [*c]struct__GRADIENT_TRIANGLE;
pub const struct__GRADIENT_RECT = extern struct {
    UpperLeft: ULONG,
    LowerRight: ULONG,
};
pub const GRADIENT_RECT = struct__GRADIENT_RECT;
pub const PGRADIENT_RECT = [*c]struct__GRADIENT_RECT;
pub const LPGRADIENT_RECT = [*c]struct__GRADIENT_RECT;
pub const struct__BLENDFUNCTION = extern struct {
    BlendOp: BYTE,
    BlendFlags: BYTE,
    SourceConstantAlpha: BYTE,
    AlphaFormat: BYTE,
};
pub const BLENDFUNCTION = struct__BLENDFUNCTION;
pub const PBLENDFUNCTION = [*c]struct__BLENDFUNCTION;
pub extern "msimg32" fn AlphaBlend(hdcDest: HDC, xoriginDest: c_int, yoriginDest: c_int, wDest: c_int, hDest: c_int, hdcSrc: HDC, xoriginSrc: c_int, yoriginSrc: c_int, wSrc: c_int, hSrc: c_int, ftn: BLENDFUNCTION) callconv(.Stdcall) BOOL;
pub extern "msimg32" fn TransparentBlt(hdcDest: HDC, xoriginDest: c_int, yoriginDest: c_int, wDest: c_int, hDest: c_int, hdcSrc: HDC, xoriginSrc: c_int, yoriginSrc: c_int, wSrc: c_int, hSrc: c_int, crTransparent: UINT) callconv(.Stdcall) BOOL;
pub extern "msimg32" fn GradientFill(hdc: HDC, pVertex: PTRIVERTEX, nVertex: ULONG, pMesh: PVOID, nMesh: ULONG, ulMode: ULONG) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GdiAlphaBlend(hdcDest: HDC, xoriginDest: c_int, yoriginDest: c_int, wDest: c_int, hDest: c_int, hdcSrc: HDC, xoriginSrc: c_int, yoriginSrc: c_int, wSrc: c_int, hSrc: c_int, ftn: BLENDFUNCTION) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GdiTransparentBlt(hdcDest: HDC, xoriginDest: c_int, yoriginDest: c_int, wDest: c_int, hDest: c_int, hdcSrc: HDC, xoriginSrc: c_int, yoriginSrc: c_int, wSrc: c_int, hSrc: c_int, crTransparent: UINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GdiGradientFill(hdc: HDC, pVertex: PTRIVERTEX, nVertex: ULONG, pMesh: PVOID, nCount: ULONG, ulMode: ULONG) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn PlayMetaFileRecord(hdc: HDC, lpHandleTable: LPHANDLETABLE, lpMR: LPMETARECORD, noObjs: UINT) callconv(.Stdcall) BOOL;
pub const MFENUMPROC = ?fn (HDC, [*c]HANDLETABLE, [*c]METARECORD, c_int, LPARAM) callconv(.C) c_int;
pub extern "gdi32" fn EnumMetaFile(hdc: HDC, hmf: HMETAFILE, proc: MFENUMPROC, param: LPARAM) callconv(.Stdcall) BOOL;
pub const ENHMFENUMPROC = ?fn (HDC, [*c]HANDLETABLE, [*c]const ENHMETARECORD, c_int, LPARAM) callconv(.C) c_int;
pub extern "gdi32" fn CloseEnhMetaFile(hdc: HDC) callconv(.Stdcall) HENHMETAFILE;
pub extern "gdi32" fn CopyEnhMetaFileA(hEnh: HENHMETAFILE, lpFileName: LPCSTR) callconv(.Stdcall) HENHMETAFILE;
pub extern "gdi32" fn CopyEnhMetaFileW(hEnh: HENHMETAFILE, lpFileName: LPCWSTR) callconv(.Stdcall) HENHMETAFILE;
pub extern "gdi32" fn CreateEnhMetaFileA(hdc: HDC, lpFilename: LPCSTR, lprc: [*c]const RECT, lpDesc: LPCSTR) callconv(.Stdcall) HDC;
pub extern "gdi32" fn CreateEnhMetaFileW(hdc: HDC, lpFilename: LPCWSTR, lprc: [*c]const RECT, lpDesc: LPCWSTR) callconv(.Stdcall) HDC;
pub extern "gdi32" fn DeleteEnhMetaFile(hmf: HENHMETAFILE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn EnumEnhMetaFile(hdc: HDC, hmf: HENHMETAFILE, proc: ENHMFENUMPROC, param: LPVOID, lpRect: [*c]const RECT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetEnhMetaFileA(lpName: LPCSTR) callconv(.Stdcall) HENHMETAFILE;
pub extern "gdi32" fn GetEnhMetaFileW(lpName: LPCWSTR) callconv(.Stdcall) HENHMETAFILE;
pub extern "gdi32" fn GetEnhMetaFileBits(hEMF: HENHMETAFILE, nSize: UINT, lpData: LPBYTE) callconv(.Stdcall) UINT;
pub extern "gdi32" fn GetEnhMetaFileDescriptionA(hemf: HENHMETAFILE, cchBuffer: UINT, lpDescription: LPSTR) callconv(.Stdcall) UINT;
pub extern "gdi32" fn GetEnhMetaFileDescriptionW(hemf: HENHMETAFILE, cchBuffer: UINT, lpDescription: LPWSTR) callconv(.Stdcall) UINT;
pub extern "gdi32" fn GetEnhMetaFileHeader(hemf: HENHMETAFILE, nSize: UINT, lpEnhMetaHeader: LPENHMETAHEADER) callconv(.Stdcall) UINT;
pub extern "gdi32" fn GetEnhMetaFilePaletteEntries(hemf: HENHMETAFILE, nNumEntries: UINT, lpPaletteEntries: LPPALETTEENTRY) callconv(.Stdcall) UINT;
pub extern "gdi32" fn GetEnhMetaFilePixelFormat(hemf: HENHMETAFILE, cbBuffer: UINT, ppfd: [*c]PIXELFORMATDESCRIPTOR) callconv(.Stdcall) UINT;
pub extern "gdi32" fn GetWinMetaFileBits(hemf: HENHMETAFILE, cbData16: UINT, pData16: LPBYTE, iMapMode: INT, hdcRef: HDC) callconv(.Stdcall) UINT;
pub extern "gdi32" fn PlayEnhMetaFile(hdc: HDC, hmf: HENHMETAFILE, lprect: [*c]const RECT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn PlayEnhMetaFileRecord(hdc: HDC, pht: LPHANDLETABLE, pmr: [*c]const ENHMETARECORD, cht: UINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SetEnhMetaFileBits(nSize: UINT, pb: [*c]const BYTE) callconv(.Stdcall) HENHMETAFILE;
pub extern "gdi32" fn SetWinMetaFileBits(nSize: UINT, lpMeta16Data: [*c]const BYTE, hdcRef: HDC, lpMFP: [*c]const METAFILEPICT) callconv(.Stdcall) HENHMETAFILE;
pub extern "gdi32" fn GdiComment(hdc: HDC, nSize: UINT, lpData: [*c]const BYTE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetTextMetricsA(hdc: HDC, lptm: LPTEXTMETRICA) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetTextMetricsW(hdc: HDC, lptm: LPTEXTMETRICW) callconv(.Stdcall) BOOL;
pub const struct_tagDIBSECTION = extern struct {
    dsBm: BITMAP,
    dsBmih: BITMAPINFOHEADER,
    dsBitfields: [3]DWORD,
    dshSection: HANDLE,
    dsOffset: DWORD,
};
pub const DIBSECTION = struct_tagDIBSECTION;
pub const LPDIBSECTION = [*c]struct_tagDIBSECTION;
pub const PDIBSECTION = [*c]struct_tagDIBSECTION;
pub extern "gdi32" fn AngleArc(hdc: HDC, x: c_int, y: c_int, r: DWORD, StartAngle: FLOAT, SweepAngle: FLOAT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn PolyPolyline(hdc: HDC, apt: [*c]const POINT, asz: [*c]const DWORD, csz: DWORD) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetWorldTransform(hdc: HDC, lpxf: LPXFORM) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SetWorldTransform(hdc: HDC, lpxf: [*c]const XFORM) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn ModifyWorldTransform(hdc: HDC, lpxf: [*c]const XFORM, mode: DWORD) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn CombineTransform(lpxfOut: LPXFORM, lpxf1: [*c]const XFORM, lpxf2: [*c]const XFORM) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn CreateDIBSection(hdc: HDC, pbmi: [*c]const BITMAPINFO, usage: UINT, ppvBits: [*c](?*c_void), hSection: HANDLE, offset: DWORD) callconv(.Stdcall) HBITMAP;
pub extern "gdi32" fn GetDIBColorTable(hdc: HDC, iStart: UINT, cEntries: UINT, prgbq: [*c]RGBQUAD) callconv(.Stdcall) UINT;
pub extern "gdi32" fn SetDIBColorTable(hdc: HDC, iStart: UINT, cEntries: UINT, prgbq: [*c]const RGBQUAD) callconv(.Stdcall) UINT;
pub const struct_tagCOLORADJUSTMENT = extern struct {
    caSize: WORD,
    caFlags: WORD,
    caIlluminantIndex: WORD,
    caRedGamma: WORD,
    caGreenGamma: WORD,
    caBlueGamma: WORD,
    caReferenceBlack: WORD,
    caReferenceWhite: WORD,
    caContrast: SHORT,
    caBrightness: SHORT,
    caColorfulness: SHORT,
    caRedGreenTint: SHORT,
};
pub const COLORADJUSTMENT = struct_tagCOLORADJUSTMENT;
pub const PCOLORADJUSTMENT = [*c]struct_tagCOLORADJUSTMENT;
pub const LPCOLORADJUSTMENT = [*c]struct_tagCOLORADJUSTMENT;
pub extern "gdi32" fn SetColorAdjustment(hdc: HDC, lpca: [*c]const COLORADJUSTMENT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetColorAdjustment(hdc: HDC, lpca: LPCOLORADJUSTMENT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn CreateHalftonePalette(hdc: HDC) callconv(.Stdcall) HPALETTE;
pub const ABORTPROC = ?fn (HDC, c_int) callconv(.C) BOOL;
pub const struct__DOCINFOA = extern struct {
    cbSize: c_int,
    lpszDocName: LPCSTR,
    lpszOutput: LPCSTR,
    lpszDatatype: LPCSTR,
    fwType: DWORD,
};
pub const DOCINFOA = struct__DOCINFOA;
pub const LPDOCINFOA = [*c]struct__DOCINFOA;
pub const struct__DOCINFOW = extern struct {
    cbSize: c_int,
    lpszDocName: LPCWSTR,
    lpszOutput: LPCWSTR,
    lpszDatatype: LPCWSTR,
    fwType: DWORD,
};
pub const DOCINFOW = struct__DOCINFOW;
pub const LPDOCINFOW = [*c]struct__DOCINFOW;
pub const DOCINFO = DOCINFOA;
pub const LPDOCINFO = LPDOCINFOA;
pub extern "gdi32" fn StartDocA(hdc: HDC, lpdi: [*c]const DOCINFOA) callconv(.Stdcall) c_int;
pub extern "gdi32" fn StartDocW(hdc: HDC, lpdi: [*c]const DOCINFOW) callconv(.Stdcall) c_int;
pub extern "gdi32" fn EndDoc(hdc: HDC) callconv(.Stdcall) c_int;
pub extern "gdi32" fn StartPage(hdc: HDC) callconv(.Stdcall) c_int;
pub extern "gdi32" fn EndPage(hdc: HDC) callconv(.Stdcall) c_int;
pub extern "gdi32" fn AbortDoc(hdc: HDC) callconv(.Stdcall) c_int;
pub extern "gdi32" fn SetAbortProc(hdc: HDC, proc: ABORTPROC) callconv(.Stdcall) c_int;
pub extern "gdi32" fn AbortPath(hdc: HDC) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn ArcTo(hdc: HDC, left: c_int, top: c_int, right: c_int, bottom: c_int, xr1: c_int, yr1: c_int, xr2: c_int, yr2: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn BeginPath(hdc: HDC) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn CloseFigure(hdc: HDC) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn EndPath(hdc: HDC) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn FillPath(hdc: HDC) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn FlattenPath(hdc: HDC) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetPath(hdc: HDC, apt: LPPOINT, aj: LPBYTE, cpt: c_int) callconv(.Stdcall) c_int;
pub extern "gdi32" fn PathToRegion(hdc: HDC) callconv(.Stdcall) HRGN;
pub extern "gdi32" fn PolyDraw(hdc: HDC, apt: [*c]const POINT, aj: [*c]const BYTE, cpt: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SelectClipPath(hdc: HDC, mode: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SetArcDirection(hdc: HDC, dir: c_int) callconv(.Stdcall) c_int;
pub extern "gdi32" fn SetMiterLimit(hdc: HDC, limit: FLOAT, old: PFLOAT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn StrokeAndFillPath(hdc: HDC) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn StrokePath(hdc: HDC) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn WidenPath(hdc: HDC) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn ExtCreatePen(iPenStyle: DWORD, cWidth: DWORD, plbrush: [*c]const LOGBRUSH, cStyle: DWORD, pstyle: [*c]const DWORD) callconv(.Stdcall) HPEN;
pub extern "gdi32" fn GetMiterLimit(hdc: HDC, plimit: PFLOAT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetArcDirection(hdc: HDC) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetObjectA(h: HANDLE, c: c_int, pv: LPVOID) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetObjectW(h: HANDLE, c: c_int, pv: LPVOID) callconv(.Stdcall) c_int;
pub extern "gdi32" fn MoveToEx(hdc: HDC, x: c_int, y: c_int, lppt: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn TextOutA(hdc: HDC, x: c_int, y: c_int, lpString: LPCSTR, c: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn TextOutW(hdc: HDC, x: c_int, y: c_int, lpString: LPCWSTR, c: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn ExtTextOutA(hdc: HDC, x: c_int, y: c_int, options: UINT, lprect: [*c]const RECT, lpString: LPCSTR, c: UINT, lpDx: [*c]const INT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn ExtTextOutW(hdc: HDC, x: c_int, y: c_int, options: UINT, lprect: [*c]const RECT, lpString: LPCWSTR, c: UINT, lpDx: [*c]const INT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn PolyTextOutA(hdc: HDC, ppt: [*c]const POLYTEXTA, nstrings: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn PolyTextOutW(hdc: HDC, ppt: [*c]const POLYTEXTW, nstrings: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn CreatePolygonRgn(pptl: [*c]const POINT, cPoint: c_int, iMode: c_int) callconv(.Stdcall) HRGN;
pub extern "gdi32" fn DPtoLP(hdc: HDC, lppt: LPPOINT, c: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn LPtoDP(hdc: HDC, lppt: LPPOINT, c: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn Polygon(hdc: HDC, apt: [*c]const POINT, cpt: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn Polyline(hdc: HDC, apt: [*c]const POINT, cpt: c_int) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn PolyBezier(hdc: HDC, apt: [*c]const POINT, cpt: DWORD) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn PolyBezierTo(hdc: HDC, apt: [*c]const POINT, cpt: DWORD) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn PolylineTo(hdc: HDC, apt: [*c]const POINT, cpt: DWORD) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SetViewportExtEx(hdc: HDC, x: c_int, y: c_int, lpsz: LPSIZE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SetViewportOrgEx(hdc: HDC, x: c_int, y: c_int, lppt: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SetWindowExtEx(hdc: HDC, x: c_int, y: c_int, lpsz: LPSIZE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SetWindowOrgEx(hdc: HDC, x: c_int, y: c_int, lppt: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn OffsetViewportOrgEx(hdc: HDC, x: c_int, y: c_int, lppt: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn OffsetWindowOrgEx(hdc: HDC, x: c_int, y: c_int, lppt: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn ScaleViewportExtEx(hdc: HDC, xn: c_int, dx: c_int, yn: c_int, yd: c_int, lpsz: LPSIZE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn ScaleWindowExtEx(hdc: HDC, xn: c_int, xd: c_int, yn: c_int, yd: c_int, lpsz: LPSIZE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SetBitmapDimensionEx(hbm: HBITMAP, w: c_int, h: c_int, lpsz: LPSIZE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SetBrushOrgEx(hdc: HDC, x: c_int, y: c_int, lppt: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetTextFaceA(hdc: HDC, c: c_int, lpName: LPSTR) callconv(.Stdcall) c_int;
pub extern "gdi32" fn GetTextFaceW(hdc: HDC, c: c_int, lpName: LPWSTR) callconv(.Stdcall) c_int;
pub const struct_tagKERNINGPAIR = extern struct {
    wFirst: WORD,
    wSecond: WORD,
    iKernAmount: c_int,
};
pub const KERNINGPAIR = struct_tagKERNINGPAIR;
pub const LPKERNINGPAIR = [*c]struct_tagKERNINGPAIR;
pub extern "gdi32" fn GetKerningPairsA(hdc: HDC, nPairs: DWORD, lpKernPair: LPKERNINGPAIR) callconv(.Stdcall) DWORD;
pub extern "gdi32" fn GetKerningPairsW(hdc: HDC, nPairs: DWORD, lpKernPair: LPKERNINGPAIR) callconv(.Stdcall) DWORD;
pub extern "gdi32" fn GetDCOrgEx(hdc: HDC, lppt: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn FixBrushOrgEx(hdc: HDC, x: c_int, y: c_int, ptl: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn UnrealizeObject(h: HGDIOBJ) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GdiFlush() callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GdiSetBatchLimit(dw: DWORD) callconv(.Stdcall) DWORD;
pub extern "gdi32" fn GdiGetBatchLimit() callconv(.Stdcall) DWORD;
pub const ICMENUMPROCA = ?fn (LPSTR, LPARAM) callconv(.C) c_int;
pub const ICMENUMPROCW = ?fn (LPWSTR, LPARAM) callconv(.C) c_int;
pub extern "gdi32" fn SetICMMode(hdc: HDC, mode: c_int) callconv(.Stdcall) c_int;
pub extern "gdi32" fn CheckColorsInGamut(hdc: HDC, lpRGBTriple: LPRGBTRIPLE, dlpBuffer: LPVOID, nCount: DWORD) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetColorSpace(hdc: HDC) callconv(.Stdcall) HCOLORSPACE;
pub extern "gdi32" fn GetLogColorSpaceA(hColorSpace: HCOLORSPACE, lpBuffer: LPLOGCOLORSPACEA, nSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetLogColorSpaceW(hColorSpace: HCOLORSPACE, lpBuffer: LPLOGCOLORSPACEW, nSize: DWORD) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn CreateColorSpaceA(lplcs: LPLOGCOLORSPACEA) callconv(.Stdcall) HCOLORSPACE;
pub extern "gdi32" fn CreateColorSpaceW(lplcs: LPLOGCOLORSPACEW) callconv(.Stdcall) HCOLORSPACE;
pub extern "gdi32" fn SetColorSpace(hdc: HDC, hcs: HCOLORSPACE) callconv(.Stdcall) HCOLORSPACE;
pub extern "gdi32" fn DeleteColorSpace(hcs: HCOLORSPACE) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetICMProfileA(hdc: HDC, pBufSize: LPDWORD, pszFilename: LPSTR) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetICMProfileW(hdc: HDC, pBufSize: LPDWORD, pszFilename: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SetICMProfileA(hdc: HDC, lpFileName: LPSTR) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SetICMProfileW(hdc: HDC, lpFileName: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn GetDeviceGammaRamp(hdc: HDC, lpRamp: LPVOID) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SetDeviceGammaRamp(hdc: HDC, lpRamp: LPVOID) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn ColorMatchToTarget(hdc: HDC, hdcTarget: HDC, action: DWORD) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn EnumICMProfilesA(hdc: HDC, proc: ICMENUMPROCA, param: LPARAM) callconv(.Stdcall) c_int;
pub extern "gdi32" fn EnumICMProfilesW(hdc: HDC, proc: ICMENUMPROCW, param: LPARAM) callconv(.Stdcall) c_int;
pub extern "gdi32" fn UpdateICMRegKeyA(reserved: DWORD, lpszCMID: LPSTR, lpszFileName: LPSTR, command: UINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn UpdateICMRegKeyW(reserved: DWORD, lpszCMID: LPWSTR, lpszFileName: LPWSTR, command: UINT) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn ColorCorrectPalette(hdc: HDC, hPal: HPALETTE, deFirst: DWORD, num: DWORD) callconv(.Stdcall) BOOL;
pub const struct_tagEMR = extern struct {
    iType: DWORD,
    nSize: DWORD,
};
pub const EMR = struct_tagEMR;
pub const PEMR = [*c]struct_tagEMR;
pub const struct_tagEMRTEXT = extern struct {
    ptlReference: POINTL,
    nChars: DWORD,
    offString: DWORD,
    fOptions: DWORD,
    rcl: RECTL,
    offDx: DWORD,
};
pub const EMRTEXT = struct_tagEMRTEXT;
pub const PEMRTEXT = [*c]struct_tagEMRTEXT;
pub const struct_tagABORTPATH = extern struct {
    emr: EMR,
};
pub const EMRABORTPATH = struct_tagABORTPATH;
pub const PEMRABORTPATH = [*c]struct_tagABORTPATH;
pub const EMRBEGINPATH = struct_tagABORTPATH;
pub const PEMRBEGINPATH = [*c]struct_tagABORTPATH;
pub const EMRENDPATH = struct_tagABORTPATH;
pub const PEMRENDPATH = [*c]struct_tagABORTPATH;
pub const EMRCLOSEFIGURE = struct_tagABORTPATH;
pub const PEMRCLOSEFIGURE = [*c]struct_tagABORTPATH;
pub const EMRFLATTENPATH = struct_tagABORTPATH;
pub const PEMRFLATTENPATH = [*c]struct_tagABORTPATH;
pub const EMRWIDENPATH = struct_tagABORTPATH;
pub const PEMRWIDENPATH = [*c]struct_tagABORTPATH;
pub const EMRSETMETARGN = struct_tagABORTPATH;
pub const PEMRSETMETARGN = [*c]struct_tagABORTPATH;
pub const EMRSAVEDC = struct_tagABORTPATH;
pub const PEMRSAVEDC = [*c]struct_tagABORTPATH;
pub const EMRREALIZEPALETTE = struct_tagABORTPATH;
pub const PEMRREALIZEPALETTE = [*c]struct_tagABORTPATH;
pub const struct_tagEMRSELECTCLIPPATH = extern struct {
    emr: EMR,
    iMode: DWORD,
};
pub const EMRSELECTCLIPPATH = struct_tagEMRSELECTCLIPPATH;
pub const PEMRSELECTCLIPPATH = [*c]struct_tagEMRSELECTCLIPPATH;
pub const EMRSETBKMODE = struct_tagEMRSELECTCLIPPATH;
pub const PEMRSETBKMODE = [*c]struct_tagEMRSELECTCLIPPATH;
pub const EMRSETMAPMODE = struct_tagEMRSELECTCLIPPATH;
pub const PEMRSETMAPMODE = [*c]struct_tagEMRSELECTCLIPPATH;
pub const EMRSETLAYOUT = struct_tagEMRSELECTCLIPPATH;
pub const PEMRSETLAYOUT = [*c]struct_tagEMRSELECTCLIPPATH;
pub const EMRSETPOLYFILLMODE = struct_tagEMRSELECTCLIPPATH;
pub const PEMRSETPOLYFILLMODE = [*c]struct_tagEMRSELECTCLIPPATH;
pub const EMRSETROP2 = struct_tagEMRSELECTCLIPPATH;
pub const PEMRSETROP2 = [*c]struct_tagEMRSELECTCLIPPATH;
pub const EMRSETSTRETCHBLTMODE = struct_tagEMRSELECTCLIPPATH;
pub const PEMRSETSTRETCHBLTMODE = [*c]struct_tagEMRSELECTCLIPPATH;
pub const EMRSETICMMODE = struct_tagEMRSELECTCLIPPATH;
pub const PEMRSETICMMODE = [*c]struct_tagEMRSELECTCLIPPATH;
pub const EMRSETTEXTALIGN = struct_tagEMRSELECTCLIPPATH;
pub const PEMRSETTEXTALIGN = [*c]struct_tagEMRSELECTCLIPPATH;
pub const struct_tagEMRSETMITERLIMIT = extern struct {
    emr: EMR,
    eMiterLimit: FLOAT,
};
pub const EMRSETMITERLIMIT = struct_tagEMRSETMITERLIMIT;
pub const PEMRSETMITERLIMIT = [*c]struct_tagEMRSETMITERLIMIT;
pub const struct_tagEMRRESTOREDC = extern struct {
    emr: EMR,
    iRelative: LONG,
};
pub const EMRRESTOREDC = struct_tagEMRRESTOREDC;
pub const PEMRRESTOREDC = [*c]struct_tagEMRRESTOREDC;
pub const struct_tagEMRSETARCDIRECTION = extern struct {
    emr: EMR,
    iArcDirection: DWORD,
};
pub const EMRSETARCDIRECTION = struct_tagEMRSETARCDIRECTION;
pub const PEMRSETARCDIRECTION = [*c]struct_tagEMRSETARCDIRECTION;
pub const struct_tagEMRSETMAPPERFLAGS = extern struct {
    emr: EMR,
    dwFlags: DWORD,
};
pub const EMRSETMAPPERFLAGS = struct_tagEMRSETMAPPERFLAGS;
pub const PEMRSETMAPPERFLAGS = [*c]struct_tagEMRSETMAPPERFLAGS;
pub const struct_tagEMRSETTEXTCOLOR = extern struct {
    emr: EMR,
    crColor: COLORREF,
};
pub const EMRSETBKCOLOR = struct_tagEMRSETTEXTCOLOR;
pub const PEMRSETBKCOLOR = [*c]struct_tagEMRSETTEXTCOLOR;
pub const EMRSETTEXTCOLOR = struct_tagEMRSETTEXTCOLOR;
pub const PEMRSETTEXTCOLOR = [*c]struct_tagEMRSETTEXTCOLOR;
pub const struct_tagEMRSELECTOBJECT = extern struct {
    emr: EMR,
    ihObject: DWORD,
};
pub const EMRSELECTOBJECT = struct_tagEMRSELECTOBJECT;
pub const PEMRSELECTOBJECT = [*c]struct_tagEMRSELECTOBJECT;
pub const EMRDELETEOBJECT = struct_tagEMRSELECTOBJECT;
pub const PEMRDELETEOBJECT = [*c]struct_tagEMRSELECTOBJECT;
pub const struct_tagEMRSELECTPALETTE = extern struct {
    emr: EMR,
    ihPal: DWORD,
};
pub const EMRSELECTPALETTE = struct_tagEMRSELECTPALETTE;
pub const PEMRSELECTPALETTE = [*c]struct_tagEMRSELECTPALETTE;
pub const struct_tagEMRRESIZEPALETTE = extern struct {
    emr: EMR,
    ihPal: DWORD,
    cEntries: DWORD,
};
pub const EMRRESIZEPALETTE = struct_tagEMRRESIZEPALETTE;
pub const PEMRRESIZEPALETTE = [*c]struct_tagEMRRESIZEPALETTE;
pub const struct_tagEMRSETPALETTEENTRIES = extern struct {
    emr: EMR,
    ihPal: DWORD,
    iStart: DWORD,
    cEntries: DWORD,
    aPalEntries: [1]PALETTEENTRY,
};
pub const EMRSETPALETTEENTRIES = struct_tagEMRSETPALETTEENTRIES;
pub const PEMRSETPALETTEENTRIES = [*c]struct_tagEMRSETPALETTEENTRIES;
pub const struct_tagEMRSETCOLORADJUSTMENT = extern struct {
    emr: EMR,
    ColorAdjustment: COLORADJUSTMENT,
};
pub const EMRSETCOLORADJUSTMENT = struct_tagEMRSETCOLORADJUSTMENT;
pub const PEMRSETCOLORADJUSTMENT = [*c]struct_tagEMRSETCOLORADJUSTMENT;
pub const struct_tagEMRGDICOMMENT = extern struct {
    emr: EMR,
    cbData: DWORD,
    Data: [1]BYTE,
};
pub const EMRGDICOMMENT = struct_tagEMRGDICOMMENT;
pub const PEMRGDICOMMENT = [*c]struct_tagEMRGDICOMMENT;
pub const struct_tagEMREOF = extern struct {
    emr: EMR,
    nPalEntries: DWORD,
    offPalEntries: DWORD,
    nSizeLast: DWORD,
};
pub const EMREOF = struct_tagEMREOF;
pub const PEMREOF = [*c]struct_tagEMREOF;
pub const struct_tagEMRLINETO = extern struct {
    emr: EMR,
    ptl: POINTL,
};
pub const EMRLINETO = struct_tagEMRLINETO;
pub const PEMRLINETO = [*c]struct_tagEMRLINETO;
pub const EMRMOVETOEX = struct_tagEMRLINETO;
pub const PEMRMOVETOEX = [*c]struct_tagEMRLINETO;
pub const struct_tagEMROFFSETCLIPRGN = extern struct {
    emr: EMR,
    ptlOffset: POINTL,
};
pub const EMROFFSETCLIPRGN = struct_tagEMROFFSETCLIPRGN;
pub const PEMROFFSETCLIPRGN = [*c]struct_tagEMROFFSETCLIPRGN;
pub const struct_tagEMRFILLPATH = extern struct {
    emr: EMR,
    rclBounds: RECTL,
};
pub const EMRFILLPATH = struct_tagEMRFILLPATH;
pub const PEMRFILLPATH = [*c]struct_tagEMRFILLPATH;
pub const EMRSTROKEANDFILLPATH = struct_tagEMRFILLPATH;
pub const PEMRSTROKEANDFILLPATH = [*c]struct_tagEMRFILLPATH;
pub const EMRSTROKEPATH = struct_tagEMRFILLPATH;
pub const PEMRSTROKEPATH = [*c]struct_tagEMRFILLPATH;
pub const struct_tagEMREXCLUDECLIPRECT = extern struct {
    emr: EMR,
    rclClip: RECTL,
};
pub const EMREXCLUDECLIPRECT = struct_tagEMREXCLUDECLIPRECT;
pub const PEMREXCLUDECLIPRECT = [*c]struct_tagEMREXCLUDECLIPRECT;
pub const EMRINTERSECTCLIPRECT = struct_tagEMREXCLUDECLIPRECT;
pub const PEMRINTERSECTCLIPRECT = [*c]struct_tagEMREXCLUDECLIPRECT;
pub const struct_tagEMRSETVIEWPORTORGEX = extern struct {
    emr: EMR,
    ptlOrigin: POINTL,
};
pub const EMRSETVIEWPORTORGEX = struct_tagEMRSETVIEWPORTORGEX;
pub const PEMRSETVIEWPORTORGEX = [*c]struct_tagEMRSETVIEWPORTORGEX;
pub const EMRSETWINDOWORGEX = struct_tagEMRSETVIEWPORTORGEX;
pub const PEMRSETWINDOWORGEX = [*c]struct_tagEMRSETVIEWPORTORGEX;
pub const EMRSETBRUSHORGEX = struct_tagEMRSETVIEWPORTORGEX;
pub const PEMRSETBRUSHORGEX = [*c]struct_tagEMRSETVIEWPORTORGEX;
pub const struct_tagEMRSETVIEWPORTEXTEX = extern struct {
    emr: EMR,
    szlExtent: SIZEL,
};
pub const EMRSETVIEWPORTEXTEX = struct_tagEMRSETVIEWPORTEXTEX;
pub const PEMRSETVIEWPORTEXTEX = [*c]struct_tagEMRSETVIEWPORTEXTEX;
pub const EMRSETWINDOWEXTEX = struct_tagEMRSETVIEWPORTEXTEX;
pub const PEMRSETWINDOWEXTEX = [*c]struct_tagEMRSETVIEWPORTEXTEX;
pub const struct_tagEMRSCALEVIEWPORTEXTEX = extern struct {
    emr: EMR,
    xNum: LONG,
    xDenom: LONG,
    yNum: LONG,
    yDenom: LONG,
};
pub const EMRSCALEVIEWPORTEXTEX = struct_tagEMRSCALEVIEWPORTEXTEX;
pub const PEMRSCALEVIEWPORTEXTEX = [*c]struct_tagEMRSCALEVIEWPORTEXTEX;
pub const EMRSCALEWINDOWEXTEX = struct_tagEMRSCALEVIEWPORTEXTEX;
pub const PEMRSCALEWINDOWEXTEX = [*c]struct_tagEMRSCALEVIEWPORTEXTEX;
pub const struct_tagEMRSETWORLDTRANSFORM = extern struct {
    emr: EMR,
    xform: XFORM,
};
pub const EMRSETWORLDTRANSFORM = struct_tagEMRSETWORLDTRANSFORM;
pub const PEMRSETWORLDTRANSFORM = [*c]struct_tagEMRSETWORLDTRANSFORM;
pub const struct_tagEMRMODIFYWORLDTRANSFORM = extern struct {
    emr: EMR,
    xform: XFORM,
    iMode: DWORD,
};
pub const EMRMODIFYWORLDTRANSFORM = struct_tagEMRMODIFYWORLDTRANSFORM;
pub const PEMRMODIFYWORLDTRANSFORM = [*c]struct_tagEMRMODIFYWORLDTRANSFORM;
pub const struct_tagEMRSETPIXELV = extern struct {
    emr: EMR,
    ptlPixel: POINTL,
    crColor: COLORREF,
};
pub const EMRSETPIXELV = struct_tagEMRSETPIXELV;
pub const PEMRSETPIXELV = [*c]struct_tagEMRSETPIXELV;
pub const struct_tagEMREXTFLOODFILL = extern struct {
    emr: EMR,
    ptlStart: POINTL,
    crColor: COLORREF,
    iMode: DWORD,
};
pub const EMREXTFLOODFILL = struct_tagEMREXTFLOODFILL;
pub const PEMREXTFLOODFILL = [*c]struct_tagEMREXTFLOODFILL;
pub const struct_tagEMRELLIPSE = extern struct {
    emr: EMR,
    rclBox: RECTL,
};
pub const EMRELLIPSE = struct_tagEMRELLIPSE;
pub const PEMRELLIPSE = [*c]struct_tagEMRELLIPSE;
pub const EMRRECTANGLE = struct_tagEMRELLIPSE;
pub const PEMRRECTANGLE = [*c]struct_tagEMRELLIPSE;
pub const struct_tagEMRROUNDRECT = extern struct {
    emr: EMR,
    rclBox: RECTL,
    szlCorner: SIZEL,
};
pub const EMRROUNDRECT = struct_tagEMRROUNDRECT;
pub const PEMRROUNDRECT = [*c]struct_tagEMRROUNDRECT;
pub const struct_tagEMRARC = extern struct {
    emr: EMR,
    rclBox: RECTL,
    ptlStart: POINTL,
    ptlEnd: POINTL,
};
pub const EMRARC = struct_tagEMRARC;
pub const PEMRARC = [*c]struct_tagEMRARC;
pub const EMRARCTO = struct_tagEMRARC;
pub const PEMRARCTO = [*c]struct_tagEMRARC;
pub const EMRCHORD = struct_tagEMRARC;
pub const PEMRCHORD = [*c]struct_tagEMRARC;
pub const EMRPIE = struct_tagEMRARC;
pub const PEMRPIE = [*c]struct_tagEMRARC;
pub const struct_tagEMRANGLEARC = extern struct {
    emr: EMR,
    ptlCenter: POINTL,
    nRadius: DWORD,
    eStartAngle: FLOAT,
    eSweepAngle: FLOAT,
};
pub const EMRANGLEARC = struct_tagEMRANGLEARC;
pub const PEMRANGLEARC = [*c]struct_tagEMRANGLEARC;
pub const struct_tagEMRPOLYLINE = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    cptl: DWORD,
    aptl: [1]POINTL,
};
pub const EMRPOLYLINE = struct_tagEMRPOLYLINE;
pub const PEMRPOLYLINE = [*c]struct_tagEMRPOLYLINE;
pub const EMRPOLYBEZIER = struct_tagEMRPOLYLINE;
pub const PEMRPOLYBEZIER = [*c]struct_tagEMRPOLYLINE;
pub const EMRPOLYGON = struct_tagEMRPOLYLINE;
pub const PEMRPOLYGON = [*c]struct_tagEMRPOLYLINE;
pub const EMRPOLYBEZIERTO = struct_tagEMRPOLYLINE;
pub const PEMRPOLYBEZIERTO = [*c]struct_tagEMRPOLYLINE;
pub const EMRPOLYLINETO = struct_tagEMRPOLYLINE;
pub const PEMRPOLYLINETO = [*c]struct_tagEMRPOLYLINE;
pub const struct_tagEMRPOLYLINE16 = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    cpts: DWORD,
    apts: [1]POINTS,
};
pub const EMRPOLYLINE16 = struct_tagEMRPOLYLINE16;
pub const PEMRPOLYLINE16 = [*c]struct_tagEMRPOLYLINE16;
pub const EMRPOLYBEZIER16 = struct_tagEMRPOLYLINE16;
pub const PEMRPOLYBEZIER16 = [*c]struct_tagEMRPOLYLINE16;
pub const EMRPOLYGON16 = struct_tagEMRPOLYLINE16;
pub const PEMRPOLYGON16 = [*c]struct_tagEMRPOLYLINE16;
pub const EMRPOLYBEZIERTO16 = struct_tagEMRPOLYLINE16;
pub const PEMRPOLYBEZIERTO16 = [*c]struct_tagEMRPOLYLINE16;
pub const EMRPOLYLINETO16 = struct_tagEMRPOLYLINE16;
pub const PEMRPOLYLINETO16 = [*c]struct_tagEMRPOLYLINE16;
pub const struct_tagEMRPOLYDRAW = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    cptl: DWORD,
    aptl: [1]POINTL,
    abTypes: [1]BYTE,
};
pub const EMRPOLYDRAW = struct_tagEMRPOLYDRAW;
pub const PEMRPOLYDRAW = [*c]struct_tagEMRPOLYDRAW;
pub const struct_tagEMRPOLYDRAW16 = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    cpts: DWORD,
    apts: [1]POINTS,
    abTypes: [1]BYTE,
};
pub const EMRPOLYDRAW16 = struct_tagEMRPOLYDRAW16;
pub const PEMRPOLYDRAW16 = [*c]struct_tagEMRPOLYDRAW16;
pub const struct_tagEMRPOLYPOLYLINE = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    nPolys: DWORD,
    cptl: DWORD,
    aPolyCounts: [1]DWORD,
    aptl: [1]POINTL,
};
pub const EMRPOLYPOLYLINE = struct_tagEMRPOLYPOLYLINE;
pub const PEMRPOLYPOLYLINE = [*c]struct_tagEMRPOLYPOLYLINE;
pub const EMRPOLYPOLYGON = struct_tagEMRPOLYPOLYLINE;
pub const PEMRPOLYPOLYGON = [*c]struct_tagEMRPOLYPOLYLINE;
pub const struct_tagEMRPOLYPOLYLINE16 = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    nPolys: DWORD,
    cpts: DWORD,
    aPolyCounts: [1]DWORD,
    apts: [1]POINTS,
};
pub const EMRPOLYPOLYLINE16 = struct_tagEMRPOLYPOLYLINE16;
pub const PEMRPOLYPOLYLINE16 = [*c]struct_tagEMRPOLYPOLYLINE16;
pub const EMRPOLYPOLYGON16 = struct_tagEMRPOLYPOLYLINE16;
pub const PEMRPOLYPOLYGON16 = [*c]struct_tagEMRPOLYPOLYLINE16;
pub const struct_tagEMRINVERTRGN = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    cbRgnData: DWORD,
    RgnData: [1]BYTE,
};
pub const EMRINVERTRGN = struct_tagEMRINVERTRGN;
pub const PEMRINVERTRGN = [*c]struct_tagEMRINVERTRGN;
pub const EMRPAINTRGN = struct_tagEMRINVERTRGN;
pub const PEMRPAINTRGN = [*c]struct_tagEMRINVERTRGN;
pub const struct_tagEMRFILLRGN = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    cbRgnData: DWORD,
    ihBrush: DWORD,
    RgnData: [1]BYTE,
};
pub const EMRFILLRGN = struct_tagEMRFILLRGN;
pub const PEMRFILLRGN = [*c]struct_tagEMRFILLRGN;
pub const struct_tagEMRFRAMERGN = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    cbRgnData: DWORD,
    ihBrush: DWORD,
    szlStroke: SIZEL,
    RgnData: [1]BYTE,
};
pub const EMRFRAMERGN = struct_tagEMRFRAMERGN;
pub const PEMRFRAMERGN = [*c]struct_tagEMRFRAMERGN;
pub const struct_tagEMREXTSELECTCLIPRGN = extern struct {
    emr: EMR,
    cbRgnData: DWORD,
    iMode: DWORD,
    RgnData: [1]BYTE,
};
pub const EMREXTSELECTCLIPRGN = struct_tagEMREXTSELECTCLIPRGN;
pub const PEMREXTSELECTCLIPRGN = [*c]struct_tagEMREXTSELECTCLIPRGN;
pub const struct_tagEMREXTTEXTOUTA = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    iGraphicsMode: DWORD,
    exScale: FLOAT,
    eyScale: FLOAT,
    emrtext: EMRTEXT,
};
pub const EMREXTTEXTOUTA = struct_tagEMREXTTEXTOUTA;
pub const PEMREXTTEXTOUTA = [*c]struct_tagEMREXTTEXTOUTA;
pub const EMREXTTEXTOUTW = struct_tagEMREXTTEXTOUTA;
pub const PEMREXTTEXTOUTW = [*c]struct_tagEMREXTTEXTOUTA;
pub const struct_tagEMRPOLYTEXTOUTA = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    iGraphicsMode: DWORD,
    exScale: FLOAT,
    eyScale: FLOAT,
    cStrings: LONG,
    aemrtext: [1]EMRTEXT,
};
pub const EMRPOLYTEXTOUTA = struct_tagEMRPOLYTEXTOUTA;
pub const PEMRPOLYTEXTOUTA = [*c]struct_tagEMRPOLYTEXTOUTA;
pub const EMRPOLYTEXTOUTW = struct_tagEMRPOLYTEXTOUTA;
pub const PEMRPOLYTEXTOUTW = [*c]struct_tagEMRPOLYTEXTOUTA;
pub const struct_tagEMRBITBLT = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    xDest: LONG,
    yDest: LONG,
    cxDest: LONG,
    cyDest: LONG,
    dwRop: DWORD,
    xSrc: LONG,
    ySrc: LONG,
    xformSrc: XFORM,
    crBkColorSrc: COLORREF,
    iUsageSrc: DWORD,
    offBmiSrc: DWORD,
    cbBmiSrc: DWORD,
    offBitsSrc: DWORD,
    cbBitsSrc: DWORD,
};
pub const EMRBITBLT = struct_tagEMRBITBLT;
pub const PEMRBITBLT = [*c]struct_tagEMRBITBLT;
pub const struct_tagEMRSTRETCHBLT = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    xDest: LONG,
    yDest: LONG,
    cxDest: LONG,
    cyDest: LONG,
    dwRop: DWORD,
    xSrc: LONG,
    ySrc: LONG,
    xformSrc: XFORM,
    crBkColorSrc: COLORREF,
    iUsageSrc: DWORD,
    offBmiSrc: DWORD,
    cbBmiSrc: DWORD,
    offBitsSrc: DWORD,
    cbBitsSrc: DWORD,
    cxSrc: LONG,
    cySrc: LONG,
};
pub const EMRSTRETCHBLT = struct_tagEMRSTRETCHBLT;
pub const PEMRSTRETCHBLT = [*c]struct_tagEMRSTRETCHBLT;
pub const struct_tagEMRMASKBLT = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    xDest: LONG,
    yDest: LONG,
    cxDest: LONG,
    cyDest: LONG,
    dwRop: DWORD,
    xSrc: LONG,
    ySrc: LONG,
    xformSrc: XFORM,
    crBkColorSrc: COLORREF,
    iUsageSrc: DWORD,
    offBmiSrc: DWORD,
    cbBmiSrc: DWORD,
    offBitsSrc: DWORD,
    cbBitsSrc: DWORD,
    xMask: LONG,
    yMask: LONG,
    iUsageMask: DWORD,
    offBmiMask: DWORD,
    cbBmiMask: DWORD,
    offBitsMask: DWORD,
    cbBitsMask: DWORD,
};
pub const EMRMASKBLT = struct_tagEMRMASKBLT;
pub const PEMRMASKBLT = [*c]struct_tagEMRMASKBLT;
pub const struct_tagEMRPLGBLT = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    aptlDest: [3]POINTL,
    xSrc: LONG,
    ySrc: LONG,
    cxSrc: LONG,
    cySrc: LONG,
    xformSrc: XFORM,
    crBkColorSrc: COLORREF,
    iUsageSrc: DWORD,
    offBmiSrc: DWORD,
    cbBmiSrc: DWORD,
    offBitsSrc: DWORD,
    cbBitsSrc: DWORD,
    xMask: LONG,
    yMask: LONG,
    iUsageMask: DWORD,
    offBmiMask: DWORD,
    cbBmiMask: DWORD,
    offBitsMask: DWORD,
    cbBitsMask: DWORD,
};
pub const EMRPLGBLT = struct_tagEMRPLGBLT;
pub const PEMRPLGBLT = [*c]struct_tagEMRPLGBLT;
pub const struct_tagEMRSETDIBITSTODEVICE = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    xDest: LONG,
    yDest: LONG,
    xSrc: LONG,
    ySrc: LONG,
    cxSrc: LONG,
    cySrc: LONG,
    offBmiSrc: DWORD,
    cbBmiSrc: DWORD,
    offBitsSrc: DWORD,
    cbBitsSrc: DWORD,
    iUsageSrc: DWORD,
    iStartScan: DWORD,
    cScans: DWORD,
};
pub const EMRSETDIBITSTODEVICE = struct_tagEMRSETDIBITSTODEVICE;
pub const PEMRSETDIBITSTODEVICE = [*c]struct_tagEMRSETDIBITSTODEVICE;
pub const struct_tagEMRSTRETCHDIBITS = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    xDest: LONG,
    yDest: LONG,
    xSrc: LONG,
    ySrc: LONG,
    cxSrc: LONG,
    cySrc: LONG,
    offBmiSrc: DWORD,
    cbBmiSrc: DWORD,
    offBitsSrc: DWORD,
    cbBitsSrc: DWORD,
    iUsageSrc: DWORD,
    dwRop: DWORD,
    cxDest: LONG,
    cyDest: LONG,
};
pub const EMRSTRETCHDIBITS = struct_tagEMRSTRETCHDIBITS;
pub const PEMRSTRETCHDIBITS = [*c]struct_tagEMRSTRETCHDIBITS;
pub const struct_tagEMREXTCREATEFONTINDIRECTW = extern struct {
    emr: EMR,
    ihFont: DWORD,
    elfw: EXTLOGFONTW,
};
pub const EMREXTCREATEFONTINDIRECTW = struct_tagEMREXTCREATEFONTINDIRECTW;
pub const PEMREXTCREATEFONTINDIRECTW = [*c]struct_tagEMREXTCREATEFONTINDIRECTW;
pub const struct_tagEMRCREATEPALETTE = extern struct {
    emr: EMR,
    ihPal: DWORD,
    lgpl: LOGPALETTE,
};
pub const EMRCREATEPALETTE = struct_tagEMRCREATEPALETTE;
pub const PEMRCREATEPALETTE = [*c]struct_tagEMRCREATEPALETTE;
pub const struct_tagEMRCREATEPEN = extern struct {
    emr: EMR,
    ihPen: DWORD,
    lopn: LOGPEN,
};
pub const EMRCREATEPEN = struct_tagEMRCREATEPEN;
pub const PEMRCREATEPEN = [*c]struct_tagEMRCREATEPEN;
pub const struct_tagEMREXTCREATEPEN = extern struct {
    emr: EMR,
    ihPen: DWORD,
    offBmi: DWORD,
    cbBmi: DWORD,
    offBits: DWORD,
    cbBits: DWORD,
    elp: EXTLOGPEN32,
};
pub const EMREXTCREATEPEN = struct_tagEMREXTCREATEPEN;
pub const PEMREXTCREATEPEN = [*c]struct_tagEMREXTCREATEPEN;
pub const struct_tagEMRCREATEBRUSHINDIRECT = extern struct {
    emr: EMR,
    ihBrush: DWORD,
    lb: LOGBRUSH32,
};
pub const EMRCREATEBRUSHINDIRECT = struct_tagEMRCREATEBRUSHINDIRECT;
pub const PEMRCREATEBRUSHINDIRECT = [*c]struct_tagEMRCREATEBRUSHINDIRECT;
pub const struct_tagEMRCREATEMONOBRUSH = extern struct {
    emr: EMR,
    ihBrush: DWORD,
    iUsage: DWORD,
    offBmi: DWORD,
    cbBmi: DWORD,
    offBits: DWORD,
    cbBits: DWORD,
};
pub const EMRCREATEMONOBRUSH = struct_tagEMRCREATEMONOBRUSH;
pub const PEMRCREATEMONOBRUSH = [*c]struct_tagEMRCREATEMONOBRUSH;
pub const struct_tagEMRCREATEDIBPATTERNBRUSHPT = extern struct {
    emr: EMR,
    ihBrush: DWORD,
    iUsage: DWORD,
    offBmi: DWORD,
    cbBmi: DWORD,
    offBits: DWORD,
    cbBits: DWORD,
};
pub const EMRCREATEDIBPATTERNBRUSHPT = struct_tagEMRCREATEDIBPATTERNBRUSHPT;
pub const PEMRCREATEDIBPATTERNBRUSHPT = [*c]struct_tagEMRCREATEDIBPATTERNBRUSHPT;
pub const struct_tagEMRFORMAT = extern struct {
    dSignature: DWORD,
    nVersion: DWORD,
    cbData: DWORD,
    offData: DWORD,
};
pub const EMRFORMAT = struct_tagEMRFORMAT;
pub const PEMRFORMAT = [*c]struct_tagEMRFORMAT;
pub const struct_tagEMRGLSRECORD = extern struct {
    emr: EMR,
    cbData: DWORD,
    Data: [1]BYTE,
};
pub const EMRGLSRECORD = struct_tagEMRGLSRECORD;
pub const PEMRGLSRECORD = [*c]struct_tagEMRGLSRECORD;
pub const struct_tagEMRGLSBOUNDEDRECORD = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    cbData: DWORD,
    Data: [1]BYTE,
};
pub const EMRGLSBOUNDEDRECORD = struct_tagEMRGLSBOUNDEDRECORD;
pub const PEMRGLSBOUNDEDRECORD = [*c]struct_tagEMRGLSBOUNDEDRECORD;
pub const struct_tagEMRPIXELFORMAT = extern struct {
    emr: EMR,
    pfd: PIXELFORMATDESCRIPTOR,
};
pub const EMRPIXELFORMAT = struct_tagEMRPIXELFORMAT;
pub const PEMRPIXELFORMAT = [*c]struct_tagEMRPIXELFORMAT;
pub const struct_tagEMRCREATECOLORSPACE = extern struct {
    emr: EMR,
    ihCS: DWORD,
    lcs: LOGCOLORSPACEA,
};
pub const EMRCREATECOLORSPACE = struct_tagEMRCREATECOLORSPACE;
pub const PEMRCREATECOLORSPACE = [*c]struct_tagEMRCREATECOLORSPACE;
pub const struct_tagEMRSETCOLORSPACE = extern struct {
    emr: EMR,
    ihCS: DWORD,
};
pub const EMRSETCOLORSPACE = struct_tagEMRSETCOLORSPACE;
pub const PEMRSETCOLORSPACE = [*c]struct_tagEMRSETCOLORSPACE;
pub const EMRSELECTCOLORSPACE = struct_tagEMRSETCOLORSPACE;
pub const PEMRSELECTCOLORSPACE = [*c]struct_tagEMRSETCOLORSPACE;
pub const EMRDELETECOLORSPACE = struct_tagEMRSETCOLORSPACE;
pub const PEMRDELETECOLORSPACE = [*c]struct_tagEMRSETCOLORSPACE;
pub const struct_tagEMREXTESCAPE = extern struct {
    emr: EMR,
    iEscape: INT,
    cbEscData: INT,
    EscData: [1]BYTE,
};
pub const EMREXTESCAPE = struct_tagEMREXTESCAPE;
pub const PEMREXTESCAPE = [*c]struct_tagEMREXTESCAPE;
pub const EMRDRAWESCAPE = struct_tagEMREXTESCAPE;
pub const PEMRDRAWESCAPE = [*c]struct_tagEMREXTESCAPE;
pub const struct_tagEMRNAMEDESCAPE = extern struct {
    emr: EMR,
    iEscape: INT,
    cbDriver: INT,
    cbEscData: INT,
    EscData: [1]BYTE,
};
pub const EMRNAMEDESCAPE = struct_tagEMRNAMEDESCAPE;
pub const PEMRNAMEDESCAPE = [*c]struct_tagEMRNAMEDESCAPE;
pub const struct_tagEMRSETICMPROFILE = extern struct {
    emr: EMR,
    dwFlags: DWORD,
    cbName: DWORD,
    cbData: DWORD,
    Data: [1]BYTE,
};
pub const EMRSETICMPROFILE = struct_tagEMRSETICMPROFILE;
pub const PEMRSETICMPROFILE = [*c]struct_tagEMRSETICMPROFILE;
pub const EMRSETICMPROFILEA = struct_tagEMRSETICMPROFILE;
pub const PEMRSETICMPROFILEA = [*c]struct_tagEMRSETICMPROFILE;
pub const EMRSETICMPROFILEW = struct_tagEMRSETICMPROFILE;
pub const PEMRSETICMPROFILEW = [*c]struct_tagEMRSETICMPROFILE;
pub const struct_tagEMRCREATECOLORSPACEW = extern struct {
    emr: EMR,
    ihCS: DWORD,
    lcs: LOGCOLORSPACEW,
    dwFlags: DWORD,
    cbData: DWORD,
    Data: [1]BYTE,
};
pub const EMRCREATECOLORSPACEW = struct_tagEMRCREATECOLORSPACEW;
pub const PEMRCREATECOLORSPACEW = [*c]struct_tagEMRCREATECOLORSPACEW;
pub const struct_tagCOLORMATCHTOTARGET = extern struct {
    emr: EMR,
    dwAction: DWORD,
    dwFlags: DWORD,
    cbName: DWORD,
    cbData: DWORD,
    Data: [1]BYTE,
};
pub const EMRCOLORMATCHTOTARGET = struct_tagCOLORMATCHTOTARGET;
pub const PEMRCOLORMATCHTOTARGET = [*c]struct_tagCOLORMATCHTOTARGET;
pub const struct_tagCOLORCORRECTPALETTE = extern struct {
    emr: EMR,
    ihPalette: DWORD,
    nFirstEntry: DWORD,
    nPalEntries: DWORD,
    nReserved: DWORD,
};
pub const EMRCOLORCORRECTPALETTE = struct_tagCOLORCORRECTPALETTE;
pub const PEMRCOLORCORRECTPALETTE = [*c]struct_tagCOLORCORRECTPALETTE;
pub const struct_tagEMRALPHABLEND = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    xDest: LONG,
    yDest: LONG,
    cxDest: LONG,
    cyDest: LONG,
    dwRop: DWORD,
    xSrc: LONG,
    ySrc: LONG,
    xformSrc: XFORM,
    crBkColorSrc: COLORREF,
    iUsageSrc: DWORD,
    offBmiSrc: DWORD,
    cbBmiSrc: DWORD,
    offBitsSrc: DWORD,
    cbBitsSrc: DWORD,
    cxSrc: LONG,
    cySrc: LONG,
};
pub const EMRALPHABLEND = struct_tagEMRALPHABLEND;
pub const PEMRALPHABLEND = [*c]struct_tagEMRALPHABLEND;
pub const struct_tagEMRGRADIENTFILL = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    nVer: DWORD,
    nTri: DWORD,
    ulMode: ULONG,
    Ver: [1]TRIVERTEX,
};
pub const EMRGRADIENTFILL = struct_tagEMRGRADIENTFILL;
pub const PEMRGRADIENTFILL = [*c]struct_tagEMRGRADIENTFILL;
pub const struct_tagEMRTRANSPARENTBLT = extern struct {
    emr: EMR,
    rclBounds: RECTL,
    xDest: LONG,
    yDest: LONG,
    cxDest: LONG,
    cyDest: LONG,
    dwRop: DWORD,
    xSrc: LONG,
    ySrc: LONG,
    xformSrc: XFORM,
    crBkColorSrc: COLORREF,
    iUsageSrc: DWORD,
    offBmiSrc: DWORD,
    cbBmiSrc: DWORD,
    offBitsSrc: DWORD,
    cbBitsSrc: DWORD,
    cxSrc: LONG,
    cySrc: LONG,
};
pub const EMRTRANSPARENTBLT = struct_tagEMRTRANSPARENTBLT;
pub const PEMRTRANSPARENTBLT = [*c]struct_tagEMRTRANSPARENTBLT;
pub extern "opengl32" fn wglCopyContext(arg0: HGLRC, arg1: HGLRC, arg2: UINT) callconv(.Stdcall) BOOL;
pub extern "opengl32" fn wglCreateContext(arg0: HDC) callconv(.Stdcall) HGLRC;
pub extern "opengl32" fn wglCreateLayerContext(arg0: HDC, arg1: c_int) callconv(.Stdcall) HGLRC;
pub extern "opengl32" fn wglDeleteContext(arg0: HGLRC) callconv(.Stdcall) BOOL;
pub extern "opengl32" fn wglGetCurrentContext() callconv(.Stdcall) HGLRC;
pub extern "opengl32" fn wglGetCurrentDC() callconv(.Stdcall) HDC;
pub extern "opengl32" fn wglGetProcAddress(arg0: LPCSTR) callconv(.Stdcall) PROC;
pub extern "opengl32" fn wglMakeCurrent(arg0: HDC, arg1: HGLRC) callconv(.Stdcall) BOOL;
pub extern "opengl32" fn wglShareLists(arg0: HGLRC, arg1: HGLRC) callconv(.Stdcall) BOOL;
pub extern "opengl32" fn wglUseFontBitmapsA(arg0: HDC, arg1: DWORD, arg2: DWORD, arg3: DWORD) callconv(.Stdcall) BOOL;
pub extern "opengl32" fn wglUseFontBitmapsW(arg0: HDC, arg1: DWORD, arg2: DWORD, arg3: DWORD) callconv(.Stdcall) BOOL;
pub extern "gdi32" fn SwapBuffers(arg0: HDC) callconv(.Stdcall) BOOL;
pub const struct__POINTFLOAT = extern struct {
    x: FLOAT,
    y: FLOAT,
};
pub const POINTFLOAT = struct__POINTFLOAT;
pub const PPOINTFLOAT = [*c]struct__POINTFLOAT;
pub const struct__GLYPHMETRICSFLOAT = extern struct {
    gmfBlackBoxX: FLOAT,
    gmfBlackBoxY: FLOAT,
    gmfptGlyphOrigin: POINTFLOAT,
    gmfCellIncX: FLOAT,
    gmfCellIncY: FLOAT,
};
pub const GLYPHMETRICSFLOAT = struct__GLYPHMETRICSFLOAT;
pub const PGLYPHMETRICSFLOAT = [*c]struct__GLYPHMETRICSFLOAT;
pub const LPGLYPHMETRICSFLOAT = [*c]struct__GLYPHMETRICSFLOAT;
pub extern "opengl32" fn wglUseFontOutlinesA(arg0: HDC, arg1: DWORD, arg2: DWORD, arg3: DWORD, arg4: FLOAT, arg5: FLOAT, arg6: c_int, arg7: LPGLYPHMETRICSFLOAT) callconv(.Stdcall) BOOL;
pub extern "opengl32" fn wglUseFontOutlinesW(arg0: HDC, arg1: DWORD, arg2: DWORD, arg3: DWORD, arg4: FLOAT, arg5: FLOAT, arg6: c_int, arg7: LPGLYPHMETRICSFLOAT) callconv(.Stdcall) BOOL;
pub const struct_tagLAYERPLANEDESCRIPTOR = extern struct {
    nSize: WORD,
    nVersion: WORD,
    dwFlags: DWORD,
    iPixelType: BYTE,
    cColorBits: BYTE,
    cRedBits: BYTE,
    cRedShift: BYTE,
    cGreenBits: BYTE,
    cGreenShift: BYTE,
    cBlueBits: BYTE,
    cBlueShift: BYTE,
    cAlphaBits: BYTE,
    cAlphaShift: BYTE,
    cAccumBits: BYTE,
    cAccumRedBits: BYTE,
    cAccumGreenBits: BYTE,
    cAccumBlueBits: BYTE,
    cAccumAlphaBits: BYTE,
    cDepthBits: BYTE,
    cStencilBits: BYTE,
    cAuxBuffers: BYTE,
    iLayerPlane: BYTE,
    bReserved: BYTE,
    crTransparent: COLORREF,
};
pub const LAYERPLANEDESCRIPTOR = struct_tagLAYERPLANEDESCRIPTOR;
pub const PLAYERPLANEDESCRIPTOR = [*c]struct_tagLAYERPLANEDESCRIPTOR;
pub const LPLAYERPLANEDESCRIPTOR = [*c]struct_tagLAYERPLANEDESCRIPTOR;
pub extern "opengl32" fn wglDescribeLayerPlane(arg0: HDC, arg1: c_int, arg2: c_int, arg3: UINT, arg4: LPLAYERPLANEDESCRIPTOR) callconv(.Stdcall) BOOL;
pub extern "opengl32" fn wglSetLayerPaletteEntries(arg0: HDC, arg1: c_int, arg2: c_int, arg3: c_int, arg4: [*c]const COLORREF) callconv(.Stdcall) c_int;
pub extern "opengl32" fn wglGetLayerPaletteEntries(arg0: HDC, arg1: c_int, arg2: c_int, arg3: c_int, arg4: [*c]COLORREF) callconv(.Stdcall) c_int;
pub extern "opengl32" fn wglRealizeLayerPalette(arg0: HDC, arg1: c_int, arg2: BOOL) callconv(.Stdcall) BOOL;
pub extern "opengl32" fn wglSwapLayerBuffers(arg0: HDC, arg1: UINT) callconv(.Stdcall) BOOL;
pub const struct__WGLSWAP = extern struct {
    hdc: HDC,
    uiFlags: UINT,
};
pub const WGLSWAP = struct__WGLSWAP;
pub const PWGLSWAP = [*c]struct__WGLSWAP;
pub const LPWGLSWAP = [*c]struct__WGLSWAP;
pub extern "opengl32" fn wglSwapMultipleBuffers(arg0: UINT, arg1: [*c]const WGLSWAP) callconv(.Stdcall) DWORD;
pub const HDWP = HANDLE;
pub const MENUTEMPLATEA = c_void;
pub const MENUTEMPLATEW = c_void;
pub const MENUTEMPLATE = MENUTEMPLATEA;
pub const LPMENUTEMPLATEA = PVOID;
pub const LPMENUTEMPLATEW = PVOID;
pub const LPMENUTEMPLATE = LPMENUTEMPLATEA;
pub const WNDPROC = ?fn (HWND, UINT, WPARAM, LPARAM) callconv(.C) LRESULT;
pub const DLGPROC = ?fn (HWND, UINT, WPARAM, LPARAM) callconv(.C) INT_PTR;
pub const TIMERPROC = ?fn (HWND, UINT, UINT_PTR, DWORD) callconv(.C) void;
pub const GRAYSTRINGPROC = ?fn (HDC, LPARAM, c_int) callconv(.C) BOOL;
pub const WNDENUMPROC = ?fn (HWND, LPARAM) callconv(.C) BOOL;
pub const HOOKPROC = ?fn (c_int, WPARAM, LPARAM) callconv(.C) LRESULT;
pub const SENDASYNCPROC = ?fn (HWND, UINT, ULONG_PTR, LRESULT) callconv(.C) void;
pub const PROPENUMPROCA = ?fn (HWND, LPCSTR, HANDLE) callconv(.C) BOOL;
pub const PROPENUMPROCW = ?fn (HWND, LPCWSTR, HANDLE) callconv(.C) BOOL;
pub const PROPENUMPROCEXA = ?fn (HWND, LPSTR, HANDLE, ULONG_PTR) callconv(.C) BOOL;
pub const PROPENUMPROCEXW = ?fn (HWND, LPWSTR, HANDLE, ULONG_PTR) callconv(.C) BOOL;
pub const EDITWORDBREAKPROCA = ?fn (LPSTR, c_int, c_int, c_int) callconv(.C) c_int;
pub const EDITWORDBREAKPROCW = ?fn (LPWSTR, c_int, c_int, c_int) callconv(.C) c_int;
pub const DRAWSTATEPROC = ?fn (HDC, LPARAM, WPARAM, c_int, c_int) callconv(.C) BOOL;
pub const PROPENUMPROC = PROPENUMPROCA;
pub const PROPENUMPROCEX = PROPENUMPROCEXA;
pub const EDITWORDBREAKPROC = EDITWORDBREAKPROCA;
pub const NAMEENUMPROCA = ?fn (LPSTR, LPARAM) callconv(.C) BOOL;
pub const NAMEENUMPROCW = ?fn (LPWSTR, LPARAM) callconv(.C) BOOL;
pub const WINSTAENUMPROCA = NAMEENUMPROCA;
pub const DESKTOPENUMPROCA = NAMEENUMPROCA;
pub const WINSTAENUMPROCW = NAMEENUMPROCW;
pub const DESKTOPENUMPROCW = NAMEENUMPROCW;
pub const WINSTAENUMPROC = WINSTAENUMPROCA;
pub const DESKTOPENUMPROC = DESKTOPENUMPROCA;
pub extern "user32" fn wvsprintfA(arg0: LPSTR, arg1: LPCSTR, arglist: va_list) callconv(.Stdcall) c_int;
pub extern "user32" fn wvsprintfW(arg0: LPWSTR, arg1: LPCWSTR, arglist: va_list) callconv(.Stdcall) c_int;
pub extern "user32" fn wsprintfA(arg0: LPSTR, arg1: LPCSTR, ...) callconv(.Stdcall) c_int;
pub extern "user32" fn wsprintfW(arg0: LPWSTR, arg1: LPCWSTR, ...) callconv(.Stdcall) c_int;
pub const struct_tagCREATESTRUCTA = extern struct {
    lpCreateParams: LPVOID,
    hInstance: HINSTANCE,
    hMenu: HMENU,
    hwndParent: HWND,
    cy: c_int,
    cx: c_int,
    y: c_int,
    x: c_int,
    style: LONG,
    lpszName: LPCSTR,
    lpszClass: LPCSTR,
    dwExStyle: DWORD,
};
pub const struct_tagCBT_CREATEWNDA = extern struct {
    lpcs: [*c]struct_tagCREATESTRUCTA,
    hwndInsertAfter: HWND,
};
pub const CBT_CREATEWNDA = struct_tagCBT_CREATEWNDA;
pub const LPCBT_CREATEWNDA = [*c]struct_tagCBT_CREATEWNDA;
pub const struct_tagCREATESTRUCTW = extern struct {
    lpCreateParams: LPVOID,
    hInstance: HINSTANCE,
    hMenu: HMENU,
    hwndParent: HWND,
    cy: c_int,
    cx: c_int,
    y: c_int,
    x: c_int,
    style: LONG,
    lpszName: LPCWSTR,
    lpszClass: LPCWSTR,
    dwExStyle: DWORD,
};
pub const struct_tagCBT_CREATEWNDW = extern struct {
    lpcs: [*c]struct_tagCREATESTRUCTW,
    hwndInsertAfter: HWND,
};
pub const CBT_CREATEWNDW = struct_tagCBT_CREATEWNDW;
pub const LPCBT_CREATEWNDW = [*c]struct_tagCBT_CREATEWNDW;
pub const CBT_CREATEWND = CBT_CREATEWNDA;
pub const LPCBT_CREATEWND = LPCBT_CREATEWNDA;
pub const struct_tagCBTACTIVATESTRUCT = extern struct {
    fMouse: BOOL,
    hWndActive: HWND,
};
pub const CBTACTIVATESTRUCT = struct_tagCBTACTIVATESTRUCT;
pub const LPCBTACTIVATESTRUCT = [*c]struct_tagCBTACTIVATESTRUCT;
pub const struct_tagWTSSESSION_NOTIFICATION = extern struct {
    cbSize: DWORD,
    dwSessionId: DWORD,
};
pub const WTSSESSION_NOTIFICATION = struct_tagWTSSESSION_NOTIFICATION;
pub const PWTSSESSION_NOTIFICATION = [*c]struct_tagWTSSESSION_NOTIFICATION;
pub const SHELLHOOKINFO = extern struct {
    hwnd: HWND,
    rc: RECT,
};
pub const LPSHELLHOOKINFO = [*c]extern struct {
    hwnd: HWND,
    rc: RECT,
};
pub const struct_tagEVENTMSG = extern struct {
    message: UINT,
    paramL: UINT,
    paramH: UINT,
    time: DWORD,
    hwnd: HWND,
};
pub const EVENTMSG = struct_tagEVENTMSG;
pub const PEVENTMSGMSG = [*c]struct_tagEVENTMSG;
pub const NPEVENTMSGMSG = [*c]struct_tagEVENTMSG;
pub const LPEVENTMSGMSG = [*c]struct_tagEVENTMSG;
pub const PEVENTMSG = [*c]struct_tagEVENTMSG;
pub const NPEVENTMSG = [*c]struct_tagEVENTMSG;
pub const LPEVENTMSG = [*c]struct_tagEVENTMSG;
pub const struct_tagCWPSTRUCT = extern struct {
    lParam: LPARAM,
    wParam: WPARAM,
    message: UINT,
    hwnd: HWND,
};
pub const CWPSTRUCT = struct_tagCWPSTRUCT;
pub const PCWPSTRUCT = [*c]struct_tagCWPSTRUCT;
pub const NPCWPSTRUCT = [*c]struct_tagCWPSTRUCT;
pub const LPCWPSTRUCT = [*c]struct_tagCWPSTRUCT;
pub const struct_tagCWPRETSTRUCT = extern struct {
    lResult: LRESULT,
    lParam: LPARAM,
    wParam: WPARAM,
    message: UINT,
    hwnd: HWND,
};
pub const CWPRETSTRUCT = struct_tagCWPRETSTRUCT;
pub const PCWPRETSTRUCT = [*c]struct_tagCWPRETSTRUCT;
pub const NPCWPRETSTRUCT = [*c]struct_tagCWPRETSTRUCT;
pub const LPCWPRETSTRUCT = [*c]struct_tagCWPRETSTRUCT;
pub const struct_tagKBDLLHOOKSTRUCT = extern struct {
    vkCode: DWORD,
    scanCode: DWORD,
    flags: DWORD,
    time: DWORD,
    dwExtraInfo: ULONG_PTR,
};
pub const KBDLLHOOKSTRUCT = struct_tagKBDLLHOOKSTRUCT;
pub const LPKBDLLHOOKSTRUCT = [*c]struct_tagKBDLLHOOKSTRUCT;
pub const PKBDLLHOOKSTRUCT = [*c]struct_tagKBDLLHOOKSTRUCT;
pub const struct_tagMSLLHOOKSTRUCT = extern struct {
    pt: POINT,
    mouseData: DWORD,
    flags: DWORD,
    time: DWORD,
    dwExtraInfo: ULONG_PTR,
};
pub const MSLLHOOKSTRUCT = struct_tagMSLLHOOKSTRUCT;
pub const LPMSLLHOOKSTRUCT = [*c]struct_tagMSLLHOOKSTRUCT;
pub const PMSLLHOOKSTRUCT = [*c]struct_tagMSLLHOOKSTRUCT;
pub const struct_tagDEBUGHOOKINFO = extern struct {
    idThread: DWORD,
    idThreadInstaller: DWORD,
    lParam: LPARAM,
    wParam: WPARAM,
    code: c_int,
};
pub const DEBUGHOOKINFO = struct_tagDEBUGHOOKINFO;
pub const PDEBUGHOOKINFO = [*c]struct_tagDEBUGHOOKINFO;
pub const NPDEBUGHOOKINFO = [*c]struct_tagDEBUGHOOKINFO;
pub const LPDEBUGHOOKINFO = [*c]struct_tagDEBUGHOOKINFO;
pub const struct_tagMOUSEHOOKSTRUCT = extern struct {
    pt: POINT,
    hwnd: HWND,
    wHitTestCode: UINT,
    dwExtraInfo: ULONG_PTR,
};
pub const MOUSEHOOKSTRUCT = struct_tagMOUSEHOOKSTRUCT;
pub const LPMOUSEHOOKSTRUCT = [*c]struct_tagMOUSEHOOKSTRUCT;
pub const PMOUSEHOOKSTRUCT = [*c]struct_tagMOUSEHOOKSTRUCT;
pub const struct_tagMOUSEHOOKSTRUCTEX = extern struct {
    @"": struct_tagMOUSEHOOKSTRUCT,
    mouseData: DWORD,
};
pub const MOUSEHOOKSTRUCTEX = struct_tagMOUSEHOOKSTRUCTEX;
pub const LPMOUSEHOOKSTRUCTEX = [*c]struct_tagMOUSEHOOKSTRUCTEX;
pub const PMOUSEHOOKSTRUCTEX = [*c]struct_tagMOUSEHOOKSTRUCTEX;
pub const struct_tagHARDWAREHOOKSTRUCT = extern struct {
    hwnd: HWND,
    message: UINT,
    wParam: WPARAM,
    lParam: LPARAM,
};
pub const HARDWAREHOOKSTRUCT = struct_tagHARDWAREHOOKSTRUCT;
pub const LPHARDWAREHOOKSTRUCT = [*c]struct_tagHARDWAREHOOKSTRUCT;
pub const PHARDWAREHOOKSTRUCT = [*c]struct_tagHARDWAREHOOKSTRUCT;
pub extern "user32" fn LoadKeyboardLayoutA(pwszKLID: LPCSTR, Flags: UINT) callconv(.Stdcall) HKL;
pub extern "user32" fn LoadKeyboardLayoutW(pwszKLID: LPCWSTR, Flags: UINT) callconv(.Stdcall) HKL;
pub extern "user32" fn ActivateKeyboardLayout(hkl: HKL, Flags: UINT) callconv(.Stdcall) HKL;
pub extern "user32" fn ToUnicodeEx(wVirtKey: UINT, wScanCode: UINT, lpKeyState: [*c]const BYTE, pwszBuff: LPWSTR, cchBuff: c_int, wFlags: UINT, dwhkl: HKL) callconv(.Stdcall) c_int;
pub extern "user32" fn UnloadKeyboardLayout(hkl: HKL) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetKeyboardLayoutNameA(pwszKLID: LPSTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetKeyboardLayoutNameW(pwszKLID: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetKeyboardLayoutList(nBuff: c_int, lpList: [*c]HKL) callconv(.Stdcall) c_int;
pub extern "user32" fn GetKeyboardLayout(idThread: DWORD) callconv(.Stdcall) HKL;
pub const struct_tagMOUSEMOVEPOINT = extern struct {
    x: c_int,
    y: c_int,
    time: DWORD,
    dwExtraInfo: ULONG_PTR,
};
pub const MOUSEMOVEPOINT = struct_tagMOUSEMOVEPOINT;
pub const PMOUSEMOVEPOINT = [*c]struct_tagMOUSEMOVEPOINT;
pub const LPMOUSEMOVEPOINT = [*c]struct_tagMOUSEMOVEPOINT;
pub extern "user32" fn GetMouseMovePointsEx(cbSize: UINT, lppt: LPMOUSEMOVEPOINT, lpptBuf: LPMOUSEMOVEPOINT, nBufPoints: c_int, resolution: DWORD) callconv(.Stdcall) c_int;
pub extern "user32" fn CreateDesktopA(lpszDesktop: LPCSTR, lpszDevice: LPCSTR, pDevmode: [*c]DEVMODEA, dwFlags: DWORD, dwDesiredAccess: ACCESS_MASK, lpsa: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) HDESK;
pub extern "user32" fn CreateDesktopW(lpszDesktop: LPCWSTR, lpszDevice: LPCWSTR, pDevmode: [*c]DEVMODEW, dwFlags: DWORD, dwDesiredAccess: ACCESS_MASK, lpsa: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) HDESK;
pub extern "user32" fn CreateDesktopExA(lpszDesktop: LPCSTR, lpszDevice: LPCSTR, pDevmode: [*c]DEVMODEA, dwFlags: DWORD, dwDesiredAccess: ACCESS_MASK, lpsa: LPSECURITY_ATTRIBUTES, ulHeapSize: ULONG, pvoid: PVOID) callconv(.Stdcall) HDESK;
pub extern "user32" fn CreateDesktopExW(lpszDesktop: LPCWSTR, lpszDevice: LPCWSTR, pDevmode: [*c]DEVMODEW, dwFlags: DWORD, dwDesiredAccess: ACCESS_MASK, lpsa: LPSECURITY_ATTRIBUTES, ulHeapSize: ULONG, pvoid: PVOID) callconv(.Stdcall) HDESK;
pub extern "user32" fn OpenDesktopA(lpszDesktop: LPCSTR, dwFlags: DWORD, fInherit: BOOL, dwDesiredAccess: ACCESS_MASK) callconv(.Stdcall) HDESK;
pub extern "user32" fn OpenDesktopW(lpszDesktop: LPCWSTR, dwFlags: DWORD, fInherit: BOOL, dwDesiredAccess: ACCESS_MASK) callconv(.Stdcall) HDESK;
pub extern "user32" fn OpenInputDesktop(dwFlags: DWORD, fInherit: BOOL, dwDesiredAccess: ACCESS_MASK) callconv(.Stdcall) HDESK;
pub extern "user32" fn EnumDesktopsA(hwinsta: HWINSTA, lpEnumFunc: DESKTOPENUMPROCA, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub extern "user32" fn EnumDesktopsW(hwinsta: HWINSTA, lpEnumFunc: DESKTOPENUMPROCW, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub extern "user32" fn EnumDesktopWindows(hDesktop: HDESK, lpfn: WNDENUMPROC, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub extern "user32" fn SwitchDesktop(hDesktop: HDESK) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetThreadDesktop(hDesktop: HDESK) callconv(.Stdcall) BOOL;
pub extern "user32" fn CloseDesktop(hDesktop: HDESK) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetThreadDesktop(dwThreadId: DWORD) callconv(.Stdcall) HDESK;
pub extern "user32" fn CreateWindowStationA(lpwinsta: LPCSTR, dwFlags: DWORD, dwDesiredAccess: ACCESS_MASK, lpsa: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) HWINSTA;
pub extern "user32" fn CreateWindowStationW(lpwinsta: LPCWSTR, dwFlags: DWORD, dwDesiredAccess: ACCESS_MASK, lpsa: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) HWINSTA;
pub extern "user32" fn OpenWindowStationA(lpszWinSta: LPCSTR, fInherit: BOOL, dwDesiredAccess: ACCESS_MASK) callconv(.Stdcall) HWINSTA;
pub extern "user32" fn OpenWindowStationW(lpszWinSta: LPCWSTR, fInherit: BOOL, dwDesiredAccess: ACCESS_MASK) callconv(.Stdcall) HWINSTA;
pub extern "user32" fn EnumWindowStationsA(lpEnumFunc: WINSTAENUMPROCA, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub extern "user32" fn EnumWindowStationsW(lpEnumFunc: WINSTAENUMPROCW, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub extern "user32" fn CloseWindowStation(hWinSta: HWINSTA) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetProcessWindowStation(hWinSta: HWINSTA) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetProcessWindowStation() callconv(.Stdcall) HWINSTA;
pub extern "user32" fn SetUserObjectSecurity(hObj: HANDLE, pSIRequested: PSECURITY_INFORMATION, pSID: PSECURITY_DESCRIPTOR) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetUserObjectSecurity(hObj: HANDLE, pSIRequested: PSECURITY_INFORMATION, pSID: PSECURITY_DESCRIPTOR, nLength: DWORD, lpnLengthNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub const struct_tagUSEROBJECTFLAGS = extern struct {
    fInherit: BOOL,
    fReserved: BOOL,
    dwFlags: DWORD,
};
pub const USEROBJECTFLAGS = struct_tagUSEROBJECTFLAGS;
pub const PUSEROBJECTFLAGS = [*c]struct_tagUSEROBJECTFLAGS;
pub extern "user32" fn GetUserObjectInformationA(hObj: HANDLE, nIndex: c_int, pvInfo: PVOID, nLength: DWORD, lpnLengthNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetUserObjectInformationW(hObj: HANDLE, nIndex: c_int, pvInfo: PVOID, nLength: DWORD, lpnLengthNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetUserObjectInformationA(hObj: HANDLE, nIndex: c_int, pvInfo: PVOID, nLength: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetUserObjectInformationW(hObj: HANDLE, nIndex: c_int, pvInfo: PVOID, nLength: DWORD) callconv(.Stdcall) BOOL;
pub const struct_tagWNDCLASSEXA = extern struct {
    cbSize: UINT,
    style: UINT,
    lpfnWndProc: WNDPROC,
    cbClsExtra: c_int,
    cbWndExtra: c_int,
    hInstance: HINSTANCE,
    hIcon: HICON,
    hCursor: HCURSOR,
    hbrBackground: HBRUSH,
    lpszMenuName: LPCSTR,
    lpszClassName: LPCSTR,
    hIconSm: HICON,
};
pub const WNDCLASSEXA = struct_tagWNDCLASSEXA;
pub const PWNDCLASSEXA = [*c]struct_tagWNDCLASSEXA;
pub const NPWNDCLASSEXA = [*c]struct_tagWNDCLASSEXA;
pub const LPWNDCLASSEXA = [*c]struct_tagWNDCLASSEXA;
pub const struct_tagWNDCLASSEXW = extern struct {
    cbSize: UINT,
    style: UINT,
    lpfnWndProc: WNDPROC,
    cbClsExtra: c_int,
    cbWndExtra: c_int,
    hInstance: HINSTANCE,
    hIcon: HICON,
    hCursor: HCURSOR,
    hbrBackground: HBRUSH,
    lpszMenuName: LPCWSTR,
    lpszClassName: LPCWSTR,
    hIconSm: HICON,
};
pub const WNDCLASSEXW = struct_tagWNDCLASSEXW;
pub const PWNDCLASSEXW = [*c]struct_tagWNDCLASSEXW;
pub const NPWNDCLASSEXW = [*c]struct_tagWNDCLASSEXW;
pub const LPWNDCLASSEXW = [*c]struct_tagWNDCLASSEXW;
pub const WNDCLASSEX = WNDCLASSEXA;
pub const PWNDCLASSEX = PWNDCLASSEXA;
pub const NPWNDCLASSEX = NPWNDCLASSEXA;
pub const LPWNDCLASSEX = LPWNDCLASSEXA;
pub const struct_tagWNDCLASSA = extern struct {
    style: UINT,
    lpfnWndProc: WNDPROC,
    cbClsExtra: c_int,
    cbWndExtra: c_int,
    hInstance: HINSTANCE,
    hIcon: HICON,
    hCursor: HCURSOR,
    hbrBackground: HBRUSH,
    lpszMenuName: LPCSTR,
    lpszClassName: LPCSTR,
};
pub const WNDCLASSA = struct_tagWNDCLASSA;
pub const PWNDCLASSA = [*c]struct_tagWNDCLASSA;
pub const NPWNDCLASSA = [*c]struct_tagWNDCLASSA;
pub const LPWNDCLASSA = [*c]struct_tagWNDCLASSA;
pub const struct_tagWNDCLASSW = extern struct {
    style: UINT,
    lpfnWndProc: WNDPROC,
    cbClsExtra: c_int,
    cbWndExtra: c_int,
    hInstance: HINSTANCE,
    hIcon: HICON,
    hCursor: HCURSOR,
    hbrBackground: HBRUSH,
    lpszMenuName: LPCWSTR,
    lpszClassName: LPCWSTR,
};
pub const WNDCLASSW = struct_tagWNDCLASSW;
pub const PWNDCLASSW = [*c]struct_tagWNDCLASSW;
pub const NPWNDCLASSW = [*c]struct_tagWNDCLASSW;
pub const LPWNDCLASSW = [*c]struct_tagWNDCLASSW;
pub const WNDCLASS = WNDCLASSA;
pub const PWNDCLASS = PWNDCLASSA;
pub const NPWNDCLASS = NPWNDCLASSA;
pub const LPWNDCLASS = LPWNDCLASSA;
pub extern "user32" fn IsHungAppWindow(hwnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn DisableProcessWindowsGhosting() callconv(.Stdcall) void;
pub const struct_tagMSG = extern struct {
    hwnd: HWND,
    message: UINT,
    wParam: WPARAM,
    lParam: LPARAM,
    time: DWORD,
    pt: POINT,
};
pub const MSG = struct_tagMSG;
pub const PMSG = [*c]struct_tagMSG;
pub const NPMSG = [*c]struct_tagMSG;
pub const LPMSG = [*c]struct_tagMSG;
pub const struct_tagMINMAXINFO = extern struct {
    ptReserved: POINT,
    ptMaxSize: POINT,
    ptMaxPosition: POINT,
    ptMinTrackSize: POINT,
    ptMaxTrackSize: POINT,
};
pub const MINMAXINFO = struct_tagMINMAXINFO;
pub const PMINMAXINFO = [*c]struct_tagMINMAXINFO;
pub const LPMINMAXINFO = [*c]struct_tagMINMAXINFO;
pub const struct_tagCOPYDATASTRUCT = extern struct {
    dwData: ULONG_PTR,
    cbData: DWORD,
    lpData: PVOID,
};
pub const COPYDATASTRUCT = struct_tagCOPYDATASTRUCT;
pub const PCOPYDATASTRUCT = [*c]struct_tagCOPYDATASTRUCT;
pub const struct_tagMDINEXTMENU = extern struct {
    hmenuIn: HMENU,
    hmenuNext: HMENU,
    hwndNext: HWND,
};
pub const MDINEXTMENU = struct_tagMDINEXTMENU;
pub const PMDINEXTMENU = [*c]struct_tagMDINEXTMENU;
pub const LPMDINEXTMENU = [*c]struct_tagMDINEXTMENU;
pub const POWERBROADCAST_SETTING = extern struct {
    PowerSetting: GUID,
    DataLength: DWORD,
    Data: [1]UCHAR,
};
pub const PPOWERBROADCAST_SETTING = [*c]extern struct {
    PowerSetting: GUID,
    DataLength: DWORD,
    Data: [1]UCHAR,
};
pub extern "user32" fn RegisterWindowMessageA(lpString: LPCSTR) callconv(.Stdcall) UINT;
pub extern "user32" fn RegisterWindowMessageW(lpString: LPCWSTR) callconv(.Stdcall) UINT;
pub const struct_tagWINDOWPOS = extern struct {
    hwnd: HWND,
    hwndInsertAfter: HWND,
    x: c_int,
    y: c_int,
    cx: c_int,
    cy: c_int,
    flags: UINT,
};
pub const WINDOWPOS = struct_tagWINDOWPOS;
pub const LPWINDOWPOS = [*c]struct_tagWINDOWPOS;
pub const PWINDOWPOS = [*c]struct_tagWINDOWPOS;
pub const struct_tagNCCALCSIZE_PARAMS = extern struct {
    rgrc: [3]RECT,
    lppos: PWINDOWPOS,
};
pub const NCCALCSIZE_PARAMS = struct_tagNCCALCSIZE_PARAMS;
pub const LPNCCALCSIZE_PARAMS = [*c]struct_tagNCCALCSIZE_PARAMS;
pub const struct_tagTRACKMOUSEEVENT = extern struct {
    cbSize: DWORD,
    dwFlags: DWORD,
    hwndTrack: HWND,
    dwHoverTime: DWORD,
};
pub const TRACKMOUSEEVENT = struct_tagTRACKMOUSEEVENT;
pub const LPTRACKMOUSEEVENT = [*c]struct_tagTRACKMOUSEEVENT;
pub extern "user32" fn TrackMouseEvent(lpEventTrack: LPTRACKMOUSEEVENT) callconv(.Stdcall) BOOL;
pub extern "user32" fn DrawEdge(hdc: HDC, qrc: LPRECT, edge: UINT, grfFlags: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn DrawFrameControl(arg0: HDC, arg1: LPRECT, arg2: UINT, arg3: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn DrawCaption(hwnd: HWND, hdc: HDC, lprect: [*c]const RECT, flags: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn DrawAnimatedRects(hwnd: HWND, idAni: c_int, lprcFrom: [*c]const RECT, lprcTo: [*c]const RECT) callconv(.Stdcall) BOOL;
pub const struct_tagACCEL = extern struct {
    fVirt: BYTE,
    key: WORD,
    cmd: WORD,
};
pub const ACCEL = struct_tagACCEL;
pub const LPACCEL = [*c]struct_tagACCEL;
pub const struct_tagPAINTSTRUCT = extern struct {
    hdc: HDC,
    fErase: BOOL,
    rcPaint: RECT,
    fRestore: BOOL,
    fIncUpdate: BOOL,
    rgbReserved: [32]BYTE,
};
pub const PAINTSTRUCT = struct_tagPAINTSTRUCT;
pub const PPAINTSTRUCT = [*c]struct_tagPAINTSTRUCT;
pub const NPPAINTSTRUCT = [*c]struct_tagPAINTSTRUCT;
pub const LPPAINTSTRUCT = [*c]struct_tagPAINTSTRUCT;
pub const CREATESTRUCTA = struct_tagCREATESTRUCTA;
pub const LPCREATESTRUCTA = [*c]struct_tagCREATESTRUCTA;
pub const CREATESTRUCTW = struct_tagCREATESTRUCTW;
pub const LPCREATESTRUCTW = [*c]struct_tagCREATESTRUCTW;
pub const CREATESTRUCT = CREATESTRUCTA;
pub const LPCREATESTRUCT = LPCREATESTRUCTA;
pub const struct_tagWINDOWPLACEMENT = extern struct {
    length: UINT,
    flags: UINT,
    showCmd: UINT,
    ptMinPosition: POINT,
    ptMaxPosition: POINT,
    rcNormalPosition: RECT,
};
pub const WINDOWPLACEMENT = struct_tagWINDOWPLACEMENT;
pub const PWINDOWPLACEMENT = [*c]WINDOWPLACEMENT;
pub const LPWINDOWPLACEMENT = [*c]WINDOWPLACEMENT;
pub const struct_tagNMHDR = extern struct {
    hwndFrom: HWND,
    idFrom: UINT_PTR,
    code: UINT,
};
pub const NMHDR = struct_tagNMHDR;
pub const LPNMHDR = [*c]NMHDR;
pub const struct_tagSTYLESTRUCT = extern struct {
    styleOld: DWORD,
    styleNew: DWORD,
};
pub const STYLESTRUCT = struct_tagSTYLESTRUCT;
pub const LPSTYLESTRUCT = [*c]struct_tagSTYLESTRUCT;
pub const struct_tagMEASUREITEMSTRUCT = extern struct {
    CtlType: UINT,
    CtlID: UINT,
    itemID: UINT,
    itemWidth: UINT,
    itemHeight: UINT,
    itemData: ULONG_PTR,
};
pub const MEASUREITEMSTRUCT = struct_tagMEASUREITEMSTRUCT;
pub const PMEASUREITEMSTRUCT = [*c]struct_tagMEASUREITEMSTRUCT;
pub const LPMEASUREITEMSTRUCT = [*c]struct_tagMEASUREITEMSTRUCT;
pub const struct_tagDRAWITEMSTRUCT = extern struct {
    CtlType: UINT,
    CtlID: UINT,
    itemID: UINT,
    itemAction: UINT,
    itemState: UINT,
    hwndItem: HWND,
    hDC: HDC,
    rcItem: RECT,
    itemData: ULONG_PTR,
};
pub const DRAWITEMSTRUCT = struct_tagDRAWITEMSTRUCT;
pub const PDRAWITEMSTRUCT = [*c]struct_tagDRAWITEMSTRUCT;
pub const LPDRAWITEMSTRUCT = [*c]struct_tagDRAWITEMSTRUCT;
pub const struct_tagDELETEITEMSTRUCT = extern struct {
    CtlType: UINT,
    CtlID: UINT,
    itemID: UINT,
    hwndItem: HWND,
    itemData: ULONG_PTR,
};
pub const DELETEITEMSTRUCT = struct_tagDELETEITEMSTRUCT;
pub const PDELETEITEMSTRUCT = [*c]struct_tagDELETEITEMSTRUCT;
pub const LPDELETEITEMSTRUCT = [*c]struct_tagDELETEITEMSTRUCT;
pub const struct_tagCOMPAREITEMSTRUCT = extern struct {
    CtlType: UINT,
    CtlID: UINT,
    hwndItem: HWND,
    itemID1: UINT,
    itemData1: ULONG_PTR,
    itemID2: UINT,
    itemData2: ULONG_PTR,
    dwLocaleId: DWORD,
};
pub const COMPAREITEMSTRUCT = struct_tagCOMPAREITEMSTRUCT;
pub const PCOMPAREITEMSTRUCT = [*c]struct_tagCOMPAREITEMSTRUCT;
pub const LPCOMPAREITEMSTRUCT = [*c]struct_tagCOMPAREITEMSTRUCT;
pub extern "user32" fn GetMessageA(lpMsg: LPMSG, hWnd: HWND, wMsgFilterMin: UINT, wMsgFilterMax: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetMessageW(lpMsg: LPMSG, hWnd: HWND, wMsgFilterMin: UINT, wMsgFilterMax: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn TranslateMessage(lpMsg: [*c]const MSG) callconv(.Stdcall) BOOL;
pub extern "user32" fn DispatchMessageA(lpMsg: [*c]const MSG) callconv(.Stdcall) LRESULT;
pub extern "user32" fn DispatchMessageW(lpMsg: [*c]const MSG) callconv(.Stdcall) LRESULT;
pub extern "user32" fn SetMessageQueue(cMessagesMax: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn PeekMessageA(lpMsg: LPMSG, hWnd: HWND, wMsgFilterMin: UINT, wMsgFilterMax: UINT, wRemoveMsg: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn PeekMessageW(lpMsg: LPMSG, hWnd: HWND, wMsgFilterMin: UINT, wMsgFilterMax: UINT, wRemoveMsg: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn RegisterHotKey(hWnd: HWND, id: c_int, fsModifiers: UINT, vk: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn UnregisterHotKey(hWnd: HWND, id: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn ExitWindowsEx(uFlags: UINT, dwReason: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn SwapMouseButton(fSwap: BOOL) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetMessagePos() callconv(.Stdcall) DWORD;
pub extern "user32" fn GetMessageTime() callconv(.Stdcall) LONG;
pub extern "user32" fn GetMessageExtraInfo() callconv(.Stdcall) LPARAM;
pub extern "user32" fn GetUnpredictedMessagePos() callconv(.Stdcall) DWORD;
pub extern "user32" fn IsWow64Message() callconv(.Stdcall) BOOL;
pub extern "user32" fn SetMessageExtraInfo(lParam: LPARAM) callconv(.Stdcall) LPARAM;
pub extern "user32" fn SendMessageA(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "user32" fn SendMessageW(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "user32" fn SendMessageTimeoutA(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM, fuFlags: UINT, uTimeout: UINT, lpdwResult: PDWORD_PTR) callconv(.Stdcall) LRESULT;
pub extern "user32" fn SendMessageTimeoutW(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM, fuFlags: UINT, uTimeout: UINT, lpdwResult: PDWORD_PTR) callconv(.Stdcall) LRESULT;
pub extern "user32" fn SendNotifyMessageA(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub extern "user32" fn SendNotifyMessageW(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub extern "user32" fn SendMessageCallbackA(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM, lpResultCallBack: SENDASYNCPROC, dwData: ULONG_PTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn SendMessageCallbackW(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM, lpResultCallBack: SENDASYNCPROC, dwData: ULONG_PTR) callconv(.Stdcall) BOOL;
pub const BSMINFO = extern struct {
    cbSize: UINT,
    hdesk: HDESK,
    hwnd: HWND,
    luid: LUID,
};
pub const PBSMINFO = [*c]extern struct {
    cbSize: UINT,
    hdesk: HDESK,
    hwnd: HWND,
    luid: LUID,
};
pub extern "user32" fn BroadcastSystemMessageExA(flags: DWORD, lpInfo: LPDWORD, Msg: UINT, wParam: WPARAM, lParam: LPARAM, pbsmInfo: PBSMINFO) callconv(.Stdcall) c_long;
pub extern "user32" fn BroadcastSystemMessageExW(flags: DWORD, lpInfo: LPDWORD, Msg: UINT, wParam: WPARAM, lParam: LPARAM, pbsmInfo: PBSMINFO) callconv(.Stdcall) c_long;
pub extern "user32" fn BroadcastSystemMessageA(flags: DWORD, lpInfo: LPDWORD, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) c_long;
pub extern "user32" fn BroadcastSystemMessageW(flags: DWORD, lpInfo: LPDWORD, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) c_long;
pub const HDEVNOTIFY = PVOID;
pub const PHDEVNOTIFY = [*c]HDEVNOTIFY;
pub extern "user32" fn RegisterDeviceNotificationA(hRecipient: HANDLE, NotificationFilter: LPVOID, Flags: DWORD) callconv(.Stdcall) HDEVNOTIFY;
pub extern "user32" fn RegisterDeviceNotificationW(hRecipient: HANDLE, NotificationFilter: LPVOID, Flags: DWORD) callconv(.Stdcall) HDEVNOTIFY;
pub extern "user32" fn UnregisterDeviceNotification(Handle: HDEVNOTIFY) callconv(.Stdcall) BOOL;
pub const HPOWERNOTIFY = PVOID;
pub const PHPOWERNOTIFY = [*c]HPOWERNOTIFY;
pub extern "user32" fn RegisterPowerSettingNotification(hRecipient: HANDLE, PowerSettingGuid: LPCGUID, Flags: DWORD) callconv(.Stdcall) HPOWERNOTIFY;
pub extern "user32" fn UnregisterPowerSettingNotification(Handle: HPOWERNOTIFY) callconv(.Stdcall) BOOL;
pub extern "user32" fn RegisterSuspendResumeNotification(hRecipient: HANDLE, Flags: DWORD) callconv(.Stdcall) HPOWERNOTIFY;
pub extern "user32" fn UnregisterSuspendResumeNotification(Handle: HPOWERNOTIFY) callconv(.Stdcall) BOOL;
pub extern "user32" fn PostMessageA(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub extern "user32" fn PostMessageW(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub extern "user32" fn PostThreadMessageA(idThread: DWORD, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub extern "user32" fn PostThreadMessageW(idThread: DWORD, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub extern "user32" fn AttachThreadInput(idAttach: DWORD, idAttachTo: DWORD, fAttach: BOOL) callconv(.Stdcall) BOOL;
pub extern "user32" fn ReplyMessage(lResult: LRESULT) callconv(.Stdcall) BOOL;
pub extern "user32" fn WaitMessage() callconv(.Stdcall) BOOL;
pub extern "user32" fn WaitForInputIdle(hProcess: HANDLE, dwMilliseconds: DWORD) callconv(.Stdcall) DWORD;
pub extern "user32" fn DefWindowProcA(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "user32" fn DefWindowProcW(hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "user32" fn PostQuitMessage(nExitCode: c_int) callconv(.Stdcall) void;
pub extern "user32" fn CallWindowProcA(lpPrevWndFunc: WNDPROC, hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "user32" fn CallWindowProcW(lpPrevWndFunc: WNDPROC, hWnd: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "user32" fn InSendMessage() callconv(.Stdcall) BOOL;
pub extern "user32" fn InSendMessageEx(lpReserved: LPVOID) callconv(.Stdcall) DWORD;
pub extern "user32" fn GetDoubleClickTime() callconv(.Stdcall) UINT;
pub extern "user32" fn SetDoubleClickTime(arg0: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn RegisterClassA(lpWndClass: [*c]const WNDCLASSA) callconv(.Stdcall) ATOM;
pub extern "user32" fn RegisterClassW(lpWndClass: [*c]const WNDCLASSW) callconv(.Stdcall) ATOM;
pub extern "user32" fn UnregisterClassA(lpClassName: LPCSTR, hInstance: HINSTANCE) callconv(.Stdcall) BOOL;
pub extern "user32" fn UnregisterClassW(lpClassName: LPCWSTR, hInstance: HINSTANCE) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetClassInfoA(hInstance: HINSTANCE, lpClassName: LPCSTR, lpWndClass: LPWNDCLASSA) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetClassInfoW(hInstance: HINSTANCE, lpClassName: LPCWSTR, lpWndClass: LPWNDCLASSW) callconv(.Stdcall) BOOL;
pub extern "user32" fn RegisterClassExA(arg0: [*c]const WNDCLASSEXA) callconv(.Stdcall) ATOM;
pub extern "user32" fn RegisterClassExW(arg0: [*c]const WNDCLASSEXW) callconv(.Stdcall) ATOM;
pub extern "user32" fn GetClassInfoExA(hInstance: HINSTANCE, lpszClass: LPCSTR, lpwcx: LPWNDCLASSEXA) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetClassInfoExW(hInstance: HINSTANCE, lpszClass: LPCWSTR, lpwcx: LPWNDCLASSEXW) callconv(.Stdcall) BOOL;
pub const PREGISTERCLASSNAMEW = ?fn (LPCWSTR) callconv(.C) BOOLEAN;
pub extern "user32" fn CreateWindowExA(dwExStyle: DWORD, lpClassName: LPCSTR, lpWindowName: LPCSTR, dwStyle: DWORD, X: c_int, Y: c_int, nWidth: c_int, nHeight: c_int, hWndParent: HWND, hMenu: HMENU, hInstance: HINSTANCE, lpParam: LPVOID) callconv(.Stdcall) HWND;
pub extern "user32" fn CreateWindowExW(dwExStyle: DWORD, lpClassName: LPCWSTR, lpWindowName: LPCWSTR, dwStyle: DWORD, X: c_int, Y: c_int, nWidth: c_int, nHeight: c_int, hWndParent: HWND, hMenu: HMENU, hInstance: HINSTANCE, lpParam: LPVOID) callconv(.Stdcall) HWND;
pub extern "user32" fn IsWindow(hWnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsMenu(hMenu: HMENU) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsChild(hWndParent: HWND, hWnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn DestroyWindow(hWnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn ShowWindow(hWnd: HWND, nCmdShow: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn AnimateWindow(hWnd: HWND, dwTime: DWORD, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn UpdateLayeredWindow(hWnd: HWND, hdcDst: HDC, pptDst: [*c]POINT, psize: [*c]SIZE, hdcSrc: HDC, pptSrc: [*c]POINT, crKey: COLORREF, pblend: [*c]BLENDFUNCTION, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub const struct_tagUPDATELAYEREDWINDOWINFO = extern struct {
    cbSize: DWORD,
    hdcDst: HDC,
    pptDst: [*c]const POINT,
    psize: [*c]const SIZE,
    hdcSrc: HDC,
    pptSrc: [*c]const POINT,
    crKey: COLORREF,
    pblend: [*c]const BLENDFUNCTION,
    dwFlags: DWORD,
    prcDirty: [*c]const RECT,
};
pub const UPDATELAYEREDWINDOWINFO = struct_tagUPDATELAYEREDWINDOWINFO;
pub const PUPDATELAYEREDWINDOWINFO = [*c]struct_tagUPDATELAYEREDWINDOWINFO;
pub extern "user32" fn UpdateLayeredWindowIndirect(hWnd: HWND, pULWInfo: [*c]const UPDATELAYEREDWINDOWINFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetLayeredWindowAttributes(hwnd: HWND, pcrKey: [*c]COLORREF, pbAlpha: [*c]BYTE, pdwFlags: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn PrintWindow(hwnd: HWND, hdcBlt: HDC, nFlags: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetLayeredWindowAttributes(hwnd: HWND, crKey: COLORREF, bAlpha: BYTE, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn ShowWindowAsync(hWnd: HWND, nCmdShow: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn FlashWindow(hWnd: HWND, bInvert: BOOL) callconv(.Stdcall) BOOL;
pub const FLASHWINFO = extern struct {
    cbSize: UINT,
    hwnd: HWND,
    dwFlags: DWORD,
    uCount: UINT,
    dwTimeout: DWORD,
};
pub const PFLASHWINFO = [*c]extern struct {
    cbSize: UINT,
    hwnd: HWND,
    dwFlags: DWORD,
    uCount: UINT,
    dwTimeout: DWORD,
};
pub extern "user32" fn FlashWindowEx(pfwi: PFLASHWINFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn ShowOwnedPopups(hWnd: HWND, fShow: BOOL) callconv(.Stdcall) BOOL;
pub extern "user32" fn OpenIcon(hWnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn CloseWindow(hWnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn MoveWindow(hWnd: HWND, X: c_int, Y: c_int, nWidth: c_int, nHeight: c_int, bRepaint: BOOL) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetWindowPos(hWnd: HWND, hWndInsertAfter: HWND, X: c_int, Y: c_int, cx: c_int, cy: c_int, uFlags: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetWindowPlacement(hWnd: HWND, lpwndpl: [*c]WINDOWPLACEMENT) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetWindowPlacement(hWnd: HWND, lpwndpl: [*c]const WINDOWPLACEMENT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetWindowDisplayAffinity(hWnd: HWND, pdwAffinity: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetWindowDisplayAffinity(hWnd: HWND, dwAffinity: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn BeginDeferWindowPos(nNumWindows: c_int) callconv(.Stdcall) HDWP;
pub extern "user32" fn DeferWindowPos(hWinPosInfo: HDWP, hWnd: HWND, hWndInsertAfter: HWND, x: c_int, y: c_int, cx: c_int, cy: c_int, uFlags: UINT) callconv(.Stdcall) HDWP;
pub extern "user32" fn EndDeferWindowPos(hWinPosInfo: HDWP) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsWindowVisible(hWnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsIconic(hWnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn AnyPopup() callconv(.Stdcall) BOOL;
pub extern "user32" fn BringWindowToTop(hWnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsZoomed(hWnd: HWND) callconv(.Stdcall) BOOL;
pub const DLGTEMPLATE = extern struct {
    style: DWORD,
    dwExtendedStyle: DWORD,
    cdit: WORD,
    x: c_short,
    y: c_short,
    cx: c_short,
    cy: c_short,
};
pub const LPDLGTEMPLATEA = [*c]DLGTEMPLATE;
pub const LPDLGTEMPLATEW = [*c]DLGTEMPLATE;
pub const LPDLGTEMPLATE = LPDLGTEMPLATEA;
pub const LPCDLGTEMPLATEA = [*c]const DLGTEMPLATE;
pub const LPCDLGTEMPLATEW = [*c]const DLGTEMPLATE;
pub const LPCDLGTEMPLATE = LPCDLGTEMPLATEA;
pub const DLGITEMTEMPLATE = extern struct {
    style: DWORD,
    dwExtendedStyle: DWORD,
    x: c_short,
    y: c_short,
    cx: c_short,
    cy: c_short,
    id: WORD,
};
pub const PDLGITEMTEMPLATEA = [*c]DLGITEMTEMPLATE;
pub const PDLGITEMTEMPLATEW = [*c]DLGITEMTEMPLATE;
pub const PDLGITEMTEMPLATE = PDLGITEMTEMPLATEA;
pub const LPDLGITEMTEMPLATEA = [*c]DLGITEMTEMPLATE;
pub const LPDLGITEMTEMPLATEW = [*c]DLGITEMTEMPLATE;
pub const LPDLGITEMTEMPLATE = LPDLGITEMTEMPLATEA;
pub extern "user32" fn CreateDialogParamA(hInstance: HINSTANCE, lpTemplateName: LPCSTR, hWndParent: HWND, lpDialogFunc: DLGPROC, dwInitParam: LPARAM) callconv(.Stdcall) HWND;
pub extern "user32" fn CreateDialogParamW(hInstance: HINSTANCE, lpTemplateName: LPCWSTR, hWndParent: HWND, lpDialogFunc: DLGPROC, dwInitParam: LPARAM) callconv(.Stdcall) HWND;
pub extern "user32" fn CreateDialogIndirectParamA(hInstance: HINSTANCE, lpTemplate: LPCDLGTEMPLATEA, hWndParent: HWND, lpDialogFunc: DLGPROC, dwInitParam: LPARAM) callconv(.Stdcall) HWND;
pub extern "user32" fn CreateDialogIndirectParamW(hInstance: HINSTANCE, lpTemplate: LPCDLGTEMPLATEW, hWndParent: HWND, lpDialogFunc: DLGPROC, dwInitParam: LPARAM) callconv(.Stdcall) HWND;
pub extern "user32" fn DialogBoxParamA(hInstance: HINSTANCE, lpTemplateName: LPCSTR, hWndParent: HWND, lpDialogFunc: DLGPROC, dwInitParam: LPARAM) callconv(.Stdcall) INT_PTR;
pub extern "user32" fn DialogBoxParamW(hInstance: HINSTANCE, lpTemplateName: LPCWSTR, hWndParent: HWND, lpDialogFunc: DLGPROC, dwInitParam: LPARAM) callconv(.Stdcall) INT_PTR;
pub extern "user32" fn DialogBoxIndirectParamA(hInstance: HINSTANCE, hDialogTemplate: LPCDLGTEMPLATEA, hWndParent: HWND, lpDialogFunc: DLGPROC, dwInitParam: LPARAM) callconv(.Stdcall) INT_PTR;
pub extern "user32" fn DialogBoxIndirectParamW(hInstance: HINSTANCE, hDialogTemplate: LPCDLGTEMPLATEW, hWndParent: HWND, lpDialogFunc: DLGPROC, dwInitParam: LPARAM) callconv(.Stdcall) INT_PTR;
pub extern "user32" fn EndDialog(hDlg: HWND, nResult: INT_PTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetDlgItem(hDlg: HWND, nIDDlgItem: c_int) callconv(.Stdcall) HWND;
pub extern "user32" fn SetDlgItemInt(hDlg: HWND, nIDDlgItem: c_int, uValue: UINT, bSigned: BOOL) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetDlgItemInt(hDlg: HWND, nIDDlgItem: c_int, lpTranslated: [*c]BOOL, bSigned: BOOL) callconv(.Stdcall) UINT;
pub extern "user32" fn SetDlgItemTextA(hDlg: HWND, nIDDlgItem: c_int, lpString: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetDlgItemTextW(hDlg: HWND, nIDDlgItem: c_int, lpString: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetDlgItemTextA(hDlg: HWND, nIDDlgItem: c_int, lpString: LPSTR, cchMax: c_int) callconv(.Stdcall) UINT;
pub extern "user32" fn GetDlgItemTextW(hDlg: HWND, nIDDlgItem: c_int, lpString: LPWSTR, cchMax: c_int) callconv(.Stdcall) UINT;
pub extern "user32" fn CheckDlgButton(hDlg: HWND, nIDButton: c_int, uCheck: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn CheckRadioButton(hDlg: HWND, nIDFirstButton: c_int, nIDLastButton: c_int, nIDCheckButton: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsDlgButtonChecked(hDlg: HWND, nIDButton: c_int) callconv(.Stdcall) UINT;
pub extern "user32" fn SendDlgItemMessageA(hDlg: HWND, nIDDlgItem: c_int, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "user32" fn SendDlgItemMessageW(hDlg: HWND, nIDDlgItem: c_int, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "user32" fn GetNextDlgGroupItem(hDlg: HWND, hCtl: HWND, bPrevious: BOOL) callconv(.Stdcall) HWND;
pub extern "user32" fn GetNextDlgTabItem(hDlg: HWND, hCtl: HWND, bPrevious: BOOL) callconv(.Stdcall) HWND;
pub extern "user32" fn GetDlgCtrlID(hWnd: HWND) callconv(.Stdcall) c_int;
pub extern "user32" fn GetDialogBaseUnits() callconv(.Stdcall) c_long;
pub extern "user32" fn DefDlgProcA(hDlg: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "user32" fn DefDlgProcW(hDlg: HWND, Msg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) LRESULT;
pub const DCDC_DEFAULT = enum_DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DEFAULT;
pub const DCDC_DISABLE_FONT_UPDATE = enum_DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DISABLE_FONT_UPDATE;
pub const DCDC_DISABLE_RELAYOUT = enum_DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DISABLE_RELAYOUT;
pub const enum_DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS = extern enum {
    DCDC_DEFAULT = 0,
    DCDC_DISABLE_FONT_UPDATE = 1,
    DCDC_DISABLE_RELAYOUT = 2,
};
pub const DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS = enum_DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS;
pub extern "user32" fn SetDialogControlDpiChangeBehavior(hWnd: HWND, mask: DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS, values: DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetDialogControlDpiChangeBehavior(hWnd: HWND) callconv(.Stdcall) DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS;
pub const DDC_DEFAULT = enum_DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DEFAULT;
pub const DDC_DISABLE_ALL = enum_DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_ALL;
pub const DDC_DISABLE_RESIZE = enum_DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_RESIZE;
pub const DDC_DISABLE_CONTROL_RELAYOUT = enum_DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_CONTROL_RELAYOUT;
pub const enum_DIALOG_DPI_CHANGE_BEHAVIORS = extern enum {
    DDC_DEFAULT = 0,
    DDC_DISABLE_ALL = 1,
    DDC_DISABLE_RESIZE = 2,
    DDC_DISABLE_CONTROL_RELAYOUT = 4,
};
pub const DIALOG_DPI_CHANGE_BEHAVIORS = enum_DIALOG_DPI_CHANGE_BEHAVIORS;
pub extern "user32" fn SetDialogDpiChangeBehavior(hDlg: HWND, mask: DIALOG_DPI_CHANGE_BEHAVIORS, values: DIALOG_DPI_CHANGE_BEHAVIORS) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetDialogDpiChangeBehavior(hDlg: HWND) callconv(.Stdcall) DIALOG_DPI_CHANGE_BEHAVIORS;
pub extern "user32" fn CallMsgFilterA(lpMsg: LPMSG, nCode: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn CallMsgFilterW(lpMsg: LPMSG, nCode: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn OpenClipboard(hWndNewOwner: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn CloseClipboard() callconv(.Stdcall) BOOL;
pub extern "user32" fn GetClipboardSequenceNumber() callconv(.Stdcall) DWORD;
pub extern "user32" fn GetClipboardOwner() callconv(.Stdcall) HWND;
pub extern "user32" fn SetClipboardViewer(hWndNewViewer: HWND) callconv(.Stdcall) HWND;
pub extern "user32" fn GetClipboardViewer() callconv(.Stdcall) HWND;
pub extern "user32" fn ChangeClipboardChain(hWndRemove: HWND, hWndNewNext: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetClipboardData(uFormat: UINT, hMem: HANDLE) callconv(.Stdcall) HANDLE;
pub extern "user32" fn GetClipboardData(uFormat: UINT) callconv(.Stdcall) HANDLE;
pub extern "user32" fn RegisterClipboardFormatA(lpszFormat: LPCSTR) callconv(.Stdcall) UINT;
pub extern "user32" fn RegisterClipboardFormatW(lpszFormat: LPCWSTR) callconv(.Stdcall) UINT;
pub extern "user32" fn CountClipboardFormats() callconv(.Stdcall) c_int;
pub extern "user32" fn EnumClipboardFormats(format: UINT) callconv(.Stdcall) UINT;
pub extern "user32" fn GetClipboardFormatNameA(format: UINT, lpszFormatName: LPSTR, cchMaxCount: c_int) callconv(.Stdcall) c_int;
pub extern "user32" fn GetClipboardFormatNameW(format: UINT, lpszFormatName: LPWSTR, cchMaxCount: c_int) callconv(.Stdcall) c_int;
pub extern "user32" fn EmptyClipboard() callconv(.Stdcall) BOOL;
pub extern "user32" fn IsClipboardFormatAvailable(format: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPriorityClipboardFormat(paFormatPriorityList: [*c]UINT, cFormats: c_int) callconv(.Stdcall) c_int;
pub extern "user32" fn GetOpenClipboardWindow() callconv(.Stdcall) HWND;
pub extern "user32" fn AddClipboardFormatListener(hwnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn RemoveClipboardFormatListener(hwnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetUpdatedClipboardFormats(lpuiFormats: PUINT, cFormats: UINT, pcFormatsOut: PUINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn CharToOemA(pSrc: LPCSTR, pDst: LPSTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn CharToOemW(pSrc: LPCWSTR, pDst: LPSTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn OemToCharA(pSrc: LPCSTR, pDst: LPSTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn OemToCharW(pSrc: LPCSTR, pDst: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn CharToOemBuffA(lpszSrc: LPCSTR, lpszDst: LPSTR, cchDstLength: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn CharToOemBuffW(lpszSrc: LPCWSTR, lpszDst: LPSTR, cchDstLength: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn OemToCharBuffA(lpszSrc: LPCSTR, lpszDst: LPSTR, cchDstLength: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn OemToCharBuffW(lpszSrc: LPCSTR, lpszDst: LPWSTR, cchDstLength: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn CharUpperA(lpsz: LPSTR) callconv(.Stdcall) LPSTR;
pub extern "user32" fn CharUpperW(lpsz: LPWSTR) callconv(.Stdcall) LPWSTR;
pub extern "user32" fn CharUpperBuffA(lpsz: LPSTR, cchLength: DWORD) callconv(.Stdcall) DWORD;
pub extern "user32" fn CharUpperBuffW(lpsz: LPWSTR, cchLength: DWORD) callconv(.Stdcall) DWORD;
pub extern "user32" fn CharLowerA(lpsz: LPSTR) callconv(.Stdcall) LPSTR;
pub extern "user32" fn CharLowerW(lpsz: LPWSTR) callconv(.Stdcall) LPWSTR;
pub extern "user32" fn CharLowerBuffA(lpsz: LPSTR, cchLength: DWORD) callconv(.Stdcall) DWORD;
pub extern "user32" fn CharLowerBuffW(lpsz: LPWSTR, cchLength: DWORD) callconv(.Stdcall) DWORD;
pub extern "user32" fn CharNextA(lpsz: LPCSTR) callconv(.Stdcall) LPSTR;
pub extern "user32" fn CharNextW(lpsz: LPCWSTR) callconv(.Stdcall) LPWSTR;
pub extern "user32" fn CharPrevA(lpszStart: LPCSTR, lpszCurrent: LPCSTR) callconv(.Stdcall) LPSTR;
pub extern "user32" fn CharPrevW(lpszStart: LPCWSTR, lpszCurrent: LPCWSTR) callconv(.Stdcall) LPWSTR;
pub extern "user32" fn CharNextExA(CodePage: WORD, lpCurrentChar: LPCSTR, dwFlags: DWORD) callconv(.Stdcall) LPSTR;
pub extern "user32" fn CharPrevExA(CodePage: WORD, lpStart: LPCSTR, lpCurrentChar: LPCSTR, dwFlags: DWORD) callconv(.Stdcall) LPSTR;
pub extern "user32" fn IsCharAlphaA(ch: CHAR) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsCharAlphaW(ch: WCHAR) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsCharAlphaNumericA(ch: CHAR) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsCharAlphaNumericW(ch: WCHAR) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsCharUpperA(ch: CHAR) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsCharUpperW(ch: WCHAR) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsCharLowerA(ch: CHAR) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsCharLowerW(ch: WCHAR) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetFocus(hWnd: HWND) callconv(.Stdcall) HWND;
pub extern "user32" fn GetActiveWindow() callconv(.Stdcall) HWND;
pub extern "user32" fn GetFocus() callconv(.Stdcall) HWND;
pub extern "user32" fn GetKBCodePage() callconv(.Stdcall) UINT;
pub extern "user32" fn GetKeyState(nVirtKey: c_int) callconv(.Stdcall) SHORT;
pub extern "user32" fn GetAsyncKeyState(vKey: c_int) callconv(.Stdcall) SHORT;
pub extern "user32" fn GetKeyboardState(lpKeyState: PBYTE) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetKeyboardState(lpKeyState: LPBYTE) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetKeyNameTextA(lParam: LONG, lpString: LPSTR, cchSize: c_int) callconv(.Stdcall) c_int;
pub extern "user32" fn GetKeyNameTextW(lParam: LONG, lpString: LPWSTR, cchSize: c_int) callconv(.Stdcall) c_int;
pub extern "user32" fn GetKeyboardType(nTypeFlag: c_int) callconv(.Stdcall) c_int;
pub extern "user32" fn ToAscii(uVirtKey: UINT, uScanCode: UINT, lpKeyState: [*c]const BYTE, lpChar: LPWORD, uFlags: UINT) callconv(.Stdcall) c_int;
pub extern "user32" fn ToAsciiEx(uVirtKey: UINT, uScanCode: UINT, lpKeyState: [*c]const BYTE, lpChar: LPWORD, uFlags: UINT, dwhkl: HKL) callconv(.Stdcall) c_int;
pub extern "user32" fn ToUnicode(wVirtKey: UINT, wScanCode: UINT, lpKeyState: [*c]const BYTE, pwszBuff: LPWSTR, cchBuff: c_int, wFlags: UINT) callconv(.Stdcall) c_int;
pub extern "user32" fn OemKeyScan(wOemChar: WORD) callconv(.Stdcall) DWORD;
pub extern "user32" fn VkKeyScanA(ch: CHAR) callconv(.Stdcall) SHORT;
pub extern "user32" fn VkKeyScanW(ch: WCHAR) callconv(.Stdcall) SHORT;
pub extern "user32" fn VkKeyScanExA(ch: CHAR, dwhkl: HKL) callconv(.Stdcall) SHORT;
pub extern "user32" fn VkKeyScanExW(ch: WCHAR, dwhkl: HKL) callconv(.Stdcall) SHORT;
pub extern "user32" fn keybd_event(bVk: BYTE, bScan: BYTE, dwFlags: DWORD, dwExtraInfo: ULONG_PTR) callconv(.Stdcall) void;
pub extern "user32" fn mouse_event(dwFlags: DWORD, dx: DWORD, dy: DWORD, dwData: DWORD, dwExtraInfo: ULONG_PTR) callconv(.Stdcall) void;
pub const struct_tagMOUSEINPUT = extern struct {
    dx: LONG,
    dy: LONG,
    mouseData: DWORD,
    dwFlags: DWORD,
    time: DWORD,
    dwExtraInfo: ULONG_PTR,
};
pub const MOUSEINPUT = struct_tagMOUSEINPUT;
pub const PMOUSEINPUT = [*c]struct_tagMOUSEINPUT;
pub const LPMOUSEINPUT = [*c]struct_tagMOUSEINPUT;
pub const struct_tagKEYBDINPUT = extern struct {
    wVk: WORD,
    wScan: WORD,
    dwFlags: DWORD,
    time: DWORD,
    dwExtraInfo: ULONG_PTR,
};
pub const KEYBDINPUT = struct_tagKEYBDINPUT;
pub const PKEYBDINPUT = [*c]struct_tagKEYBDINPUT;
pub const LPKEYBDINPUT = [*c]struct_tagKEYBDINPUT;
pub const struct_tagHARDWAREINPUT = extern struct {
    uMsg: DWORD,
    wParamL: WORD,
    wParamH: WORD,
};
pub const HARDWAREINPUT = struct_tagHARDWAREINPUT;
pub const PHARDWAREINPUT = [*c]struct_tagHARDWAREINPUT;
pub const LPHARDWAREINPUT = [*c]struct_tagHARDWAREINPUT;
pub const struct_tagINPUT = extern struct {
    type: DWORD,
    @"": extern union {
        mi: MOUSEINPUT,
        ki: KEYBDINPUT,
        hi: HARDWAREINPUT,
    },
};
pub const INPUT = struct_tagINPUT;
pub const PINPUT = [*c]struct_tagINPUT;
pub const LPINPUT = [*c]struct_tagINPUT;
pub extern "user32" fn SendInput(cInputs: UINT, pInputs: LPINPUT, cbSize: c_int) callconv(.Stdcall) UINT;
pub const struct_HTOUCHINPUT__ = extern struct {
    unused: c_int,
};
pub const HTOUCHINPUT = [*c]struct_HTOUCHINPUT__;
pub const struct_tagTOUCHINPUT = extern struct {
    x: LONG,
    y: LONG,
    hSource: HANDLE,
    dwID: DWORD,
    dwFlags: DWORD,
    dwMask: DWORD,
    dwTime: DWORD,
    dwExtraInfo: ULONG_PTR,
    cxContact: DWORD,
    cyContact: DWORD,
};
pub const TOUCHINPUT = struct_tagTOUCHINPUT;
pub const PTOUCHINPUT = [*c]struct_tagTOUCHINPUT;
pub const PCTOUCHINPUT = [*c]const TOUCHINPUT;
pub extern "user32" fn GetTouchInputInfo(hTouchInput: HTOUCHINPUT, cInputs: UINT, pInputs: PTOUCHINPUT, cbSize: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn CloseTouchInputHandle(hTouchInput: HTOUCHINPUT) callconv(.Stdcall) BOOL;
pub extern "user32" fn RegisterTouchWindow(hwnd: HWND, ulFlags: ULONG) callconv(.Stdcall) BOOL;
pub extern "user32" fn UnregisterTouchWindow(hwnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsTouchWindow(hwnd: HWND, pulFlags: PULONG) callconv(.Stdcall) BOOL;
pub const PT_POINTER = enum_tagPOINTER_INPUT_TYPE.PT_POINTER;
pub const PT_TOUCH = enum_tagPOINTER_INPUT_TYPE.PT_TOUCH;
pub const PT_PEN = enum_tagPOINTER_INPUT_TYPE.PT_PEN;
pub const PT_MOUSE = enum_tagPOINTER_INPUT_TYPE.PT_MOUSE;
pub const PT_TOUCHPAD = enum_tagPOINTER_INPUT_TYPE.PT_TOUCHPAD;
pub const enum_tagPOINTER_INPUT_TYPE = extern enum {
    PT_POINTER = 1,
    PT_TOUCH = 2,
    PT_PEN = 3,
    PT_MOUSE = 4,
    PT_TOUCHPAD = 5,
};
pub const POINTER_INPUT_TYPE = DWORD;
pub const POINTER_FLAGS = UINT32;
pub const POINTER_CHANGE_NONE = enum_tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_NONE;
pub const POINTER_CHANGE_FIRSTBUTTON_DOWN = enum_tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIRSTBUTTON_DOWN;
pub const POINTER_CHANGE_FIRSTBUTTON_UP = enum_tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIRSTBUTTON_UP;
pub const POINTER_CHANGE_SECONDBUTTON_DOWN = enum_tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_SECONDBUTTON_DOWN;
pub const POINTER_CHANGE_SECONDBUTTON_UP = enum_tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_SECONDBUTTON_UP;
pub const POINTER_CHANGE_THIRDBUTTON_DOWN = enum_tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_THIRDBUTTON_DOWN;
pub const POINTER_CHANGE_THIRDBUTTON_UP = enum_tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_THIRDBUTTON_UP;
pub const POINTER_CHANGE_FOURTHBUTTON_DOWN = enum_tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FOURTHBUTTON_DOWN;
pub const POINTER_CHANGE_FOURTHBUTTON_UP = enum_tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FOURTHBUTTON_UP;
pub const POINTER_CHANGE_FIFTHBUTTON_DOWN = enum_tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIFTHBUTTON_DOWN;
pub const POINTER_CHANGE_FIFTHBUTTON_UP = enum_tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIFTHBUTTON_UP;
pub const enum_tagPOINTER_BUTTON_CHANGE_TYPE = extern enum {
    POINTER_CHANGE_NONE,
    POINTER_CHANGE_FIRSTBUTTON_DOWN,
    POINTER_CHANGE_FIRSTBUTTON_UP,
    POINTER_CHANGE_SECONDBUTTON_DOWN,
    POINTER_CHANGE_SECONDBUTTON_UP,
    POINTER_CHANGE_THIRDBUTTON_DOWN,
    POINTER_CHANGE_THIRDBUTTON_UP,
    POINTER_CHANGE_FOURTHBUTTON_DOWN,
    POINTER_CHANGE_FOURTHBUTTON_UP,
    POINTER_CHANGE_FIFTHBUTTON_DOWN,
    POINTER_CHANGE_FIFTHBUTTON_UP,
};
pub const POINTER_BUTTON_CHANGE_TYPE = enum_tagPOINTER_BUTTON_CHANGE_TYPE;
pub const struct_tagPOINTER_INFO = extern struct {
    pointerType: POINTER_INPUT_TYPE,
    pointerId: UINT32,
    frameId: UINT32,
    pointerFlags: POINTER_FLAGS,
    sourceDevice: HANDLE,
    hwndTarget: HWND,
    ptPixelLocation: POINT,
    ptHimetricLocation: POINT,
    ptPixelLocationRaw: POINT,
    ptHimetricLocationRaw: POINT,
    dwTime: DWORD,
    historyCount: UINT32,
    InputData: INT32,
    dwKeyStates: DWORD,
    PerformanceCount: UINT64,
    ButtonChangeType: POINTER_BUTTON_CHANGE_TYPE,
};
pub const POINTER_INFO = struct_tagPOINTER_INFO;
pub const TOUCH_FLAGS = UINT32;
pub const TOUCH_MASK = UINT32;
pub const struct_tagPOINTER_TOUCH_INFO = extern struct {
    pointerInfo: POINTER_INFO,
    touchFlags: TOUCH_FLAGS,
    touchMask: TOUCH_MASK,
    rcContact: RECT,
    rcContactRaw: RECT,
    orientation: UINT32,
    pressure: UINT32,
};
pub const POINTER_TOUCH_INFO = struct_tagPOINTER_TOUCH_INFO;
pub const PEN_FLAGS = UINT32;
pub const PEN_MASK = UINT32;
pub const struct_tagPOINTER_PEN_INFO = extern struct {
    pointerInfo: POINTER_INFO,
    penFlags: PEN_FLAGS,
    penMask: PEN_MASK,
    pressure: UINT32,
    rotation: UINT32,
    tiltX: INT32,
    tiltY: INT32,
};
pub const POINTER_PEN_INFO = struct_tagPOINTER_PEN_INFO;
pub const POINTER_FEEDBACK_DEFAULT = 1;
pub const POINTER_FEEDBACK_INDIRECT = 2;
pub const POINTER_FEEDBACK_NONE = 3;
pub const POINTER_FEEDBACK_MODE = extern enum {
    POINTER_FEEDBACK_DEFAULT = 1,
    POINTER_FEEDBACK_INDIRECT = 2,
    POINTER_FEEDBACK_NONE = 3,
};
pub extern "user32" fn InitializeTouchInjection(maxCount: UINT32, dwMode: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn InjectTouchInput(count: UINT32, contacts: [*c]const POINTER_TOUCH_INFO) callconv(.Stdcall) BOOL;
pub const struct_tagUSAGE_PROPERTIES = extern struct {
    level: USHORT,
    page: USHORT,
    usage: USHORT,
    logicalMinimum: INT32,
    logicalMaximum: INT32,
    unit: USHORT,
    exponent: USHORT,
    count: BYTE,
    physicalMinimum: INT32,
    physicalMaximum: INT32,
};
pub const USAGE_PROPERTIES = struct_tagUSAGE_PROPERTIES;
pub const PUSAGE_PROPERTIES = [*c]struct_tagUSAGE_PROPERTIES;
pub const struct_tagPOINTER_TYPE_INFO = extern struct {
    type: POINTER_INPUT_TYPE,
    @"": extern union {
        touchInfo: POINTER_TOUCH_INFO,
        penInfo: POINTER_PEN_INFO,
    },
};
pub const POINTER_TYPE_INFO = struct_tagPOINTER_TYPE_INFO;
pub const PPOINTER_TYPE_INFO = [*c]struct_tagPOINTER_TYPE_INFO;
pub const struct_tagINPUT_INJECTION_VALUE = extern struct {
    page: USHORT,
    usage: USHORT,
    value: INT32,
    index: USHORT,
};
pub const INPUT_INJECTION_VALUE = struct_tagINPUT_INJECTION_VALUE;
pub const PINPUT_INJECTION_VALUE = [*c]struct_tagINPUT_INJECTION_VALUE;
pub extern "user32" fn GetPointerType(pointerId: UINT32, pointerType: [*c]POINTER_INPUT_TYPE) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPointerCursorId(pointerId: UINT32, cursorId: [*c]UINT32) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPointerInfo(pointerId: UINT32, pointerInfo: [*c]POINTER_INFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPointerInfoHistory(pointerId: UINT32, entriesCount: [*c]UINT32, pointerInfo: [*c]POINTER_INFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPointerFrameInfo(pointerId: UINT32, pointerCount: [*c]UINT32, pointerInfo: [*c]POINTER_INFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPointerFrameInfoHistory(pointerId: UINT32, entriesCount: [*c]UINT32, pointerCount: [*c]UINT32, pointerInfo: [*c]POINTER_INFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPointerTouchInfo(pointerId: UINT32, touchInfo: [*c]POINTER_TOUCH_INFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPointerTouchInfoHistory(pointerId: UINT32, entriesCount: [*c]UINT32, touchInfo: [*c]POINTER_TOUCH_INFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPointerFrameTouchInfo(pointerId: UINT32, pointerCount: [*c]UINT32, touchInfo: [*c]POINTER_TOUCH_INFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPointerFrameTouchInfoHistory(pointerId: UINT32, entriesCount: [*c]UINT32, pointerCount: [*c]UINT32, touchInfo: [*c]POINTER_TOUCH_INFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPointerPenInfo(pointerId: UINT32, penInfo: [*c]POINTER_PEN_INFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPointerPenInfoHistory(pointerId: UINT32, entriesCount: [*c]UINT32, penInfo: [*c]POINTER_PEN_INFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPointerFramePenInfo(pointerId: UINT32, pointerCount: [*c]UINT32, penInfo: [*c]POINTER_PEN_INFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPointerFramePenInfoHistory(pointerId: UINT32, entriesCount: [*c]UINT32, pointerCount: [*c]UINT32, penInfo: [*c]POINTER_PEN_INFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn SkipPointerFrameMessages(pointerId: UINT32) callconv(.Stdcall) BOOL;
pub extern "user32" fn RegisterPointerInputTarget(hwnd: HWND, pointerType: POINTER_INPUT_TYPE) callconv(.Stdcall) BOOL;
pub extern "user32" fn UnregisterPointerInputTarget(hwnd: HWND, pointerType: POINTER_INPUT_TYPE) callconv(.Stdcall) BOOL;
pub extern "user32" fn RegisterPointerInputTargetEx(hwnd: HWND, pointerType: POINTER_INPUT_TYPE, fObserve: BOOL) callconv(.Stdcall) BOOL;
pub extern "user32" fn UnregisterPointerInputTargetEx(hwnd: HWND, pointerType: POINTER_INPUT_TYPE) callconv(.Stdcall) BOOL;
pub const struct_HSYNTHETICPOINTERDEVICE__ = extern struct {
    unused: c_int,
};
pub const HSYNTHETICPOINTERDEVICE = [*c]struct_HSYNTHETICPOINTERDEVICE__;
pub extern "user32" fn CreateSyntheticPointerDevice(pointerType: POINTER_INPUT_TYPE, maxCount: ULONG, mode: POINTER_FEEDBACK_MODE) callconv(.Stdcall) HSYNTHETICPOINTERDEVICE;
pub extern "user32" fn InjectSyntheticPointerInput(device: HSYNTHETICPOINTERDEVICE, pointerInfo: [*c]const POINTER_TYPE_INFO, count: UINT32) callconv(.Stdcall) BOOL;
pub extern "user32" fn DestroySyntheticPointerDevice(device: HSYNTHETICPOINTERDEVICE) callconv(.Stdcall) void;
pub extern "user32" fn EnableMouseInPointer(fEnable: BOOL) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsMouseInPointerEnabled() callconv(.Stdcall) BOOL;
pub extern "user32" fn EnableMouseInPointerForThread() callconv(.Stdcall) BOOL;
pub extern "user32" fn RegisterTouchHitTestingWindow(hwnd: HWND, value: ULONG) callconv(.Stdcall) BOOL;
pub const struct_tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION = extern struct {
    score: UINT16,
    adjustedPoint: POINT,
};
pub const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION = struct_tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION;
pub const PTOUCH_HIT_TESTING_PROXIMITY_EVALUATION = [*c]struct_tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION;
pub const struct_tagTOUCH_HIT_TESTING_INPUT = extern struct {
    pointerId: UINT32,
    point: POINT,
    boundingBox: RECT,
    nonOccludedBoundingBox: RECT,
    orientation: UINT32,
};
pub const TOUCH_HIT_TESTING_INPUT = struct_tagTOUCH_HIT_TESTING_INPUT;
pub const PTOUCH_HIT_TESTING_INPUT = [*c]struct_tagTOUCH_HIT_TESTING_INPUT;
pub extern "user32" fn EvaluateProximityToRect(controlBoundingBox: [*c]const RECT, pHitTestingInput: [*c]const TOUCH_HIT_TESTING_INPUT, pProximityEval: [*c]TOUCH_HIT_TESTING_PROXIMITY_EVALUATION) callconv(.Stdcall) BOOL;
pub extern "user32" fn EvaluateProximityToPolygon(numVertices: UINT32, controlPolygon: [*c]const POINT, pHitTestingInput: [*c]const TOUCH_HIT_TESTING_INPUT, pProximityEval: [*c]TOUCH_HIT_TESTING_PROXIMITY_EVALUATION) callconv(.Stdcall) BOOL;
pub extern "user32" fn PackTouchHitTestingProximityEvaluation(pHitTestingInput: [*c]const TOUCH_HIT_TESTING_INPUT, pProximityEval: [*c]const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION) callconv(.Stdcall) LRESULT;
pub const FEEDBACK_TOUCH_CONTACTVISUALIZATION = enum_tagFEEDBACK_TYPE.FEEDBACK_TOUCH_CONTACTVISUALIZATION;
pub const FEEDBACK_PEN_BARRELVISUALIZATION = enum_tagFEEDBACK_TYPE.FEEDBACK_PEN_BARRELVISUALIZATION;
pub const FEEDBACK_PEN_TAP = enum_tagFEEDBACK_TYPE.FEEDBACK_PEN_TAP;
pub const FEEDBACK_PEN_DOUBLETAP = enum_tagFEEDBACK_TYPE.FEEDBACK_PEN_DOUBLETAP;
pub const FEEDBACK_PEN_PRESSANDHOLD = enum_tagFEEDBACK_TYPE.FEEDBACK_PEN_PRESSANDHOLD;
pub const FEEDBACK_PEN_RIGHTTAP = enum_tagFEEDBACK_TYPE.FEEDBACK_PEN_RIGHTTAP;
pub const FEEDBACK_TOUCH_TAP = enum_tagFEEDBACK_TYPE.FEEDBACK_TOUCH_TAP;
pub const FEEDBACK_TOUCH_DOUBLETAP = enum_tagFEEDBACK_TYPE.FEEDBACK_TOUCH_DOUBLETAP;
pub const FEEDBACK_TOUCH_PRESSANDHOLD = enum_tagFEEDBACK_TYPE.FEEDBACK_TOUCH_PRESSANDHOLD;
pub const FEEDBACK_TOUCH_RIGHTTAP = enum_tagFEEDBACK_TYPE.FEEDBACK_TOUCH_RIGHTTAP;
pub const FEEDBACK_GESTURE_PRESSANDTAP = enum_tagFEEDBACK_TYPE.FEEDBACK_GESTURE_PRESSANDTAP;
pub const FEEDBACK_MAX = enum_tagFEEDBACK_TYPE.FEEDBACK_MAX;
pub const enum_tagFEEDBACK_TYPE = extern enum {
    FEEDBACK_TOUCH_CONTACTVISUALIZATION = 1,
    FEEDBACK_PEN_BARRELVISUALIZATION = 2,
    FEEDBACK_PEN_TAP = 3,
    FEEDBACK_PEN_DOUBLETAP = 4,
    FEEDBACK_PEN_PRESSANDHOLD = 5,
    FEEDBACK_PEN_RIGHTTAP = 6,
    FEEDBACK_TOUCH_TAP = 7,
    FEEDBACK_TOUCH_DOUBLETAP = 8,
    FEEDBACK_TOUCH_PRESSANDHOLD = 9,
    FEEDBACK_TOUCH_RIGHTTAP = 10,
    FEEDBACK_GESTURE_PRESSANDTAP = 11,
    FEEDBACK_MAX = -1,
};
pub const FEEDBACK_TYPE = enum_tagFEEDBACK_TYPE;
pub extern "user32" fn GetWindowFeedbackSetting(hwnd: HWND, feedback: FEEDBACK_TYPE, dwFlags: DWORD, pSize: [*c]UINT32, config: ?*c_void) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetWindowFeedbackSetting(hwnd: HWND, feedback: FEEDBACK_TYPE, dwFlags: DWORD, size: UINT32, configuration: ?*const c_void) callconv(.Stdcall) BOOL;
pub const struct_tagINPUT_TRANSFORM = extern struct {
    @"": extern union {
        @"": extern struct {
            _11: f32,
            _12: f32,
            _13: f32,
            _14: f32,
            _21: f32,
            _22: f32,
            _23: f32,
            _24: f32,
            _31: f32,
            _32: f32,
            _33: f32,
            _34: f32,
            _41: f32,
            _42: f32,
            _43: f32,
            _44: f32,
        },
        m: [4][4]f32,
    },
};
pub const INPUT_TRANSFORM = struct_tagINPUT_TRANSFORM;
pub extern "user32" fn GetPointerInputTransform(pointerId: UINT32, historyCount: UINT32, inputTransform: [*c]INPUT_TRANSFORM) callconv(.Stdcall) BOOL;
pub const struct_tagLASTINPUTINFO = extern struct {
    cbSize: UINT,
    dwTime: DWORD,
};
pub const LASTINPUTINFO = struct_tagLASTINPUTINFO;
pub const PLASTINPUTINFO = [*c]struct_tagLASTINPUTINFO;
pub extern "user32" fn GetLastInputInfo(plii: PLASTINPUTINFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn MapVirtualKeyA(uCode: UINT, uMapType: UINT) callconv(.Stdcall) UINT;
pub extern "user32" fn MapVirtualKeyW(uCode: UINT, uMapType: UINT) callconv(.Stdcall) UINT;
pub extern "user32" fn MapVirtualKeyExA(uCode: UINT, uMapType: UINT, dwhkl: HKL) callconv(.Stdcall) UINT;
pub extern "user32" fn MapVirtualKeyExW(uCode: UINT, uMapType: UINT, dwhkl: HKL) callconv(.Stdcall) UINT;
pub extern "user32" fn GetInputState() callconv(.Stdcall) BOOL;
pub extern "user32" fn GetQueueStatus(flags: UINT) callconv(.Stdcall) DWORD;
pub extern "user32" fn GetCapture() callconv(.Stdcall) HWND;
pub extern "user32" fn SetCapture(hWnd: HWND) callconv(.Stdcall) HWND;
pub extern "user32" fn ReleaseCapture() callconv(.Stdcall) BOOL;
pub extern "user32" fn MsgWaitForMultipleObjects(nCount: DWORD, pHandles: [*c]const HANDLE, fWaitAll: BOOL, dwMilliseconds: DWORD, dwWakeMask: DWORD) callconv(.Stdcall) DWORD;
pub extern "user32" fn MsgWaitForMultipleObjectsEx(nCount: DWORD, pHandles: [*c]const HANDLE, dwMilliseconds: DWORD, dwWakeMask: DWORD, dwFlags: DWORD) callconv(.Stdcall) DWORD;
pub extern "user32" fn SetTimer(hWnd: HWND, nIDEvent: UINT_PTR, uElapse: UINT, lpTimerFunc: TIMERPROC) callconv(.Stdcall) UINT_PTR;
pub extern "user32" fn SetCoalescableTimer(hWnd: HWND, nIDEvent: UINT_PTR, uElapse: UINT, lpTimerFunc: TIMERPROC, uToleranceDelay: ULONG) callconv(.Stdcall) UINT_PTR;
pub extern "user32" fn KillTimer(hWnd: HWND, uIDEvent: UINT_PTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsWindowUnicode(hWnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn EnableWindow(hWnd: HWND, bEnable: BOOL) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsWindowEnabled(hWnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn LoadAcceleratorsA(hInstance: HINSTANCE, lpTableName: LPCSTR) callconv(.Stdcall) HACCEL;
pub extern "user32" fn LoadAcceleratorsW(hInstance: HINSTANCE, lpTableName: LPCWSTR) callconv(.Stdcall) HACCEL;
pub extern "user32" fn CreateAcceleratorTableA(paccel: LPACCEL, cAccel: c_int) callconv(.Stdcall) HACCEL;
pub extern "user32" fn CreateAcceleratorTableW(paccel: LPACCEL, cAccel: c_int) callconv(.Stdcall) HACCEL;
pub extern "user32" fn DestroyAcceleratorTable(hAccel: HACCEL) callconv(.Stdcall) BOOL;
pub extern "user32" fn CopyAcceleratorTableA(hAccelSrc: HACCEL, lpAccelDst: LPACCEL, cAccelEntries: c_int) callconv(.Stdcall) c_int;
pub extern "user32" fn CopyAcceleratorTableW(hAccelSrc: HACCEL, lpAccelDst: LPACCEL, cAccelEntries: c_int) callconv(.Stdcall) c_int;
pub extern "user32" fn TranslateAcceleratorA(hWnd: HWND, hAccTable: HACCEL, lpMsg: LPMSG) callconv(.Stdcall) c_int;
pub extern "user32" fn TranslateAcceleratorW(hWnd: HWND, hAccTable: HACCEL, lpMsg: LPMSG) callconv(.Stdcall) c_int;
pub extern "user32" fn GetSystemMetrics(nIndex: c_int) callconv(.Stdcall) c_int;
pub extern "user32" fn GetSystemMetricsForDpi(nIndex: c_int, dpi: UINT) callconv(.Stdcall) c_int;
pub extern "user32" fn LoadMenuA(hInstance: HINSTANCE, lpMenuName: LPCSTR) callconv(.Stdcall) HMENU;
pub extern "user32" fn LoadMenuW(hInstance: HINSTANCE, lpMenuName: LPCWSTR) callconv(.Stdcall) HMENU;
pub extern "user32" fn LoadMenuIndirectA(lpMenuTemplate: ?*const MENUTEMPLATEA) callconv(.Stdcall) HMENU;
pub extern "user32" fn LoadMenuIndirectW(lpMenuTemplate: ?*const MENUTEMPLATEW) callconv(.Stdcall) HMENU;
pub extern "user32" fn GetMenu(hWnd: HWND) callconv(.Stdcall) HMENU;
pub extern "user32" fn SetMenu(hWnd: HWND, hMenu: HMENU) callconv(.Stdcall) BOOL;
pub extern "user32" fn ChangeMenuA(hMenu: HMENU, cmd: UINT, lpszNewItem: LPCSTR, cmdInsert: UINT, flags: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn ChangeMenuW(hMenu: HMENU, cmd: UINT, lpszNewItem: LPCWSTR, cmdInsert: UINT, flags: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn HiliteMenuItem(hWnd: HWND, hMenu: HMENU, uIDHiliteItem: UINT, uHilite: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetMenuStringA(hMenu: HMENU, uIDItem: UINT, lpString: LPSTR, cchMax: c_int, flags: UINT) callconv(.Stdcall) c_int;
pub extern "user32" fn GetMenuStringW(hMenu: HMENU, uIDItem: UINT, lpString: LPWSTR, cchMax: c_int, flags: UINT) callconv(.Stdcall) c_int;
pub extern "user32" fn GetMenuState(hMenu: HMENU, uId: UINT, uFlags: UINT) callconv(.Stdcall) UINT;
pub extern "user32" fn DrawMenuBar(hWnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetSystemMenu(hWnd: HWND, bRevert: BOOL) callconv(.Stdcall) HMENU;
pub extern "user32" fn CreateMenu() callconv(.Stdcall) HMENU;
pub extern "user32" fn CreatePopupMenu() callconv(.Stdcall) HMENU;
pub extern "user32" fn DestroyMenu(hMenu: HMENU) callconv(.Stdcall) BOOL;
pub extern "user32" fn CheckMenuItem(hMenu: HMENU, uIDCheckItem: UINT, uCheck: UINT) callconv(.Stdcall) DWORD;
pub extern "user32" fn EnableMenuItem(hMenu: HMENU, uIDEnableItem: UINT, uEnable: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetSubMenu(hMenu: HMENU, nPos: c_int) callconv(.Stdcall) HMENU;
pub extern "user32" fn GetMenuItemID(hMenu: HMENU, nPos: c_int) callconv(.Stdcall) UINT;
pub extern "user32" fn GetMenuItemCount(hMenu: HMENU) callconv(.Stdcall) c_int;
pub extern "user32" fn InsertMenuA(hMenu: HMENU, uPosition: UINT, uFlags: UINT, uIDNewItem: UINT_PTR, lpNewItem: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn InsertMenuW(hMenu: HMENU, uPosition: UINT, uFlags: UINT, uIDNewItem: UINT_PTR, lpNewItem: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn AppendMenuA(hMenu: HMENU, uFlags: UINT, uIDNewItem: UINT_PTR, lpNewItem: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn AppendMenuW(hMenu: HMENU, uFlags: UINT, uIDNewItem: UINT_PTR, lpNewItem: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn ModifyMenuA(hMnu: HMENU, uPosition: UINT, uFlags: UINT, uIDNewItem: UINT_PTR, lpNewItem: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn ModifyMenuW(hMnu: HMENU, uPosition: UINT, uFlags: UINT, uIDNewItem: UINT_PTR, lpNewItem: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn RemoveMenu(hMenu: HMENU, uPosition: UINT, uFlags: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn DeleteMenu(hMenu: HMENU, uPosition: UINT, uFlags: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetMenuItemBitmaps(hMenu: HMENU, uPosition: UINT, uFlags: UINT, hBitmapUnchecked: HBITMAP, hBitmapChecked: HBITMAP) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetMenuCheckMarkDimensions() callconv(.Stdcall) LONG;
pub extern "user32" fn TrackPopupMenu(hMenu: HMENU, uFlags: UINT, x: c_int, y: c_int, nReserved: c_int, hWnd: HWND, prcRect: [*c]const RECT) callconv(.Stdcall) BOOL;
pub const struct_tagTPMPARAMS = extern struct {
    cbSize: UINT,
    rcExclude: RECT,
};
pub const TPMPARAMS = struct_tagTPMPARAMS;
pub const LPTPMPARAMS = [*c]TPMPARAMS;
pub extern "user32" fn TrackPopupMenuEx(hMenu: HMENU, uFlags: UINT, x: c_int, y: c_int, hwnd: HWND, lptpm: LPTPMPARAMS) callconv(.Stdcall) BOOL;
pub extern "user32" fn CalculatePopupWindowPosition(anchorPoint: [*c]const POINT, windowSize: [*c]const SIZE, flags: UINT, excludeRect: [*c]RECT, popupWindowPosition: [*c]RECT) callconv(.Stdcall) BOOL;
pub const struct_tagMENUINFO = extern struct {
    cbSize: DWORD,
    fMask: DWORD,
    dwStyle: DWORD,
    cyMax: UINT,
    hbrBack: HBRUSH,
    dwContextHelpID: DWORD,
    dwMenuData: ULONG_PTR,
};
pub const MENUINFO = struct_tagMENUINFO;
pub const LPMENUINFO = [*c]struct_tagMENUINFO;
pub const LPCMENUINFO = [*c]const MENUINFO;
pub extern "user32" fn GetMenuInfo(arg0: HMENU, arg1: LPMENUINFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetMenuInfo(arg0: HMENU, arg1: LPCMENUINFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn EndMenu() callconv(.Stdcall) BOOL;
pub const struct_tagMENUGETOBJECTINFO = extern struct {
    dwFlags: DWORD,
    uPos: UINT,
    hmenu: HMENU,
    riid: PVOID,
    pvObj: PVOID,
};
pub const MENUGETOBJECTINFO = struct_tagMENUGETOBJECTINFO;
pub const PMENUGETOBJECTINFO = [*c]struct_tagMENUGETOBJECTINFO;
pub const struct_tagMENUITEMINFOA = extern struct {
    cbSize: UINT,
    fMask: UINT,
    fType: UINT,
    fState: UINT,
    wID: UINT,
    hSubMenu: HMENU,
    hbmpChecked: HBITMAP,
    hbmpUnchecked: HBITMAP,
    dwItemData: ULONG_PTR,
    dwTypeData: LPSTR,
    cch: UINT,
    hbmpItem: HBITMAP,
};
pub const MENUITEMINFOA = struct_tagMENUITEMINFOA;
pub const LPMENUITEMINFOA = [*c]struct_tagMENUITEMINFOA;
pub const struct_tagMENUITEMINFOW = extern struct {
    cbSize: UINT,
    fMask: UINT,
    fType: UINT,
    fState: UINT,
    wID: UINT,
    hSubMenu: HMENU,
    hbmpChecked: HBITMAP,
    hbmpUnchecked: HBITMAP,
    dwItemData: ULONG_PTR,
    dwTypeData: LPWSTR,
    cch: UINT,
    hbmpItem: HBITMAP,
};
pub const MENUITEMINFOW = struct_tagMENUITEMINFOW;
pub const LPMENUITEMINFOW = [*c]struct_tagMENUITEMINFOW;
pub const MENUITEMINFO = MENUITEMINFOA;
pub const LPMENUITEMINFO = LPMENUITEMINFOA;
pub const LPCMENUITEMINFOA = [*c]const MENUITEMINFOA;
pub const LPCMENUITEMINFOW = [*c]const MENUITEMINFOW;
pub const LPCMENUITEMINFO = LPCMENUITEMINFOA;
pub extern "user32" fn InsertMenuItemA(hmenu: HMENU, item: UINT, fByPosition: BOOL, lpmi: LPCMENUITEMINFOA) callconv(.Stdcall) BOOL;
pub extern "user32" fn InsertMenuItemW(hmenu: HMENU, item: UINT, fByPosition: BOOL, lpmi: LPCMENUITEMINFOW) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetMenuItemInfoA(hmenu: HMENU, item: UINT, fByPosition: BOOL, lpmii: LPMENUITEMINFOA) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetMenuItemInfoW(hmenu: HMENU, item: UINT, fByPosition: BOOL, lpmii: LPMENUITEMINFOW) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetMenuItemInfoA(hmenu: HMENU, item: UINT, fByPositon: BOOL, lpmii: LPCMENUITEMINFOA) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetMenuItemInfoW(hmenu: HMENU, item: UINT, fByPositon: BOOL, lpmii: LPCMENUITEMINFOW) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetMenuDefaultItem(hMenu: HMENU, fByPos: UINT, gmdiFlags: UINT) callconv(.Stdcall) UINT;
pub extern "user32" fn SetMenuDefaultItem(hMenu: HMENU, uItem: UINT, fByPos: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetMenuItemRect(hWnd: HWND, hMenu: HMENU, uItem: UINT, lprcItem: LPRECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn MenuItemFromPoint(hWnd: HWND, hMenu: HMENU, ptScreen: POINT) callconv(.Stdcall) c_int;
pub const struct_tagDROPSTRUCT = extern struct {
    hwndSource: HWND,
    hwndSink: HWND,
    wFmt: DWORD,
    dwData: ULONG_PTR,
    ptDrop: POINT,
    dwControlData: DWORD,
};
pub const DROPSTRUCT = struct_tagDROPSTRUCT;
pub const PDROPSTRUCT = [*c]struct_tagDROPSTRUCT;
pub const LPDROPSTRUCT = [*c]struct_tagDROPSTRUCT;
pub extern "user32" fn DragObject(hwndParent: HWND, hwndFrom: HWND, fmt: UINT, data: ULONG_PTR, hcur: HCURSOR) callconv(.Stdcall) DWORD;
pub extern "user32" fn DragDetect(hwnd: HWND, pt: POINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn DrawIcon(hDC: HDC, X: c_int, Y: c_int, hIcon: HICON) callconv(.Stdcall) BOOL;
pub const struct_tagDRAWTEXTPARAMS = extern struct {
    cbSize: UINT,
    iTabLength: c_int,
    iLeftMargin: c_int,
    iRightMargin: c_int,
    uiLengthDrawn: UINT,
};
pub const DRAWTEXTPARAMS = struct_tagDRAWTEXTPARAMS;
pub const LPDRAWTEXTPARAMS = [*c]struct_tagDRAWTEXTPARAMS;
pub extern "user32" fn DrawTextA(hdc: HDC, lpchText: LPCSTR, cchText: c_int, lprc: LPRECT, format: UINT) callconv(.Stdcall) c_int;
pub extern "user32" fn DrawTextW(hdc: HDC, lpchText: LPCWSTR, cchText: c_int, lprc: LPRECT, format: UINT) callconv(.Stdcall) c_int;
pub extern "user32" fn DrawTextExA(hdc: HDC, lpchText: LPSTR, cchText: c_int, lprc: LPRECT, format: UINT, lpdtp: LPDRAWTEXTPARAMS) callconv(.Stdcall) c_int;
pub extern "user32" fn DrawTextExW(hdc: HDC, lpchText: LPWSTR, cchText: c_int, lprc: LPRECT, format: UINT, lpdtp: LPDRAWTEXTPARAMS) callconv(.Stdcall) c_int;
pub extern "user32" fn GrayStringA(hDC: HDC, hBrush: HBRUSH, lpOutputFunc: GRAYSTRINGPROC, lpData: LPARAM, nCount: c_int, X: c_int, Y: c_int, nWidth: c_int, nHeight: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn GrayStringW(hDC: HDC, hBrush: HBRUSH, lpOutputFunc: GRAYSTRINGPROC, lpData: LPARAM, nCount: c_int, X: c_int, Y: c_int, nWidth: c_int, nHeight: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn DrawStateA(hdc: HDC, hbrFore: HBRUSH, qfnCallBack: DRAWSTATEPROC, lData: LPARAM, wData: WPARAM, x: c_int, y: c_int, cx: c_int, cy: c_int, uFlags: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn DrawStateW(hdc: HDC, hbrFore: HBRUSH, qfnCallBack: DRAWSTATEPROC, lData: LPARAM, wData: WPARAM, x: c_int, y: c_int, cx: c_int, cy: c_int, uFlags: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn TabbedTextOutA(hdc: HDC, x: c_int, y: c_int, lpString: LPCSTR, chCount: c_int, nTabPositions: c_int, lpnTabStopPositions: [*c]const INT, nTabOrigin: c_int) callconv(.Stdcall) LONG;
pub extern "user32" fn TabbedTextOutW(hdc: HDC, x: c_int, y: c_int, lpString: LPCWSTR, chCount: c_int, nTabPositions: c_int, lpnTabStopPositions: [*c]const INT, nTabOrigin: c_int) callconv(.Stdcall) LONG;
pub extern "user32" fn GetTabbedTextExtentA(hdc: HDC, lpString: LPCSTR, chCount: c_int, nTabPositions: c_int, lpnTabStopPositions: [*c]const INT) callconv(.Stdcall) DWORD;
pub extern "user32" fn GetTabbedTextExtentW(hdc: HDC, lpString: LPCWSTR, chCount: c_int, nTabPositions: c_int, lpnTabStopPositions: [*c]const INT) callconv(.Stdcall) DWORD;
pub extern "user32" fn UpdateWindow(hWnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetActiveWindow(hWnd: HWND) callconv(.Stdcall) HWND;
pub extern "user32" fn GetForegroundWindow() callconv(.Stdcall) HWND;
pub extern "user32" fn PaintDesktop(hdc: HDC) callconv(.Stdcall) BOOL;
pub extern "user32" fn SwitchToThisWindow(hwnd: HWND, fUnknown: BOOL) callconv(.Stdcall) void;
pub extern "user32" fn SetForegroundWindow(hWnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn AllowSetForegroundWindow(dwProcessId: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn LockSetForegroundWindow(uLockCode: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn WindowFromDC(hDC: HDC) callconv(.Stdcall) HWND;
pub extern "user32" fn GetDC(hWnd: HWND) callconv(.Stdcall) HDC;
pub extern "user32" fn GetDCEx(hWnd: HWND, hrgnClip: HRGN, flags: DWORD) callconv(.Stdcall) HDC;
pub extern "user32" fn GetWindowDC(hWnd: HWND) callconv(.Stdcall) HDC;
pub extern "user32" fn ReleaseDC(hWnd: HWND, hDC: HDC) callconv(.Stdcall) c_int;
pub extern "user32" fn BeginPaint(hWnd: HWND, lpPaint: LPPAINTSTRUCT) callconv(.Stdcall) HDC;
pub extern "user32" fn EndPaint(hWnd: HWND, lpPaint: [*c]const PAINTSTRUCT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetUpdateRect(hWnd: HWND, lpRect: LPRECT, bErase: BOOL) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetUpdateRgn(hWnd: HWND, hRgn: HRGN, bErase: BOOL) callconv(.Stdcall) c_int;
pub extern "user32" fn SetWindowRgn(hWnd: HWND, hRgn: HRGN, bRedraw: BOOL) callconv(.Stdcall) c_int;
pub extern "user32" fn GetWindowRgn(hWnd: HWND, hRgn: HRGN) callconv(.Stdcall) c_int;
pub extern "user32" fn GetWindowRgnBox(hWnd: HWND, lprc: LPRECT) callconv(.Stdcall) c_int;
pub extern "user32" fn ExcludeUpdateRgn(hDC: HDC, hWnd: HWND) callconv(.Stdcall) c_int;
pub extern "user32" fn InvalidateRect(hWnd: HWND, lpRect: [*c]const RECT, bErase: BOOL) callconv(.Stdcall) BOOL;
pub extern "user32" fn ValidateRect(hWnd: HWND, lpRect: [*c]const RECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn InvalidateRgn(hWnd: HWND, hRgn: HRGN, bErase: BOOL) callconv(.Stdcall) BOOL;
pub extern "user32" fn ValidateRgn(hWnd: HWND, hRgn: HRGN) callconv(.Stdcall) BOOL;
pub extern "user32" fn RedrawWindow(hWnd: HWND, lprcUpdate: [*c]const RECT, hrgnUpdate: HRGN, flags: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn LockWindowUpdate(hWndLock: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn ScrollWindow(hWnd: HWND, XAmount: c_int, YAmount: c_int, lpRect: [*c]const RECT, lpClipRect: [*c]const RECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn ScrollDC(hDC: HDC, dx: c_int, dy: c_int, lprcScroll: [*c]const RECT, lprcClip: [*c]const RECT, hrgnUpdate: HRGN, lprcUpdate: LPRECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn ScrollWindowEx(hWnd: HWND, dx: c_int, dy: c_int, prcScroll: [*c]const RECT, prcClip: [*c]const RECT, hrgnUpdate: HRGN, prcUpdate: LPRECT, flags: UINT) callconv(.Stdcall) c_int;
pub extern "user32" fn SetScrollPos(hWnd: HWND, nBar: c_int, nPos: c_int, bRedraw: BOOL) callconv(.Stdcall) c_int;
pub extern "user32" fn GetScrollPos(hWnd: HWND, nBar: c_int) callconv(.Stdcall) c_int;
pub extern "user32" fn SetScrollRange(hWnd: HWND, nBar: c_int, nMinPos: c_int, nMaxPos: c_int, bRedraw: BOOL) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetScrollRange(hWnd: HWND, nBar: c_int, lpMinPos: LPINT, lpMaxPos: LPINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn ShowScrollBar(hWnd: HWND, wBar: c_int, bShow: BOOL) callconv(.Stdcall) BOOL;
pub extern "user32" fn EnableScrollBar(hWnd: HWND, wSBflags: UINT, wArrows: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetPropA(hWnd: HWND, lpString: LPCSTR, hData: HANDLE) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetPropW(hWnd: HWND, lpString: LPCWSTR, hData: HANDLE) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPropA(hWnd: HWND, lpString: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "user32" fn GetPropW(hWnd: HWND, lpString: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "user32" fn RemovePropA(hWnd: HWND, lpString: LPCSTR) callconv(.Stdcall) HANDLE;
pub extern "user32" fn RemovePropW(hWnd: HWND, lpString: LPCWSTR) callconv(.Stdcall) HANDLE;
pub extern "user32" fn EnumPropsExA(hWnd: HWND, lpEnumFunc: PROPENUMPROCEXA, lParam: LPARAM) callconv(.Stdcall) c_int;
pub extern "user32" fn EnumPropsExW(hWnd: HWND, lpEnumFunc: PROPENUMPROCEXW, lParam: LPARAM) callconv(.Stdcall) c_int;
pub extern "user32" fn EnumPropsA(hWnd: HWND, lpEnumFunc: PROPENUMPROCA) callconv(.Stdcall) c_int;
pub extern "user32" fn EnumPropsW(hWnd: HWND, lpEnumFunc: PROPENUMPROCW) callconv(.Stdcall) c_int;
pub extern "user32" fn SetWindowTextA(hWnd: HWND, lpString: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetWindowTextW(hWnd: HWND, lpString: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetWindowTextA(hWnd: HWND, lpString: LPSTR, nMaxCount: c_int) callconv(.Stdcall) c_int;
pub extern "user32" fn GetWindowTextW(hWnd: HWND, lpString: LPWSTR, nMaxCount: c_int) callconv(.Stdcall) c_int;
pub extern "user32" fn GetWindowTextLengthA(hWnd: HWND) callconv(.Stdcall) c_int;
pub extern "user32" fn GetWindowTextLengthW(hWnd: HWND) callconv(.Stdcall) c_int;
pub extern "user32" fn GetClientRect(hWnd: HWND, lpRect: LPRECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetWindowRect(hWnd: HWND, lpRect: LPRECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn AdjustWindowRect(lpRect: LPRECT, dwStyle: DWORD, bMenu: BOOL) callconv(.Stdcall) BOOL;
pub extern "user32" fn AdjustWindowRectEx(lpRect: LPRECT, dwStyle: DWORD, bMenu: BOOL, dwExStyle: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn AdjustWindowRectExForDpi(lpRect: LPRECT, dwStyle: DWORD, bMenu: BOOL, dwExStyle: DWORD, dpi: UINT) callconv(.Stdcall) BOOL;
pub const struct_tagHELPINFO = extern struct {
    cbSize: UINT,
    iContextType: c_int,
    iCtrlId: c_int,
    hItemHandle: HANDLE,
    dwContextId: DWORD_PTR,
    MousePos: POINT,
};
pub const HELPINFO = struct_tagHELPINFO;
pub const LPHELPINFO = [*c]struct_tagHELPINFO;
pub extern "user32" fn SetWindowContextHelpId(arg0: HWND, arg1: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetWindowContextHelpId(arg0: HWND) callconv(.Stdcall) DWORD;
pub extern "user32" fn SetMenuContextHelpId(arg0: HMENU, arg1: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetMenuContextHelpId(arg0: HMENU) callconv(.Stdcall) DWORD;
pub extern "user32" fn MessageBoxA(hWnd: HWND, lpText: LPCSTR, lpCaption: LPCSTR, uType: UINT) callconv(.Stdcall) c_int;
pub extern "user32" fn MessageBoxW(hWnd: HWND, lpText: LPCWSTR, lpCaption: LPCWSTR, uType: UINT) callconv(.Stdcall) c_int;
pub extern "user32" fn MessageBoxExA(hWnd: HWND, lpText: LPCSTR, lpCaption: LPCSTR, uType: UINT, wLanguageId: WORD) callconv(.Stdcall) c_int;
pub extern "user32" fn MessageBoxExW(hWnd: HWND, lpText: LPCWSTR, lpCaption: LPCWSTR, uType: UINT, wLanguageId: WORD) callconv(.Stdcall) c_int;
pub const MSGBOXCALLBACK = ?fn (LPHELPINFO) callconv(.C) void;
pub const struct_tagMSGBOXPARAMSA = extern struct {
    cbSize: UINT,
    hwndOwner: HWND,
    hInstance: HINSTANCE,
    lpszText: LPCSTR,
    lpszCaption: LPCSTR,
    dwStyle: DWORD,
    lpszIcon: LPCSTR,
    dwContextHelpId: DWORD_PTR,
    lpfnMsgBoxCallback: MSGBOXCALLBACK,
    dwLanguageId: DWORD,
};
pub const MSGBOXPARAMSA = struct_tagMSGBOXPARAMSA;
pub const PMSGBOXPARAMSA = [*c]struct_tagMSGBOXPARAMSA;
pub const LPMSGBOXPARAMSA = [*c]struct_tagMSGBOXPARAMSA;
pub const struct_tagMSGBOXPARAMSW = extern struct {
    cbSize: UINT,
    hwndOwner: HWND,
    hInstance: HINSTANCE,
    lpszText: LPCWSTR,
    lpszCaption: LPCWSTR,
    dwStyle: DWORD,
    lpszIcon: LPCWSTR,
    dwContextHelpId: DWORD_PTR,
    lpfnMsgBoxCallback: MSGBOXCALLBACK,
    dwLanguageId: DWORD,
};
pub const MSGBOXPARAMSW = struct_tagMSGBOXPARAMSW;
pub const PMSGBOXPARAMSW = [*c]struct_tagMSGBOXPARAMSW;
pub const LPMSGBOXPARAMSW = [*c]struct_tagMSGBOXPARAMSW;
pub const MSGBOXPARAMS = MSGBOXPARAMSA;
pub const PMSGBOXPARAMS = PMSGBOXPARAMSA;
pub const LPMSGBOXPARAMS = LPMSGBOXPARAMSA;
pub extern "user32" fn MessageBoxIndirectA(lpmbp: [*c]const MSGBOXPARAMSA) callconv(.Stdcall) c_int;
pub extern "user32" fn MessageBoxIndirectW(lpmbp: [*c]const MSGBOXPARAMSW) callconv(.Stdcall) c_int;
pub extern "user32" fn MessageBeep(uType: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn ShowCursor(bShow: BOOL) callconv(.Stdcall) c_int;
pub extern "user32" fn SetCursorPos(X: c_int, Y: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetPhysicalCursorPos(X: c_int, Y: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetCursor(hCursor: HCURSOR) callconv(.Stdcall) HCURSOR;
pub extern "user32" fn GetCursorPos(lpPoint: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPhysicalCursorPos(lpPoint: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetClipCursor(lpRect: LPRECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetCursor() callconv(.Stdcall) HCURSOR;
pub extern "user32" fn CreateCaret(hWnd: HWND, hBitmap: HBITMAP, nWidth: c_int, nHeight: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetCaretBlinkTime() callconv(.Stdcall) UINT;
pub extern "user32" fn SetCaretBlinkTime(uMSeconds: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn DestroyCaret() callconv(.Stdcall) BOOL;
pub extern "user32" fn HideCaret(hWnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn ShowCaret(hWnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetCaretPos(X: c_int, Y: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetCaretPos(lpPoint: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn ClientToScreen(hWnd: HWND, lpPoint: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn ScreenToClient(hWnd: HWND, lpPoint: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn LogicalToPhysicalPoint(hWnd: HWND, lpPoint: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn PhysicalToLogicalPoint(hWnd: HWND, lpPoint: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn LogicalToPhysicalPointForPerMonitorDPI(hWnd: HWND, lpPoint: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn PhysicalToLogicalPointForPerMonitorDPI(hWnd: HWND, lpPoint: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn MapWindowPoints(hWndFrom: HWND, hWndTo: HWND, lpPoints: LPPOINT, cPoints: UINT) callconv(.Stdcall) c_int;
pub extern "user32" fn WindowFromPoint(Point: POINT) callconv(.Stdcall) HWND;
pub extern "user32" fn WindowFromPhysicalPoint(Point: POINT) callconv(.Stdcall) HWND;
pub extern "user32" fn ChildWindowFromPoint(hWndParent: HWND, Point: POINT) callconv(.Stdcall) HWND;
pub extern "user32" fn ClipCursor(lpRect: [*c]const RECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn ChildWindowFromPointEx(hwnd: HWND, pt: POINT, flags: UINT) callconv(.Stdcall) HWND;
pub extern "user32" fn GetSysColor(nIndex: c_int) callconv(.Stdcall) DWORD;
pub extern "user32" fn GetSysColorBrush(nIndex: c_int) callconv(.Stdcall) HBRUSH;
pub extern "user32" fn SetSysColors(cElements: c_int, lpaElements: [*c]const INT, lpaRgbValues: [*c]const COLORREF) callconv(.Stdcall) BOOL;
pub extern "user32" fn DrawFocusRect(hDC: HDC, lprc: [*c]const RECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn FillRect(hDC: HDC, lprc: [*c]const RECT, hbr: HBRUSH) callconv(.Stdcall) c_int;
pub extern "user32" fn FrameRect(hDC: HDC, lprc: [*c]const RECT, hbr: HBRUSH) callconv(.Stdcall) c_int;
pub extern "user32" fn InvertRect(hDC: HDC, lprc: [*c]const RECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetRect(lprc: LPRECT, xLeft: c_int, yTop: c_int, xRight: c_int, yBottom: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetRectEmpty(lprc: LPRECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn CopyRect(lprcDst: LPRECT, lprcSrc: [*c]const RECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn InflateRect(lprc: LPRECT, dx: c_int, dy: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn IntersectRect(lprcDst: LPRECT, lprcSrc1: [*c]const RECT, lprcSrc2: [*c]const RECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn UnionRect(lprcDst: LPRECT, lprcSrc1: [*c]const RECT, lprcSrc2: [*c]const RECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn SubtractRect(lprcDst: LPRECT, lprcSrc1: [*c]const RECT, lprcSrc2: [*c]const RECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn OffsetRect(lprc: LPRECT, dx: c_int, dy: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsRectEmpty(lprc: [*c]const RECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn EqualRect(lprc1: [*c]const RECT, lprc2: [*c]const RECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn PtInRect(lprc: [*c]const RECT, pt: POINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetWindowWord(hWnd: HWND, nIndex: c_int) callconv(.Stdcall) WORD;
pub extern "user32" fn SetWindowWord(hWnd: HWND, nIndex: c_int, wNewWord: WORD) callconv(.Stdcall) WORD;
pub extern "user32" fn GetWindowLongA(hWnd: HWND, nIndex: c_int) callconv(.Stdcall) LONG;
pub extern "user32" fn GetWindowLongW(hWnd: HWND, nIndex: c_int) callconv(.Stdcall) LONG;
pub extern "user32" fn SetWindowLongA(hWnd: HWND, nIndex: c_int, dwNewLong: LONG) callconv(.Stdcall) LONG;
pub extern "user32" fn SetWindowLongW(hWnd: HWND, nIndex: c_int, dwNewLong: LONG) callconv(.Stdcall) LONG;
pub extern "user32" fn GetWindowLongPtrA(hWnd: HWND, nIndex: c_int) callconv(.Stdcall) LONG_PTR;
pub extern "user32" fn GetWindowLongPtrW(hWnd: HWND, nIndex: c_int) callconv(.Stdcall) LONG_PTR;
pub extern "user32" fn SetWindowLongPtrA(hWnd: HWND, nIndex: c_int, dwNewLong: LONG_PTR) callconv(.Stdcall) LONG_PTR;
pub extern "user32" fn SetWindowLongPtrW(hWnd: HWND, nIndex: c_int, dwNewLong: LONG_PTR) callconv(.Stdcall) LONG_PTR;
pub extern "user32" fn GetClassWord(hWnd: HWND, nIndex: c_int) callconv(.Stdcall) WORD;
pub extern "user32" fn SetClassWord(hWnd: HWND, nIndex: c_int, wNewWord: WORD) callconv(.Stdcall) WORD;
pub extern "user32" fn GetClassLongA(hWnd: HWND, nIndex: c_int) callconv(.Stdcall) DWORD;
pub extern "user32" fn GetClassLongW(hWnd: HWND, nIndex: c_int) callconv(.Stdcall) DWORD;
pub extern "user32" fn SetClassLongA(hWnd: HWND, nIndex: c_int, dwNewLong: LONG) callconv(.Stdcall) DWORD;
pub extern "user32" fn SetClassLongW(hWnd: HWND, nIndex: c_int, dwNewLong: LONG) callconv(.Stdcall) DWORD;
pub extern "user32" fn GetClassLongPtrA(hWnd: HWND, nIndex: c_int) callconv(.Stdcall) ULONG_PTR;
pub extern "user32" fn GetClassLongPtrW(hWnd: HWND, nIndex: c_int) callconv(.Stdcall) ULONG_PTR;
pub extern "user32" fn SetClassLongPtrA(hWnd: HWND, nIndex: c_int, dwNewLong: LONG_PTR) callconv(.Stdcall) ULONG_PTR;
pub extern "user32" fn SetClassLongPtrW(hWnd: HWND, nIndex: c_int, dwNewLong: LONG_PTR) callconv(.Stdcall) ULONG_PTR;
pub extern "user32" fn GetProcessDefaultLayout(pdwDefaultLayout: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetProcessDefaultLayout(dwDefaultLayout: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetDesktopWindow() callconv(.Stdcall) HWND;
pub extern "user32" fn GetParent(hWnd: HWND) callconv(.Stdcall) HWND;
pub extern "user32" fn SetParent(hWndChild: HWND, hWndNewParent: HWND) callconv(.Stdcall) HWND;
pub extern "user32" fn EnumChildWindows(hWndParent: HWND, lpEnumFunc: WNDENUMPROC, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub extern "user32" fn FindWindowA(lpClassName: LPCSTR, lpWindowName: LPCSTR) callconv(.Stdcall) HWND;
pub extern "user32" fn FindWindowW(lpClassName: LPCWSTR, lpWindowName: LPCWSTR) callconv(.Stdcall) HWND;
pub extern "user32" fn FindWindowExA(hWndParent: HWND, hWndChildAfter: HWND, lpszClass: LPCSTR, lpszWindow: LPCSTR) callconv(.Stdcall) HWND;
pub extern "user32" fn FindWindowExW(hWndParent: HWND, hWndChildAfter: HWND, lpszClass: LPCWSTR, lpszWindow: LPCWSTR) callconv(.Stdcall) HWND;
pub extern "user32" fn GetShellWindow() callconv(.Stdcall) HWND;
pub extern "user32" fn RegisterShellHookWindow(hwnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn DeregisterShellHookWindow(hwnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn EnumWindows(lpEnumFunc: WNDENUMPROC, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub extern "user32" fn EnumThreadWindows(dwThreadId: DWORD, lpfn: WNDENUMPROC, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetClassNameA(hWnd: HWND, lpClassName: LPSTR, nMaxCount: c_int) callconv(.Stdcall) c_int;
pub extern "user32" fn GetClassNameW(hWnd: HWND, lpClassName: LPWSTR, nMaxCount: c_int) callconv(.Stdcall) c_int;
pub extern "user32" fn GetTopWindow(hWnd: HWND) callconv(.Stdcall) HWND;
pub extern "user32" fn GetWindowThreadProcessId(hWnd: HWND, lpdwProcessId: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "user32" fn IsGUIThread(bConvert: BOOL) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetLastActivePopup(hWnd: HWND) callconv(.Stdcall) HWND;
pub extern "user32" fn GetWindow(hWnd: HWND, uCmd: UINT) callconv(.Stdcall) HWND;
pub extern "user32" fn SetWindowsHookA(nFilterType: c_int, pfnFilterProc: HOOKPROC) callconv(.Stdcall) HHOOK;
pub extern "user32" fn SetWindowsHookW(nFilterType: c_int, pfnFilterProc: HOOKPROC) callconv(.Stdcall) HHOOK;
pub extern "user32" fn UnhookWindowsHook(nCode: c_int, pfnFilterProc: HOOKPROC) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetWindowsHookExA(idHook: c_int, lpfn: HOOKPROC, hmod: HINSTANCE, dwThreadId: DWORD) callconv(.Stdcall) HHOOK;
pub extern "user32" fn SetWindowsHookExW(idHook: c_int, lpfn: HOOKPROC, hmod: HINSTANCE, dwThreadId: DWORD) callconv(.Stdcall) HHOOK;
pub extern "user32" fn UnhookWindowsHookEx(hhk: HHOOK) callconv(.Stdcall) BOOL;
pub extern "user32" fn CallNextHookEx(hhk: HHOOK, nCode: c_int, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "user32" fn CheckMenuRadioItem(hmenu: HMENU, first: UINT, last: UINT, check: UINT, flags: UINT) callconv(.Stdcall) BOOL;
pub const MENUITEMTEMPLATEHEADER = extern struct {
    versionNumber: WORD,
    offset: WORD,
};
pub const PMENUITEMTEMPLATEHEADER = [*c]extern struct {
    versionNumber: WORD,
    offset: WORD,
};
pub const MENUITEMTEMPLATE = extern struct {
    mtOption: WORD,
    mtID: WORD,
    mtString: [1]WCHAR,
};
pub const PMENUITEMTEMPLATE = [*c]extern struct {
    mtOption: WORD,
    mtID: WORD,
    mtString: [1]WCHAR,
};
pub extern "user32" fn LoadBitmapA(hInstance: HINSTANCE, lpBitmapName: LPCSTR) callconv(.Stdcall) HBITMAP;
pub extern "user32" fn LoadBitmapW(hInstance: HINSTANCE, lpBitmapName: LPCWSTR) callconv(.Stdcall) HBITMAP;
pub extern "user32" fn LoadCursorA(hInstance: HINSTANCE, lpCursorName: LPCSTR) callconv(.Stdcall) HCURSOR;
pub extern "user32" fn LoadCursorW(hInstance: HINSTANCE, lpCursorName: LPCWSTR) callconv(.Stdcall) HCURSOR;
pub extern "user32" fn LoadCursorFromFileA(lpFileName: LPCSTR) callconv(.Stdcall) HCURSOR;
pub extern "user32" fn LoadCursorFromFileW(lpFileName: LPCWSTR) callconv(.Stdcall) HCURSOR;
pub extern "user32" fn CreateCursor(hInst: HINSTANCE, xHotSpot: c_int, yHotSpot: c_int, nWidth: c_int, nHeight: c_int, pvANDPlane: ?*const c_void, pvXORPlane: ?*const c_void) callconv(.Stdcall) HCURSOR;
pub extern "user32" fn DestroyCursor(hCursor: HCURSOR) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetSystemCursor(hcur: HCURSOR, id: DWORD) callconv(.Stdcall) BOOL;
pub const struct__ICONINFO = extern struct {
    fIcon: BOOL,
    xHotspot: DWORD,
    yHotspot: DWORD,
    hbmMask: HBITMAP,
    hbmColor: HBITMAP,
};
pub const ICONINFO = struct__ICONINFO;
pub const PICONINFO = [*c]ICONINFO;
pub extern "user32" fn LoadIconA(hInstance: HINSTANCE, lpIconName: LPCSTR) callconv(.Stdcall) HICON;
pub extern "user32" fn LoadIconW(hInstance: HINSTANCE, lpIconName: LPCWSTR) callconv(.Stdcall) HICON;
pub extern "user32" fn PrivateExtractIconsA(szFileName: LPCSTR, nIconIndex: c_int, cxIcon: c_int, cyIcon: c_int, phicon: [*c]HICON, piconid: [*c]UINT, nIcons: UINT, flags: UINT) callconv(.Stdcall) UINT;
pub extern "user32" fn PrivateExtractIconsW(szFileName: LPCWSTR, nIconIndex: c_int, cxIcon: c_int, cyIcon: c_int, phicon: [*c]HICON, piconid: [*c]UINT, nIcons: UINT, flags: UINT) callconv(.Stdcall) UINT;
pub extern "user32" fn CreateIcon(hInstance: HINSTANCE, nWidth: c_int, nHeight: c_int, cPlanes: BYTE, cBitsPixel: BYTE, lpbANDbits: [*c]const BYTE, lpbXORbits: [*c]const BYTE) callconv(.Stdcall) HICON;
pub extern "user32" fn DestroyIcon(hIcon: HICON) callconv(.Stdcall) BOOL;
pub extern "user32" fn LookupIconIdFromDirectory(presbits: PBYTE, fIcon: BOOL) callconv(.Stdcall) c_int;
pub extern "user32" fn LookupIconIdFromDirectoryEx(presbits: PBYTE, fIcon: BOOL, cxDesired: c_int, cyDesired: c_int, Flags: UINT) callconv(.Stdcall) c_int;
pub extern "user32" fn CreateIconFromResource(presbits: PBYTE, dwResSize: DWORD, fIcon: BOOL, dwVer: DWORD) callconv(.Stdcall) HICON;
pub extern "user32" fn CreateIconFromResourceEx(presbits: PBYTE, dwResSize: DWORD, fIcon: BOOL, dwVer: DWORD, cxDesired: c_int, cyDesired: c_int, Flags: UINT) callconv(.Stdcall) HICON;
pub const struct_tagCURSORSHAPE = extern struct {
    xHotSpot: c_int,
    yHotSpot: c_int,
    cx: c_int,
    cy: c_int,
    cbWidth: c_int,
    Planes: BYTE,
    BitsPixel: BYTE,
};
pub const CURSORSHAPE = struct_tagCURSORSHAPE;
pub const LPCURSORSHAPE = [*c]struct_tagCURSORSHAPE;
pub extern "user32" fn LoadImageA(hInst: HINSTANCE, name: LPCSTR, type_0: UINT, cx: c_int, cy: c_int, fuLoad: UINT) callconv(.Stdcall) HANDLE;
pub extern "user32" fn LoadImageW(hInst: HINSTANCE, name: LPCWSTR, type_0: UINT, cx: c_int, cy: c_int, fuLoad: UINT) callconv(.Stdcall) HANDLE;
pub extern "user32" fn CopyImage(h: HANDLE, type_0: UINT, cx: c_int, cy: c_int, flags: UINT) callconv(.Stdcall) HANDLE;
pub extern "user32" fn DrawIconEx(hdc: HDC, xLeft: c_int, yTop: c_int, hIcon: HICON, cxWidth: c_int, cyWidth: c_int, istepIfAniCur: UINT, hbrFlickerFreeDraw: HBRUSH, diFlags: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn CreateIconIndirect(piconinfo: PICONINFO) callconv(.Stdcall) HICON;
pub extern "user32" fn CopyIcon(hIcon: HICON) callconv(.Stdcall) HICON;
pub extern "user32" fn GetIconInfo(hIcon: HICON, piconinfo: PICONINFO) callconv(.Stdcall) BOOL;
pub const struct__ICONINFOEXA = extern struct {
    cbSize: DWORD,
    fIcon: BOOL,
    xHotspot: DWORD,
    yHotspot: DWORD,
    hbmMask: HBITMAP,
    hbmColor: HBITMAP,
    wResID: WORD,
    szModName: [260]CHAR,
    szResName: [260]CHAR,
};
pub const ICONINFOEXA = struct__ICONINFOEXA;
pub const PICONINFOEXA = [*c]struct__ICONINFOEXA;
pub const struct__ICONINFOEXW = extern struct {
    cbSize: DWORD,
    fIcon: BOOL,
    xHotspot: DWORD,
    yHotspot: DWORD,
    hbmMask: HBITMAP,
    hbmColor: HBITMAP,
    wResID: WORD,
    szModName: [260]WCHAR,
    szResName: [260]WCHAR,
};
pub const ICONINFOEXW = struct__ICONINFOEXW;
pub const PICONINFOEXW = [*c]struct__ICONINFOEXW;
pub const ICONINFOEX = ICONINFOEXA;
pub const PICONINFOEX = PICONINFOEXA;
pub extern "user32" fn GetIconInfoExA(hicon: HICON, piconinfo: PICONINFOEXA) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetIconInfoExW(hicon: HICON, piconinfo: PICONINFOEXW) callconv(.Stdcall) BOOL;
pub const EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT = 0;
pub const EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS = 1;
pub const EDIT_CONTROL_FEATURE = extern enum {
    EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT = 0,
    EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS = 1,
};
pub extern "user32" fn IsDialogMessageA(hDlg: HWND, lpMsg: LPMSG) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsDialogMessageW(hDlg: HWND, lpMsg: LPMSG) callconv(.Stdcall) BOOL;
pub extern "user32" fn MapDialogRect(hDlg: HWND, lpRect: LPRECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn DlgDirListA(hDlg: HWND, lpPathSpec: LPSTR, nIDListBox: c_int, nIDStaticPath: c_int, uFileType: UINT) callconv(.Stdcall) c_int;
pub extern "user32" fn DlgDirListW(hDlg: HWND, lpPathSpec: LPWSTR, nIDListBox: c_int, nIDStaticPath: c_int, uFileType: UINT) callconv(.Stdcall) c_int;
pub extern "user32" fn DlgDirSelectExA(hwndDlg: HWND, lpString: LPSTR, chCount: c_int, idListBox: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn DlgDirSelectExW(hwndDlg: HWND, lpString: LPWSTR, chCount: c_int, idListBox: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn DlgDirListComboBoxA(hDlg: HWND, lpPathSpec: LPSTR, nIDComboBox: c_int, nIDStaticPath: c_int, uFiletype: UINT) callconv(.Stdcall) c_int;
pub extern "user32" fn DlgDirListComboBoxW(hDlg: HWND, lpPathSpec: LPWSTR, nIDComboBox: c_int, nIDStaticPath: c_int, uFiletype: UINT) callconv(.Stdcall) c_int;
pub extern "user32" fn DlgDirSelectComboBoxExA(hwndDlg: HWND, lpString: LPSTR, cchOut: c_int, idComboBox: c_int) callconv(.Stdcall) BOOL;
pub extern "user32" fn DlgDirSelectComboBoxExW(hwndDlg: HWND, lpString: LPWSTR, cchOut: c_int, idComboBox: c_int) callconv(.Stdcall) BOOL;
pub const struct_tagSCROLLINFO = extern struct {
    cbSize: UINT,
    fMask: UINT,
    nMin: c_int,
    nMax: c_int,
    nPage: UINT,
    nPos: c_int,
    nTrackPos: c_int,
};
pub const SCROLLINFO = struct_tagSCROLLINFO;
pub const LPSCROLLINFO = [*c]struct_tagSCROLLINFO;
pub const LPCSCROLLINFO = [*c]const SCROLLINFO;
pub extern "user32" fn SetScrollInfo(hwnd: HWND, nBar: c_int, lpsi: LPCSCROLLINFO, redraw: BOOL) callconv(.Stdcall) c_int;
pub extern "user32" fn GetScrollInfo(hwnd: HWND, nBar: c_int, lpsi: LPSCROLLINFO) callconv(.Stdcall) BOOL;
pub const struct_tagMDICREATESTRUCTA = extern struct {
    szClass: LPCSTR,
    szTitle: LPCSTR,
    hOwner: HANDLE,
    x: c_int,
    y: c_int,
    cx: c_int,
    cy: c_int,
    style: DWORD,
    lParam: LPARAM,
};
pub const MDICREATESTRUCTA = struct_tagMDICREATESTRUCTA;
pub const LPMDICREATESTRUCTA = [*c]struct_tagMDICREATESTRUCTA;
pub const struct_tagMDICREATESTRUCTW = extern struct {
    szClass: LPCWSTR,
    szTitle: LPCWSTR,
    hOwner: HANDLE,
    x: c_int,
    y: c_int,
    cx: c_int,
    cy: c_int,
    style: DWORD,
    lParam: LPARAM,
};
pub const MDICREATESTRUCTW = struct_tagMDICREATESTRUCTW;
pub const LPMDICREATESTRUCTW = [*c]struct_tagMDICREATESTRUCTW;
pub const MDICREATESTRUCT = MDICREATESTRUCTA;
pub const LPMDICREATESTRUCT = LPMDICREATESTRUCTA;
pub const struct_tagCLIENTCREATESTRUCT = extern struct {
    hWindowMenu: HANDLE,
    idFirstChild: UINT,
};
pub const CLIENTCREATESTRUCT = struct_tagCLIENTCREATESTRUCT;
pub const LPCLIENTCREATESTRUCT = [*c]struct_tagCLIENTCREATESTRUCT;
pub extern "user32" fn DefFrameProcA(hWnd: HWND, hWndMDIClient: HWND, uMsg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "user32" fn DefFrameProcW(hWnd: HWND, hWndMDIClient: HWND, uMsg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "user32" fn DefMDIChildProcA(hWnd: HWND, uMsg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "user32" fn DefMDIChildProcW(hWnd: HWND, uMsg: UINT, wParam: WPARAM, lParam: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "user32" fn TranslateMDISysAccel(hWndClient: HWND, lpMsg: LPMSG) callconv(.Stdcall) BOOL;
pub extern "user32" fn ArrangeIconicWindows(hWnd: HWND) callconv(.Stdcall) UINT;
pub extern "user32" fn CreateMDIWindowA(lpClassName: LPCSTR, lpWindowName: LPCSTR, dwStyle: DWORD, X: c_int, Y: c_int, nWidth: c_int, nHeight: c_int, hWndParent: HWND, hInstance: HINSTANCE, lParam: LPARAM) callconv(.Stdcall) HWND;
pub extern "user32" fn CreateMDIWindowW(lpClassName: LPCWSTR, lpWindowName: LPCWSTR, dwStyle: DWORD, X: c_int, Y: c_int, nWidth: c_int, nHeight: c_int, hWndParent: HWND, hInstance: HINSTANCE, lParam: LPARAM) callconv(.Stdcall) HWND;
pub extern "user32" fn TileWindows(hwndParent: HWND, wHow: UINT, lpRect: [*c]const RECT, cKids: UINT, lpKids: [*c]const HWND) callconv(.Stdcall) WORD;
pub extern "user32" fn CascadeWindows(hwndParent: HWND, wHow: UINT, lpRect: [*c]const RECT, cKids: UINT, lpKids: [*c]const HWND) callconv(.Stdcall) WORD;
pub const HELPPOLY = DWORD;
pub const struct_tagMULTIKEYHELPA = extern struct {
    mkSize: DWORD,
    mkKeylist: CHAR,
    szKeyphrase: [1]CHAR,
};
pub const MULTIKEYHELPA = struct_tagMULTIKEYHELPA;
pub const PMULTIKEYHELPA = [*c]struct_tagMULTIKEYHELPA;
pub const LPMULTIKEYHELPA = [*c]struct_tagMULTIKEYHELPA;
pub const struct_tagMULTIKEYHELPW = extern struct {
    mkSize: DWORD,
    mkKeylist: WCHAR,
    szKeyphrase: [1]WCHAR,
};
pub const MULTIKEYHELPW = struct_tagMULTIKEYHELPW;
pub const PMULTIKEYHELPW = [*c]struct_tagMULTIKEYHELPW;
pub const LPMULTIKEYHELPW = [*c]struct_tagMULTIKEYHELPW;
pub const MULTIKEYHELP = MULTIKEYHELPA;
pub const PMULTIKEYHELP = PMULTIKEYHELPA;
pub const LPMULTIKEYHELP = LPMULTIKEYHELPA;
pub const struct_tagHELPWININFOA = extern struct {
    wStructSize: c_int,
    x: c_int,
    y: c_int,
    dx: c_int,
    dy: c_int,
    wMax: c_int,
    rgchMember: [2]CHAR,
};
pub const HELPWININFOA = struct_tagHELPWININFOA;
pub const PHELPWININFOA = [*c]struct_tagHELPWININFOA;
pub const LPHELPWININFOA = [*c]struct_tagHELPWININFOA;
pub const struct_tagHELPWININFOW = extern struct {
    wStructSize: c_int,
    x: c_int,
    y: c_int,
    dx: c_int,
    dy: c_int,
    wMax: c_int,
    rgchMember: [2]WCHAR,
};
pub const HELPWININFOW = struct_tagHELPWININFOW;
pub const PHELPWININFOW = [*c]struct_tagHELPWININFOW;
pub const LPHELPWININFOW = [*c]struct_tagHELPWININFOW;
pub const HELPWININFO = HELPWININFOA;
pub const PHELPWININFO = PHELPWININFOA;
pub const LPHELPWININFO = LPHELPWININFOA;
pub extern "user32" fn WinHelpA(hWndMain: HWND, lpszHelp: LPCSTR, uCommand: UINT, dwData: ULONG_PTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn WinHelpW(hWndMain: HWND, lpszHelp: LPCWSTR, uCommand: UINT, dwData: ULONG_PTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetGuiResources(hProcess: HANDLE, uiFlags: DWORD) callconv(.Stdcall) DWORD;
pub const struct_tagTouchPredictionParameters = extern struct {
    cbSize: UINT,
    dwLatency: UINT,
    dwSampleTime: UINT,
    bUseHWTimeStamp: UINT,
};
pub const TOUCHPREDICTIONPARAMETERS = struct_tagTouchPredictionParameters;
pub const PTOUCHPREDICTIONPARAMETERS = [*c]struct_tagTouchPredictionParameters;
pub const HANDEDNESS_LEFT = enum_tagHANDEDNESS.HANDEDNESS_LEFT;
pub const HANDEDNESS_RIGHT = enum_tagHANDEDNESS.HANDEDNESS_RIGHT;
pub const enum_tagHANDEDNESS = extern enum {
    HANDEDNESS_LEFT = 0,
    HANDEDNESS_RIGHT = 1,
};
pub const HANDEDNESS = enum_tagHANDEDNESS;
pub const PHANDEDNESS = [*c]enum_tagHANDEDNESS;
pub const struct_tagNONCLIENTMETRICSA = extern struct {
    cbSize: UINT,
    iBorderWidth: c_int,
    iScrollWidth: c_int,
    iScrollHeight: c_int,
    iCaptionWidth: c_int,
    iCaptionHeight: c_int,
    lfCaptionFont: LOGFONTA,
    iSmCaptionWidth: c_int,
    iSmCaptionHeight: c_int,
    lfSmCaptionFont: LOGFONTA,
    iMenuWidth: c_int,
    iMenuHeight: c_int,
    lfMenuFont: LOGFONTA,
    lfStatusFont: LOGFONTA,
    lfMessageFont: LOGFONTA,
    iPaddedBorderWidth: c_int,
};
pub const NONCLIENTMETRICSA = struct_tagNONCLIENTMETRICSA;
pub const PNONCLIENTMETRICSA = [*c]struct_tagNONCLIENTMETRICSA;
pub const LPNONCLIENTMETRICSA = [*c]struct_tagNONCLIENTMETRICSA;
pub const struct_tagNONCLIENTMETRICSW = extern struct {
    cbSize: UINT,
    iBorderWidth: c_int,
    iScrollWidth: c_int,
    iScrollHeight: c_int,
    iCaptionWidth: c_int,
    iCaptionHeight: c_int,
    lfCaptionFont: LOGFONTW,
    iSmCaptionWidth: c_int,
    iSmCaptionHeight: c_int,
    lfSmCaptionFont: LOGFONTW,
    iMenuWidth: c_int,
    iMenuHeight: c_int,
    lfMenuFont: LOGFONTW,
    lfStatusFont: LOGFONTW,
    lfMessageFont: LOGFONTW,
    iPaddedBorderWidth: c_int,
};
pub const NONCLIENTMETRICSW = struct_tagNONCLIENTMETRICSW;
pub const PNONCLIENTMETRICSW = [*c]struct_tagNONCLIENTMETRICSW;
pub const LPNONCLIENTMETRICSW = [*c]struct_tagNONCLIENTMETRICSW;
pub const NONCLIENTMETRICS = NONCLIENTMETRICSA;
pub const PNONCLIENTMETRICS = PNONCLIENTMETRICSA;
pub const LPNONCLIENTMETRICS = LPNONCLIENTMETRICSA;
pub const struct_tagMINIMIZEDMETRICS = extern struct {
    cbSize: UINT,
    iWidth: c_int,
    iHorzGap: c_int,
    iVertGap: c_int,
    iArrange: c_int,
};
pub const MINIMIZEDMETRICS = struct_tagMINIMIZEDMETRICS;
pub const PMINIMIZEDMETRICS = [*c]struct_tagMINIMIZEDMETRICS;
pub const LPMINIMIZEDMETRICS = [*c]struct_tagMINIMIZEDMETRICS;
pub const struct_tagICONMETRICSA = extern struct {
    cbSize: UINT,
    iHorzSpacing: c_int,
    iVertSpacing: c_int,
    iTitleWrap: c_int,
    lfFont: LOGFONTA,
};
pub const ICONMETRICSA = struct_tagICONMETRICSA;
pub const PICONMETRICSA = [*c]struct_tagICONMETRICSA;
pub const LPICONMETRICSA = [*c]struct_tagICONMETRICSA;
pub const struct_tagICONMETRICSW = extern struct {
    cbSize: UINT,
    iHorzSpacing: c_int,
    iVertSpacing: c_int,
    iTitleWrap: c_int,
    lfFont: LOGFONTW,
};
pub const ICONMETRICSW = struct_tagICONMETRICSW;
pub const PICONMETRICSW = [*c]struct_tagICONMETRICSW;
pub const LPICONMETRICSW = [*c]struct_tagICONMETRICSW;
pub const ICONMETRICS = ICONMETRICSA;
pub const PICONMETRICS = PICONMETRICSA;
pub const LPICONMETRICS = LPICONMETRICSA;
pub const struct_tagANIMATIONINFO = extern struct {
    cbSize: UINT,
    iMinAnimate: c_int,
};
pub const ANIMATIONINFO = struct_tagANIMATIONINFO;
pub const LPANIMATIONINFO = [*c]struct_tagANIMATIONINFO;
pub const struct_tagSERIALKEYSA = extern struct {
    cbSize: UINT,
    dwFlags: DWORD,
    lpszActivePort: LPSTR,
    lpszPort: LPSTR,
    iBaudRate: UINT,
    iPortState: UINT,
    iActive: UINT,
};
pub const SERIALKEYSA = struct_tagSERIALKEYSA;
pub const LPSERIALKEYSA = [*c]struct_tagSERIALKEYSA;
pub const struct_tagSERIALKEYSW = extern struct {
    cbSize: UINT,
    dwFlags: DWORD,
    lpszActivePort: LPWSTR,
    lpszPort: LPWSTR,
    iBaudRate: UINT,
    iPortState: UINT,
    iActive: UINT,
};
pub const SERIALKEYSW = struct_tagSERIALKEYSW;
pub const LPSERIALKEYSW = [*c]struct_tagSERIALKEYSW;
pub const SERIALKEYS = SERIALKEYSA;
pub const LPSERIALKEYS = LPSERIALKEYSA;
pub const struct_tagHIGHCONTRASTA = extern struct {
    cbSize: UINT,
    dwFlags: DWORD,
    lpszDefaultScheme: LPSTR,
};
pub const HIGHCONTRASTA = struct_tagHIGHCONTRASTA;
pub const LPHIGHCONTRASTA = [*c]struct_tagHIGHCONTRASTA;
pub const struct_tagHIGHCONTRASTW = extern struct {
    cbSize: UINT,
    dwFlags: DWORD,
    lpszDefaultScheme: LPWSTR,
};
pub const HIGHCONTRASTW = struct_tagHIGHCONTRASTW;
pub const LPHIGHCONTRASTW = [*c]struct_tagHIGHCONTRASTW;
pub const HIGHCONTRAST = HIGHCONTRASTA;
pub const LPHIGHCONTRAST = LPHIGHCONTRASTA;
pub const struct__VIDEOPARAMETERS = extern struct {
    Guid: GUID,
    dwOffset: ULONG,
    dwCommand: ULONG,
    dwFlags: ULONG,
    dwMode: ULONG,
    dwTVStandard: ULONG,
    dwAvailableModes: ULONG,
    dwAvailableTVStandard: ULONG,
    dwFlickerFilter: ULONG,
    dwOverScanX: ULONG,
    dwOverScanY: ULONG,
    dwMaxUnscaledX: ULONG,
    dwMaxUnscaledY: ULONG,
    dwPositionX: ULONG,
    dwPositionY: ULONG,
    dwBrightness: ULONG,
    dwContrast: ULONG,
    dwCPType: ULONG,
    dwCPCommand: ULONG,
    dwCPStandard: ULONG,
    dwCPKey: ULONG,
    bCP_APSTriggerBits: ULONG,
    bOEMCopyProtection: [256]UCHAR,
};
pub const VIDEOPARAMETERS = struct__VIDEOPARAMETERS;
pub const PVIDEOPARAMETERS = [*c]struct__VIDEOPARAMETERS;
pub const LPVIDEOPARAMETERS = [*c]struct__VIDEOPARAMETERS;
pub extern "user32" fn ChangeDisplaySettingsA(lpDevMode: [*c]DEVMODEA, dwFlags: DWORD) callconv(.Stdcall) LONG;
pub extern "user32" fn ChangeDisplaySettingsW(lpDevMode: [*c]DEVMODEW, dwFlags: DWORD) callconv(.Stdcall) LONG;
pub extern "user32" fn ChangeDisplaySettingsExA(lpszDeviceName: LPCSTR, lpDevMode: [*c]DEVMODEA, hwnd: HWND, dwflags: DWORD, lParam: LPVOID) callconv(.Stdcall) LONG;
pub extern "user32" fn ChangeDisplaySettingsExW(lpszDeviceName: LPCWSTR, lpDevMode: [*c]DEVMODEW, hwnd: HWND, dwflags: DWORD, lParam: LPVOID) callconv(.Stdcall) LONG;
pub extern "user32" fn EnumDisplaySettingsA(lpszDeviceName: LPCSTR, iModeNum: DWORD, lpDevMode: [*c]DEVMODEA) callconv(.Stdcall) BOOL;
pub extern "user32" fn EnumDisplaySettingsW(lpszDeviceName: LPCWSTR, iModeNum: DWORD, lpDevMode: [*c]DEVMODEW) callconv(.Stdcall) BOOL;
pub extern "user32" fn EnumDisplaySettingsExA(lpszDeviceName: LPCSTR, iModeNum: DWORD, lpDevMode: [*c]DEVMODEA, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn EnumDisplaySettingsExW(lpszDeviceName: LPCWSTR, iModeNum: DWORD, lpDevMode: [*c]DEVMODEW, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn EnumDisplayDevicesA(lpDevice: LPCSTR, iDevNum: DWORD, lpDisplayDevice: PDISPLAY_DEVICEA, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn EnumDisplayDevicesW(lpDevice: LPCWSTR, iDevNum: DWORD, lpDisplayDevice: PDISPLAY_DEVICEW, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetDisplayConfigBufferSizes(flags: UINT32, numPathArrayElements: [*c]UINT32, numModeInfoArrayElements: [*c]UINT32) callconv(.Stdcall) LONG;
pub extern "user32" fn SetDisplayConfig(numPathArrayElements: UINT32, pathArray: [*c]DISPLAYCONFIG_PATH_INFO, numModeInfoArrayElements: UINT32, modeInfoArray: [*c]DISPLAYCONFIG_MODE_INFO, flags: UINT32) callconv(.Stdcall) LONG;
pub extern "user32" fn QueryDisplayConfig(flags: UINT32, numPathArrayElements: [*c]UINT32, pathArray: [*c]DISPLAYCONFIG_PATH_INFO, numModeInfoArrayElements: [*c]UINT32, modeInfoArray: [*c]DISPLAYCONFIG_MODE_INFO, currentTopologyId: [*c]DISPLAYCONFIG_TOPOLOGY_ID) callconv(.Stdcall) LONG;
pub extern "user32" fn DisplayConfigGetDeviceInfo(requestPacket: [*c]DISPLAYCONFIG_DEVICE_INFO_HEADER) callconv(.Stdcall) LONG;
pub extern "user32" fn DisplayConfigSetDeviceInfo(setPacket: [*c]DISPLAYCONFIG_DEVICE_INFO_HEADER) callconv(.Stdcall) LONG;
pub extern "user32" fn SystemParametersInfoA(uiAction: UINT, uiParam: UINT, pvParam: PVOID, fWinIni: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn SystemParametersInfoW(uiAction: UINT, uiParam: UINT, pvParam: PVOID, fWinIni: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn SystemParametersInfoForDpi(uiAction: UINT, uiParam: UINT, pvParam: PVOID, fWinIni: UINT, dpi: UINT) callconv(.Stdcall) BOOL;
pub const struct_tagFILTERKEYS = extern struct {
    cbSize: UINT,
    dwFlags: DWORD,
    iWaitMSec: DWORD,
    iDelayMSec: DWORD,
    iRepeatMSec: DWORD,
    iBounceMSec: DWORD,
};
pub const FILTERKEYS = struct_tagFILTERKEYS;
pub const LPFILTERKEYS = [*c]struct_tagFILTERKEYS;
pub const struct_tagSTICKYKEYS = extern struct {
    cbSize: UINT,
    dwFlags: DWORD,
};
pub const STICKYKEYS = struct_tagSTICKYKEYS;
pub const LPSTICKYKEYS = [*c]struct_tagSTICKYKEYS;
pub const struct_tagMOUSEKEYS = extern struct {
    cbSize: UINT,
    dwFlags: DWORD,
    iMaxSpeed: DWORD,
    iTimeToMaxSpeed: DWORD,
    iCtrlSpeed: DWORD,
    dwReserved1: DWORD,
    dwReserved2: DWORD,
};
pub const MOUSEKEYS = struct_tagMOUSEKEYS;
pub const LPMOUSEKEYS = [*c]struct_tagMOUSEKEYS;
pub const struct_tagACCESSTIMEOUT = extern struct {
    cbSize: UINT,
    dwFlags: DWORD,
    iTimeOutMSec: DWORD,
};
pub const ACCESSTIMEOUT = struct_tagACCESSTIMEOUT;
pub const LPACCESSTIMEOUT = [*c]struct_tagACCESSTIMEOUT;
pub const struct_tagSOUNDSENTRYA = extern struct {
    cbSize: UINT,
    dwFlags: DWORD,
    iFSTextEffect: DWORD,
    iFSTextEffectMSec: DWORD,
    iFSTextEffectColorBits: DWORD,
    iFSGrafEffect: DWORD,
    iFSGrafEffectMSec: DWORD,
    iFSGrafEffectColor: DWORD,
    iWindowsEffect: DWORD,
    iWindowsEffectMSec: DWORD,
    lpszWindowsEffectDLL: LPSTR,
    iWindowsEffectOrdinal: DWORD,
};
pub const SOUNDSENTRYA = struct_tagSOUNDSENTRYA;
pub const LPSOUNDSENTRYA = [*c]struct_tagSOUNDSENTRYA;
pub const struct_tagSOUNDSENTRYW = extern struct {
    cbSize: UINT,
    dwFlags: DWORD,
    iFSTextEffect: DWORD,
    iFSTextEffectMSec: DWORD,
    iFSTextEffectColorBits: DWORD,
    iFSGrafEffect: DWORD,
    iFSGrafEffectMSec: DWORD,
    iFSGrafEffectColor: DWORD,
    iWindowsEffect: DWORD,
    iWindowsEffectMSec: DWORD,
    lpszWindowsEffectDLL: LPWSTR,
    iWindowsEffectOrdinal: DWORD,
};
pub const SOUNDSENTRYW = struct_tagSOUNDSENTRYW;
pub const LPSOUNDSENTRYW = [*c]struct_tagSOUNDSENTRYW;
pub const SOUNDSENTRY = SOUNDSENTRYA;
pub const LPSOUNDSENTRY = LPSOUNDSENTRYA;
pub extern "user32" fn SoundSentry() callconv(.Stdcall) BOOL;
pub const struct_tagTOGGLEKEYS = extern struct {
    cbSize: UINT,
    dwFlags: DWORD,
};
pub const TOGGLEKEYS = struct_tagTOGGLEKEYS;
pub const LPTOGGLEKEYS = [*c]struct_tagTOGGLEKEYS;
pub const struct_tagAUDIODESCRIPTION = extern struct {
    cbSize: UINT,
    Enabled: BOOL,
    Locale: LCID,
};
pub const AUDIODESCRIPTION = struct_tagAUDIODESCRIPTION;
pub const LPAUDIODESCRIPTION = [*c]struct_tagAUDIODESCRIPTION;
pub extern "user32" fn SetDebugErrorLevel(dwLevel: DWORD) callconv(.Stdcall) void;
pub extern "user32" fn SetLastErrorEx(dwErrCode: DWORD, dwType: DWORD) callconv(.Stdcall) void;
pub extern "user32" fn InternalGetWindowText(hWnd: HWND, pString: LPWSTR, cchMaxCount: c_int) callconv(.Stdcall) c_int;
pub extern "user32" fn CancelShutdown() callconv(.Stdcall) BOOL;
pub extern "user32" fn MonitorFromPoint(pt: POINT, dwFlags: DWORD) callconv(.Stdcall) HMONITOR;
pub extern "user32" fn MonitorFromRect(lprc: LPCRECT, dwFlags: DWORD) callconv(.Stdcall) HMONITOR;
pub extern "user32" fn MonitorFromWindow(hwnd: HWND, dwFlags: DWORD) callconv(.Stdcall) HMONITOR;
pub const struct_tagMONITORINFO = extern struct {
    cbSize: DWORD,
    rcMonitor: RECT,
    rcWork: RECT,
    dwFlags: DWORD,
};
pub const MONITORINFO = struct_tagMONITORINFO;
pub const LPMONITORINFO = [*c]struct_tagMONITORINFO;
pub const struct_tagMONITORINFOEXA = extern struct {
    @"": struct_tagMONITORINFO,
    szDevice: [32]CHAR,
};
pub const MONITORINFOEXA = struct_tagMONITORINFOEXA;
pub const LPMONITORINFOEXA = [*c]struct_tagMONITORINFOEXA;
pub const struct_tagMONITORINFOEXW = extern struct {
    @"": struct_tagMONITORINFO,
    szDevice: [32]WCHAR,
};
pub const MONITORINFOEXW = struct_tagMONITORINFOEXW;
pub const LPMONITORINFOEXW = [*c]struct_tagMONITORINFOEXW;
pub const MONITORINFOEX = MONITORINFOEXA;
pub const LPMONITORINFOEX = LPMONITORINFOEXA;
pub extern "user32" fn GetMonitorInfoA(hMonitor: HMONITOR, lpmi: LPMONITORINFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetMonitorInfoW(hMonitor: HMONITOR, lpmi: LPMONITORINFO) callconv(.Stdcall) BOOL;
pub const MONITORENUMPROC = ?fn (HMONITOR, HDC, LPRECT, LPARAM) callconv(.C) BOOL;
pub extern "user32" fn EnumDisplayMonitors(hdc: HDC, lprcClip: LPCRECT, lpfnEnum: MONITORENUMPROC, dwData: LPARAM) callconv(.Stdcall) BOOL;
pub extern "user32" fn NotifyWinEvent(event: DWORD, hwnd: HWND, idObject: LONG, idChild: LONG) callconv(.Stdcall) void;
pub const WINEVENTPROC = ?fn (HWINEVENTHOOK, DWORD, HWND, LONG, LONG, DWORD, DWORD) callconv(.C) void;
pub extern "user32" fn SetWinEventHook(eventMin: DWORD, eventMax: DWORD, hmodWinEventProc: HMODULE, pfnWinEventProc: WINEVENTPROC, idProcess: DWORD, idThread: DWORD, dwFlags: DWORD) callconv(.Stdcall) HWINEVENTHOOK;
pub extern "user32" fn IsWinEventHookInstalled(event: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn UnhookWinEvent(hWinEventHook: HWINEVENTHOOK) callconv(.Stdcall) BOOL;
pub const struct_tagGUITHREADINFO = extern struct {
    cbSize: DWORD,
    flags: DWORD,
    hwndActive: HWND,
    hwndFocus: HWND,
    hwndCapture: HWND,
    hwndMenuOwner: HWND,
    hwndMoveSize: HWND,
    hwndCaret: HWND,
    rcCaret: RECT,
};
pub const GUITHREADINFO = struct_tagGUITHREADINFO;
pub const PGUITHREADINFO = [*c]struct_tagGUITHREADINFO;
pub const LPGUITHREADINFO = [*c]struct_tagGUITHREADINFO;
pub extern "user32" fn GetGUIThreadInfo(idThread: DWORD, pgui: PGUITHREADINFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn BlockInput(fBlockIt: BOOL) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetProcessDPIAware() callconv(.Stdcall) BOOL;
pub extern "user32" fn IsProcessDPIAware() callconv(.Stdcall) BOOL;
pub extern "user32" fn SetThreadDpiAwarenessContext(dpiContext: DPI_AWARENESS_CONTEXT) callconv(.Stdcall) DPI_AWARENESS_CONTEXT;
pub extern "user32" fn GetThreadDpiAwarenessContext() callconv(.Stdcall) DPI_AWARENESS_CONTEXT;
pub extern "user32" fn GetWindowDpiAwarenessContext(hwnd: HWND) callconv(.Stdcall) DPI_AWARENESS_CONTEXT;
pub extern "user32" fn GetAwarenessFromDpiAwarenessContext(value: DPI_AWARENESS_CONTEXT) callconv(.Stdcall) DPI_AWARENESS;
pub extern "user32" fn GetDpiFromDpiAwarenessContext(value: DPI_AWARENESS_CONTEXT) callconv(.Stdcall) UINT;
pub extern "user32" fn AreDpiAwarenessContextsEqual(dpiContextA: DPI_AWARENESS_CONTEXT, dpiContextB: DPI_AWARENESS_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "user32" fn IsValidDpiAwarenessContext(value: DPI_AWARENESS_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetDpiForWindow(hwnd: HWND) callconv(.Stdcall) UINT;
pub extern "user32" fn GetDpiForSystem() callconv(.Stdcall) UINT;
pub extern "user32" fn GetSystemDpiForProcess(hProcess: HANDLE) callconv(.Stdcall) UINT;
pub extern "user32" fn EnableNonClientDpiScaling(hwnd: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn InheritWindowMonitor(hwnd: HWND, hwndInherit: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn SetProcessDpiAwarenessContext(value: DPI_AWARENESS_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetDpiAwarenessContextForProcess(hProcess: HANDLE) callconv(.Stdcall) DPI_AWARENESS_CONTEXT;
pub extern "user32" fn SetThreadDpiHostingBehavior(value: DPI_HOSTING_BEHAVIOR) callconv(.Stdcall) DPI_HOSTING_BEHAVIOR;
pub extern "user32" fn GetThreadDpiHostingBehavior() callconv(.Stdcall) DPI_HOSTING_BEHAVIOR;
pub extern "user32" fn GetWindowDpiHostingBehavior(hwnd: HWND) callconv(.Stdcall) DPI_HOSTING_BEHAVIOR;
pub extern "user32" fn GetWindowModuleFileNameA(hwnd: HWND, pszFileName: LPSTR, cchFileNameMax: UINT) callconv(.Stdcall) UINT;
pub extern "user32" fn GetWindowModuleFileNameW(hwnd: HWND, pszFileName: LPWSTR, cchFileNameMax: UINT) callconv(.Stdcall) UINT;
pub const struct_tagCURSORINFO = extern struct {
    cbSize: DWORD,
    flags: DWORD,
    hCursor: HCURSOR,
    ptScreenPos: POINT,
};
pub const CURSORINFO = struct_tagCURSORINFO;
pub const PCURSORINFO = [*c]struct_tagCURSORINFO;
pub const LPCURSORINFO = [*c]struct_tagCURSORINFO;
pub extern "user32" fn GetCursorInfo(pci: PCURSORINFO) callconv(.Stdcall) BOOL;
pub const struct_tagWINDOWINFO = extern struct {
    cbSize: DWORD,
    rcWindow: RECT,
    rcClient: RECT,
    dwStyle: DWORD,
    dwExStyle: DWORD,
    dwWindowStatus: DWORD,
    cxWindowBorders: UINT,
    cyWindowBorders: UINT,
    atomWindowType: ATOM,
    wCreatorVersion: WORD,
};
pub const WINDOWINFO = struct_tagWINDOWINFO;
pub const PWINDOWINFO = [*c]struct_tagWINDOWINFO;
pub const LPWINDOWINFO = [*c]struct_tagWINDOWINFO;
pub extern "user32" fn GetWindowInfo(hwnd: HWND, pwi: PWINDOWINFO) callconv(.Stdcall) BOOL;
pub const struct_tagTITLEBARINFO = extern struct {
    cbSize: DWORD,
    rcTitleBar: RECT,
    rgstate: [6]DWORD,
};
pub const TITLEBARINFO = struct_tagTITLEBARINFO;
pub const PTITLEBARINFO = [*c]struct_tagTITLEBARINFO;
pub const LPTITLEBARINFO = [*c]struct_tagTITLEBARINFO;
pub extern "user32" fn GetTitleBarInfo(hwnd: HWND, pti: PTITLEBARINFO) callconv(.Stdcall) BOOL;
pub const struct_tagTITLEBARINFOEX = extern struct {
    cbSize: DWORD,
    rcTitleBar: RECT,
    rgstate: [6]DWORD,
    rgrect: [6]RECT,
};
pub const TITLEBARINFOEX = struct_tagTITLEBARINFOEX;
pub const PTITLEBARINFOEX = [*c]struct_tagTITLEBARINFOEX;
pub const LPTITLEBARINFOEX = [*c]struct_tagTITLEBARINFOEX;
pub const struct_tagMENUBARINFO = @OpaqueType();
pub const MENUBARINFO = struct_tagMENUBARINFO;
pub const PMENUBARINFO = ?*struct_tagMENUBARINFO;
pub const LPMENUBARINFO = ?*struct_tagMENUBARINFO;
pub extern "user32" fn GetMenuBarInfo(hwnd: HWND, idObject: LONG, idItem: LONG, pmbi: PMENUBARINFO) callconv(.Stdcall) BOOL;
pub const struct_tagSCROLLBARINFO = extern struct {
    cbSize: DWORD,
    rcScrollBar: RECT,
    dxyLineButton: c_int,
    xyThumbTop: c_int,
    xyThumbBottom: c_int,
    reserved: c_int,
    rgstate: [6]DWORD,
};
pub const SCROLLBARINFO = struct_tagSCROLLBARINFO;
pub const PSCROLLBARINFO = [*c]struct_tagSCROLLBARINFO;
pub const LPSCROLLBARINFO = [*c]struct_tagSCROLLBARINFO;
pub extern "user32" fn GetScrollBarInfo(hwnd: HWND, idObject: LONG, psbi: PSCROLLBARINFO) callconv(.Stdcall) BOOL;
pub const struct_tagCOMBOBOXINFO = extern struct {
    cbSize: DWORD,
    rcItem: RECT,
    rcButton: RECT,
    stateButton: DWORD,
    hwndCombo: HWND,
    hwndItem: HWND,
    hwndList: HWND,
};
pub const COMBOBOXINFO = struct_tagCOMBOBOXINFO;
pub const PCOMBOBOXINFO = [*c]struct_tagCOMBOBOXINFO;
pub const LPCOMBOBOXINFO = [*c]struct_tagCOMBOBOXINFO;
pub extern "user32" fn GetComboBoxInfo(hwndCombo: HWND, pcbi: PCOMBOBOXINFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetAncestor(hwnd: HWND, gaFlags: UINT) callconv(.Stdcall) HWND;
pub extern "user32" fn RealChildWindowFromPoint(hwndParent: HWND, ptParentClientCoords: POINT) callconv(.Stdcall) HWND;
pub extern "user32" fn RealGetWindowClassA(hwnd: HWND, ptszClassName: LPSTR, cchClassNameMax: UINT) callconv(.Stdcall) UINT;
pub extern "user32" fn RealGetWindowClassW(hwnd: HWND, ptszClassName: LPWSTR, cchClassNameMax: UINT) callconv(.Stdcall) UINT;
pub const struct_tagALTTABINFO = extern struct {
    cbSize: DWORD,
    cItems: c_int,
    cColumns: c_int,
    cRows: c_int,
    iColFocus: c_int,
    iRowFocus: c_int,
    cxItem: c_int,
    cyItem: c_int,
    ptStart: POINT,
};
pub const ALTTABINFO = struct_tagALTTABINFO;
pub const PALTTABINFO = [*c]struct_tagALTTABINFO;
pub const LPALTTABINFO = [*c]struct_tagALTTABINFO;
pub extern "user32" fn GetAltTabInfoA(hwnd: HWND, iItem: c_int, pati: PALTTABINFO, pszItemText: LPSTR, cchItemText: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetAltTabInfoW(hwnd: HWND, iItem: c_int, pati: PALTTABINFO, pszItemText: LPWSTR, cchItemText: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetListBoxInfo(hwnd: HWND) callconv(.Stdcall) DWORD;
pub extern "user32" fn LockWorkStation() callconv(.Stdcall) BOOL;
pub extern "user32" fn UserHandleGrantAccess(hUserHandle: HANDLE, hJob: HANDLE, bGrant: BOOL) callconv(.Stdcall) BOOL;
pub const struct_HRAWINPUT__ = extern struct {
    unused: c_int,
};
pub const HRAWINPUT = [*c]struct_HRAWINPUT__;
pub const struct_tagRAWINPUTHEADER = extern struct {
    dwType: DWORD,
    dwSize: DWORD,
    hDevice: HANDLE,
    wParam: WPARAM,
};
pub const RAWINPUTHEADER = struct_tagRAWINPUTHEADER;
pub const PRAWINPUTHEADER = [*c]struct_tagRAWINPUTHEADER;
pub const LPRAWINPUTHEADER = [*c]struct_tagRAWINPUTHEADER;
pub const struct_tagRAWMOUSE = extern struct {
    usFlags: USHORT,
    @"": extern union {
        ulButtons: ULONG,
        @"": extern struct {
            usButtonFlags: USHORT,
            usButtonData: USHORT,
        },
    },
    ulRawButtons: ULONG,
    lLastX: LONG,
    lLastY: LONG,
    ulExtraInformation: ULONG,
};
pub const RAWMOUSE = struct_tagRAWMOUSE;
pub const PRAWMOUSE = [*c]struct_tagRAWMOUSE;
pub const LPRAWMOUSE = [*c]struct_tagRAWMOUSE;
pub const struct_tagRAWKEYBOARD = extern struct {
    MakeCode: USHORT,
    Flags: USHORT,
    Reserved: USHORT,
    VKey: USHORT,
    Message: UINT,
    ExtraInformation: ULONG,
};
pub const RAWKEYBOARD = struct_tagRAWKEYBOARD;
pub const PRAWKEYBOARD = [*c]struct_tagRAWKEYBOARD;
pub const LPRAWKEYBOARD = [*c]struct_tagRAWKEYBOARD;
pub const struct_tagRAWHID = extern struct {
    dwSizeHid: DWORD,
    dwCount: DWORD,
    bRawData: [1]BYTE,
};
pub const RAWHID = struct_tagRAWHID;
pub const PRAWHID = [*c]struct_tagRAWHID;
pub const LPRAWHID = [*c]struct_tagRAWHID;
pub const struct_tagRAWINPUT = extern struct {
    header: RAWINPUTHEADER,
    data: extern union {
        mouse: RAWMOUSE,
        keyboard: RAWKEYBOARD,
        hid: RAWHID,
    },
};
pub const RAWINPUT = struct_tagRAWINPUT;
pub const PRAWINPUT = [*c]struct_tagRAWINPUT;
pub const LPRAWINPUT = [*c]struct_tagRAWINPUT;
pub extern "user32" fn GetRawInputData(hRawInput: HRAWINPUT, uiCommand: UINT, pData: LPVOID, pcbSize: PUINT, cbSizeHeader: UINT) callconv(.Stdcall) UINT;
pub const struct_tagRID_DEVICE_INFO_MOUSE = extern struct {
    dwId: DWORD,
    dwNumberOfButtons: DWORD,
    dwSampleRate: DWORD,
    fHasHorizontalWheel: BOOL,
};
pub const RID_DEVICE_INFO_MOUSE = struct_tagRID_DEVICE_INFO_MOUSE;
pub const PRID_DEVICE_INFO_MOUSE = [*c]struct_tagRID_DEVICE_INFO_MOUSE;
pub const struct_tagRID_DEVICE_INFO_KEYBOARD = extern struct {
    dwType: DWORD,
    dwSubType: DWORD,
    dwKeyboardMode: DWORD,
    dwNumberOfFunctionKeys: DWORD,
    dwNumberOfIndicators: DWORD,
    dwNumberOfKeysTotal: DWORD,
};
pub const RID_DEVICE_INFO_KEYBOARD = struct_tagRID_DEVICE_INFO_KEYBOARD;
pub const PRID_DEVICE_INFO_KEYBOARD = [*c]struct_tagRID_DEVICE_INFO_KEYBOARD;
pub const struct_tagRID_DEVICE_INFO_HID = extern struct {
    dwVendorId: DWORD,
    dwProductId: DWORD,
    dwVersionNumber: DWORD,
    usUsagePage: USHORT,
    usUsage: USHORT,
};
pub const RID_DEVICE_INFO_HID = struct_tagRID_DEVICE_INFO_HID;
pub const PRID_DEVICE_INFO_HID = [*c]struct_tagRID_DEVICE_INFO_HID;
pub const struct_tagRID_DEVICE_INFO = extern struct {
    cbSize: DWORD,
    dwType: DWORD,
    @"": extern union {
        mouse: RID_DEVICE_INFO_MOUSE,
        keyboard: RID_DEVICE_INFO_KEYBOARD,
        hid: RID_DEVICE_INFO_HID,
    },
};
pub const RID_DEVICE_INFO = struct_tagRID_DEVICE_INFO;
pub const PRID_DEVICE_INFO = [*c]struct_tagRID_DEVICE_INFO;
pub const LPRID_DEVICE_INFO = [*c]struct_tagRID_DEVICE_INFO;
pub extern "user32" fn GetRawInputDeviceInfoA(hDevice: HANDLE, uiCommand: UINT, pData: LPVOID, pcbSize: PUINT) callconv(.Stdcall) UINT;
pub extern "user32" fn GetRawInputDeviceInfoW(hDevice: HANDLE, uiCommand: UINT, pData: LPVOID, pcbSize: PUINT) callconv(.Stdcall) UINT;
pub extern "user32" fn GetRawInputBuffer(pData: PRAWINPUT, pcbSize: PUINT, cbSizeHeader: UINT) callconv(.Stdcall) UINT;
pub const struct_tagRAWINPUTDEVICE = extern struct {
    usUsagePage: USHORT,
    usUsage: USHORT,
    dwFlags: DWORD,
    hwndTarget: HWND,
};
pub const RAWINPUTDEVICE = struct_tagRAWINPUTDEVICE;
pub const PRAWINPUTDEVICE = [*c]struct_tagRAWINPUTDEVICE;
pub const LPRAWINPUTDEVICE = [*c]struct_tagRAWINPUTDEVICE;
pub const PCRAWINPUTDEVICE = [*c]const RAWINPUTDEVICE;
pub extern "user32" fn RegisterRawInputDevices(pRawInputDevices: PCRAWINPUTDEVICE, uiNumDevices: UINT, cbSize: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetRegisteredRawInputDevices(pRawInputDevices: PRAWINPUTDEVICE, puiNumDevices: PUINT, cbSize: UINT) callconv(.Stdcall) UINT;
pub const struct_tagRAWINPUTDEVICELIST = extern struct {
    hDevice: HANDLE,
    dwType: DWORD,
};
pub const RAWINPUTDEVICELIST = struct_tagRAWINPUTDEVICELIST;
pub const PRAWINPUTDEVICELIST = [*c]struct_tagRAWINPUTDEVICELIST;
pub extern "user32" fn GetRawInputDeviceList(pRawInputDeviceList: PRAWINPUTDEVICELIST, puiNumDevices: PUINT, cbSize: UINT) callconv(.Stdcall) UINT;
pub extern "user32" fn DefRawInputProc(paRawInput: [*c]PRAWINPUT, nInput: INT, cbSizeHeader: UINT) callconv(.Stdcall) LRESULT;
pub const POINTER_DEVICE_TYPE_INTEGRATED_PEN = enum_tagPOINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_INTEGRATED_PEN;
pub const POINTER_DEVICE_TYPE_EXTERNAL_PEN = enum_tagPOINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_EXTERNAL_PEN;
pub const POINTER_DEVICE_TYPE_TOUCH = enum_tagPOINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_TOUCH;
pub const POINTER_DEVICE_TYPE_TOUCH_PAD = enum_tagPOINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_TOUCH_PAD;
pub const POINTER_DEVICE_TYPE_MAX = enum_tagPOINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_MAX;
pub const enum_tagPOINTER_DEVICE_TYPE = extern enum {
    POINTER_DEVICE_TYPE_INTEGRATED_PEN = 1,
    POINTER_DEVICE_TYPE_EXTERNAL_PEN = 2,
    POINTER_DEVICE_TYPE_TOUCH = 3,
    POINTER_DEVICE_TYPE_TOUCH_PAD = 4,
    POINTER_DEVICE_TYPE_MAX = -1,
};
pub const POINTER_DEVICE_TYPE = enum_tagPOINTER_DEVICE_TYPE;
pub const struct_tagPOINTER_DEVICE_INFO = extern struct {
    displayOrientation: DWORD,
    device: HANDLE,
    pointerDeviceType: POINTER_DEVICE_TYPE,
    monitor: HMONITOR,
    startingCursorId: ULONG,
    maxActiveContacts: USHORT,
    productString: [520]WCHAR,
};
pub const POINTER_DEVICE_INFO = struct_tagPOINTER_DEVICE_INFO;
pub const struct_tagPOINTER_DEVICE_PROPERTY = extern struct {
    logicalMin: INT32,
    logicalMax: INT32,
    physicalMin: INT32,
    physicalMax: INT32,
    unit: UINT32,
    unitExponent: UINT32,
    usagePageId: USHORT,
    usageId: USHORT,
};
pub const POINTER_DEVICE_PROPERTY = struct_tagPOINTER_DEVICE_PROPERTY;
pub const POINTER_DEVICE_CURSOR_TYPE_UNKNOWN = enum_tagPOINTER_DEVICE_CURSOR_TYPE.POINTER_DEVICE_CURSOR_TYPE_UNKNOWN;
pub const POINTER_DEVICE_CURSOR_TYPE_TIP = enum_tagPOINTER_DEVICE_CURSOR_TYPE.POINTER_DEVICE_CURSOR_TYPE_TIP;
pub const POINTER_DEVICE_CURSOR_TYPE_ERASER = enum_tagPOINTER_DEVICE_CURSOR_TYPE.POINTER_DEVICE_CURSOR_TYPE_ERASER;
pub const POINTER_DEVICE_CURSOR_TYPE_MAX = enum_tagPOINTER_DEVICE_CURSOR_TYPE.POINTER_DEVICE_CURSOR_TYPE_MAX;
pub const enum_tagPOINTER_DEVICE_CURSOR_TYPE = extern enum {
    POINTER_DEVICE_CURSOR_TYPE_UNKNOWN = 0,
    POINTER_DEVICE_CURSOR_TYPE_TIP = 1,
    POINTER_DEVICE_CURSOR_TYPE_ERASER = 2,
    POINTER_DEVICE_CURSOR_TYPE_MAX = -1,
};
pub const POINTER_DEVICE_CURSOR_TYPE = enum_tagPOINTER_DEVICE_CURSOR_TYPE;
pub const struct_tagPOINTER_DEVICE_CURSOR_INFO = extern struct {
    cursorId: UINT32,
    cursor: POINTER_DEVICE_CURSOR_TYPE,
};
pub const POINTER_DEVICE_CURSOR_INFO = struct_tagPOINTER_DEVICE_CURSOR_INFO;
pub extern "user32" fn GetPointerDevices(deviceCount: [*c]UINT32, pointerDevices: [*c]POINTER_DEVICE_INFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPointerDevice(device: HANDLE, pointerDevice: [*c]POINTER_DEVICE_INFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPointerDeviceProperties(device: HANDLE, propertyCount: [*c]UINT32, pointerProperties: [*c]POINTER_DEVICE_PROPERTY) callconv(.Stdcall) BOOL;
pub extern "user32" fn RegisterPointerDeviceNotifications(window: HWND, notifyRange: BOOL) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPointerDeviceRects(device: HANDLE, pointerDeviceRect: [*c]RECT, displayRect: [*c]RECT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetPointerDeviceCursors(device: HANDLE, cursorCount: [*c]UINT32, deviceCursors: [*c]POINTER_DEVICE_CURSOR_INFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetRawPointerDeviceData(pointerId: UINT32, historyCount: UINT32, propertiesCount: UINT32, pProperties: [*c]POINTER_DEVICE_PROPERTY, pValues: [*c]LONG) callconv(.Stdcall) BOOL;
pub extern "user32" fn ChangeWindowMessageFilter(message: UINT, dwFlag: DWORD) callconv(.Stdcall) BOOL;
pub const struct_tagCHANGEFILTERSTRUCT = extern struct {
    cbSize: DWORD,
    ExtStatus: DWORD,
};
pub const CHANGEFILTERSTRUCT = struct_tagCHANGEFILTERSTRUCT;
pub const PCHANGEFILTERSTRUCT = [*c]struct_tagCHANGEFILTERSTRUCT;
pub extern "user32" fn ChangeWindowMessageFilterEx(hwnd: HWND, message: UINT, action: DWORD, pChangeFilterStruct: PCHANGEFILTERSTRUCT) callconv(.Stdcall) BOOL;
pub const struct_HGESTUREINFO__ = extern struct {
    unused: c_int,
};
pub const HGESTUREINFO = [*c]struct_HGESTUREINFO__;
pub const struct_tagGESTUREINFO = extern struct {
    cbSize: UINT,
    dwFlags: DWORD,
    dwID: DWORD,
    hwndTarget: HWND,
    ptsLocation: POINTS,
    dwInstanceID: DWORD,
    dwSequenceID: DWORD,
    ullArguments: ULONGLONG,
    cbExtraArgs: UINT,
};
pub const GESTUREINFO = struct_tagGESTUREINFO;
pub const PGESTUREINFO = [*c]struct_tagGESTUREINFO;
pub const PCGESTUREINFO = [*c]const GESTUREINFO;
pub const struct_tagGESTURENOTIFYSTRUCT = extern struct {
    cbSize: UINT,
    dwFlags: DWORD,
    hwndTarget: HWND,
    ptsLocation: POINTS,
    dwInstanceID: DWORD,
};
pub const GESTURENOTIFYSTRUCT = struct_tagGESTURENOTIFYSTRUCT;
pub const PGESTURENOTIFYSTRUCT = [*c]struct_tagGESTURENOTIFYSTRUCT;
pub extern "user32" fn GetGestureInfo(hGestureInfo: HGESTUREINFO, pGestureInfo: PGESTUREINFO) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetGestureExtraArgs(hGestureInfo: HGESTUREINFO, cbExtraArgs: UINT, pExtraArgs: PBYTE) callconv(.Stdcall) BOOL;
pub extern "user32" fn CloseGestureInfoHandle(hGestureInfo: HGESTUREINFO) callconv(.Stdcall) BOOL;
pub const struct_tagGESTURECONFIG = extern struct {
    dwID: DWORD,
    dwWant: DWORD,
    dwBlock: DWORD,
};
pub const GESTURECONFIG = struct_tagGESTURECONFIG;
pub const PGESTURECONFIG = [*c]struct_tagGESTURECONFIG;
pub extern "user32" fn SetGestureConfig(hwnd: HWND, dwReserved: DWORD, cIDs: UINT, pGestureConfig: PGESTURECONFIG, cbSize: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetGestureConfig(hwnd: HWND, dwReserved: DWORD, dwFlags: DWORD, pcIDs: PUINT, pGestureConfig: PGESTURECONFIG, cbSize: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn ShutdownBlockReasonCreate(hWnd: HWND, pwszReason: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn ShutdownBlockReasonQuery(hWnd: HWND, pwszBuff: LPWSTR, pcchBuff: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn ShutdownBlockReasonDestroy(hWnd: HWND) callconv(.Stdcall) BOOL;
pub const IMDT_UNAVAILABLE = enum_tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_UNAVAILABLE;
pub const IMDT_KEYBOARD = enum_tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_KEYBOARD;
pub const IMDT_MOUSE = enum_tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_MOUSE;
pub const IMDT_TOUCH = enum_tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_TOUCH;
pub const IMDT_PEN = enum_tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_PEN;
pub const IMDT_TOUCHPAD = enum_tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_TOUCHPAD;
pub const enum_tagINPUT_MESSAGE_DEVICE_TYPE = extern enum {
    IMDT_UNAVAILABLE = 0,
    IMDT_KEYBOARD = 1,
    IMDT_MOUSE = 2,
    IMDT_TOUCH = 4,
    IMDT_PEN = 8,
    IMDT_TOUCHPAD = 16,
};
pub const INPUT_MESSAGE_DEVICE_TYPE = enum_tagINPUT_MESSAGE_DEVICE_TYPE;
pub const IMO_UNAVAILABLE = enum_tagINPUT_MESSAGE_ORIGIN_ID.IMO_UNAVAILABLE;
pub const IMO_HARDWARE = enum_tagINPUT_MESSAGE_ORIGIN_ID.IMO_HARDWARE;
pub const IMO_INJECTED = enum_tagINPUT_MESSAGE_ORIGIN_ID.IMO_INJECTED;
pub const IMO_SYSTEM = enum_tagINPUT_MESSAGE_ORIGIN_ID.IMO_SYSTEM;
pub const enum_tagINPUT_MESSAGE_ORIGIN_ID = extern enum {
    IMO_UNAVAILABLE = 0,
    IMO_HARDWARE = 1,
    IMO_INJECTED = 2,
    IMO_SYSTEM = 4,
};
pub const INPUT_MESSAGE_ORIGIN_ID = enum_tagINPUT_MESSAGE_ORIGIN_ID;
pub const struct_tagINPUT_MESSAGE_SOURCE = extern struct {
    deviceType: INPUT_MESSAGE_DEVICE_TYPE,
    originId: INPUT_MESSAGE_ORIGIN_ID,
};
pub const INPUT_MESSAGE_SOURCE = struct_tagINPUT_MESSAGE_SOURCE;
pub extern "user32" fn GetCurrentInputMessageSource(inputMessageSource: [*c]INPUT_MESSAGE_SOURCE) callconv(.Stdcall) BOOL;
pub extern "user32" fn GetCIMSSM(inputMessageSource: [*c]INPUT_MESSAGE_SOURCE) callconv(.Stdcall) BOOL;
pub const AR_ENABLED = enum_tagAR_STATE.AR_ENABLED;
pub const AR_DISABLED = enum_tagAR_STATE.AR_DISABLED;
pub const AR_SUPPRESSED = enum_tagAR_STATE.AR_SUPPRESSED;
pub const AR_REMOTESESSION = enum_tagAR_STATE.AR_REMOTESESSION;
pub const AR_MULTIMON = enum_tagAR_STATE.AR_MULTIMON;
pub const AR_NOSENSOR = enum_tagAR_STATE.AR_NOSENSOR;
pub const AR_NOT_SUPPORTED = enum_tagAR_STATE.AR_NOT_SUPPORTED;
pub const AR_DOCKED = enum_tagAR_STATE.AR_DOCKED;
pub const AR_LAPTOP = enum_tagAR_STATE.AR_LAPTOP;
pub const enum_tagAR_STATE = extern enum {
    AR_ENABLED = 0,
    AR_DISABLED = 1,
    AR_SUPPRESSED = 2,
    AR_REMOTESESSION = 4,
    AR_MULTIMON = 8,
    AR_NOSENSOR = 16,
    AR_NOT_SUPPORTED = 32,
    AR_DOCKED = 64,
    AR_LAPTOP = 128,
};
pub const AR_STATE = enum_tagAR_STATE;
pub const PAR_STATE = [*c]enum_tagAR_STATE;
pub const ORIENTATION_PREFERENCE_NONE = enum_ORIENTATION_PREFERENCE._NONE;
pub const ORIENTATION_PREFERENCE_LANDSCAPE = enum_ORIENTATION_PREFERENCE._LANDSCAPE;
pub const ORIENTATION_PREFERENCE_PORTRAIT = enum_ORIENTATION_PREFERENCE._PORTRAIT;
pub const ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED = enum_ORIENTATION_PREFERENCE._LANDSCAPE_FLIPPED;
pub const ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED = enum_ORIENTATION_PREFERENCE._PORTRAIT_FLIPPED;
pub const enum_ORIENTATION_PREFERENCE = extern enum {
    _NONE = 0,
    _LANDSCAPE = 1,
    _PORTRAIT = 2,
    _LANDSCAPE_FLIPPED = 4,
    _PORTRAIT_FLIPPED = 8,
};
pub const ORIENTATION_PREFERENCE = enum_ORIENTATION_PREFERENCE;
pub extern "kernel32" fn GetAutoRotationState(pState: PAR_STATE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetDisplayAutoRotationPreferences(pOrientation: [*c]ORIENTATION_PREFERENCE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetDisplayAutoRotationPreferencesByProcessId(dwProcessId: DWORD, pOrientation: [*c]ORIENTATION_PREFERENCE, fRotateScreen: [*c]BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetDisplayAutoRotationPreferences(orientation: ORIENTATION_PREFERENCE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsImmersiveProcess(hProcess: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetProcessRestrictionExemption(fEnableExemption: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetDateFormatA(Locale: LCID, dwFlags: DWORD, lpDate: [*c]const SYSTEMTIME, lpFormat: LPCSTR, lpDateStr: LPSTR, cchDate: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetDateFormatW(Locale: LCID, dwFlags: DWORD, lpDate: [*c]const SYSTEMTIME, lpFormat: LPCWSTR, lpDateStr: LPWSTR, cchDate: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetTimeFormatA(Locale: LCID, dwFlags: DWORD, lpTime: [*c]const SYSTEMTIME, lpFormat: LPCSTR, lpTimeStr: LPSTR, cchTime: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetTimeFormatW(Locale: LCID, dwFlags: DWORD, lpTime: [*c]const SYSTEMTIME, lpFormat: LPCWSTR, lpTimeStr: LPWSTR, cchTime: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetTimeFormatEx(lpLocaleName: LPCWSTR, dwFlags: DWORD, lpTime: [*c]const SYSTEMTIME, lpFormat: LPCWSTR, lpTimeStr: LPWSTR, cchTime: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetDateFormatEx(lpLocaleName: LPCWSTR, dwFlags: DWORD, lpDate: [*c]const SYSTEMTIME, lpFormat: LPCWSTR, lpDateStr: LPWSTR, cchDate: c_int, lpCalendar: LPCWSTR) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetDurationFormatEx(lpLocaleName: LPCWSTR, dwFlags: DWORD, lpDuration: [*c]const SYSTEMTIME, ullDuration: ULONGLONG, lpFormat: LPCWSTR, lpDurationStr: LPWSTR, cchDuration: c_int) callconv(.Stdcall) c_int;
pub const LGRPID = DWORD;
pub const LCTYPE = DWORD;
pub const CALTYPE = DWORD;
pub const CALID = DWORD;
pub const struct__cpinfo = extern struct {
    MaxCharSize: UINT,
    DefaultChar: [2]BYTE,
    LeadByte: [12]BYTE,
};
pub const CPINFO = struct__cpinfo;
pub const LPCPINFO = [*c]struct__cpinfo;
pub const GEOTYPE = DWORD;
pub const GEOCLASS = DWORD;
pub const GEOID = LONG;
pub const struct__cpinfoexA = extern struct {
    MaxCharSize: UINT,
    DefaultChar: [2]BYTE,
    LeadByte: [12]BYTE,
    UnicodeDefaultChar: WCHAR,
    CodePage: UINT,
    CodePageName: [260]CHAR,
};
pub const CPINFOEXA = struct__cpinfoexA;
pub const LPCPINFOEXA = [*c]struct__cpinfoexA;
pub const struct__cpinfoexW = extern struct {
    MaxCharSize: UINT,
    DefaultChar: [2]BYTE,
    LeadByte: [12]BYTE,
    UnicodeDefaultChar: WCHAR,
    CodePage: UINT,
    CodePageName: [260]WCHAR,
};
pub const CPINFOEXW = struct__cpinfoexW;
pub const LPCPINFOEXW = [*c]struct__cpinfoexW;
pub const CPINFOEX = CPINFOEXA;
pub const LPCPINFOEX = LPCPINFOEXA;
pub const struct__numberfmtA = extern struct {
    NumDigits: UINT,
    LeadingZero: UINT,
    Grouping: UINT,
    lpDecimalSep: LPSTR,
    lpThousandSep: LPSTR,
    NegativeOrder: UINT,
};
pub const NUMBERFMTA = struct__numberfmtA;
pub const LPNUMBERFMTA = [*c]struct__numberfmtA;
pub const struct__numberfmtW = extern struct {
    NumDigits: UINT,
    LeadingZero: UINT,
    Grouping: UINT,
    lpDecimalSep: LPWSTR,
    lpThousandSep: LPWSTR,
    NegativeOrder: UINT,
};
pub const NUMBERFMTW = struct__numberfmtW;
pub const LPNUMBERFMTW = [*c]struct__numberfmtW;
pub const NUMBERFMT = NUMBERFMTA;
pub const LPNUMBERFMT = LPNUMBERFMTA;
pub const struct__currencyfmtA = extern struct {
    NumDigits: UINT,
    LeadingZero: UINT,
    Grouping: UINT,
    lpDecimalSep: LPSTR,
    lpThousandSep: LPSTR,
    NegativeOrder: UINT,
    PositiveOrder: UINT,
    lpCurrencySymbol: LPSTR,
};
pub const CURRENCYFMTA = struct__currencyfmtA;
pub const LPCURRENCYFMTA = [*c]struct__currencyfmtA;
pub const struct__currencyfmtW = extern struct {
    NumDigits: UINT,
    LeadingZero: UINT,
    Grouping: UINT,
    lpDecimalSep: LPWSTR,
    lpThousandSep: LPWSTR,
    NegativeOrder: UINT,
    PositiveOrder: UINT,
    lpCurrencySymbol: LPWSTR,
};
pub const CURRENCYFMTW = struct__currencyfmtW;
pub const LPCURRENCYFMTW = [*c]struct__currencyfmtW;
pub const CURRENCYFMT = CURRENCYFMTA;
pub const LPCURRENCYFMT = LPCURRENCYFMTA;
pub const COMPARE_STRING = enum_SYSNLS_FUNCTION.COMPARE_STRING;
pub const enum_SYSNLS_FUNCTION = extern enum {
    COMPARE_STRING = 1,
};
pub const NLS_FUNCTION = DWORD;
pub const struct__nlsversioninfo = extern struct {
    dwNLSVersionInfoSize: DWORD,
    dwNLSVersion: DWORD,
    dwDefinedVersion: DWORD,
    dwEffectiveId: DWORD,
    guidCustomVersion: GUID,
};
pub const NLSVERSIONINFO = struct__nlsversioninfo;
pub const LPNLSVERSIONINFO = [*c]struct__nlsversioninfo;
pub const struct__nlsversioninfoex = extern struct {
    dwNLSVersionInfoSize: DWORD,
    dwNLSVersion: DWORD,
    dwDefinedVersion: DWORD,
    dwEffectiveId: DWORD,
    guidCustomVersion: GUID,
};
pub const NLSVERSIONINFOEX = struct__nlsversioninfoex;
pub const LPNLSVERSIONINFOEX = [*c]struct__nlsversioninfoex;
pub const GEO_NATION = enum_SYSGEOTYPE.GEO_NATION;
pub const GEO_LATITUDE = enum_SYSGEOTYPE.GEO_LATITUDE;
pub const GEO_LONGITUDE = enum_SYSGEOTYPE.GEO_LONGITUDE;
pub const GEO_ISO2 = enum_SYSGEOTYPE.GEO_ISO2;
pub const GEO_ISO3 = enum_SYSGEOTYPE.GEO_ISO3;
pub const GEO_RFC1766 = enum_SYSGEOTYPE.GEO_RFC1766;
pub const GEO_LCID = enum_SYSGEOTYPE.GEO_LCID;
pub const GEO_FRIENDLYNAME = enum_SYSGEOTYPE.GEO_FRIENDLYNAME;
pub const GEO_OFFICIALNAME = enum_SYSGEOTYPE.GEO_OFFICIALNAME;
pub const GEO_TIMEZONES = enum_SYSGEOTYPE.GEO_TIMEZONES;
pub const GEO_OFFICIALLANGUAGES = enum_SYSGEOTYPE.GEO_OFFICIALLANGUAGES;
pub const GEO_ISO_UN_NUMBER = enum_SYSGEOTYPE.GEO_ISO_UN_NUMBER;
pub const GEO_PARENT = enum_SYSGEOTYPE.GEO_PARENT;
pub const GEO_DIALINGCODE = enum_SYSGEOTYPE.GEO_DIALINGCODE;
pub const GEO_CURRENCYCODE = enum_SYSGEOTYPE.GEO_CURRENCYCODE;
pub const GEO_CURRENCYSYMBOL = enum_SYSGEOTYPE.GEO_CURRENCYSYMBOL;
pub const GEO_NAME = enum_SYSGEOTYPE.GEO_NAME;
pub const GEO_ID = enum_SYSGEOTYPE.GEO_ID;
pub const enum_SYSGEOTYPE = extern enum {
    GEO_NATION = 1,
    GEO_LATITUDE = 2,
    GEO_LONGITUDE = 3,
    GEO_ISO2 = 4,
    GEO_ISO3 = 5,
    GEO_RFC1766 = 6,
    GEO_LCID = 7,
    GEO_FRIENDLYNAME = 8,
    GEO_OFFICIALNAME = 9,
    GEO_TIMEZONES = 10,
    GEO_OFFICIALLANGUAGES = 11,
    GEO_ISO_UN_NUMBER = 12,
    GEO_PARENT = 13,
    GEO_DIALINGCODE = 14,
    GEO_CURRENCYCODE = 15,
    GEO_CURRENCYSYMBOL = 16,
    GEO_NAME = 17,
    GEO_ID = 18,
};
pub const GEOCLASS_NATION = enum_SYSGEOCLASS.GEOCLASS_NATION;
pub const GEOCLASS_REGION = enum_SYSGEOCLASS.GEOCLASS_REGION;
pub const GEOCLASS_ALL = enum_SYSGEOCLASS.GEOCLASS_ALL;
pub const enum_SYSGEOCLASS = extern enum {
    GEOCLASS_NATION = 16,
    GEOCLASS_REGION = 14,
    GEOCLASS_ALL = 0,
};
pub const NormalizationOther = enum__NORM_FORM.NormalizationOther;
pub const NormalizationC = enum__NORM_FORM.NormalizationC;
pub const NormalizationD = enum__NORM_FORM.NormalizationD;
pub const NormalizationKC = enum__NORM_FORM.NormalizationKC;
pub const NormalizationKD = enum__NORM_FORM.NormalizationKD;
pub const enum__NORM_FORM = extern enum {
    NormalizationOther = 0,
    NormalizationC = 1,
    NormalizationD = 2,
    NormalizationKC = 5,
    NormalizationKD = 6,
};
pub const NORM_FORM = enum__NORM_FORM;
pub const LANGUAGEGROUP_ENUMPROCA = ?fn (LGRPID, LPSTR, LPSTR, DWORD, LONG_PTR) callconv(.C) BOOL;
pub const LANGGROUPLOCALE_ENUMPROCA = ?fn (LGRPID, LCID, LPSTR, LONG_PTR) callconv(.C) BOOL;
pub const UILANGUAGE_ENUMPROCA = ?fn (LPSTR, LONG_PTR) callconv(.C) BOOL;
pub const CODEPAGE_ENUMPROCA = ?fn (LPSTR) callconv(.C) BOOL;
pub const DATEFMT_ENUMPROCA = ?fn (LPSTR) callconv(.C) BOOL;
pub const DATEFMT_ENUMPROCEXA = ?fn (LPSTR, CALID) callconv(.C) BOOL;
pub const TIMEFMT_ENUMPROCA = ?fn (LPSTR) callconv(.C) BOOL;
pub const CALINFO_ENUMPROCA = ?fn (LPSTR) callconv(.C) BOOL;
pub const CALINFO_ENUMPROCEXA = ?fn (LPSTR, CALID) callconv(.C) BOOL;
pub const LOCALE_ENUMPROCA = ?fn (LPSTR) callconv(.C) BOOL;
pub const LOCALE_ENUMPROCW = ?fn (LPWSTR) callconv(.C) BOOL;
pub const LANGUAGEGROUP_ENUMPROCW = ?fn (LGRPID, LPWSTR, LPWSTR, DWORD, LONG_PTR) callconv(.C) BOOL;
pub const LANGGROUPLOCALE_ENUMPROCW = ?fn (LGRPID, LCID, LPWSTR, LONG_PTR) callconv(.C) BOOL;
pub const UILANGUAGE_ENUMPROCW = ?fn (LPWSTR, LONG_PTR) callconv(.C) BOOL;
pub const CODEPAGE_ENUMPROCW = ?fn (LPWSTR) callconv(.C) BOOL;
pub const DATEFMT_ENUMPROCW = ?fn (LPWSTR) callconv(.C) BOOL;
pub const DATEFMT_ENUMPROCEXW = ?fn (LPWSTR, CALID) callconv(.C) BOOL;
pub const TIMEFMT_ENUMPROCW = ?fn (LPWSTR) callconv(.C) BOOL;
pub const CALINFO_ENUMPROCW = ?fn (LPWSTR) callconv(.C) BOOL;
pub const CALINFO_ENUMPROCEXW = ?fn (LPWSTR, CALID) callconv(.C) BOOL;
pub const GEO_ENUMPROC = ?fn (GEOID) callconv(.C) BOOL;
pub const GEO_ENUMNAMEPROC = ?fn (PWSTR, LPARAM) callconv(.C) BOOL;
pub const struct__FILEMUIINFO = extern struct {
    dwSize: DWORD,
    dwVersion: DWORD,
    dwFileType: DWORD,
    pChecksum: [16]BYTE,
    pServiceChecksum: [16]BYTE,
    dwLanguageNameOffset: DWORD,
    dwTypeIDMainSize: DWORD,
    dwTypeIDMainOffset: DWORD,
    dwTypeNameMainOffset: DWORD,
    dwTypeIDMUISize: DWORD,
    dwTypeIDMUIOffset: DWORD,
    dwTypeNameMUIOffset: DWORD,
    abBuffer: [8]BYTE,
};
pub const FILEMUIINFO = struct__FILEMUIINFO;
pub const PFILEMUIINFO = [*c]struct__FILEMUIINFO;
pub extern "kernel32" fn CompareStringEx(lpLocaleName: LPCWSTR, dwCmpFlags: DWORD, lpString1: LPCWCH, cchCount1: c_int, lpString2: LPCWCH, cchCount2: c_int, lpVersionInformation: LPNLSVERSIONINFO, lpReserved: LPVOID, lParam: LPARAM) callconv(.Stdcall) c_int;
pub extern "kernel32" fn CompareStringOrdinal(lpString1: LPCWCH, cchCount1: c_int, lpString2: LPCWCH, cchCount2: c_int, bIgnoreCase: BOOL) callconv(.Stdcall) c_int;
pub extern "kernel32" fn CompareStringW(Locale: LCID, dwCmpFlags: DWORD, lpString1: PCNZWCH, cchCount1: c_int, lpString2: PCNZWCH, cchCount2: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn FoldStringW(dwMapFlags: DWORD, lpSrcStr: LPCWCH, cchSrc: c_int, lpDestStr: LPWSTR, cchDest: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetStringTypeExW(Locale: LCID, dwInfoType: DWORD, lpSrcStr: LPCWCH, cchSrc: c_int, lpCharType: LPWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetStringTypeW(dwInfoType: DWORD, lpSrcStr: LPCWCH, cchSrc: c_int, lpCharType: LPWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn MultiByteToWideChar(CodePage: UINT, dwFlags: DWORD, lpMultiByteStr: LPCCH, cbMultiByte: c_int, lpWideCharStr: LPWSTR, cchWideChar: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn WideCharToMultiByte(CodePage: UINT, dwFlags: DWORD, lpWideCharStr: LPCWCH, cchWideChar: c_int, lpMultiByteStr: LPSTR, cbMultiByte: c_int, lpDefaultChar: LPCCH, lpUsedDefaultChar: LPBOOL) callconv(.Stdcall) c_int;
pub extern "kernel32" fn IsValidCodePage(CodePage: UINT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetACP() callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetOEMCP() callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetCPInfo(CodePage: UINT, lpCPInfo: LPCPINFO) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCPInfoExA(CodePage: UINT, dwFlags: DWORD, lpCPInfoEx: LPCPINFOEXA) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCPInfoExW(CodePage: UINT, dwFlags: DWORD, lpCPInfoEx: LPCPINFOEXW) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CompareStringA(Locale: LCID, dwCmpFlags: DWORD, lpString1: PCNZCH, cchCount1: c_int, lpString2: PCNZCH, cchCount2: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn FindNLSString(Locale: LCID, dwFindNLSStringFlags: DWORD, lpStringSource: LPCWSTR, cchSource: c_int, lpStringValue: LPCWSTR, cchValue: c_int, pcchFound: LPINT) callconv(.Stdcall) c_int;
pub extern "kernel32" fn LCMapStringW(Locale: LCID, dwMapFlags: DWORD, lpSrcStr: LPCWSTR, cchSrc: c_int, lpDestStr: LPWSTR, cchDest: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn LCMapStringA(Locale: LCID, dwMapFlags: DWORD, lpSrcStr: LPCSTR, cchSrc: c_int, lpDestStr: LPSTR, cchDest: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetLocaleInfoW(Locale: LCID, LCType: LCTYPE, lpLCData: LPWSTR, cchData: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetLocaleInfoA(Locale: LCID, LCType: LCTYPE, lpLCData: LPSTR, cchData: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn SetLocaleInfoA(Locale: LCID, LCType: LCTYPE, lpLCData: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetLocaleInfoW(Locale: LCID, LCType: LCTYPE, lpLCData: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetCalendarInfoA(Locale: LCID, Calendar: CALID, CalType: CALTYPE, lpCalData: LPSTR, cchData: c_int, lpValue: LPDWORD) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetCalendarInfoW(Locale: LCID, Calendar: CALID, CalType: CALTYPE, lpCalData: LPWSTR, cchData: c_int, lpValue: LPDWORD) callconv(.Stdcall) c_int;
pub extern "kernel32" fn SetCalendarInfoA(Locale: LCID, Calendar: CALID, CalType: CALTYPE, lpCalData: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetCalendarInfoW(Locale: LCID, Calendar: CALID, CalType: CALTYPE, lpCalData: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn LoadStringByReference(Flags: DWORD, Language: PCWSTR, SourceString: PCWSTR, Buffer: PWSTR, cchBuffer: ULONG, Directory: PCWSTR, pcchBufferOut: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsDBCSLeadByte(TestChar: BYTE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsDBCSLeadByteEx(CodePage: UINT, TestChar: BYTE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn LocaleNameToLCID(lpName: LPCWSTR, dwFlags: DWORD) callconv(.Stdcall) LCID;
pub extern "kernel32" fn LCIDToLocaleName(Locale: LCID, lpName: LPWSTR, cchName: c_int, dwFlags: DWORD) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetDurationFormat(Locale: LCID, dwFlags: DWORD, lpDuration: [*c]const SYSTEMTIME, ullDuration: ULONGLONG, lpFormat: LPCWSTR, lpDurationStr: LPWSTR, cchDuration: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetNumberFormatA(Locale: LCID, dwFlags: DWORD, lpValue: LPCSTR, lpFormat: [*c]const NUMBERFMTA, lpNumberStr: LPSTR, cchNumber: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetNumberFormatW(Locale: LCID, dwFlags: DWORD, lpValue: LPCWSTR, lpFormat: [*c]const NUMBERFMTW, lpNumberStr: LPWSTR, cchNumber: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetCurrencyFormatA(Locale: LCID, dwFlags: DWORD, lpValue: LPCSTR, lpFormat: [*c]const CURRENCYFMTA, lpCurrencyStr: LPSTR, cchCurrency: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetCurrencyFormatW(Locale: LCID, dwFlags: DWORD, lpValue: LPCWSTR, lpFormat: [*c]const CURRENCYFMTW, lpCurrencyStr: LPWSTR, cchCurrency: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn EnumCalendarInfoA(lpCalInfoEnumProc: CALINFO_ENUMPROCA, Locale: LCID, Calendar: CALID, CalType: CALTYPE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumCalendarInfoW(lpCalInfoEnumProc: CALINFO_ENUMPROCW, Locale: LCID, Calendar: CALID, CalType: CALTYPE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumCalendarInfoExA(lpCalInfoEnumProcEx: CALINFO_ENUMPROCEXA, Locale: LCID, Calendar: CALID, CalType: CALTYPE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumCalendarInfoExW(lpCalInfoEnumProcEx: CALINFO_ENUMPROCEXW, Locale: LCID, Calendar: CALID, CalType: CALTYPE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumTimeFormatsA(lpTimeFmtEnumProc: TIMEFMT_ENUMPROCA, Locale: LCID, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumTimeFormatsW(lpTimeFmtEnumProc: TIMEFMT_ENUMPROCW, Locale: LCID, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumDateFormatsA(lpDateFmtEnumProc: DATEFMT_ENUMPROCA, Locale: LCID, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumDateFormatsW(lpDateFmtEnumProc: DATEFMT_ENUMPROCW, Locale: LCID, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumDateFormatsExA(lpDateFmtEnumProcEx: DATEFMT_ENUMPROCEXA, Locale: LCID, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumDateFormatsExW(lpDateFmtEnumProcEx: DATEFMT_ENUMPROCEXW, Locale: LCID, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsValidLanguageGroup(LanguageGroup: LGRPID, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNLSVersion(Function: NLS_FUNCTION, Locale: LCID, lpVersionInformation: LPNLSVERSIONINFO) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsValidLocale(Locale: LCID, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetGeoInfoA(Location: GEOID, GeoType: GEOTYPE, lpGeoData: LPSTR, cchData: c_int, LangId: LANGID) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetGeoInfoW(Location: GEOID, GeoType: GEOTYPE, lpGeoData: LPWSTR, cchData: c_int, LangId: LANGID) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetGeoInfoEx(location: PWSTR, geoType: GEOTYPE, geoData: PWSTR, geoDataCount: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn EnumSystemGeoID(GeoClass: GEOCLASS, ParentGeoId: GEOID, lpGeoEnumProc: GEO_ENUMPROC) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumSystemGeoNames(geoClass: GEOCLASS, geoEnumProc: GEO_ENUMNAMEPROC, data: LPARAM) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetUserGeoID(GeoClass: GEOCLASS) callconv(.Stdcall) GEOID;
pub extern "kernel32" fn GetUserDefaultGeoName(geoName: LPWSTR, geoNameCount: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn SetUserGeoID(GeoId: GEOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetUserGeoName(geoName: PWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ConvertDefaultLocale(Locale: LCID) callconv(.Stdcall) LCID;
pub extern "kernel32" fn GetSystemDefaultUILanguage() callconv(.Stdcall) LANGID;
pub extern "kernel32" fn GetThreadLocale() callconv(.Stdcall) LCID;
pub extern "kernel32" fn SetThreadLocale(Locale: LCID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetUserDefaultUILanguage() callconv(.Stdcall) LANGID;
pub extern "kernel32" fn GetUserDefaultLangID() callconv(.Stdcall) LANGID;
pub extern "kernel32" fn GetSystemDefaultLangID() callconv(.Stdcall) LANGID;
pub extern "kernel32" fn GetSystemDefaultLCID() callconv(.Stdcall) LCID;
pub extern "kernel32" fn GetUserDefaultLCID() callconv(.Stdcall) LCID;
pub extern "kernel32" fn SetThreadUILanguage(LangId: LANGID) callconv(.Stdcall) LANGID;
pub extern "kernel32" fn GetThreadUILanguage() callconv(.Stdcall) LANGID;
pub extern "kernel32" fn GetProcessPreferredUILanguages(dwFlags: DWORD, pulNumLanguages: PULONG, pwszLanguagesBuffer: PZZWSTR, pcchLanguagesBuffer: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetProcessPreferredUILanguages(dwFlags: DWORD, pwszLanguagesBuffer: PCZZWSTR, pulNumLanguages: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetUserPreferredUILanguages(dwFlags: DWORD, pulNumLanguages: PULONG, pwszLanguagesBuffer: PZZWSTR, pcchLanguagesBuffer: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetSystemPreferredUILanguages(dwFlags: DWORD, pulNumLanguages: PULONG, pwszLanguagesBuffer: PZZWSTR, pcchLanguagesBuffer: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetThreadPreferredUILanguages(dwFlags: DWORD, pulNumLanguages: PULONG, pwszLanguagesBuffer: PZZWSTR, pcchLanguagesBuffer: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetThreadPreferredUILanguages(dwFlags: DWORD, pwszLanguagesBuffer: PCZZWSTR, pulNumLanguages: PULONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetFileMUIInfo(dwFlags: DWORD, pcwszFilePath: PCWSTR, pFileMUIInfo: PFILEMUIINFO, pcbFileMUIInfo: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetFileMUIPath(dwFlags: DWORD, pcwszFilePath: PCWSTR, pwszLanguage: PWSTR, pcchLanguage: PULONG, pwszFileMUIPath: PWSTR, pcchFileMUIPath: PULONG, pululEnumerator: PULONGLONG) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetUILanguageInfo(dwFlags: DWORD, pwmszLanguage: PCZZWSTR, pwszFallbackLanguages: PZZWSTR, pcchFallbackLanguages: PDWORD, pAttributes: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn NotifyUILanguageChange(dwFlags: DWORD, pcwstrNewLanguage: PCWSTR, pcwstrPreviousLanguage: PCWSTR, dwReserved: DWORD, pdwStatusRtrn: PDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetStringTypeExA(Locale: LCID, dwInfoType: DWORD, lpSrcStr: LPCSTR, cchSrc: c_int, lpCharType: LPWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetStringTypeA(Locale: LCID, dwInfoType: DWORD, lpSrcStr: LPCSTR, cchSrc: c_int, lpCharType: LPWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FoldStringA(dwMapFlags: DWORD, lpSrcStr: LPCSTR, cchSrc: c_int, lpDestStr: LPSTR, cchDest: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn EnumSystemLocalesA(lpLocaleEnumProc: LOCALE_ENUMPROCA, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumSystemLocalesW(lpLocaleEnumProc: LOCALE_ENUMPROCW, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumSystemLanguageGroupsA(lpLanguageGroupEnumProc: LANGUAGEGROUP_ENUMPROCA, dwFlags: DWORD, lParam: LONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumSystemLanguageGroupsW(lpLanguageGroupEnumProc: LANGUAGEGROUP_ENUMPROCW, dwFlags: DWORD, lParam: LONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumLanguageGroupLocalesA(lpLangGroupLocaleEnumProc: LANGGROUPLOCALE_ENUMPROCA, LanguageGroup: LGRPID, dwFlags: DWORD, lParam: LONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumLanguageGroupLocalesW(lpLangGroupLocaleEnumProc: LANGGROUPLOCALE_ENUMPROCW, LanguageGroup: LGRPID, dwFlags: DWORD, lParam: LONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumUILanguagesA(lpUILanguageEnumProc: UILANGUAGE_ENUMPROCA, dwFlags: DWORD, lParam: LONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumUILanguagesW(lpUILanguageEnumProc: UILANGUAGE_ENUMPROCW, dwFlags: DWORD, lParam: LONG_PTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumSystemCodePagesA(lpCodePageEnumProc: CODEPAGE_ENUMPROCA, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn EnumSystemCodePagesW(lpCodePageEnumProc: CODEPAGE_ENUMPROCW, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IdnToAscii(dwFlags: DWORD, lpUnicodeCharStr: LPCWSTR, cchUnicodeChar: c_int, lpASCIICharStr: LPWSTR, cchASCIIChar: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn IdnToUnicode(dwFlags: DWORD, lpASCIICharStr: LPCWSTR, cchASCIIChar: c_int, lpUnicodeCharStr: LPWSTR, cchUnicodeChar: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn IdnToNameprepUnicode(dwFlags: DWORD, lpUnicodeCharStr: LPCWSTR, cchUnicodeChar: c_int, lpNameprepCharStr: LPWSTR, cchNameprepChar: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn NormalizeString(NormForm: NORM_FORM, lpSrcString: LPCWSTR, cwSrcLength: c_int, lpDstString: LPWSTR, cwDstLength: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn IsNormalizedString(NormForm: NORM_FORM, lpString: LPCWSTR, cwLength: c_int) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn VerifyScripts(dwFlags: DWORD, lpLocaleScripts: LPCWSTR, cchLocaleScripts: c_int, lpTestScripts: LPCWSTR, cchTestScripts: c_int) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetStringScripts(dwFlags: DWORD, lpString: LPCWSTR, cchString: c_int, lpScripts: LPWSTR, cchScripts: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetLocaleInfoEx(lpLocaleName: LPCWSTR, LCType: LCTYPE, lpLCData: LPWSTR, cchData: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetCalendarInfoEx(lpLocaleName: LPCWSTR, Calendar: CALID, lpReserved: LPCWSTR, CalType: CALTYPE, lpCalData: LPWSTR, cchData: c_int, lpValue: LPDWORD) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetNumberFormatEx(lpLocaleName: LPCWSTR, dwFlags: DWORD, lpValue: LPCWSTR, lpFormat: [*c]const NUMBERFMTW, lpNumberStr: LPWSTR, cchNumber: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetCurrencyFormatEx(lpLocaleName: LPCWSTR, dwFlags: DWORD, lpValue: LPCWSTR, lpFormat: [*c]const CURRENCYFMTW, lpCurrencyStr: LPWSTR, cchCurrency: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetUserDefaultLocaleName(lpLocaleName: LPWSTR, cchLocaleName: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn GetSystemDefaultLocaleName(lpLocaleName: LPWSTR, cchLocaleName: c_int) callconv(.Stdcall) c_int;
pub extern "kernel32" fn IsNLSDefinedString(Function: NLS_FUNCTION, dwFlags: DWORD, lpVersionInformation: LPNLSVERSIONINFO, lpString: LPCWSTR, cchStr: INT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNLSVersionEx(function: NLS_FUNCTION, lpLocaleName: LPCWSTR, lpVersionInformation: LPNLSVERSIONINFOEX) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn IsValidNLSVersion(function: NLS_FUNCTION, lpLocaleName: LPCWSTR, lpVersionInformation: LPNLSVERSIONINFOEX) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn FindNLSStringEx(lpLocaleName: LPCWSTR, dwFindNLSStringFlags: DWORD, lpStringSource: LPCWSTR, cchSource: c_int, lpStringValue: LPCWSTR, cchValue: c_int, pcchFound: LPINT, lpVersionInformation: LPNLSVERSIONINFO, lpReserved: LPVOID, sortHandle: LPARAM) callconv(.Stdcall) c_int;
pub extern "kernel32" fn LCMapStringEx(lpLocaleName: LPCWSTR, dwMapFlags: DWORD, lpSrcStr: LPCWSTR, cchSrc: c_int, lpDestStr: LPWSTR, cchDest: c_int, lpVersionInformation: LPNLSVERSIONINFO, lpReserved: LPVOID, sortHandle: LPARAM) callconv(.Stdcall) c_int;
pub extern "kernel32" fn IsValidLocaleName(lpLocaleName: LPCWSTR) callconv(.Stdcall) BOOL;
pub const CALINFO_ENUMPROCEXEX = ?fn (LPWSTR, CALID, LPWSTR, LPARAM) callconv(.C) BOOL;
pub extern "kernel32" fn EnumCalendarInfoExEx(pCalInfoEnumProcExEx: CALINFO_ENUMPROCEXEX, lpLocaleName: LPCWSTR, Calendar: CALID, lpReserved: LPCWSTR, CalType: CALTYPE, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub const DATEFMT_ENUMPROCEXEX = ?fn (LPWSTR, CALID, LPARAM) callconv(.C) BOOL;
pub extern "kernel32" fn EnumDateFormatsExEx(lpDateFmtEnumProcExEx: DATEFMT_ENUMPROCEXEX, lpLocaleName: LPCWSTR, dwFlags: DWORD, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub const TIMEFMT_ENUMPROCEX = ?fn (LPWSTR, LPARAM) callconv(.C) BOOL;
pub extern "kernel32" fn EnumTimeFormatsEx(lpTimeFmtEnumProcEx: TIMEFMT_ENUMPROCEX, lpLocaleName: LPCWSTR, dwFlags: DWORD, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub const LOCALE_ENUMPROCEX = ?fn (LPWSTR, DWORD, LPARAM) callconv(.C) BOOL;
pub extern "kernel32" fn EnumSystemLocalesEx(lpLocaleEnumProcEx: LOCALE_ENUMPROCEX, dwFlags: DWORD, lParam: LPARAM, lpReserved: LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ResolveLocaleName(lpNameToResolve: LPCWSTR, lpLocaleName: LPWSTR, cchLocaleName: c_int) callconv(.Stdcall) c_int;
pub const struct__COORD = extern struct {
    X: SHORT,
    Y: SHORT,
};
pub const COORD = struct__COORD;
pub const PCOORD = [*c]struct__COORD;
pub const struct__SMALL_RECT = extern struct {
    Left: SHORT,
    Top: SHORT,
    Right: SHORT,
    Bottom: SHORT,
};
pub const SMALL_RECT = struct__SMALL_RECT;
pub const PSMALL_RECT = [*c]struct__SMALL_RECT;
pub const struct__KEY_EVENT_RECORD = extern struct {
    bKeyDown: BOOL,
    wRepeatCount: WORD,
    wVirtualKeyCode: WORD,
    wVirtualScanCode: WORD,
    uChar: extern union {
        UnicodeChar: WCHAR,
        AsciiChar: CHAR,
    },
    dwControlKeyState: DWORD,
};
pub const KEY_EVENT_RECORD = struct__KEY_EVENT_RECORD;
pub const PKEY_EVENT_RECORD = [*c]struct__KEY_EVENT_RECORD;
pub const struct__MOUSE_EVENT_RECORD = extern struct {
    dwMousePosition: COORD,
    dwButtonState: DWORD,
    dwControlKeyState: DWORD,
    dwEventFlags: DWORD,
};
pub const MOUSE_EVENT_RECORD = struct__MOUSE_EVENT_RECORD;
pub const PMOUSE_EVENT_RECORD = [*c]struct__MOUSE_EVENT_RECORD;
pub const struct__WINDOW_BUFFER_SIZE_RECORD = extern struct {
    dwSize: COORD,
};
pub const WINDOW_BUFFER_SIZE_RECORD = struct__WINDOW_BUFFER_SIZE_RECORD;
pub const PWINDOW_BUFFER_SIZE_RECORD = [*c]struct__WINDOW_BUFFER_SIZE_RECORD;
pub const struct__MENU_EVENT_RECORD = extern struct {
    dwCommandId: UINT,
};
pub const MENU_EVENT_RECORD = struct__MENU_EVENT_RECORD;
pub const PMENU_EVENT_RECORD = [*c]struct__MENU_EVENT_RECORD;
pub const struct__FOCUS_EVENT_RECORD = extern struct {
    bSetFocus: BOOL,
};
pub const FOCUS_EVENT_RECORD = struct__FOCUS_EVENT_RECORD;
pub const PFOCUS_EVENT_RECORD = [*c]struct__FOCUS_EVENT_RECORD;
pub const struct__INPUT_RECORD = extern struct {
    EventType: WORD,
    Event: extern union {
        KeyEvent: KEY_EVENT_RECORD,
        MouseEvent: MOUSE_EVENT_RECORD,
        WindowBufferSizeEvent: WINDOW_BUFFER_SIZE_RECORD,
        MenuEvent: MENU_EVENT_RECORD,
        FocusEvent: FOCUS_EVENT_RECORD,
    },
};
pub const INPUT_RECORD = struct__INPUT_RECORD;
pub const PINPUT_RECORD = [*c]struct__INPUT_RECORD;
pub const struct__CHAR_INFO = extern struct {
    Char: extern union {
        UnicodeChar: WCHAR,
        AsciiChar: CHAR,
    },
    Attributes: WORD,
};
pub const CHAR_INFO = struct__CHAR_INFO;
pub const PCHAR_INFO = [*c]struct__CHAR_INFO;
pub const struct__CONSOLE_FONT_INFO = extern struct {
    nFont: DWORD,
    dwFontSize: COORD,
};
pub const CONSOLE_FONT_INFO = struct__CONSOLE_FONT_INFO;
pub const PCONSOLE_FONT_INFO = [*c]struct__CONSOLE_FONT_INFO;
pub const HPCON = ?*c_void;
pub extern "kernel32" fn AllocConsole() callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FreeConsole() callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AttachConsole(dwProcessId: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetConsoleCP() callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetConsoleOutputCP() callconv(.Stdcall) UINT;
pub extern "kernel32" fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetConsoleMode(hConsoleHandle: HANDLE, dwMode: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNumberOfConsoleInputEvents(hConsoleInput: HANDLE, lpNumberOfEvents: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ReadConsoleInputA(hConsoleInput: HANDLE, lpBuffer: PINPUT_RECORD, nLength: DWORD, lpNumberOfEventsRead: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ReadConsoleInputW(hConsoleInput: HANDLE, lpBuffer: PINPUT_RECORD, nLength: DWORD, lpNumberOfEventsRead: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn PeekConsoleInputA(hConsoleInput: HANDLE, lpBuffer: PINPUT_RECORD, nLength: DWORD, lpNumberOfEventsRead: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn PeekConsoleInputW(hConsoleInput: HANDLE, lpBuffer: PINPUT_RECORD, nLength: DWORD, lpNumberOfEventsRead: LPDWORD) callconv(.Stdcall) BOOL;
pub const struct__CONSOLE_READCONSOLE_CONTROL = extern struct {
    nLength: ULONG,
    nInitialChars: ULONG,
    dwCtrlWakeupMask: ULONG,
    dwControlKeyState: ULONG,
};
pub const CONSOLE_READCONSOLE_CONTROL = struct__CONSOLE_READCONSOLE_CONTROL;
pub const PCONSOLE_READCONSOLE_CONTROL = [*c]struct__CONSOLE_READCONSOLE_CONTROL;
pub extern "kernel32" fn ReadConsoleA(hConsoleInput: HANDLE, lpBuffer: LPVOID, nNumberOfCharsToRead: DWORD, lpNumberOfCharsRead: LPDWORD, pInputControl: PCONSOLE_READCONSOLE_CONTROL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ReadConsoleW(hConsoleInput: HANDLE, lpBuffer: LPVOID, nNumberOfCharsToRead: DWORD, lpNumberOfCharsRead: LPDWORD, pInputControl: PCONSOLE_READCONSOLE_CONTROL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WriteConsoleA(hConsoleOutput: HANDLE, lpBuffer: ?*const c_void, nNumberOfCharsToWrite: DWORD, lpNumberOfCharsWritten: LPDWORD, lpReserved: LPVOID) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WriteConsoleW(hConsoleOutput: HANDLE, lpBuffer: ?*const c_void, nNumberOfCharsToWrite: DWORD, lpNumberOfCharsWritten: LPDWORD, lpReserved: LPVOID) callconv(.Stdcall) BOOL;
pub const PHANDLER_ROUTINE = ?fn (DWORD) callconv(.C) BOOL;
pub extern "kernel32" fn SetConsoleCtrlHandler(HandlerRoutine: PHANDLER_ROUTINE, Add: BOOL) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreatePseudoConsole(size: COORD, hInput: HANDLE, hOutput: HANDLE, dwFlags: DWORD, phPC: [*c]HPCON) callconv(.Stdcall) HRESULT;
pub extern "kernel32" fn ResizePseudoConsole(hPC: HPCON, size: COORD) callconv(.Stdcall) HRESULT;
pub extern "kernel32" fn ClosePseudoConsole(hPC: HPCON) callconv(.Stdcall) void;
pub extern "kernel32" fn FillConsoleOutputCharacterA(hConsoleOutput: HANDLE, cCharacter: CHAR, nLength: DWORD, dwWriteCoord: COORD, lpNumberOfCharsWritten: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FillConsoleOutputCharacterW(hConsoleOutput: HANDLE, cCharacter: WCHAR, nLength: DWORD, dwWriteCoord: COORD, lpNumberOfCharsWritten: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FillConsoleOutputAttribute(hConsoleOutput: HANDLE, wAttribute: WORD, nLength: DWORD, dwWriteCoord: COORD, lpNumberOfAttrsWritten: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GenerateConsoleCtrlEvent(dwCtrlEvent: DWORD, dwProcessGroupId: DWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn CreateConsoleScreenBuffer(dwDesiredAccess: DWORD, dwShareMode: DWORD, lpSecurityAttributes: [*c]const SECURITY_ATTRIBUTES, dwFlags: DWORD, lpScreenBufferData: LPVOID) callconv(.Stdcall) HANDLE;
pub extern "kernel32" fn SetConsoleActiveScreenBuffer(hConsoleOutput: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn FlushConsoleInputBuffer(hConsoleInput: HANDLE) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetConsoleCP(wCodePageID: UINT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetConsoleOutputCP(wCodePageID: UINT) callconv(.Stdcall) BOOL;
pub const struct__CONSOLE_CURSOR_INFO = extern struct {
    dwSize: DWORD,
    bVisible: BOOL,
};
pub const CONSOLE_CURSOR_INFO = struct__CONSOLE_CURSOR_INFO;
pub const PCONSOLE_CURSOR_INFO = [*c]struct__CONSOLE_CURSOR_INFO;
pub extern "kernel32" fn GetConsoleCursorInfo(hConsoleOutput: HANDLE, lpConsoleCursorInfo: PCONSOLE_CURSOR_INFO) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetConsoleCursorInfo(hConsoleOutput: HANDLE, lpConsoleCursorInfo: [*c]const CONSOLE_CURSOR_INFO) callconv(.Stdcall) BOOL;
pub const struct__CONSOLE_SCREEN_BUFFER_INFO = extern struct {
    dwSize: COORD,
    dwCursorPosition: COORD,
    wAttributes: WORD,
    srWindow: SMALL_RECT,
    dwMaximumWindowSize: COORD,
};
pub const CONSOLE_SCREEN_BUFFER_INFO = struct__CONSOLE_SCREEN_BUFFER_INFO;
pub const PCONSOLE_SCREEN_BUFFER_INFO = [*c]struct__CONSOLE_SCREEN_BUFFER_INFO;
pub extern "kernel32" fn GetConsoleScreenBufferInfo(hConsoleOutput: HANDLE, lpConsoleScreenBufferInfo: PCONSOLE_SCREEN_BUFFER_INFO) callconv(.Stdcall) BOOL;
pub const struct__CONSOLE_SCREEN_BUFFER_INFOEX = extern struct {
    cbSize: ULONG,
    dwSize: COORD,
    dwCursorPosition: COORD,
    wAttributes: WORD,
    srWindow: SMALL_RECT,
    dwMaximumWindowSize: COORD,
    wPopupAttributes: WORD,
    bFullscreenSupported: BOOL,
    ColorTable: [16]COLORREF,
};
pub const CONSOLE_SCREEN_BUFFER_INFOEX = struct__CONSOLE_SCREEN_BUFFER_INFOEX;
pub const PCONSOLE_SCREEN_BUFFER_INFOEX = [*c]struct__CONSOLE_SCREEN_BUFFER_INFOEX;
pub extern "kernel32" fn GetConsoleScreenBufferInfoEx(hConsoleOutput: HANDLE, lpConsoleScreenBufferInfoEx: PCONSOLE_SCREEN_BUFFER_INFOEX) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetConsoleScreenBufferInfoEx(hConsoleOutput: HANDLE, lpConsoleScreenBufferInfoEx: PCONSOLE_SCREEN_BUFFER_INFOEX) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetConsoleScreenBufferSize(hConsoleOutput: HANDLE, dwSize: COORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetConsoleCursorPosition(hConsoleOutput: HANDLE, dwCursorPosition: COORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetLargestConsoleWindowSize(hConsoleOutput: HANDLE) callconv(.Stdcall) COORD;
pub extern "kernel32" fn SetConsoleTextAttribute(hConsoleOutput: HANDLE, wAttributes: WORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetConsoleWindowInfo(hConsoleOutput: HANDLE, bAbsolute: BOOL, lpConsoleWindow: [*c]const SMALL_RECT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WriteConsoleOutputCharacterA(hConsoleOutput: HANDLE, lpCharacter: LPCSTR, nLength: DWORD, dwWriteCoord: COORD, lpNumberOfCharsWritten: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WriteConsoleOutputCharacterW(hConsoleOutput: HANDLE, lpCharacter: LPCWSTR, nLength: DWORD, dwWriteCoord: COORD, lpNumberOfCharsWritten: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WriteConsoleOutputAttribute(hConsoleOutput: HANDLE, lpAttribute: [*c]const WORD, nLength: DWORD, dwWriteCoord: COORD, lpNumberOfAttrsWritten: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ReadConsoleOutputCharacterA(hConsoleOutput: HANDLE, lpCharacter: LPSTR, nLength: DWORD, dwReadCoord: COORD, lpNumberOfCharsRead: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ReadConsoleOutputCharacterW(hConsoleOutput: HANDLE, lpCharacter: LPWSTR, nLength: DWORD, dwReadCoord: COORD, lpNumberOfCharsRead: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ReadConsoleOutputAttribute(hConsoleOutput: HANDLE, lpAttribute: LPWORD, nLength: DWORD, dwReadCoord: COORD, lpNumberOfAttrsRead: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WriteConsoleInputA(hConsoleInput: HANDLE, lpBuffer: [*c]const INPUT_RECORD, nLength: DWORD, lpNumberOfEventsWritten: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WriteConsoleInputW(hConsoleInput: HANDLE, lpBuffer: [*c]const INPUT_RECORD, nLength: DWORD, lpNumberOfEventsWritten: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ScrollConsoleScreenBufferA(hConsoleOutput: HANDLE, lpScrollRectangle: [*c]const SMALL_RECT, lpClipRectangle: [*c]const SMALL_RECT, dwDestinationOrigin: COORD, lpFill: [*c]const CHAR_INFO) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ScrollConsoleScreenBufferW(hConsoleOutput: HANDLE, lpScrollRectangle: [*c]const SMALL_RECT, lpClipRectangle: [*c]const SMALL_RECT, dwDestinationOrigin: COORD, lpFill: [*c]const CHAR_INFO) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WriteConsoleOutputA(hConsoleOutput: HANDLE, lpBuffer: [*c]const CHAR_INFO, dwBufferSize: COORD, dwBufferCoord: COORD, lpWriteRegion: PSMALL_RECT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn WriteConsoleOutputW(hConsoleOutput: HANDLE, lpBuffer: [*c]const CHAR_INFO, dwBufferSize: COORD, dwBufferCoord: COORD, lpWriteRegion: PSMALL_RECT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ReadConsoleOutputA(hConsoleOutput: HANDLE, lpBuffer: PCHAR_INFO, dwBufferSize: COORD, dwBufferCoord: COORD, lpReadRegion: PSMALL_RECT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn ReadConsoleOutputW(hConsoleOutput: HANDLE, lpBuffer: PCHAR_INFO, dwBufferSize: COORD, dwBufferCoord: COORD, lpReadRegion: PSMALL_RECT) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetConsoleTitleA(lpConsoleTitle: LPSTR, nSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetConsoleTitleW(lpConsoleTitle: LPWSTR, nSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetConsoleOriginalTitleA(lpConsoleTitle: LPSTR, nSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetConsoleOriginalTitleW(lpConsoleTitle: LPWSTR, nSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn SetConsoleTitleA(lpConsoleTitle: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetConsoleTitleW(lpConsoleTitle: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetNumberOfConsoleMouseButtons(lpNumberOfMouseButtons: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetConsoleFontSize(hConsoleOutput: HANDLE, nFont: DWORD) callconv(.Stdcall) COORD;
pub extern "kernel32" fn GetCurrentConsoleFont(hConsoleOutput: HANDLE, bMaximumWindow: BOOL, lpConsoleCurrentFont: PCONSOLE_FONT_INFO) callconv(.Stdcall) BOOL;
pub const struct__CONSOLE_FONT_INFOEX = extern struct {
    cbSize: ULONG,
    nFont: DWORD,
    dwFontSize: COORD,
    FontFamily: UINT,
    FontWeight: UINT,
    FaceName: [32]WCHAR,
};
pub const CONSOLE_FONT_INFOEX = struct__CONSOLE_FONT_INFOEX;
pub const PCONSOLE_FONT_INFOEX = [*c]struct__CONSOLE_FONT_INFOEX;
pub extern "kernel32" fn GetCurrentConsoleFontEx(hConsoleOutput: HANDLE, bMaximumWindow: BOOL, lpConsoleCurrentFontEx: PCONSOLE_FONT_INFOEX) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetCurrentConsoleFontEx(hConsoleOutput: HANDLE, bMaximumWindow: BOOL, lpConsoleCurrentFontEx: PCONSOLE_FONT_INFOEX) callconv(.Stdcall) BOOL;
pub const struct__CONSOLE_SELECTION_INFO = extern struct {
    dwFlags: DWORD,
    dwSelectionAnchor: COORD,
    srSelection: SMALL_RECT,
};
pub const CONSOLE_SELECTION_INFO = struct__CONSOLE_SELECTION_INFO;
pub const PCONSOLE_SELECTION_INFO = [*c]struct__CONSOLE_SELECTION_INFO;
pub extern "kernel32" fn GetConsoleSelectionInfo(lpConsoleSelectionInfo: PCONSOLE_SELECTION_INFO) callconv(.Stdcall) BOOL;
pub const struct__CONSOLE_HISTORY_INFO = extern struct {
    cbSize: UINT,
    HistoryBufferSize: UINT,
    NumberOfHistoryBuffers: UINT,
    dwFlags: DWORD,
};
pub const CONSOLE_HISTORY_INFO = struct__CONSOLE_HISTORY_INFO;
pub const PCONSOLE_HISTORY_INFO = [*c]struct__CONSOLE_HISTORY_INFO;
pub extern "kernel32" fn GetConsoleHistoryInfo(lpConsoleHistoryInfo: PCONSOLE_HISTORY_INFO) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetConsoleHistoryInfo(lpConsoleHistoryInfo: PCONSOLE_HISTORY_INFO) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetConsoleDisplayMode(lpModeFlags: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetConsoleDisplayMode(hConsoleOutput: HANDLE, dwFlags: DWORD, lpNewScreenBufferDimensions: PCOORD) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetConsoleWindow() callconv(.Stdcall) HWND;
pub extern "kernel32" fn AddConsoleAliasA(Source: LPSTR, Target: LPSTR, ExeName: LPSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn AddConsoleAliasW(Source: LPWSTR, Target: LPWSTR, ExeName: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetConsoleAliasA(Source: LPSTR, TargetBuffer: LPSTR, TargetBufferLength: DWORD, ExeName: LPSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetConsoleAliasW(Source: LPWSTR, TargetBuffer: LPWSTR, TargetBufferLength: DWORD, ExeName: LPWSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetConsoleAliasesLengthA(ExeName: LPSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetConsoleAliasesLengthW(ExeName: LPWSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetConsoleAliasExesLengthA() callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetConsoleAliasExesLengthW() callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetConsoleAliasesA(AliasBuffer: LPSTR, AliasBufferLength: DWORD, ExeName: LPSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetConsoleAliasesW(AliasBuffer: LPWSTR, AliasBufferLength: DWORD, ExeName: LPWSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetConsoleAliasExesA(ExeNameBuffer: LPSTR, ExeNameBufferLength: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetConsoleAliasExesW(ExeNameBuffer: LPWSTR, ExeNameBufferLength: DWORD) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn ExpungeConsoleCommandHistoryA(ExeName: LPSTR) callconv(.Stdcall) void;
pub extern "kernel32" fn ExpungeConsoleCommandHistoryW(ExeName: LPWSTR) callconv(.Stdcall) void;
pub extern "kernel32" fn SetConsoleNumberOfCommandsA(Number: DWORD, ExeName: LPSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn SetConsoleNumberOfCommandsW(Number: DWORD, ExeName: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "kernel32" fn GetConsoleCommandHistoryLengthA(ExeName: LPSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetConsoleCommandHistoryLengthW(ExeName: LPWSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetConsoleCommandHistoryA(Commands: LPSTR, CommandBufferLength: DWORD, ExeName: LPSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetConsoleCommandHistoryW(Commands: LPWSTR, CommandBufferLength: DWORD, ExeName: LPWSTR) callconv(.Stdcall) DWORD;
pub extern "kernel32" fn GetConsoleProcessList(lpdwProcessList: LPDWORD, dwProcessCount: DWORD) callconv(.Stdcall) DWORD;
pub const struct_tagVS_FIXEDFILEINFO = extern struct {
    dwSignature: DWORD,
    dwStrucVersion: DWORD,
    dwFileVersionMS: DWORD,
    dwFileVersionLS: DWORD,
    dwProductVersionMS: DWORD,
    dwProductVersionLS: DWORD,
    dwFileFlagsMask: DWORD,
    dwFileFlags: DWORD,
    dwFileOS: DWORD,
    dwFileType: DWORD,
    dwFileSubtype: DWORD,
    dwFileDateMS: DWORD,
    dwFileDateLS: DWORD,
};
pub const VS_FIXEDFILEINFO = struct_tagVS_FIXEDFILEINFO;
pub extern "mincore" fn VerFindFileA(uFlags: DWORD, szFileName: LPCSTR, szWinDir: LPCSTR, szAppDir: LPCSTR, szCurDir: LPSTR, puCurDirLen: PUINT, szDestDir: LPSTR, puDestDirLen: PUINT) DWORD;
pub extern "mincore" fn VerFindFileW(uFlags: DWORD, szFileName: LPCWSTR, szWinDir: LPCWSTR, szAppDir: LPCWSTR, szCurDir: LPWSTR, puCurDirLen: PUINT, szDestDir: LPWSTR, puDestDirLen: PUINT) DWORD;
pub extern "mincore" fn VerInstallFileA(uFlags: DWORD, szSrcFileName: LPCSTR, szDestFileName: LPCSTR, szSrcDir: LPCSTR, szDestDir: LPCSTR, szCurDir: LPCSTR, szTmpFile: LPSTR, puTmpFileLen: PUINT) DWORD;
pub extern "mincore" fn VerInstallFileW(uFlags: DWORD, szSrcFileName: LPCWSTR, szDestFileName: LPCWSTR, szSrcDir: LPCWSTR, szDestDir: LPCWSTR, szCurDir: LPCWSTR, szTmpFile: LPWSTR, puTmpFileLen: PUINT) DWORD;
pub extern "mincore" fn GetFileVersionInfoSizeA(lptstrFilename: LPCSTR, lpdwHandle: LPDWORD) DWORD;
pub extern "mincore" fn GetFileVersionInfoSizeW(lptstrFilename: LPCWSTR, lpdwHandle: LPDWORD) DWORD;
pub extern "mincore" fn GetFileVersionInfoA(lptstrFilename: LPCSTR, dwHandle: DWORD, dwLen: DWORD, lpData: LPVOID) BOOL;
pub extern "mincore" fn GetFileVersionInfoW(lptstrFilename: LPCWSTR, dwHandle: DWORD, dwLen: DWORD, lpData: LPVOID) BOOL;
pub extern "mincore" fn GetFileVersionInfoSizeExA(dwFlags: DWORD, lpwstrFilename: LPCSTR, lpdwHandle: LPDWORD) DWORD;
pub extern "mincore" fn GetFileVersionInfoSizeExW(dwFlags: DWORD, lpwstrFilename: LPCWSTR, lpdwHandle: LPDWORD) DWORD;
pub extern "mincore" fn GetFileVersionInfoExA(dwFlags: DWORD, lpwstrFilename: LPCSTR, dwHandle: DWORD, dwLen: DWORD, lpData: LPVOID) BOOL;
pub extern "mincore" fn GetFileVersionInfoExW(dwFlags: DWORD, lpwstrFilename: LPCWSTR, dwHandle: DWORD, dwLen: DWORD, lpData: LPVOID) BOOL;
pub extern "mincore" fn VerLanguageNameA(wLang: DWORD, szLang: LPSTR, cchLang: DWORD) DWORD;
pub extern "mincore" fn VerLanguageNameW(wLang: DWORD, szLang: LPWSTR, cchLang: DWORD) DWORD;
pub extern "mincore" fn VerQueryValueA(pBlock: LPCVOID, lpSubBlock: LPCSTR, lplpBuffer: [*c]LPVOID, puLen: PUINT) BOOL;
pub extern "mincore" fn VerQueryValueW(pBlock: LPCVOID, lpSubBlock: LPCWSTR, lplpBuffer: [*c]LPVOID, puLen: PUINT) BOOL;
pub const LSTATUS = LONG;
pub const REGSAM = ACCESS_MASK;
pub const struct_val_context = extern struct {
    valuelen: c_int,
    value_context: LPVOID,
    val_buff_ptr: LPVOID,
};
pub const PVALCONTEXT = [*c]struct_val_context;
pub const struct_pvalueA = extern struct {
    pv_valuename: LPSTR,
    pv_valuelen: c_int,
    pv_value_context: LPVOID,
    pv_type: DWORD,
};
pub const PVALUEA = struct_pvalueA;
pub const PPVALUEA = [*c]struct_pvalueA;
pub const struct_pvalueW = extern struct {
    pv_valuename: LPWSTR,
    pv_valuelen: c_int,
    pv_value_context: LPVOID,
    pv_type: DWORD,
};
pub const PVALUEW = struct_pvalueW;
pub const PPVALUEW = [*c]struct_pvalueW;
pub const PVALUE = PVALUEA;
pub const PPVALUE = PPVALUEA;
pub const QUERYHANDLER = fn (LPVOID, PVALCONTEXT, DWORD, LPVOID, [*c]DWORD, DWORD) callconv(.C) DWORD;
pub const PQUERYHANDLER = [*c]QUERYHANDLER;
pub const struct_provider_info = extern struct {
    pi_R0_1val: PQUERYHANDLER,
    pi_R0_allvals: PQUERYHANDLER,
    pi_R3_1val: PQUERYHANDLER,
    pi_R3_allvals: PQUERYHANDLER,
    pi_flags: DWORD,
    pi_key_context: LPVOID,
};
pub const REG_PROVIDER = struct_provider_info;
pub const PPROVIDER = [*c]struct_provider_info;
pub const struct_value_entA = extern struct {
    ve_valuename: LPSTR,
    ve_valuelen: DWORD,
    ve_valueptr: DWORD_PTR,
    ve_type: DWORD,
};
pub const VALENTA = struct_value_entA;
pub const PVALENTA = [*c]struct_value_entA;
pub const struct_value_entW = extern struct {
    ve_valuename: LPWSTR,
    ve_valuelen: DWORD,
    ve_valueptr: DWORD_PTR,
    ve_type: DWORD,
};
pub const VALENTW = struct_value_entW;
pub const PVALENTW = [*c]struct_value_entW;
pub const VALENT = VALENTA;
pub const PVALENT = PVALENTA;
pub extern "advapi32" fn RegCloseKey(hKey: HKEY) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegOverridePredefKey(hKey: HKEY, hNewHKey: HKEY) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegOpenUserClassesRoot(hToken: HANDLE, dwOptions: DWORD, samDesired: REGSAM, phkResult: PHKEY) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegOpenCurrentUser(samDesired: REGSAM, phkResult: PHKEY) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegDisablePredefinedCache() callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegDisablePredefinedCacheEx() callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegConnectRegistryA(lpMachineName: LPCSTR, hKey: HKEY, phkResult: PHKEY) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegConnectRegistryW(lpMachineName: LPCWSTR, hKey: HKEY, phkResult: PHKEY) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegConnectRegistryExA(lpMachineName: LPCSTR, hKey: HKEY, Flags: ULONG, phkResult: PHKEY) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegConnectRegistryExW(lpMachineName: LPCWSTR, hKey: HKEY, Flags: ULONG, phkResult: PHKEY) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegCreateKeyA(hKey: HKEY, lpSubKey: LPCSTR, phkResult: PHKEY) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegCreateKeyW(hKey: HKEY, lpSubKey: LPCWSTR, phkResult: PHKEY) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegCreateKeyExA(hKey: HKEY, lpSubKey: LPCSTR, Reserved: DWORD, lpClass: LPSTR, dwOptions: DWORD, samDesired: REGSAM, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, phkResult: PHKEY, lpdwDisposition: LPDWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegCreateKeyExW(hKey: HKEY, lpSubKey: LPCWSTR, Reserved: DWORD, lpClass: LPWSTR, dwOptions: DWORD, samDesired: REGSAM, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, phkResult: PHKEY, lpdwDisposition: LPDWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegCreateKeyTransactedA(hKey: HKEY, lpSubKey: LPCSTR, Reserved: DWORD, lpClass: LPSTR, dwOptions: DWORD, samDesired: REGSAM, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, phkResult: PHKEY, lpdwDisposition: LPDWORD, hTransaction: HANDLE, pExtendedParemeter: PVOID) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegCreateKeyTransactedW(hKey: HKEY, lpSubKey: LPCWSTR, Reserved: DWORD, lpClass: LPWSTR, dwOptions: DWORD, samDesired: REGSAM, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, phkResult: PHKEY, lpdwDisposition: LPDWORD, hTransaction: HANDLE, pExtendedParemeter: PVOID) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegDeleteKeyA(hKey: HKEY, lpSubKey: LPCSTR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegDeleteKeyW(hKey: HKEY, lpSubKey: LPCWSTR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegDeleteKeyExA(hKey: HKEY, lpSubKey: LPCSTR, samDesired: REGSAM, Reserved: DWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegDeleteKeyExW(hKey: HKEY, lpSubKey: LPCWSTR, samDesired: REGSAM, Reserved: DWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegDeleteKeyTransactedA(hKey: HKEY, lpSubKey: LPCSTR, samDesired: REGSAM, Reserved: DWORD, hTransaction: HANDLE, pExtendedParameter: PVOID) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegDeleteKeyTransactedW(hKey: HKEY, lpSubKey: LPCWSTR, samDesired: REGSAM, Reserved: DWORD, hTransaction: HANDLE, pExtendedParameter: PVOID) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegDisableReflectionKey(hBase: HKEY) callconv(.Stdcall) LONG;
pub extern "advapi32" fn RegEnableReflectionKey(hBase: HKEY) callconv(.Stdcall) LONG;
pub extern "advapi32" fn RegQueryReflectionKey(hBase: HKEY, bIsReflectionDisabled: [*c]BOOL) callconv(.Stdcall) LONG;
pub extern "advapi32" fn RegDeleteValueA(hKey: HKEY, lpValueName: LPCSTR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegDeleteValueW(hKey: HKEY, lpValueName: LPCWSTR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegEnumKeyA(hKey: HKEY, dwIndex: DWORD, lpName: LPSTR, cchName: DWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegEnumKeyW(hKey: HKEY, dwIndex: DWORD, lpName: LPWSTR, cchName: DWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegEnumKeyExA(hKey: HKEY, dwIndex: DWORD, lpName: LPSTR, lpcchName: LPDWORD, lpReserved: LPDWORD, lpClass: LPSTR, lpcchClass: LPDWORD, lpftLastWriteTime: PFILETIME) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegEnumKeyExW(hKey: HKEY, dwIndex: DWORD, lpName: LPWSTR, lpcchName: LPDWORD, lpReserved: LPDWORD, lpClass: LPWSTR, lpcchClass: LPDWORD, lpftLastWriteTime: PFILETIME) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegEnumValueA(hKey: HKEY, dwIndex: DWORD, lpValueName: LPSTR, lpcchValueName: LPDWORD, lpReserved: LPDWORD, lpType: LPDWORD, lpData: LPBYTE, lpcbData: LPDWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegEnumValueW(hKey: HKEY, dwIndex: DWORD, lpValueName: LPWSTR, lpcchValueName: LPDWORD, lpReserved: LPDWORD, lpType: LPDWORD, lpData: LPBYTE, lpcbData: LPDWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegFlushKey(hKey: HKEY) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegGetKeySecurity(hKey: HKEY, SecurityInformation: SECURITY_INFORMATION, pSecurityDescriptor: PSECURITY_DESCRIPTOR, lpcbSecurityDescriptor: LPDWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegLoadKeyA(hKey: HKEY, lpSubKey: LPCSTR, lpFile: LPCSTR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegLoadKeyW(hKey: HKEY, lpSubKey: LPCWSTR, lpFile: LPCWSTR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegNotifyChangeKeyValue(hKey: HKEY, bWatchSubtree: BOOL, dwNotifyFilter: DWORD, hEvent: HANDLE, fAsynchronous: BOOL) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegOpenKeyA(hKey: HKEY, lpSubKey: LPCSTR, phkResult: PHKEY) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegOpenKeyW(hKey: HKEY, lpSubKey: LPCWSTR, phkResult: PHKEY) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegOpenKeyExA(hKey: HKEY, lpSubKey: LPCSTR, ulOptions: DWORD, samDesired: REGSAM, phkResult: PHKEY) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegOpenKeyExW(hKey: HKEY, lpSubKey: LPCWSTR, ulOptions: DWORD, samDesired: REGSAM, phkResult: PHKEY) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegOpenKeyTransactedA(hKey: HKEY, lpSubKey: LPCSTR, ulOptions: DWORD, samDesired: REGSAM, phkResult: PHKEY, hTransaction: HANDLE, pExtendedParemeter: PVOID) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegOpenKeyTransactedW(hKey: HKEY, lpSubKey: LPCWSTR, ulOptions: DWORD, samDesired: REGSAM, phkResult: PHKEY, hTransaction: HANDLE, pExtendedParemeter: PVOID) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegQueryInfoKeyA(hKey: HKEY, lpClass: LPSTR, lpcchClass: LPDWORD, lpReserved: LPDWORD, lpcSubKeys: LPDWORD, lpcbMaxSubKeyLen: LPDWORD, lpcbMaxClassLen: LPDWORD, lpcValues: LPDWORD, lpcbMaxValueNameLen: LPDWORD, lpcbMaxValueLen: LPDWORD, lpcbSecurityDescriptor: LPDWORD, lpftLastWriteTime: PFILETIME) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegQueryInfoKeyW(hKey: HKEY, lpClass: LPWSTR, lpcchClass: LPDWORD, lpReserved: LPDWORD, lpcSubKeys: LPDWORD, lpcbMaxSubKeyLen: LPDWORD, lpcbMaxClassLen: LPDWORD, lpcValues: LPDWORD, lpcbMaxValueNameLen: LPDWORD, lpcbMaxValueLen: LPDWORD, lpcbSecurityDescriptor: LPDWORD, lpftLastWriteTime: PFILETIME) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegQueryValueA(hKey: HKEY, lpSubKey: LPCSTR, lpData: LPSTR, lpcbData: PLONG) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegQueryValueW(hKey: HKEY, lpSubKey: LPCWSTR, lpData: LPWSTR, lpcbData: PLONG) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegQueryMultipleValuesA(hKey: HKEY, val_list: PVALENTA, num_vals: DWORD, lpValueBuf: LPSTR, ldwTotsize: LPDWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegQueryMultipleValuesW(hKey: HKEY, val_list: PVALENTW, num_vals: DWORD, lpValueBuf: LPWSTR, ldwTotsize: LPDWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegQueryValueExA(hKey: HKEY, lpValueName: LPCSTR, lpReserved: LPDWORD, lpType: LPDWORD, lpData: LPBYTE, lpcbData: LPDWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegQueryValueExW(hKey: HKEY, lpValueName: LPCWSTR, lpReserved: LPDWORD, lpType: LPDWORD, lpData: LPBYTE, lpcbData: LPDWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegReplaceKeyA(hKey: HKEY, lpSubKey: LPCSTR, lpNewFile: LPCSTR, lpOldFile: LPCSTR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegReplaceKeyW(hKey: HKEY, lpSubKey: LPCWSTR, lpNewFile: LPCWSTR, lpOldFile: LPCWSTR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegRestoreKeyA(hKey: HKEY, lpFile: LPCSTR, dwFlags: DWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegRestoreKeyW(hKey: HKEY, lpFile: LPCWSTR, dwFlags: DWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegRenameKey(hKey: HKEY, lpSubKeyName: LPCWSTR, lpNewKeyName: LPCWSTR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegSaveKeyA(hKey: HKEY, lpFile: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegSaveKeyW(hKey: HKEY, lpFile: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegSetKeySecurity(hKey: HKEY, SecurityInformation: SECURITY_INFORMATION, pSecurityDescriptor: PSECURITY_DESCRIPTOR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegSetValueA(hKey: HKEY, lpSubKey: LPCSTR, dwType: DWORD, lpData: LPCSTR, cbData: DWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegSetValueW(hKey: HKEY, lpSubKey: LPCWSTR, dwType: DWORD, lpData: LPCWSTR, cbData: DWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegSetValueExA(hKey: HKEY, lpValueName: LPCSTR, Reserved: DWORD, dwType: DWORD, lpData: [*c]const BYTE, cbData: DWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegSetValueExW(hKey: HKEY, lpValueName: LPCWSTR, Reserved: DWORD, dwType: DWORD, lpData: [*c]const BYTE, cbData: DWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegUnLoadKeyA(hKey: HKEY, lpSubKey: LPCSTR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegUnLoadKeyW(hKey: HKEY, lpSubKey: LPCWSTR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegDeleteKeyValueA(hKey: HKEY, lpSubKey: LPCSTR, lpValueName: LPCSTR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegDeleteKeyValueW(hKey: HKEY, lpSubKey: LPCWSTR, lpValueName: LPCWSTR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegSetKeyValueA(hKey: HKEY, lpSubKey: LPCSTR, lpValueName: LPCSTR, dwType: DWORD, lpData: LPCVOID, cbData: DWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegSetKeyValueW(hKey: HKEY, lpSubKey: LPCWSTR, lpValueName: LPCWSTR, dwType: DWORD, lpData: LPCVOID, cbData: DWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegDeleteTreeA(hKey: HKEY, lpSubKey: LPCSTR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegDeleteTreeW(hKey: HKEY, lpSubKey: LPCWSTR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegCopyTreeA(hKeySrc: HKEY, lpSubKey: LPCSTR, hKeyDest: HKEY) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegGetValueA(hkey: HKEY, lpSubKey: LPCSTR, lpValue: LPCSTR, dwFlags: DWORD, pdwType: LPDWORD, pvData: PVOID, pcbData: LPDWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegGetValueW(hkey: HKEY, lpSubKey: LPCWSTR, lpValue: LPCWSTR, dwFlags: DWORD, pdwType: LPDWORD, pvData: PVOID, pcbData: LPDWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegCopyTreeW(hKeySrc: HKEY, lpSubKey: LPCWSTR, hKeyDest: HKEY) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegLoadMUIStringA(hKey: HKEY, pszValue: LPCSTR, pszOutBuf: LPSTR, cbOutBuf: DWORD, pcbData: LPDWORD, Flags: DWORD, pszDirectory: LPCSTR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegLoadMUIStringW(hKey: HKEY, pszValue: LPCWSTR, pszOutBuf: LPWSTR, cbOutBuf: DWORD, pcbData: LPDWORD, Flags: DWORD, pszDirectory: LPCWSTR) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegLoadAppKeyA(lpFile: LPCSTR, phkResult: PHKEY, samDesired: REGSAM, dwOptions: DWORD, Reserved: DWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegLoadAppKeyW(lpFile: LPCWSTR, phkResult: PHKEY, samDesired: REGSAM, dwOptions: DWORD, Reserved: DWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn InitiateSystemShutdownA(lpMachineName: LPSTR, lpMessage: LPSTR, dwTimeout: DWORD, bForceAppsClosed: BOOL, bRebootAfterShutdown: BOOL) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn InitiateSystemShutdownW(lpMachineName: LPWSTR, lpMessage: LPWSTR, dwTimeout: DWORD, bForceAppsClosed: BOOL, bRebootAfterShutdown: BOOL) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn AbortSystemShutdownA(lpMachineName: LPSTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn AbortSystemShutdownW(lpMachineName: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn InitiateSystemShutdownExA(lpMachineName: LPSTR, lpMessage: LPSTR, dwTimeout: DWORD, bForceAppsClosed: BOOL, bRebootAfterShutdown: BOOL, dwReason: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn InitiateSystemShutdownExW(lpMachineName: LPWSTR, lpMessage: LPWSTR, dwTimeout: DWORD, bForceAppsClosed: BOOL, bRebootAfterShutdown: BOOL, dwReason: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn InitiateShutdownA(lpMachineName: LPSTR, lpMessage: LPSTR, dwGracePeriod: DWORD, dwShutdownFlags: DWORD, dwReason: DWORD) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn InitiateShutdownW(lpMachineName: LPWSTR, lpMessage: LPWSTR, dwGracePeriod: DWORD, dwShutdownFlags: DWORD, dwReason: DWORD) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn CheckForHiberboot(pHiberboot: PBOOLEAN, bClearFlag: BOOLEAN) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn RegSaveKeyExA(hKey: HKEY, lpFile: LPCSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, Flags: DWORD) callconv(.Stdcall) LSTATUS;
pub extern "advapi32" fn RegSaveKeyExW(hKey: HKEY, lpFile: LPCWSTR, lpSecurityAttributes: LPSECURITY_ATTRIBUTES, Flags: DWORD) callconv(.Stdcall) LSTATUS;
pub const struct__NETRESOURCEA = extern struct {
    dwScope: DWORD,
    dwType: DWORD,
    dwDisplayType: DWORD,
    dwUsage: DWORD,
    lpLocalName: LPSTR,
    lpRemoteName: LPSTR,
    lpComment: LPSTR,
    lpProvider: LPSTR,
};
pub const NETRESOURCEA = struct__NETRESOURCEA;
pub const LPNETRESOURCEA = [*c]struct__NETRESOURCEA;
pub const struct__NETRESOURCEW = extern struct {
    dwScope: DWORD,
    dwType: DWORD,
    dwDisplayType: DWORD,
    dwUsage: DWORD,
    lpLocalName: LPWSTR,
    lpRemoteName: LPWSTR,
    lpComment: LPWSTR,
    lpProvider: LPWSTR,
};
pub const NETRESOURCEW = struct__NETRESOURCEW;
pub const LPNETRESOURCEW = [*c]struct__NETRESOURCEW;
pub const NETRESOURCE = NETRESOURCEA;
pub const LPNETRESOURCE = LPNETRESOURCEA;
pub extern "mpr" fn WNetAddConnectionA(lpRemoteName: LPCSTR, lpPassword: LPCSTR, lpLocalName: LPCSTR) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetAddConnectionW(lpRemoteName: LPCWSTR, lpPassword: LPCWSTR, lpLocalName: LPCWSTR) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetAddConnection2A(lpNetResource: LPNETRESOURCEA, lpPassword: LPCSTR, lpUserName: LPCSTR, dwFlags: DWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetAddConnection2W(lpNetResource: LPNETRESOURCEW, lpPassword: LPCWSTR, lpUserName: LPCWSTR, dwFlags: DWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetAddConnection3A(hwndOwner: HWND, lpNetResource: LPNETRESOURCEA, lpPassword: LPCSTR, lpUserName: LPCSTR, dwFlags: DWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetAddConnection3W(hwndOwner: HWND, lpNetResource: LPNETRESOURCEW, lpPassword: LPCWSTR, lpUserName: LPCWSTR, dwFlags: DWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetCancelConnectionA(lpName: LPCSTR, fForce: BOOL) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetCancelConnectionW(lpName: LPCWSTR, fForce: BOOL) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetCancelConnection2A(lpName: LPCSTR, dwFlags: DWORD, fForce: BOOL) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetCancelConnection2W(lpName: LPCWSTR, dwFlags: DWORD, fForce: BOOL) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetGetConnectionA(lpLocalName: LPCSTR, lpRemoteName: LPSTR, lpnLength: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetGetConnectionW(lpLocalName: LPCWSTR, lpRemoteName: LPWSTR, lpnLength: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetRestoreSingleConnectionW(hwndParent: HWND, lpDevice: LPCWSTR, fUseUI: BOOL) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetUseConnectionA(hwndOwner: HWND, lpNetResource: LPNETRESOURCEA, lpPassword: LPCSTR, lpUserId: LPCSTR, dwFlags: DWORD, lpAccessName: LPSTR, lpBufferSize: LPDWORD, lpResult: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetUseConnectionW(hwndOwner: HWND, lpNetResource: LPNETRESOURCEW, lpPassword: LPCWSTR, lpUserId: LPCWSTR, dwFlags: DWORD, lpAccessName: LPWSTR, lpBufferSize: LPDWORD, lpResult: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetConnectionDialog(hwnd: HWND, dwType: DWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetDisconnectDialog(hwnd: HWND, dwType: DWORD) callconv(.Stdcall) DWORD;
pub const struct__CONNECTDLGSTRUCTA = extern struct {
    cbStructure: DWORD,
    hwndOwner: HWND,
    lpConnRes: LPNETRESOURCEA,
    dwFlags: DWORD,
    dwDevNum: DWORD,
};
pub const CONNECTDLGSTRUCTA = struct__CONNECTDLGSTRUCTA;
pub const LPCONNECTDLGSTRUCTA = [*c]struct__CONNECTDLGSTRUCTA;
pub const struct__CONNECTDLGSTRUCTW = extern struct {
    cbStructure: DWORD,
    hwndOwner: HWND,
    lpConnRes: LPNETRESOURCEW,
    dwFlags: DWORD,
    dwDevNum: DWORD,
};
pub const CONNECTDLGSTRUCTW = struct__CONNECTDLGSTRUCTW;
pub const LPCONNECTDLGSTRUCTW = [*c]struct__CONNECTDLGSTRUCTW;
pub const CONNECTDLGSTRUCT = CONNECTDLGSTRUCTA;
pub const LPCONNECTDLGSTRUCT = LPCONNECTDLGSTRUCTA;
pub extern "mpr" fn WNetConnectionDialog1A(lpConnDlgStruct: LPCONNECTDLGSTRUCTA) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetConnectionDialog1W(lpConnDlgStruct: LPCONNECTDLGSTRUCTW) callconv(.Stdcall) DWORD;
pub const struct__DISCDLGSTRUCTA = extern struct {
    cbStructure: DWORD,
    hwndOwner: HWND,
    lpLocalName: LPSTR,
    lpRemoteName: LPSTR,
    dwFlags: DWORD,
};
pub const DISCDLGSTRUCTA = struct__DISCDLGSTRUCTA;
pub const LPDISCDLGSTRUCTA = [*c]struct__DISCDLGSTRUCTA;
pub const struct__DISCDLGSTRUCTW = extern struct {
    cbStructure: DWORD,
    hwndOwner: HWND,
    lpLocalName: LPWSTR,
    lpRemoteName: LPWSTR,
    dwFlags: DWORD,
};
pub const DISCDLGSTRUCTW = struct__DISCDLGSTRUCTW;
pub const LPDISCDLGSTRUCTW = [*c]struct__DISCDLGSTRUCTW;
pub const DISCDLGSTRUCT = DISCDLGSTRUCTA;
pub const LPDISCDLGSTRUCT = LPDISCDLGSTRUCTA;
pub extern "mpr" fn WNetDisconnectDialog1A(lpConnDlgStruct: LPDISCDLGSTRUCTA) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetDisconnectDialog1W(lpConnDlgStruct: LPDISCDLGSTRUCTW) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetOpenEnumA(dwScope: DWORD, dwType: DWORD, dwUsage: DWORD, lpNetResource: LPNETRESOURCEA, lphEnum: LPHANDLE) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetOpenEnumW(dwScope: DWORD, dwType: DWORD, dwUsage: DWORD, lpNetResource: LPNETRESOURCEW, lphEnum: LPHANDLE) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetEnumResourceA(hEnum: HANDLE, lpcCount: LPDWORD, lpBuffer: LPVOID, lpBufferSize: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetEnumResourceW(hEnum: HANDLE, lpcCount: LPDWORD, lpBuffer: LPVOID, lpBufferSize: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetCloseEnum(hEnum: HANDLE) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetGetResourceParentA(lpNetResource: LPNETRESOURCEA, lpBuffer: LPVOID, lpcbBuffer: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetGetResourceParentW(lpNetResource: LPNETRESOURCEW, lpBuffer: LPVOID, lpcbBuffer: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetGetResourceInformationA(lpNetResource: LPNETRESOURCEA, lpBuffer: LPVOID, lpcbBuffer: LPDWORD, lplpSystem: [*c]LPSTR) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetGetResourceInformationW(lpNetResource: LPNETRESOURCEW, lpBuffer: LPVOID, lpcbBuffer: LPDWORD, lplpSystem: [*c]LPWSTR) callconv(.Stdcall) DWORD;
pub const struct__UNIVERSAL_NAME_INFOA = extern struct {
    lpUniversalName: LPSTR,
};
pub const UNIVERSAL_NAME_INFOA = struct__UNIVERSAL_NAME_INFOA;
pub const LPUNIVERSAL_NAME_INFOA = [*c]struct__UNIVERSAL_NAME_INFOA;
pub const struct__UNIVERSAL_NAME_INFOW = extern struct {
    lpUniversalName: LPWSTR,
};
pub const UNIVERSAL_NAME_INFOW = struct__UNIVERSAL_NAME_INFOW;
pub const LPUNIVERSAL_NAME_INFOW = [*c]struct__UNIVERSAL_NAME_INFOW;
pub const UNIVERSAL_NAME_INFO = UNIVERSAL_NAME_INFOA;
pub const LPUNIVERSAL_NAME_INFO = LPUNIVERSAL_NAME_INFOA;
pub const struct__REMOTE_NAME_INFOA = extern struct {
    lpUniversalName: LPSTR,
    lpConnectionName: LPSTR,
    lpRemainingPath: LPSTR,
};
pub const REMOTE_NAME_INFOA = struct__REMOTE_NAME_INFOA;
pub const LPREMOTE_NAME_INFOA = [*c]struct__REMOTE_NAME_INFOA;
pub const struct__REMOTE_NAME_INFOW = extern struct {
    lpUniversalName: LPWSTR,
    lpConnectionName: LPWSTR,
    lpRemainingPath: LPWSTR,
};
pub const REMOTE_NAME_INFOW = struct__REMOTE_NAME_INFOW;
pub const LPREMOTE_NAME_INFOW = [*c]struct__REMOTE_NAME_INFOW;
pub const REMOTE_NAME_INFO = REMOTE_NAME_INFOA;
pub const LPREMOTE_NAME_INFO = LPREMOTE_NAME_INFOA;
pub extern "mpr" fn WNetGetUniversalNameA(lpLocalPath: LPCSTR, dwInfoLevel: DWORD, lpBuffer: LPVOID, lpBufferSize: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetGetUniversalNameW(lpLocalPath: LPCWSTR, dwInfoLevel: DWORD, lpBuffer: LPVOID, lpBufferSize: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetGetUserA(lpName: LPCSTR, lpUserName: LPSTR, lpnLength: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetGetUserW(lpName: LPCWSTR, lpUserName: LPWSTR, lpnLength: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetGetProviderNameA(dwNetType: DWORD, lpProviderName: LPSTR, lpBufferSize: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetGetProviderNameW(dwNetType: DWORD, lpProviderName: LPWSTR, lpBufferSize: LPDWORD) callconv(.Stdcall) DWORD;
pub const struct__NETINFOSTRUCT = extern struct {
    cbStructure: DWORD,
    dwProviderVersion: DWORD,
    dwStatus: DWORD,
    dwCharacteristics: DWORD,
    dwHandle: ULONG_PTR,
    wNetType: WORD,
    dwPrinters: DWORD,
    dwDrives: DWORD,
};
pub const NETINFOSTRUCT = struct__NETINFOSTRUCT;
pub const LPNETINFOSTRUCT = [*c]struct__NETINFOSTRUCT;
pub extern "mpr" fn WNetGetNetworkInformationA(lpProvider: LPCSTR, lpNetInfoStruct: LPNETINFOSTRUCT) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetGetNetworkInformationW(lpProvider: LPCWSTR, lpNetInfoStruct: LPNETINFOSTRUCT) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetGetLastErrorA(lpError: LPDWORD, lpErrorBuf: LPSTR, nErrorBufSize: DWORD, lpNameBuf: LPSTR, nNameBufSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "mpr" fn WNetGetLastErrorW(lpError: LPDWORD, lpErrorBuf: LPWSTR, nErrorBufSize: DWORD, lpNameBuf: LPWSTR, nNameBufSize: DWORD) callconv(.Stdcall) DWORD;
pub const struct__NETCONNECTINFOSTRUCT = extern struct {
    cbStructure: DWORD,
    dwFlags: DWORD,
    dwSpeed: DWORD,
    dwDelay: DWORD,
    dwOptDataSize: DWORD,
};
pub const NETCONNECTINFOSTRUCT = struct__NETCONNECTINFOSTRUCT;
pub const LPNETCONNECTINFOSTRUCT = [*c]struct__NETCONNECTINFOSTRUCT;
pub extern "mpr" fn MultinetGetConnectionPerformanceA(lpNetResource: LPNETRESOURCEA, lpNetConnectInfoStruct: LPNETCONNECTINFOSTRUCT) callconv(.Stdcall) DWORD;
pub extern "mpr" fn MultinetGetConnectionPerformanceW(lpNetResource: LPNETRESOURCEW, lpNetConnectInfoStruct: LPNETCONNECTINFOSTRUCT) callconv(.Stdcall) DWORD;
pub const DDEACK = @OpaqueType();
pub const DDEADVISE = @OpaqueType();
pub const DDEDATA = @OpaqueType();
pub const DDEPOKE = @OpaqueType();
pub const DDELN = @OpaqueType();
pub const DDEUP = @OpaqueType();
pub extern "user32" fn DdeSetQualityOfService(hwndClient: HWND, pqosNew: [*c]const SECURITY_QUALITY_OF_SERVICE, pqosPrev: PSECURITY_QUALITY_OF_SERVICE) callconv(.Stdcall) BOOL;
pub extern "user32" fn ImpersonateDdeClientWindow(hWndClient: HWND, hWndServer: HWND) callconv(.Stdcall) BOOL;
pub extern "user32" fn PackDDElParam(msg: UINT, uiLo: UINT_PTR, uiHi: UINT_PTR) callconv(.Stdcall) LPARAM;
pub extern "user32" fn UnpackDDElParam(msg: UINT, lParam: LPARAM, puiLo: PUINT_PTR, puiHi: PUINT_PTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn FreeDDElParam(msg: UINT, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub extern "user32" fn ReuseDDElParam(lParam: LPARAM, msgIn: UINT, msgOut: UINT, uiLo: UINT_PTR, uiHi: UINT_PTR) callconv(.Stdcall) LPARAM;
pub const struct_HCONVLIST__ = extern struct {
    unused: c_int,
};
pub const HCONVLIST = [*c]struct_HCONVLIST__;
pub const struct_HCONV__ = extern struct {
    unused: c_int,
};
pub const HCONV = [*c]struct_HCONV__;
pub const struct_HSZ__ = extern struct {
    unused: c_int,
};
pub const HSZ = [*c]struct_HSZ__;
pub const struct_HDDEDATA__ = extern struct {
    unused: c_int,
};
pub const HDDEDATA = [*c]struct_HDDEDATA__;
pub const struct_tagHSZPAIR = extern struct {
    hszSvc: HSZ,
    hszTopic: HSZ,
};
pub const HSZPAIR = struct_tagHSZPAIR;
pub const PHSZPAIR = [*c]struct_tagHSZPAIR;
pub const struct_tagCONVCONTEXT = extern struct {
    cb: UINT,
    wFlags: UINT,
    wCountryID: UINT,
    iCodePage: c_int,
    dwLangID: DWORD,
    dwSecurity: DWORD,
    qos: SECURITY_QUALITY_OF_SERVICE,
};
pub const CONVCONTEXT = struct_tagCONVCONTEXT;
pub const PCONVCONTEXT = [*c]struct_tagCONVCONTEXT;
pub const struct_tagCONVINFO = extern struct {
    cb: DWORD,
    hUser: DWORD_PTR,
    hConvPartner: HCONV,
    hszSvcPartner: HSZ,
    hszServiceReq: HSZ,
    hszTopic: HSZ,
    hszItem: HSZ,
    wFmt: UINT,
    wType: UINT,
    wStatus: UINT,
    wConvst: UINT,
    wLastError: UINT,
    hConvList: HCONVLIST,
    ConvCtxt: CONVCONTEXT,
    hwnd: HWND,
    hwndPartner: HWND,
};
pub const CONVINFO = struct_tagCONVINFO;
pub const PCONVINFO = [*c]struct_tagCONVINFO;
pub const FNCALLBACK = fn (UINT, UINT, HCONV, HSZ, HSZ, HDDEDATA, ULONG_PTR, ULONG_PTR) callconv(.C) HDDEDATA;
pub const PFNCALLBACK = ?fn (UINT, UINT, HCONV, HSZ, HSZ, HDDEDATA, ULONG_PTR, ULONG_PTR) callconv(.C) HDDEDATA;
pub extern "user32" fn DdeInitializeA(pidInst: LPDWORD, pfnCallback: PFNCALLBACK, afCmd: DWORD, ulRes: DWORD) callconv(.Stdcall) UINT;
pub extern "user32" fn DdeInitializeW(pidInst: LPDWORD, pfnCallback: PFNCALLBACK, afCmd: DWORD, ulRes: DWORD) callconv(.Stdcall) UINT;
pub extern "user32" fn DdeUninitialize(idInst: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn DdeConnectList(idInst: DWORD, hszService: HSZ, hszTopic: HSZ, hConvList: HCONVLIST, pCC: PCONVCONTEXT) callconv(.Stdcall) HCONVLIST;
pub extern "user32" fn DdeQueryNextServer(hConvList: HCONVLIST, hConvPrev: HCONV) callconv(.Stdcall) HCONV;
pub extern "user32" fn DdeDisconnectList(hConvList: HCONVLIST) callconv(.Stdcall) BOOL;
pub extern "user32" fn DdeConnect(idInst: DWORD, hszService: HSZ, hszTopic: HSZ, pCC: PCONVCONTEXT) callconv(.Stdcall) HCONV;
pub extern "user32" fn DdeDisconnect(hConv: HCONV) callconv(.Stdcall) BOOL;
pub extern "user32" fn DdeReconnect(hConv: HCONV) callconv(.Stdcall) HCONV;
pub extern "user32" fn DdeQueryConvInfo(hConv: HCONV, idTransaction: DWORD, pConvInfo: PCONVINFO) callconv(.Stdcall) UINT;
pub extern "user32" fn DdeSetUserHandle(hConv: HCONV, id: DWORD, hUser: DWORD_PTR) callconv(.Stdcall) BOOL;
pub extern "user32" fn DdeAbandonTransaction(idInst: DWORD, hConv: HCONV, idTransaction: DWORD) callconv(.Stdcall) BOOL;
pub extern "user32" fn DdePostAdvise(idInst: DWORD, hszTopic: HSZ, hszItem: HSZ) callconv(.Stdcall) BOOL;
pub extern "user32" fn DdeEnableCallback(idInst: DWORD, hConv: HCONV, wCmd: UINT) callconv(.Stdcall) BOOL;
pub extern "user32" fn DdeImpersonateClient(hConv: HCONV) callconv(.Stdcall) BOOL;
pub extern "user32" fn DdeNameService(idInst: DWORD, hsz1: HSZ, hsz2: HSZ, afCmd: UINT) callconv(.Stdcall) HDDEDATA;
pub extern "user32" fn DdeClientTransaction(pData: LPBYTE, cbData: DWORD, hConv: HCONV, hszItem: HSZ, wFmt: UINT, wType: UINT, dwTimeout: DWORD, pdwResult: LPDWORD) callconv(.Stdcall) HDDEDATA;
pub extern "user32" fn DdeCreateDataHandle(idInst: DWORD, pSrc: LPBYTE, cb: DWORD, cbOff: DWORD, hszItem: HSZ, wFmt: UINT, afCmd: UINT) callconv(.Stdcall) HDDEDATA;
pub extern "user32" fn DdeAddData(hData: HDDEDATA, pSrc: LPBYTE, cb: DWORD, cbOff: DWORD) callconv(.Stdcall) HDDEDATA;
pub extern "user32" fn DdeGetData(hData: HDDEDATA, pDst: LPBYTE, cbMax: DWORD, cbOff: DWORD) callconv(.Stdcall) DWORD;
pub extern "user32" fn DdeAccessData(hData: HDDEDATA, pcbDataSize: LPDWORD) callconv(.Stdcall) LPBYTE;
pub extern "user32" fn DdeUnaccessData(hData: HDDEDATA) callconv(.Stdcall) BOOL;
pub extern "user32" fn DdeFreeDataHandle(hData: HDDEDATA) callconv(.Stdcall) BOOL;
pub extern "user32" fn DdeGetLastError(idInst: DWORD) callconv(.Stdcall) UINT;
pub extern "user32" fn DdeCreateStringHandleA(idInst: DWORD, psz: LPCSTR, iCodePage: c_int) callconv(.Stdcall) HSZ;
pub extern "user32" fn DdeCreateStringHandleW(idInst: DWORD, psz: LPCWSTR, iCodePage: c_int) callconv(.Stdcall) HSZ;
pub extern "user32" fn DdeQueryStringA(idInst: DWORD, hsz: HSZ, psz: LPSTR, cchMax: DWORD, iCodePage: c_int) callconv(.Stdcall) DWORD;
pub extern "user32" fn DdeQueryStringW(idInst: DWORD, hsz: HSZ, psz: LPWSTR, cchMax: DWORD, iCodePage: c_int) callconv(.Stdcall) DWORD;
pub extern "user32" fn DdeFreeStringHandle(idInst: DWORD, hsz: HSZ) callconv(.Stdcall) BOOL;
pub extern "user32" fn DdeKeepStringHandle(idInst: DWORD, hsz: HSZ) callconv(.Stdcall) BOOL;
pub extern "user32" fn DdeCmpStringHandles(hsz1: HSZ, hsz2: HSZ) callconv(.Stdcall) c_int;
pub const struct_tagDDEML_MSG_HOOK_DATA = extern struct {
    uiLo: UINT_PTR,
    uiHi: UINT_PTR,
    cbData: DWORD,
    Data: [8]DWORD,
};
pub const DDEML_MSG_HOOK_DATA = struct_tagDDEML_MSG_HOOK_DATA;
pub const PDDEML_MSG_HOOK_DATA = [*c]struct_tagDDEML_MSG_HOOK_DATA;
pub const struct_tagMONMSGSTRUCT = extern struct {
    cb: UINT,
    hwndTo: HWND,
    dwTime: DWORD,
    hTask: HANDLE,
    wMsg: UINT,
    wParam: WPARAM,
    lParam: LPARAM,
    dmhd: DDEML_MSG_HOOK_DATA,
};
pub const MONMSGSTRUCT = struct_tagMONMSGSTRUCT;
pub const PMONMSGSTRUCT = [*c]struct_tagMONMSGSTRUCT;
pub const struct_tagMONCBSTRUCT = extern struct {
    cb: UINT,
    dwTime: DWORD,
    hTask: HANDLE,
    dwRet: DWORD,
    wType: UINT,
    wFmt: UINT,
    hConv: HCONV,
    hsz1: HSZ,
    hsz2: HSZ,
    hData: HDDEDATA,
    dwData1: ULONG_PTR,
    dwData2: ULONG_PTR,
    cc: CONVCONTEXT,
    cbData: DWORD,
    Data: [8]DWORD,
};
pub const MONCBSTRUCT = struct_tagMONCBSTRUCT;
pub const PMONCBSTRUCT = [*c]struct_tagMONCBSTRUCT;
pub const struct_tagMONHSZSTRUCTA = extern struct {
    cb: UINT,
    fsAction: BOOL,
    dwTime: DWORD,
    hsz: HSZ,
    hTask: HANDLE,
    str: [1]CHAR,
};
pub const MONHSZSTRUCTA = struct_tagMONHSZSTRUCTA;
pub const PMONHSZSTRUCTA = [*c]struct_tagMONHSZSTRUCTA;
pub const struct_tagMONHSZSTRUCTW = extern struct {
    cb: UINT,
    fsAction: BOOL,
    dwTime: DWORD,
    hsz: HSZ,
    hTask: HANDLE,
    str: [1]WCHAR,
};
pub const MONHSZSTRUCTW = struct_tagMONHSZSTRUCTW;
pub const PMONHSZSTRUCTW = [*c]struct_tagMONHSZSTRUCTW;
pub const MONHSZSTRUCT = MONHSZSTRUCTA;
pub const PMONHSZSTRUCT = PMONHSZSTRUCTA;
pub const struct_tagMONERRSTRUCT = extern struct {
    cb: UINT,
    wLastError: UINT,
    dwTime: DWORD,
    hTask: HANDLE,
};
pub const MONERRSTRUCT = struct_tagMONERRSTRUCT;
pub const PMONERRSTRUCT = [*c]struct_tagMONERRSTRUCT;
pub const struct_tagMONLINKSTRUCT = extern struct {
    cb: UINT,
    dwTime: DWORD,
    hTask: HANDLE,
    fEstablished: BOOL,
    fNoData: BOOL,
    hszSvc: HSZ,
    hszTopic: HSZ,
    hszItem: HSZ,
    wFmt: UINT,
    fServer: BOOL,
    hConvServer: HCONV,
    hConvClient: HCONV,
};
pub const MONLINKSTRUCT = struct_tagMONLINKSTRUCT;
pub const PMONLINKSTRUCT = [*c]struct_tagMONLINKSTRUCT;
pub const struct_tagMONCONVSTRUCT = extern struct {
    cb: UINT,
    fConnect: BOOL,
    dwTime: DWORD,
    hTask: HANDLE,
    hszSvc: HSZ,
    hszTopic: HSZ,
    hConvClient: HCONV,
    hConvServer: HCONV,
};
pub const MONCONVSTRUCT = struct_tagMONCONVSTRUCT;
pub const PMONCONVSTRUCT = [*c]struct_tagMONCONVSTRUCT;
pub const struct_tagCRGB = extern struct {
    bRed: BYTE,
    bGreen: BYTE,
    bBlue: BYTE,
    bExtra: BYTE,
};
pub const CRGB = struct_tagCRGB;
pub extern "lz32" fn LZStart() callconv(.Stdcall) INT;
pub extern "lz32" fn LZDone() callconv(.Stdcall) void;
pub extern "lz32" fn CopyLZFile(hfSource: INT, hfDest: INT) callconv(.Stdcall) LONG;
pub extern "lz32" fn LZCopy(hfSource: INT, hfDest: INT) callconv(.Stdcall) LONG;
pub extern "lz32" fn LZInit(hfSource: INT) callconv(.Stdcall) INT;
pub extern "lz32" fn GetExpandedNameA(lpszSource: LPSTR, lpszBuffer: LPSTR) callconv(.Stdcall) INT;
pub extern "lz32" fn GetExpandedNameW(lpszSource: LPWSTR, lpszBuffer: LPWSTR) callconv(.Stdcall) INT;
pub extern "lz32" fn LZOpenFileA(lpFileName: LPSTR, lpReOpenBuf: LPOFSTRUCT, wStyle: WORD) callconv(.Stdcall) INT;
pub extern "lz32" fn LZOpenFileW(lpFileName: LPWSTR, lpReOpenBuf: LPOFSTRUCT, wStyle: WORD) callconv(.Stdcall) INT;
pub extern "lz32" fn LZSeek(hFile: INT, lOffset: LONG, iOrigin: INT) callconv(.Stdcall) LONG;
pub extern "lz32" fn LZRead(hFile: INT, lpBuffer: [*c]CHAR, cbRead: INT) callconv(.Stdcall) INT;
pub extern "lz32" fn LZClose(hFile: INT) callconv(.Stdcall) void;
pub const MMVERSION = UINT;
pub const MMRESULT = UINT;
pub const LPUINT = [*c]UINT;
pub const struct_mmtime_tag = extern struct {
    wType: UINT,
    u: extern union {
        ms: DWORD,
        sample: DWORD,
        cb: DWORD,
        ticks: DWORD,
        smpte: extern struct {
            hour: BYTE,
            min: BYTE,
            sec: BYTE,
            frame: BYTE,
            fps: BYTE,
            dummy: BYTE,
            pad: [2]BYTE,
        },
        midi: extern struct {
            songptrpos: DWORD,
        },
    },
};
pub const MMTIME = struct_mmtime_tag;
pub const PMMTIME = [*c]struct_mmtime_tag;
pub const NPMMTIME = [*c]struct_mmtime_tag;
pub const LPMMTIME = [*c]struct_mmtime_tag;
pub const struct_HDRVR__ = extern struct {
    unused: c_int,
};
pub const HDRVR = [*c]struct_HDRVR__;
pub const DRVCALLBACK = fn (HDRVR, UINT, DWORD_PTR, DWORD_PTR, DWORD_PTR) callconv(.C) void;
pub const LPDRVCALLBACK = [*c]DRVCALLBACK;
pub const PDRVCALLBACK = [*c]DRVCALLBACK;
pub const MCIERROR = DWORD;
pub const MCIDEVICEID = UINT;
pub const YIELDPROC = ?fn (MCIDEVICEID, DWORD) callconv(.C) UINT;
pub extern "winmm" fn mciSendCommandA(mciId: MCIDEVICEID, uMsg: UINT, dwParam1: DWORD_PTR, dwParam2: DWORD_PTR) callconv(.Stdcall) MCIERROR;
pub extern "winmm" fn mciSendCommandW(mciId: MCIDEVICEID, uMsg: UINT, dwParam1: DWORD_PTR, dwParam2: DWORD_PTR) callconv(.Stdcall) MCIERROR;
pub extern "winmm" fn mciSendStringA(lpstrCommand: LPCSTR, lpstrReturnString: LPSTR, uReturnLength: UINT, hwndCallback: HWND) callconv(.Stdcall) MCIERROR;
pub extern "winmm" fn mciSendStringW(lpstrCommand: LPCWSTR, lpstrReturnString: LPWSTR, uReturnLength: UINT, hwndCallback: HWND) callconv(.Stdcall) MCIERROR;
pub extern "winmm" fn mciGetDeviceIDA(pszDevice: LPCSTR) callconv(.Stdcall) MCIDEVICEID;
pub extern "winmm" fn mciGetDeviceIDW(pszDevice: LPCWSTR) callconv(.Stdcall) MCIDEVICEID;
pub extern "winmm" fn mciGetDeviceIDFromElementIDA(dwElementID: DWORD, lpstrType: LPCSTR) callconv(.Stdcall) MCIDEVICEID;
pub extern "winmm" fn mciGetDeviceIDFromElementIDW(dwElementID: DWORD, lpstrType: LPCWSTR) callconv(.Stdcall) MCIDEVICEID;
pub extern "winmm" fn mciGetErrorStringA(mcierr: MCIERROR, pszText: LPSTR, cchText: UINT) callconv(.Stdcall) BOOL;
pub extern "winmm" fn mciGetErrorStringW(mcierr: MCIERROR, pszText: LPWSTR, cchText: UINT) callconv(.Stdcall) BOOL;
pub extern "winmm" fn mciSetYieldProc(mciId: MCIDEVICEID, fpYieldProc: YIELDPROC, dwYieldData: DWORD) callconv(.Stdcall) BOOL;
pub extern "winmm" fn mciGetCreatorTask(mciId: MCIDEVICEID) callconv(.Stdcall) HTASK;
pub extern "winmm" fn mciGetYieldProc(mciId: MCIDEVICEID, pdwYieldData: LPDWORD) callconv(.Stdcall) YIELDPROC;
pub const struct_tagMCI_GENERIC_PARMS = extern struct {
    dwCallback: DWORD_PTR,
};
pub const MCI_GENERIC_PARMS = struct_tagMCI_GENERIC_PARMS;
pub const PMCI_GENERIC_PARMS = [*c]struct_tagMCI_GENERIC_PARMS;
pub const LPMCI_GENERIC_PARMS = [*c]struct_tagMCI_GENERIC_PARMS;
pub const struct_tagMCI_OPEN_PARMSA = extern struct {
    dwCallback: DWORD_PTR,
    wDeviceID: MCIDEVICEID,
    lpstrDeviceType: LPCSTR,
    lpstrElementName: LPCSTR,
    lpstrAlias: LPCSTR,
};
pub const MCI_OPEN_PARMSA = struct_tagMCI_OPEN_PARMSA;
pub const PMCI_OPEN_PARMSA = [*c]struct_tagMCI_OPEN_PARMSA;
pub const LPMCI_OPEN_PARMSA = [*c]struct_tagMCI_OPEN_PARMSA;
pub const struct_tagMCI_OPEN_PARMSW = extern struct {
    dwCallback: DWORD_PTR,
    wDeviceID: MCIDEVICEID,
    lpstrDeviceType: LPCWSTR,
    lpstrElementName: LPCWSTR,
    lpstrAlias: LPCWSTR,
};
pub const MCI_OPEN_PARMSW = struct_tagMCI_OPEN_PARMSW;
pub const PMCI_OPEN_PARMSW = [*c]struct_tagMCI_OPEN_PARMSW;
pub const LPMCI_OPEN_PARMSW = [*c]struct_tagMCI_OPEN_PARMSW;
pub const MCI_OPEN_PARMS = MCI_OPEN_PARMSA;
pub const PMCI_OPEN_PARMS = PMCI_OPEN_PARMSA;
pub const LPMCI_OPEN_PARMS = LPMCI_OPEN_PARMSA;
pub const struct_tagMCI_PLAY_PARMS = extern struct {
    dwCallback: DWORD_PTR,
    dwFrom: DWORD,
    dwTo: DWORD,
};
pub const MCI_PLAY_PARMS = struct_tagMCI_PLAY_PARMS;
pub const PMCI_PLAY_PARMS = [*c]struct_tagMCI_PLAY_PARMS;
pub const LPMCI_PLAY_PARMS = [*c]struct_tagMCI_PLAY_PARMS;
pub const struct_tagMCI_SEEK_PARMS = extern struct {
    dwCallback: DWORD_PTR,
    dwTo: DWORD,
};
pub const MCI_SEEK_PARMS = struct_tagMCI_SEEK_PARMS;
pub const PMCI_SEEK_PARMS = [*c]struct_tagMCI_SEEK_PARMS;
pub const LPMCI_SEEK_PARMS = [*c]struct_tagMCI_SEEK_PARMS;
pub const struct_tagMCI_STATUS_PARMS = extern struct {
    dwCallback: DWORD_PTR,
    dwReturn: DWORD_PTR,
    dwItem: DWORD,
    dwTrack: DWORD,
};
pub const MCI_STATUS_PARMS = struct_tagMCI_STATUS_PARMS;
pub const PMCI_STATUS_PARMS = [*c]struct_tagMCI_STATUS_PARMS;
pub const LPMCI_STATUS_PARMS = [*c]struct_tagMCI_STATUS_PARMS;
pub const struct_tagMCI_INFO_PARMSA = extern struct {
    dwCallback: DWORD_PTR,
    lpstrReturn: LPSTR,
    dwRetSize: DWORD,
};
pub const MCI_INFO_PARMSA = struct_tagMCI_INFO_PARMSA;
pub const LPMCI_INFO_PARMSA = [*c]struct_tagMCI_INFO_PARMSA;
pub const struct_tagMCI_INFO_PARMSW = extern struct {
    dwCallback: DWORD_PTR,
    lpstrReturn: LPWSTR,
    dwRetSize: DWORD,
};
pub const MCI_INFO_PARMSW = struct_tagMCI_INFO_PARMSW;
pub const LPMCI_INFO_PARMSW = [*c]struct_tagMCI_INFO_PARMSW;
pub const MCI_INFO_PARMS = MCI_INFO_PARMSA;
pub const LPMCI_INFO_PARMS = LPMCI_INFO_PARMSA;
pub const struct_tagMCI_GETDEVCAPS_PARMS = extern struct {
    dwCallback: DWORD_PTR,
    dwReturn: DWORD,
    dwItem: DWORD,
};
pub const MCI_GETDEVCAPS_PARMS = struct_tagMCI_GETDEVCAPS_PARMS;
pub const PMCI_GETDEVCAPS_PARMS = [*c]struct_tagMCI_GETDEVCAPS_PARMS;
pub const LPMCI_GETDEVCAPS_PARMS = [*c]struct_tagMCI_GETDEVCAPS_PARMS;
pub const struct_tagMCI_SYSINFO_PARMSA = extern struct {
    dwCallback: DWORD_PTR,
    lpstrReturn: LPSTR,
    dwRetSize: DWORD,
    dwNumber: DWORD,
    wDeviceType: UINT,
};
pub const MCI_SYSINFO_PARMSA = struct_tagMCI_SYSINFO_PARMSA;
pub const PMCI_SYSINFO_PARMSA = [*c]struct_tagMCI_SYSINFO_PARMSA;
pub const LPMCI_SYSINFO_PARMSA = [*c]struct_tagMCI_SYSINFO_PARMSA;
pub const struct_tagMCI_SYSINFO_PARMSW = extern struct {
    dwCallback: DWORD_PTR,
    lpstrReturn: LPWSTR,
    dwRetSize: DWORD,
    dwNumber: DWORD,
    wDeviceType: UINT,
};
pub const MCI_SYSINFO_PARMSW = struct_tagMCI_SYSINFO_PARMSW;
pub const PMCI_SYSINFO_PARMSW = [*c]struct_tagMCI_SYSINFO_PARMSW;
pub const LPMCI_SYSINFO_PARMSW = [*c]struct_tagMCI_SYSINFO_PARMSW;
pub const MCI_SYSINFO_PARMS = MCI_SYSINFO_PARMSA;
pub const PMCI_SYSINFO_PARMS = PMCI_SYSINFO_PARMSA;
pub const LPMCI_SYSINFO_PARMS = LPMCI_SYSINFO_PARMSA;
pub const struct_tagMCI_SET_PARMS = extern struct {
    dwCallback: DWORD_PTR,
    dwTimeFormat: DWORD,
    dwAudio: DWORD,
};
pub const MCI_SET_PARMS = struct_tagMCI_SET_PARMS;
pub const PMCI_SET_PARMS = [*c]struct_tagMCI_SET_PARMS;
pub const LPMCI_SET_PARMS = [*c]struct_tagMCI_SET_PARMS;
pub const struct_tagMCI_BREAK_PARMS = extern struct {
    dwCallback: DWORD_PTR,
    nVirtKey: c_int,
    hwndBreak: HWND,
};
pub const MCI_BREAK_PARMS = struct_tagMCI_BREAK_PARMS;
pub const PMCI_BREAK_PARMS = [*c]struct_tagMCI_BREAK_PARMS;
pub const LPMCI_BREAK_PARMS = [*c]struct_tagMCI_BREAK_PARMS;
pub const struct_tagMCI_SAVE_PARMSA = extern struct {
    dwCallback: DWORD_PTR,
    lpfilename: LPCSTR,
};
pub const MCI_SAVE_PARMSA = struct_tagMCI_SAVE_PARMSA;
pub const PMCI_SAVE_PARMSA = [*c]struct_tagMCI_SAVE_PARMSA;
pub const LPMCI_SAVE_PARMSA = [*c]struct_tagMCI_SAVE_PARMSA;
pub const struct_tagMCI_SAVE_PARMSW = extern struct {
    dwCallback: DWORD_PTR,
    lpfilename: LPCWSTR,
};
pub const MCI_SAVE_PARMSW = struct_tagMCI_SAVE_PARMSW;
pub const PMCI_SAVE_PARMSW = [*c]struct_tagMCI_SAVE_PARMSW;
pub const LPMCI_SAVE_PARMSW = [*c]struct_tagMCI_SAVE_PARMSW;
pub const MCI_SAVE_PARMS = MCI_SAVE_PARMSA;
pub const PMCI_SAVE_PARMS = PMCI_SAVE_PARMSA;
pub const LPMCI_SAVE_PARMS = LPMCI_SAVE_PARMSA;
pub const struct_tagMCI_LOAD_PARMSA = extern struct {
    dwCallback: DWORD_PTR,
    lpfilename: LPCSTR,
};
pub const MCI_LOAD_PARMSA = struct_tagMCI_LOAD_PARMSA;
pub const PMCI_LOAD_PARMSA = [*c]struct_tagMCI_LOAD_PARMSA;
pub const LPMCI_LOAD_PARMSA = [*c]struct_tagMCI_LOAD_PARMSA;
pub const struct_tagMCI_LOAD_PARMSW = extern struct {
    dwCallback: DWORD_PTR,
    lpfilename: LPCWSTR,
};
pub const MCI_LOAD_PARMSW = struct_tagMCI_LOAD_PARMSW;
pub const PMCI_LOAD_PARMSW = [*c]struct_tagMCI_LOAD_PARMSW;
pub const LPMCI_LOAD_PARMSW = [*c]struct_tagMCI_LOAD_PARMSW;
pub const MCI_LOAD_PARMS = MCI_LOAD_PARMSA;
pub const PMCI_LOAD_PARMS = PMCI_LOAD_PARMSA;
pub const LPMCI_LOAD_PARMS = LPMCI_LOAD_PARMSA;
pub const struct_tagMCI_RECORD_PARMS = extern struct {
    dwCallback: DWORD_PTR,
    dwFrom: DWORD,
    dwTo: DWORD,
};
pub const MCI_RECORD_PARMS = struct_tagMCI_RECORD_PARMS;
pub const LPMCI_RECORD_PARMS = [*c]struct_tagMCI_RECORD_PARMS;
pub const struct_tagMCI_VD_PLAY_PARMS = extern struct {
    dwCallback: DWORD_PTR,
    dwFrom: DWORD,
    dwTo: DWORD,
    dwSpeed: DWORD,
};
pub const MCI_VD_PLAY_PARMS = struct_tagMCI_VD_PLAY_PARMS;
pub const PMCI_VD_PLAY_PARMS = [*c]struct_tagMCI_VD_PLAY_PARMS;
pub const LPMCI_VD_PLAY_PARMS = [*c]struct_tagMCI_VD_PLAY_PARMS;
pub const struct_tagMCI_VD_STEP_PARMS = extern struct {
    dwCallback: DWORD_PTR,
    dwFrames: DWORD,
};
pub const MCI_VD_STEP_PARMS = struct_tagMCI_VD_STEP_PARMS;
pub const PMCI_VD_STEP_PARMS = [*c]struct_tagMCI_VD_STEP_PARMS;
pub const LPMCI_VD_STEP_PARMS = [*c]struct_tagMCI_VD_STEP_PARMS;
pub const struct_tagMCI_VD_ESCAPE_PARMSA = extern struct {
    dwCallback: DWORD_PTR,
    lpstrCommand: LPCSTR,
};
pub const MCI_VD_ESCAPE_PARMSA = struct_tagMCI_VD_ESCAPE_PARMSA;
pub const PMCI_VD_ESCAPE_PARMSA = [*c]struct_tagMCI_VD_ESCAPE_PARMSA;
pub const LPMCI_VD_ESCAPE_PARMSA = [*c]struct_tagMCI_VD_ESCAPE_PARMSA;
pub const struct_tagMCI_VD_ESCAPE_PARMSW = extern struct {
    dwCallback: DWORD_PTR,
    lpstrCommand: LPCWSTR,
};
pub const MCI_VD_ESCAPE_PARMSW = struct_tagMCI_VD_ESCAPE_PARMSW;
pub const PMCI_VD_ESCAPE_PARMSW = [*c]struct_tagMCI_VD_ESCAPE_PARMSW;
pub const LPMCI_VD_ESCAPE_PARMSW = [*c]struct_tagMCI_VD_ESCAPE_PARMSW;
pub const MCI_VD_ESCAPE_PARMS = MCI_VD_ESCAPE_PARMSA;
pub const PMCI_VD_ESCAPE_PARMS = PMCI_VD_ESCAPE_PARMSA;
pub const LPMCI_VD_ESCAPE_PARMS = LPMCI_VD_ESCAPE_PARMSA;
pub const struct_tagMCI_WAVE_OPEN_PARMSA = extern struct {
    dwCallback: DWORD_PTR,
    wDeviceID: MCIDEVICEID,
    lpstrDeviceType: LPCSTR,
    lpstrElementName: LPCSTR,
    lpstrAlias: LPCSTR,
    dwBufferSeconds: DWORD,
};
pub const MCI_WAVE_OPEN_PARMSA = struct_tagMCI_WAVE_OPEN_PARMSA;
pub const PMCI_WAVE_OPEN_PARMSA = [*c]struct_tagMCI_WAVE_OPEN_PARMSA;
pub const LPMCI_WAVE_OPEN_PARMSA = [*c]struct_tagMCI_WAVE_OPEN_PARMSA;
pub const struct_tagMCI_WAVE_OPEN_PARMSW = extern struct {
    dwCallback: DWORD_PTR,
    wDeviceID: MCIDEVICEID,
    lpstrDeviceType: LPCWSTR,
    lpstrElementName: LPCWSTR,
    lpstrAlias: LPCWSTR,
    dwBufferSeconds: DWORD,
};
pub const MCI_WAVE_OPEN_PARMSW = struct_tagMCI_WAVE_OPEN_PARMSW;
pub const PMCI_WAVE_OPEN_PARMSW = [*c]struct_tagMCI_WAVE_OPEN_PARMSW;
pub const LPMCI_WAVE_OPEN_PARMSW = [*c]struct_tagMCI_WAVE_OPEN_PARMSW;
pub const MCI_WAVE_OPEN_PARMS = MCI_WAVE_OPEN_PARMSA;
pub const PMCI_WAVE_OPEN_PARMS = PMCI_WAVE_OPEN_PARMSA;
pub const LPMCI_WAVE_OPEN_PARMS = LPMCI_WAVE_OPEN_PARMSA;
pub const struct_tagMCI_WAVE_DELETE_PARMS = extern struct {
    dwCallback: DWORD_PTR,
    dwFrom: DWORD,
    dwTo: DWORD,
};
pub const MCI_WAVE_DELETE_PARMS = struct_tagMCI_WAVE_DELETE_PARMS;
pub const PMCI_WAVE_DELETE_PARMS = [*c]struct_tagMCI_WAVE_DELETE_PARMS;
pub const LPMCI_WAVE_DELETE_PARMS = [*c]struct_tagMCI_WAVE_DELETE_PARMS;
pub const struct_tagMCI_WAVE_SET_PARMS = extern struct {
    dwCallback: DWORD_PTR,
    dwTimeFormat: DWORD,
    dwAudio: DWORD,
    wInput: UINT,
    wOutput: UINT,
    wFormatTag: WORD,
    wReserved2: WORD,
    nChannels: WORD,
    wReserved3: WORD,
    nSamplesPerSec: DWORD,
    nAvgBytesPerSec: DWORD,
    nBlockAlign: WORD,
    wReserved4: WORD,
    wBitsPerSample: WORD,
    wReserved5: WORD,
};
pub const MCI_WAVE_SET_PARMS = struct_tagMCI_WAVE_SET_PARMS;
pub const PMCI_WAVE_SET_PARMS = [*c]struct_tagMCI_WAVE_SET_PARMS;
pub const LPMCI_WAVE_SET_PARMS = [*c]struct_tagMCI_WAVE_SET_PARMS;
pub const struct_tagMCI_SEQ_SET_PARMS = extern struct {
    dwCallback: DWORD_PTR,
    dwTimeFormat: DWORD,
    dwAudio: DWORD,
    dwTempo: DWORD,
    dwPort: DWORD,
    dwSlave: DWORD,
    dwMaster: DWORD,
    dwOffset: DWORD,
};
pub const MCI_SEQ_SET_PARMS = struct_tagMCI_SEQ_SET_PARMS;
pub const PMCI_SEQ_SET_PARMS = [*c]struct_tagMCI_SEQ_SET_PARMS;
pub const LPMCI_SEQ_SET_PARMS = [*c]struct_tagMCI_SEQ_SET_PARMS;
pub const struct_tagMCI_ANIM_OPEN_PARMSA = extern struct {
    dwCallback: DWORD_PTR,
    wDeviceID: MCIDEVICEID,
    lpstrDeviceType: LPCSTR,
    lpstrElementName: LPCSTR,
    lpstrAlias: LPCSTR,
    dwStyle: DWORD,
    hWndParent: HWND,
};
pub const MCI_ANIM_OPEN_PARMSA = struct_tagMCI_ANIM_OPEN_PARMSA;
pub const PMCI_ANIM_OPEN_PARMSA = [*c]struct_tagMCI_ANIM_OPEN_PARMSA;
pub const LPMCI_ANIM_OPEN_PARMSA = [*c]struct_tagMCI_ANIM_OPEN_PARMSA;
pub const struct_tagMCI_ANIM_OPEN_PARMSW = extern struct {
    dwCallback: DWORD_PTR,
    wDeviceID: MCIDEVICEID,
    lpstrDeviceType: LPCWSTR,
    lpstrElementName: LPCWSTR,
    lpstrAlias: LPCWSTR,
    dwStyle: DWORD,
    hWndParent: HWND,
};
pub const MCI_ANIM_OPEN_PARMSW = struct_tagMCI_ANIM_OPEN_PARMSW;
pub const PMCI_ANIM_OPEN_PARMSW = [*c]struct_tagMCI_ANIM_OPEN_PARMSW;
pub const LPMCI_ANIM_OPEN_PARMSW = [*c]struct_tagMCI_ANIM_OPEN_PARMSW;
pub const MCI_ANIM_OPEN_PARMS = MCI_ANIM_OPEN_PARMSA;
pub const PMCI_ANIM_OPEN_PARMS = PMCI_ANIM_OPEN_PARMSA;
pub const LPMCI_ANIM_OPEN_PARMS = LPMCI_ANIM_OPEN_PARMSA;
pub const struct_tagMCI_ANIM_PLAY_PARMS = extern struct {
    dwCallback: DWORD_PTR,
    dwFrom: DWORD,
    dwTo: DWORD,
    dwSpeed: DWORD,
};
pub const MCI_ANIM_PLAY_PARMS = struct_tagMCI_ANIM_PLAY_PARMS;
pub const PMCI_ANIM_PLAY_PARMS = [*c]struct_tagMCI_ANIM_PLAY_PARMS;
pub const LPMCI_ANIM_PLAY_PARMS = [*c]struct_tagMCI_ANIM_PLAY_PARMS;
pub const struct_tagMCI_ANIM_STEP_PARMS = extern struct {
    dwCallback: DWORD_PTR,
    dwFrames: DWORD,
};
pub const MCI_ANIM_STEP_PARMS = struct_tagMCI_ANIM_STEP_PARMS;
pub const PMCI_ANIM_STEP_PARMS = [*c]struct_tagMCI_ANIM_STEP_PARMS;
pub const LPMCI_ANIM_STEP_PARMS = [*c]struct_tagMCI_ANIM_STEP_PARMS;
pub const struct_tagMCI_ANIM_WINDOW_PARMSA = extern struct {
    dwCallback: DWORD_PTR,
    hWnd: HWND,
    nCmdShow: UINT,
    lpstrText: LPCSTR,
};
pub const MCI_ANIM_WINDOW_PARMSA = struct_tagMCI_ANIM_WINDOW_PARMSA;
pub const PMCI_ANIM_WINDOW_PARMSA = [*c]struct_tagMCI_ANIM_WINDOW_PARMSA;
pub const LPMCI_ANIM_WINDOW_PARMSA = [*c]struct_tagMCI_ANIM_WINDOW_PARMSA;
pub const struct_tagMCI_ANIM_WINDOW_PARMSW = extern struct {
    dwCallback: DWORD_PTR,
    hWnd: HWND,
    nCmdShow: UINT,
    lpstrText: LPCWSTR,
};
pub const MCI_ANIM_WINDOW_PARMSW = struct_tagMCI_ANIM_WINDOW_PARMSW;
pub const PMCI_ANIM_WINDOW_PARMSW = [*c]struct_tagMCI_ANIM_WINDOW_PARMSW;
pub const LPMCI_ANIM_WINDOW_PARMSW = [*c]struct_tagMCI_ANIM_WINDOW_PARMSW;
pub const MCI_ANIM_WINDOW_PARMS = MCI_ANIM_WINDOW_PARMSA;
pub const PMCI_ANIM_WINDOW_PARMS = PMCI_ANIM_WINDOW_PARMSA;
pub const LPMCI_ANIM_WINDOW_PARMS = LPMCI_ANIM_WINDOW_PARMSA;
pub const struct_tagMCI_ANIM_RECT_PARMS = extern struct {
    dwCallback: DWORD_PTR,
    rc: RECT,
};
pub const MCI_ANIM_RECT_PARMS = struct_tagMCI_ANIM_RECT_PARMS;
pub const PMCI_ANIM_RECT_PARMS = [*c]MCI_ANIM_RECT_PARMS;
pub const LPMCI_ANIM_RECT_PARMS = [*c]MCI_ANIM_RECT_PARMS;
pub const struct_tagMCI_ANIM_UPDATE_PARMS = extern struct {
    dwCallback: DWORD_PTR,
    rc: RECT,
    hDC: HDC,
};
pub const MCI_ANIM_UPDATE_PARMS = struct_tagMCI_ANIM_UPDATE_PARMS;
pub const PMCI_ANIM_UPDATE_PARMS = [*c]struct_tagMCI_ANIM_UPDATE_PARMS;
pub const LPMCI_ANIM_UPDATE_PARMS = [*c]struct_tagMCI_ANIM_UPDATE_PARMS;
pub const struct_tagMCI_OVLY_OPEN_PARMSA = extern struct {
    dwCallback: DWORD_PTR,
    wDeviceID: MCIDEVICEID,
    lpstrDeviceType: LPCSTR,
    lpstrElementName: LPCSTR,
    lpstrAlias: LPCSTR,
    dwStyle: DWORD,
    hWndParent: HWND,
};
pub const MCI_OVLY_OPEN_PARMSA = struct_tagMCI_OVLY_OPEN_PARMSA;
pub const PMCI_OVLY_OPEN_PARMSA = [*c]struct_tagMCI_OVLY_OPEN_PARMSA;
pub const LPMCI_OVLY_OPEN_PARMSA = [*c]struct_tagMCI_OVLY_OPEN_PARMSA;
pub const struct_tagMCI_OVLY_OPEN_PARMSW = extern struct {
    dwCallback: DWORD_PTR,
    wDeviceID: MCIDEVICEID,
    lpstrDeviceType: LPCWSTR,
    lpstrElementName: LPCWSTR,
    lpstrAlias: LPCWSTR,
    dwStyle: DWORD,
    hWndParent: HWND,
};
pub const MCI_OVLY_OPEN_PARMSW = struct_tagMCI_OVLY_OPEN_PARMSW;
pub const PMCI_OVLY_OPEN_PARMSW = [*c]struct_tagMCI_OVLY_OPEN_PARMSW;
pub const LPMCI_OVLY_OPEN_PARMSW = [*c]struct_tagMCI_OVLY_OPEN_PARMSW;
pub const MCI_OVLY_OPEN_PARMS = MCI_OVLY_OPEN_PARMSA;
pub const PMCI_OVLY_OPEN_PARMS = PMCI_OVLY_OPEN_PARMSA;
pub const LPMCI_OVLY_OPEN_PARMS = LPMCI_OVLY_OPEN_PARMSA;
pub const struct_tagMCI_OVLY_WINDOW_PARMSA = extern struct {
    dwCallback: DWORD_PTR,
    hWnd: HWND,
    nCmdShow: UINT,
    lpstrText: LPCSTR,
};
pub const MCI_OVLY_WINDOW_PARMSA = struct_tagMCI_OVLY_WINDOW_PARMSA;
pub const PMCI_OVLY_WINDOW_PARMSA = [*c]struct_tagMCI_OVLY_WINDOW_PARMSA;
pub const LPMCI_OVLY_WINDOW_PARMSA = [*c]struct_tagMCI_OVLY_WINDOW_PARMSA;
pub const struct_tagMCI_OVLY_WINDOW_PARMSW = extern struct {
    dwCallback: DWORD_PTR,
    hWnd: HWND,
    nCmdShow: UINT,
    lpstrText: LPCWSTR,
};
pub const MCI_OVLY_WINDOW_PARMSW = struct_tagMCI_OVLY_WINDOW_PARMSW;
pub const PMCI_OVLY_WINDOW_PARMSW = [*c]struct_tagMCI_OVLY_WINDOW_PARMSW;
pub const LPMCI_OVLY_WINDOW_PARMSW = [*c]struct_tagMCI_OVLY_WINDOW_PARMSW;
pub const MCI_OVLY_WINDOW_PARMS = MCI_OVLY_WINDOW_PARMSA;
pub const PMCI_OVLY_WINDOW_PARMS = PMCI_OVLY_WINDOW_PARMSA;
pub const LPMCI_OVLY_WINDOW_PARMS = LPMCI_OVLY_WINDOW_PARMSA;
pub const struct_tagMCI_OVLY_RECT_PARMS = extern struct {
    dwCallback: DWORD_PTR,
    rc: RECT,
};
pub const MCI_OVLY_RECT_PARMS = struct_tagMCI_OVLY_RECT_PARMS;
pub const PMCI_OVLY_RECT_PARMS = [*c]struct_tagMCI_OVLY_RECT_PARMS;
pub const LPMCI_OVLY_RECT_PARMS = [*c]struct_tagMCI_OVLY_RECT_PARMS;
pub const struct_tagMCI_OVLY_SAVE_PARMSA = extern struct {
    dwCallback: DWORD_PTR,
    lpfilename: LPCSTR,
    rc: RECT,
};
pub const MCI_OVLY_SAVE_PARMSA = struct_tagMCI_OVLY_SAVE_PARMSA;
pub const PMCI_OVLY_SAVE_PARMSA = [*c]struct_tagMCI_OVLY_SAVE_PARMSA;
pub const LPMCI_OVLY_SAVE_PARMSA = [*c]struct_tagMCI_OVLY_SAVE_PARMSA;
pub const struct_tagMCI_OVLY_SAVE_PARMSW = extern struct {
    dwCallback: DWORD_PTR,
    lpfilename: LPCWSTR,
    rc: RECT,
};
pub const MCI_OVLY_SAVE_PARMSW = struct_tagMCI_OVLY_SAVE_PARMSW;
pub const PMCI_OVLY_SAVE_PARMSW = [*c]struct_tagMCI_OVLY_SAVE_PARMSW;
pub const LPMCI_OVLY_SAVE_PARMSW = [*c]struct_tagMCI_OVLY_SAVE_PARMSW;
pub const MCI_OVLY_SAVE_PARMS = MCI_OVLY_SAVE_PARMSA;
pub const PMCI_OVLY_SAVE_PARMS = PMCI_OVLY_SAVE_PARMSA;
pub const LPMCI_OVLY_SAVE_PARMS = LPMCI_OVLY_SAVE_PARMSA;
pub const struct_tagMCI_OVLY_LOAD_PARMSA = extern struct {
    dwCallback: DWORD_PTR,
    lpfilename: LPCSTR,
    rc: RECT,
};
pub const MCI_OVLY_LOAD_PARMSA = struct_tagMCI_OVLY_LOAD_PARMSA;
pub const PMCI_OVLY_LOAD_PARMSA = [*c]struct_tagMCI_OVLY_LOAD_PARMSA;
pub const LPMCI_OVLY_LOAD_PARMSA = [*c]struct_tagMCI_OVLY_LOAD_PARMSA;
pub const struct_tagMCI_OVLY_LOAD_PARMSW = extern struct {
    dwCallback: DWORD_PTR,
    lpfilename: LPCWSTR,
    rc: RECT,
};
pub const MCI_OVLY_LOAD_PARMSW = struct_tagMCI_OVLY_LOAD_PARMSW;
pub const PMCI_OVLY_LOAD_PARMSW = [*c]struct_tagMCI_OVLY_LOAD_PARMSW;
pub const LPMCI_OVLY_LOAD_PARMSW = [*c]struct_tagMCI_OVLY_LOAD_PARMSW;
pub const MCI_OVLY_LOAD_PARMS = MCI_OVLY_LOAD_PARMSA;
pub const PMCI_OVLY_LOAD_PARMS = PMCI_OVLY_LOAD_PARMSA;
pub const LPMCI_OVLY_LOAD_PARMS = LPMCI_OVLY_LOAD_PARMSA;
pub extern "winmm" fn mciGetDriverData(wDeviceID: MCIDEVICEID) callconv(.Stdcall) DWORD_PTR;
pub extern "winmm" fn mciLoadCommandResource(hInstance: HANDLE, lpResName: LPCWSTR, wType: UINT) callconv(.Stdcall) UINT;
pub extern "winmm" fn mciSetDriverData(wDeviceID: MCIDEVICEID, dwData: DWORD_PTR) callconv(.Stdcall) BOOL;
pub extern "winmm" fn mciDriverYield(wDeviceID: MCIDEVICEID) callconv(.Stdcall) UINT;
pub extern "winmm" fn mciDriverNotify(hwndCallback: HANDLE, wDeviceID: MCIDEVICEID, uStatus: UINT) callconv(.Stdcall) BOOL;
pub extern "winmm" fn mciFreeCommandResource(wTable: UINT) callconv(.Stdcall) BOOL;
pub const struct_DRVCONFIGINFOEX = extern struct {
    dwDCISize: DWORD,
    lpszDCISectionName: LPCWSTR,
    lpszDCIAliasName: LPCWSTR,
    dnDevNode: DWORD,
};
pub const DRVCONFIGINFOEX = struct_DRVCONFIGINFOEX;
pub const PDRVCONFIGINFOEX = [*c]struct_DRVCONFIGINFOEX;
pub const NPDRVCONFIGINFOEX = [*c]struct_DRVCONFIGINFOEX;
pub const LPDRVCONFIGINFOEX = [*c]struct_DRVCONFIGINFOEX;
pub const struct_tagDRVCONFIGINFO = extern struct {
    dwDCISize: DWORD,
    lpszDCISectionName: LPCWSTR,
    lpszDCIAliasName: LPCWSTR,
};
pub const DRVCONFIGINFO = struct_tagDRVCONFIGINFO;
pub const PDRVCONFIGINFO = [*c]struct_tagDRVCONFIGINFO;
pub const NPDRVCONFIGINFO = [*c]struct_tagDRVCONFIGINFO;
pub const LPDRVCONFIGINFO = [*c]struct_tagDRVCONFIGINFO;
pub const DRIVERPROC = ?fn (DWORD_PTR, HDRVR, UINT, LPARAM, LPARAM) callconv(.C) LRESULT;
pub extern "winmm" fn CloseDriver(hDriver: HDRVR, lParam1: LPARAM, lParam2: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "winmm" fn OpenDriver(szDriverName: LPCWSTR, szSectionName: LPCWSTR, lParam2: LPARAM) callconv(.Stdcall) HDRVR;
pub extern "winmm" fn SendDriverMessage(hDriver: HDRVR, message: UINT, lParam1: LPARAM, lParam2: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "winmm" fn DrvGetModuleHandle(hDriver: HDRVR) callconv(.Stdcall) HMODULE;
pub extern "winmm" fn GetDriverModuleHandle(hDriver: HDRVR) callconv(.Stdcall) HMODULE;
pub extern "winmm" fn DefDriverProc(dwDriverIdentifier: DWORD_PTR, hdrvr: HDRVR, uMsg: UINT, lParam1: LPARAM, lParam2: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "winmm" fn DriverCallback(dwCallback: DWORD_PTR, dwFlags: DWORD, hDevice: HDRVR, dwMsg: DWORD, dwUser: DWORD_PTR, dwParam1: DWORD_PTR, dwParam2: DWORD_PTR) callconv(.Stdcall) BOOL;
pub extern "winmmbse" fn sndOpenSound(EventName: LPCWSTR, AppName: LPCWSTR, Flags: INT32, FileHandle: PHANDLE) callconv(.Stdcall) LONG;
pub const DRIVERMSGPROC = ?fn (DWORD, DWORD, DWORD_PTR, DWORD_PTR, DWORD_PTR) callconv(.C) DWORD;
pub extern "winmm" fn mmDrvInstall(hDriver: HDRVR, wszDrvEntry: LPCWSTR, drvMessage: DRIVERMSGPROC, wFlags: UINT) UINT;
pub const FOURCC = DWORD;
pub const HPSTR = [*c]u8;
pub const struct_HMMIO__ = extern struct {
    unused: c_int,
};
pub const HMMIO = [*c]struct_HMMIO__;
pub const MMIOPROC = fn (LPSTR, UINT, LPARAM, LPARAM) callconv(.C) LRESULT;
pub const LPMMIOPROC = [*c]MMIOPROC;
pub const struct__MMIOINFO = extern struct {
    dwFlags: DWORD,
    fccIOProc: FOURCC,
    pIOProc: LPMMIOPROC,
    wErrorRet: UINT,
    htask: HTASK,
    cchBuffer: LONG,
    pchBuffer: HPSTR,
    pchNext: HPSTR,
    pchEndRead: HPSTR,
    pchEndWrite: HPSTR,
    lBufOffset: LONG,
    lDiskOffset: LONG,
    adwInfo: [3]DWORD,
    dwReserved1: DWORD,
    dwReserved2: DWORD,
    hmmio: HMMIO,
};
pub const MMIOINFO = struct__MMIOINFO;
pub const PMMIOINFO = [*c]struct__MMIOINFO;
pub const NPMMIOINFO = [*c]struct__MMIOINFO;
pub const LPMMIOINFO = [*c]struct__MMIOINFO;
pub const LPCMMIOINFO = [*c]const MMIOINFO;
pub const struct__MMCKINFO = extern struct {
    ckid: FOURCC,
    cksize: DWORD,
    fccType: FOURCC,
    dwDataOffset: DWORD,
    dwFlags: DWORD,
};
pub const MMCKINFO = struct__MMCKINFO;
pub const PMMCKINFO = [*c]struct__MMCKINFO;
pub const NPMMCKINFO = [*c]struct__MMCKINFO;
pub const LPMMCKINFO = [*c]struct__MMCKINFO;
pub const LPCMMCKINFO = [*c]const MMCKINFO;
pub extern "winmm" fn mmioStringToFOURCCA(sz: LPCSTR, uFlags: UINT) callconv(.Stdcall) FOURCC;
pub extern "winmm" fn mmioStringToFOURCCW(sz: LPCWSTR, uFlags: UINT) callconv(.Stdcall) FOURCC;
pub extern "winmm" fn mmioInstallIOProcA(fccIOProc: FOURCC, pIOProc: LPMMIOPROC, dwFlags: DWORD) callconv(.Stdcall) LPMMIOPROC;
pub extern "winmm" fn mmioInstallIOProcW(fccIOProc: FOURCC, pIOProc: LPMMIOPROC, dwFlags: DWORD) callconv(.Stdcall) LPMMIOPROC;
pub extern "winmm" fn mmioOpenA(pszFileName: LPSTR, pmmioinfo: LPMMIOINFO, fdwOpen: DWORD) callconv(.Stdcall) HMMIO;
pub extern "winmm" fn mmioOpenW(pszFileName: LPWSTR, pmmioinfo: LPMMIOINFO, fdwOpen: DWORD) callconv(.Stdcall) HMMIO;
pub extern "winmm" fn mmioRenameA(pszFileName: LPCSTR, pszNewFileName: LPCSTR, pmmioinfo: LPCMMIOINFO, fdwRename: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mmioRenameW(pszFileName: LPCWSTR, pszNewFileName: LPCWSTR, pmmioinfo: LPCMMIOINFO, fdwRename: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mmioClose(hmmio: HMMIO, fuClose: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mmioRead(hmmio: HMMIO, pch: HPSTR, cch: LONG) callconv(.Stdcall) LONG;
pub extern "winmm" fn mmioWrite(hmmio: HMMIO, pch: [*c]const u8, cch: LONG) callconv(.Stdcall) LONG;
pub extern "winmm" fn mmioSeek(hmmio: HMMIO, lOffset: LONG, iOrigin: c_int) callconv(.Stdcall) LONG;
pub extern "winmm" fn mmioGetInfo(hmmio: HMMIO, pmmioinfo: LPMMIOINFO, fuInfo: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mmioSetInfo(hmmio: HMMIO, pmmioinfo: LPCMMIOINFO, fuInfo: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mmioSetBuffer(hmmio: HMMIO, pchBuffer: LPSTR, cchBuffer: LONG, fuBuffer: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mmioFlush(hmmio: HMMIO, fuFlush: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mmioAdvance(hmmio: HMMIO, pmmioinfo: LPMMIOINFO, fuAdvance: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mmioSendMessage(hmmio: HMMIO, uMsg: UINT, lParam1: LPARAM, lParam2: LPARAM) callconv(.Stdcall) LRESULT;
pub extern "winmm" fn mmioDescend(hmmio: HMMIO, pmmcki: LPMMCKINFO, pmmckiParent: [*c]const MMCKINFO, fuDescend: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mmioAscend(hmmio: HMMIO, pmmcki: LPMMCKINFO, fuAscend: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mmioCreateChunk(hmmio: HMMIO, pmmcki: LPMMCKINFO, fuCreate: UINT) callconv(.Stdcall) MMRESULT;
pub const TIMECALLBACK = fn (UINT, UINT, DWORD_PTR, DWORD_PTR, DWORD_PTR) callconv(.C) void;
pub const LPTIMECALLBACK = [*c]TIMECALLBACK;
pub extern "winmm" fn timeSetEvent(uDelay: UINT, uResolution: UINT, fptc: LPTIMECALLBACK, dwUser: DWORD_PTR, fuEvent: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn timeKillEvent(uTimerID: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn sndPlaySoundA(pszSound: LPCSTR, fuSound: UINT) callconv(.Stdcall) BOOL;
pub extern "winmm" fn sndPlaySoundW(pszSound: LPCWSTR, fuSound: UINT) callconv(.Stdcall) BOOL;
pub extern "winmm" fn PlaySoundA(pszSound: LPCSTR, hmod: HMODULE, fdwSound: DWORD) callconv(.Stdcall) BOOL;
pub extern "winmm" fn PlaySoundW(pszSound: LPCWSTR, hmod: HMODULE, fdwSound: DWORD) callconv(.Stdcall) BOOL;
pub const struct_HWAVE__ = extern struct {
    unused: c_int,
};
pub const HWAVE = [*c]struct_HWAVE__;
pub const struct_HWAVEIN__ = extern struct {
    unused: c_int,
};
pub const HWAVEIN = [*c]struct_HWAVEIN__;
pub const struct_HWAVEOUT__ = extern struct {
    unused: c_int,
};
pub const HWAVEOUT = [*c]struct_HWAVEOUT__;
pub const LPHWAVEIN = [*c]HWAVEIN;
pub const LPHWAVEOUT = [*c]HWAVEOUT;
pub const WAVECALLBACK = DRVCALLBACK;
pub const LPWAVECALLBACK = [*c]WAVECALLBACK;
pub const struct_wavehdr_tag = extern struct {
    lpData: LPSTR,
    dwBufferLength: DWORD,
    dwBytesRecorded: DWORD,
    dwUser: DWORD_PTR,
    dwFlags: DWORD,
    dwLoops: DWORD,
    lpNext: [*c]struct_wavehdr_tag,
    reserved: DWORD_PTR,
};
pub const WAVEHDR = struct_wavehdr_tag;
pub const PWAVEHDR = [*c]struct_wavehdr_tag;
pub const NPWAVEHDR = [*c]struct_wavehdr_tag;
pub const LPWAVEHDR = [*c]struct_wavehdr_tag;
pub const struct_tagWAVEOUTCAPSA = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]CHAR,
    dwFormats: DWORD,
    wChannels: WORD,
    wReserved1: WORD,
    dwSupport: DWORD,
};
pub const WAVEOUTCAPSA = struct_tagWAVEOUTCAPSA;
pub const PWAVEOUTCAPSA = [*c]struct_tagWAVEOUTCAPSA;
pub const NPWAVEOUTCAPSA = [*c]struct_tagWAVEOUTCAPSA;
pub const LPWAVEOUTCAPSA = [*c]struct_tagWAVEOUTCAPSA;
pub const struct_tagWAVEOUTCAPSW = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]WCHAR,
    dwFormats: DWORD,
    wChannels: WORD,
    wReserved1: WORD,
    dwSupport: DWORD,
};
pub const WAVEOUTCAPSW = struct_tagWAVEOUTCAPSW;
pub const PWAVEOUTCAPSW = [*c]struct_tagWAVEOUTCAPSW;
pub const NPWAVEOUTCAPSW = [*c]struct_tagWAVEOUTCAPSW;
pub const LPWAVEOUTCAPSW = [*c]struct_tagWAVEOUTCAPSW;
pub const WAVEOUTCAPS = WAVEOUTCAPSA;
pub const PWAVEOUTCAPS = PWAVEOUTCAPSA;
pub const NPWAVEOUTCAPS = NPWAVEOUTCAPSA;
pub const LPWAVEOUTCAPS = LPWAVEOUTCAPSA;
pub const struct_tagWAVEOUTCAPS2A = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]CHAR,
    dwFormats: DWORD,
    wChannels: WORD,
    wReserved1: WORD,
    dwSupport: DWORD,
    ManufacturerGuid: GUID,
    ProductGuid: GUID,
    NameGuid: GUID,
};
pub const WAVEOUTCAPS2A = struct_tagWAVEOUTCAPS2A;
pub const PWAVEOUTCAPS2A = [*c]struct_tagWAVEOUTCAPS2A;
pub const NPWAVEOUTCAPS2A = [*c]struct_tagWAVEOUTCAPS2A;
pub const LPWAVEOUTCAPS2A = [*c]struct_tagWAVEOUTCAPS2A;
pub const struct_tagWAVEOUTCAPS2W = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]WCHAR,
    dwFormats: DWORD,
    wChannels: WORD,
    wReserved1: WORD,
    dwSupport: DWORD,
    ManufacturerGuid: GUID,
    ProductGuid: GUID,
    NameGuid: GUID,
};
pub const WAVEOUTCAPS2W = struct_tagWAVEOUTCAPS2W;
pub const PWAVEOUTCAPS2W = [*c]struct_tagWAVEOUTCAPS2W;
pub const NPWAVEOUTCAPS2W = [*c]struct_tagWAVEOUTCAPS2W;
pub const LPWAVEOUTCAPS2W = [*c]struct_tagWAVEOUTCAPS2W;
pub const WAVEOUTCAPS2 = WAVEOUTCAPS2A;
pub const PWAVEOUTCAPS2 = PWAVEOUTCAPS2A;
pub const NPWAVEOUTCAPS2 = NPWAVEOUTCAPS2A;
pub const LPWAVEOUTCAPS2 = LPWAVEOUTCAPS2A;
pub const struct_tagWAVEINCAPSA = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]CHAR,
    dwFormats: DWORD,
    wChannels: WORD,
    wReserved1: WORD,
};
pub const WAVEINCAPSA = struct_tagWAVEINCAPSA;
pub const PWAVEINCAPSA = [*c]struct_tagWAVEINCAPSA;
pub const NPWAVEINCAPSA = [*c]struct_tagWAVEINCAPSA;
pub const LPWAVEINCAPSA = [*c]struct_tagWAVEINCAPSA;
pub const struct_tagWAVEINCAPSW = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]WCHAR,
    dwFormats: DWORD,
    wChannels: WORD,
    wReserved1: WORD,
};
pub const WAVEINCAPSW = struct_tagWAVEINCAPSW;
pub const PWAVEINCAPSW = [*c]struct_tagWAVEINCAPSW;
pub const NPWAVEINCAPSW = [*c]struct_tagWAVEINCAPSW;
pub const LPWAVEINCAPSW = [*c]struct_tagWAVEINCAPSW;
pub const WAVEINCAPS = WAVEINCAPSA;
pub const PWAVEINCAPS = PWAVEINCAPSA;
pub const NPWAVEINCAPS = NPWAVEINCAPSA;
pub const LPWAVEINCAPS = LPWAVEINCAPSA;
pub const struct_tagWAVEINCAPS2A = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]CHAR,
    dwFormats: DWORD,
    wChannels: WORD,
    wReserved1: WORD,
    ManufacturerGuid: GUID,
    ProductGuid: GUID,
    NameGuid: GUID,
};
pub const WAVEINCAPS2A = struct_tagWAVEINCAPS2A;
pub const PWAVEINCAPS2A = [*c]struct_tagWAVEINCAPS2A;
pub const NPWAVEINCAPS2A = [*c]struct_tagWAVEINCAPS2A;
pub const LPWAVEINCAPS2A = [*c]struct_tagWAVEINCAPS2A;
pub const struct_tagWAVEINCAPS2W = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]WCHAR,
    dwFormats: DWORD,
    wChannels: WORD,
    wReserved1: WORD,
    ManufacturerGuid: GUID,
    ProductGuid: GUID,
    NameGuid: GUID,
};
pub const WAVEINCAPS2W = struct_tagWAVEINCAPS2W;
pub const PWAVEINCAPS2W = [*c]struct_tagWAVEINCAPS2W;
pub const NPWAVEINCAPS2W = [*c]struct_tagWAVEINCAPS2W;
pub const LPWAVEINCAPS2W = [*c]struct_tagWAVEINCAPS2W;
pub const WAVEINCAPS2 = WAVEINCAPS2A;
pub const PWAVEINCAPS2 = PWAVEINCAPS2A;
pub const NPWAVEINCAPS2 = NPWAVEINCAPS2A;
pub const LPWAVEINCAPS2 = LPWAVEINCAPS2A;
pub const struct_waveformat_tag = extern struct {
    wFormatTag: WORD,
    nChannels: WORD,
    nSamplesPerSec: DWORD,
    nAvgBytesPerSec: DWORD,
    nBlockAlign: WORD,
};
pub const WAVEFORMAT = struct_waveformat_tag;
pub const PWAVEFORMAT = [*c]struct_waveformat_tag;
pub const NPWAVEFORMAT = [*c]struct_waveformat_tag;
pub const LPWAVEFORMAT = [*c]struct_waveformat_tag;
pub const struct_pcmwaveformat_tag = extern struct {
    wf: WAVEFORMAT,
    wBitsPerSample: WORD,
};
pub const PCMWAVEFORMAT = struct_pcmwaveformat_tag;
pub const PPCMWAVEFORMAT = [*c]struct_pcmwaveformat_tag;
pub const NPPCMWAVEFORMAT = [*c]struct_pcmwaveformat_tag;
pub const LPPCMWAVEFORMAT = [*c]struct_pcmwaveformat_tag;
pub const struct_tWAVEFORMATEX = extern struct {
    wFormatTag: WORD,
    nChannels: WORD,
    nSamplesPerSec: DWORD,
    nAvgBytesPerSec: DWORD,
    nBlockAlign: WORD,
    wBitsPerSample: WORD,
    cbSize: WORD,
};
pub const WAVEFORMATEX = struct_tWAVEFORMATEX;
pub const PWAVEFORMATEX = [*c]struct_tWAVEFORMATEX;
pub const NPWAVEFORMATEX = [*c]struct_tWAVEFORMATEX;
pub const LPWAVEFORMATEX = [*c]struct_tWAVEFORMATEX;
pub const LPCWAVEFORMATEX = [*c]const WAVEFORMATEX;
pub extern "winmm" fn waveOutGetNumDevs() callconv(.Stdcall) UINT;
pub extern "winmm" fn waveOutGetDevCapsA(uDeviceID: UINT_PTR, pwoc: LPWAVEOUTCAPSA, cbwoc: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutGetDevCapsW(uDeviceID: UINT_PTR, pwoc: LPWAVEOUTCAPSW, cbwoc: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutGetVolume(hwo: HWAVEOUT, pdwVolume: LPDWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutSetVolume(hwo: HWAVEOUT, dwVolume: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutGetErrorTextA(mmrError: MMRESULT, pszText: LPSTR, cchText: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutGetErrorTextW(mmrError: MMRESULT, pszText: LPWSTR, cchText: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutOpen(phwo: LPHWAVEOUT, uDeviceID: UINT, pwfx: LPCWAVEFORMATEX, dwCallback: DWORD_PTR, dwInstance: DWORD_PTR, fdwOpen: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutClose(hwo: HWAVEOUT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutPrepareHeader(hwo: HWAVEOUT, pwh: LPWAVEHDR, cbwh: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutUnprepareHeader(hwo: HWAVEOUT, pwh: LPWAVEHDR, cbwh: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutWrite(hwo: HWAVEOUT, pwh: LPWAVEHDR, cbwh: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutPause(hwo: HWAVEOUT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutRestart(hwo: HWAVEOUT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutReset(hwo: HWAVEOUT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutBreakLoop(hwo: HWAVEOUT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutGetPosition(hwo: HWAVEOUT, pmmt: LPMMTIME, cbmmt: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutGetPitch(hwo: HWAVEOUT, pdwPitch: LPDWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutSetPitch(hwo: HWAVEOUT, dwPitch: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutGetPlaybackRate(hwo: HWAVEOUT, pdwRate: LPDWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutSetPlaybackRate(hwo: HWAVEOUT, dwRate: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutGetID(hwo: HWAVEOUT, puDeviceID: LPUINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveOutMessage(hwo: HWAVEOUT, uMsg: UINT, dw1: DWORD_PTR, dw2: DWORD_PTR) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveInGetNumDevs() callconv(.Stdcall) UINT;
pub extern "winmm" fn waveInGetDevCapsA(uDeviceID: UINT_PTR, pwic: LPWAVEINCAPSA, cbwic: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveInGetDevCapsW(uDeviceID: UINT_PTR, pwic: LPWAVEINCAPSW, cbwic: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveInGetErrorTextA(mmrError: MMRESULT, pszText: LPSTR, cchText: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveInGetErrorTextW(mmrError: MMRESULT, pszText: LPWSTR, cchText: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveInOpen(phwi: LPHWAVEIN, uDeviceID: UINT, pwfx: LPCWAVEFORMATEX, dwCallback: DWORD_PTR, dwInstance: DWORD_PTR, fdwOpen: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveInClose(hwi: HWAVEIN) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveInPrepareHeader(hwi: HWAVEIN, pwh: LPWAVEHDR, cbwh: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveInUnprepareHeader(hwi: HWAVEIN, pwh: LPWAVEHDR, cbwh: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveInAddBuffer(hwi: HWAVEIN, pwh: LPWAVEHDR, cbwh: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveInStart(hwi: HWAVEIN) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveInStop(hwi: HWAVEIN) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveInReset(hwi: HWAVEIN) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveInGetPosition(hwi: HWAVEIN, pmmt: LPMMTIME, cbmmt: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveInGetID(hwi: HWAVEIN, puDeviceID: LPUINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn waveInMessage(hwi: HWAVEIN, uMsg: UINT, dw1: DWORD_PTR, dw2: DWORD_PTR) callconv(.Stdcall) MMRESULT;
pub const struct_HMIDI__ = extern struct {
    unused: c_int,
};
pub const HMIDI = [*c]struct_HMIDI__;
pub const struct_HMIDIIN__ = extern struct {
    unused: c_int,
};
pub const HMIDIIN = [*c]struct_HMIDIIN__;
pub const struct_HMIDIOUT__ = extern struct {
    unused: c_int,
};
pub const HMIDIOUT = [*c]struct_HMIDIOUT__;
pub const struct_HMIDISTRM__ = extern struct {
    unused: c_int,
};
pub const HMIDISTRM = [*c]struct_HMIDISTRM__;
pub const LPHMIDI = [*c]HMIDI;
pub const LPHMIDIIN = [*c]HMIDIIN;
pub const LPHMIDIOUT = [*c]HMIDIOUT;
pub const LPHMIDISTRM = [*c]HMIDISTRM;
pub const MIDICALLBACK = DRVCALLBACK;
pub const LPMIDICALLBACK = [*c]MIDICALLBACK;
pub const PATCHARRAY = [128]WORD;
pub const LPPATCHARRAY = [*c]WORD;
pub const KEYARRAY = [128]WORD;
pub const LPKEYARRAY = [*c]WORD;
pub const struct_tagMIDIOUTCAPSA = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]CHAR,
    wTechnology: WORD,
    wVoices: WORD,
    wNotes: WORD,
    wChannelMask: WORD,
    dwSupport: DWORD,
};
pub const MIDIOUTCAPSA = struct_tagMIDIOUTCAPSA;
pub const PMIDIOUTCAPSA = [*c]struct_tagMIDIOUTCAPSA;
pub const NPMIDIOUTCAPSA = [*c]struct_tagMIDIOUTCAPSA;
pub const LPMIDIOUTCAPSA = [*c]struct_tagMIDIOUTCAPSA;
pub const struct_tagMIDIOUTCAPSW = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]WCHAR,
    wTechnology: WORD,
    wVoices: WORD,
    wNotes: WORD,
    wChannelMask: WORD,
    dwSupport: DWORD,
};
pub const MIDIOUTCAPSW = struct_tagMIDIOUTCAPSW;
pub const PMIDIOUTCAPSW = [*c]struct_tagMIDIOUTCAPSW;
pub const NPMIDIOUTCAPSW = [*c]struct_tagMIDIOUTCAPSW;
pub const LPMIDIOUTCAPSW = [*c]struct_tagMIDIOUTCAPSW;
pub const MIDIOUTCAPS = MIDIOUTCAPSA;
pub const PMIDIOUTCAPS = PMIDIOUTCAPSA;
pub const NPMIDIOUTCAPS = NPMIDIOUTCAPSA;
pub const LPMIDIOUTCAPS = LPMIDIOUTCAPSA;
pub const struct_tagMIDIOUTCAPS2A = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]CHAR,
    wTechnology: WORD,
    wVoices: WORD,
    wNotes: WORD,
    wChannelMask: WORD,
    dwSupport: DWORD,
    ManufacturerGuid: GUID,
    ProductGuid: GUID,
    NameGuid: GUID,
};
pub const MIDIOUTCAPS2A = struct_tagMIDIOUTCAPS2A;
pub const PMIDIOUTCAPS2A = [*c]struct_tagMIDIOUTCAPS2A;
pub const NPMIDIOUTCAPS2A = [*c]struct_tagMIDIOUTCAPS2A;
pub const LPMIDIOUTCAPS2A = [*c]struct_tagMIDIOUTCAPS2A;
pub const struct_tagMIDIOUTCAPS2W = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]WCHAR,
    wTechnology: WORD,
    wVoices: WORD,
    wNotes: WORD,
    wChannelMask: WORD,
    dwSupport: DWORD,
    ManufacturerGuid: GUID,
    ProductGuid: GUID,
    NameGuid: GUID,
};
pub const MIDIOUTCAPS2W = struct_tagMIDIOUTCAPS2W;
pub const PMIDIOUTCAPS2W = [*c]struct_tagMIDIOUTCAPS2W;
pub const NPMIDIOUTCAPS2W = [*c]struct_tagMIDIOUTCAPS2W;
pub const LPMIDIOUTCAPS2W = [*c]struct_tagMIDIOUTCAPS2W;
pub const MIDIOUTCAPS2 = MIDIOUTCAPS2A;
pub const PMIDIOUTCAPS2 = PMIDIOUTCAPS2A;
pub const NPMIDIOUTCAPS2 = NPMIDIOUTCAPS2A;
pub const LPMIDIOUTCAPS2 = LPMIDIOUTCAPS2A;
pub const struct_tagMIDIINCAPSA = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]CHAR,
    dwSupport: DWORD,
};
pub const MIDIINCAPSA = struct_tagMIDIINCAPSA;
pub const PMIDIINCAPSA = [*c]struct_tagMIDIINCAPSA;
pub const NPMIDIINCAPSA = [*c]struct_tagMIDIINCAPSA;
pub const LPMIDIINCAPSA = [*c]struct_tagMIDIINCAPSA;
pub const struct_tagMIDIINCAPSW = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]WCHAR,
    dwSupport: DWORD,
};
pub const MIDIINCAPSW = struct_tagMIDIINCAPSW;
pub const PMIDIINCAPSW = [*c]struct_tagMIDIINCAPSW;
pub const NPMIDIINCAPSW = [*c]struct_tagMIDIINCAPSW;
pub const LPMIDIINCAPSW = [*c]struct_tagMIDIINCAPSW;
pub const MIDIINCAPS = MIDIINCAPSA;
pub const PMIDIINCAPS = PMIDIINCAPSA;
pub const NPMIDIINCAPS = NPMIDIINCAPSA;
pub const LPMIDIINCAPS = LPMIDIINCAPSA;
pub const struct_tagMIDIINCAPS2A = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]CHAR,
    dwSupport: DWORD,
    ManufacturerGuid: GUID,
    ProductGuid: GUID,
    NameGuid: GUID,
};
pub const MIDIINCAPS2A = struct_tagMIDIINCAPS2A;
pub const PMIDIINCAPS2A = [*c]struct_tagMIDIINCAPS2A;
pub const NPMIDIINCAPS2A = [*c]struct_tagMIDIINCAPS2A;
pub const LPMIDIINCAPS2A = [*c]struct_tagMIDIINCAPS2A;
pub const struct_tagMIDIINCAPS2W = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]WCHAR,
    dwSupport: DWORD,
    ManufacturerGuid: GUID,
    ProductGuid: GUID,
    NameGuid: GUID,
};
pub const MIDIINCAPS2W = struct_tagMIDIINCAPS2W;
pub const PMIDIINCAPS2W = [*c]struct_tagMIDIINCAPS2W;
pub const NPMIDIINCAPS2W = [*c]struct_tagMIDIINCAPS2W;
pub const LPMIDIINCAPS2W = [*c]struct_tagMIDIINCAPS2W;
pub const MIDIINCAPS2 = MIDIINCAPS2A;
pub const PMIDIINCAPS2 = PMIDIINCAPS2A;
pub const NPMIDIINCAPS2 = NPMIDIINCAPS2A;
pub const LPMIDIINCAPS2 = LPMIDIINCAPS2A;
pub const struct_midihdr_tag = extern struct {
    lpData: LPSTR,
    dwBufferLength: DWORD,
    dwBytesRecorded: DWORD,
    dwUser: DWORD_PTR,
    dwFlags: DWORD,
    lpNext: [*c]struct_midihdr_tag,
    reserved: DWORD_PTR,
    dwOffset: DWORD,
    dwReserved: [8]DWORD_PTR,
};
pub const MIDIHDR = struct_midihdr_tag;
pub const PMIDIHDR = [*c]struct_midihdr_tag;
pub const NPMIDIHDR = [*c]struct_midihdr_tag;
pub const LPMIDIHDR = [*c]struct_midihdr_tag;
pub const struct_midievent_tag = extern struct {
    dwDeltaTime: DWORD,
    dwStreamID: DWORD,
    dwEvent: DWORD,
    dwParms: [1]DWORD,
};
pub const MIDIEVENT = struct_midievent_tag;
pub const struct_midistrmbuffver_tag = extern struct {
    dwVersion: DWORD,
    dwMid: DWORD,
    dwOEMVersion: DWORD,
};
pub const MIDISTRMBUFFVER = struct_midistrmbuffver_tag;
pub const struct_midiproptimediv_tag = extern struct {
    cbStruct: DWORD,
    dwTimeDiv: DWORD,
};
pub const MIDIPROPTIMEDIV = struct_midiproptimediv_tag;
pub const LPMIDIPROPTIMEDIV = [*c]struct_midiproptimediv_tag;
pub const struct_midiproptempo_tag = extern struct {
    cbStruct: DWORD,
    dwTempo: DWORD,
};
pub const MIDIPROPTEMPO = struct_midiproptempo_tag;
pub const LPMIDIPROPTEMPO = [*c]struct_midiproptempo_tag;
pub extern "winmm" fn midiOutGetNumDevs() callconv(.Stdcall) UINT;
pub extern "winmm" fn midiStreamOpen(phms: LPHMIDISTRM, puDeviceID: LPUINT, cMidi: DWORD, dwCallback: DWORD_PTR, dwInstance: DWORD_PTR, fdwOpen: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiStreamClose(hms: HMIDISTRM) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiStreamProperty(hms: HMIDISTRM, lppropdata: LPBYTE, dwProperty: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiStreamPosition(hms: HMIDISTRM, lpmmt: LPMMTIME, cbmmt: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiStreamOut(hms: HMIDISTRM, pmh: LPMIDIHDR, cbmh: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiStreamPause(hms: HMIDISTRM) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiStreamRestart(hms: HMIDISTRM) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiStreamStop(hms: HMIDISTRM) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiConnect(hmi: HMIDI, hmo: HMIDIOUT, pReserved: LPVOID) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiDisconnect(hmi: HMIDI, hmo: HMIDIOUT, pReserved: LPVOID) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiOutGetDevCapsA(uDeviceID: UINT_PTR, pmoc: LPMIDIOUTCAPSA, cbmoc: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiOutGetDevCapsW(uDeviceID: UINT_PTR, pmoc: LPMIDIOUTCAPSW, cbmoc: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiOutGetVolume(hmo: HMIDIOUT, pdwVolume: LPDWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiOutSetVolume(hmo: HMIDIOUT, dwVolume: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiOutGetErrorTextA(mmrError: MMRESULT, pszText: LPSTR, cchText: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiOutGetErrorTextW(mmrError: MMRESULT, pszText: LPWSTR, cchText: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiOutOpen(phmo: LPHMIDIOUT, uDeviceID: UINT, dwCallback: DWORD_PTR, dwInstance: DWORD_PTR, fdwOpen: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiOutClose(hmo: HMIDIOUT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiOutPrepareHeader(hmo: HMIDIOUT, pmh: LPMIDIHDR, cbmh: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiOutUnprepareHeader(hmo: HMIDIOUT, pmh: LPMIDIHDR, cbmh: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiOutShortMsg(hmo: HMIDIOUT, dwMsg: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiOutLongMsg(hmo: HMIDIOUT, pmh: LPMIDIHDR, cbmh: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiOutReset(hmo: HMIDIOUT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiOutCachePatches(hmo: HMIDIOUT, uBank: UINT, pwpa: LPWORD, fuCache: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiOutCacheDrumPatches(hmo: HMIDIOUT, uPatch: UINT, pwkya: LPWORD, fuCache: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiOutGetID(hmo: HMIDIOUT, puDeviceID: LPUINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiOutMessage(hmo: HMIDIOUT, uMsg: UINT, dw1: DWORD_PTR, dw2: DWORD_PTR) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiInGetNumDevs() callconv(.Stdcall) UINT;
pub extern "winmm" fn midiInGetDevCapsA(uDeviceID: UINT_PTR, pmic: LPMIDIINCAPSA, cbmic: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiInGetDevCapsW(uDeviceID: UINT_PTR, pmic: LPMIDIINCAPSW, cbmic: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiInGetErrorTextA(mmrError: MMRESULT, pszText: LPSTR, cchText: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiInGetErrorTextW(mmrError: MMRESULT, pszText: LPWSTR, cchText: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiInOpen(phmi: LPHMIDIIN, uDeviceID: UINT, dwCallback: DWORD_PTR, dwInstance: DWORD_PTR, fdwOpen: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiInClose(hmi: HMIDIIN) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiInPrepareHeader(hmi: HMIDIIN, pmh: LPMIDIHDR, cbmh: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiInUnprepareHeader(hmi: HMIDIIN, pmh: LPMIDIHDR, cbmh: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiInAddBuffer(hmi: HMIDIIN, pmh: LPMIDIHDR, cbmh: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiInStart(hmi: HMIDIIN) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiInStop(hmi: HMIDIIN) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiInReset(hmi: HMIDIIN) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiInGetID(hmi: HMIDIIN, puDeviceID: LPUINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn midiInMessage(hmi: HMIDIIN, uMsg: UINT, dw1: DWORD_PTR, dw2: DWORD_PTR) callconv(.Stdcall) MMRESULT;
pub const struct_tagAUXCAPSA = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]CHAR,
    wTechnology: WORD,
    wReserved1: WORD,
    dwSupport: DWORD,
};
pub const AUXCAPSA = struct_tagAUXCAPSA;
pub const PAUXCAPSA = [*c]struct_tagAUXCAPSA;
pub const NPAUXCAPSA = [*c]struct_tagAUXCAPSA;
pub const LPAUXCAPSA = [*c]struct_tagAUXCAPSA;
pub const struct_tagAUXCAPSW = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]WCHAR,
    wTechnology: WORD,
    wReserved1: WORD,
    dwSupport: DWORD,
};
pub const AUXCAPSW = struct_tagAUXCAPSW;
pub const PAUXCAPSW = [*c]struct_tagAUXCAPSW;
pub const NPAUXCAPSW = [*c]struct_tagAUXCAPSW;
pub const LPAUXCAPSW = [*c]struct_tagAUXCAPSW;
pub const AUXCAPS = AUXCAPSA;
pub const PAUXCAPS = PAUXCAPSA;
pub const NPAUXCAPS = NPAUXCAPSA;
pub const LPAUXCAPS = LPAUXCAPSA;
pub const struct_tagAUXCAPS2A = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]CHAR,
    wTechnology: WORD,
    wReserved1: WORD,
    dwSupport: DWORD,
    ManufacturerGuid: GUID,
    ProductGuid: GUID,
    NameGuid: GUID,
};
pub const AUXCAPS2A = struct_tagAUXCAPS2A;
pub const PAUXCAPS2A = [*c]struct_tagAUXCAPS2A;
pub const NPAUXCAPS2A = [*c]struct_tagAUXCAPS2A;
pub const LPAUXCAPS2A = [*c]struct_tagAUXCAPS2A;
pub const struct_tagAUXCAPS2W = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]WCHAR,
    wTechnology: WORD,
    wReserved1: WORD,
    dwSupport: DWORD,
    ManufacturerGuid: GUID,
    ProductGuid: GUID,
    NameGuid: GUID,
};
pub const AUXCAPS2W = struct_tagAUXCAPS2W;
pub const PAUXCAPS2W = [*c]struct_tagAUXCAPS2W;
pub const NPAUXCAPS2W = [*c]struct_tagAUXCAPS2W;
pub const LPAUXCAPS2W = [*c]struct_tagAUXCAPS2W;
pub const AUXCAPS2 = AUXCAPS2A;
pub const PAUXCAPS2 = PAUXCAPS2A;
pub const NPAUXCAPS2 = NPAUXCAPS2A;
pub const LPAUXCAPS2 = LPAUXCAPS2A;
pub extern "winmm" fn auxGetNumDevs() callconv(.Stdcall) UINT;
pub extern "winmm" fn auxGetDevCapsA(uDeviceID: UINT_PTR, pac: LPAUXCAPSA, cbac: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn auxGetDevCapsW(uDeviceID: UINT_PTR, pac: LPAUXCAPSW, cbac: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn auxSetVolume(uDeviceID: UINT, dwVolume: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn auxGetVolume(uDeviceID: UINT, pdwVolume: LPDWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn auxOutMessage(uDeviceID: UINT, uMsg: UINT, dw1: DWORD_PTR, dw2: DWORD_PTR) callconv(.Stdcall) MMRESULT;
pub const struct_HMIXEROBJ__ = extern struct {
    unused: c_int,
};
pub const HMIXEROBJ = [*c]struct_HMIXEROBJ__;
pub const LPHMIXEROBJ = [*c]HMIXEROBJ;
pub const struct_HMIXER__ = extern struct {
    unused: c_int,
};
pub const HMIXER = [*c]struct_HMIXER__;
pub const LPHMIXER = [*c]HMIXER;
pub extern "winmm" fn mixerGetNumDevs() callconv(.Stdcall) UINT;
pub const struct_tagMIXERCAPSA = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]CHAR,
    fdwSupport: DWORD,
    cDestinations: DWORD,
};
pub const MIXERCAPSA = struct_tagMIXERCAPSA;
pub const PMIXERCAPSA = [*c]struct_tagMIXERCAPSA;
pub const LPMIXERCAPSA = [*c]struct_tagMIXERCAPSA;
pub const struct_tagMIXERCAPSW = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]WCHAR,
    fdwSupport: DWORD,
    cDestinations: DWORD,
};
pub const MIXERCAPSW = struct_tagMIXERCAPSW;
pub const PMIXERCAPSW = [*c]struct_tagMIXERCAPSW;
pub const LPMIXERCAPSW = [*c]struct_tagMIXERCAPSW;
pub const MIXERCAPS = MIXERCAPSA;
pub const PMIXERCAPS = PMIXERCAPSA;
pub const LPMIXERCAPS = LPMIXERCAPSA;
pub const struct_tagMIXERCAPS2A = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]CHAR,
    fdwSupport: DWORD,
    cDestinations: DWORD,
    ManufacturerGuid: GUID,
    ProductGuid: GUID,
    NameGuid: GUID,
};
pub const MIXERCAPS2A = struct_tagMIXERCAPS2A;
pub const PMIXERCAPS2A = [*c]struct_tagMIXERCAPS2A;
pub const LPMIXERCAPS2A = [*c]struct_tagMIXERCAPS2A;
pub const struct_tagMIXERCAPS2W = extern struct {
    wMid: WORD,
    wPid: WORD,
    vDriverVersion: MMVERSION,
    szPname: [32]WCHAR,
    fdwSupport: DWORD,
    cDestinations: DWORD,
    ManufacturerGuid: GUID,
    ProductGuid: GUID,
    NameGuid: GUID,
};
pub const MIXERCAPS2W = struct_tagMIXERCAPS2W;
pub const PMIXERCAPS2W = [*c]struct_tagMIXERCAPS2W;
pub const LPMIXERCAPS2W = [*c]struct_tagMIXERCAPS2W;
pub const MIXERCAPS2 = MIXERCAPS2A;
pub const PMIXERCAPS2 = PMIXERCAPS2A;
pub const LPMIXERCAPS2 = LPMIXERCAPS2A;
pub extern "winmm" fn mixerGetDevCapsA(uMxId: UINT_PTR, pmxcaps: LPMIXERCAPSA, cbmxcaps: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mixerGetDevCapsW(uMxId: UINT_PTR, pmxcaps: LPMIXERCAPSW, cbmxcaps: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mixerOpen(phmx: LPHMIXER, uMxId: UINT, dwCallback: DWORD_PTR, dwInstance: DWORD_PTR, fdwOpen: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mixerClose(hmx: HMIXER) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mixerMessage(hmx: HMIXER, uMsg: UINT, dwParam1: DWORD_PTR, dwParam2: DWORD_PTR) callconv(.Stdcall) DWORD;
pub const struct_tagMIXERLINEA = extern struct {
    cbStruct: DWORD,
    dwDestination: DWORD,
    dwSource: DWORD,
    dwLineID: DWORD,
    fdwLine: DWORD,
    dwUser: DWORD_PTR,
    dwComponentType: DWORD,
    cChannels: DWORD,
    cConnections: DWORD,
    cControls: DWORD,
    szShortName: [16]CHAR,
    szName: [64]CHAR,
    Target: extern struct {
        dwType: DWORD,
        dwDeviceID: DWORD,
        wMid: WORD,
        wPid: WORD,
        vDriverVersion: MMVERSION,
        szPname: [32]CHAR,
    },
};
pub const MIXERLINEA = struct_tagMIXERLINEA;
pub const PMIXERLINEA = [*c]struct_tagMIXERLINEA;
pub const LPMIXERLINEA = [*c]struct_tagMIXERLINEA;
pub const struct_tagMIXERLINEW = extern struct {
    cbStruct: DWORD,
    dwDestination: DWORD,
    dwSource: DWORD,
    dwLineID: DWORD,
    fdwLine: DWORD,
    dwUser: DWORD_PTR,
    dwComponentType: DWORD,
    cChannels: DWORD,
    cConnections: DWORD,
    cControls: DWORD,
    szShortName: [16]WCHAR,
    szName: [64]WCHAR,
    Target: extern struct {
        dwType: DWORD,
        dwDeviceID: DWORD,
        wMid: WORD,
        wPid: WORD,
        vDriverVersion: MMVERSION,
        szPname: [32]WCHAR,
    },
};
pub const MIXERLINEW = struct_tagMIXERLINEW;
pub const PMIXERLINEW = [*c]struct_tagMIXERLINEW;
pub const LPMIXERLINEW = [*c]struct_tagMIXERLINEW;
pub const MIXERLINE = MIXERLINEA;
pub const PMIXERLINE = PMIXERLINEA;
pub const LPMIXERLINE = LPMIXERLINEA;
pub extern "winmm" fn mixerGetLineInfoA(hmxobj: HMIXEROBJ, pmxl: LPMIXERLINEA, fdwInfo: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mixerGetLineInfoW(hmxobj: HMIXEROBJ, pmxl: LPMIXERLINEW, fdwInfo: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mixerGetID(hmxobj: HMIXEROBJ, puMxId: [*c]UINT, fdwId: DWORD) callconv(.Stdcall) MMRESULT;
pub const struct_tagMIXERCONTROLA = extern struct {
    cbStruct: DWORD,
    dwControlID: DWORD,
    dwControlType: DWORD,
    fdwControl: DWORD,
    cMultipleItems: DWORD,
    szShortName: [16]CHAR,
    szName: [64]CHAR,
    Bounds: extern union {
        @"": extern struct {
            lMinimum: LONG,
            lMaximum: LONG,
        },
        @"": extern struct {
            dwMinimum: DWORD,
            dwMaximum: DWORD,
        },
        dwReserved: [6]DWORD,
    },
    Metrics: extern union {
        cSteps: DWORD,
        cbCustomData: DWORD,
        dwReserved: [6]DWORD,
    },
};
pub const MIXERCONTROLA = struct_tagMIXERCONTROLA;
pub const PMIXERCONTROLA = [*c]struct_tagMIXERCONTROLA;
pub const LPMIXERCONTROLA = [*c]struct_tagMIXERCONTROLA;
pub const struct_tagMIXERCONTROLW = extern struct {
    cbStruct: DWORD,
    dwControlID: DWORD,
    dwControlType: DWORD,
    fdwControl: DWORD,
    cMultipleItems: DWORD,
    szShortName: [16]WCHAR,
    szName: [64]WCHAR,
    Bounds: extern union {
        @"": extern struct {
            lMinimum: LONG,
            lMaximum: LONG,
        },
        @"": extern struct {
            dwMinimum: DWORD,
            dwMaximum: DWORD,
        },
        dwReserved: [6]DWORD,
    },
    Metrics: extern union {
        cSteps: DWORD,
        cbCustomData: DWORD,
        dwReserved: [6]DWORD,
    },
};
pub const MIXERCONTROLW = struct_tagMIXERCONTROLW;
pub const PMIXERCONTROLW = [*c]struct_tagMIXERCONTROLW;
pub const LPMIXERCONTROLW = [*c]struct_tagMIXERCONTROLW;
pub const MIXERCONTROL = MIXERCONTROLA;
pub const PMIXERCONTROL = PMIXERCONTROLA;
pub const LPMIXERCONTROL = LPMIXERCONTROLA;
pub const struct_tagMIXERLINECONTROLSA = extern struct {
    cbStruct: DWORD,
    dwLineID: DWORD,
    @"": extern union {
        dwControlID: DWORD,
        dwControlType: DWORD,
    },
    cControls: DWORD,
    cbmxctrl: DWORD,
    pamxctrl: LPMIXERCONTROLA,
};
pub const MIXERLINECONTROLSA = struct_tagMIXERLINECONTROLSA;
pub const PMIXERLINECONTROLSA = [*c]struct_tagMIXERLINECONTROLSA;
pub const LPMIXERLINECONTROLSA = [*c]struct_tagMIXERLINECONTROLSA;
pub const struct_tagMIXERLINECONTROLSW = extern struct {
    cbStruct: DWORD,
    dwLineID: DWORD,
    @"": extern union {
        dwControlID: DWORD,
        dwControlType: DWORD,
    },
    cControls: DWORD,
    cbmxctrl: DWORD,
    pamxctrl: LPMIXERCONTROLW,
};
pub const MIXERLINECONTROLSW = struct_tagMIXERLINECONTROLSW;
pub const PMIXERLINECONTROLSW = [*c]struct_tagMIXERLINECONTROLSW;
pub const LPMIXERLINECONTROLSW = [*c]struct_tagMIXERLINECONTROLSW;
pub const MIXERLINECONTROLS = MIXERLINECONTROLSA;
pub const PMIXERLINECONTROLS = PMIXERLINECONTROLSA;
pub const LPMIXERLINECONTROLS = LPMIXERLINECONTROLSA;
pub extern "winmm" fn mixerGetLineControlsA(hmxobj: HMIXEROBJ, pmxlc: LPMIXERLINECONTROLSA, fdwControls: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mixerGetLineControlsW(hmxobj: HMIXEROBJ, pmxlc: LPMIXERLINECONTROLSW, fdwControls: DWORD) callconv(.Stdcall) MMRESULT;
pub const struct_tMIXERCONTROLDETAILS = extern struct {
    cbStruct: DWORD,
    dwControlID: DWORD,
    cChannels: DWORD,
    @"": extern union {
        hwndOwner: HWND,
        cMultipleItems: DWORD,
    },
    cbDetails: DWORD,
    paDetails: LPVOID,
};
pub const MIXERCONTROLDETAILS = struct_tMIXERCONTROLDETAILS;
pub const PMIXERCONTROLDETAILS = [*c]struct_tMIXERCONTROLDETAILS;
pub const LPMIXERCONTROLDETAILS = [*c]struct_tMIXERCONTROLDETAILS;
pub const struct_tagMIXERCONTROLDETAILS_LISTTEXTA = extern struct {
    dwParam1: DWORD,
    dwParam2: DWORD,
    szName: [64]CHAR,
};
pub const MIXERCONTROLDETAILS_LISTTEXTA = struct_tagMIXERCONTROLDETAILS_LISTTEXTA;
pub const PMIXERCONTROLDETAILS_LISTTEXTA = [*c]struct_tagMIXERCONTROLDETAILS_LISTTEXTA;
pub const LPMIXERCONTROLDETAILS_LISTTEXTA = [*c]struct_tagMIXERCONTROLDETAILS_LISTTEXTA;
pub const struct_tagMIXERCONTROLDETAILS_LISTTEXTW = extern struct {
    dwParam1: DWORD,
    dwParam2: DWORD,
    szName: [64]WCHAR,
};
pub const MIXERCONTROLDETAILS_LISTTEXTW = struct_tagMIXERCONTROLDETAILS_LISTTEXTW;
pub const PMIXERCONTROLDETAILS_LISTTEXTW = [*c]struct_tagMIXERCONTROLDETAILS_LISTTEXTW;
pub const LPMIXERCONTROLDETAILS_LISTTEXTW = [*c]struct_tagMIXERCONTROLDETAILS_LISTTEXTW;
pub const MIXERCONTROLDETAILS_LISTTEXT = MIXERCONTROLDETAILS_LISTTEXTA;
pub const PMIXERCONTROLDETAILS_LISTTEXT = PMIXERCONTROLDETAILS_LISTTEXTA;
pub const LPMIXERCONTROLDETAILS_LISTTEXT = LPMIXERCONTROLDETAILS_LISTTEXTA;
pub const struct_tMIXERCONTROLDETAILS_BOOLEAN = extern struct {
    fValue: LONG,
};
pub const MIXERCONTROLDETAILS_BOOLEAN = struct_tMIXERCONTROLDETAILS_BOOLEAN;
pub const PMIXERCONTROLDETAILS_BOOLEAN = [*c]struct_tMIXERCONTROLDETAILS_BOOLEAN;
pub const LPMIXERCONTROLDETAILS_BOOLEAN = [*c]struct_tMIXERCONTROLDETAILS_BOOLEAN;
pub const struct_tMIXERCONTROLDETAILS_SIGNED = extern struct {
    lValue: LONG,
};
pub const MIXERCONTROLDETAILS_SIGNED = struct_tMIXERCONTROLDETAILS_SIGNED;
pub const PMIXERCONTROLDETAILS_SIGNED = [*c]struct_tMIXERCONTROLDETAILS_SIGNED;
pub const LPMIXERCONTROLDETAILS_SIGNED = [*c]struct_tMIXERCONTROLDETAILS_SIGNED;
pub const struct_tMIXERCONTROLDETAILS_UNSIGNED = extern struct {
    dwValue: DWORD,
};
pub const MIXERCONTROLDETAILS_UNSIGNED = struct_tMIXERCONTROLDETAILS_UNSIGNED;
pub const PMIXERCONTROLDETAILS_UNSIGNED = [*c]struct_tMIXERCONTROLDETAILS_UNSIGNED;
pub const LPMIXERCONTROLDETAILS_UNSIGNED = [*c]struct_tMIXERCONTROLDETAILS_UNSIGNED;
pub extern "winmm" fn mixerGetControlDetailsA(hmxobj: HMIXEROBJ, pmxcd: LPMIXERCONTROLDETAILS, fdwDetails: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mixerGetControlDetailsW(hmxobj: HMIXEROBJ, pmxcd: LPMIXERCONTROLDETAILS, fdwDetails: DWORD) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn mixerSetControlDetails(hmxobj: HMIXEROBJ, pmxcd: LPMIXERCONTROLDETAILS, fdwDetails: DWORD) callconv(.Stdcall) MMRESULT;
pub const struct_timecaps_tag = extern struct {
    wPeriodMin: UINT,
    wPeriodMax: UINT,
};
pub const TIMECAPS = struct_timecaps_tag;
pub const PTIMECAPS = [*c]struct_timecaps_tag;
pub const NPTIMECAPS = [*c]struct_timecaps_tag;
pub const LPTIMECAPS = [*c]struct_timecaps_tag;
pub extern "winmm" fn timeGetSystemTime(pmmt: LPMMTIME, cbmmt: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn timeGetTime() callconv(.Stdcall) DWORD;
pub extern "winmm" fn timeGetDevCaps(ptc: LPTIMECAPS, cbtc: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn timeBeginPeriod(uPeriod: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn timeEndPeriod(uPeriod: UINT) callconv(.Stdcall) MMRESULT;
pub const struct_tagJOYCAPSA = extern struct {
    wMid: WORD,
    wPid: WORD,
    szPname: [32]CHAR,
    wXmin: UINT,
    wXmax: UINT,
    wYmin: UINT,
    wYmax: UINT,
    wZmin: UINT,
    wZmax: UINT,
    wNumButtons: UINT,
    wPeriodMin: UINT,
    wPeriodMax: UINT,
    wRmin: UINT,
    wRmax: UINT,
    wUmin: UINT,
    wUmax: UINT,
    wVmin: UINT,
    wVmax: UINT,
    wCaps: UINT,
    wMaxAxes: UINT,
    wNumAxes: UINT,
    wMaxButtons: UINT,
    szRegKey: [32]CHAR,
    szOEMVxD: [260]CHAR,
};
pub const JOYCAPSA = struct_tagJOYCAPSA;
pub const PJOYCAPSA = [*c]struct_tagJOYCAPSA;
pub const NPJOYCAPSA = [*c]struct_tagJOYCAPSA;
pub const LPJOYCAPSA = [*c]struct_tagJOYCAPSA;
pub const struct_tagJOYCAPSW = extern struct {
    wMid: WORD,
    wPid: WORD,
    szPname: [32]WCHAR,
    wXmin: UINT,
    wXmax: UINT,
    wYmin: UINT,
    wYmax: UINT,
    wZmin: UINT,
    wZmax: UINT,
    wNumButtons: UINT,
    wPeriodMin: UINT,
    wPeriodMax: UINT,
    wRmin: UINT,
    wRmax: UINT,
    wUmin: UINT,
    wUmax: UINT,
    wVmin: UINT,
    wVmax: UINT,
    wCaps: UINT,
    wMaxAxes: UINT,
    wNumAxes: UINT,
    wMaxButtons: UINT,
    szRegKey: [32]WCHAR,
    szOEMVxD: [260]WCHAR,
};
pub const JOYCAPSW = struct_tagJOYCAPSW;
pub const PJOYCAPSW = [*c]struct_tagJOYCAPSW;
pub const NPJOYCAPSW = [*c]struct_tagJOYCAPSW;
pub const LPJOYCAPSW = [*c]struct_tagJOYCAPSW;
pub const JOYCAPS = JOYCAPSA;
pub const PJOYCAPS = PJOYCAPSA;
pub const NPJOYCAPS = NPJOYCAPSA;
pub const LPJOYCAPS = LPJOYCAPSA;
pub const struct_tagJOYCAPS2A = extern struct {
    wMid: WORD,
    wPid: WORD,
    szPname: [32]CHAR,
    wXmin: UINT,
    wXmax: UINT,
    wYmin: UINT,
    wYmax: UINT,
    wZmin: UINT,
    wZmax: UINT,
    wNumButtons: UINT,
    wPeriodMin: UINT,
    wPeriodMax: UINT,
    wRmin: UINT,
    wRmax: UINT,
    wUmin: UINT,
    wUmax: UINT,
    wVmin: UINT,
    wVmax: UINT,
    wCaps: UINT,
    wMaxAxes: UINT,
    wNumAxes: UINT,
    wMaxButtons: UINT,
    szRegKey: [32]CHAR,
    szOEMVxD: [260]CHAR,
    ManufacturerGuid: GUID,
    ProductGuid: GUID,
    NameGuid: GUID,
};
pub const JOYCAPS2A = struct_tagJOYCAPS2A;
pub const PJOYCAPS2A = [*c]struct_tagJOYCAPS2A;
pub const NPJOYCAPS2A = [*c]struct_tagJOYCAPS2A;
pub const LPJOYCAPS2A = [*c]struct_tagJOYCAPS2A;
pub const struct_tagJOYCAPS2W = extern struct {
    wMid: WORD,
    wPid: WORD,
    szPname: [32]WCHAR,
    wXmin: UINT,
    wXmax: UINT,
    wYmin: UINT,
    wYmax: UINT,
    wZmin: UINT,
    wZmax: UINT,
    wNumButtons: UINT,
    wPeriodMin: UINT,
    wPeriodMax: UINT,
    wRmin: UINT,
    wRmax: UINT,
    wUmin: UINT,
    wUmax: UINT,
    wVmin: UINT,
    wVmax: UINT,
    wCaps: UINT,
    wMaxAxes: UINT,
    wNumAxes: UINT,
    wMaxButtons: UINT,
    szRegKey: [32]WCHAR,
    szOEMVxD: [260]WCHAR,
    ManufacturerGuid: GUID,
    ProductGuid: GUID,
    NameGuid: GUID,
};
pub const JOYCAPS2W = struct_tagJOYCAPS2W;
pub const PJOYCAPS2W = [*c]struct_tagJOYCAPS2W;
pub const NPJOYCAPS2W = [*c]struct_tagJOYCAPS2W;
pub const LPJOYCAPS2W = [*c]struct_tagJOYCAPS2W;
pub const JOYCAPS2 = JOYCAPS2A;
pub const PJOYCAPS2 = PJOYCAPS2A;
pub const NPJOYCAPS2 = NPJOYCAPS2A;
pub const LPJOYCAPS2 = LPJOYCAPS2A;
pub const struct_joyinfo_tag = extern struct {
    wXpos: UINT,
    wYpos: UINT,
    wZpos: UINT,
    wButtons: UINT,
};
pub const JOYINFO = struct_joyinfo_tag;
pub const PJOYINFO = [*c]struct_joyinfo_tag;
pub const NPJOYINFO = [*c]struct_joyinfo_tag;
pub const LPJOYINFO = [*c]struct_joyinfo_tag;
pub const struct_joyinfoex_tag = extern struct {
    dwSize: DWORD,
    dwFlags: DWORD,
    dwXpos: DWORD,
    dwYpos: DWORD,
    dwZpos: DWORD,
    dwRpos: DWORD,
    dwUpos: DWORD,
    dwVpos: DWORD,
    dwButtons: DWORD,
    dwButtonNumber: DWORD,
    dwPOV: DWORD,
    dwReserved1: DWORD,
    dwReserved2: DWORD,
};
pub const JOYINFOEX = struct_joyinfoex_tag;
pub const PJOYINFOEX = [*c]struct_joyinfoex_tag;
pub const NPJOYINFOEX = [*c]struct_joyinfoex_tag;
pub const LPJOYINFOEX = [*c]struct_joyinfoex_tag;
pub extern "winmm" fn joyGetPosEx(uJoyID: UINT, pji: LPJOYINFOEX) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn joyGetNumDevs() callconv(.Stdcall) UINT;
pub extern "winmm" fn joyGetDevCapsA(uJoyID: UINT_PTR, pjc: LPJOYCAPSA, cbjc: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn joyGetDevCapsW(uJoyID: UINT_PTR, pjc: LPJOYCAPSW, cbjc: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn joyGetPos(uJoyID: UINT, pji: LPJOYINFO) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn joyGetThreshold(uJoyID: UINT, puThreshold: LPUINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn joyReleaseCapture(uJoyID: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn joySetCapture(hwnd: HWND, uJoyID: UINT, uPeriod: UINT, fChanged: BOOL) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn joySetThreshold(uJoyID: UINT, uThreshold: UINT) callconv(.Stdcall) MMRESULT;
pub extern "winmm" fn joyConfigChanged(dwFlags: DWORD) callconv(.Stdcall) MMRESULT;
pub const struct__NCB = extern struct {
    ncb_command: UCHAR,
    ncb_retcode: UCHAR,
    ncb_lsn: UCHAR,
    ncb_num: UCHAR,
    ncb_buffer: PUCHAR,
    ncb_length: WORD,
    ncb_callname: [16]UCHAR,
    ncb_name: [16]UCHAR,
    ncb_rto: UCHAR,
    ncb_sto: UCHAR,
    ncb_post: ?fn ([*c]struct__NCB) callconv(.C) void,
    ncb_lana_num: UCHAR,
    ncb_cmd_cplt: UCHAR,
    ncb_reserve: [18]UCHAR,
    ncb_event: HANDLE,
};
pub const NCB = struct__NCB;
pub const PNCB = [*c]struct__NCB;
pub const struct__ADAPTER_STATUS = extern struct {
    adapter_address: [6]UCHAR,
    rev_major: UCHAR,
    reserved0: UCHAR,
    adapter_type: UCHAR,
    rev_minor: UCHAR,
    duration: WORD,
    frmr_recv: WORD,
    frmr_xmit: WORD,
    iframe_recv_err: WORD,
    xmit_aborts: WORD,
    xmit_success: DWORD,
    recv_success: DWORD,
    iframe_xmit_err: WORD,
    recv_buff_unavail: WORD,
    t1_timeouts: WORD,
    ti_timeouts: WORD,
    reserved1: DWORD,
    free_ncbs: WORD,
    max_cfg_ncbs: WORD,
    max_ncbs: WORD,
    xmit_buf_unavail: WORD,
    max_dgram_size: WORD,
    pending_sess: WORD,
    max_cfg_sess: WORD,
    max_sess: WORD,
    max_sess_pkt_size: WORD,
    name_count: WORD,
};
pub const ADAPTER_STATUS = struct__ADAPTER_STATUS;
pub const PADAPTER_STATUS = [*c]struct__ADAPTER_STATUS;
pub const struct__NAME_BUFFER = extern struct {
    name: [16]UCHAR,
    name_num: UCHAR,
    name_flags: UCHAR,
};
pub const NAME_BUFFER = struct__NAME_BUFFER;
pub const PNAME_BUFFER = [*c]struct__NAME_BUFFER;
pub const struct__SESSION_HEADER = extern struct {
    sess_name: UCHAR,
    num_sess: UCHAR,
    rcv_dg_outstanding: UCHAR,
    rcv_any_outstanding: UCHAR,
};
pub const SESSION_HEADER = struct__SESSION_HEADER;
pub const PSESSION_HEADER = [*c]struct__SESSION_HEADER;
pub const struct__SESSION_BUFFER = extern struct {
    lsn: UCHAR,
    state: UCHAR,
    local_name: [16]UCHAR,
    remote_name: [16]UCHAR,
    rcvs_outstanding: UCHAR,
    sends_outstanding: UCHAR,
};
pub const SESSION_BUFFER = struct__SESSION_BUFFER;
pub const PSESSION_BUFFER = [*c]struct__SESSION_BUFFER;
pub const struct__LANA_ENUM = extern struct {
    length: UCHAR,
    lana: [255]UCHAR,
};
pub const LANA_ENUM = struct__LANA_ENUM;
pub const PLANA_ENUM = [*c]struct__LANA_ENUM;
pub const struct__FIND_NAME_HEADER = extern struct {
    node_count: WORD,
    reserved: UCHAR,
    unique_group: UCHAR,
};
pub const FIND_NAME_HEADER = struct__FIND_NAME_HEADER;
pub const PFIND_NAME_HEADER = [*c]struct__FIND_NAME_HEADER;
pub const struct__FIND_NAME_BUFFER = extern struct {
    length: UCHAR,
    access_control: UCHAR,
    frame_control: UCHAR,
    destination_addr: [6]UCHAR,
    source_addr: [6]UCHAR,
    routing_info: [18]UCHAR,
};
pub const FIND_NAME_BUFFER = struct__FIND_NAME_BUFFER;
pub const PFIND_NAME_BUFFER = [*c]struct__FIND_NAME_BUFFER;
pub const struct__ACTION_HEADER = extern struct {
    transport_id: ULONG,
    action_code: USHORT,
    reserved: USHORT,
};
pub const ACTION_HEADER = struct__ACTION_HEADER;
pub const PACTION_HEADER = [*c]struct__ACTION_HEADER;
pub extern "netapi32" fn Netbios(pncb: PNCB) callconv(.Stdcall) UCHAR;
pub const I_RPC_HANDLE = ?*c_void;
pub const RPC_STATUS = c_long;
pub const RPC_CSTR = [*c]u8;
pub const RPC_WSTR = [*c]c_ushort;
pub const RPC_CWSTR = [*c]const c_ushort;
pub const RPC_BINDING_HANDLE = I_RPC_HANDLE;
pub const handle_t = RPC_BINDING_HANDLE;
pub const UUID = GUID;
pub const struct__RPC_BINDING_VECTOR = extern struct {
    Count: c_ulong,
    BindingH: [1]RPC_BINDING_HANDLE,
};
pub const RPC_BINDING_VECTOR = struct__RPC_BINDING_VECTOR;
pub const struct__UUID_VECTOR = extern struct {
    Count: c_ulong,
    Uuid: [1]([*c]UUID),
};
pub const UUID_VECTOR = struct__UUID_VECTOR;
pub const RPC_IF_HANDLE = ?*c_void;
pub const struct__RPC_IF_ID = extern struct {
    Uuid: UUID,
    VersMajor: c_ushort,
    VersMinor: c_ushort,
};
pub const RPC_IF_ID = struct__RPC_IF_ID;
pub const struct__RPC_PROTSEQ_VECTORA = extern struct {
    Count: c_uint,
    Protseq: [1]([*c]u8),
};
pub const RPC_PROTSEQ_VECTORA = struct__RPC_PROTSEQ_VECTORA;
pub const struct__RPC_PROTSEQ_VECTORW = extern struct {
    Count: c_uint,
    Protseq: [1]([*c]c_ushort),
};
pub const RPC_PROTSEQ_VECTORW = struct__RPC_PROTSEQ_VECTORW;
pub const struct__RPC_POLICY = extern struct {
    Length: c_uint,
    EndpointFlags: c_ulong,
    NICFlags: c_ulong,
};
pub const RPC_POLICY = struct__RPC_POLICY;
pub const PRPC_POLICY = [*c]struct__RPC_POLICY;
pub const RPC_OBJECT_INQ_FN = fn ([*c]UUID, [*c]UUID, [*c]RPC_STATUS) callconv(.C) void;
pub const RPC_IF_CALLBACK_FN = fn (RPC_IF_HANDLE, ?*c_void) callconv(.C) RPC_STATUS;
pub const RPC_SECURITY_CALLBACK_FN = fn (?*c_void) callconv(.C) void;
pub const RPC_STATS_VECTOR = extern struct {
    Count: c_uint,
    Stats: [1]c_ulong,
};
pub const RPC_IF_ID_VECTOR = extern struct {
    Count: c_ulong,
    IfId: [1]([*c]RPC_IF_ID),
};
pub extern "rpcrt4" fn RpcBindingCopy(SourceBinding: RPC_BINDING_HANDLE, DestinationBinding: [*c]RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingFree(Binding: [*c]RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingSetOption(hBinding: RPC_BINDING_HANDLE, option: c_ulong, optionValue: ULONG_PTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingInqOption(hBinding: RPC_BINDING_HANDLE, option: c_ulong, pOptionValue: [*c]ULONG_PTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingFromStringBindingA(StringBinding: RPC_CSTR, Binding: [*c]RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingFromStringBindingW(StringBinding: RPC_WSTR, Binding: [*c]RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcSsGetContextBinding(ContextHandle: ?*c_void, Binding: [*c]RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingInqObject(Binding: RPC_BINDING_HANDLE, ObjectUuid: [*c]UUID) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingReset(Binding: RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingSetObject(Binding: RPC_BINDING_HANDLE, ObjectUuid: [*c]UUID) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcMgmtInqDefaultProtectLevel(AuthnSvc: c_ulong, AuthnLevel: [*c]c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingToStringBindingA(Binding: RPC_BINDING_HANDLE, StringBinding: [*c]RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingToStringBindingW(Binding: RPC_BINDING_HANDLE, StringBinding: [*c]RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingVectorFree(BindingVector: [*c]([*c]RPC_BINDING_VECTOR)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcStringBindingComposeA(ObjUuid: RPC_CSTR, ProtSeq: RPC_CSTR, NetworkAddr: RPC_CSTR, Endpoint: RPC_CSTR, Options: RPC_CSTR, StringBinding: [*c]RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcStringBindingComposeW(ObjUuid: RPC_WSTR, ProtSeq: RPC_WSTR, NetworkAddr: RPC_WSTR, Endpoint: RPC_WSTR, Options: RPC_WSTR, StringBinding: [*c]RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcStringBindingParseA(StringBinding: RPC_CSTR, ObjUuid: [*c]RPC_CSTR, Protseq: [*c]RPC_CSTR, NetworkAddr: [*c]RPC_CSTR, Endpoint: [*c]RPC_CSTR, NetworkOptions: [*c]RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcStringBindingParseW(StringBinding: RPC_WSTR, ObjUuid: [*c]RPC_WSTR, Protseq: [*c]RPC_WSTR, NetworkAddr: [*c]RPC_WSTR, Endpoint: [*c]RPC_WSTR, NetworkOptions: [*c]RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcStringFreeA(String: [*c]RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcStringFreeW(String: [*c]RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcIfInqId(RpcIfHandle: RPC_IF_HANDLE, RpcIfId: [*c]RPC_IF_ID) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcNetworkIsProtseqValidA(Protseq: RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcNetworkIsProtseqValidW(Protseq: RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcMgmtInqComTimeout(Binding: RPC_BINDING_HANDLE, Timeout: [*c]c_uint) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcMgmtSetComTimeout(Binding: RPC_BINDING_HANDLE, Timeout: c_uint) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcMgmtSetCancelTimeout(Timeout: c_long) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcNetworkInqProtseqsA(ProtseqVector: [*c]([*c]RPC_PROTSEQ_VECTORA)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcNetworkInqProtseqsW(ProtseqVector: [*c]([*c]RPC_PROTSEQ_VECTORW)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcObjectInqType(ObjUuid: [*c]UUID, TypeUuid: [*c]UUID) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcObjectSetInqFn(InquiryFn: [*c]RPC_OBJECT_INQ_FN) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcObjectSetType(ObjUuid: [*c]UUID, TypeUuid: [*c]UUID) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcProtseqVectorFreeA(ProtseqVector: [*c]([*c]RPC_PROTSEQ_VECTORA)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcProtseqVectorFreeW(ProtseqVector: [*c]([*c]RPC_PROTSEQ_VECTORW)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerInqBindings(BindingVector: [*c]([*c]RPC_BINDING_VECTOR)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerInqBindingsEx(SecurityDescriptor: ?*c_void, BindingVector: [*c]([*c]RPC_BINDING_VECTOR)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerInqIf(IfSpec: RPC_IF_HANDLE, MgrTypeUuid: [*c]UUID, MgrEpv: [*c](?*c_void)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerListen(MinimumCallThreads: c_uint, MaxCalls: c_uint, DontWait: c_uint) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerRegisterIf(IfSpec: RPC_IF_HANDLE, MgrTypeUuid: [*c]UUID, MgrEpv: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerRegisterIfEx(IfSpec: RPC_IF_HANDLE, MgrTypeUuid: [*c]UUID, MgrEpv: ?*c_void, Flags: c_uint, MaxCalls: c_uint, IfCallback: [*c]RPC_IF_CALLBACK_FN) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerRegisterIf2(IfSpec: RPC_IF_HANDLE, MgrTypeUuid: [*c]UUID, MgrEpv: ?*c_void, Flags: c_uint, MaxCalls: c_uint, MaxRpcSize: c_uint, IfCallbackFn: [*c]RPC_IF_CALLBACK_FN) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerRegisterIf3(IfSpec: RPC_IF_HANDLE, MgrTypeUuid: [*c]UUID, MgrEpv: ?*c_void, Flags: c_uint, MaxCalls: c_uint, MaxRpcSize: c_uint, IfCallback: [*c]RPC_IF_CALLBACK_FN, SecurityDescriptor: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUnregisterIf(IfSpec: RPC_IF_HANDLE, MgrTypeUuid: [*c]UUID, WaitForCallsToComplete: c_uint) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUnregisterIfEx(IfSpec: RPC_IF_HANDLE, MgrTypeUuid: [*c]UUID, RundownContextHandles: c_int) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUseAllProtseqs(MaxCalls: c_uint, SecurityDescriptor: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUseAllProtseqsEx(MaxCalls: c_uint, SecurityDescriptor: ?*c_void, Policy: PRPC_POLICY) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUseAllProtseqsIf(MaxCalls: c_uint, IfSpec: RPC_IF_HANDLE, SecurityDescriptor: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUseAllProtseqsIfEx(MaxCalls: c_uint, IfSpec: RPC_IF_HANDLE, SecurityDescriptor: ?*c_void, Policy: PRPC_POLICY) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUseProtseqA(Protseq: RPC_CSTR, MaxCalls: c_uint, SecurityDescriptor: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUseProtseqExA(Protseq: RPC_CSTR, MaxCalls: c_uint, SecurityDescriptor: ?*c_void, Policy: PRPC_POLICY) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUseProtseqW(Protseq: RPC_WSTR, MaxCalls: c_uint, SecurityDescriptor: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUseProtseqExW(Protseq: RPC_WSTR, MaxCalls: c_uint, SecurityDescriptor: ?*c_void, Policy: PRPC_POLICY) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUseProtseqEpA(Protseq: RPC_CSTR, MaxCalls: c_uint, Endpoint: RPC_CSTR, SecurityDescriptor: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUseProtseqEpExA(Protseq: RPC_CSTR, MaxCalls: c_uint, Endpoint: RPC_CSTR, SecurityDescriptor: ?*c_void, Policy: PRPC_POLICY) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUseProtseqEpW(Protseq: RPC_WSTR, MaxCalls: c_uint, Endpoint: RPC_WSTR, SecurityDescriptor: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUseProtseqEpExW(Protseq: RPC_WSTR, MaxCalls: c_uint, Endpoint: RPC_WSTR, SecurityDescriptor: ?*c_void, Policy: PRPC_POLICY) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUseProtseqIfA(Protseq: RPC_CSTR, MaxCalls: c_uint, IfSpec: RPC_IF_HANDLE, SecurityDescriptor: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUseProtseqIfExA(Protseq: RPC_CSTR, MaxCalls: c_uint, IfSpec: RPC_IF_HANDLE, SecurityDescriptor: ?*c_void, Policy: PRPC_POLICY) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUseProtseqIfW(Protseq: RPC_WSTR, MaxCalls: c_uint, IfSpec: RPC_IF_HANDLE, SecurityDescriptor: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUseProtseqIfExW(Protseq: RPC_WSTR, MaxCalls: c_uint, IfSpec: RPC_IF_HANDLE, SecurityDescriptor: ?*c_void, Policy: PRPC_POLICY) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerYield() callconv(.Stdcall) void;
pub extern "rpcrt4" fn RpcMgmtStatsVectorFree(StatsVector: [*c]([*c]RPC_STATS_VECTOR)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcMgmtInqStats(Binding: RPC_BINDING_HANDLE, Statistics: [*c]([*c]RPC_STATS_VECTOR)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcMgmtIsServerListening(Binding: RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcMgmtStopServerListening(Binding: RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcMgmtWaitServerListen() callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcMgmtSetServerStackSize(ThreadStackSize: c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcSsDontSerializeContext() callconv(.Stdcall) void;
pub extern "rpcrt4" fn RpcMgmtEnableIdleCleanup() callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcMgmtInqIfIds(Binding: RPC_BINDING_HANDLE, IfIdVector: [*c]([*c]RPC_IF_ID_VECTOR)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcIfIdVectorFree(IfIdVector: [*c]([*c]RPC_IF_ID_VECTOR)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcMgmtInqServerPrincNameA(Binding: RPC_BINDING_HANDLE, AuthnSvc: c_ulong, ServerPrincName: [*c]RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcMgmtInqServerPrincNameW(Binding: RPC_BINDING_HANDLE, AuthnSvc: c_ulong, ServerPrincName: [*c]RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerInqDefaultPrincNameA(AuthnSvc: c_ulong, PrincName: [*c]RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerInqDefaultPrincNameW(AuthnSvc: c_ulong, PrincName: [*c]RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcEpResolveBinding(Binding: RPC_BINDING_HANDLE, IfSpec: RPC_IF_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcNsBindingInqEntryNameA(Binding: RPC_BINDING_HANDLE, EntryNameSyntax: c_ulong, EntryName: [*c]RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcNsBindingInqEntryNameW(Binding: RPC_BINDING_HANDLE, EntryNameSyntax: c_ulong, EntryName: [*c]RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub const RPC_AUTH_IDENTITY_HANDLE = ?*c_void;
pub const RPC_AUTHZ_HANDLE = ?*c_void;
pub const struct__RPC_SECURITY_QOS = extern struct {
    Version: c_ulong,
    Capabilities: c_ulong,
    IdentityTracking: c_ulong,
    ImpersonationType: c_ulong,
};
pub const RPC_SECURITY_QOS = struct__RPC_SECURITY_QOS;
pub const PRPC_SECURITY_QOS = [*c]struct__RPC_SECURITY_QOS;
pub const struct__SEC_WINNT_AUTH_IDENTITY_W = extern struct {
    User: [*c]c_ushort,
    UserLength: c_ulong,
    Domain: [*c]c_ushort,
    DomainLength: c_ulong,
    Password: [*c]c_ushort,
    PasswordLength: c_ulong,
    Flags: c_ulong,
};
pub const SEC_WINNT_AUTH_IDENTITY_W = struct__SEC_WINNT_AUTH_IDENTITY_W;
pub const PSEC_WINNT_AUTH_IDENTITY_W = [*c]struct__SEC_WINNT_AUTH_IDENTITY_W;
pub const struct__SEC_WINNT_AUTH_IDENTITY_A = extern struct {
    User: [*c]u8,
    UserLength: c_ulong,
    Domain: [*c]u8,
    DomainLength: c_ulong,
    Password: [*c]u8,
    PasswordLength: c_ulong,
    Flags: c_ulong,
};
pub const SEC_WINNT_AUTH_IDENTITY_A = struct__SEC_WINNT_AUTH_IDENTITY_A;
pub const PSEC_WINNT_AUTH_IDENTITY_A = [*c]struct__SEC_WINNT_AUTH_IDENTITY_A;
pub const struct__RPC_HTTP_TRANSPORT_CREDENTIALS_W = extern struct {
    TransportCredentials: [*c]SEC_WINNT_AUTH_IDENTITY_W,
    Flags: c_ulong,
    AuthenticationTarget: c_ulong,
    NumberOfAuthnSchemes: c_ulong,
    AuthnSchemes: [*c]c_ulong,
    ServerCertificateSubject: [*c]c_ushort,
};
pub const RPC_HTTP_TRANSPORT_CREDENTIALS_W = struct__RPC_HTTP_TRANSPORT_CREDENTIALS_W;
pub const PRPC_HTTP_TRANSPORT_CREDENTIALS_W = [*c]struct__RPC_HTTP_TRANSPORT_CREDENTIALS_W;
pub const struct__RPC_HTTP_TRANSPORT_CREDENTIALS_A = extern struct {
    TransportCredentials: [*c]SEC_WINNT_AUTH_IDENTITY_A,
    Flags: c_ulong,
    AuthenticationTarget: c_ulong,
    NumberOfAuthnSchemes: c_ulong,
    AuthnSchemes: [*c]c_ulong,
    ServerCertificateSubject: [*c]u8,
};
pub const RPC_HTTP_TRANSPORT_CREDENTIALS_A = struct__RPC_HTTP_TRANSPORT_CREDENTIALS_A;
pub const PRPC_HTTP_TRANSPORT_CREDENTIALS_A = [*c]struct__RPC_HTTP_TRANSPORT_CREDENTIALS_A;
pub const struct__RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W = extern struct {
    TransportCredentials: [*c]SEC_WINNT_AUTH_IDENTITY_W,
    Flags: c_ulong,
    AuthenticationTarget: c_ulong,
    NumberOfAuthnSchemes: c_ulong,
    AuthnSchemes: [*c]c_ulong,
    ServerCertificateSubject: [*c]c_ushort,
    ProxyCredentials: [*c]SEC_WINNT_AUTH_IDENTITY_W,
    NumberOfProxyAuthnSchemes: c_ulong,
    ProxyAuthnSchemes: [*c]c_ulong,
};
pub const RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W = struct__RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W;
pub const PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_W = [*c]struct__RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W;
pub const struct__RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A = extern struct {
    TransportCredentials: [*c]SEC_WINNT_AUTH_IDENTITY_A,
    Flags: c_ulong,
    AuthenticationTarget: c_ulong,
    NumberOfAuthnSchemes: c_ulong,
    AuthnSchemes: [*c]c_ulong,
    ServerCertificateSubject: [*c]u8,
    ProxyCredentials: [*c]SEC_WINNT_AUTH_IDENTITY_A,
    NumberOfProxyAuthnSchemes: c_ulong,
    ProxyAuthnSchemes: [*c]c_ulong,
};
pub const RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A = struct__RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A;
pub const PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_A = [*c]struct__RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A;
pub const struct__RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W = extern struct {
    TransportCredentials: RPC_AUTH_IDENTITY_HANDLE,
    Flags: c_ulong,
    AuthenticationTarget: c_ulong,
    NumberOfAuthnSchemes: c_ulong,
    AuthnSchemes: [*c]c_ulong,
    ServerCertificateSubject: [*c]c_ushort,
    ProxyCredentials: RPC_AUTH_IDENTITY_HANDLE,
    NumberOfProxyAuthnSchemes: c_ulong,
    ProxyAuthnSchemes: [*c]c_ulong,
};
pub const RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W = struct__RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W;
pub const PRPC_HTTP_TRANSPORT_CREDENTIALS_V3_W = [*c]struct__RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W;
pub const struct__RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A = extern struct {
    TransportCredentials: RPC_AUTH_IDENTITY_HANDLE,
    Flags: c_ulong,
    AuthenticationTarget: c_ulong,
    NumberOfAuthnSchemes: c_ulong,
    AuthnSchemes: [*c]c_ulong,
    ServerCertificateSubject: [*c]u8,
    ProxyCredentials: RPC_AUTH_IDENTITY_HANDLE,
    NumberOfProxyAuthnSchemes: c_ulong,
    ProxyAuthnSchemes: [*c]c_ulong,
};
pub const RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A = struct__RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A;
pub const PRPC_HTTP_TRANSPORT_CREDENTIALS_V3_A = [*c]struct__RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A;
pub const struct__RPC_SECURITY_QOS_V2_W = extern struct {
    Version: c_ulong,
    Capabilities: c_ulong,
    IdentityTracking: c_ulong,
    ImpersonationType: c_ulong,
    AdditionalSecurityInfoType: c_ulong,
    u: extern union {
        HttpCredentials: [*c]RPC_HTTP_TRANSPORT_CREDENTIALS_W,
    },
};
pub const RPC_SECURITY_QOS_V2_W = struct__RPC_SECURITY_QOS_V2_W;
pub const PRPC_SECURITY_QOS_V2_W = [*c]struct__RPC_SECURITY_QOS_V2_W;
pub const struct__RPC_SECURITY_QOS_V2_A = extern struct {
    Version: c_ulong,
    Capabilities: c_ulong,
    IdentityTracking: c_ulong,
    ImpersonationType: c_ulong,
    AdditionalSecurityInfoType: c_ulong,
    u: extern union {
        HttpCredentials: [*c]RPC_HTTP_TRANSPORT_CREDENTIALS_A,
    },
};
pub const RPC_SECURITY_QOS_V2_A = struct__RPC_SECURITY_QOS_V2_A;
pub const PRPC_SECURITY_QOS_V2_A = [*c]struct__RPC_SECURITY_QOS_V2_A;
pub const struct__RPC_SECURITY_QOS_V3_W = extern struct {
    Version: c_ulong,
    Capabilities: c_ulong,
    IdentityTracking: c_ulong,
    ImpersonationType: c_ulong,
    AdditionalSecurityInfoType: c_ulong,
    u: extern union {
        HttpCredentials: [*c]RPC_HTTP_TRANSPORT_CREDENTIALS_W,
    },
    Sid: ?*c_void,
};
pub const RPC_SECURITY_QOS_V3_W = struct__RPC_SECURITY_QOS_V3_W;
pub const PRPC_SECURITY_QOS_V3_W = [*c]struct__RPC_SECURITY_QOS_V3_W;
pub const struct__RPC_SECURITY_QOS_V3_A = extern struct {
    Version: c_ulong,
    Capabilities: c_ulong,
    IdentityTracking: c_ulong,
    ImpersonationType: c_ulong,
    AdditionalSecurityInfoType: c_ulong,
    u: extern union {
        HttpCredentials: [*c]RPC_HTTP_TRANSPORT_CREDENTIALS_A,
    },
    Sid: ?*c_void,
};
pub const RPC_SECURITY_QOS_V3_A = struct__RPC_SECURITY_QOS_V3_A;
pub const PRPC_SECURITY_QOS_V3_A = [*c]struct__RPC_SECURITY_QOS_V3_A;
pub const struct__RPC_SECURITY_QOS_V4_W = extern struct {
    Version: c_ulong,
    Capabilities: c_ulong,
    IdentityTracking: c_ulong,
    ImpersonationType: c_ulong,
    AdditionalSecurityInfoType: c_ulong,
    u: extern union {
        HttpCredentials: [*c]RPC_HTTP_TRANSPORT_CREDENTIALS_W,
    },
    Sid: ?*c_void,
    EffectiveOnly: c_uint,
};
pub const RPC_SECURITY_QOS_V4_W = struct__RPC_SECURITY_QOS_V4_W;
pub const PRPC_SECURITY_QOS_V4_W = [*c]struct__RPC_SECURITY_QOS_V4_W;
pub const struct__RPC_SECURITY_QOS_V4_A = extern struct {
    Version: c_ulong,
    Capabilities: c_ulong,
    IdentityTracking: c_ulong,
    ImpersonationType: c_ulong,
    AdditionalSecurityInfoType: c_ulong,
    u: extern union {
        HttpCredentials: [*c]RPC_HTTP_TRANSPORT_CREDENTIALS_A,
    },
    Sid: ?*c_void,
    EffectiveOnly: c_uint,
};
pub const RPC_SECURITY_QOS_V4_A = struct__RPC_SECURITY_QOS_V4_A;
pub const PRPC_SECURITY_QOS_V4_A = [*c]struct__RPC_SECURITY_QOS_V4_A;
pub const struct__RPC_SECURITY_QOS_V5_W = extern struct {
    Version: c_ulong,
    Capabilities: c_ulong,
    IdentityTracking: c_ulong,
    ImpersonationType: c_ulong,
    AdditionalSecurityInfoType: c_ulong,
    u: extern union {
        HttpCredentials: [*c]RPC_HTTP_TRANSPORT_CREDENTIALS_W,
    },
    Sid: ?*c_void,
    EffectiveOnly: c_uint,
    ServerSecurityDescriptor: ?*c_void,
};
pub const RPC_SECURITY_QOS_V5_W = struct__RPC_SECURITY_QOS_V5_W;
pub const PRPC_SECURITY_QOS_V5_W = [*c]struct__RPC_SECURITY_QOS_V5_W;
pub const struct__RPC_SECURITY_QOS_V5_A = extern struct {
    Version: c_ulong,
    Capabilities: c_ulong,
    IdentityTracking: c_ulong,
    ImpersonationType: c_ulong,
    AdditionalSecurityInfoType: c_ulong,
    u: extern union {
        HttpCredentials: [*c]RPC_HTTP_TRANSPORT_CREDENTIALS_A,
    },
    Sid: ?*c_void,
    EffectiveOnly: c_uint,
    ServerSecurityDescriptor: ?*c_void,
};
pub const RPC_SECURITY_QOS_V5_A = struct__RPC_SECURITY_QOS_V5_A;
pub const PRPC_SECURITY_QOS_V5_A = [*c]struct__RPC_SECURITY_QOS_V5_A;
pub const struct__RPC_BINDING_HANDLE_TEMPLATE_V1_W = extern struct {
    Version: c_ulong,
    Flags: c_ulong,
    ProtocolSequence: c_ulong,
    NetworkAddress: [*c]c_ushort,
    StringEndpoint: [*c]c_ushort,
    u1: extern union {
        Reserved: [*c]c_ushort,
    },
    ObjectUuid: UUID,
};
pub const RPC_BINDING_HANDLE_TEMPLATE_V1_W = struct__RPC_BINDING_HANDLE_TEMPLATE_V1_W;
pub const PRPC_BINDING_HANDLE_TEMPLATE_V1_W = [*c]struct__RPC_BINDING_HANDLE_TEMPLATE_V1_W;
pub const struct__RPC_BINDING_HANDLE_TEMPLATE_V1_A = extern struct {
    Version: c_ulong,
    Flags: c_ulong,
    ProtocolSequence: c_ulong,
    NetworkAddress: [*c]u8,
    StringEndpoint: [*c]u8,
    u1: extern union {
        Reserved: [*c]u8,
    },
    ObjectUuid: UUID,
};
pub const RPC_BINDING_HANDLE_TEMPLATE_V1_A = struct__RPC_BINDING_HANDLE_TEMPLATE_V1_A;
pub const PRPC_BINDING_HANDLE_TEMPLATE_V1_A = [*c]struct__RPC_BINDING_HANDLE_TEMPLATE_V1_A;
pub const struct__RPC_BINDING_HANDLE_SECURITY_V1_W = extern struct {
    Version: c_ulong,
    ServerPrincName: [*c]c_ushort,
    AuthnLevel: c_ulong,
    AuthnSvc: c_ulong,
    AuthIdentity: [*c]SEC_WINNT_AUTH_IDENTITY_W,
    SecurityQos: [*c]RPC_SECURITY_QOS,
};
pub const RPC_BINDING_HANDLE_SECURITY_V1_W = struct__RPC_BINDING_HANDLE_SECURITY_V1_W;
pub const PRPC_BINDING_HANDLE_SECURITY_V1_W = [*c]struct__RPC_BINDING_HANDLE_SECURITY_V1_W;
pub const struct__RPC_BINDING_HANDLE_SECURITY_V1_A = extern struct {
    Version: c_ulong,
    ServerPrincName: [*c]u8,
    AuthnLevel: c_ulong,
    AuthnSvc: c_ulong,
    AuthIdentity: [*c]SEC_WINNT_AUTH_IDENTITY_A,
    SecurityQos: [*c]RPC_SECURITY_QOS,
};
pub const RPC_BINDING_HANDLE_SECURITY_V1_A = struct__RPC_BINDING_HANDLE_SECURITY_V1_A;
pub const PRPC_BINDING_HANDLE_SECURITY_V1_A = [*c]struct__RPC_BINDING_HANDLE_SECURITY_V1_A;
pub const struct__RPC_BINDING_HANDLE_OPTIONS_V1 = extern struct {
    Version: c_ulong,
    Flags: c_ulong,
    ComTimeout: c_ulong,
    CallTimeout: c_ulong,
};
pub const RPC_BINDING_HANDLE_OPTIONS_V1 = struct__RPC_BINDING_HANDLE_OPTIONS_V1;
pub const PRPC_BINDING_HANDLE_OPTIONS_V1 = [*c]struct__RPC_BINDING_HANDLE_OPTIONS_V1;
pub extern "rpcrt4" fn RpcBindingCreateA(Template: [*c]RPC_BINDING_HANDLE_TEMPLATE_V1_A, Security: [*c]RPC_BINDING_HANDLE_SECURITY_V1_A, Options: [*c]RPC_BINDING_HANDLE_OPTIONS_V1, Binding: [*c]RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingCreateW(Template: [*c]RPC_BINDING_HANDLE_TEMPLATE_V1_W, Security: [*c]RPC_BINDING_HANDLE_SECURITY_V1_W, Options: [*c]RPC_BINDING_HANDLE_OPTIONS_V1, Binding: [*c]RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingGetTrainingContextHandle(Binding: RPC_BINDING_HANDLE, ContextHandle: [*c](?*c_void)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerInqBindingHandle(Binding: [*c]RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub const RPCHTTP_RS_REDIRECT = enum__RPC_HTTP_REDIRECTOR_STAGE.RPCHTTP_RS_REDIRECT;
pub const RPCHTTP_RS_ACCESS_1 = enum__RPC_HTTP_REDIRECTOR_STAGE.RPCHTTP_RS_ACCESS_1;
pub const RPCHTTP_RS_SESSION = enum__RPC_HTTP_REDIRECTOR_STAGE.RPCHTTP_RS_SESSION;
pub const RPCHTTP_RS_ACCESS_2 = enum__RPC_HTTP_REDIRECTOR_STAGE.RPCHTTP_RS_ACCESS_2;
pub const RPCHTTP_RS_INTERFACE = enum__RPC_HTTP_REDIRECTOR_STAGE.RPCHTTP_RS_INTERFACE;
pub const enum__RPC_HTTP_REDIRECTOR_STAGE = extern enum {
    RPCHTTP_RS_REDIRECT = 1,
    RPCHTTP_RS_ACCESS_1 = 2,
    RPCHTTP_RS_SESSION = 3,
    RPCHTTP_RS_ACCESS_2 = 4,
    RPCHTTP_RS_INTERFACE = 5,
};
pub const RPC_HTTP_REDIRECTOR_STAGE = enum__RPC_HTTP_REDIRECTOR_STAGE;
pub const RPC_NEW_HTTP_PROXY_CHANNEL = ?fn (RPC_HTTP_REDIRECTOR_STAGE, RPC_WSTR, RPC_WSTR, RPC_WSTR, RPC_WSTR, ?*c_void, ?*c_void, ?*c_void, ?*c_void, c_ulong, [*c]RPC_WSTR, [*c]RPC_WSTR) callconv(.C) RPC_STATUS;
pub const RPC_HTTP_PROXY_FREE_STRING = ?fn (RPC_WSTR) callconv(.C) void;
pub extern "rpcrt4" fn RpcImpersonateClient(BindingHandle: RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcImpersonateClient2(BindingHandle: RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcRevertToSelfEx(BindingHandle: RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcRevertToSelf() callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcImpersonateClientContainer(BindingHandle: RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcRevertContainerImpersonation() callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingInqAuthClientA(ClientBinding: RPC_BINDING_HANDLE, Privs: [*c]RPC_AUTHZ_HANDLE, ServerPrincName: [*c]RPC_CSTR, AuthnLevel: [*c]c_ulong, AuthnSvc: [*c]c_ulong, AuthzSvc: [*c]c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingInqAuthClientW(ClientBinding: RPC_BINDING_HANDLE, Privs: [*c]RPC_AUTHZ_HANDLE, ServerPrincName: [*c]RPC_WSTR, AuthnLevel: [*c]c_ulong, AuthnSvc: [*c]c_ulong, AuthzSvc: [*c]c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingInqAuthClientExA(ClientBinding: RPC_BINDING_HANDLE, Privs: [*c]RPC_AUTHZ_HANDLE, ServerPrincName: [*c]RPC_CSTR, AuthnLevel: [*c]c_ulong, AuthnSvc: [*c]c_ulong, AuthzSvc: [*c]c_ulong, Flags: c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingInqAuthClientExW(ClientBinding: RPC_BINDING_HANDLE, Privs: [*c]RPC_AUTHZ_HANDLE, ServerPrincName: [*c]RPC_WSTR, AuthnLevel: [*c]c_ulong, AuthnSvc: [*c]c_ulong, AuthzSvc: [*c]c_ulong, Flags: c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingInqAuthInfoA(Binding: RPC_BINDING_HANDLE, ServerPrincName: [*c]RPC_CSTR, AuthnLevel: [*c]c_ulong, AuthnSvc: [*c]c_ulong, AuthIdentity: [*c]RPC_AUTH_IDENTITY_HANDLE, AuthzSvc: [*c]c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingInqAuthInfoW(Binding: RPC_BINDING_HANDLE, ServerPrincName: [*c]RPC_WSTR, AuthnLevel: [*c]c_ulong, AuthnSvc: [*c]c_ulong, AuthIdentity: [*c]RPC_AUTH_IDENTITY_HANDLE, AuthzSvc: [*c]c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingSetAuthInfoA(Binding: RPC_BINDING_HANDLE, ServerPrincName: RPC_CSTR, AuthnLevel: c_ulong, AuthnSvc: c_ulong, AuthIdentity: RPC_AUTH_IDENTITY_HANDLE, AuthzSvc: c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingSetAuthInfoExA(Binding: RPC_BINDING_HANDLE, ServerPrincName: RPC_CSTR, AuthnLevel: c_ulong, AuthnSvc: c_ulong, AuthIdentity: RPC_AUTH_IDENTITY_HANDLE, AuthzSvc: c_ulong, SecurityQos: [*c]RPC_SECURITY_QOS) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingSetAuthInfoW(Binding: RPC_BINDING_HANDLE, ServerPrincName: RPC_WSTR, AuthnLevel: c_ulong, AuthnSvc: c_ulong, AuthIdentity: RPC_AUTH_IDENTITY_HANDLE, AuthzSvc: c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingSetAuthInfoExW(Binding: RPC_BINDING_HANDLE, ServerPrincName: RPC_WSTR, AuthnLevel: c_ulong, AuthnSvc: c_ulong, AuthIdentity: RPC_AUTH_IDENTITY_HANDLE, AuthzSvc: c_ulong, SecurityQOS: [*c]RPC_SECURITY_QOS) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingInqAuthInfoExA(Binding: RPC_BINDING_HANDLE, ServerPrincName: [*c]RPC_CSTR, AuthnLevel: [*c]c_ulong, AuthnSvc: [*c]c_ulong, AuthIdentity: [*c]RPC_AUTH_IDENTITY_HANDLE, AuthzSvc: [*c]c_ulong, RpcQosVersion: c_ulong, SecurityQOS: [*c]RPC_SECURITY_QOS) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingInqAuthInfoExW(Binding: RPC_BINDING_HANDLE, ServerPrincName: [*c]RPC_WSTR, AuthnLevel: [*c]c_ulong, AuthnSvc: [*c]c_ulong, AuthIdentity: [*c]RPC_AUTH_IDENTITY_HANDLE, AuthzSvc: [*c]c_ulong, RpcQosVersion: c_ulong, SecurityQOS: [*c]RPC_SECURITY_QOS) callconv(.Stdcall) RPC_STATUS;
pub const RPC_AUTH_KEY_RETRIEVAL_FN = ?fn (?*c_void, RPC_WSTR, c_ulong, [*c](?*c_void), [*c]RPC_STATUS) callconv(.C) void;
pub extern "rpcrt4" fn RpcServerCompleteSecurityCallback(BindingHandle: RPC_BINDING_HANDLE, Status: RPC_STATUS) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerRegisterAuthInfoA(ServerPrincName: RPC_CSTR, AuthnSvc: c_ulong, GetKeyFn: RPC_AUTH_KEY_RETRIEVAL_FN, Arg: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerRegisterAuthInfoW(ServerPrincName: RPC_WSTR, AuthnSvc: c_ulong, GetKeyFn: RPC_AUTH_KEY_RETRIEVAL_FN, Arg: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub const RPC_CLIENT_INFORMATION1 = extern struct {
    UserName: [*c]u8,
    ComputerName: [*c]u8,
    Privilege: c_ushort,
    AuthFlags: c_ulong,
};
pub const PRPC_CLIENT_INFORMATION1 = [*c]extern struct {
    UserName: [*c]u8,
    ComputerName: [*c]u8,
    Privilege: c_ushort,
    AuthFlags: c_ulong,
};
pub extern "rpcrt4" fn RpcBindingServerFromClient(ClientBinding: RPC_BINDING_HANDLE, ServerBinding: [*c]RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcRaiseException(exception: RPC_STATUS) callconv(.Stdcall) noreturn;
pub extern "rpcrt4" fn RpcTestCancel() callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerTestCancel(BindingHandle: RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcCancelThread(Thread: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcCancelThreadEx(Thread: ?*c_void, Timeout: c_long) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn UuidCreate(Uuid: [*c]UUID) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn UuidCreateSequential(Uuid: [*c]UUID) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn UuidToStringA(Uuid: [*c]const UUID, StringUuid: [*c]RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn UuidFromStringA(StringUuid: RPC_CSTR, Uuid: [*c]UUID) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn UuidToStringW(Uuid: [*c]const UUID, StringUuid: [*c]RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn UuidFromStringW(StringUuid: RPC_WSTR, Uuid: [*c]UUID) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn UuidCompare(Uuid1: [*c]UUID, Uuid2: [*c]UUID, Status: [*c]RPC_STATUS) callconv(.Stdcall) c_int;
pub extern "rpcrt4" fn UuidCreateNil(NilUuid: [*c]UUID) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn UuidEqual(Uuid1: [*c]UUID, Uuid2: [*c]UUID, Status: [*c]RPC_STATUS) callconv(.Stdcall) c_int;
pub extern "rpcrt4" fn UuidHash(Uuid: [*c]UUID, Status: [*c]RPC_STATUS) callconv(.Stdcall) c_ushort;
pub extern "rpcrt4" fn UuidIsNil(Uuid: [*c]UUID, Status: [*c]RPC_STATUS) callconv(.Stdcall) c_int;
pub extern "rpcrt4" fn RpcEpRegisterNoReplaceA(IfSpec: RPC_IF_HANDLE, BindingVector: [*c]RPC_BINDING_VECTOR, UuidVector: [*c]UUID_VECTOR, Annotation: RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcEpRegisterNoReplaceW(IfSpec: RPC_IF_HANDLE, BindingVector: [*c]RPC_BINDING_VECTOR, UuidVector: [*c]UUID_VECTOR, Annotation: RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcEpRegisterA(IfSpec: RPC_IF_HANDLE, BindingVector: [*c]RPC_BINDING_VECTOR, UuidVector: [*c]UUID_VECTOR, Annotation: RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcEpRegisterW(IfSpec: RPC_IF_HANDLE, BindingVector: [*c]RPC_BINDING_VECTOR, UuidVector: [*c]UUID_VECTOR, Annotation: RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcEpUnregister(IfSpec: RPC_IF_HANDLE, BindingVector: [*c]RPC_BINDING_VECTOR, UuidVector: [*c]UUID_VECTOR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn DceErrorInqTextA(RpcStatus: RPC_STATUS, ErrorText: RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn DceErrorInqTextW(RpcStatus: RPC_STATUS, ErrorText: RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub const RPC_EP_INQ_HANDLE = [*c]I_RPC_HANDLE;
pub extern "rpcrt4" fn RpcMgmtEpEltInqBegin(EpBinding: RPC_BINDING_HANDLE, InquiryType: c_ulong, IfId: [*c]RPC_IF_ID, VersOption: c_ulong, ObjectUuid: [*c]UUID, InquiryContext: [*c]RPC_EP_INQ_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcMgmtEpEltInqDone(InquiryContext: [*c]RPC_EP_INQ_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcMgmtEpEltInqNextA(InquiryContext: RPC_EP_INQ_HANDLE, IfId: [*c]RPC_IF_ID, Binding: [*c]RPC_BINDING_HANDLE, ObjectUuid: [*c]UUID, Annotation: [*c]RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcMgmtEpEltInqNextW(InquiryContext: RPC_EP_INQ_HANDLE, IfId: [*c]RPC_IF_ID, Binding: [*c]RPC_BINDING_HANDLE, ObjectUuid: [*c]UUID, Annotation: [*c]RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcMgmtEpUnregister(EpBinding: RPC_BINDING_HANDLE, IfId: [*c]RPC_IF_ID, Binding: RPC_BINDING_HANDLE, ObjectUuid: [*c]UUID) callconv(.Stdcall) RPC_STATUS;
pub const RPC_MGMT_AUTHORIZATION_FN = ?fn (RPC_BINDING_HANDLE, c_ulong, [*c]RPC_STATUS) callconv(.C) c_int;
pub extern "rpcrt4" fn RpcMgmtSetAuthorizationFn(AuthorizationFn: RPC_MGMT_AUTHORIZATION_FN) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcExceptionFilter(ExceptionCode: c_ulong) callconv(.Stdcall) c_int;
pub const RPC_INTERFACE_GROUP = ?*c_void;
pub const PRPC_INTERFACE_GROUP = [*c](?*c_void);
pub const RPC_ENDPOINT_TEMPLATEW = extern struct {
    Version: c_ulong,
    ProtSeq: RPC_WSTR,
    Endpoint: RPC_WSTR,
    SecurityDescriptor: ?*c_void,
    Backlog: c_ulong,
};
pub const PRPC_ENDPOINT_TEMPLATEW = [*c]extern struct {
    Version: c_ulong,
    ProtSeq: RPC_WSTR,
    Endpoint: RPC_WSTR,
    SecurityDescriptor: ?*c_void,
    Backlog: c_ulong,
};
pub const RPC_ENDPOINT_TEMPLATEA = extern struct {
    Version: c_ulong,
    ProtSeq: RPC_CSTR,
    Endpoint: RPC_CSTR,
    SecurityDescriptor: ?*c_void,
    Backlog: c_ulong,
};
pub const PRPC_ENDPOINT_TEMPLATEA = [*c]extern struct {
    Version: c_ulong,
    ProtSeq: RPC_CSTR,
    Endpoint: RPC_CSTR,
    SecurityDescriptor: ?*c_void,
    Backlog: c_ulong,
};
pub const RPC_INTERFACE_TEMPLATEA = extern struct {
    Version: c_ulong,
    IfSpec: RPC_IF_HANDLE,
    MgrTypeUuid: [*c]UUID,
    MgrEpv: ?*c_void,
    Flags: c_uint,
    MaxCalls: c_uint,
    MaxRpcSize: c_uint,
    IfCallback: [*c]RPC_IF_CALLBACK_FN,
    UuidVector: [*c]UUID_VECTOR,
    Annotation: RPC_CSTR,
    SecurityDescriptor: ?*c_void,
};
pub const PRPC_INTERFACE_TEMPLATEA = [*c]extern struct {
    Version: c_ulong,
    IfSpec: RPC_IF_HANDLE,
    MgrTypeUuid: [*c]UUID,
    MgrEpv: ?*c_void,
    Flags: c_uint,
    MaxCalls: c_uint,
    MaxRpcSize: c_uint,
    IfCallback: [*c]RPC_IF_CALLBACK_FN,
    UuidVector: [*c]UUID_VECTOR,
    Annotation: RPC_CSTR,
    SecurityDescriptor: ?*c_void,
};
pub const RPC_INTERFACE_TEMPLATEW = extern struct {
    Version: c_ulong,
    IfSpec: RPC_IF_HANDLE,
    MgrTypeUuid: [*c]UUID,
    MgrEpv: ?*c_void,
    Flags: c_uint,
    MaxCalls: c_uint,
    MaxRpcSize: c_uint,
    IfCallback: [*c]RPC_IF_CALLBACK_FN,
    UuidVector: [*c]UUID_VECTOR,
    Annotation: RPC_WSTR,
    SecurityDescriptor: ?*c_void,
};
pub const PRPC_INTERFACE_TEMPLATEW = [*c]extern struct {
    Version: c_ulong,
    IfSpec: RPC_IF_HANDLE,
    MgrTypeUuid: [*c]UUID,
    MgrEpv: ?*c_void,
    Flags: c_uint,
    MaxCalls: c_uint,
    MaxRpcSize: c_uint,
    IfCallback: [*c]RPC_IF_CALLBACK_FN,
    UuidVector: [*c]UUID_VECTOR,
    Annotation: RPC_WSTR,
    SecurityDescriptor: ?*c_void,
};
pub const RPC_INTERFACE_GROUP_IDLE_CALLBACK_FN = fn (RPC_INTERFACE_GROUP, ?*c_void, c_ulong) callconv(.C) void;
pub extern "rpcrt4" fn RpcServerInterfaceGroupCreateW(Interfaces: [*c]RPC_INTERFACE_TEMPLATEW, NumIfs: c_ulong, Endpoints: [*c]RPC_ENDPOINT_TEMPLATEW, NumEndpoints: c_ulong, IdlePeriod: c_ulong, IdleCallbackFn: [*c]RPC_INTERFACE_GROUP_IDLE_CALLBACK_FN, IdleCallbackContext: ?*c_void, IfGroup: PRPC_INTERFACE_GROUP) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerInterfaceGroupCreateA(Interfaces: [*c]RPC_INTERFACE_TEMPLATEA, NumIfs: c_ulong, Endpoints: [*c]RPC_ENDPOINT_TEMPLATEA, NumEndpoints: c_ulong, IdlePeriod: c_ulong, IdleCallbackFn: [*c]RPC_INTERFACE_GROUP_IDLE_CALLBACK_FN, IdleCallbackContext: ?*c_void, IfGroup: PRPC_INTERFACE_GROUP) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerInterfaceGroupClose(IfGroup: RPC_INTERFACE_GROUP) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerInterfaceGroupActivate(IfGroup: RPC_INTERFACE_GROUP) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerInterfaceGroupDeactivate(IfGroup: RPC_INTERFACE_GROUP, ForceDeactivation: c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerInterfaceGroupInqBindings(IfGroup: RPC_INTERFACE_GROUP, BindingVector: [*c]([*c]RPC_BINDING_VECTOR)) callconv(.Stdcall) RPC_STATUS;
pub const struct__RPC_VERSION = extern struct {
    MajorVersion: c_ushort,
    MinorVersion: c_ushort,
};
pub const RPC_VERSION = struct__RPC_VERSION;
pub const struct__RPC_SYNTAX_IDENTIFIER = extern struct {
    SyntaxGUID: GUID,
    SyntaxVersion: RPC_VERSION,
};
pub const RPC_SYNTAX_IDENTIFIER = struct__RPC_SYNTAX_IDENTIFIER;
pub const PRPC_SYNTAX_IDENTIFIER = [*c]struct__RPC_SYNTAX_IDENTIFIER;
pub const struct__RPC_MESSAGE = extern struct {
    Handle: RPC_BINDING_HANDLE,
    DataRepresentation: c_ulong,
    Buffer: ?*c_void,
    BufferLength: c_uint,
    ProcNum: c_uint,
    TransferSyntax: PRPC_SYNTAX_IDENTIFIER,
    RpcInterfaceInformation: ?*c_void,
    ReservedForRuntime: ?*c_void,
    ManagerEpv: ?*c_void,
    ImportContext: ?*c_void,
    RpcFlags: c_ulong,
};
pub const RPC_MESSAGE = struct__RPC_MESSAGE;
pub const PRPC_MESSAGE = [*c]struct__RPC_MESSAGE;
pub const RPC_FORWARD_FUNCTION = fn ([*c]UUID, [*c]RPC_VERSION, [*c]UUID, [*c]u8, [*c](?*c_void)) callconv(.C) RPC_STATUS;
pub const PROTOCOL_NOT_LOADED = enum_RPC_ADDRESS_CHANGE_TYPE.PROTOCOL_NOT_LOADED;
pub const PROTOCOL_LOADED = enum_RPC_ADDRESS_CHANGE_TYPE.PROTOCOL_LOADED;
pub const PROTOCOL_ADDRESS_CHANGE = enum_RPC_ADDRESS_CHANGE_TYPE.PROTOCOL_ADDRESS_CHANGE;
pub const enum_RPC_ADDRESS_CHANGE_TYPE = extern enum {
    PROTOCOL_NOT_LOADED = 1,
    PROTOCOL_LOADED = 2,
    PROTOCOL_ADDRESS_CHANGE = 3,
};
pub const RPC_ADDRESS_CHANGE_FN = fn (?*c_void) callconv(.C) void;
pub const RPC_DISPATCH_FUNCTION = ?fn (PRPC_MESSAGE) callconv(.C) void;
pub const RPC_DISPATCH_TABLE = extern struct {
    DispatchTableCount: c_uint,
    DispatchTable: [*c]RPC_DISPATCH_FUNCTION,
    Reserved: LONG_PTR,
};
pub const PRPC_DISPATCH_TABLE = [*c]extern struct {
    DispatchTableCount: c_uint,
    DispatchTable: [*c]RPC_DISPATCH_FUNCTION,
    Reserved: LONG_PTR,
};
pub const struct__RPC_PROTSEQ_ENDPOINT = extern struct {
    RpcProtocolSequence: [*c]u8,
    Endpoint: [*c]u8,
};
pub const RPC_PROTSEQ_ENDPOINT = struct__RPC_PROTSEQ_ENDPOINT;
pub const PRPC_PROTSEQ_ENDPOINT = [*c]struct__RPC_PROTSEQ_ENDPOINT;
pub const struct__RPC_SERVER_INTERFACE = extern struct {
    Length: c_uint,
    InterfaceId: RPC_SYNTAX_IDENTIFIER,
    TransferSyntax: RPC_SYNTAX_IDENTIFIER,
    DispatchTable: PRPC_DISPATCH_TABLE,
    RpcProtseqEndpointCount: c_uint,
    RpcProtseqEndpoint: PRPC_PROTSEQ_ENDPOINT,
    DefaultManagerEpv: ?*c_void,
    InterpreterInfo: ?*const c_void,
    Flags: c_uint,
};
pub const RPC_SERVER_INTERFACE = struct__RPC_SERVER_INTERFACE;
pub const PRPC_SERVER_INTERFACE = [*c]struct__RPC_SERVER_INTERFACE;
pub const struct__RPC_CLIENT_INTERFACE = extern struct {
    Length: c_uint,
    InterfaceId: RPC_SYNTAX_IDENTIFIER,
    TransferSyntax: RPC_SYNTAX_IDENTIFIER,
    DispatchTable: PRPC_DISPATCH_TABLE,
    RpcProtseqEndpointCount: c_uint,
    RpcProtseqEndpoint: PRPC_PROTSEQ_ENDPOINT,
    Reserved: ULONG_PTR,
    InterpreterInfo: ?*const c_void,
    Flags: c_uint,
};
pub const RPC_CLIENT_INTERFACE = struct__RPC_CLIENT_INTERFACE;
pub const PRPC_CLIENT_INTERFACE = [*c]struct__RPC_CLIENT_INTERFACE;
pub extern "rpcrt4" fn I_RpcNegotiateTransferSyntax(Message: [*c]RPC_MESSAGE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcGetBuffer(Message: [*c]RPC_MESSAGE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcGetBufferWithObject(Message: [*c]RPC_MESSAGE, ObjectUuid: [*c]UUID) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcSendReceive(Message: [*c]RPC_MESSAGE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcFreeBuffer(Message: [*c]RPC_MESSAGE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcSend(Message: PRPC_MESSAGE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcReceive(Message: PRPC_MESSAGE, Size: c_uint) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcFreePipeBuffer(Message: [*c]RPC_MESSAGE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcReallocPipeBuffer(Message: PRPC_MESSAGE, NewSize: c_uint) callconv(.Stdcall) RPC_STATUS;
pub const I_RPC_MUTEX = ?*c_void;
pub extern "rpcrt4" fn I_RpcRequestMutex(Mutex: [*c]I_RPC_MUTEX) callconv(.Stdcall) void;
pub extern "rpcrt4" fn I_RpcClearMutex(Mutex: I_RPC_MUTEX) callconv(.Stdcall) void;
pub extern "rpcrt4" fn I_RpcDeleteMutex(Mutex: I_RPC_MUTEX) callconv(.Stdcall) void;
pub extern "rpcrt4" fn I_RpcAllocate(Size: c_uint) callconv(.Stdcall) ?*c_void;
pub extern "rpcrt4" fn I_RpcFree(Object: ?*c_void) callconv(.Stdcall) void;
pub extern "rpcrt4" fn I_RpcFreeSystemHandleCollection(CallObj: ?*c_void, FreeFlags: c_ulong) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn I_RpcSetSystemHandle(Handle: ?*c_void, Type: u8, AccessMask: c_ulong, CallObj: ?*c_void, HandleIndex: [*c]c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcGetSystemHandle(pMemory: [*c]u8, Type: u8, AccessMask: c_ulong, HandleIndex: c_ulong, CallObj: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcFreeSystemHandle(Type: u8, Handle: ?*c_void) callconv(.Stdcall) void;
pub extern "rpcrt4" fn I_RpcPauseExecution(Milliseconds: c_ulong) callconv(.Stdcall) void;
pub extern "rpcrt4" fn I_RpcGetExtendedError() callconv(.Stdcall) RPC_STATUS;
pub const MarshalDirectionMarshal = enum__LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION.MarshalDirectionMarshal;
pub const MarshalDirectionUnmarshal = enum__LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION.MarshalDirectionUnmarshal;
pub const enum__LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION = extern enum {
    MarshalDirectionMarshal,
    MarshalDirectionUnmarshal,
};
pub const LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION = enum__LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION;
pub extern "rpcrt4" fn I_RpcSystemHandleTypeSpecificWork(Handle: ?*c_void, ActualType: u8, IdlType: u8, MarshalDirection: LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION) callconv(.Stdcall) RPC_STATUS;
pub const PRPC_RUNDOWN = ?fn (?*c_void) callconv(.C) void;
pub extern "rpcrt4" fn I_RpcMonitorAssociation(Handle: RPC_BINDING_HANDLE, RundownRoutine: PRPC_RUNDOWN, Context: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcStopMonitorAssociation(Handle: RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcGetCurrentCallHandle() callconv(.Stdcall) RPC_BINDING_HANDLE;
pub extern "rpcrt4" fn I_RpcGetAssociationContext(BindingHandle: RPC_BINDING_HANDLE, AssociationContext: [*c](?*c_void)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcGetServerContextList(BindingHandle: RPC_BINDING_HANDLE) callconv(.Stdcall) ?*c_void;
pub extern "rpcrt4" fn I_RpcSetServerContextList(BindingHandle: RPC_BINDING_HANDLE, ServerContextList: ?*c_void) callconv(.Stdcall) void;
pub extern "rpcrt4" fn I_RpcNsInterfaceExported(EntryNameSyntax: c_ulong, EntryName: [*c]c_ushort, RpcInterfaceInformation: [*c]RPC_SERVER_INTERFACE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcNsInterfaceUnexported(EntryNameSyntax: c_ulong, EntryName: [*c]c_ushort, RpcInterfaceInformation: [*c]RPC_SERVER_INTERFACE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcBindingToStaticStringBindingW(Binding: RPC_BINDING_HANDLE, StringBinding: [*c]([*c]c_ushort)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcBindingInqSecurityContext(Binding: RPC_BINDING_HANDLE, SecurityContextHandle: [*c](?*c_void)) callconv(.Stdcall) RPC_STATUS;
pub const struct__RPC_SEC_CONTEXT_KEY_INFO = extern struct {
    EncryptAlgorithm: c_ulong,
    KeySize: c_ulong,
    SignatureAlgorithm: c_ulong,
};
pub const RPC_SEC_CONTEXT_KEY_INFO = struct__RPC_SEC_CONTEXT_KEY_INFO;
pub const PRPC_SEC_CONTEXT_KEY_INFO = [*c]struct__RPC_SEC_CONTEXT_KEY_INFO;
pub extern "rpcrt4" fn I_RpcBindingInqSecurityContextKeyInfo(Binding: RPC_BINDING_HANDLE, KeyInfo: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcBindingInqWireIdForSnego(Binding: RPC_BINDING_HANDLE, WireId: [*c]u8) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcBindingInqMarshalledTargetInfo(Binding: RPC_BINDING_HANDLE, MarshalledTargetInfoSize: [*c]c_ulong, MarshalledTargetInfo: [*c]RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcBindingInqLocalClientPID(Binding: RPC_BINDING_HANDLE, Pid: [*c]c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcBindingHandleToAsyncHandle(Binding: RPC_BINDING_HANDLE, AsyncHandle: [*c](?*c_void)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcNsBindingSetEntryNameW(Binding: RPC_BINDING_HANDLE, EntryNameSyntax: c_ulong, EntryName: RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcNsBindingSetEntryNameA(Binding: RPC_BINDING_HANDLE, EntryNameSyntax: c_ulong, EntryName: RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcServerUseProtseqEp2A(NetworkAddress: RPC_CSTR, Protseq: RPC_CSTR, MaxCalls: c_uint, Endpoint: RPC_CSTR, SecurityDescriptor: ?*c_void, Policy: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcServerUseProtseqEp2W(NetworkAddress: RPC_WSTR, Protseq: RPC_WSTR, MaxCalls: c_uint, Endpoint: RPC_WSTR, SecurityDescriptor: ?*c_void, Policy: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcServerUseProtseq2W(NetworkAddress: RPC_WSTR, Protseq: RPC_WSTR, MaxCalls: c_uint, SecurityDescriptor: ?*c_void, Policy: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcServerUseProtseq2A(NetworkAddress: RPC_CSTR, Protseq: RPC_CSTR, MaxCalls: c_uint, SecurityDescriptor: ?*c_void, Policy: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcServerStartService(Protseq: RPC_WSTR, Endpoint: RPC_WSTR, IfSpec: RPC_IF_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcBindingInqDynamicEndpointW(Binding: RPC_BINDING_HANDLE, DynamicEndpoint: [*c]RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcBindingInqDynamicEndpointA(Binding: RPC_BINDING_HANDLE, DynamicEndpoint: [*c]RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcServerCheckClientRestriction(Context: RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcBindingInqTransportType(Binding: RPC_BINDING_HANDLE, Type: [*c]c_uint) callconv(.Stdcall) RPC_STATUS;
pub const struct__RPC_TRANSFER_SYNTAX = extern struct {
    Uuid: UUID,
    VersMajor: c_ushort,
    VersMinor: c_ushort,
};
pub const RPC_TRANSFER_SYNTAX = struct__RPC_TRANSFER_SYNTAX;
pub extern "rpcrt4" fn I_RpcIfInqTransferSyntaxes(RpcIfHandle: RPC_IF_HANDLE, TransferSyntaxes: [*c]RPC_TRANSFER_SYNTAX, TransferSyntaxSize: c_uint, TransferSyntaxCount: [*c]c_uint) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_UuidCreate(Uuid: [*c]UUID) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcUninitializeNdrOle() callconv(.Stdcall) void;
pub extern "rpcrt4" fn I_RpcBindingCopy(SourceBinding: RPC_BINDING_HANDLE, DestinationBinding: [*c]RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcBindingIsClientLocal(BindingHandle: RPC_BINDING_HANDLE, ClientLocalFlag: [*c]c_uint) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcBindingInqConnId(Binding: RPC_BINDING_HANDLE, ConnId: [*c](?*c_void), pfFirstCall: [*c]c_int) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcBindingCreateNP(ServerName: RPC_WSTR, ServiceName: RPC_WSTR, NetworkOptions: RPC_WSTR, Binding: [*c]RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcSsDontSerializeContext() callconv(.Stdcall) void;
pub extern "rpcrt4" fn I_RpcLaunchDatagramReceiveThread(pAddress: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcServerRegisterForwardFunction(pForwardFunction: [*c]RPC_FORWARD_FUNCTION) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcServerInqAddressChangeFn() callconv(.Stdcall) [*c]RPC_ADDRESS_CHANGE_FN;
pub extern "rpcrt4" fn I_RpcServerSetAddressChangeFn(pAddressChangeFn: [*c]RPC_ADDRESS_CHANGE_FN) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcServerInqLocalConnAddress(Binding: RPC_BINDING_HANDLE, Buffer: ?*c_void, BufferSize: [*c]c_ulong, AddressFormat: [*c]c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcServerInqRemoteConnAddress(Binding: RPC_BINDING_HANDLE, Buffer: ?*c_void, BufferSize: [*c]c_ulong, AddressFormat: [*c]c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcSessionStrictContextHandle() callconv(.Stdcall) void;
pub extern "rpcrt4" fn I_RpcTurnOnEEInfoPropagation() callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcConnectionInqSockBuffSize(RecvBuffSize: [*c]c_ulong, SendBuffSize: [*c]c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcConnectionSetSockBuffSize(RecvBuffSize: c_ulong, SendBuffSize: c_ulong) callconv(.Stdcall) RPC_STATUS;
pub const RPCLT_PDU_FILTER_FUNC = ?fn (?*c_void, c_uint, c_int) callconv(.C) void;
pub const RPC_SETFILTER_FUNC = ?fn (RPCLT_PDU_FILTER_FUNC) callconv(.C) void;
pub extern "rpcrt4" fn I_RpcServerStartListening(hWnd: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcServerStopListening() callconv(.Stdcall) RPC_STATUS;
pub const RPC_BLOCKING_FN = ?fn (?*c_void, ?*c_void, ?*c_void) callconv(.C) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcBindingSetAsync(Binding: RPC_BINDING_HANDLE, BlockingFn: RPC_BLOCKING_FN, ServerTid: c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcSetThreadParams(fClientFree: c_int, Context: ?*c_void, hWndClient: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcWindowProc(hWnd: ?*c_void, Message: c_uint, wParam: c_uint, lParam: c_ulong) callconv(.Stdcall) c_uint;
pub extern "rpcrt4" fn I_RpcServerUnregisterEndpointA(Protseq: RPC_CSTR, Endpoint: RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcServerUnregisterEndpointW(Protseq: RPC_WSTR, Endpoint: RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcServerInqTransportType(Type: [*c]c_uint) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcMapWin32Status(Status: RPC_STATUS) callconv(.Stdcall) c_long;
pub const struct__RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR = extern struct {
    BufferSize: c_ulong,
    Buffer: [*c]u8,
};
pub const RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR = struct__RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR;
pub const struct__RDR_CALLOUT_STATE = extern struct {
    LastError: RPC_STATUS,
    LastEEInfo: ?*c_void,
    LastCalledStage: RPC_HTTP_REDIRECTOR_STAGE,
    ServerName: [*c]c_ushort,
    ServerPort: [*c]c_ushort,
    RemoteUser: [*c]c_ushort,
    AuthType: [*c]c_ushort,
    ResourceTypePresent: u8,
    SessionIdPresent: u8,
    InterfacePresent: u8,
    ResourceType: UUID,
    SessionId: UUID,
    Interface: RPC_SYNTAX_IDENTIFIER,
    CertContext: ?*c_void,
};
pub const RDR_CALLOUT_STATE = struct__RDR_CALLOUT_STATE;
pub const I_RpcProxyIsValidMachineFn = ?fn (RPC_WSTR, RPC_WSTR, c_ulong) callconv(.C) RPC_STATUS;
pub const I_RpcProxyGetClientAddressFn = ?fn (?*c_void, [*c]u8, [*c]c_ulong) callconv(.C) RPC_STATUS;
pub const I_RpcProxyGetConnectionTimeoutFn = ?fn ([*c]c_ulong) callconv(.C) RPC_STATUS;
pub const I_RpcPerformCalloutFn = ?fn (?*c_void, [*c]RDR_CALLOUT_STATE, RPC_HTTP_REDIRECTOR_STAGE) callconv(.C) RPC_STATUS;
pub const I_RpcFreeCalloutStateFn = ?fn ([*c]RDR_CALLOUT_STATE) callconv(.C) void;
pub const I_RpcProxyGetClientSessionAndResourceUUID = ?fn (?*c_void, [*c]c_int, [*c]UUID, [*c]c_int, [*c]UUID) callconv(.C) RPC_STATUS;
pub const I_RpcProxyFilterIfFn = ?fn (?*c_void, [*c]UUID, c_ushort, [*c]c_int) callconv(.C) RPC_STATUS;
pub const RpcCurrentUniqueUser = enum_RpcProxyPerfCounters.RpcCurrentUniqueUser;
pub const RpcBackEndConnectionAttempts = enum_RpcProxyPerfCounters.RpcBackEndConnectionAttempts;
pub const RpcBackEndConnectionFailed = enum_RpcProxyPerfCounters.RpcBackEndConnectionFailed;
pub const RpcRequestsPerSecond = enum_RpcProxyPerfCounters.RpcRequestsPerSecond;
pub const RpcIncomingConnections = enum_RpcProxyPerfCounters.RpcIncomingConnections;
pub const RpcIncomingBandwidth = enum_RpcProxyPerfCounters.RpcIncomingBandwidth;
pub const RpcOutgoingBandwidth = enum_RpcProxyPerfCounters.RpcOutgoingBandwidth;
pub const RpcAttemptedLbsDecisions = enum_RpcProxyPerfCounters.RpcAttemptedLbsDecisions;
pub const RpcFailedLbsDecisions = enum_RpcProxyPerfCounters.RpcFailedLbsDecisions;
pub const RpcAttemptedLbsMessages = enum_RpcProxyPerfCounters.RpcAttemptedLbsMessages;
pub const RpcFailedLbsMessages = enum_RpcProxyPerfCounters.RpcFailedLbsMessages;
pub const RpcLastCounter = enum_RpcProxyPerfCounters.RpcLastCounter;
pub const enum_RpcProxyPerfCounters = extern enum {
    RpcCurrentUniqueUser = 1,
    RpcBackEndConnectionAttempts = 2,
    RpcBackEndConnectionFailed = 3,
    RpcRequestsPerSecond = 4,
    RpcIncomingConnections = 5,
    RpcIncomingBandwidth = 6,
    RpcOutgoingBandwidth = 7,
    RpcAttemptedLbsDecisions = 8,
    RpcFailedLbsDecisions = 9,
    RpcAttemptedLbsMessages = 10,
    RpcFailedLbsMessages = 11,
    RpcLastCounter = 12,
};
pub const RpcPerfCounters = enum_RpcProxyPerfCounters;
pub const I_RpcProxyUpdatePerfCounterFn = ?fn (RpcPerfCounters, c_int, c_ulong) callconv(.C) void;
pub const I_RpcProxyUpdatePerfCounterBackendServerFn = ?fn ([*c]c_ushort, c_int) callconv(.C) void;
pub const struct_tagI_RpcProxyCallbackInterface = extern struct {
    IsValidMachineFn: I_RpcProxyIsValidMachineFn,
    GetClientAddressFn: I_RpcProxyGetClientAddressFn,
    GetConnectionTimeoutFn: I_RpcProxyGetConnectionTimeoutFn,
    PerformCalloutFn: I_RpcPerformCalloutFn,
    FreeCalloutStateFn: I_RpcFreeCalloutStateFn,
    GetClientSessionAndResourceUUIDFn: I_RpcProxyGetClientSessionAndResourceUUID,
    ProxyFilterIfFn: I_RpcProxyFilterIfFn,
    RpcProxyUpdatePerfCounterFn: I_RpcProxyUpdatePerfCounterFn,
    RpcProxyUpdatePerfCounterBackendServerFn: I_RpcProxyUpdatePerfCounterBackendServerFn,
};
pub const I_RpcProxyCallbackInterface = struct_tagI_RpcProxyCallbackInterface;
pub extern "rpcrt4" fn I_RpcProxyNewConnection(ConnectionType: c_ulong, ServerAddress: [*c]c_ushort, ServerPort: [*c]c_ushort, MinConnTimeout: [*c]c_ushort, ConnectionParameter: ?*c_void, CallOutState: [*c]RDR_CALLOUT_STATE, ProxyCallbackInterface: [*c]I_RpcProxyCallbackInterface) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcReplyToClientWithStatus(ConnectionParameter: ?*c_void, RpcStatus: RPC_STATUS) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcRecordCalloutFailure(RpcStatus: RPC_STATUS, CallOutState: [*c]RDR_CALLOUT_STATE, DllName: [*c]c_ushort) callconv(.Stdcall) void;
pub extern "rpcrt4" fn I_RpcMgmtEnableDedicatedThreadPool() callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcGetDefaultSD(ppSecurityDescriptor: [*c](?*c_void)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcOpenClientProcess(Binding: RPC_BINDING_HANDLE, DesiredAccess: c_ulong, ClientProcess: [*c](?*c_void)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcBindingIsServerLocal(Binding: RPC_BINDING_HANDLE, ServerLocalFlag: [*c]c_uint) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcBindingSetPrivateOption(hBinding: RPC_BINDING_HANDLE, option: c_ulong, optionValue: ULONG_PTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcServerSubscribeForDisconnectNotification(Binding: RPC_BINDING_HANDLE, hEvent: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcServerGetAssociationID(Binding: RPC_BINDING_HANDLE, AssociationID: [*c]c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcServerDisableExceptionFilter() callconv(.Stdcall) c_long;
pub extern "rpcrt4" fn I_RpcServerSubscribeForDisconnectNotification2(Binding: RPC_BINDING_HANDLE, hEvent: ?*c_void, SubscriptionId: [*c]UUID) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcServerUnsubscribeForDisconnectNotification(Binding: RPC_BINDING_HANDLE, SubscriptionId: UUID) callconv(.Stdcall) RPC_STATUS;
pub const RPC_NS_HANDLE = ?*c_void;
pub extern "rpcns4" fn RpcNsBindingExportA(EntryNameSyntax: c_ulong, EntryName: RPC_CSTR, IfSpec: RPC_IF_HANDLE, BindingVec: [*c]RPC_BINDING_VECTOR, ObjectUuidVec: [*c]UUID_VECTOR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsBindingUnexportA(EntryNameSyntax: c_ulong, EntryName: RPC_CSTR, IfSpec: RPC_IF_HANDLE, ObjectUuidVec: [*c]UUID_VECTOR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsBindingExportW(EntryNameSyntax: c_ulong, EntryName: RPC_WSTR, IfSpec: RPC_IF_HANDLE, BindingVec: [*c]RPC_BINDING_VECTOR, ObjectUuidVec: [*c]UUID_VECTOR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsBindingUnexportW(EntryNameSyntax: c_ulong, EntryName: RPC_WSTR, IfSpec: RPC_IF_HANDLE, ObjectUuidVec: [*c]UUID_VECTOR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsBindingExportPnPA(EntryNameSyntax: c_ulong, EntryName: RPC_CSTR, IfSpec: RPC_IF_HANDLE, ObjectVector: [*c]UUID_VECTOR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsBindingUnexportPnPA(EntryNameSyntax: c_ulong, EntryName: RPC_CSTR, IfSpec: RPC_IF_HANDLE, ObjectVector: [*c]UUID_VECTOR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsBindingExportPnPW(EntryNameSyntax: c_ulong, EntryName: RPC_WSTR, IfSpec: RPC_IF_HANDLE, ObjectVector: [*c]UUID_VECTOR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsBindingUnexportPnPW(EntryNameSyntax: c_ulong, EntryName: RPC_WSTR, IfSpec: RPC_IF_HANDLE, ObjectVector: [*c]UUID_VECTOR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsBindingLookupBeginA(EntryNameSyntax: c_ulong, EntryName: RPC_CSTR, IfSpec: RPC_IF_HANDLE, ObjUuid: [*c]UUID, BindingMaxCount: c_ulong, LookupContext: [*c]RPC_NS_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsBindingLookupBeginW(EntryNameSyntax: c_ulong, EntryName: RPC_WSTR, IfSpec: RPC_IF_HANDLE, ObjUuid: [*c]UUID, BindingMaxCount: c_ulong, LookupContext: [*c]RPC_NS_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsBindingLookupNext(LookupContext: RPC_NS_HANDLE, BindingVec: [*c]([*c]RPC_BINDING_VECTOR)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsBindingLookupDone(LookupContext: [*c]RPC_NS_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsGroupDeleteA(GroupNameSyntax: c_ulong, GroupName: RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsGroupMbrAddA(GroupNameSyntax: c_ulong, GroupName: RPC_CSTR, MemberNameSyntax: c_ulong, MemberName: RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsGroupMbrRemoveA(GroupNameSyntax: c_ulong, GroupName: RPC_CSTR, MemberNameSyntax: c_ulong, MemberName: RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsGroupMbrInqBeginA(GroupNameSyntax: c_ulong, GroupName: RPC_CSTR, MemberNameSyntax: c_ulong, InquiryContext: [*c]RPC_NS_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsGroupMbrInqNextA(InquiryContext: RPC_NS_HANDLE, MemberName: [*c]RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsGroupDeleteW(GroupNameSyntax: c_ulong, GroupName: RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsGroupMbrAddW(GroupNameSyntax: c_ulong, GroupName: RPC_WSTR, MemberNameSyntax: c_ulong, MemberName: RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsGroupMbrRemoveW(GroupNameSyntax: c_ulong, GroupName: RPC_WSTR, MemberNameSyntax: c_ulong, MemberName: RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsGroupMbrInqBeginW(GroupNameSyntax: c_ulong, GroupName: RPC_WSTR, MemberNameSyntax: c_ulong, InquiryContext: [*c]RPC_NS_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsGroupMbrInqNextW(InquiryContext: RPC_NS_HANDLE, MemberName: [*c]RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsGroupMbrInqDone(InquiryContext: [*c]RPC_NS_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsProfileDeleteA(ProfileNameSyntax: c_ulong, ProfileName: RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsProfileEltAddA(ProfileNameSyntax: c_ulong, ProfileName: RPC_CSTR, IfId: [*c]RPC_IF_ID, MemberNameSyntax: c_ulong, MemberName: RPC_CSTR, Priority: c_ulong, Annotation: RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsProfileEltRemoveA(ProfileNameSyntax: c_ulong, ProfileName: RPC_CSTR, IfId: [*c]RPC_IF_ID, MemberNameSyntax: c_ulong, MemberName: RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsProfileEltInqBeginA(ProfileNameSyntax: c_ulong, ProfileName: RPC_CSTR, InquiryType: c_ulong, IfId: [*c]RPC_IF_ID, VersOption: c_ulong, MemberNameSyntax: c_ulong, MemberName: RPC_CSTR, InquiryContext: [*c]RPC_NS_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsProfileEltInqNextA(InquiryContext: RPC_NS_HANDLE, IfId: [*c]RPC_IF_ID, MemberName: [*c]RPC_CSTR, Priority: [*c]c_ulong, Annotation: [*c]RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsProfileDeleteW(ProfileNameSyntax: c_ulong, ProfileName: RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsProfileEltAddW(ProfileNameSyntax: c_ulong, ProfileName: RPC_WSTR, IfId: [*c]RPC_IF_ID, MemberNameSyntax: c_ulong, MemberName: RPC_WSTR, Priority: c_ulong, Annotation: RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsProfileEltRemoveW(ProfileNameSyntax: c_ulong, ProfileName: RPC_WSTR, IfId: [*c]RPC_IF_ID, MemberNameSyntax: c_ulong, MemberName: RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsProfileEltInqBeginW(ProfileNameSyntax: c_ulong, ProfileName: RPC_WSTR, InquiryType: c_ulong, IfId: [*c]RPC_IF_ID, VersOption: c_ulong, MemberNameSyntax: c_ulong, MemberName: RPC_WSTR, InquiryContext: [*c]RPC_NS_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsProfileEltInqNextW(InquiryContext: RPC_NS_HANDLE, IfId: [*c]RPC_IF_ID, MemberName: [*c]RPC_WSTR, Priority: [*c]c_ulong, Annotation: [*c]RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsProfileEltInqDone(InquiryContext: [*c]RPC_NS_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsEntryObjectInqBeginA(EntryNameSyntax: c_ulong, EntryName: RPC_CSTR, InquiryContext: [*c]RPC_NS_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsEntryObjectInqBeginW(EntryNameSyntax: c_ulong, EntryName: RPC_WSTR, InquiryContext: [*c]RPC_NS_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsEntryObjectInqNext(InquiryContext: RPC_NS_HANDLE, ObjUuid: [*c]UUID) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsEntryObjectInqDone(InquiryContext: [*c]RPC_NS_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsEntryExpandNameA(EntryNameSyntax: c_ulong, EntryName: RPC_CSTR, ExpandedName: [*c]RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsMgmtBindingUnexportA(EntryNameSyntax: c_ulong, EntryName: RPC_CSTR, IfId: [*c]RPC_IF_ID, VersOption: c_ulong, ObjectUuidVec: [*c]UUID_VECTOR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsMgmtEntryCreateA(EntryNameSyntax: c_ulong, EntryName: RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsMgmtEntryDeleteA(EntryNameSyntax: c_ulong, EntryName: RPC_CSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsMgmtEntryInqIfIdsA(EntryNameSyntax: c_ulong, EntryName: RPC_CSTR, IfIdVec: [*c]([*c]RPC_IF_ID_VECTOR)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsMgmtHandleSetExpAge(NsHandle: RPC_NS_HANDLE, ExpirationAge: c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsMgmtInqExpAge(ExpirationAge: [*c]c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsMgmtSetExpAge(ExpirationAge: c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsEntryExpandNameW(EntryNameSyntax: c_ulong, EntryName: RPC_WSTR, ExpandedName: [*c]RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsMgmtBindingUnexportW(EntryNameSyntax: c_ulong, EntryName: RPC_WSTR, IfId: [*c]RPC_IF_ID, VersOption: c_ulong, ObjectUuidVec: [*c]UUID_VECTOR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsMgmtEntryCreateW(EntryNameSyntax: c_ulong, EntryName: RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsMgmtEntryDeleteW(EntryNameSyntax: c_ulong, EntryName: RPC_WSTR) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsMgmtEntryInqIfIdsW(EntryNameSyntax: c_ulong, EntryName: RPC_WSTR, IfIdVec: [*c]([*c]RPC_IF_ID_VECTOR)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsBindingImportBeginA(EntryNameSyntax: c_ulong, EntryName: RPC_CSTR, IfSpec: RPC_IF_HANDLE, ObjUuid: [*c]UUID, ImportContext: [*c]RPC_NS_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsBindingImportBeginW(EntryNameSyntax: c_ulong, EntryName: RPC_WSTR, IfSpec: RPC_IF_HANDLE, ObjUuid: [*c]UUID, ImportContext: [*c]RPC_NS_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsBindingImportNext(ImportContext: RPC_NS_HANDLE, Binding: [*c]RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsBindingImportDone(ImportContext: [*c]RPC_NS_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcns4" fn RpcNsBindingSelect(BindingVec: [*c]RPC_BINDING_VECTOR, Binding: [*c]RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub const RpcNotificationTypeNone = enum__RPC_NOTIFICATION_TYPES.RpcNotificationTypeNone;
pub const RpcNotificationTypeEvent = enum__RPC_NOTIFICATION_TYPES.RpcNotificationTypeEvent;
pub const RpcNotificationTypeApc = enum__RPC_NOTIFICATION_TYPES.RpcNotificationTypeApc;
pub const RpcNotificationTypeIoc = enum__RPC_NOTIFICATION_TYPES.RpcNotificationTypeIoc;
pub const RpcNotificationTypeHwnd = enum__RPC_NOTIFICATION_TYPES.RpcNotificationTypeHwnd;
pub const RpcNotificationTypeCallback = enum__RPC_NOTIFICATION_TYPES.RpcNotificationTypeCallback;
pub const enum__RPC_NOTIFICATION_TYPES = extern enum {
    RpcNotificationTypeNone,
    RpcNotificationTypeEvent,
    RpcNotificationTypeApc,
    RpcNotificationTypeIoc,
    RpcNotificationTypeHwnd,
    RpcNotificationTypeCallback,
};
pub const RPC_NOTIFICATION_TYPES = enum__RPC_NOTIFICATION_TYPES;
pub const RpcCallComplete = enum__RPC_ASYNC_EVENT.RpcCallComplete;
pub const RpcSendComplete = enum__RPC_ASYNC_EVENT.RpcSendComplete;
pub const RpcReceiveComplete = enum__RPC_ASYNC_EVENT.RpcReceiveComplete;
pub const RpcClientDisconnect = enum__RPC_ASYNC_EVENT.RpcClientDisconnect;
pub const RpcClientCancel = enum__RPC_ASYNC_EVENT.RpcClientCancel;
pub const enum__RPC_ASYNC_EVENT = extern enum {
    RpcCallComplete,
    RpcSendComplete,
    RpcReceiveComplete,
    RpcClientDisconnect,
    RpcClientCancel,
};
pub const RPC_ASYNC_EVENT = enum__RPC_ASYNC_EVENT;
pub const RPCNOTIFICATION_ROUTINE = fn ([*c]struct__RPC_ASYNC_STATE, ?*c_void, RPC_ASYNC_EVENT) callconv(.C) void;
pub const PFN_RPCNOTIFICATION_ROUTINE = [*c]RPCNOTIFICATION_ROUTINE;
pub const union__RPC_ASYNC_NOTIFICATION_INFO = extern union {
    APC: extern struct {
        NotificationRoutine: PFN_RPCNOTIFICATION_ROUTINE,
        hThread: HANDLE,
    },
    IOC: extern struct {
        hIOPort: HANDLE,
        dwNumberOfBytesTransferred: DWORD,
        dwCompletionKey: DWORD_PTR,
        lpOverlapped: LPOVERLAPPED,
    },
    HWND: extern struct {
        hWnd: HWND,
        Msg: UINT,
    },
    hEvent: HANDLE,
    NotificationRoutine: PFN_RPCNOTIFICATION_ROUTINE,
};
pub const RPC_ASYNC_NOTIFICATION_INFO = union__RPC_ASYNC_NOTIFICATION_INFO;
pub const struct__RPC_ASYNC_STATE = extern struct {
    Size: c_uint,
    Signature: c_ulong,
    Lock: c_long,
    Flags: c_ulong,
    StubInfo: ?*c_void,
    UserInfo: ?*c_void,
    RuntimeInfo: ?*c_void,
    Event: RPC_ASYNC_EVENT,
    NotificationType: RPC_NOTIFICATION_TYPES,
    u: RPC_ASYNC_NOTIFICATION_INFO,
    Reserved: [4]LONG_PTR,
};
pub const PRPC_ASYNC_NOTIFICATION_INFO = [*c]union__RPC_ASYNC_NOTIFICATION_INFO;
pub const RPC_ASYNC_STATE = struct__RPC_ASYNC_STATE;
pub const PRPC_ASYNC_STATE = [*c]struct__RPC_ASYNC_STATE;
pub extern "rpcrt4" fn RpcAsyncRegisterInfo(pAsync: PRPC_ASYNC_STATE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcAsyncInitializeHandle(pAsync: PRPC_ASYNC_STATE, Size: c_uint) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcAsyncGetCallStatus(pAsync: PRPC_ASYNC_STATE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcAsyncCompleteCall(pAsync: PRPC_ASYNC_STATE, Reply: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcAsyncAbortCall(pAsync: PRPC_ASYNC_STATE, ExceptionCode: c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcAsyncCancelCall(pAsync: PRPC_ASYNC_STATE, fAbort: BOOL) callconv(.Stdcall) RPC_STATUS;
pub const eeptAnsiString = enum_tagExtendedErrorParamTypes.eeptAnsiString;
pub const eeptUnicodeString = enum_tagExtendedErrorParamTypes.eeptUnicodeString;
pub const eeptLongVal = enum_tagExtendedErrorParamTypes.eeptLongVal;
pub const eeptShortVal = enum_tagExtendedErrorParamTypes.eeptShortVal;
pub const eeptPointerVal = enum_tagExtendedErrorParamTypes.eeptPointerVal;
pub const eeptNone = enum_tagExtendedErrorParamTypes.eeptNone;
pub const eeptBinary = enum_tagExtendedErrorParamTypes.eeptBinary;
pub const enum_tagExtendedErrorParamTypes = extern enum {
    eeptAnsiString = 1,
    eeptUnicodeString = 2,
    eeptLongVal = 3,
    eeptShortVal = 4,
    eeptPointerVal = 5,
    eeptNone = 6,
    eeptBinary = 7,
};
pub const ExtendedErrorParamTypes = enum_tagExtendedErrorParamTypes;
pub const struct_tagBinaryParam = extern struct {
    Buffer: ?*c_void,
    Size: c_short,
};
pub const BinaryParam = struct_tagBinaryParam;
pub const struct_tagRPC_EE_INFO_PARAM = extern struct {
    ParameterType: ExtendedErrorParamTypes,
    u: extern union {
        AnsiString: LPSTR,
        UnicodeString: LPWSTR,
        LVal: c_long,
        SVal: c_short,
        PVal: ULONGLONG,
        BVal: BinaryParam,
    },
};
pub const RPC_EE_INFO_PARAM = struct_tagRPC_EE_INFO_PARAM;
pub const struct_tagRPC_EXTENDED_ERROR_INFO = extern struct {
    Version: ULONG,
    ComputerName: LPWSTR,
    ProcessID: ULONG,
    u: extern union {
        SystemTime: SYSTEMTIME,
        FileTime: FILETIME,
    },
    GeneratingComponent: ULONG,
    Status: ULONG,
    DetectionLocation: USHORT,
    Flags: USHORT,
    NumberOfParameters: c_int,
    Parameters: [4]RPC_EE_INFO_PARAM,
};
pub const RPC_EXTENDED_ERROR_INFO = struct_tagRPC_EXTENDED_ERROR_INFO;
pub const struct_tagRPC_ERROR_ENUM_HANDLE = extern struct {
    Signature: ULONG,
    CurrentPos: ?*c_void,
    Head: ?*c_void,
};
pub const RPC_ERROR_ENUM_HANDLE = struct_tagRPC_ERROR_ENUM_HANDLE;
pub extern "rpcrt4" fn RpcErrorStartEnumeration(EnumHandle: [*c]RPC_ERROR_ENUM_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcErrorGetNextRecord(EnumHandle: [*c]RPC_ERROR_ENUM_HANDLE, CopyStrings: BOOL, ErrorInfo: [*c]RPC_EXTENDED_ERROR_INFO) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcErrorEndEnumeration(EnumHandle: [*c]RPC_ERROR_ENUM_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcErrorResetEnumeration(EnumHandle: [*c]RPC_ERROR_ENUM_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcErrorGetNumberOfRecords(EnumHandle: [*c]RPC_ERROR_ENUM_HANDLE, Records: [*c]c_int) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcErrorSaveErrorInfo(EnumHandle: [*c]RPC_ERROR_ENUM_HANDLE, ErrorBlob: [*c]PVOID, BlobSize: [*c]usize) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcErrorLoadErrorInfo(ErrorBlob: PVOID, BlobSize: usize, EnumHandle: [*c]RPC_ERROR_ENUM_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcErrorAddRecord(ErrorInfo: [*c]RPC_EXTENDED_ERROR_INFO) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcErrorClearInformation() callconv(.Stdcall) void;
pub extern "rpcrt4" fn RpcAsyncCleanupThread(dwTimeout: DWORD) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcGetAuthorizationContextForClient(ClientBinding: RPC_BINDING_HANDLE, ImpersonateOnReturn: BOOL, Reserved1: PVOID, pExpirationTime: PLARGE_INTEGER, Reserved2: LUID, Reserved3: DWORD, Reserved4: PVOID, pAuthzClientContext: [*c]PVOID) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcFreeAuthorizationContext(pAuthzClientContext: [*c]PVOID) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcSsContextLockExclusive(ServerBindingHandle: RPC_BINDING_HANDLE, UserContext: PVOID) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcSsContextLockShared(ServerBindingHandle: RPC_BINDING_HANDLE, UserContext: PVOID) callconv(.Stdcall) RPC_STATUS;
pub const rlafInvalid = enum_tagRpcLocalAddressFormat.rlafInvalid;
pub const rlafIPv4 = enum_tagRpcLocalAddressFormat.rlafIPv4;
pub const rlafIPv6 = enum_tagRpcLocalAddressFormat.rlafIPv6;
pub const enum_tagRpcLocalAddressFormat = extern enum {
    rlafInvalid = 0,
    rlafIPv4 = 1,
    rlafIPv6 = 2,
};
pub const RpcLocalAddressFormat = enum_tagRpcLocalAddressFormat;
pub const struct__RPC_CALL_LOCAL_ADDRESS_V1 = extern struct {
    Version: c_uint,
    Buffer: ?*c_void,
    BufferSize: c_ulong,
    AddressFormat: RpcLocalAddressFormat,
};
pub const RPC_CALL_LOCAL_ADDRESS_V1 = struct__RPC_CALL_LOCAL_ADDRESS_V1;
pub const PRPC_CALL_LOCAL_ADDRESS_V1 = [*c]struct__RPC_CALL_LOCAL_ADDRESS_V1;
pub const struct_tagRPC_CALL_ATTRIBUTES_V1_W = extern struct {
    Version: c_uint,
    Flags: c_ulong,
    ServerPrincipalNameBufferLength: c_ulong,
    ServerPrincipalName: [*c]c_ushort,
    ClientPrincipalNameBufferLength: c_ulong,
    ClientPrincipalName: [*c]c_ushort,
    AuthenticationLevel: c_ulong,
    AuthenticationService: c_ulong,
    NullSession: BOOL,
};
pub const RPC_CALL_ATTRIBUTES_V1_W = struct_tagRPC_CALL_ATTRIBUTES_V1_W;
pub const struct_tagRPC_CALL_ATTRIBUTES_V1_A = extern struct {
    Version: c_uint,
    Flags: c_ulong,
    ServerPrincipalNameBufferLength: c_ulong,
    ServerPrincipalName: [*c]u8,
    ClientPrincipalNameBufferLength: c_ulong,
    ClientPrincipalName: [*c]u8,
    AuthenticationLevel: c_ulong,
    AuthenticationService: c_ulong,
    NullSession: BOOL,
};
pub const RPC_CALL_ATTRIBUTES_V1_A = struct_tagRPC_CALL_ATTRIBUTES_V1_A;
pub const rctInvalid = enum_tagRpcCallType.rctInvalid;
pub const rctNormal = enum_tagRpcCallType.rctNormal;
pub const rctTraining = enum_tagRpcCallType.rctTraining;
pub const rctGuaranteed = enum_tagRpcCallType.rctGuaranteed;
pub const enum_tagRpcCallType = extern enum {
    rctInvalid = 0,
    rctNormal = 1,
    rctTraining = 2,
    rctGuaranteed = 3,
};
pub const RpcCallType = enum_tagRpcCallType;
pub const rcclInvalid = enum_tagRpcCallClientLocality.rcclInvalid;
pub const rcclLocal = enum_tagRpcCallClientLocality.rcclLocal;
pub const rcclRemote = enum_tagRpcCallClientLocality.rcclRemote;
pub const rcclClientUnknownLocality = enum_tagRpcCallClientLocality.rcclClientUnknownLocality;
pub const enum_tagRpcCallClientLocality = extern enum {
    rcclInvalid = 0,
    rcclLocal = 1,
    rcclRemote = 2,
    rcclClientUnknownLocality = 3,
};
pub const RpcCallClientLocality = enum_tagRpcCallClientLocality;
pub const struct_tagRPC_CALL_ATTRIBUTES_V2_W = extern struct {
    Version: c_uint,
    Flags: c_ulong,
    ServerPrincipalNameBufferLength: c_ulong,
    ServerPrincipalName: [*c]c_ushort,
    ClientPrincipalNameBufferLength: c_ulong,
    ClientPrincipalName: [*c]c_ushort,
    AuthenticationLevel: c_ulong,
    AuthenticationService: c_ulong,
    NullSession: BOOL,
    KernelModeCaller: BOOL,
    ProtocolSequence: c_ulong,
    IsClientLocal: RpcCallClientLocality,
    ClientPID: HANDLE,
    CallStatus: c_ulong,
    CallType: RpcCallType,
    CallLocalAddress: [*c]RPC_CALL_LOCAL_ADDRESS_V1,
    OpNum: c_ushort,
    InterfaceUuid: UUID,
};
pub const RPC_CALL_ATTRIBUTES_V2_W = struct_tagRPC_CALL_ATTRIBUTES_V2_W;
pub const struct_tagRPC_CALL_ATTRIBUTES_V2_A = extern struct {
    Version: c_uint,
    Flags: c_ulong,
    ServerPrincipalNameBufferLength: c_ulong,
    ServerPrincipalName: [*c]u8,
    ClientPrincipalNameBufferLength: c_ulong,
    ClientPrincipalName: [*c]u8,
    AuthenticationLevel: c_ulong,
    AuthenticationService: c_ulong,
    NullSession: BOOL,
    KernelModeCaller: BOOL,
    ProtocolSequence: c_ulong,
    IsClientLocal: c_ulong,
    ClientPID: HANDLE,
    CallStatus: c_ulong,
    CallType: RpcCallType,
    CallLocalAddress: [*c]RPC_CALL_LOCAL_ADDRESS_V1,
    OpNum: c_ushort,
    InterfaceUuid: UUID,
};
pub const RPC_CALL_ATTRIBUTES_V2_A = struct_tagRPC_CALL_ATTRIBUTES_V2_A;
pub const struct_tagRPC_CALL_ATTRIBUTES_V3_W = extern struct {
    Version: c_uint,
    Flags: c_ulong,
    ServerPrincipalNameBufferLength: c_ulong,
    ServerPrincipalName: [*c]c_ushort,
    ClientPrincipalNameBufferLength: c_ulong,
    ClientPrincipalName: [*c]c_ushort,
    AuthenticationLevel: c_ulong,
    AuthenticationService: c_ulong,
    NullSession: BOOL,
    KernelModeCaller: BOOL,
    ProtocolSequence: c_ulong,
    IsClientLocal: RpcCallClientLocality,
    ClientPID: HANDLE,
    CallStatus: c_ulong,
    CallType: RpcCallType,
    CallLocalAddress: [*c]RPC_CALL_LOCAL_ADDRESS_V1,
    OpNum: c_ushort,
    InterfaceUuid: UUID,
    ClientIdentifierBufferLength: c_ulong,
    ClientIdentifier: [*c]u8,
};
pub const RPC_CALL_ATTRIBUTES_V3_W = struct_tagRPC_CALL_ATTRIBUTES_V3_W;
pub const struct_tagRPC_CALL_ATTRIBUTES_V3_A = extern struct {
    Version: c_uint,
    Flags: c_ulong,
    ServerPrincipalNameBufferLength: c_ulong,
    ServerPrincipalName: [*c]u8,
    ClientPrincipalNameBufferLength: c_ulong,
    ClientPrincipalName: [*c]u8,
    AuthenticationLevel: c_ulong,
    AuthenticationService: c_ulong,
    NullSession: BOOL,
    KernelModeCaller: BOOL,
    ProtocolSequence: c_ulong,
    IsClientLocal: c_ulong,
    ClientPID: HANDLE,
    CallStatus: c_ulong,
    CallType: RpcCallType,
    CallLocalAddress: [*c]RPC_CALL_LOCAL_ADDRESS_V1,
    OpNum: c_ushort,
    InterfaceUuid: UUID,
    ClientIdentifierBufferLength: c_ulong,
    ClientIdentifier: [*c]u8,
};
pub const RPC_CALL_ATTRIBUTES_V3_A = struct_tagRPC_CALL_ATTRIBUTES_V3_A;
pub extern "rpcrt4" fn RpcServerInqCallAttributesW(ClientBinding: RPC_BINDING_HANDLE, RpcCallAttributes: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerInqCallAttributesA(ClientBinding: RPC_BINDING_HANDLE, RpcCallAttributes: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub const RPC_CALL_ATTRIBUTES = RPC_CALL_ATTRIBUTES_V3_A;
pub const RpcNotificationCallNone = enum__RPC_NOTIFICATIONS.RpcNotificationCallNone;
pub const RpcNotificationClientDisconnect = enum__RPC_NOTIFICATIONS.RpcNotificationClientDisconnect;
pub const RpcNotificationCallCancel = enum__RPC_NOTIFICATIONS.RpcNotificationCallCancel;
pub const enum__RPC_NOTIFICATIONS = extern enum {
    RpcNotificationCallNone = 0,
    RpcNotificationClientDisconnect = 1,
    RpcNotificationCallCancel = 2,
};
pub const RPC_NOTIFICATIONS = enum__RPC_NOTIFICATIONS;
pub extern "rpcrt4" fn RpcServerSubscribeForNotification(Binding: RPC_BINDING_HANDLE, Notification: RPC_NOTIFICATIONS, NotificationType: RPC_NOTIFICATION_TYPES, NotificationInfo: [*c]RPC_ASYNC_NOTIFICATION_INFO) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcServerUnsubscribeForNotification(Binding: RPC_BINDING_HANDLE, Notification: RPC_NOTIFICATIONS, NotificationsQueued: [*c]c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingBind(pAsync: PRPC_ASYNC_STATE, Binding: RPC_BINDING_HANDLE, IfSpec: RPC_IF_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcBindingUnbind(Binding: RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcAsyncSetHandle(Message: PRPC_MESSAGE, pAsync: PRPC_ASYNC_STATE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcAsyncAbortCall(pAsync: PRPC_ASYNC_STATE, ExceptionCode: c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn I_RpcExceptionFilter(ExceptionCode: c_ulong) callconv(.Stdcall) c_int;
pub extern "rpcrt4" fn I_RpcBindingInqClientTokenAttributes(Binding: RPC_BINDING_HANDLE, TokenId: [*c]LUID, AuthenticationId: [*c]LUID, ModifiedId: [*c]LUID) callconv(.Stdcall) RPC_STATUS;
pub const struct_HDROP__ = extern struct {
    unused: c_int,
};
pub const HDROP = [*c]struct_HDROP__;
pub extern "shell32" fn DragQueryFileA(hDrop: HDROP, iFile: UINT, lpszFile: LPSTR, cch: UINT) UINT;
pub extern "shell32" fn DragQueryFileW(hDrop: HDROP, iFile: UINT, lpszFile: LPWSTR, cch: UINT) UINT;
pub extern "shell32" fn DragQueryPoint(hDrop: HDROP, ppt: [*c]POINT) BOOL;
pub extern "shell32" fn DragFinish(hDrop: HDROP) void;
pub extern "shell32" fn DragAcceptFiles(hWnd: HWND, fAccept: BOOL) void;
pub extern "shell32" fn ShellExecuteA(hwnd: HWND, lpOperation: LPCSTR, lpFile: LPCSTR, lpParameters: LPCSTR, lpDirectory: LPCSTR, nShowCmd: INT) HINSTANCE;
pub extern "shell32" fn ShellExecuteW(hwnd: HWND, lpOperation: LPCWSTR, lpFile: LPCWSTR, lpParameters: LPCWSTR, lpDirectory: LPCWSTR, nShowCmd: INT) HINSTANCE;
pub extern "shell32" fn FindExecutableA(lpFile: LPCSTR, lpDirectory: LPCSTR, lpResult: LPSTR) HINSTANCE;
pub extern "shell32" fn FindExecutableW(lpFile: LPCWSTR, lpDirectory: LPCWSTR, lpResult: LPWSTR) HINSTANCE;
pub extern "shell32" fn CommandLineToArgvW(lpCmdLine: LPCWSTR, pNumArgs: [*c]c_int) [*c]LPWSTR;
pub extern "shell32" fn ShellAboutA(hWnd: HWND, szApp: LPCSTR, szOtherStuff: LPCSTR, hIcon: HICON) INT;
pub extern "shell32" fn ShellAboutW(hWnd: HWND, szApp: LPCWSTR, szOtherStuff: LPCWSTR, hIcon: HICON) INT;
pub extern "shell32" fn DuplicateIcon(hInst: HINSTANCE, hIcon: HICON) HICON;
pub extern "shell32" fn ExtractAssociatedIconA(hInst: HINSTANCE, pszIconPath: LPSTR, piIcon: [*c]WORD) HICON;
pub extern "shell32" fn ExtractAssociatedIconW(hInst: HINSTANCE, pszIconPath: LPWSTR, piIcon: [*c]WORD) HICON;
pub extern "shell32" fn ExtractAssociatedIconExA(hInst: HINSTANCE, pszIconPath: LPSTR, piIconIndex: [*c]WORD, piIconId: [*c]WORD) HICON;
pub extern "shell32" fn ExtractAssociatedIconExW(hInst: HINSTANCE, pszIconPath: LPWSTR, piIconIndex: [*c]WORD, piIconId: [*c]WORD) HICON;
pub extern "shell32" fn ExtractIconA(hInst: HINSTANCE, pszExeFileName: LPCSTR, nIconIndex: UINT) HICON;
pub extern "shell32" fn ExtractIconW(hInst: HINSTANCE, pszExeFileName: LPCWSTR, nIconIndex: UINT) HICON;
pub const struct__DRAGINFOA = extern struct {
    uSize: UINT,
    pt: POINT,
    fNC: BOOL,
    lpFileList: PZZSTR,
    grfKeyState: DWORD,
};
pub const DRAGINFOA = struct__DRAGINFOA;
pub const LPDRAGINFOA = [*c]struct__DRAGINFOA;
pub const struct__DRAGINFOW = extern struct {
    uSize: UINT,
    pt: POINT,
    fNC: BOOL,
    lpFileList: PZZWSTR,
    grfKeyState: DWORD,
};
pub const DRAGINFOW = struct__DRAGINFOW;
pub const LPDRAGINFOW = [*c]struct__DRAGINFOW;
pub const DRAGINFO = DRAGINFOA;
pub const LPDRAGINFO = LPDRAGINFOA;
pub const struct__AppBarData = extern struct {
    cbSize: DWORD,
    hWnd: HWND,
    uCallbackMessage: UINT,
    uEdge: UINT,
    rc: RECT,
    lParam: LPARAM,
};
pub const APPBARDATA = struct__AppBarData;
pub const PAPPBARDATA = [*c]struct__AppBarData;
pub extern "shell32" fn SHAppBarMessage(dwMessage: DWORD, pData: PAPPBARDATA) callconv(.Stdcall) UINT_PTR;
pub extern "shell32" fn DoEnvironmentSubstA(pszSrc: LPSTR, cchSrc: UINT) callconv(.Stdcall) DWORD;
pub extern "shell32" fn DoEnvironmentSubstW(pszSrc: LPWSTR, cchSrc: UINT) callconv(.Stdcall) DWORD;
pub extern "shell32" fn ExtractIconExA(lpszFile: LPCSTR, nIconIndex: c_int, phiconLarge: [*c]HICON, phiconSmall: [*c]HICON, nIcons: UINT) callconv(.Stdcall) UINT;
pub extern "shell32" fn ExtractIconExW(lpszFile: LPCWSTR, nIconIndex: c_int, phiconLarge: [*c]HICON, phiconSmall: [*c]HICON, nIcons: UINT) callconv(.Stdcall) UINT;
pub const FILEOP_FLAGS = WORD;
pub const PRINTEROP_FLAGS = WORD;
pub const struct__SHFILEOPSTRUCTA = extern struct {
    hwnd: HWND,
    wFunc: UINT,
    pFrom: PCZZSTR,
    pTo: PCZZSTR,
    fFlags: FILEOP_FLAGS,
    fAnyOperationsAborted: BOOL,
    hNameMappings: LPVOID,
    lpszProgressTitle: PCSTR,
};
pub const SHFILEOPSTRUCTA = struct__SHFILEOPSTRUCTA;
pub const LPSHFILEOPSTRUCTA = [*c]struct__SHFILEOPSTRUCTA;
pub const struct__SHFILEOPSTRUCTW = extern struct {
    hwnd: HWND,
    wFunc: UINT,
    pFrom: PCZZWSTR,
    pTo: PCZZWSTR,
    fFlags: FILEOP_FLAGS,
    fAnyOperationsAborted: BOOL,
    hNameMappings: LPVOID,
    lpszProgressTitle: PCWSTR,
};
pub const SHFILEOPSTRUCTW = struct__SHFILEOPSTRUCTW;
pub const LPSHFILEOPSTRUCTW = [*c]struct__SHFILEOPSTRUCTW;
pub const SHFILEOPSTRUCT = SHFILEOPSTRUCTA;
pub const LPSHFILEOPSTRUCT = LPSHFILEOPSTRUCTA;
pub extern "shell32" fn SHFileOperationA(lpFileOp: LPSHFILEOPSTRUCTA) callconv(.Stdcall) c_int;
pub extern "shell32" fn SHFileOperationW(lpFileOp: LPSHFILEOPSTRUCTW) callconv(.Stdcall) c_int;
pub extern "shell32" fn SHFreeNameMappings(hNameMappings: HANDLE) callconv(.Stdcall) void;
pub const struct__SHNAMEMAPPINGA = extern struct {
    pszOldPath: LPSTR,
    pszNewPath: LPSTR,
    cchOldPath: c_int,
    cchNewPath: c_int,
};
pub const SHNAMEMAPPINGA = struct__SHNAMEMAPPINGA;
pub const LPSHNAMEMAPPINGA = [*c]struct__SHNAMEMAPPINGA;
pub const struct__SHNAMEMAPPINGW = extern struct {
    pszOldPath: LPWSTR,
    pszNewPath: LPWSTR,
    cchOldPath: c_int,
    cchNewPath: c_int,
};
pub const SHNAMEMAPPINGW = struct__SHNAMEMAPPINGW;
pub const LPSHNAMEMAPPINGW = [*c]struct__SHNAMEMAPPINGW;
pub const SHNAMEMAPPING = SHNAMEMAPPINGA;
pub const LPSHNAMEMAPPING = LPSHNAMEMAPPINGA;
pub const struct__SHELLEXECUTEINFOA = extern struct {
    cbSize: DWORD,
    fMask: ULONG,
    hwnd: HWND,
    lpVerb: LPCSTR,
    lpFile: LPCSTR,
    lpParameters: LPCSTR,
    lpDirectory: LPCSTR,
    nShow: c_int,
    hInstApp: HINSTANCE,
    lpIDList: ?*c_void,
    lpClass: LPCSTR,
    hkeyClass: HKEY,
    dwHotKey: DWORD,
    @"": extern union {
        hIcon: HANDLE,
        hMonitor: HANDLE,
    },
    hProcess: HANDLE,
};
pub const SHELLEXECUTEINFOA = struct__SHELLEXECUTEINFOA;
pub const LPSHELLEXECUTEINFOA = [*c]struct__SHELLEXECUTEINFOA;
pub const struct__SHELLEXECUTEINFOW = extern struct {
    cbSize: DWORD,
    fMask: ULONG,
    hwnd: HWND,
    lpVerb: LPCWSTR,
    lpFile: LPCWSTR,
    lpParameters: LPCWSTR,
    lpDirectory: LPCWSTR,
    nShow: c_int,
    hInstApp: HINSTANCE,
    lpIDList: ?*c_void,
    lpClass: LPCWSTR,
    hkeyClass: HKEY,
    dwHotKey: DWORD,
    @"": extern union {
        hIcon: HANDLE,
        hMonitor: HANDLE,
    },
    hProcess: HANDLE,
};
pub const SHELLEXECUTEINFOW = struct__SHELLEXECUTEINFOW;
pub const LPSHELLEXECUTEINFOW = [*c]struct__SHELLEXECUTEINFOW;
pub const SHELLEXECUTEINFO = SHELLEXECUTEINFOA;
pub const LPSHELLEXECUTEINFO = LPSHELLEXECUTEINFOA;
pub extern "shell32" fn ShellExecuteExA(pExecInfo: [*c]SHELLEXECUTEINFOA) callconv(.Stdcall) BOOL;
pub extern "shell32" fn ShellExecuteExW(pExecInfo: [*c]SHELLEXECUTEINFOW) callconv(.Stdcall) BOOL;
pub const struct__SHCREATEPROCESSINFOW = extern struct {
    cbSize: DWORD,
    fMask: ULONG,
    hwnd: HWND,
    pszFile: LPCWSTR,
    pszParameters: LPCWSTR,
    pszCurrentDirectory: LPCWSTR,
    hUserToken: HANDLE,
    lpProcessAttributes: LPSECURITY_ATTRIBUTES,
    lpThreadAttributes: LPSECURITY_ATTRIBUTES,
    bInheritHandles: BOOL,
    dwCreationFlags: DWORD,
    lpStartupInfo: LPSTARTUPINFOW,
    lpProcessInformation: LPPROCESS_INFORMATION,
};
pub const SHCREATEPROCESSINFOW = struct__SHCREATEPROCESSINFOW;
pub const PSHCREATEPROCESSINFOW = [*c]struct__SHCREATEPROCESSINFOW;
pub extern "shell32" fn SHCreateProcessAsUserW(pscpi: PSHCREATEPROCESSINFOW) callconv(.Stdcall) BOOL;
pub extern "shell32" fn SHEvaluateSystemCommandTemplate(pszCmdTemplate: PCWSTR, ppszApplication: [*c]PWSTR, ppszCommandLine: [*c]PWSTR, ppszParameters: [*c]PWSTR) callconv(.Stdcall) HRESULT;
pub const ASSOCCLASS_SHELL_KEY = enum_ASSOCCLASS._SHELL_KEY;
pub const ASSOCCLASS_PROGID_KEY = enum_ASSOCCLASS._PROGID_KEY;
pub const ASSOCCLASS_PROGID_STR = enum_ASSOCCLASS._PROGID_STR;
pub const ASSOCCLASS_CLSID_KEY = enum_ASSOCCLASS._CLSID_KEY;
pub const ASSOCCLASS_CLSID_STR = enum_ASSOCCLASS._CLSID_STR;
pub const ASSOCCLASS_APP_KEY = enum_ASSOCCLASS._APP_KEY;
pub const ASSOCCLASS_APP_STR = enum_ASSOCCLASS._APP_STR;
pub const ASSOCCLASS_SYSTEM_STR = enum_ASSOCCLASS._SYSTEM_STR;
pub const ASSOCCLASS_FOLDER = enum_ASSOCCLASS._FOLDER;
pub const ASSOCCLASS_STAR = enum_ASSOCCLASS._STAR;
pub const ASSOCCLASS_FIXED_PROGID_STR = enum_ASSOCCLASS._FIXED_PROGID_STR;
pub const ASSOCCLASS_PROTOCOL_STR = enum_ASSOCCLASS._PROTOCOL_STR;
pub const enum_ASSOCCLASS = extern enum {
    _SHELL_KEY = 0,
    _PROGID_KEY = 1,
    _PROGID_STR = 2,
    _CLSID_KEY = 3,
    _CLSID_STR = 4,
    _APP_KEY = 5,
    _APP_STR = 6,
    _SYSTEM_STR = 7,
    _FOLDER = 8,
    _STAR = 9,
    _FIXED_PROGID_STR = 10,
    _PROTOCOL_STR = 11,
};
pub const ASSOCCLASS = enum_ASSOCCLASS;
pub const struct_ASSOCIATIONELEMENT = extern struct {
    ac: ASSOCCLASS,
    hkClass: HKEY,
    pszClass: PCWSTR,
};
pub const ASSOCIATIONELEMENT = struct_ASSOCIATIONELEMENT;
pub extern "shell32" fn AssocCreateForClasses(rgClasses: [*c]const ASSOCIATIONELEMENT, cClasses: ULONG, riid: [*c]const IID, ppv: [*c](?*c_void)) callconv(.Stdcall) HRESULT;
pub const struct__SHQUERYRBINFO = extern struct {
    cbSize: DWORD,
    i64Size: c_longlong,
    i64NumItems: c_longlong,
};
pub const SHQUERYRBINFO = struct__SHQUERYRBINFO;
pub const LPSHQUERYRBINFO = [*c]struct__SHQUERYRBINFO;
pub extern "shell32" fn SHQueryRecycleBinA(pszRootPath: LPCSTR, pSHQueryRBInfo: LPSHQUERYRBINFO) callconv(.Stdcall) HRESULT;
pub extern "shell32" fn SHQueryRecycleBinW(pszRootPath: LPCWSTR, pSHQueryRBInfo: LPSHQUERYRBINFO) callconv(.Stdcall) HRESULT;
pub extern "shell32" fn SHEmptyRecycleBinA(hwnd: HWND, pszRootPath: LPCSTR, dwFlags: DWORD) callconv(.Stdcall) HRESULT;
pub extern "shell32" fn SHEmptyRecycleBinW(hwnd: HWND, pszRootPath: LPCWSTR, dwFlags: DWORD) callconv(.Stdcall) HRESULT;
pub const QUNS_NOT_PRESENT = 1;
pub const QUNS_BUSY = 2;
pub const QUNS_RUNNING_D3D_FULL_SCREEN = 3;
pub const QUNS_PRESENTATION_MODE = 4;
pub const QUNS_ACCEPTS_NOTIFICATIONS = 5;
pub const QUNS_QUIET_TIME = 6;
pub const QUNS_APP = 7;
pub const QUERY_USER_NOTIFICATION_STATE = extern enum {
    QUNS_NOT_PRESENT = 1,
    QUNS_BUSY = 2,
    QUNS_RUNNING_D3D_FULL_SCREEN = 3,
    QUNS_PRESENTATION_MODE = 4,
    QUNS_ACCEPTS_NOTIFICATIONS = 5,
    QUNS_QUIET_TIME = 6,
    QUNS_APP = 7,
};
pub extern "shell32" fn SHQueryUserNotificationState(pquns: [*c]QUERY_USER_NOTIFICATION_STATE) callconv(.Stdcall) HRESULT;
pub extern "shell32" fn SHGetPropertyStoreForWindow(hwnd: HWND, riid: [*c]const IID, ppv: [*c](?*c_void)) callconv(.Stdcall) HRESULT;
pub const struct__NOTIFYICONDATAA = extern struct {
    cbSize: DWORD,
    hWnd: HWND,
    uID: UINT,
    uFlags: UINT,
    uCallbackMessage: UINT,
    hIcon: HICON,
    szTip: [128]CHAR,
    dwState: DWORD,
    dwStateMask: DWORD,
    szInfo: [256]CHAR,
    @"": extern union {
        uTimeout: UINT,
        uVersion: UINT,
    },
    szInfoTitle: [64]CHAR,
    dwInfoFlags: DWORD,
    guidItem: GUID,
    hBalloonIcon: HICON,
};
pub const NOTIFYICONDATAA = struct__NOTIFYICONDATAA;
pub const PNOTIFYICONDATAA = [*c]struct__NOTIFYICONDATAA;
pub const struct__NOTIFYICONDATAW = extern struct {
    cbSize: DWORD,
    hWnd: HWND,
    uID: UINT,
    uFlags: UINT,
    uCallbackMessage: UINT,
    hIcon: HICON,
    szTip: [128]WCHAR,
    dwState: DWORD,
    dwStateMask: DWORD,
    szInfo: [256]WCHAR,
    @"": extern union {
        uTimeout: UINT,
        uVersion: UINT,
    },
    szInfoTitle: [64]WCHAR,
    dwInfoFlags: DWORD,
    guidItem: GUID,
    hBalloonIcon: HICON,
};
pub const NOTIFYICONDATAW = struct__NOTIFYICONDATAW;
pub const PNOTIFYICONDATAW = [*c]struct__NOTIFYICONDATAW;
pub const NOTIFYICONDATA = NOTIFYICONDATAA;
pub const PNOTIFYICONDATA = PNOTIFYICONDATAA;
pub const struct__NOTIFYICONIDENTIFIER = extern struct {
    cbSize: DWORD,
    hWnd: HWND,
    uID: UINT,
    guidItem: GUID,
};
pub const NOTIFYICONIDENTIFIER = struct__NOTIFYICONIDENTIFIER;
pub const PNOTIFYICONIDENTIFIER = [*c]struct__NOTIFYICONIDENTIFIER;
pub extern "shell32" fn Shell_NotifyIconA(dwMessage: DWORD, lpData: PNOTIFYICONDATAA) callconv(.Stdcall) BOOL;
pub extern "shell32" fn Shell_NotifyIconW(dwMessage: DWORD, lpData: PNOTIFYICONDATAW) callconv(.Stdcall) BOOL;
pub extern "shell32" fn Shell_NotifyIconGetRect(identifier: [*c]const NOTIFYICONIDENTIFIER, iconLocation: [*c]RECT) callconv(.Stdcall) HRESULT;
pub const struct__SHFILEINFOA = extern struct {
    hIcon: HICON,
    iIcon: c_int,
    dwAttributes: DWORD,
    szDisplayName: [260]CHAR,
    szTypeName: [80]CHAR,
};
pub const SHFILEINFOA = struct__SHFILEINFOA;
pub const struct__SHFILEINFOW = extern struct {
    hIcon: HICON,
    iIcon: c_int,
    dwAttributes: DWORD,
    szDisplayName: [260]WCHAR,
    szTypeName: [80]WCHAR,
};
pub const SHFILEINFOW = struct__SHFILEINFOW;
pub const SHFILEINFO = SHFILEINFOA;
pub extern "shell32" fn SHGetFileInfoA(pszPath: LPCSTR, dwFileAttributes: DWORD, psfi: [*c]SHFILEINFOA, cbFileInfo: UINT, uFlags: UINT) callconv(.Stdcall) DWORD_PTR;
pub extern "shell32" fn SHGetFileInfoW(pszPath: LPCWSTR, dwFileAttributes: DWORD, psfi: [*c]SHFILEINFOW, cbFileInfo: UINT, uFlags: UINT) callconv(.Stdcall) DWORD_PTR;
pub const struct__SHSTOCKICONINFO = extern struct {
    cbSize: DWORD,
    hIcon: HICON,
    iSysImageIndex: c_int,
    iIcon: c_int,
    szPath: [260]WCHAR,
};
pub const SHSTOCKICONINFO = struct__SHSTOCKICONINFO;
pub const SIID_DOCNOASSOC = enum_SHSTOCKICONID.SIID_DOCNOASSOC;
pub const SIID_DOCASSOC = enum_SHSTOCKICONID.SIID_DOCASSOC;
pub const SIID_APPLICATION = enum_SHSTOCKICONID.SIID_APPLICATION;
pub const SIID_FOLDER = enum_SHSTOCKICONID.SIID_FOLDER;
pub const SIID_FOLDEROPEN = enum_SHSTOCKICONID.SIID_FOLDEROPEN;
pub const SIID_DRIVE525 = enum_SHSTOCKICONID.SIID_DRIVE525;
pub const SIID_DRIVE35 = enum_SHSTOCKICONID.SIID_DRIVE35;
pub const SIID_DRIVEREMOVE = enum_SHSTOCKICONID.SIID_DRIVEREMOVE;
pub const SIID_DRIVEFIXED = enum_SHSTOCKICONID.SIID_DRIVEFIXED;
pub const SIID_DRIVENET = enum_SHSTOCKICONID.SIID_DRIVENET;
pub const SIID_DRIVENETDISABLED = enum_SHSTOCKICONID.SIID_DRIVENETDISABLED;
pub const SIID_DRIVECD = enum_SHSTOCKICONID.SIID_DRIVECD;
pub const SIID_DRIVERAM = enum_SHSTOCKICONID.SIID_DRIVERAM;
pub const SIID_WORLD = enum_SHSTOCKICONID.SIID_WORLD;
pub const SIID_SERVER = enum_SHSTOCKICONID.SIID_SERVER;
pub const SIID_PRINTER = enum_SHSTOCKICONID.SIID_PRINTER;
pub const SIID_MYNETWORK = enum_SHSTOCKICONID.SIID_MYNETWORK;
pub const SIID_FIND = enum_SHSTOCKICONID.SIID_FIND;
pub const SIID_HELP = enum_SHSTOCKICONID.SIID_HELP;
pub const SIID_SHARE = enum_SHSTOCKICONID.SIID_SHARE;
pub const SIID_LINK = enum_SHSTOCKICONID.SIID_LINK;
pub const SIID_SLOWFILE = enum_SHSTOCKICONID.SIID_SLOWFILE;
pub const SIID_RECYCLER = enum_SHSTOCKICONID.SIID_RECYCLER;
pub const SIID_RECYCLERFULL = enum_SHSTOCKICONID.SIID_RECYCLERFULL;
pub const SIID_MEDIACDAUDIO = enum_SHSTOCKICONID.SIID_MEDIACDAUDIO;
pub const SIID_LOCK = enum_SHSTOCKICONID.SIID_LOCK;
pub const SIID_AUTOLIST = enum_SHSTOCKICONID.SIID_AUTOLIST;
pub const SIID_PRINTERNET = enum_SHSTOCKICONID.SIID_PRINTERNET;
pub const SIID_SERVERSHARE = enum_SHSTOCKICONID.SIID_SERVERSHARE;
pub const SIID_PRINTERFAX = enum_SHSTOCKICONID.SIID_PRINTERFAX;
pub const SIID_PRINTERFAXNET = enum_SHSTOCKICONID.SIID_PRINTERFAXNET;
pub const SIID_PRINTERFILE = enum_SHSTOCKICONID.SIID_PRINTERFILE;
pub const SIID_STACK = enum_SHSTOCKICONID.SIID_STACK;
pub const SIID_MEDIASVCD = enum_SHSTOCKICONID.SIID_MEDIASVCD;
pub const SIID_STUFFEDFOLDER = enum_SHSTOCKICONID.SIID_STUFFEDFOLDER;
pub const SIID_DRIVEUNKNOWN = enum_SHSTOCKICONID.SIID_DRIVEUNKNOWN;
pub const SIID_DRIVEDVD = enum_SHSTOCKICONID.SIID_DRIVEDVD;
pub const SIID_MEDIADVD = enum_SHSTOCKICONID.SIID_MEDIADVD;
pub const SIID_MEDIADVDRAM = enum_SHSTOCKICONID.SIID_MEDIADVDRAM;
pub const SIID_MEDIADVDRW = enum_SHSTOCKICONID.SIID_MEDIADVDRW;
pub const SIID_MEDIADVDR = enum_SHSTOCKICONID.SIID_MEDIADVDR;
pub const SIID_MEDIADVDROM = enum_SHSTOCKICONID.SIID_MEDIADVDROM;
pub const SIID_MEDIACDAUDIOPLUS = enum_SHSTOCKICONID.SIID_MEDIACDAUDIOPLUS;
pub const SIID_MEDIACDRW = enum_SHSTOCKICONID.SIID_MEDIACDRW;
pub const SIID_MEDIACDR = enum_SHSTOCKICONID.SIID_MEDIACDR;
pub const SIID_MEDIACDBURN = enum_SHSTOCKICONID.SIID_MEDIACDBURN;
pub const SIID_MEDIABLANKCD = enum_SHSTOCKICONID.SIID_MEDIABLANKCD;
pub const SIID_MEDIACDROM = enum_SHSTOCKICONID.SIID_MEDIACDROM;
pub const SIID_AUDIOFILES = enum_SHSTOCKICONID.SIID_AUDIOFILES;
pub const SIID_IMAGEFILES = enum_SHSTOCKICONID.SIID_IMAGEFILES;
pub const SIID_VIDEOFILES = enum_SHSTOCKICONID.SIID_VIDEOFILES;
pub const SIID_MIXEDFILES = enum_SHSTOCKICONID.SIID_MIXEDFILES;
pub const SIID_FOLDERBACK = enum_SHSTOCKICONID.SIID_FOLDERBACK;
pub const SIID_FOLDERFRONT = enum_SHSTOCKICONID.SIID_FOLDERFRONT;
pub const SIID_SHIELD = enum_SHSTOCKICONID.SIID_SHIELD;
pub const SIID_WARNING = enum_SHSTOCKICONID.SIID_WARNING;
pub const SIID_INFO = enum_SHSTOCKICONID.SIID_INFO;
pub const SIID_ERROR = enum_SHSTOCKICONID.SIID_ERROR;
pub const SIID_KEY = enum_SHSTOCKICONID.SIID_KEY;
pub const SIID_SOFTWARE = enum_SHSTOCKICONID.SIID_SOFTWARE;
pub const SIID_RENAME = enum_SHSTOCKICONID.SIID_RENAME;
pub const SIID_DELETE = enum_SHSTOCKICONID.SIID_DELETE;
pub const SIID_MEDIAAUDIODVD = enum_SHSTOCKICONID.SIID_MEDIAAUDIODVD;
pub const SIID_MEDIAMOVIEDVD = enum_SHSTOCKICONID.SIID_MEDIAMOVIEDVD;
pub const SIID_MEDIAENHANCEDCD = enum_SHSTOCKICONID.SIID_MEDIAENHANCEDCD;
pub const SIID_MEDIAENHANCEDDVD = enum_SHSTOCKICONID.SIID_MEDIAENHANCEDDVD;
pub const SIID_MEDIAHDDVD = enum_SHSTOCKICONID.SIID_MEDIAHDDVD;
pub const SIID_MEDIABLURAY = enum_SHSTOCKICONID.SIID_MEDIABLURAY;
pub const SIID_MEDIAVCD = enum_SHSTOCKICONID.SIID_MEDIAVCD;
pub const SIID_MEDIADVDPLUSR = enum_SHSTOCKICONID.SIID_MEDIADVDPLUSR;
pub const SIID_MEDIADVDPLUSRW = enum_SHSTOCKICONID.SIID_MEDIADVDPLUSRW;
pub const SIID_DESKTOPPC = enum_SHSTOCKICONID.SIID_DESKTOPPC;
pub const SIID_MOBILEPC = enum_SHSTOCKICONID.SIID_MOBILEPC;
pub const SIID_USERS = enum_SHSTOCKICONID.SIID_USERS;
pub const SIID_MEDIASMARTMEDIA = enum_SHSTOCKICONID.SIID_MEDIASMARTMEDIA;
pub const SIID_MEDIACOMPACTFLASH = enum_SHSTOCKICONID.SIID_MEDIACOMPACTFLASH;
pub const SIID_DEVICECELLPHONE = enum_SHSTOCKICONID.SIID_DEVICECELLPHONE;
pub const SIID_DEVICECAMERA = enum_SHSTOCKICONID.SIID_DEVICECAMERA;
pub const SIID_DEVICEVIDEOCAMERA = enum_SHSTOCKICONID.SIID_DEVICEVIDEOCAMERA;
pub const SIID_DEVICEAUDIOPLAYER = enum_SHSTOCKICONID.SIID_DEVICEAUDIOPLAYER;
pub const SIID_NETWORKCONNECT = enum_SHSTOCKICONID.SIID_NETWORKCONNECT;
pub const SIID_INTERNET = enum_SHSTOCKICONID.SIID_INTERNET;
pub const SIID_ZIPFILE = enum_SHSTOCKICONID.SIID_ZIPFILE;
pub const SIID_SETTINGS = enum_SHSTOCKICONID.SIID_SETTINGS;
pub const SIID_DRIVEHDDVD = enum_SHSTOCKICONID.SIID_DRIVEHDDVD;
pub const SIID_DRIVEBD = enum_SHSTOCKICONID.SIID_DRIVEBD;
pub const SIID_MEDIAHDDVDROM = enum_SHSTOCKICONID.SIID_MEDIAHDDVDROM;
pub const SIID_MEDIAHDDVDR = enum_SHSTOCKICONID.SIID_MEDIAHDDVDR;
pub const SIID_MEDIAHDDVDRAM = enum_SHSTOCKICONID.SIID_MEDIAHDDVDRAM;
pub const SIID_MEDIABDROM = enum_SHSTOCKICONID.SIID_MEDIABDROM;
pub const SIID_MEDIABDR = enum_SHSTOCKICONID.SIID_MEDIABDR;
pub const SIID_MEDIABDRE = enum_SHSTOCKICONID.SIID_MEDIABDRE;
pub const SIID_CLUSTEREDDRIVE = enum_SHSTOCKICONID.SIID_CLUSTEREDDRIVE;
pub const SIID_MAX_ICONS = enum_SHSTOCKICONID.SIID_MAX_ICONS;
pub const enum_SHSTOCKICONID = extern enum {
    SIID_DOCNOASSOC = 0,
    SIID_DOCASSOC = 1,
    SIID_APPLICATION = 2,
    SIID_FOLDER = 3,
    SIID_FOLDEROPEN = 4,
    SIID_DRIVE525 = 5,
    SIID_DRIVE35 = 6,
    SIID_DRIVEREMOVE = 7,
    SIID_DRIVEFIXED = 8,
    SIID_DRIVENET = 9,
    SIID_DRIVENETDISABLED = 10,
    SIID_DRIVECD = 11,
    SIID_DRIVERAM = 12,
    SIID_WORLD = 13,
    SIID_SERVER = 15,
    SIID_PRINTER = 16,
    SIID_MYNETWORK = 17,
    SIID_FIND = 22,
    SIID_HELP = 23,
    SIID_SHARE = 28,
    SIID_LINK = 29,
    SIID_SLOWFILE = 30,
    SIID_RECYCLER = 31,
    SIID_RECYCLERFULL = 32,
    SIID_MEDIACDAUDIO = 40,
    SIID_LOCK = 47,
    SIID_AUTOLIST = 49,
    SIID_PRINTERNET = 50,
    SIID_SERVERSHARE = 51,
    SIID_PRINTERFAX = 52,
    SIID_PRINTERFAXNET = 53,
    SIID_PRINTERFILE = 54,
    SIID_STACK = 55,
    SIID_MEDIASVCD = 56,
    SIID_STUFFEDFOLDER = 57,
    SIID_DRIVEUNKNOWN = 58,
    SIID_DRIVEDVD = 59,
    SIID_MEDIADVD = 60,
    SIID_MEDIADVDRAM = 61,
    SIID_MEDIADVDRW = 62,
    SIID_MEDIADVDR = 63,
    SIID_MEDIADVDROM = 64,
    SIID_MEDIACDAUDIOPLUS = 65,
    SIID_MEDIACDRW = 66,
    SIID_MEDIACDR = 67,
    SIID_MEDIACDBURN = 68,
    SIID_MEDIABLANKCD = 69,
    SIID_MEDIACDROM = 70,
    SIID_AUDIOFILES = 71,
    SIID_IMAGEFILES = 72,
    SIID_VIDEOFILES = 73,
    SIID_MIXEDFILES = 74,
    SIID_FOLDERBACK = 75,
    SIID_FOLDERFRONT = 76,
    SIID_SHIELD = 77,
    SIID_WARNING = 78,
    SIID_INFO = 79,
    SIID_ERROR = 80,
    SIID_KEY = 81,
    SIID_SOFTWARE = 82,
    SIID_RENAME = 83,
    SIID_DELETE = 84,
    SIID_MEDIAAUDIODVD = 85,
    SIID_MEDIAMOVIEDVD = 86,
    SIID_MEDIAENHANCEDCD = 87,
    SIID_MEDIAENHANCEDDVD = 88,
    SIID_MEDIAHDDVD = 89,
    SIID_MEDIABLURAY = 90,
    SIID_MEDIAVCD = 91,
    SIID_MEDIADVDPLUSR = 92,
    SIID_MEDIADVDPLUSRW = 93,
    SIID_DESKTOPPC = 94,
    SIID_MOBILEPC = 95,
    SIID_USERS = 96,
    SIID_MEDIASMARTMEDIA = 97,
    SIID_MEDIACOMPACTFLASH = 98,
    SIID_DEVICECELLPHONE = 99,
    SIID_DEVICECAMERA = 100,
    SIID_DEVICEVIDEOCAMERA = 101,
    SIID_DEVICEAUDIOPLAYER = 102,
    SIID_NETWORKCONNECT = 103,
    SIID_INTERNET = 104,
    SIID_ZIPFILE = 105,
    SIID_SETTINGS = 106,
    SIID_DRIVEHDDVD = 132,
    SIID_DRIVEBD = 133,
    SIID_MEDIAHDDVDROM = 134,
    SIID_MEDIAHDDVDR = 135,
    SIID_MEDIAHDDVDRAM = 136,
    SIID_MEDIABDROM = 137,
    SIID_MEDIABDR = 138,
    SIID_MEDIABDRE = 139,
    SIID_CLUSTEREDDRIVE = 140,
    SIID_MAX_ICONS = 181,
};
pub const SHSTOCKICONID = enum_SHSTOCKICONID;
pub extern "shell32" fn SHGetStockIconInfo(siid: SHSTOCKICONID, uFlags: UINT, psii: [*c]SHSTOCKICONINFO) callconv(.Stdcall) HRESULT;
pub extern "shell32" fn SHGetDiskFreeSpaceExA(pszDirectoryName: LPCSTR, pulFreeBytesAvailableToCaller: [*c]ULARGE_INTEGER, pulTotalNumberOfBytes: [*c]ULARGE_INTEGER, pulTotalNumberOfFreeBytes: [*c]ULARGE_INTEGER) callconv(.Stdcall) BOOL;
pub extern "shell32" fn SHGetDiskFreeSpaceExW(pszDirectoryName: LPCWSTR, pulFreeBytesAvailableToCaller: [*c]ULARGE_INTEGER, pulTotalNumberOfBytes: [*c]ULARGE_INTEGER, pulTotalNumberOfFreeBytes: [*c]ULARGE_INTEGER) callconv(.Stdcall) BOOL;
pub extern "shell32" fn SHGetNewLinkInfoA(pszLinkTo: LPCSTR, pszDir: LPCSTR, pszName: LPSTR, pfMustCopy: [*c]BOOL, uFlags: UINT) callconv(.Stdcall) BOOL;
pub extern "shell32" fn SHGetNewLinkInfoW(pszLinkTo: LPCWSTR, pszDir: LPCWSTR, pszName: LPWSTR, pfMustCopy: [*c]BOOL, uFlags: UINT) callconv(.Stdcall) BOOL;
pub extern "shell32" fn SHInvokePrinterCommandA(hwnd: HWND, uAction: UINT, lpBuf1: LPCSTR, lpBuf2: LPCSTR, fModal: BOOL) callconv(.Stdcall) BOOL;
pub extern "shell32" fn SHInvokePrinterCommandW(hwnd: HWND, uAction: UINT, lpBuf1: LPCWSTR, lpBuf2: LPCWSTR, fModal: BOOL) callconv(.Stdcall) BOOL;
pub const struct__OPEN_PRINTER_PROPS_INFOA = extern struct {
    dwSize: DWORD,
    pszSheetName: LPSTR,
    uSheetIndex: UINT,
    dwFlags: DWORD,
    bModal: BOOL,
};
pub const OPEN_PRINTER_PROPS_INFOA = struct__OPEN_PRINTER_PROPS_INFOA;
pub const POPEN_PRINTER_PROPS_INFOA = [*c]struct__OPEN_PRINTER_PROPS_INFOA;
pub const struct__OPEN_PRINTER_PROPS_INFOW = extern struct {
    dwSize: DWORD,
    pszSheetName: LPWSTR,
    uSheetIndex: UINT,
    dwFlags: DWORD,
    bModal: BOOL,
};
pub const OPEN_PRINTER_PROPS_INFOW = struct__OPEN_PRINTER_PROPS_INFOW;
pub const POPEN_PRINTER_PROPS_INFOW = [*c]struct__OPEN_PRINTER_PROPS_INFOW;
pub const OPEN_PRINTER_PROPS_INFO = OPEN_PRINTER_PROPS_INFOA;
pub const POPEN_PRINTER_PROPS_INFO = POPEN_PRINTER_PROPS_INFOA;
pub extern "shell32" fn SHLoadNonloadedIconOverlayIdentifiers() callconv(.Stdcall) HRESULT;
pub extern "shell32" fn SHIsFileAvailableOffline(pwszPath: PCWSTR, pdwStatus: [*c]DWORD) callconv(.Stdcall) HRESULT;
pub extern "shell32" fn SHSetLocalizedName(pszPath: PCWSTR, pszResModule: PCWSTR, idsRes: c_int) callconv(.Stdcall) HRESULT;
pub extern "shell32" fn SHRemoveLocalizedName(pszPath: PCWSTR) callconv(.Stdcall) HRESULT;
pub extern "shell32" fn SHGetLocalizedName(pszPath: PCWSTR, pszResModule: PWSTR, cch: UINT, pidsRes: [*c]c_int) callconv(.Stdcall) HRESULT;
pub extern "shell32" fn ShellMessageBoxA(hAppInst: HINSTANCE, hWnd: HWND, lpcText: LPCSTR, lpcTitle: LPCSTR, fuStyle: UINT, ...) callconv(.Stdcall) c_int;
pub extern "shell32" fn ShellMessageBoxW(hAppInst: HINSTANCE, hWnd: HWND, lpcText: LPCWSTR, lpcTitle: LPCWSTR, fuStyle: UINT, ...) callconv(.Stdcall) c_int;
pub extern "shell32" fn IsLFNDriveA(pszPath: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "shell32" fn IsLFNDriveW(pszPath: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "shell32" fn SHEnumerateUnreadMailAccountsA(hKeyUser: HKEY, dwIndex: DWORD, pszMailAddress: LPSTR, cchMailAddress: c_int) callconv(.Stdcall) HRESULT;
pub extern "shell32" fn SHEnumerateUnreadMailAccountsW(hKeyUser: HKEY, dwIndex: DWORD, pszMailAddress: LPWSTR, cchMailAddress: c_int) callconv(.Stdcall) HRESULT;
pub extern "shell32" fn SHGetUnreadMailCountA(hKeyUser: HKEY, pszMailAddress: LPCSTR, pdwCount: [*c]DWORD, pFileTime: [*c]FILETIME, pszShellExecuteCommand: LPSTR, cchShellExecuteCommand: c_int) callconv(.Stdcall) HRESULT;
pub extern "shell32" fn SHGetUnreadMailCountW(hKeyUser: HKEY, pszMailAddress: LPCWSTR, pdwCount: [*c]DWORD, pFileTime: [*c]FILETIME, pszShellExecuteCommand: LPWSTR, cchShellExecuteCommand: c_int) callconv(.Stdcall) HRESULT;
pub extern "shell32" fn SHSetUnreadMailCountA(pszMailAddress: LPCSTR, dwCount: DWORD, pszShellExecuteCommand: LPCSTR) callconv(.Stdcall) HRESULT;
pub extern "shell32" fn SHSetUnreadMailCountW(pszMailAddress: LPCWSTR, dwCount: DWORD, pszShellExecuteCommand: LPCWSTR) callconv(.Stdcall) HRESULT;
pub extern "shell32" fn SHTestTokenMembership(hToken: HANDLE, ulRID: ULONG) callconv(.Stdcall) BOOL;
pub extern "shell32" fn SHGetImageList(iImageList: c_int, riid: [*c]const IID, ppvObj: [*c](?*c_void)) callconv(.Stdcall) HRESULT;
pub const PFNCANSHAREFOLDERW = ?fn (PCWSTR) callconv(.C) HRESULT;
pub const PFNSHOWSHAREFOLDERUIW = ?fn (HWND, PCWSTR) callconv(.C) HRESULT;
pub extern "shell32" fn InitNetworkAddressControl() callconv(.Stdcall) BOOL;
pub const struct_NET_ADDRESS_INFO_ = @OpaqueType();
pub const struct_tagNC_ADDRESS = extern struct {
    pAddrInfo: ?*struct_NET_ADDRESS_INFO_,
    PortNumber: USHORT,
    PrefixLength: BYTE,
};
pub const NC_ADDRESS = struct_tagNC_ADDRESS;
pub const PNC_ADDRESS = [*c]struct_tagNC_ADDRESS;
pub extern "shell32" fn SHGetDriveMedia(pszDrive: PCWSTR, pdwMediaContent: [*c]DWORD) callconv(.Stdcall) HRESULT;
pub const struct__PERF_DATA_BLOCK = extern struct {
    Signature: [4]WCHAR,
    LittleEndian: DWORD,
    Version: DWORD,
    Revision: DWORD,
    TotalByteLength: DWORD,
    HeaderLength: DWORD,
    NumObjectTypes: DWORD,
    DefaultObject: LONG,
    SystemTime: SYSTEMTIME,
    PerfTime: LARGE_INTEGER,
    PerfFreq: LARGE_INTEGER,
    PerfTime100nSec: LARGE_INTEGER,
    SystemNameLength: DWORD,
    SystemNameOffset: DWORD,
};
pub const PERF_DATA_BLOCK = struct__PERF_DATA_BLOCK;
pub const PPERF_DATA_BLOCK = [*c]struct__PERF_DATA_BLOCK;
pub const struct__PERF_OBJECT_TYPE = extern struct {
    TotalByteLength: DWORD,
    DefinitionLength: DWORD,
    HeaderLength: DWORD,
    ObjectNameTitleIndex: DWORD,
    ObjectNameTitle: DWORD,
    ObjectHelpTitleIndex: DWORD,
    ObjectHelpTitle: DWORD,
    DetailLevel: DWORD,
    NumCounters: DWORD,
    DefaultCounter: LONG,
    NumInstances: LONG,
    CodePage: DWORD,
    PerfTime: LARGE_INTEGER,
    PerfFreq: LARGE_INTEGER,
};
pub const PERF_OBJECT_TYPE = struct__PERF_OBJECT_TYPE;
pub const PPERF_OBJECT_TYPE = [*c]struct__PERF_OBJECT_TYPE;
pub const struct__PERF_COUNTER_DEFINITION = extern struct {
    ByteLength: DWORD,
    CounterNameTitleIndex: DWORD,
    CounterNameTitle: DWORD,
    CounterHelpTitleIndex: DWORD,
    CounterHelpTitle: DWORD,
    DefaultScale: LONG,
    DetailLevel: DWORD,
    CounterType: DWORD,
    CounterSize: DWORD,
    CounterOffset: DWORD,
};
pub const PERF_COUNTER_DEFINITION = struct__PERF_COUNTER_DEFINITION;
pub const PPERF_COUNTER_DEFINITION = [*c]struct__PERF_COUNTER_DEFINITION;
pub const struct__PERF_INSTANCE_DEFINITION = extern struct {
    ByteLength: DWORD,
    ParentObjectTitleIndex: DWORD,
    ParentObjectInstance: DWORD,
    UniqueID: LONG,
    NameOffset: DWORD,
    NameLength: DWORD,
};
pub const PERF_INSTANCE_DEFINITION = struct__PERF_INSTANCE_DEFINITION;
pub const PPERF_INSTANCE_DEFINITION = [*c]struct__PERF_INSTANCE_DEFINITION;
pub const struct__PERF_COUNTER_BLOCK = extern struct {
    ByteLength: DWORD,
};
pub const PERF_COUNTER_BLOCK = struct__PERF_COUNTER_BLOCK;
pub const PPERF_COUNTER_BLOCK = [*c]struct__PERF_COUNTER_BLOCK;
pub const PM_OPEN_PROC = fn (LPWSTR) callconv(.C) DWORD;
pub const PM_COLLECT_PROC = fn (LPWSTR, [*c]LPVOID, LPDWORD, LPDWORD) callconv(.C) DWORD;
pub const PM_CLOSE_PROC = fn () callconv(.C) DWORD;
pub const PM_QUERY_PROC = fn (LPDWORD, [*c]LPVOID, LPDWORD, LPDWORD) callconv(.C) DWORD;
pub const u_char = u8;
pub const u_short = c_ushort;
pub const u_int = c_uint;
pub const u_long = c_ulong;
pub const SOCKET = UINT_PTR;
pub const struct_fd_set = extern struct {
    fd_count: u_int,
    fd_array: [64]SOCKET,
};
pub const fd_set = struct_fd_set;
pub extern "ws2_32" fn __WSAFDIsSet(arg0: SOCKET, arg1: [*c]fd_set) c_int;
pub const struct_timeval = extern struct {
    tv_sec: c_long,
    tv_usec: c_long,
};
pub const struct_hostent = extern struct {
    h_name: [*c]u8,
    h_aliases: [*c]([*c]u8),
    h_addrtype: c_short,
    h_length: c_short,
    h_addr_list: [*c]([*c]u8),
};
pub const struct_netent = extern struct {
    n_name: [*c]u8,
    n_aliases: [*c]([*c]u8),
    n_addrtype: c_short,
    n_net: u_long,
};
pub const struct_servent = extern struct {
    s_name: [*c]u8,
    s_aliases: [*c]([*c]u8),
    s_proto: [*c]u8,
    s_port: c_short,
};
pub const struct_protoent = extern struct {
    p_name: [*c]u8,
    p_aliases: [*c]([*c]u8),
    p_proto: c_short,
};
pub const struct_in_addr = extern struct {
    S_un: extern union {
        S_un_b: extern struct {
            s_b1: UCHAR,
            s_b2: UCHAR,
            s_b3: UCHAR,
            s_b4: UCHAR,
        },
        S_un_w: extern struct {
            s_w1: USHORT,
            s_w2: USHORT,
        },
        S_addr: ULONG,
    },
};
pub const IN_ADDR = struct_in_addr;
pub const PIN_ADDR = [*c]struct_in_addr;
pub const LPIN_ADDR = [*c]struct_in_addr;
pub const struct_sockaddr_in = extern struct {
    sin_family: c_short,
    sin_port: u_short,
    sin_addr: struct_in_addr,
    sin_zero: [8]u8,
};
pub const struct_WSAData = extern struct {
    wVersion: WORD,
    wHighVersion: WORD,
    iMaxSockets: c_ushort,
    iMaxUdpDg: c_ushort,
    lpVendorInfo: [*c]u8,
    szDescription: [257]u8,
    szSystemStatus: [129]u8,
};
pub const WSADATA = struct_WSAData;
pub const LPWSADATA = [*c]WSADATA;
pub const struct_ip_mreq = extern struct {
    imr_multiaddr: struct_in_addr,
    imr_interface: struct_in_addr,
};
pub const struct_sockaddr = extern struct {
    sa_family: u_short,
    sa_data: [14]u8,
};
pub const struct_sockproto = extern struct {
    sp_family: u_short,
    sp_protocol: u_short,
};
pub const struct_linger = extern struct {
    l_onoff: u_short,
    l_linger: u_short,
};
pub extern "ws2_32" fn accept(s: SOCKET, addr: [*c]struct_sockaddr, addrlen: [*c]c_int) callconv(.Stdcall) SOCKET;
pub extern "ws2_32" fn bind(s: SOCKET, addr: [*c]const struct_sockaddr, namelen: c_int) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn closesocket(s: SOCKET) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn connect(s: SOCKET, name: [*c]const struct_sockaddr, namelen: c_int) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn ioctlsocket(s: SOCKET, cmd: c_long, argp: [*c]u_long) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn getpeername(s: SOCKET, name: [*c]struct_sockaddr, namelen: [*c]c_int) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn getsockname(s: SOCKET, name: [*c]struct_sockaddr, namelen: [*c]c_int) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn getsockopt(s: SOCKET, level: c_int, optname: c_int, optval: [*c]u8, optlen: [*c]c_int) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn htonl(hostlong: u_long) callconv(.Stdcall) u_long;
pub extern "ws2_32" fn htons(hostshort: u_short) callconv(.Stdcall) u_short;
pub extern "ws2_32" fn inet_addr(cp: [*c]const u8) callconv(.Stdcall) c_ulong;
pub extern "ws2_32" fn inet_ntoa(in: struct_in_addr) callconv(.Stdcall) [*c]u8;
pub extern "ws2_32" fn listen(s: SOCKET, backlog: c_int) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn ntohl(netlong: u_long) callconv(.Stdcall) u_long;
pub extern "ws2_32" fn ntohs(netshort: u_short) callconv(.Stdcall) u_short;
pub extern "ws2_32" fn recv(s: SOCKET, buf: [*c]u8, len: c_int, flags: c_int) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn recvfrom(s: SOCKET, buf: [*c]u8, len: c_int, flags: c_int, from: [*c]struct_sockaddr, fromlen: [*c]c_int) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn select(nfds: c_int, readfds: [*c]fd_set, writefds: [*c]fd_set, exceptfds: [*c]fd_set, timeout: [*c]const struct_timeval) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn send(s: SOCKET, buf: [*c]const u8, len: c_int, flags: c_int) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn sendto(s: SOCKET, buf: [*c]const u8, len: c_int, flags: c_int, to: [*c]const struct_sockaddr, tolen: c_int) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn setsockopt(s: SOCKET, level: c_int, optname: c_int, optval: [*c]const u8, optlen: c_int) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn shutdown(s: SOCKET, how: c_int) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn socket(af: c_int, type_0: c_int, protocol: c_int) callconv(.Stdcall) SOCKET;
pub extern "ws2_32" fn gethostbyaddr(addr: [*c]const u8, len: c_int, type_0: c_int) callconv(.Stdcall) [*c]struct_hostent;
pub extern "ws2_32" fn gethostbyname(name: [*c]const u8) callconv(.Stdcall) [*c]struct_hostent;
pub extern "ws2_32" fn gethostname(name: [*c]u8, namelen: c_int) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn getservbyport(port: c_int, proto: [*c]const u8) callconv(.Stdcall) [*c]struct_servent;
pub extern "ws2_32" fn getservbyname(name: [*c]const u8, proto: [*c]const u8) callconv(.Stdcall) [*c]struct_servent;
pub extern "ws2_32" fn getprotobynumber(proto: c_int) callconv(.Stdcall) [*c]struct_protoent;
pub extern "ws2_32" fn getprotobyname(name: [*c]const u8) callconv(.Stdcall) [*c]struct_protoent;
pub extern "ws2_32" fn WSAStartup(wVersionRequired: WORD, lpWSAData: LPWSADATA) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn WSACleanup() callconv(.Stdcall) c_int;
pub extern "ws2_32" fn WSASetLastError(iError: c_int) callconv(.Stdcall) void;
pub extern "ws2_32" fn WSAGetLastError() callconv(.Stdcall) c_int;
pub extern "ws2_32" fn WSAIsBlocking() callconv(.Stdcall) BOOL;
pub extern "ws2_32" fn WSAUnhookBlockingHook() callconv(.Stdcall) c_int;
pub extern "ws2_32" fn WSASetBlockingHook(lpBlockFunc: FARPROC) callconv(.Stdcall) FARPROC;
pub extern "ws2_32" fn WSACancelBlockingCall() callconv(.Stdcall) c_int;
pub extern "ws2_32" fn WSAAsyncGetServByName(hWnd: HWND, wMsg: u_int, name: [*c]const u8, proto: [*c]const u8, buf: [*c]u8, buflen: c_int) callconv(.Stdcall) HANDLE;
pub extern "ws2_32" fn WSAAsyncGetServByPort(hWnd: HWND, wMsg: u_int, port: c_int, proto: [*c]const u8, buf: [*c]u8, buflen: c_int) callconv(.Stdcall) HANDLE;
pub extern "ws2_32" fn WSAAsyncGetProtoByName(hWnd: HWND, wMsg: u_int, name: [*c]const u8, buf: [*c]u8, buflen: c_int) callconv(.Stdcall) HANDLE;
pub extern "ws2_32" fn WSAAsyncGetProtoByNumber(hWnd: HWND, wMsg: u_int, number: c_int, buf: [*c]u8, buflen: c_int) callconv(.Stdcall) HANDLE;
pub extern "ws2_32" fn WSAAsyncGetHostByName(hWnd: HWND, wMsg: u_int, name: [*c]const u8, buf: [*c]u8, buflen: c_int) callconv(.Stdcall) HANDLE;
pub extern "ws2_32" fn WSAAsyncGetHostByAddr(hWnd: HWND, wMsg: u_int, addr: [*c]const u8, len: c_int, type_0: c_int, buf: [*c]u8, buflen: c_int) callconv(.Stdcall) HANDLE;
pub extern "ws2_32" fn WSACancelAsyncRequest(hAsyncTaskHandle: HANDLE) callconv(.Stdcall) c_int;
pub extern "ws2_32" fn WSAAsyncSelect(s: SOCKET, hWnd: HWND, wMsg: u_int, lEvent: c_long) callconv(.Stdcall) c_int;
pub extern "mswsock" fn WSARecvEx(s: SOCKET, buf: [*c]u8, len: c_int, flags: [*c]c_int) callconv(.Stdcall) c_int;
pub const struct__TRANSMIT_FILE_BUFFERS = extern struct {
    Head: PVOID,
    HeadLength: DWORD,
    Tail: PVOID,
    TailLength: DWORD,
};
pub const TRANSMIT_FILE_BUFFERS = struct__TRANSMIT_FILE_BUFFERS;
pub const PTRANSMIT_FILE_BUFFERS = [*c]struct__TRANSMIT_FILE_BUFFERS;
pub const LPTRANSMIT_FILE_BUFFERS = [*c]struct__TRANSMIT_FILE_BUFFERS;
pub extern "mswsock" fn TransmitFile(hSocket: SOCKET, hFile: HANDLE, nNumberOfBytesToWrite: DWORD, nNumberOfBytesPerSend: DWORD, lpOverlapped: LPOVERLAPPED, lpTransmitBuffers: LPTRANSMIT_FILE_BUFFERS, dwReserved: DWORD) callconv(.Stdcall) BOOL;
pub extern "mswsock" fn AcceptEx(sListenSocket: SOCKET, sAcceptSocket: SOCKET, lpOutputBuffer: PVOID, dwReceiveDataLength: DWORD, dwLocalAddressLength: DWORD, dwRemoteAddressLength: DWORD, lpdwBytesReceived: LPDWORD, lpOverlapped: LPOVERLAPPED) callconv(.Stdcall) BOOL;
pub extern "mswsock" fn GetAcceptExSockaddrs(lpOutputBuffer: PVOID, dwReceiveDataLength: DWORD, dwLocalAddressLength: DWORD, dwRemoteAddressLength: DWORD, LocalSockaddr: [*c]([*c]struct_sockaddr), LocalSockaddrLength: LPINT, RemoteSockaddr: [*c]([*c]struct_sockaddr), RemoteSockaddrLength: LPINT) callconv(.Stdcall) void;
pub const SOCKADDR = struct_sockaddr;
pub const PSOCKADDR = [*c]struct_sockaddr;
pub const LPSOCKADDR = [*c]struct_sockaddr;
pub const SOCKADDR_IN = struct_sockaddr_in;
pub const PSOCKADDR_IN = [*c]struct_sockaddr_in;
pub const LPSOCKADDR_IN = [*c]struct_sockaddr_in;
pub const LINGER = struct_linger;
pub const PLINGER = [*c]struct_linger;
pub const LPLINGER = [*c]struct_linger;
pub const FD_SET = struct_fd_set;
pub const PFD_SET = [*c]struct_fd_set;
pub const LPFD_SET = [*c]struct_fd_set;
pub const HOSTENT = struct_hostent;
pub const PHOSTENT = [*c]struct_hostent;
pub const LPHOSTENT = [*c]struct_hostent;
pub const SERVENT = struct_servent;
pub const PSERVENT = [*c]struct_servent;
pub const LPSERVENT = [*c]struct_servent;
pub const PROTOENT = struct_protoent;
pub const PPROTOENT = [*c]struct_protoent;
pub const LPPROTOENT = [*c]struct_protoent;
pub const TIMEVAL = struct_timeval;
pub const PTIMEVAL = [*c]struct_timeval;
pub const LPTIMEVAL = [*c]struct_timeval;
pub const ALG_ID = c_uint;
pub const HCRYPTPROV = ULONG_PTR;
pub const HCRYPTKEY = ULONG_PTR;
pub const HCRYPTHASH = ULONG_PTR;
pub const struct__CMS_KEY_INFO = extern struct {
    dwVersion: DWORD,
    Algid: ALG_ID,
    pbOID: [*c]BYTE,
    cbOID: DWORD,
};
pub const CMS_KEY_INFO = struct__CMS_KEY_INFO;
pub const PCMS_KEY_INFO = [*c]struct__CMS_KEY_INFO;
pub const struct__HMAC_Info = extern struct {
    HashAlgid: ALG_ID,
    pbInnerString: [*c]BYTE,
    cbInnerString: DWORD,
    pbOuterString: [*c]BYTE,
    cbOuterString: DWORD,
};
pub const HMAC_INFO = struct__HMAC_Info;
pub const PHMAC_INFO = [*c]struct__HMAC_Info;
pub const struct__SCHANNEL_ALG = extern struct {
    dwUse: DWORD,
    Algid: ALG_ID,
    cBits: DWORD,
    dwFlags: DWORD,
    dwReserved: DWORD,
};
pub const SCHANNEL_ALG = struct__SCHANNEL_ALG;
pub const PSCHANNEL_ALG = [*c]struct__SCHANNEL_ALG;
pub const struct__PROV_ENUMALGS = extern struct {
    aiAlgid: ALG_ID,
    dwBitLen: DWORD,
    dwNameLen: DWORD,
    szName: [20]CHAR,
};
pub const PROV_ENUMALGS = struct__PROV_ENUMALGS;
pub const struct__PROV_ENUMALGS_EX = extern struct {
    aiAlgid: ALG_ID,
    dwDefaultLen: DWORD,
    dwMinLen: DWORD,
    dwMaxLen: DWORD,
    dwProtocols: DWORD,
    dwNameLen: DWORD,
    szName: [20]CHAR,
    dwLongNameLen: DWORD,
    szLongName: [40]CHAR,
};
pub const PROV_ENUMALGS_EX = struct__PROV_ENUMALGS_EX;
pub const struct__PUBLICKEYSTRUC = extern struct {
    bType: BYTE,
    bVersion: BYTE,
    reserved: WORD,
    aiKeyAlg: ALG_ID,
};
pub const BLOBHEADER = struct__PUBLICKEYSTRUC;
pub const PUBLICKEYSTRUC = struct__PUBLICKEYSTRUC;
pub const struct__RSAPUBKEY = extern struct {
    magic: DWORD,
    bitlen: DWORD,
    pubexp: DWORD,
};
pub const RSAPUBKEY = struct__RSAPUBKEY;
pub const struct__PUBKEY = extern struct {
    magic: DWORD,
    bitlen: DWORD,
};
pub const DHPUBKEY = struct__PUBKEY;
pub const DSSPUBKEY = struct__PUBKEY;
pub const KEAPUBKEY = struct__PUBKEY;
pub const TEKPUBKEY = struct__PUBKEY;
pub const struct__DSSSEED = extern struct {
    counter: DWORD,
    seed: [20]BYTE,
};
pub const DSSSEED = struct__DSSSEED;
pub const struct__PUBKEYVER3 = extern struct {
    magic: DWORD,
    bitlenP: DWORD,
    bitlenQ: DWORD,
    bitlenJ: DWORD,
    DSSSeed: DSSSEED,
};
pub const DHPUBKEY_VER3 = struct__PUBKEYVER3;
pub const DSSPUBKEY_VER3 = struct__PUBKEYVER3;
pub const struct__PRIVKEYVER3 = extern struct {
    magic: DWORD,
    bitlenP: DWORD,
    bitlenQ: DWORD,
    bitlenJ: DWORD,
    bitlenX: DWORD,
    DSSSeed: DSSSEED,
};
pub const DHPRIVKEY_VER3 = struct__PRIVKEYVER3;
pub const DSSPRIVKEY_VER3 = struct__PRIVKEYVER3;
pub const struct__KEY_TYPE_SUBTYPE = extern struct {
    dwKeySpec: DWORD,
    Type: GUID,
    Subtype: GUID,
};
pub const KEY_TYPE_SUBTYPE = struct__KEY_TYPE_SUBTYPE;
pub const PKEY_TYPE_SUBTYPE = [*c]struct__KEY_TYPE_SUBTYPE;
pub const struct__CERT_FORTEZZA_DATA_PROP = extern struct {
    SerialNumber: [8]u8,
    CertIndex: c_int,
    CertLabel: [36]u8,
};
pub const CERT_FORTEZZA_DATA_PROP = struct__CERT_FORTEZZA_DATA_PROP;
pub const struct__CRYPT_RC4_KEY_STATE = extern struct {
    Key: [16]u8,
    SBox: [256]u8,
    i: u8,
    j: u8,
};
pub const CRYPT_RC4_KEY_STATE = struct__CRYPT_RC4_KEY_STATE;
pub const PCRYPT_RC4_KEY_STATE = [*c]struct__CRYPT_RC4_KEY_STATE;
pub const struct__CRYPT_DES_KEY_STATE = extern struct {
    Key: [8]u8,
    IV: [8]u8,
    Feedback: [8]u8,
};
pub const CRYPT_DES_KEY_STATE = struct__CRYPT_DES_KEY_STATE;
pub const PCRYPT_DES_KEY_STATE = [*c]struct__CRYPT_DES_KEY_STATE;
pub const struct__CRYPT_3DES_KEY_STATE = extern struct {
    Key: [24]u8,
    IV: [8]u8,
    Feedback: [8]u8,
};
pub const CRYPT_3DES_KEY_STATE = struct__CRYPT_3DES_KEY_STATE;
pub const PCRYPT_3DES_KEY_STATE = [*c]struct__CRYPT_3DES_KEY_STATE;
pub const struct__CRYPT_AES_128_KEY_STATE = extern struct {
    Key: [16]u8,
    IV: [16]u8,
    EncryptionState: [11][16]u8,
    DecryptionState: [11][16]u8,
    Feedback: [16]u8,
};
pub const CRYPT_AES_128_KEY_STATE = struct__CRYPT_AES_128_KEY_STATE;
pub const PCRYPT_AES_128_KEY_STATE = [*c]struct__CRYPT_AES_128_KEY_STATE;
pub const struct__CRYPT_AES_256_KEY_STATE = extern struct {
    Key: [32]u8,
    IV: [16]u8,
    EncryptionState: [15][16]u8,
    DecryptionState: [15][16]u8,
    Feedback: [16]u8,
};
pub const CRYPT_AES_256_KEY_STATE = struct__CRYPT_AES_256_KEY_STATE;
pub const PCRYPT_AES_256_KEY_STATE = [*c]struct__CRYPT_AES_256_KEY_STATE;
pub const struct__CRYPTOAPI_BLOB = extern struct {
    cbData: DWORD,
    pbData: [*c]BYTE,
};
pub const CRYPT_INTEGER_BLOB = struct__CRYPTOAPI_BLOB;
pub const PCRYPT_INTEGER_BLOB = [*c]struct__CRYPTOAPI_BLOB;
pub const CRYPT_UINT_BLOB = struct__CRYPTOAPI_BLOB;
pub const PCRYPT_UINT_BLOB = [*c]struct__CRYPTOAPI_BLOB;
pub const CRYPT_OBJID_BLOB = struct__CRYPTOAPI_BLOB;
pub const PCRYPT_OBJID_BLOB = [*c]struct__CRYPTOAPI_BLOB;
pub const CERT_NAME_BLOB = struct__CRYPTOAPI_BLOB;
pub const PCERT_NAME_BLOB = [*c]struct__CRYPTOAPI_BLOB;
pub const CERT_RDN_VALUE_BLOB = struct__CRYPTOAPI_BLOB;
pub const PCERT_RDN_VALUE_BLOB = [*c]struct__CRYPTOAPI_BLOB;
pub const CERT_BLOB = struct__CRYPTOAPI_BLOB;
pub const PCERT_BLOB = [*c]struct__CRYPTOAPI_BLOB;
pub const CRL_BLOB = struct__CRYPTOAPI_BLOB;
pub const PCRL_BLOB = [*c]struct__CRYPTOAPI_BLOB;
pub const DATA_BLOB = struct__CRYPTOAPI_BLOB;
pub const PDATA_BLOB = [*c]struct__CRYPTOAPI_BLOB;
pub const CRYPT_DATA_BLOB = struct__CRYPTOAPI_BLOB;
pub const PCRYPT_DATA_BLOB = [*c]struct__CRYPTOAPI_BLOB;
pub const CRYPT_HASH_BLOB = struct__CRYPTOAPI_BLOB;
pub const PCRYPT_HASH_BLOB = [*c]struct__CRYPTOAPI_BLOB;
pub const CRYPT_DIGEST_BLOB = struct__CRYPTOAPI_BLOB;
pub const PCRYPT_DIGEST_BLOB = [*c]struct__CRYPTOAPI_BLOB;
pub const CRYPT_DER_BLOB = struct__CRYPTOAPI_BLOB;
pub const PCRYPT_DER_BLOB = [*c]struct__CRYPTOAPI_BLOB;
pub const CRYPT_ATTR_BLOB = struct__CRYPTOAPI_BLOB;
pub const PCRYPT_ATTR_BLOB = [*c]struct__CRYPTOAPI_BLOB;
pub const struct__CMS_DH_KEY_INFO = extern struct {
    dwVersion: DWORD,
    Algid: ALG_ID,
    pszContentEncObjId: LPSTR,
    PubInfo: CRYPT_DATA_BLOB,
    pReserved: ?*c_void,
};
pub const CMS_DH_KEY_INFO = struct__CMS_DH_KEY_INFO;
pub const PCMS_DH_KEY_INFO = [*c]struct__CMS_DH_KEY_INFO;
pub extern "advapi32" fn CryptAcquireContextA(phProv: [*c]HCRYPTPROV, szContainer: LPCSTR, szProvider: LPCSTR, dwProvType: DWORD, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptAcquireContextW(phProv: [*c]HCRYPTPROV, szContainer: LPCWSTR, szProvider: LPCWSTR, dwProvType: DWORD, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptReleaseContext(hProv: HCRYPTPROV, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptGenKey(hProv: HCRYPTPROV, Algid: ALG_ID, dwFlags: DWORD, phKey: [*c]HCRYPTKEY) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptDeriveKey(hProv: HCRYPTPROV, Algid: ALG_ID, hBaseData: HCRYPTHASH, dwFlags: DWORD, phKey: [*c]HCRYPTKEY) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptDestroyKey(hKey: HCRYPTKEY) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptSetKeyParam(hKey: HCRYPTKEY, dwParam: DWORD, pbData: [*c]const BYTE, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptGetKeyParam(hKey: HCRYPTKEY, dwParam: DWORD, pbData: [*c]BYTE, pdwDataLen: [*c]DWORD, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptSetHashParam(hHash: HCRYPTHASH, dwParam: DWORD, pbData: [*c]const BYTE, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptGetHashParam(hHash: HCRYPTHASH, dwParam: DWORD, pbData: [*c]BYTE, pdwDataLen: [*c]DWORD, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptSetProvParam(hProv: HCRYPTPROV, dwParam: DWORD, pbData: [*c]const BYTE, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptGetProvParam(hProv: HCRYPTPROV, dwParam: DWORD, pbData: [*c]BYTE, pdwDataLen: [*c]DWORD, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptGenRandom(hProv: HCRYPTPROV, dwLen: DWORD, pbBuffer: [*c]BYTE) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptGetUserKey(hProv: HCRYPTPROV, dwKeySpec: DWORD, phUserKey: [*c]HCRYPTKEY) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptExportKey(hKey: HCRYPTKEY, hExpKey: HCRYPTKEY, dwBlobType: DWORD, dwFlags: DWORD, pbData: [*c]BYTE, pdwDataLen: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptImportKey(hProv: HCRYPTPROV, pbData: [*c]const BYTE, dwDataLen: DWORD, hPubKey: HCRYPTKEY, dwFlags: DWORD, phKey: [*c]HCRYPTKEY) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptEncrypt(hKey: HCRYPTKEY, hHash: HCRYPTHASH, Final: BOOL, dwFlags: DWORD, pbData: [*c]BYTE, pdwDataLen: [*c]DWORD, dwBufLen: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptDecrypt(hKey: HCRYPTKEY, hHash: HCRYPTHASH, Final: BOOL, dwFlags: DWORD, pbData: [*c]BYTE, pdwDataLen: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptCreateHash(hProv: HCRYPTPROV, Algid: ALG_ID, hKey: HCRYPTKEY, dwFlags: DWORD, phHash: [*c]HCRYPTHASH) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptHashData(hHash: HCRYPTHASH, pbData: [*c]const BYTE, dwDataLen: DWORD, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptHashSessionKey(hHash: HCRYPTHASH, hKey: HCRYPTKEY, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptDestroyHash(hHash: HCRYPTHASH) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptSignHashA(hHash: HCRYPTHASH, dwKeySpec: DWORD, szDescription: LPCSTR, dwFlags: DWORD, pbSignature: [*c]BYTE, pdwSigLen: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptSignHashW(hHash: HCRYPTHASH, dwKeySpec: DWORD, szDescription: LPCWSTR, dwFlags: DWORD, pbSignature: [*c]BYTE, pdwSigLen: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptVerifySignatureA(hHash: HCRYPTHASH, pbSignature: [*c]const BYTE, dwSigLen: DWORD, hPubKey: HCRYPTKEY, szDescription: LPCSTR, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptVerifySignatureW(hHash: HCRYPTHASH, pbSignature: [*c]const BYTE, dwSigLen: DWORD, hPubKey: HCRYPTKEY, szDescription: LPCWSTR, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptSetProviderA(pszProvName: LPCSTR, dwProvType: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptSetProviderW(pszProvName: LPCWSTR, dwProvType: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptSetProviderExA(pszProvName: LPCSTR, dwProvType: DWORD, pdwReserved: [*c]DWORD, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptSetProviderExW(pszProvName: LPCWSTR, dwProvType: DWORD, pdwReserved: [*c]DWORD, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptGetDefaultProviderA(dwProvType: DWORD, pdwReserved: [*c]DWORD, dwFlags: DWORD, pszProvName: LPSTR, pcbProvName: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptGetDefaultProviderW(dwProvType: DWORD, pdwReserved: [*c]DWORD, dwFlags: DWORD, pszProvName: LPWSTR, pcbProvName: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptEnumProviderTypesA(dwIndex: DWORD, pdwReserved: [*c]DWORD, dwFlags: DWORD, pdwProvType: [*c]DWORD, szTypeName: LPSTR, pcbTypeName: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptEnumProviderTypesW(dwIndex: DWORD, pdwReserved: [*c]DWORD, dwFlags: DWORD, pdwProvType: [*c]DWORD, szTypeName: LPWSTR, pcbTypeName: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptEnumProvidersA(dwIndex: DWORD, pdwReserved: [*c]DWORD, dwFlags: DWORD, pdwProvType: [*c]DWORD, szProvName: LPSTR, pcbProvName: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptEnumProvidersW(dwIndex: DWORD, pdwReserved: [*c]DWORD, dwFlags: DWORD, pdwProvType: [*c]DWORD, szProvName: LPWSTR, pcbProvName: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptContextAddRef(hProv: HCRYPTPROV, pdwReserved: [*c]DWORD, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptDuplicateKey(hKey: HCRYPTKEY, pdwReserved: [*c]DWORD, dwFlags: DWORD, phKey: [*c]HCRYPTKEY) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CryptDuplicateHash(hHash: HCRYPTHASH, pdwReserved: [*c]DWORD, dwFlags: DWORD, phHash: [*c]HCRYPTHASH) callconv(.Stdcall) BOOL;
pub const NTSTATUS = LONG;
pub const PNTSTATUS = [*c]NTSTATUS;
pub const struct___BCRYPT_KEY_LENGTHS_STRUCT = extern struct {
    dwMinLength: ULONG,
    dwMaxLength: ULONG,
    dwIncrement: ULONG,
};
pub const BCRYPT_KEY_LENGTHS_STRUCT = struct___BCRYPT_KEY_LENGTHS_STRUCT;
pub const BCRYPT_AUTH_TAG_LENGTHS_STRUCT = BCRYPT_KEY_LENGTHS_STRUCT;
pub const struct__BCRYPT_OID = extern struct {
    cbOID: ULONG,
    pbOID: PUCHAR,
};
pub const BCRYPT_OID = struct__BCRYPT_OID;
pub const struct__BCRYPT_OID_LIST = extern struct {
    dwOIDCount: ULONG,
    pOIDs: [*c]BCRYPT_OID,
};
pub const BCRYPT_OID_LIST = struct__BCRYPT_OID_LIST;
pub const struct__BCRYPT_PKCS1_PADDING_INFO = extern struct {
    pszAlgId: LPCWSTR,
};
pub const BCRYPT_PKCS1_PADDING_INFO = struct__BCRYPT_PKCS1_PADDING_INFO;
pub const struct__BCRYPT_PSS_PADDING_INFO = extern struct {
    pszAlgId: LPCWSTR,
    cbSalt: ULONG,
};
pub const BCRYPT_PSS_PADDING_INFO = struct__BCRYPT_PSS_PADDING_INFO;
pub const struct__BCRYPT_OAEP_PADDING_INFO = extern struct {
    pszAlgId: LPCWSTR,
    pbLabel: PUCHAR,
    cbLabel: ULONG,
};
pub const BCRYPT_OAEP_PADDING_INFO = struct__BCRYPT_OAEP_PADDING_INFO;
pub const struct__BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO = extern struct {
    cbSize: ULONG,
    dwInfoVersion: ULONG,
    pbNonce: PUCHAR,
    cbNonce: ULONG,
    pbAuthData: PUCHAR,
    cbAuthData: ULONG,
    pbTag: PUCHAR,
    cbTag: ULONG,
    pbMacContext: PUCHAR,
    cbMacContext: ULONG,
    cbAAD: ULONG,
    cbData: ULONGLONG,
    dwFlags: ULONG,
};
pub const BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO = struct__BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO;
pub const PBCRYPT_AUTHENTICATED_CIPHER_MODE_INFO = [*c]struct__BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO;
pub const struct__BCryptBuffer = extern struct {
    cbBuffer: ULONG,
    BufferType: ULONG,
    pvBuffer: PVOID,
};
pub const BCryptBuffer = struct__BCryptBuffer;
pub const PBCryptBuffer = [*c]struct__BCryptBuffer;
pub const struct__BCryptBufferDesc = extern struct {
    ulVersion: ULONG,
    cBuffers: ULONG,
    pBuffers: PBCryptBuffer,
};
pub const BCryptBufferDesc = struct__BCryptBufferDesc;
pub const PBCryptBufferDesc = [*c]struct__BCryptBufferDesc;
pub const BCRYPT_HANDLE = PVOID;
pub const BCRYPT_ALG_HANDLE = PVOID;
pub const BCRYPT_KEY_HANDLE = PVOID;
pub const BCRYPT_HASH_HANDLE = PVOID;
pub const BCRYPT_SECRET_HANDLE = PVOID;
pub const struct__BCRYPT_KEY_BLOB = extern struct {
    Magic: ULONG,
};
pub const BCRYPT_KEY_BLOB = struct__BCRYPT_KEY_BLOB;
pub const struct__BCRYPT_RSAKEY_BLOB = extern struct {
    Magic: ULONG,
    BitLength: ULONG,
    cbPublicExp: ULONG,
    cbModulus: ULONG,
    cbPrime1: ULONG,
    cbPrime2: ULONG,
};
pub const BCRYPT_RSAKEY_BLOB = struct__BCRYPT_RSAKEY_BLOB;
pub const struct__BCRYPT_ECCKEY_BLOB = extern struct {
    dwMagic: ULONG,
    cbKey: ULONG,
};
pub const BCRYPT_ECCKEY_BLOB = struct__BCRYPT_ECCKEY_BLOB;
pub const PBCRYPT_ECCKEY_BLOB = [*c]struct__BCRYPT_ECCKEY_BLOB;
pub const struct__SSL_ECCKEY_BLOB = extern struct {
    dwCurveType: ULONG,
    cbKey: ULONG,
};
pub const SSL_ECCKEY_BLOB = struct__SSL_ECCKEY_BLOB;
pub const PSSL_ECCKEY_BLOB = [*c]struct__SSL_ECCKEY_BLOB;
pub const BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE = 1;
pub const BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE = 2;
pub const BCRYPT_ECC_PRIME_MONTGOMERY_CURVE = 3;
pub const ECC_CURVE_TYPE_ENUM = extern enum {
    BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE = 1,
    BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE = 2,
    BCRYPT_ECC_PRIME_MONTGOMERY_CURVE = 3,
};
pub const BCRYPT_NO_CURVE_GENERATION_ALG_ID = 0;
pub const ECC_CURVE_ALG_ID_ENUM = extern enum {
    BCRYPT_NO_CURVE_GENERATION_ALG_ID = 0,
};
pub const struct__BCRYPT_ECCFULLKEY_BLOB = extern struct {
    dwMagic: ULONG,
    dwVersion: ULONG,
    dwCurveType: ECC_CURVE_TYPE_ENUM,
    dwCurveGenerationAlgId: ECC_CURVE_ALG_ID_ENUM,
    cbFieldLength: ULONG,
    cbSubgroupOrder: ULONG,
    cbCofactor: ULONG,
    cbSeed: ULONG,
};
pub const BCRYPT_ECCFULLKEY_BLOB = struct__BCRYPT_ECCFULLKEY_BLOB;
pub const PBCRYPT_ECCFULLKEY_BLOB = [*c]struct__BCRYPT_ECCFULLKEY_BLOB;
pub const struct__BCRYPT_DH_KEY_BLOB = extern struct {
    dwMagic: ULONG,
    cbKey: ULONG,
};
pub const BCRYPT_DH_KEY_BLOB = struct__BCRYPT_DH_KEY_BLOB;
pub const PBCRYPT_DH_KEY_BLOB = [*c]struct__BCRYPT_DH_KEY_BLOB;
pub const struct__BCRYPT_DH_PARAMETER_HEADER = extern struct {
    cbLength: ULONG,
    dwMagic: ULONG,
    cbKeyLength: ULONG,
};
pub const BCRYPT_DH_PARAMETER_HEADER = struct__BCRYPT_DH_PARAMETER_HEADER;
pub const struct__BCRYPT_DSA_KEY_BLOB = extern struct {
    dwMagic: ULONG,
    cbKey: ULONG,
    Count: [4]UCHAR,
    Seed: [20]UCHAR,
    q: [20]UCHAR,
};
pub const BCRYPT_DSA_KEY_BLOB = struct__BCRYPT_DSA_KEY_BLOB;
pub const PBCRYPT_DSA_KEY_BLOB = [*c]struct__BCRYPT_DSA_KEY_BLOB;
pub const DSA_HASH_ALGORITHM_SHA1 = 0;
pub const DSA_HASH_ALGORITHM_SHA256 = 1;
pub const DSA_HASH_ALGORITHM_SHA512 = 2;
pub const HASHALGORITHM_ENUM = extern enum {
    DSA_HASH_ALGORITHM_SHA1 = 0,
    DSA_HASH_ALGORITHM_SHA256 = 1,
    DSA_HASH_ALGORITHM_SHA512 = 2,
};
pub const DSA_FIPS186_2 = 0;
pub const DSA_FIPS186_3 = 1;
pub const DSAFIPSVERSION_ENUM = extern enum {
    DSA_FIPS186_2 = 0,
    DSA_FIPS186_3 = 1,
};
pub const struct__BCRYPT_DSA_KEY_BLOB_V2 = extern struct {
    dwMagic: ULONG,
    cbKey: ULONG,
    hashAlgorithm: HASHALGORITHM_ENUM,
    standardVersion: DSAFIPSVERSION_ENUM,
    cbSeedLength: ULONG,
    cbGroupSize: ULONG,
    Count: [4]UCHAR,
};
pub const BCRYPT_DSA_KEY_BLOB_V2 = struct__BCRYPT_DSA_KEY_BLOB_V2;
pub const PBCRYPT_DSA_KEY_BLOB_V2 = [*c]struct__BCRYPT_DSA_KEY_BLOB_V2;
pub const struct__BCRYPT_KEY_DATA_BLOB_HEADER = extern struct {
    dwMagic: ULONG,
    dwVersion: ULONG,
    cbKeyData: ULONG,
};
pub const BCRYPT_KEY_DATA_BLOB_HEADER = struct__BCRYPT_KEY_DATA_BLOB_HEADER;
pub const PBCRYPT_KEY_DATA_BLOB_HEADER = [*c]struct__BCRYPT_KEY_DATA_BLOB_HEADER;
pub const struct__BCRYPT_DSA_PARAMETER_HEADER = extern struct {
    cbLength: ULONG,
    dwMagic: ULONG,
    cbKeyLength: ULONG,
    Count: [4]UCHAR,
    Seed: [20]UCHAR,
    q: [20]UCHAR,
};
pub const BCRYPT_DSA_PARAMETER_HEADER = struct__BCRYPT_DSA_PARAMETER_HEADER;
pub const struct__BCRYPT_DSA_PARAMETER_HEADER_V2 = extern struct {
    cbLength: ULONG,
    dwMagic: ULONG,
    cbKeyLength: ULONG,
    hashAlgorithm: HASHALGORITHM_ENUM,
    standardVersion: DSAFIPSVERSION_ENUM,
    cbSeedLength: ULONG,
    cbGroupSize: ULONG,
    Count: [4]UCHAR,
};
pub const BCRYPT_DSA_PARAMETER_HEADER_V2 = struct__BCRYPT_DSA_PARAMETER_HEADER_V2;
pub const struct__BCRYPT_ECC_CURVE_NAMES = extern struct {
    dwEccCurveNames: ULONG,
    pEccCurveNames: [*c]LPWSTR,
};
pub const BCRYPT_ECC_CURVE_NAMES = struct__BCRYPT_ECC_CURVE_NAMES;
pub const BCRYPT_HASH_OPERATION_HASH_DATA = 1;
pub const BCRYPT_HASH_OPERATION_FINISH_HASH = 2;
pub const BCRYPT_HASH_OPERATION_TYPE = extern enum {
    BCRYPT_HASH_OPERATION_HASH_DATA = 1,
    BCRYPT_HASH_OPERATION_FINISH_HASH = 2,
};
pub const struct__BCRYPT_MULTI_HASH_OPERATION = extern struct {
    iHash: ULONG,
    hashOperation: BCRYPT_HASH_OPERATION_TYPE,
    pbBuffer: PUCHAR,
    cbBuffer: ULONG,
};
pub const BCRYPT_MULTI_HASH_OPERATION = struct__BCRYPT_MULTI_HASH_OPERATION;
pub const BCRYPT_OPERATION_TYPE_HASH = 1;
pub const BCRYPT_MULTI_OPERATION_TYPE = extern enum {
    BCRYPT_OPERATION_TYPE_HASH = 1,
};
pub const struct__BCRYPT_MULTI_OBJECT_LENGTH_STRUCT = extern struct {
    cbPerObject: ULONG,
    cbPerElement: ULONG,
};
pub const BCRYPT_MULTI_OBJECT_LENGTH_STRUCT = struct__BCRYPT_MULTI_OBJECT_LENGTH_STRUCT;
pub extern "bcrypt" fn BCryptOpenAlgorithmProvider(phAlgorithm: [*c]BCRYPT_ALG_HANDLE, pszAlgId: LPCWSTR, pszImplementation: LPCWSTR, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub const struct__BCRYPT_ALGORITHM_IDENTIFIER = extern struct {
    pszName: LPWSTR,
    dwClass: ULONG,
    dwFlags: ULONG,
};
pub const BCRYPT_ALGORITHM_IDENTIFIER = struct__BCRYPT_ALGORITHM_IDENTIFIER;
pub extern "bcrypt" fn BCryptEnumAlgorithms(dwAlgOperations: ULONG, pAlgCount: [*c]ULONG, ppAlgList: [*c]([*c]BCRYPT_ALGORITHM_IDENTIFIER), dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub const struct__BCRYPT_PROVIDER_NAME = extern struct {
    pszProviderName: LPWSTR,
};
pub const BCRYPT_PROVIDER_NAME = struct__BCRYPT_PROVIDER_NAME;
pub extern "bcrypt" fn BCryptEnumProviders(pszAlgId: LPCWSTR, pImplCount: [*c]ULONG, ppImplList: [*c]([*c]BCRYPT_PROVIDER_NAME), dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptGetProperty(hObject: BCRYPT_HANDLE, pszProperty: LPCWSTR, pbOutput: PUCHAR, cbOutput: ULONG, pcbResult: [*c]ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptSetProperty(hObject: BCRYPT_HANDLE, pszProperty: LPCWSTR, pbInput: PUCHAR, cbInput: ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptCloseAlgorithmProvider(hAlgorithm: BCRYPT_ALG_HANDLE, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptFreeBuffer(pvBuffer: PVOID) callconv(.Stdcall) void;
pub extern "bcrypt" fn BCryptGenerateSymmetricKey(hAlgorithm: BCRYPT_ALG_HANDLE, phKey: [*c]BCRYPT_KEY_HANDLE, pbKeyObject: PUCHAR, cbKeyObject: ULONG, pbSecret: PUCHAR, cbSecret: ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptGenerateKeyPair(hAlgorithm: BCRYPT_ALG_HANDLE, phKey: [*c]BCRYPT_KEY_HANDLE, dwLength: ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptEncrypt(hKey: BCRYPT_KEY_HANDLE, pbInput: PUCHAR, cbInput: ULONG, pPaddingInfo: ?*c_void, pbIV: PUCHAR, cbIV: ULONG, pbOutput: PUCHAR, cbOutput: ULONG, pcbResult: [*c]ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptDecrypt(hKey: BCRYPT_KEY_HANDLE, pbInput: PUCHAR, cbInput: ULONG, pPaddingInfo: ?*c_void, pbIV: PUCHAR, cbIV: ULONG, pbOutput: PUCHAR, cbOutput: ULONG, pcbResult: [*c]ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptExportKey(hKey: BCRYPT_KEY_HANDLE, hExportKey: BCRYPT_KEY_HANDLE, pszBlobType: LPCWSTR, pbOutput: PUCHAR, cbOutput: ULONG, pcbResult: [*c]ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptImportKey(hAlgorithm: BCRYPT_ALG_HANDLE, hImportKey: BCRYPT_KEY_HANDLE, pszBlobType: LPCWSTR, phKey: [*c]BCRYPT_KEY_HANDLE, pbKeyObject: PUCHAR, cbKeyObject: ULONG, pbInput: PUCHAR, cbInput: ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptImportKeyPair(hAlgorithm: BCRYPT_ALG_HANDLE, hImportKey: BCRYPT_KEY_HANDLE, pszBlobType: LPCWSTR, phKey: [*c]BCRYPT_KEY_HANDLE, pbInput: PUCHAR, cbInput: ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptDuplicateKey(hKey: BCRYPT_KEY_HANDLE, phNewKey: [*c]BCRYPT_KEY_HANDLE, pbKeyObject: PUCHAR, cbKeyObject: ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptFinalizeKeyPair(hKey: BCRYPT_KEY_HANDLE, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptDestroyKey(hKey: BCRYPT_KEY_HANDLE) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptDestroySecret(hSecret: BCRYPT_SECRET_HANDLE) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptSignHash(hKey: BCRYPT_KEY_HANDLE, pPaddingInfo: ?*c_void, pbInput: PUCHAR, cbInput: ULONG, pbOutput: PUCHAR, cbOutput: ULONG, pcbResult: [*c]ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptVerifySignature(hKey: BCRYPT_KEY_HANDLE, pPaddingInfo: ?*c_void, pbHash: PUCHAR, cbHash: ULONG, pbSignature: PUCHAR, cbSignature: ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptSecretAgreement(hPrivKey: BCRYPT_KEY_HANDLE, hPubKey: BCRYPT_KEY_HANDLE, phAgreedSecret: [*c]BCRYPT_SECRET_HANDLE, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptDeriveKey(hSharedSecret: BCRYPT_SECRET_HANDLE, pwszKDF: LPCWSTR, pParameterList: [*c]BCryptBufferDesc, pbDerivedKey: PUCHAR, cbDerivedKey: ULONG, pcbResult: [*c]ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptKeyDerivation(hKey: BCRYPT_KEY_HANDLE, pParameterList: [*c]BCryptBufferDesc, pbDerivedKey: PUCHAR, cbDerivedKey: ULONG, pcbResult: [*c]ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptCreateHash(hAlgorithm: BCRYPT_ALG_HANDLE, phHash: [*c]BCRYPT_HASH_HANDLE, pbHashObject: PUCHAR, cbHashObject: ULONG, pbSecret: PUCHAR, cbSecret: ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptHashData(hHash: BCRYPT_HASH_HANDLE, pbInput: PUCHAR, cbInput: ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptFinishHash(hHash: BCRYPT_HASH_HANDLE, pbOutput: PUCHAR, cbOutput: ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptCreateMultiHash(hAlgorithm: BCRYPT_ALG_HANDLE, phHash: [*c]BCRYPT_HASH_HANDLE, nHashes: ULONG, pbHashObject: PUCHAR, cbHashObject: ULONG, pbSecret: PUCHAR, cbSecret: ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptProcessMultiOperations(hObject: BCRYPT_HANDLE, operationType: BCRYPT_MULTI_OPERATION_TYPE, pOperations: PVOID, cbOperations: ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptDuplicateHash(hHash: BCRYPT_HASH_HANDLE, phNewHash: [*c]BCRYPT_HASH_HANDLE, pbHashObject: PUCHAR, cbHashObject: ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptDestroyHash(hHash: BCRYPT_HASH_HANDLE) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptHash(hAlgorithm: BCRYPT_ALG_HANDLE, pbSecret: PUCHAR, cbSecret: ULONG, pbInput: PUCHAR, cbInput: ULONG, pbOutput: PUCHAR, cbOutput: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptGenRandom(hAlgorithm: BCRYPT_ALG_HANDLE, pbBuffer: PUCHAR, cbBuffer: ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptDeriveKeyCapi(hHash: BCRYPT_HASH_HANDLE, hTargetAlg: BCRYPT_ALG_HANDLE, pbDerivedKey: PUCHAR, cbDerivedKey: ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptDeriveKeyPBKDF2(hPrf: BCRYPT_ALG_HANDLE, pbPassword: PUCHAR, cbPassword: ULONG, pbSalt: PUCHAR, cbSalt: ULONG, cIterations: ULONGLONG, pbDerivedKey: PUCHAR, cbDerivedKey: ULONG, dwFlags: ULONG) callconv(.Stdcall) NTSTATUS;
pub const struct__BCRYPT_INTERFACE_VERSION = extern struct {
    MajorVersion: USHORT,
    MinorVersion: USHORT,
};
pub const BCRYPT_INTERFACE_VERSION = struct__BCRYPT_INTERFACE_VERSION;
pub const PBCRYPT_INTERFACE_VERSION = [*c]struct__BCRYPT_INTERFACE_VERSION;
pub const struct__CRYPT_INTERFACE_REG = extern struct {
    dwInterface: ULONG,
    dwFlags: ULONG,
    cFunctions: ULONG,
    rgpszFunctions: [*c]PWSTR,
};
pub const CRYPT_INTERFACE_REG = struct__CRYPT_INTERFACE_REG;
pub const PCRYPT_INTERFACE_REG = [*c]struct__CRYPT_INTERFACE_REG;
pub const struct__CRYPT_IMAGE_REG = extern struct {
    pszImage: PWSTR,
    cInterfaces: ULONG,
    rgpInterfaces: [*c]PCRYPT_INTERFACE_REG,
};
pub const CRYPT_IMAGE_REG = struct__CRYPT_IMAGE_REG;
pub const PCRYPT_IMAGE_REG = [*c]struct__CRYPT_IMAGE_REG;
pub const struct__CRYPT_PROVIDER_REG = extern struct {
    cAliases: ULONG,
    rgpszAliases: [*c]PWSTR,
    pUM: PCRYPT_IMAGE_REG,
    pKM: PCRYPT_IMAGE_REG,
};
pub const CRYPT_PROVIDER_REG = struct__CRYPT_PROVIDER_REG;
pub const PCRYPT_PROVIDER_REG = [*c]struct__CRYPT_PROVIDER_REG;
pub const struct__CRYPT_PROVIDERS = extern struct {
    cProviders: ULONG,
    rgpszProviders: [*c]PWSTR,
};
pub const CRYPT_PROVIDERS = struct__CRYPT_PROVIDERS;
pub const PCRYPT_PROVIDERS = [*c]struct__CRYPT_PROVIDERS;
pub const struct__CRYPT_CONTEXT_CONFIG = extern struct {
    dwFlags: ULONG,
    dwReserved: ULONG,
};
pub const CRYPT_CONTEXT_CONFIG = struct__CRYPT_CONTEXT_CONFIG;
pub const PCRYPT_CONTEXT_CONFIG = [*c]struct__CRYPT_CONTEXT_CONFIG;
pub const struct__CRYPT_CONTEXT_FUNCTION_CONFIG = extern struct {
    dwFlags: ULONG,
    dwReserved: ULONG,
};
pub const CRYPT_CONTEXT_FUNCTION_CONFIG = struct__CRYPT_CONTEXT_FUNCTION_CONFIG;
pub const PCRYPT_CONTEXT_FUNCTION_CONFIG = [*c]struct__CRYPT_CONTEXT_FUNCTION_CONFIG;
pub const struct__CRYPT_CONTEXTS = extern struct {
    cContexts: ULONG,
    rgpszContexts: [*c]PWSTR,
};
pub const CRYPT_CONTEXTS = struct__CRYPT_CONTEXTS;
pub const PCRYPT_CONTEXTS = [*c]struct__CRYPT_CONTEXTS;
pub const struct__CRYPT_CONTEXT_FUNCTIONS = extern struct {
    cFunctions: ULONG,
    rgpszFunctions: [*c]PWSTR,
};
pub const CRYPT_CONTEXT_FUNCTIONS = struct__CRYPT_CONTEXT_FUNCTIONS;
pub const PCRYPT_CONTEXT_FUNCTIONS = [*c]struct__CRYPT_CONTEXT_FUNCTIONS;
pub const struct__CRYPT_CONTEXT_FUNCTION_PROVIDERS = extern struct {
    cProviders: ULONG,
    rgpszProviders: [*c]PWSTR,
};
pub const CRYPT_CONTEXT_FUNCTION_PROVIDERS = struct__CRYPT_CONTEXT_FUNCTION_PROVIDERS;
pub const PCRYPT_CONTEXT_FUNCTION_PROVIDERS = [*c]struct__CRYPT_CONTEXT_FUNCTION_PROVIDERS;
pub const struct__CRYPT_PROPERTY_REF = extern struct {
    pszProperty: PWSTR,
    cbValue: ULONG,
    pbValue: PUCHAR,
};
pub const CRYPT_PROPERTY_REF = struct__CRYPT_PROPERTY_REF;
pub const PCRYPT_PROPERTY_REF = [*c]struct__CRYPT_PROPERTY_REF;
pub const struct__CRYPT_IMAGE_REF = extern struct {
    pszImage: PWSTR,
    dwFlags: ULONG,
};
pub const CRYPT_IMAGE_REF = struct__CRYPT_IMAGE_REF;
pub const PCRYPT_IMAGE_REF = [*c]struct__CRYPT_IMAGE_REF;
pub const struct__CRYPT_PROVIDER_REF = extern struct {
    dwInterface: ULONG,
    pszFunction: PWSTR,
    pszProvider: PWSTR,
    cProperties: ULONG,
    rgpProperties: [*c]PCRYPT_PROPERTY_REF,
    pUM: PCRYPT_IMAGE_REF,
    pKM: PCRYPT_IMAGE_REF,
};
pub const CRYPT_PROVIDER_REF = struct__CRYPT_PROVIDER_REF;
pub const PCRYPT_PROVIDER_REF = [*c]struct__CRYPT_PROVIDER_REF;
pub const struct__CRYPT_PROVIDER_REFS = extern struct {
    cProviders: ULONG,
    rgpProviders: [*c]PCRYPT_PROVIDER_REF,
};
pub const CRYPT_PROVIDER_REFS = struct__CRYPT_PROVIDER_REFS;
pub const PCRYPT_PROVIDER_REFS = [*c]struct__CRYPT_PROVIDER_REFS;
pub extern "bcrypt" fn BCryptQueryProviderRegistration(pszProvider: LPCWSTR, dwMode: ULONG, dwInterface: ULONG, pcbBuffer: [*c]ULONG, ppBuffer: [*c]PCRYPT_PROVIDER_REG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptEnumRegisteredProviders(pcbBuffer: [*c]ULONG, ppBuffer: [*c]PCRYPT_PROVIDERS) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptCreateContext(dwTable: ULONG, pszContext: LPCWSTR, pConfig: PCRYPT_CONTEXT_CONFIG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptDeleteContext(dwTable: ULONG, pszContext: LPCWSTR) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptEnumContexts(dwTable: ULONG, pcbBuffer: [*c]ULONG, ppBuffer: [*c]PCRYPT_CONTEXTS) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptConfigureContext(dwTable: ULONG, pszContext: LPCWSTR, pConfig: PCRYPT_CONTEXT_CONFIG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptQueryContextConfiguration(dwTable: ULONG, pszContext: LPCWSTR, pcbBuffer: [*c]ULONG, ppBuffer: [*c]PCRYPT_CONTEXT_CONFIG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptAddContextFunction(dwTable: ULONG, pszContext: LPCWSTR, dwInterface: ULONG, pszFunction: LPCWSTR, dwPosition: ULONG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptRemoveContextFunction(dwTable: ULONG, pszContext: LPCWSTR, dwInterface: ULONG, pszFunction: LPCWSTR) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptEnumContextFunctions(dwTable: ULONG, pszContext: LPCWSTR, dwInterface: ULONG, pcbBuffer: [*c]ULONG, ppBuffer: [*c]PCRYPT_CONTEXT_FUNCTIONS) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptConfigureContextFunction(dwTable: ULONG, pszContext: LPCWSTR, dwInterface: ULONG, pszFunction: LPCWSTR, pConfig: PCRYPT_CONTEXT_FUNCTION_CONFIG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptQueryContextFunctionConfiguration(dwTable: ULONG, pszContext: LPCWSTR, dwInterface: ULONG, pszFunction: LPCWSTR, pcbBuffer: [*c]ULONG, ppBuffer: [*c]PCRYPT_CONTEXT_FUNCTION_CONFIG) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptEnumContextFunctionProviders(dwTable: ULONG, pszContext: LPCWSTR, dwInterface: ULONG, pszFunction: LPCWSTR, pcbBuffer: [*c]ULONG, ppBuffer: [*c]PCRYPT_CONTEXT_FUNCTION_PROVIDERS) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptSetContextFunctionProperty(dwTable: ULONG, pszContext: LPCWSTR, dwInterface: ULONG, pszFunction: LPCWSTR, pszProperty: LPCWSTR, cbValue: ULONG, pbValue: PUCHAR) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptQueryContextFunctionProperty(dwTable: ULONG, pszContext: LPCWSTR, dwInterface: ULONG, pszFunction: LPCWSTR, pszProperty: LPCWSTR, pcbValue: [*c]ULONG, ppbValue: [*c]PUCHAR) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptRegisterConfigChangeNotify(phEvent: [*c]HANDLE) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptUnregisterConfigChangeNotify(hEvent: HANDLE) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptResolveProviders(pszContext: LPCWSTR, dwInterface: ULONG, pszFunction: LPCWSTR, pszProvider: LPCWSTR, dwMode: ULONG, dwFlags: ULONG, pcbBuffer: [*c]ULONG, ppBuffer: [*c]PCRYPT_PROVIDER_REFS) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn BCryptGetFipsAlgorithmMode(pfEnabled: [*c]BOOLEAN) callconv(.Stdcall) NTSTATUS;
pub extern "bcrypt" fn CngGetFipsAlgorithmMode() callconv(.Stdcall) BOOLEAN;
pub const SECURITY_STATUS = LONG;
pub const PFN_NCRYPT_ALLOC = ?fn (SIZE_T) callconv(.C) LPVOID;
pub const PFN_NCRYPT_FREE = ?fn (LPVOID) callconv(.C) void;
pub const struct_NCRYPT_ALLOC_PARA = extern struct {
    cbSize: DWORD,
    pfnAlloc: PFN_NCRYPT_ALLOC,
    pfnFree: PFN_NCRYPT_FREE,
};
pub const NCRYPT_ALLOC_PARA = struct_NCRYPT_ALLOC_PARA;
pub const NCryptBuffer = BCryptBuffer;
pub const PNCryptBuffer = [*c]BCryptBuffer;
pub const NCryptBufferDesc = BCryptBufferDesc;
pub const PNCryptBufferDesc = [*c]BCryptBufferDesc;
pub const NCRYPT_HANDLE = ULONG_PTR;
pub const NCRYPT_PROV_HANDLE = ULONG_PTR;
pub const NCRYPT_KEY_HANDLE = ULONG_PTR;
pub const NCRYPT_HASH_HANDLE = ULONG_PTR;
pub const NCRYPT_SECRET_HANDLE = ULONG_PTR;
pub const struct__NCRYPT_CIPHER_PADDING_INFO = extern struct {
    cbSize: ULONG,
    dwFlags: DWORD,
    pbIV: PUCHAR,
    cbIV: ULONG,
    pbOtherInfo: PUCHAR,
    cbOtherInfo: ULONG,
};
pub const NCRYPT_CIPHER_PADDING_INFO = struct__NCRYPT_CIPHER_PADDING_INFO;
pub const PNCRYPT_CIPHER_PADDING_INFO = [*c]struct__NCRYPT_CIPHER_PADDING_INFO;
pub const struct__NCRYPT_PLATFORM_ATTEST_PADDING_INFO = extern struct {
    magic: ULONG,
    pcrMask: ULONG,
};
pub const NCRYPT_PLATFORM_ATTEST_PADDING_INFO = struct__NCRYPT_PLATFORM_ATTEST_PADDING_INFO;
pub const struct__NCRYPT_KEY_ATTEST_PADDING_INFO = extern struct {
    magic: ULONG,
    pbKeyBlob: PUCHAR,
    cbKeyBlob: ULONG,
    pbKeyAuth: PUCHAR,
    cbKeyAuth: ULONG,
};
pub const NCRYPT_KEY_ATTEST_PADDING_INFO = struct__NCRYPT_KEY_ATTEST_PADDING_INFO;
pub const struct__NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES = extern struct {
    Version: ULONG,
    Flags: ULONG,
    cbPublicKeyBlob: ULONG,
};
pub const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES = struct__NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES;
pub const PNCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES = [*c]struct__NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES;
pub const struct__NCRYPT_VSM_KEY_ATTESTATION_STATEMENT = extern struct {
    Magic: ULONG,
    Version: ULONG,
    cbSignature: ULONG,
    cbReport: ULONG,
    cbAttributes: ULONG,
};
pub const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT = struct__NCRYPT_VSM_KEY_ATTESTATION_STATEMENT;
pub const PNCRYPT_VSM_KEY_ATTESTATION_STATEMENT = [*c]struct__NCRYPT_VSM_KEY_ATTESTATION_STATEMENT;
pub const struct__NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = @OpaqueType();
pub const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = struct__NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS;
pub const PNCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = ?*struct__NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS;
pub const struct__NCRYPT_EXPORTED_ISOLATED_KEY_HEADER = @OpaqueType();
pub const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER = struct__NCRYPT_EXPORTED_ISOLATED_KEY_HEADER;
pub const PNCRYPT_EXPORTED_ISOLATED_KEY_HEADER = ?*struct__NCRYPT_EXPORTED_ISOLATED_KEY_HEADER;
pub const struct__NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE = extern struct {
    Header: NCRYPT_EXPORTED_ISOLATED_KEY_HEADER,
};
pub const NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE = struct__NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE;
pub const PNCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE = [*c]struct__NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE;
pub const struct___NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT = extern struct {
    Magic: UINT32,
    Version: UINT32,
    HeaderSize: UINT32,
    cbCertifyInfo: UINT32,
    cbSignature: UINT32,
    cbTpmPublic: UINT32,
};
pub const NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT = struct___NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT;
pub const PNCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT = [*c]struct___NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT;
pub const struct__NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT = extern struct {
    Magic: ULONG,
    Version: ULONG,
    pcrAlg: ULONG,
    cbSignature: ULONG,
    cbQuote: ULONG,
    cbPcrs: ULONG,
};
pub const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT = struct__NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT;
pub const PNCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT = [*c]struct__NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT;
pub extern "ncrypt" fn NCryptOpenStorageProvider(phProvider: [*c]NCRYPT_PROV_HANDLE, pszProviderName: LPCWSTR, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub const struct__NCryptAlgorithmName = extern struct {
    pszName: LPWSTR,
    dwClass: DWORD,
    dwAlgOperations: DWORD,
    dwFlags: DWORD,
};
pub const NCryptAlgorithmName = struct__NCryptAlgorithmName;
pub extern "ncrypt" fn NCryptEnumAlgorithms(hProvider: NCRYPT_PROV_HANDLE, dwAlgOperations: DWORD, pdwAlgCount: [*c]DWORD, ppAlgList: [*c]([*c]NCryptAlgorithmName), dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptIsAlgSupported(hProvider: NCRYPT_PROV_HANDLE, pszAlgId: LPCWSTR, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub const struct_NCryptKeyName = extern struct {
    pszName: LPWSTR,
    pszAlgid: LPWSTR,
    dwLegacyKeySpec: DWORD,
    dwFlags: DWORD,
};
pub const NCryptKeyName = struct_NCryptKeyName;
pub extern "ncrypt" fn NCryptEnumKeys(hProvider: NCRYPT_PROV_HANDLE, pszScope: LPCWSTR, ppKeyName: [*c]([*c]NCryptKeyName), ppEnumState: [*c]PVOID, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub const struct_NCryptProviderName = extern struct {
    pszName: LPWSTR,
    pszComment: LPWSTR,
};
pub const NCryptProviderName = struct_NCryptProviderName;
pub extern "ncrypt" fn NCryptEnumStorageProviders(pdwProviderCount: [*c]DWORD, ppProviderList: [*c]([*c]NCryptProviderName), dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptFreeBuffer(pvInput: PVOID) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptOpenKey(hProvider: NCRYPT_PROV_HANDLE, phKey: [*c]NCRYPT_KEY_HANDLE, pszKeyName: LPCWSTR, dwLegacyKeySpec: DWORD, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptCreatePersistedKey(hProvider: NCRYPT_PROV_HANDLE, phKey: [*c]NCRYPT_KEY_HANDLE, pszAlgId: LPCWSTR, pszKeyName: LPCWSTR, dwLegacyKeySpec: DWORD, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub const struct___NCRYPT_UI_POLICY = extern struct {
    dwVersion: DWORD,
    dwFlags: DWORD,
    pszCreationTitle: LPCWSTR,
    pszFriendlyName: LPCWSTR,
    pszDescription: LPCWSTR,
};
pub const NCRYPT_UI_POLICY = struct___NCRYPT_UI_POLICY;
pub const struct___NCRYPT_KEY_ACCESS_POLICY_BLOB = extern struct {
    dwVersion: DWORD,
    dwPolicyFlags: DWORD,
    cbUserSid: DWORD,
    cbApplicationSid: DWORD,
};
pub const NCRYPT_KEY_ACCESS_POLICY_BLOB = struct___NCRYPT_KEY_ACCESS_POLICY_BLOB;
pub const struct___NCRYPT_SUPPORTED_LENGTHS = extern struct {
    dwMinLength: DWORD,
    dwMaxLength: DWORD,
    dwIncrement: DWORD,
    dwDefaultLength: DWORD,
};
pub const NCRYPT_SUPPORTED_LENGTHS = struct___NCRYPT_SUPPORTED_LENGTHS;
pub const struct___NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO = extern struct {
    dwVersion: DWORD,
    iExpiration: INT32,
    pabNonce: [32]BYTE,
    pabPolicyRef: [32]BYTE,
    pabHMAC: [32]BYTE,
};
pub const NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO = struct___NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO;
pub const struct___NCRYPT_PCP_TPM_FW_VERSION_INFO = extern struct {
    major1: UINT16,
    major2: UINT16,
    minor1: UINT16,
    minor2: UINT16,
};
pub const NCRYPT_PCP_TPM_FW_VERSION_INFO = struct___NCRYPT_PCP_TPM_FW_VERSION_INFO;
pub const struct___NCRYPT_PCP_RAW_POLICYDIGEST = extern struct {
    dwVersion: DWORD,
    cbDigest: DWORD,
};
pub const NCRYPT_PCP_RAW_POLICYDIGEST_INFO = struct___NCRYPT_PCP_RAW_POLICYDIGEST;
pub extern "ncrypt" fn NCryptGetProperty(hObject: NCRYPT_HANDLE, pszProperty: LPCWSTR, pbOutput: PBYTE, cbOutput: DWORD, pcbResult: [*c]DWORD, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptSetProperty(hObject: NCRYPT_HANDLE, pszProperty: LPCWSTR, pbInput: PBYTE, cbInput: DWORD, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptFinalizeKey(hKey: NCRYPT_KEY_HANDLE, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptEncrypt(hKey: NCRYPT_KEY_HANDLE, pbInput: PBYTE, cbInput: DWORD, pPaddingInfo: ?*c_void, pbOutput: PBYTE, cbOutput: DWORD, pcbResult: [*c]DWORD, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptDecrypt(hKey: NCRYPT_KEY_HANDLE, pbInput: PBYTE, cbInput: DWORD, pPaddingInfo: ?*c_void, pbOutput: PBYTE, cbOutput: DWORD, pcbResult: [*c]DWORD, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub const struct__NCRYPT_KEY_BLOB_HEADER = extern struct {
    cbSize: ULONG,
    dwMagic: ULONG,
    cbAlgName: ULONG,
    cbKeyData: ULONG,
};
pub const NCRYPT_KEY_BLOB_HEADER = struct__NCRYPT_KEY_BLOB_HEADER;
pub const PNCRYPT_KEY_BLOB_HEADER = [*c]struct__NCRYPT_KEY_BLOB_HEADER;
pub const struct_NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER = extern struct {
    magic: DWORD,
    cbHeader: DWORD,
    cbPublic: DWORD,
    cbPrivate: DWORD,
    cbName: DWORD,
};
pub const NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER = struct_NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER;
pub const PNCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER = [*c]struct_NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER;
pub extern "ncrypt" fn NCryptImportKey(hProvider: NCRYPT_PROV_HANDLE, hImportKey: NCRYPT_KEY_HANDLE, pszBlobType: LPCWSTR, pParameterList: [*c]NCryptBufferDesc, phKey: [*c]NCRYPT_KEY_HANDLE, pbData: PBYTE, cbData: DWORD, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptExportKey(hKey: NCRYPT_KEY_HANDLE, hExportKey: NCRYPT_KEY_HANDLE, pszBlobType: LPCWSTR, pParameterList: [*c]NCryptBufferDesc, pbOutput: PBYTE, cbOutput: DWORD, pcbResult: [*c]DWORD, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptSignHash(hKey: NCRYPT_KEY_HANDLE, pPaddingInfo: ?*c_void, pbHashValue: PBYTE, cbHashValue: DWORD, pbSignature: PBYTE, cbSignature: DWORD, pcbResult: [*c]DWORD, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptVerifySignature(hKey: NCRYPT_KEY_HANDLE, pPaddingInfo: ?*c_void, pbHashValue: PBYTE, cbHashValue: DWORD, pbSignature: PBYTE, cbSignature: DWORD, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptDeleteKey(hKey: NCRYPT_KEY_HANDLE, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptFreeObject(hObject: NCRYPT_HANDLE) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptIsKeyHandle(hKey: NCRYPT_KEY_HANDLE) callconv(.Stdcall) BOOL;
pub extern "ncrypt" fn NCryptTranslateHandle(phProvider: [*c]NCRYPT_PROV_HANDLE, phKey: [*c]NCRYPT_KEY_HANDLE, hLegacyProv: HCRYPTPROV, hLegacyKey: HCRYPTKEY, dwLegacyKeySpec: DWORD, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptNotifyChangeKey(hProvider: NCRYPT_PROV_HANDLE, phEvent: [*c]HANDLE, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptSecretAgreement(hPrivKey: NCRYPT_KEY_HANDLE, hPubKey: NCRYPT_KEY_HANDLE, phAgreedSecret: [*c]NCRYPT_SECRET_HANDLE, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptDeriveKey(hSharedSecret: NCRYPT_SECRET_HANDLE, pwszKDF: LPCWSTR, pParameterList: [*c]NCryptBufferDesc, pbDerivedKey: PBYTE, cbDerivedKey: DWORD, pcbResult: [*c]DWORD, dwFlags: ULONG) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptKeyDerivation(hKey: NCRYPT_KEY_HANDLE, pParameterList: [*c]NCryptBufferDesc, pbDerivedKey: PUCHAR, cbDerivedKey: DWORD, pcbResult: [*c]DWORD, dwFlags: ULONG) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptCreateClaim(hSubjectKey: NCRYPT_KEY_HANDLE, hAuthorityKey: NCRYPT_KEY_HANDLE, dwClaimType: DWORD, pParameterList: [*c]NCryptBufferDesc, pbClaimBlob: PBYTE, cbClaimBlob: DWORD, pcbResult: [*c]DWORD, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub extern "ncrypt" fn NCryptVerifyClaim(hSubjectKey: NCRYPT_KEY_HANDLE, hAuthorityKey: NCRYPT_KEY_HANDLE, dwClaimType: DWORD, pParameterList: [*c]NCryptBufferDesc, pbClaimBlob: PBYTE, cbClaimBlob: DWORD, pOutput: [*c]NCryptBufferDesc, dwFlags: DWORD) callconv(.Stdcall) SECURITY_STATUS;
pub const HCRYPTPROV_OR_NCRYPT_KEY_HANDLE = ULONG_PTR;
pub const HCRYPTPROV_LEGACY = ULONG_PTR;
pub const struct__CRYPT_BIT_BLOB = extern struct {
    cbData: DWORD,
    pbData: [*c]BYTE,
    cUnusedBits: DWORD,
};
pub const CRYPT_BIT_BLOB = struct__CRYPT_BIT_BLOB;
pub const PCRYPT_BIT_BLOB = [*c]struct__CRYPT_BIT_BLOB;
pub const struct__CRYPT_ALGORITHM_IDENTIFIER = extern struct {
    pszObjId: LPSTR,
    Parameters: CRYPT_OBJID_BLOB,
};
pub const CRYPT_ALGORITHM_IDENTIFIER = struct__CRYPT_ALGORITHM_IDENTIFIER;
pub const PCRYPT_ALGORITHM_IDENTIFIER = [*c]struct__CRYPT_ALGORITHM_IDENTIFIER;
pub const struct__CRYPT_OBJID_TABLE = extern struct {
    dwAlgId: DWORD,
    pszObjId: LPCSTR,
};
pub const CRYPT_OBJID_TABLE = struct__CRYPT_OBJID_TABLE;
pub const PCRYPT_OBJID_TABLE = [*c]struct__CRYPT_OBJID_TABLE;
pub const struct__CRYPT_HASH_INFO = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Hash: CRYPT_HASH_BLOB,
};
pub const CRYPT_HASH_INFO = struct__CRYPT_HASH_INFO;
pub const PCRYPT_HASH_INFO = [*c]struct__CRYPT_HASH_INFO;
pub const struct__CERT_EXTENSION = extern struct {
    pszObjId: LPSTR,
    fCritical: BOOL,
    Value: CRYPT_OBJID_BLOB,
};
pub const CERT_EXTENSION = struct__CERT_EXTENSION;
pub const PCERT_EXTENSION = [*c]struct__CERT_EXTENSION;
pub const PCCERT_EXTENSION = [*c]const CERT_EXTENSION;
pub const struct__CRYPT_ATTRIBUTE_TYPE_VALUE = extern struct {
    pszObjId: LPSTR,
    Value: CRYPT_OBJID_BLOB,
};
pub const CRYPT_ATTRIBUTE_TYPE_VALUE = struct__CRYPT_ATTRIBUTE_TYPE_VALUE;
pub const PCRYPT_ATTRIBUTE_TYPE_VALUE = [*c]struct__CRYPT_ATTRIBUTE_TYPE_VALUE;
pub const struct__CRYPT_ATTRIBUTE = extern struct {
    pszObjId: LPSTR,
    cValue: DWORD,
    rgValue: PCRYPT_ATTR_BLOB,
};
pub const CRYPT_ATTRIBUTE = struct__CRYPT_ATTRIBUTE;
pub const PCRYPT_ATTRIBUTE = [*c]struct__CRYPT_ATTRIBUTE;
pub const struct__CRYPT_ATTRIBUTES = extern struct {
    cAttr: DWORD,
    rgAttr: PCRYPT_ATTRIBUTE,
};
pub const CRYPT_ATTRIBUTES = struct__CRYPT_ATTRIBUTES;
pub const PCRYPT_ATTRIBUTES = [*c]struct__CRYPT_ATTRIBUTES;
pub const struct__CERT_RDN_ATTR = extern struct {
    pszObjId: LPSTR,
    dwValueType: DWORD,
    Value: CERT_RDN_VALUE_BLOB,
};
pub const CERT_RDN_ATTR = struct__CERT_RDN_ATTR;
pub const PCERT_RDN_ATTR = [*c]struct__CERT_RDN_ATTR;
pub const struct__CERT_RDN = extern struct {
    cRDNAttr: DWORD,
    rgRDNAttr: PCERT_RDN_ATTR,
};
pub const CERT_RDN = struct__CERT_RDN;
pub const PCERT_RDN = [*c]struct__CERT_RDN;
pub const struct__CERT_NAME_INFO = extern struct {
    cRDN: DWORD,
    rgRDN: PCERT_RDN,
};
pub const CERT_NAME_INFO = struct__CERT_NAME_INFO;
pub const PCERT_NAME_INFO = [*c]struct__CERT_NAME_INFO;
pub const struct__CERT_NAME_VALUE = extern struct {
    dwValueType: DWORD,
    Value: CERT_RDN_VALUE_BLOB,
};
pub const CERT_NAME_VALUE = struct__CERT_NAME_VALUE;
pub const PCERT_NAME_VALUE = [*c]struct__CERT_NAME_VALUE;
pub const struct__CERT_PUBLIC_KEY_INFO = extern struct {
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    PublicKey: CRYPT_BIT_BLOB,
};
pub const CERT_PUBLIC_KEY_INFO = struct__CERT_PUBLIC_KEY_INFO;
pub const PCERT_PUBLIC_KEY_INFO = [*c]struct__CERT_PUBLIC_KEY_INFO;
pub const struct__CRYPT_ECC_PRIVATE_KEY_INFO = extern struct {
    dwVersion: DWORD,
    PrivateKey: CRYPT_DER_BLOB,
    szCurveOid: LPSTR,
    PublicKey: CRYPT_BIT_BLOB,
};
pub const CRYPT_ECC_PRIVATE_KEY_INFO = struct__CRYPT_ECC_PRIVATE_KEY_INFO;
pub const PCRYPT_ECC_PRIVATE_KEY_INFO = [*c]struct__CRYPT_ECC_PRIVATE_KEY_INFO;
pub const struct__CRYPT_PRIVATE_KEY_INFO = extern struct {
    Version: DWORD,
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    PrivateKey: CRYPT_DER_BLOB,
    pAttributes: PCRYPT_ATTRIBUTES,
};
pub const CRYPT_PRIVATE_KEY_INFO = struct__CRYPT_PRIVATE_KEY_INFO;
pub const PCRYPT_PRIVATE_KEY_INFO = [*c]struct__CRYPT_PRIVATE_KEY_INFO;
pub const struct__CRYPT_ENCRYPTED_PRIVATE_KEY_INFO = extern struct {
    EncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedPrivateKey: CRYPT_DATA_BLOB,
};
pub const CRYPT_ENCRYPTED_PRIVATE_KEY_INFO = struct__CRYPT_ENCRYPTED_PRIVATE_KEY_INFO;
pub const PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO = [*c]struct__CRYPT_ENCRYPTED_PRIVATE_KEY_INFO;
pub const PCRYPT_DECRYPT_PRIVATE_KEY_FUNC = ?fn (CRYPT_ALGORITHM_IDENTIFIER, CRYPT_DATA_BLOB, [*c]BYTE, [*c]DWORD, LPVOID) callconv(.C) BOOL;
pub const PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC = ?fn ([*c]CRYPT_ALGORITHM_IDENTIFIER, [*c]CRYPT_DATA_BLOB, [*c]BYTE, [*c]DWORD, LPVOID) callconv(.C) BOOL;
pub const PCRYPT_RESOLVE_HCRYPTPROV_FUNC = ?fn ([*c]CRYPT_PRIVATE_KEY_INFO, [*c]HCRYPTPROV, LPVOID) callconv(.C) BOOL;
pub const struct__CRYPT_PKCS8_IMPORT_PARAMS = extern struct {
    PrivateKey: CRYPT_DIGEST_BLOB,
    pResolvehCryptProvFunc: PCRYPT_RESOLVE_HCRYPTPROV_FUNC,
    pVoidResolveFunc: LPVOID,
    pDecryptPrivateKeyFunc: PCRYPT_DECRYPT_PRIVATE_KEY_FUNC,
    pVoidDecryptFunc: LPVOID,
};
pub const CRYPT_PKCS8_IMPORT_PARAMS = struct__CRYPT_PKCS8_IMPORT_PARAMS;
pub const PCRYPT_PKCS8_IMPORT_PARAMS = [*c]struct__CRYPT_PKCS8_IMPORT_PARAMS;
pub const CRYPT_PRIVATE_KEY_BLOB_AND_PARAMS = struct__CRYPT_PKCS8_IMPORT_PARAMS;
pub const PCRYPT_PRIVATE_KEY_BLOB_AND_PARAMS = [*c]struct__CRYPT_PKCS8_IMPORT_PARAMS;
pub const struct__CRYPT_PKCS8_EXPORT_PARAMS = extern struct {
    hCryptProv: HCRYPTPROV,
    dwKeySpec: DWORD,
    pszPrivateKeyObjId: LPSTR,
    pEncryptPrivateKeyFunc: PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC,
    pVoidEncryptFunc: LPVOID,
};
pub const CRYPT_PKCS8_EXPORT_PARAMS = struct__CRYPT_PKCS8_EXPORT_PARAMS;
pub const PCRYPT_PKCS8_EXPORT_PARAMS = [*c]struct__CRYPT_PKCS8_EXPORT_PARAMS;
pub const struct__CERT_INFO = extern struct {
    dwVersion: DWORD,
    SerialNumber: CRYPT_INTEGER_BLOB,
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Issuer: CERT_NAME_BLOB,
    NotBefore: FILETIME,
    NotAfter: FILETIME,
    Subject: CERT_NAME_BLOB,
    SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    IssuerUniqueId: CRYPT_BIT_BLOB,
    SubjectUniqueId: CRYPT_BIT_BLOB,
    cExtension: DWORD,
    rgExtension: PCERT_EXTENSION,
};
pub const CERT_INFO = struct__CERT_INFO;
pub const PCERT_INFO = [*c]struct__CERT_INFO;
pub const struct__CRL_ENTRY = extern struct {
    SerialNumber: CRYPT_INTEGER_BLOB,
    RevocationDate: FILETIME,
    cExtension: DWORD,
    rgExtension: PCERT_EXTENSION,
};
pub const CRL_ENTRY = struct__CRL_ENTRY;
pub const PCRL_ENTRY = [*c]struct__CRL_ENTRY;
pub const struct__CRL_INFO = extern struct {
    dwVersion: DWORD,
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Issuer: CERT_NAME_BLOB,
    ThisUpdate: FILETIME,
    NextUpdate: FILETIME,
    cCRLEntry: DWORD,
    rgCRLEntry: PCRL_ENTRY,
    cExtension: DWORD,
    rgExtension: PCERT_EXTENSION,
};
pub const CRL_INFO = struct__CRL_INFO;
pub const PCRL_INFO = [*c]struct__CRL_INFO;
pub const struct__CERT_OR_CRL_BLOB = extern struct {
    dwChoice: DWORD,
    cbEncoded: DWORD,
    pbEncoded: [*c]BYTE,
};
pub const CERT_OR_CRL_BLOB = struct__CERT_OR_CRL_BLOB;
pub const PCERT_OR_CRL_BLOB = [*c]struct__CERT_OR_CRL_BLOB;
pub const struct__CERT_OR_CRL_BUNDLE = extern struct {
    cItem: DWORD,
    rgItem: PCERT_OR_CRL_BLOB,
};
pub const CERT_OR_CRL_BUNDLE = struct__CERT_OR_CRL_BUNDLE;
pub const PCERT_OR_CRL_BUNDLE = [*c]struct__CERT_OR_CRL_BUNDLE;
pub const struct__CERT_REQUEST_INFO = extern struct {
    dwVersion: DWORD,
    Subject: CERT_NAME_BLOB,
    SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    cAttribute: DWORD,
    rgAttribute: PCRYPT_ATTRIBUTE,
};
pub const CERT_REQUEST_INFO = struct__CERT_REQUEST_INFO;
pub const PCERT_REQUEST_INFO = [*c]struct__CERT_REQUEST_INFO;
pub const struct__CERT_KEYGEN_REQUEST_INFO = extern struct {
    dwVersion: DWORD,
    SubjectPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    pwszChallengeString: LPWSTR,
};
pub const CERT_KEYGEN_REQUEST_INFO = struct__CERT_KEYGEN_REQUEST_INFO;
pub const PCERT_KEYGEN_REQUEST_INFO = [*c]struct__CERT_KEYGEN_REQUEST_INFO;
pub const struct__CERT_SIGNED_CONTENT_INFO = extern struct {
    ToBeSigned: CRYPT_DER_BLOB,
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Signature: CRYPT_BIT_BLOB,
};
pub const CERT_SIGNED_CONTENT_INFO = struct__CERT_SIGNED_CONTENT_INFO;
pub const PCERT_SIGNED_CONTENT_INFO = [*c]struct__CERT_SIGNED_CONTENT_INFO;
pub const struct__CTL_USAGE = extern struct {
    cUsageIdentifier: DWORD,
    rgpszUsageIdentifier: [*c]LPSTR,
};
pub const CTL_USAGE = struct__CTL_USAGE;
pub const PCTL_USAGE = [*c]struct__CTL_USAGE;
pub const CERT_ENHKEY_USAGE = struct__CTL_USAGE;
pub const PCERT_ENHKEY_USAGE = [*c]struct__CTL_USAGE;
pub const PCCTL_USAGE = [*c]const CTL_USAGE;
pub const PCCERT_ENHKEY_USAGE = [*c]const CERT_ENHKEY_USAGE;
pub const struct__CTL_ENTRY = extern struct {
    SubjectIdentifier: CRYPT_DATA_BLOB,
    cAttribute: DWORD,
    rgAttribute: PCRYPT_ATTRIBUTE,
};
pub const CTL_ENTRY = struct__CTL_ENTRY;
pub const PCTL_ENTRY = [*c]struct__CTL_ENTRY;
pub const struct__CTL_INFO = extern struct {
    dwVersion: DWORD,
    SubjectUsage: CTL_USAGE,
    ListIdentifier: CRYPT_DATA_BLOB,
    SequenceNumber: CRYPT_INTEGER_BLOB,
    ThisUpdate: FILETIME,
    NextUpdate: FILETIME,
    SubjectAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    cCTLEntry: DWORD,
    rgCTLEntry: PCTL_ENTRY,
    cExtension: DWORD,
    rgExtension: PCERT_EXTENSION,
};
pub const CTL_INFO = struct__CTL_INFO;
pub const PCTL_INFO = [*c]struct__CTL_INFO;
pub const struct__CRYPT_TIME_STAMP_REQUEST_INFO = extern struct {
    pszTimeStampAlgorithm: LPSTR,
    pszContentType: LPSTR,
    Content: CRYPT_OBJID_BLOB,
    cAttribute: DWORD,
    rgAttribute: PCRYPT_ATTRIBUTE,
};
pub const CRYPT_TIME_STAMP_REQUEST_INFO = struct__CRYPT_TIME_STAMP_REQUEST_INFO;
pub const PCRYPT_TIME_STAMP_REQUEST_INFO = [*c]struct__CRYPT_TIME_STAMP_REQUEST_INFO;
pub const struct__CRYPT_ENROLLMENT_NAME_VALUE_PAIR = extern struct {
    pwszName: LPWSTR,
    pwszValue: LPWSTR,
};
pub const CRYPT_ENROLLMENT_NAME_VALUE_PAIR = struct__CRYPT_ENROLLMENT_NAME_VALUE_PAIR;
pub const PCRYPT_ENROLLMENT_NAME_VALUE_PAIR = [*c]struct__CRYPT_ENROLLMENT_NAME_VALUE_PAIR;
pub const struct__CRYPT_CSP_PROVIDER = extern struct {
    dwKeySpec: DWORD,
    pwszProviderName: LPWSTR,
    Signature: CRYPT_BIT_BLOB,
};
pub const CRYPT_CSP_PROVIDER = struct__CRYPT_CSP_PROVIDER;
pub const PCRYPT_CSP_PROVIDER = [*c]struct__CRYPT_CSP_PROVIDER;
pub extern "crypt32" fn CryptFormatObject(dwCertEncodingType: DWORD, dwFormatType: DWORD, dwFormatStrType: DWORD, pFormatStruct: ?*c_void, lpszStructType: LPCSTR, pbEncoded: [*c]const BYTE, cbEncoded: DWORD, pbFormat: ?*c_void, pcbFormat: [*c]DWORD) callconv(.Stdcall) BOOL;
pub const PFN_CRYPT_ALLOC = ?fn (usize) callconv(.C) LPVOID;
pub const PFN_CRYPT_FREE = ?fn (LPVOID) callconv(.C) void;
pub const struct__CRYPT_ENCODE_PARA = extern struct {
    cbSize: DWORD,
    pfnAlloc: PFN_CRYPT_ALLOC,
    pfnFree: PFN_CRYPT_FREE,
};
pub const CRYPT_ENCODE_PARA = struct__CRYPT_ENCODE_PARA;
pub const PCRYPT_ENCODE_PARA = [*c]struct__CRYPT_ENCODE_PARA;
pub extern "crypt32" fn CryptEncodeObjectEx(dwCertEncodingType: DWORD, lpszStructType: LPCSTR, pvStructInfo: ?*const c_void, dwFlags: DWORD, pEncodePara: PCRYPT_ENCODE_PARA, pvEncoded: ?*c_void, pcbEncoded: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptEncodeObject(dwCertEncodingType: DWORD, lpszStructType: LPCSTR, pvStructInfo: ?*const c_void, pbEncoded: [*c]BYTE, pcbEncoded: [*c]DWORD) callconv(.Stdcall) BOOL;
pub const struct__CRYPT_DECODE_PARA = extern struct {
    cbSize: DWORD,
    pfnAlloc: PFN_CRYPT_ALLOC,
    pfnFree: PFN_CRYPT_FREE,
};
pub const CRYPT_DECODE_PARA = struct__CRYPT_DECODE_PARA;
pub const PCRYPT_DECODE_PARA = [*c]struct__CRYPT_DECODE_PARA;
pub extern "crypt32" fn CryptDecodeObjectEx(dwCertEncodingType: DWORD, lpszStructType: LPCSTR, pbEncoded: [*c]const BYTE, cbEncoded: DWORD, dwFlags: DWORD, pDecodePara: PCRYPT_DECODE_PARA, pvStructInfo: ?*c_void, pcbStructInfo: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptDecodeObject(dwCertEncodingType: DWORD, lpszStructType: LPCSTR, pbEncoded: [*c]const BYTE, cbEncoded: DWORD, dwFlags: DWORD, pvStructInfo: ?*c_void, pcbStructInfo: [*c]DWORD) callconv(.Stdcall) BOOL;
pub const struct__CERT_EXTENSIONS = extern struct {
    cExtension: DWORD,
    rgExtension: PCERT_EXTENSION,
};
pub const CERT_EXTENSIONS = struct__CERT_EXTENSIONS;
pub const PCERT_EXTENSIONS = [*c]struct__CERT_EXTENSIONS;
pub const struct__CERT_AUTHORITY_KEY_ID_INFO = extern struct {
    KeyId: CRYPT_DATA_BLOB,
    CertIssuer: CERT_NAME_BLOB,
    CertSerialNumber: CRYPT_INTEGER_BLOB,
};
pub const CERT_AUTHORITY_KEY_ID_INFO = struct__CERT_AUTHORITY_KEY_ID_INFO;
pub const PCERT_AUTHORITY_KEY_ID_INFO = [*c]struct__CERT_AUTHORITY_KEY_ID_INFO;
pub const struct__CERT_PRIVATE_KEY_VALIDITY = extern struct {
    NotBefore: FILETIME,
    NotAfter: FILETIME,
};
pub const CERT_PRIVATE_KEY_VALIDITY = struct__CERT_PRIVATE_KEY_VALIDITY;
pub const PCERT_PRIVATE_KEY_VALIDITY = [*c]struct__CERT_PRIVATE_KEY_VALIDITY;
pub const struct__CERT_KEY_ATTRIBUTES_INFO = extern struct {
    KeyId: CRYPT_DATA_BLOB,
    IntendedKeyUsage: CRYPT_BIT_BLOB,
    pPrivateKeyUsagePeriod: PCERT_PRIVATE_KEY_VALIDITY,
};
pub const CERT_KEY_ATTRIBUTES_INFO = struct__CERT_KEY_ATTRIBUTES_INFO;
pub const PCERT_KEY_ATTRIBUTES_INFO = [*c]struct__CERT_KEY_ATTRIBUTES_INFO;
pub const struct__CERT_POLICY_ID = extern struct {
    cCertPolicyElementId: DWORD,
    rgpszCertPolicyElementId: [*c]LPSTR,
};
pub const CERT_POLICY_ID = struct__CERT_POLICY_ID;
pub const PCERT_POLICY_ID = [*c]struct__CERT_POLICY_ID;
pub const struct__CERT_KEY_USAGE_RESTRICTION_INFO = extern struct {
    cCertPolicyId: DWORD,
    rgCertPolicyId: PCERT_POLICY_ID,
    RestrictedKeyUsage: CRYPT_BIT_BLOB,
};
pub const CERT_KEY_USAGE_RESTRICTION_INFO = struct__CERT_KEY_USAGE_RESTRICTION_INFO;
pub const PCERT_KEY_USAGE_RESTRICTION_INFO = [*c]struct__CERT_KEY_USAGE_RESTRICTION_INFO;
pub const struct__CERT_OTHER_NAME = extern struct {
    pszObjId: LPSTR,
    Value: CRYPT_OBJID_BLOB,
};
pub const CERT_OTHER_NAME = struct__CERT_OTHER_NAME;
pub const PCERT_OTHER_NAME = [*c]struct__CERT_OTHER_NAME;
pub const struct__CERT_ALT_NAME_ENTRY = extern struct {
    dwAltNameChoice: DWORD,
    @"": extern union {
        pOtherName: PCERT_OTHER_NAME,
        pwszRfc822Name: LPWSTR,
        pwszDNSName: LPWSTR,
        DirectoryName: CERT_NAME_BLOB,
        pwszURL: LPWSTR,
        IPAddress: CRYPT_DATA_BLOB,
        pszRegisteredID: LPSTR,
    },
};
pub const CERT_ALT_NAME_ENTRY = struct__CERT_ALT_NAME_ENTRY;
pub const PCERT_ALT_NAME_ENTRY = [*c]struct__CERT_ALT_NAME_ENTRY;
pub const struct__CERT_ALT_NAME_INFO = extern struct {
    cAltEntry: DWORD,
    rgAltEntry: PCERT_ALT_NAME_ENTRY,
};
pub const CERT_ALT_NAME_INFO = struct__CERT_ALT_NAME_INFO;
pub const PCERT_ALT_NAME_INFO = [*c]struct__CERT_ALT_NAME_INFO;
pub const struct__CERT_BASIC_CONSTRAINTS_INFO = extern struct {
    SubjectType: CRYPT_BIT_BLOB,
    fPathLenConstraint: BOOL,
    dwPathLenConstraint: DWORD,
    cSubtreesConstraint: DWORD,
    rgSubtreesConstraint: [*c]CERT_NAME_BLOB,
};
pub const CERT_BASIC_CONSTRAINTS_INFO = struct__CERT_BASIC_CONSTRAINTS_INFO;
pub const PCERT_BASIC_CONSTRAINTS_INFO = [*c]struct__CERT_BASIC_CONSTRAINTS_INFO;
pub const struct__CERT_BASIC_CONSTRAINTS2_INFO = extern struct {
    fCA: BOOL,
    fPathLenConstraint: BOOL,
    dwPathLenConstraint: DWORD,
};
pub const CERT_BASIC_CONSTRAINTS2_INFO = struct__CERT_BASIC_CONSTRAINTS2_INFO;
pub const PCERT_BASIC_CONSTRAINTS2_INFO = [*c]struct__CERT_BASIC_CONSTRAINTS2_INFO;
pub const struct__CERT_POLICY_QUALIFIER_INFO = extern struct {
    pszPolicyQualifierId: LPSTR,
    Qualifier: CRYPT_OBJID_BLOB,
};
pub const CERT_POLICY_QUALIFIER_INFO = struct__CERT_POLICY_QUALIFIER_INFO;
pub const PCERT_POLICY_QUALIFIER_INFO = [*c]struct__CERT_POLICY_QUALIFIER_INFO;
pub const struct__CERT_POLICY_INFO = extern struct {
    pszPolicyIdentifier: LPSTR,
    cPolicyQualifier: DWORD,
    rgPolicyQualifier: [*c]CERT_POLICY_QUALIFIER_INFO,
};
pub const CERT_POLICY_INFO = struct__CERT_POLICY_INFO;
pub const PCERT_POLICY_INFO = [*c]struct__CERT_POLICY_INFO;
pub const struct__CERT_POLICIES_INFO = extern struct {
    cPolicyInfo: DWORD,
    rgPolicyInfo: [*c]CERT_POLICY_INFO,
};
pub const CERT_POLICIES_INFO = struct__CERT_POLICIES_INFO;
pub const PCERT_POLICIES_INFO = [*c]struct__CERT_POLICIES_INFO;
pub const struct__CERT_POLICY_QUALIFIER_NOTICE_REFERENCE = extern struct {
    pszOrganization: LPSTR,
    cNoticeNumbers: DWORD,
    rgNoticeNumbers: [*c]c_int,
};
pub const CERT_POLICY_QUALIFIER_NOTICE_REFERENCE = struct__CERT_POLICY_QUALIFIER_NOTICE_REFERENCE;
pub const PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE = [*c]struct__CERT_POLICY_QUALIFIER_NOTICE_REFERENCE;
pub const struct__CERT_POLICY_QUALIFIER_USER_NOTICE = extern struct {
    pNoticeReference: [*c]CERT_POLICY_QUALIFIER_NOTICE_REFERENCE,
    pszDisplayText: LPWSTR,
};
pub const CERT_POLICY_QUALIFIER_USER_NOTICE = struct__CERT_POLICY_QUALIFIER_USER_NOTICE;
pub const PCERT_POLICY_QUALIFIER_USER_NOTICE = [*c]struct__CERT_POLICY_QUALIFIER_USER_NOTICE;
pub const struct__CPS_URLS = extern struct {
    pszURL: LPWSTR,
    pAlgorithm: [*c]CRYPT_ALGORITHM_IDENTIFIER,
    pDigest: [*c]CRYPT_DATA_BLOB,
};
pub const CPS_URLS = struct__CPS_URLS;
pub const PCPS_URLS = [*c]struct__CPS_URLS;
pub const struct__CERT_POLICY95_QUALIFIER1 = extern struct {
    pszPracticesReference: LPWSTR,
    pszNoticeIdentifier: LPSTR,
    pszNSINoticeIdentifier: LPSTR,
    cCPSURLs: DWORD,
    rgCPSURLs: [*c]CPS_URLS,
};
pub const CERT_POLICY95_QUALIFIER1 = struct__CERT_POLICY95_QUALIFIER1;
pub const PCERT_POLICY95_QUALIFIER1 = [*c]struct__CERT_POLICY95_QUALIFIER1;
pub const struct__CERT_POLICY_MAPPING = extern struct {
    pszIssuerDomainPolicy: LPSTR,
    pszSubjectDomainPolicy: LPSTR,
};
pub const CERT_POLICY_MAPPING = struct__CERT_POLICY_MAPPING;
pub const PCERT_POLICY_MAPPING = [*c]struct__CERT_POLICY_MAPPING;
pub const struct__CERT_POLICY_MAPPINGS_INFO = extern struct {
    cPolicyMapping: DWORD,
    rgPolicyMapping: PCERT_POLICY_MAPPING,
};
pub const CERT_POLICY_MAPPINGS_INFO = struct__CERT_POLICY_MAPPINGS_INFO;
pub const PCERT_POLICY_MAPPINGS_INFO = [*c]struct__CERT_POLICY_MAPPINGS_INFO;
pub const struct__CERT_POLICY_CONSTRAINTS_INFO = extern struct {
    fRequireExplicitPolicy: BOOL,
    dwRequireExplicitPolicySkipCerts: DWORD,
    fInhibitPolicyMapping: BOOL,
    dwInhibitPolicyMappingSkipCerts: DWORD,
};
pub const CERT_POLICY_CONSTRAINTS_INFO = struct__CERT_POLICY_CONSTRAINTS_INFO;
pub const PCERT_POLICY_CONSTRAINTS_INFO = [*c]struct__CERT_POLICY_CONSTRAINTS_INFO;
pub const struct__CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = extern struct {
    pszObjId: LPSTR,
    cValue: DWORD,
    rgValue: PCRYPT_DER_BLOB,
};
pub const CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = struct__CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY;
pub const PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = [*c]struct__CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY;
pub const struct__CRYPT_CONTENT_INFO = extern struct {
    pszObjId: LPSTR,
    Content: CRYPT_DER_BLOB,
};
pub const CRYPT_CONTENT_INFO = struct__CRYPT_CONTENT_INFO;
pub const PCRYPT_CONTENT_INFO = [*c]struct__CRYPT_CONTENT_INFO;
pub const struct__CRYPT_SEQUENCE_OF_ANY = extern struct {
    cValue: DWORD,
    rgValue: PCRYPT_DER_BLOB,
};
pub const CRYPT_SEQUENCE_OF_ANY = struct__CRYPT_SEQUENCE_OF_ANY;
pub const PCRYPT_SEQUENCE_OF_ANY = [*c]struct__CRYPT_SEQUENCE_OF_ANY;
pub const struct__CERT_AUTHORITY_KEY_ID2_INFO = extern struct {
    KeyId: CRYPT_DATA_BLOB,
    AuthorityCertIssuer: CERT_ALT_NAME_INFO,
    AuthorityCertSerialNumber: CRYPT_INTEGER_BLOB,
};
pub const CERT_AUTHORITY_KEY_ID2_INFO = struct__CERT_AUTHORITY_KEY_ID2_INFO;
pub const PCERT_AUTHORITY_KEY_ID2_INFO = [*c]struct__CERT_AUTHORITY_KEY_ID2_INFO;
pub const struct__CERT_ACCESS_DESCRIPTION = extern struct {
    pszAccessMethod: LPSTR,
    AccessLocation: CERT_ALT_NAME_ENTRY,
};
pub const CERT_ACCESS_DESCRIPTION = struct__CERT_ACCESS_DESCRIPTION;
pub const PCERT_ACCESS_DESCRIPTION = [*c]struct__CERT_ACCESS_DESCRIPTION;
pub const struct__CERT_AUTHORITY_INFO_ACCESS = extern struct {
    cAccDescr: DWORD,
    rgAccDescr: PCERT_ACCESS_DESCRIPTION,
};
pub const CERT_AUTHORITY_INFO_ACCESS = struct__CERT_AUTHORITY_INFO_ACCESS;
pub const PCERT_AUTHORITY_INFO_ACCESS = [*c]struct__CERT_AUTHORITY_INFO_ACCESS;
pub const CERT_SUBJECT_INFO_ACCESS = struct__CERT_AUTHORITY_INFO_ACCESS;
pub const PCERT_SUBJECT_INFO_ACCESS = [*c]struct__CERT_AUTHORITY_INFO_ACCESS;
pub const struct__CRL_DIST_POINT_NAME = extern struct {
    dwDistPointNameChoice: DWORD,
    @"": extern union {
        FullName: CERT_ALT_NAME_INFO,
    },
};
pub const CRL_DIST_POINT_NAME = struct__CRL_DIST_POINT_NAME;
pub const PCRL_DIST_POINT_NAME = [*c]struct__CRL_DIST_POINT_NAME;
pub const struct__CRL_DIST_POINT = extern struct {
    DistPointName: CRL_DIST_POINT_NAME,
    ReasonFlags: CRYPT_BIT_BLOB,
    CRLIssuer: CERT_ALT_NAME_INFO,
};
pub const CRL_DIST_POINT = struct__CRL_DIST_POINT;
pub const PCRL_DIST_POINT = [*c]struct__CRL_DIST_POINT;
pub const struct__CRL_DIST_POINTS_INFO = extern struct {
    cDistPoint: DWORD,
    rgDistPoint: PCRL_DIST_POINT,
};
pub const CRL_DIST_POINTS_INFO = struct__CRL_DIST_POINTS_INFO;
pub const PCRL_DIST_POINTS_INFO = [*c]struct__CRL_DIST_POINTS_INFO;
pub const struct__CROSS_CERT_DIST_POINTS_INFO = extern struct {
    dwSyncDeltaTime: DWORD,
    cDistPoint: DWORD,
    rgDistPoint: PCERT_ALT_NAME_INFO,
};
pub const CROSS_CERT_DIST_POINTS_INFO = struct__CROSS_CERT_DIST_POINTS_INFO;
pub const PCROSS_CERT_DIST_POINTS_INFO = [*c]struct__CROSS_CERT_DIST_POINTS_INFO;
pub const struct__CERT_PAIR = extern struct {
    Forward: CERT_BLOB,
    Reverse: CERT_BLOB,
};
pub const CERT_PAIR = struct__CERT_PAIR;
pub const PCERT_PAIR = [*c]struct__CERT_PAIR;
pub const struct__CRL_ISSUING_DIST_POINT = extern struct {
    DistPointName: CRL_DIST_POINT_NAME,
    fOnlyContainsUserCerts: BOOL,
    fOnlyContainsCACerts: BOOL,
    OnlySomeReasonFlags: CRYPT_BIT_BLOB,
    fIndirectCRL: BOOL,
};
pub const CRL_ISSUING_DIST_POINT = struct__CRL_ISSUING_DIST_POINT;
pub const PCRL_ISSUING_DIST_POINT = [*c]struct__CRL_ISSUING_DIST_POINT;
pub const struct__CERT_GENERAL_SUBTREE = extern struct {
    Base: CERT_ALT_NAME_ENTRY,
    dwMinimum: DWORD,
    fMaximum: BOOL,
    dwMaximum: DWORD,
};
pub const CERT_GENERAL_SUBTREE = struct__CERT_GENERAL_SUBTREE;
pub const PCERT_GENERAL_SUBTREE = [*c]struct__CERT_GENERAL_SUBTREE;
pub const struct__CERT_NAME_CONSTRAINTS_INFO = extern struct {
    cPermittedSubtree: DWORD,
    rgPermittedSubtree: PCERT_GENERAL_SUBTREE,
    cExcludedSubtree: DWORD,
    rgExcludedSubtree: PCERT_GENERAL_SUBTREE,
};
pub const CERT_NAME_CONSTRAINTS_INFO = struct__CERT_NAME_CONSTRAINTS_INFO;
pub const PCERT_NAME_CONSTRAINTS_INFO = [*c]struct__CERT_NAME_CONSTRAINTS_INFO;
pub const struct__CERT_DSS_PARAMETERS = extern struct {
    p: CRYPT_UINT_BLOB,
    q: CRYPT_UINT_BLOB,
    g: CRYPT_UINT_BLOB,
};
pub const CERT_DSS_PARAMETERS = struct__CERT_DSS_PARAMETERS;
pub const PCERT_DSS_PARAMETERS = [*c]struct__CERT_DSS_PARAMETERS;
pub const struct__CERT_DH_PARAMETERS = extern struct {
    p: CRYPT_UINT_BLOB,
    g: CRYPT_UINT_BLOB,
};
pub const CERT_DH_PARAMETERS = struct__CERT_DH_PARAMETERS;
pub const PCERT_DH_PARAMETERS = [*c]struct__CERT_DH_PARAMETERS;
pub const struct__CERT_ECC_SIGNATURE = extern struct {
    r: CRYPT_UINT_BLOB,
    s: CRYPT_UINT_BLOB,
};
pub const CERT_ECC_SIGNATURE = struct__CERT_ECC_SIGNATURE;
pub const PCERT_ECC_SIGNATURE = [*c]struct__CERT_ECC_SIGNATURE;
pub const struct__CERT_X942_DH_VALIDATION_PARAMS = extern struct {
    seed: CRYPT_BIT_BLOB,
    pgenCounter: DWORD,
};
pub const CERT_X942_DH_VALIDATION_PARAMS = struct__CERT_X942_DH_VALIDATION_PARAMS;
pub const PCERT_X942_DH_VALIDATION_PARAMS = [*c]struct__CERT_X942_DH_VALIDATION_PARAMS;
pub const struct__CERT_X942_DH_PARAMETERS = extern struct {
    p: CRYPT_UINT_BLOB,
    g: CRYPT_UINT_BLOB,
    q: CRYPT_UINT_BLOB,
    j: CRYPT_UINT_BLOB,
    pValidationParams: PCERT_X942_DH_VALIDATION_PARAMS,
};
pub const CERT_X942_DH_PARAMETERS = struct__CERT_X942_DH_PARAMETERS;
pub const PCERT_X942_DH_PARAMETERS = [*c]struct__CERT_X942_DH_PARAMETERS;
pub const struct__CRYPT_X942_OTHER_INFO = extern struct {
    pszContentEncryptionObjId: LPSTR,
    rgbCounter: [4]BYTE,
    rgbKeyLength: [4]BYTE,
    PubInfo: CRYPT_DATA_BLOB,
};
pub const CRYPT_X942_OTHER_INFO = struct__CRYPT_X942_OTHER_INFO;
pub const PCRYPT_X942_OTHER_INFO = [*c]struct__CRYPT_X942_OTHER_INFO;
pub const struct__CRYPT_ECC_CMS_SHARED_INFO = extern struct {
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EntityUInfo: CRYPT_DATA_BLOB,
    rgbSuppPubInfo: [4]BYTE,
};
pub const CRYPT_ECC_CMS_SHARED_INFO = struct__CRYPT_ECC_CMS_SHARED_INFO;
pub const PCRYPT_ECC_CMS_SHARED_INFO = [*c]struct__CRYPT_ECC_CMS_SHARED_INFO;
pub const struct__CRYPT_RC2_CBC_PARAMETERS = extern struct {
    dwVersion: DWORD,
    fIV: BOOL,
    rgbIV: [8]BYTE,
};
pub const CRYPT_RC2_CBC_PARAMETERS = struct__CRYPT_RC2_CBC_PARAMETERS;
pub const PCRYPT_RC2_CBC_PARAMETERS = [*c]struct__CRYPT_RC2_CBC_PARAMETERS;
pub const struct__CRYPT_SMIME_CAPABILITY = extern struct {
    pszObjId: LPSTR,
    Parameters: CRYPT_OBJID_BLOB,
};
pub const CRYPT_SMIME_CAPABILITY = struct__CRYPT_SMIME_CAPABILITY;
pub const PCRYPT_SMIME_CAPABILITY = [*c]struct__CRYPT_SMIME_CAPABILITY;
pub const struct__CRYPT_SMIME_CAPABILITIES = extern struct {
    cCapability: DWORD,
    rgCapability: PCRYPT_SMIME_CAPABILITY,
};
pub const CRYPT_SMIME_CAPABILITIES = struct__CRYPT_SMIME_CAPABILITIES;
pub const PCRYPT_SMIME_CAPABILITIES = [*c]struct__CRYPT_SMIME_CAPABILITIES;
pub const struct__CERT_QC_STATEMENT = extern struct {
    pszStatementId: LPSTR,
    StatementInfo: CRYPT_OBJID_BLOB,
};
pub const CERT_QC_STATEMENT = struct__CERT_QC_STATEMENT;
pub const PCERT_QC_STATEMENT = [*c]struct__CERT_QC_STATEMENT;
pub const struct__CERT_QC_STATEMENTS_EXT_INFO = extern struct {
    cStatement: DWORD,
    rgStatement: PCERT_QC_STATEMENT,
};
pub const CERT_QC_STATEMENTS_EXT_INFO = struct__CERT_QC_STATEMENTS_EXT_INFO;
pub const PCERT_QC_STATEMENTS_EXT_INFO = [*c]struct__CERT_QC_STATEMENTS_EXT_INFO;
pub const struct__CRYPT_MASK_GEN_ALGORITHM = extern struct {
    pszObjId: LPSTR,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
};
pub const CRYPT_MASK_GEN_ALGORITHM = struct__CRYPT_MASK_GEN_ALGORITHM;
pub const PCRYPT_MASK_GEN_ALGORITHM = [*c]struct__CRYPT_MASK_GEN_ALGORITHM;
pub const struct__CRYPT_RSA_SSA_PSS_PARAMETERS = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    MaskGenAlgorithm: CRYPT_MASK_GEN_ALGORITHM,
    dwSaltLength: DWORD,
    dwTrailerField: DWORD,
};
pub const CRYPT_RSA_SSA_PSS_PARAMETERS = struct__CRYPT_RSA_SSA_PSS_PARAMETERS;
pub const PCRYPT_RSA_SSA_PSS_PARAMETERS = [*c]struct__CRYPT_RSA_SSA_PSS_PARAMETERS;
pub const struct__CRYPT_PSOURCE_ALGORITHM = extern struct {
    pszObjId: LPSTR,
    EncodingParameters: CRYPT_DATA_BLOB,
};
pub const CRYPT_PSOURCE_ALGORITHM = struct__CRYPT_PSOURCE_ALGORITHM;
pub const PCRYPT_PSOURCE_ALGORITHM = [*c]struct__CRYPT_PSOURCE_ALGORITHM;
pub const struct__CRYPT_RSAES_OAEP_PARAMETERS = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    MaskGenAlgorithm: CRYPT_MASK_GEN_ALGORITHM,
    PSourceAlgorithm: CRYPT_PSOURCE_ALGORITHM,
};
pub const CRYPT_RSAES_OAEP_PARAMETERS = struct__CRYPT_RSAES_OAEP_PARAMETERS;
pub const PCRYPT_RSAES_OAEP_PARAMETERS = [*c]struct__CRYPT_RSAES_OAEP_PARAMETERS;
pub const struct__CMC_TAGGED_ATTRIBUTE = extern struct {
    dwBodyPartID: DWORD,
    Attribute: CRYPT_ATTRIBUTE,
};
pub const CMC_TAGGED_ATTRIBUTE = struct__CMC_TAGGED_ATTRIBUTE;
pub const PCMC_TAGGED_ATTRIBUTE = [*c]struct__CMC_TAGGED_ATTRIBUTE;
pub const struct__CMC_TAGGED_CERT_REQUEST = extern struct {
    dwBodyPartID: DWORD,
    SignedCertRequest: CRYPT_DER_BLOB,
};
pub const CMC_TAGGED_CERT_REQUEST = struct__CMC_TAGGED_CERT_REQUEST;
pub const PCMC_TAGGED_CERT_REQUEST = [*c]struct__CMC_TAGGED_CERT_REQUEST;
pub const struct__CMC_TAGGED_REQUEST = extern struct {
    dwTaggedRequestChoice: DWORD,
    @"": extern union {
        pTaggedCertRequest: PCMC_TAGGED_CERT_REQUEST,
    },
};
pub const CMC_TAGGED_REQUEST = struct__CMC_TAGGED_REQUEST;
pub const PCMC_TAGGED_REQUEST = [*c]struct__CMC_TAGGED_REQUEST;
pub const struct__CMC_TAGGED_CONTENT_INFO = extern struct {
    dwBodyPartID: DWORD,
    EncodedContentInfo: CRYPT_DER_BLOB,
};
pub const CMC_TAGGED_CONTENT_INFO = struct__CMC_TAGGED_CONTENT_INFO;
pub const PCMC_TAGGED_CONTENT_INFO = [*c]struct__CMC_TAGGED_CONTENT_INFO;
pub const struct__CMC_TAGGED_OTHER_MSG = extern struct {
    dwBodyPartID: DWORD,
    pszObjId: LPSTR,
    Value: CRYPT_OBJID_BLOB,
};
pub const CMC_TAGGED_OTHER_MSG = struct__CMC_TAGGED_OTHER_MSG;
pub const PCMC_TAGGED_OTHER_MSG = [*c]struct__CMC_TAGGED_OTHER_MSG;
pub const struct__CMC_DATA_INFO = extern struct {
    cTaggedAttribute: DWORD,
    rgTaggedAttribute: PCMC_TAGGED_ATTRIBUTE,
    cTaggedRequest: DWORD,
    rgTaggedRequest: PCMC_TAGGED_REQUEST,
    cTaggedContentInfo: DWORD,
    rgTaggedContentInfo: PCMC_TAGGED_CONTENT_INFO,
    cTaggedOtherMsg: DWORD,
    rgTaggedOtherMsg: PCMC_TAGGED_OTHER_MSG,
};
pub const CMC_DATA_INFO = struct__CMC_DATA_INFO;
pub const PCMC_DATA_INFO = [*c]struct__CMC_DATA_INFO;
pub const struct__CMC_RESPONSE_INFO = extern struct {
    cTaggedAttribute: DWORD,
    rgTaggedAttribute: PCMC_TAGGED_ATTRIBUTE,
    cTaggedContentInfo: DWORD,
    rgTaggedContentInfo: PCMC_TAGGED_CONTENT_INFO,
    cTaggedOtherMsg: DWORD,
    rgTaggedOtherMsg: PCMC_TAGGED_OTHER_MSG,
};
pub const CMC_RESPONSE_INFO = struct__CMC_RESPONSE_INFO;
pub const PCMC_RESPONSE_INFO = [*c]struct__CMC_RESPONSE_INFO;
pub const struct__CMC_PEND_INFO = extern struct {
    PendToken: CRYPT_DATA_BLOB,
    PendTime: FILETIME,
};
pub const CMC_PEND_INFO = struct__CMC_PEND_INFO;
pub const PCMC_PEND_INFO = [*c]struct__CMC_PEND_INFO;
pub const struct__CMC_STATUS_INFO = extern struct {
    dwStatus: DWORD,
    cBodyList: DWORD,
    rgdwBodyList: [*c]DWORD,
    pwszStatusString: LPWSTR,
    dwOtherInfoChoice: DWORD,
    @"": extern union {
        dwFailInfo: DWORD,
        pPendInfo: PCMC_PEND_INFO,
    },
};
pub const CMC_STATUS_INFO = struct__CMC_STATUS_INFO;
pub const PCMC_STATUS_INFO = [*c]struct__CMC_STATUS_INFO;
pub const struct__CMC_ADD_EXTENSIONS_INFO = extern struct {
    dwCmcDataReference: DWORD,
    cCertReference: DWORD,
    rgdwCertReference: [*c]DWORD,
    cExtension: DWORD,
    rgExtension: PCERT_EXTENSION,
};
pub const CMC_ADD_EXTENSIONS_INFO = struct__CMC_ADD_EXTENSIONS_INFO;
pub const PCMC_ADD_EXTENSIONS_INFO = [*c]struct__CMC_ADD_EXTENSIONS_INFO;
pub const struct__CMC_ADD_ATTRIBUTES_INFO = extern struct {
    dwCmcDataReference: DWORD,
    cCertReference: DWORD,
    rgdwCertReference: [*c]DWORD,
    cAttribute: DWORD,
    rgAttribute: PCRYPT_ATTRIBUTE,
};
pub const CMC_ADD_ATTRIBUTES_INFO = struct__CMC_ADD_ATTRIBUTES_INFO;
pub const PCMC_ADD_ATTRIBUTES_INFO = [*c]struct__CMC_ADD_ATTRIBUTES_INFO;
pub const struct__CERT_TEMPLATE_EXT = extern struct {
    pszObjId: LPSTR,
    dwMajorVersion: DWORD,
    fMinorVersion: BOOL,
    dwMinorVersion: DWORD,
};
pub const CERT_TEMPLATE_EXT = struct__CERT_TEMPLATE_EXT;
pub const PCERT_TEMPLATE_EXT = [*c]struct__CERT_TEMPLATE_EXT;
pub const struct__CERT_HASHED_URL = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Hash: CRYPT_HASH_BLOB,
    pwszUrl: LPWSTR,
};
pub const CERT_HASHED_URL = struct__CERT_HASHED_URL;
pub const PCERT_HASHED_URL = [*c]struct__CERT_HASHED_URL;
pub const struct__CERT_LOGOTYPE_DETAILS = extern struct {
    pwszMimeType: LPWSTR,
    cHashedUrl: DWORD,
    rgHashedUrl: PCERT_HASHED_URL,
};
pub const CERT_LOGOTYPE_DETAILS = struct__CERT_LOGOTYPE_DETAILS;
pub const PCERT_LOGOTYPE_DETAILS = [*c]struct__CERT_LOGOTYPE_DETAILS;
pub const struct__CERT_LOGOTYPE_REFERENCE = extern struct {
    cHashedUrl: DWORD,
    rgHashedUrl: PCERT_HASHED_URL,
};
pub const CERT_LOGOTYPE_REFERENCE = struct__CERT_LOGOTYPE_REFERENCE;
pub const PCERT_LOGOTYPE_REFERENCE = [*c]struct__CERT_LOGOTYPE_REFERENCE;
pub const struct__CERT_LOGOTYPE_IMAGE_INFO = extern struct {
    dwLogotypeImageInfoChoice: DWORD,
    dwFileSize: DWORD,
    dwXSize: DWORD,
    dwYSize: DWORD,
    dwLogotypeImageResolutionChoice: DWORD,
    @"": extern union {
        dwNumBits: DWORD,
        dwTableSize: DWORD,
    },
    pwszLanguage: LPWSTR,
};
pub const CERT_LOGOTYPE_IMAGE_INFO = struct__CERT_LOGOTYPE_IMAGE_INFO;
pub const PCERT_LOGOTYPE_IMAGE_INFO = [*c]struct__CERT_LOGOTYPE_IMAGE_INFO;
pub const struct__CERT_LOGOTYPE_IMAGE = extern struct {
    LogotypeDetails: CERT_LOGOTYPE_DETAILS,
    pLogotypeImageInfo: PCERT_LOGOTYPE_IMAGE_INFO,
};
pub const CERT_LOGOTYPE_IMAGE = struct__CERT_LOGOTYPE_IMAGE;
pub const PCERT_LOGOTYPE_IMAGE = [*c]struct__CERT_LOGOTYPE_IMAGE;
pub const struct__CERT_LOGOTYPE_AUDIO_INFO = extern struct {
    dwFileSize: DWORD,
    dwPlayTime: DWORD,
    dwChannels: DWORD,
    dwSampleRate: DWORD,
    pwszLanguage: LPWSTR,
};
pub const CERT_LOGOTYPE_AUDIO_INFO = struct__CERT_LOGOTYPE_AUDIO_INFO;
pub const PCERT_LOGOTYPE_AUDIO_INFO = [*c]struct__CERT_LOGOTYPE_AUDIO_INFO;
pub const struct__CERT_LOGOTYPE_AUDIO = extern struct {
    LogotypeDetails: CERT_LOGOTYPE_DETAILS,
    pLogotypeAudioInfo: PCERT_LOGOTYPE_AUDIO_INFO,
};
pub const CERT_LOGOTYPE_AUDIO = struct__CERT_LOGOTYPE_AUDIO;
pub const PCERT_LOGOTYPE_AUDIO = [*c]struct__CERT_LOGOTYPE_AUDIO;
pub const struct__CERT_LOGOTYPE_DATA = extern struct {
    cLogotypeImage: DWORD,
    rgLogotypeImage: PCERT_LOGOTYPE_IMAGE,
    cLogotypeAudio: DWORD,
    rgLogotypeAudio: PCERT_LOGOTYPE_AUDIO,
};
pub const CERT_LOGOTYPE_DATA = struct__CERT_LOGOTYPE_DATA;
pub const PCERT_LOGOTYPE_DATA = [*c]struct__CERT_LOGOTYPE_DATA;
pub const struct__CERT_LOGOTYPE_INFO = extern struct {
    dwLogotypeInfoChoice: DWORD,
    @"": extern union {
        pLogotypeDirectInfo: PCERT_LOGOTYPE_DATA,
        pLogotypeIndirectInfo: PCERT_LOGOTYPE_REFERENCE,
    },
};
pub const CERT_LOGOTYPE_INFO = struct__CERT_LOGOTYPE_INFO;
pub const PCERT_LOGOTYPE_INFO = [*c]struct__CERT_LOGOTYPE_INFO;
pub const struct__CERT_OTHER_LOGOTYPE_INFO = extern struct {
    pszObjId: LPSTR,
    LogotypeInfo: CERT_LOGOTYPE_INFO,
};
pub const CERT_OTHER_LOGOTYPE_INFO = struct__CERT_OTHER_LOGOTYPE_INFO;
pub const PCERT_OTHER_LOGOTYPE_INFO = [*c]struct__CERT_OTHER_LOGOTYPE_INFO;
pub const struct__CERT_LOGOTYPE_EXT_INFO = extern struct {
    cCommunityLogo: DWORD,
    rgCommunityLogo: PCERT_LOGOTYPE_INFO,
    pIssuerLogo: PCERT_LOGOTYPE_INFO,
    pSubjectLogo: PCERT_LOGOTYPE_INFO,
    cOtherLogo: DWORD,
    rgOtherLogo: PCERT_OTHER_LOGOTYPE_INFO,
};
pub const CERT_LOGOTYPE_EXT_INFO = struct__CERT_LOGOTYPE_EXT_INFO;
pub const PCERT_LOGOTYPE_EXT_INFO = [*c]struct__CERT_LOGOTYPE_EXT_INFO;
pub const struct__CERT_BIOMETRIC_DATA = extern struct {
    dwTypeOfBiometricDataChoice: DWORD,
    @"": extern union {
        dwPredefined: DWORD,
        pszObjId: LPSTR,
    },
    HashedUrl: CERT_HASHED_URL,
};
pub const CERT_BIOMETRIC_DATA = struct__CERT_BIOMETRIC_DATA;
pub const PCERT_BIOMETRIC_DATA = [*c]struct__CERT_BIOMETRIC_DATA;
pub const struct__CERT_BIOMETRIC_EXT_INFO = extern struct {
    cBiometricData: DWORD,
    rgBiometricData: PCERT_BIOMETRIC_DATA,
};
pub const CERT_BIOMETRIC_EXT_INFO = struct__CERT_BIOMETRIC_EXT_INFO;
pub const PCERT_BIOMETRIC_EXT_INFO = [*c]struct__CERT_BIOMETRIC_EXT_INFO;
pub const struct__OCSP_SIGNATURE_INFO = extern struct {
    SignatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Signature: CRYPT_BIT_BLOB,
    cCertEncoded: DWORD,
    rgCertEncoded: PCERT_BLOB,
};
pub const OCSP_SIGNATURE_INFO = struct__OCSP_SIGNATURE_INFO;
pub const POCSP_SIGNATURE_INFO = [*c]struct__OCSP_SIGNATURE_INFO;
pub const struct__OCSP_SIGNED_REQUEST_INFO = extern struct {
    ToBeSigned: CRYPT_DER_BLOB,
    pOptionalSignatureInfo: POCSP_SIGNATURE_INFO,
};
pub const OCSP_SIGNED_REQUEST_INFO = struct__OCSP_SIGNED_REQUEST_INFO;
pub const POCSP_SIGNED_REQUEST_INFO = [*c]struct__OCSP_SIGNED_REQUEST_INFO;
pub const struct__OCSP_CERT_ID = extern struct {
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    IssuerNameHash: CRYPT_HASH_BLOB,
    IssuerKeyHash: CRYPT_HASH_BLOB,
    SerialNumber: CRYPT_INTEGER_BLOB,
};
pub const OCSP_CERT_ID = struct__OCSP_CERT_ID;
pub const POCSP_CERT_ID = [*c]struct__OCSP_CERT_ID;
pub const struct__OCSP_REQUEST_ENTRY = extern struct {
    CertId: OCSP_CERT_ID,
    cExtension: DWORD,
    rgExtension: PCERT_EXTENSION,
};
pub const OCSP_REQUEST_ENTRY = struct__OCSP_REQUEST_ENTRY;
pub const POCSP_REQUEST_ENTRY = [*c]struct__OCSP_REQUEST_ENTRY;
pub const struct__OCSP_REQUEST_INFO = extern struct {
    dwVersion: DWORD,
    pRequestorName: PCERT_ALT_NAME_ENTRY,
    cRequestEntry: DWORD,
    rgRequestEntry: POCSP_REQUEST_ENTRY,
    cExtension: DWORD,
    rgExtension: PCERT_EXTENSION,
};
pub const OCSP_REQUEST_INFO = struct__OCSP_REQUEST_INFO;
pub const POCSP_REQUEST_INFO = [*c]struct__OCSP_REQUEST_INFO;
pub const struct__OCSP_RESPONSE_INFO = extern struct {
    dwStatus: DWORD,
    pszObjId: LPSTR,
    Value: CRYPT_OBJID_BLOB,
};
pub const OCSP_RESPONSE_INFO = struct__OCSP_RESPONSE_INFO;
pub const POCSP_RESPONSE_INFO = [*c]struct__OCSP_RESPONSE_INFO;
pub const struct__OCSP_BASIC_SIGNED_RESPONSE_INFO = extern struct {
    ToBeSigned: CRYPT_DER_BLOB,
    SignatureInfo: OCSP_SIGNATURE_INFO,
};
pub const OCSP_BASIC_SIGNED_RESPONSE_INFO = struct__OCSP_BASIC_SIGNED_RESPONSE_INFO;
pub const POCSP_BASIC_SIGNED_RESPONSE_INFO = [*c]struct__OCSP_BASIC_SIGNED_RESPONSE_INFO;
pub const struct__OCSP_BASIC_REVOKED_INFO = extern struct {
    RevocationDate: FILETIME,
    dwCrlReasonCode: DWORD,
};
pub const OCSP_BASIC_REVOKED_INFO = struct__OCSP_BASIC_REVOKED_INFO;
pub const POCSP_BASIC_REVOKED_INFO = [*c]struct__OCSP_BASIC_REVOKED_INFO;
pub const struct__OCSP_BASIC_RESPONSE_ENTRY = extern struct {
    CertId: OCSP_CERT_ID,
    dwCertStatus: DWORD,
    @"": extern union {
        pRevokedInfo: POCSP_BASIC_REVOKED_INFO,
    },
    ThisUpdate: FILETIME,
    NextUpdate: FILETIME,
    cExtension: DWORD,
    rgExtension: PCERT_EXTENSION,
};
pub const OCSP_BASIC_RESPONSE_ENTRY = struct__OCSP_BASIC_RESPONSE_ENTRY;
pub const POCSP_BASIC_RESPONSE_ENTRY = [*c]struct__OCSP_BASIC_RESPONSE_ENTRY;
pub const struct__OCSP_BASIC_RESPONSE_INFO = extern struct {
    dwVersion: DWORD,
    dwResponderIdChoice: DWORD,
    @"": extern union {
        ByNameResponderId: CERT_NAME_BLOB,
        ByKeyResponderId: CRYPT_HASH_BLOB,
    },
    ProducedAt: FILETIME,
    cResponseEntry: DWORD,
    rgResponseEntry: POCSP_BASIC_RESPONSE_ENTRY,
    cExtension: DWORD,
    rgExtension: PCERT_EXTENSION,
};
pub const OCSP_BASIC_RESPONSE_INFO = struct__OCSP_BASIC_RESPONSE_INFO;
pub const POCSP_BASIC_RESPONSE_INFO = [*c]struct__OCSP_BASIC_RESPONSE_INFO;
pub const struct__CERT_SUPPORTED_ALGORITHM_INFO = extern struct {
    Algorithm: CRYPT_ALGORITHM_IDENTIFIER,
    IntendedKeyUsage: CRYPT_BIT_BLOB,
    IntendedCertPolicies: CERT_POLICIES_INFO,
};
pub const CERT_SUPPORTED_ALGORITHM_INFO = struct__CERT_SUPPORTED_ALGORITHM_INFO;
pub const PCERT_SUPPORTED_ALGORITHM_INFO = [*c]struct__CERT_SUPPORTED_ALGORITHM_INFO;
pub const struct__CERT_TPM_SPECIFICATION_INFO = extern struct {
    pwszFamily: LPWSTR,
    dwLevel: DWORD,
    dwRevision: DWORD,
};
pub const CERT_TPM_SPECIFICATION_INFO = struct__CERT_TPM_SPECIFICATION_INFO;
pub const PCERT_TPM_SPECIFICATION_INFO = [*c]struct__CERT_TPM_SPECIFICATION_INFO;
pub const HCRYPTOIDFUNCSET = ?*c_void;
pub const HCRYPTOIDFUNCADDR = ?*c_void;
pub const struct__CRYPT_OID_FUNC_ENTRY = extern struct {
    pszOID: LPCSTR,
    pvFuncAddr: ?*c_void,
};
pub const CRYPT_OID_FUNC_ENTRY = struct__CRYPT_OID_FUNC_ENTRY;
pub const PCRYPT_OID_FUNC_ENTRY = [*c]struct__CRYPT_OID_FUNC_ENTRY;
pub extern "crypt32" fn CryptInstallOIDFunctionAddress(hModule: HMODULE, dwEncodingType: DWORD, pszFuncName: LPCSTR, cFuncEntry: DWORD, rgFuncEntry: [*c]const CRYPT_OID_FUNC_ENTRY, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptInitOIDFunctionSet(pszFuncName: LPCSTR, dwFlags: DWORD) callconv(.Stdcall) HCRYPTOIDFUNCSET;
pub extern "crypt32" fn CryptGetOIDFunctionAddress(hFuncSet: HCRYPTOIDFUNCSET, dwEncodingType: DWORD, pszOID: LPCSTR, dwFlags: DWORD, ppvFuncAddr: [*c](?*c_void), phFuncAddr: [*c]HCRYPTOIDFUNCADDR) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptGetDefaultOIDDllList(hFuncSet: HCRYPTOIDFUNCSET, dwEncodingType: DWORD, pwszDllList: [*c]WCHAR, pcchDllList: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptGetDefaultOIDFunctionAddress(hFuncSet: HCRYPTOIDFUNCSET, dwEncodingType: DWORD, pwszDll: LPCWSTR, dwFlags: DWORD, ppvFuncAddr: [*c](?*c_void), phFuncAddr: [*c]HCRYPTOIDFUNCADDR) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptFreeOIDFunctionAddress(hFuncAddr: HCRYPTOIDFUNCADDR, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptRegisterOIDFunction(dwEncodingType: DWORD, pszFuncName: LPCSTR, pszOID: LPCSTR, pwszDll: LPCWSTR, pszOverrideFuncName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptUnregisterOIDFunction(dwEncodingType: DWORD, pszFuncName: LPCSTR, pszOID: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptRegisterDefaultOIDFunction(dwEncodingType: DWORD, pszFuncName: LPCSTR, dwIndex: DWORD, pwszDll: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptUnregisterDefaultOIDFunction(dwEncodingType: DWORD, pszFuncName: LPCSTR, pwszDll: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptSetOIDFunctionValue(dwEncodingType: DWORD, pszFuncName: LPCSTR, pszOID: LPCSTR, pwszValueName: LPCWSTR, dwValueType: DWORD, pbValueData: [*c]const BYTE, cbValueData: DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptGetOIDFunctionValue(dwEncodingType: DWORD, pszFuncName: LPCSTR, pszOID: LPCSTR, pwszValueName: LPCWSTR, pdwValueType: [*c]DWORD, pbValueData: [*c]BYTE, pcbValueData: [*c]DWORD) callconv(.Stdcall) BOOL;
pub const PFN_CRYPT_ENUM_OID_FUNC = ?fn (DWORD, LPCSTR, LPCSTR, DWORD, [*c]const DWORD, [*c]const LPCWSTR, [*c]const ([*c]const BYTE), [*c]const DWORD, ?*c_void) callconv(.C) BOOL;
pub extern "crypt32" fn CryptEnumOIDFunction(dwEncodingType: DWORD, pszFuncName: LPCSTR, pszOID: LPCSTR, dwFlags: DWORD, pvArg: ?*c_void, pfnEnumOIDFunc: PFN_CRYPT_ENUM_OID_FUNC) callconv(.Stdcall) BOOL;
pub const struct__CRYPT_OID_INFO = extern struct {
    cbSize: DWORD,
    pszOID: LPCSTR,
    pwszName: LPCWSTR,
    dwGroupId: DWORD,
    @"": extern union {
        dwValue: DWORD,
        Algid: ALG_ID,
        dwLength: DWORD,
    },
    ExtraInfo: CRYPT_DATA_BLOB,
};
pub const CRYPT_OID_INFO = struct__CRYPT_OID_INFO;
pub const PCRYPT_OID_INFO = [*c]struct__CRYPT_OID_INFO;
pub const CCRYPT_OID_INFO = CRYPT_OID_INFO;
pub const PCCRYPT_OID_INFO = [*c]const CRYPT_OID_INFO;
pub extern "crypt32" fn CryptFindOIDInfo(dwKeyType: DWORD, pvKey: ?*c_void, dwGroupId: DWORD) callconv(.Stdcall) PCCRYPT_OID_INFO;
pub extern "crypt32" fn CryptRegisterOIDInfo(pInfo: PCCRYPT_OID_INFO, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptUnregisterOIDInfo(pInfo: PCCRYPT_OID_INFO) callconv(.Stdcall) BOOL;
pub const PFN_CRYPT_ENUM_OID_INFO = ?fn (PCCRYPT_OID_INFO, ?*c_void) callconv(.C) BOOL;
pub extern "crypt32" fn CryptEnumOIDInfo(dwGroupId: DWORD, dwFlags: DWORD, pvArg: ?*c_void, pfnEnumOIDInfo: PFN_CRYPT_ENUM_OID_INFO) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptFindLocalizedName(pwszCryptName: LPCWSTR) callconv(.Stdcall) LPCWSTR;
pub const struct__CERT_STRONG_SIGN_SERIALIZED_INFO = extern struct {
    dwFlags: DWORD,
    pwszCNGSignHashAlgids: LPWSTR,
    pwszCNGPubKeyMinBitLengths: LPWSTR,
};
pub const CERT_STRONG_SIGN_SERIALIZED_INFO = struct__CERT_STRONG_SIGN_SERIALIZED_INFO;
pub const PCERT_STRONG_SIGN_SERIALIZED_INFO = [*c]struct__CERT_STRONG_SIGN_SERIALIZED_INFO;
pub const struct__CERT_STRONG_SIGN_PARA = extern struct {
    cbSize: DWORD,
    dwInfoChoice: DWORD,
    @"": extern union {
        pvInfo: ?*c_void,
        pSerializedInfo: PCERT_STRONG_SIGN_SERIALIZED_INFO,
        pszOID: LPSTR,
    },
};
pub const CERT_STRONG_SIGN_PARA = struct__CERT_STRONG_SIGN_PARA;
pub const PCERT_STRONG_SIGN_PARA = [*c]struct__CERT_STRONG_SIGN_PARA;
pub const PCCERT_STRONG_SIGN_PARA = [*c]const CERT_STRONG_SIGN_PARA;
pub const HCRYPTMSG = ?*c_void;
pub const struct__CERT_ISSUER_SERIAL_NUMBER = extern struct {
    Issuer: CERT_NAME_BLOB,
    SerialNumber: CRYPT_INTEGER_BLOB,
};
pub const CERT_ISSUER_SERIAL_NUMBER = struct__CERT_ISSUER_SERIAL_NUMBER;
pub const PCERT_ISSUER_SERIAL_NUMBER = [*c]struct__CERT_ISSUER_SERIAL_NUMBER;
pub const struct__CERT_ID = extern struct {
    dwIdChoice: DWORD,
    @"": extern union {
        IssuerSerialNumber: CERT_ISSUER_SERIAL_NUMBER,
        KeyId: CRYPT_HASH_BLOB,
        HashId: CRYPT_HASH_BLOB,
    },
};
pub const CERT_ID = struct__CERT_ID;
pub const PCERT_ID = [*c]struct__CERT_ID;
pub const struct__CMSG_SIGNER_ENCODE_INFO = extern struct {
    cbSize: DWORD,
    pCertInfo: PCERT_INFO,
    @"": extern union {
        hCryptProv: HCRYPTPROV,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: DWORD,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*c_void,
    cAuthAttr: DWORD,
    rgAuthAttr: PCRYPT_ATTRIBUTE,
    cUnauthAttr: DWORD,
    rgUnauthAttr: PCRYPT_ATTRIBUTE,
};
pub const CMSG_SIGNER_ENCODE_INFO = struct__CMSG_SIGNER_ENCODE_INFO;
pub const PCMSG_SIGNER_ENCODE_INFO = [*c]struct__CMSG_SIGNER_ENCODE_INFO;
pub const struct__CMSG_SIGNED_ENCODE_INFO = extern struct {
    cbSize: DWORD,
    cSigners: DWORD,
    rgSigners: PCMSG_SIGNER_ENCODE_INFO,
    cCertEncoded: DWORD,
    rgCertEncoded: PCERT_BLOB,
    cCrlEncoded: DWORD,
    rgCrlEncoded: PCRL_BLOB,
};
pub const CMSG_SIGNED_ENCODE_INFO = struct__CMSG_SIGNED_ENCODE_INFO;
pub const PCMSG_SIGNED_ENCODE_INFO = [*c]struct__CMSG_SIGNED_ENCODE_INFO;
pub const struct__CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = extern struct {
    cbSize: DWORD,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyEncryptionAuxInfo: ?*c_void,
    hCryptProv: HCRYPTPROV_LEGACY,
    RecipientPublicKey: CRYPT_BIT_BLOB,
    RecipientId: CERT_ID,
};
pub const PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = [*c]struct__CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO;
pub const struct__CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = extern struct {
    cbSize: DWORD,
    RecipientPublicKey: CRYPT_BIT_BLOB,
    RecipientId: CERT_ID,
    Date: FILETIME,
    pOtherAttr: PCRYPT_ATTRIBUTE_TYPE_VALUE,
};
pub const PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = [*c]struct__CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO;
pub const struct__CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = extern struct {
    cbSize: DWORD,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyEncryptionAuxInfo: ?*c_void,
    KeyWrapAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyWrapAuxInfo: ?*c_void,
    hCryptProv: HCRYPTPROV_LEGACY,
    dwKeySpec: DWORD,
    dwKeyChoice: DWORD,
    @"": extern union {
        pEphemeralAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER,
        pSenderId: PCERT_ID,
    },
    UserKeyingMaterial: CRYPT_DATA_BLOB,
    cRecipientEncryptedKeys: DWORD,
    rgpRecipientEncryptedKeys: [*c]PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO,
};
pub const PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = [*c]struct__CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO;
pub const struct__CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = extern struct {
    cbSize: DWORD,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvKeyEncryptionAuxInfo: ?*c_void,
    hCryptProv: HCRYPTPROV,
    dwKeyChoice: DWORD,
    @"": extern union {
        hKeyEncryptionKey: HCRYPTKEY,
        pvKeyEncryptionKey: ?*c_void,
    },
    KeyId: CRYPT_DATA_BLOB,
    Date: FILETIME,
    pOtherAttr: PCRYPT_ATTRIBUTE_TYPE_VALUE,
};
pub const PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = [*c]struct__CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO;
pub const struct__CMSG_RECIPIENT_ENCODE_INFO = extern struct {
    dwRecipientChoice: DWORD,
    @"": extern union {
        pKeyTrans: PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO,
        pKeyAgree: PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO,
        pMailList: PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO,
    },
};
pub const CMSG_RECIPIENT_ENCODE_INFO = struct__CMSG_RECIPIENT_ENCODE_INFO;
pub const PCMSG_RECIPIENT_ENCODE_INFO = [*c]struct__CMSG_RECIPIENT_ENCODE_INFO;
pub const struct__CMSG_ENVELOPED_ENCODE_INFO = extern struct {
    cbSize: DWORD,
    hCryptProv: HCRYPTPROV_LEGACY,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: ?*c_void,
    cRecipients: DWORD,
    rgpRecipients: [*c]PCERT_INFO,
};
pub const CMSG_ENVELOPED_ENCODE_INFO = struct__CMSG_ENVELOPED_ENCODE_INFO;
pub const PCMSG_ENVELOPED_ENCODE_INFO = [*c]struct__CMSG_ENVELOPED_ENCODE_INFO;
pub const CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = struct__CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO;
pub const CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = struct__CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO;
pub const CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = struct__CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO;
pub const CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = struct__CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO;
pub const struct__CMSG_RC2_AUX_INFO = extern struct {
    cbSize: DWORD,
    dwBitLen: DWORD,
};
pub const CMSG_RC2_AUX_INFO = struct__CMSG_RC2_AUX_INFO;
pub const PCMSG_RC2_AUX_INFO = [*c]struct__CMSG_RC2_AUX_INFO;
pub const struct__CMSG_SP3_COMPATIBLE_AUX_INFO = extern struct {
    cbSize: DWORD,
    dwFlags: DWORD,
};
pub const CMSG_SP3_COMPATIBLE_AUX_INFO = struct__CMSG_SP3_COMPATIBLE_AUX_INFO;
pub const PCMSG_SP3_COMPATIBLE_AUX_INFO = [*c]struct__CMSG_SP3_COMPATIBLE_AUX_INFO;
pub const struct__CMSG_RC4_AUX_INFO = extern struct {
    cbSize: DWORD,
    dwBitLen: DWORD,
};
pub const CMSG_RC4_AUX_INFO = struct__CMSG_RC4_AUX_INFO;
pub const PCMSG_RC4_AUX_INFO = [*c]struct__CMSG_RC4_AUX_INFO;
pub const struct__CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = extern struct {
    cbSize: DWORD,
    SignedInfo: CMSG_SIGNED_ENCODE_INFO,
    EnvelopedInfo: CMSG_ENVELOPED_ENCODE_INFO,
};
pub const CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = struct__CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO;
pub const PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = [*c]struct__CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO;
pub const struct__CMSG_HASHED_ENCODE_INFO = extern struct {
    cbSize: DWORD,
    hCryptProv: HCRYPTPROV_LEGACY,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*c_void,
};
pub const CMSG_HASHED_ENCODE_INFO = struct__CMSG_HASHED_ENCODE_INFO;
pub const PCMSG_HASHED_ENCODE_INFO = [*c]struct__CMSG_HASHED_ENCODE_INFO;
pub const struct__CMSG_ENCRYPTED_ENCODE_INFO = extern struct {
    cbSize: DWORD,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: ?*c_void,
};
pub const CMSG_ENCRYPTED_ENCODE_INFO = struct__CMSG_ENCRYPTED_ENCODE_INFO;
pub const PCMSG_ENCRYPTED_ENCODE_INFO = [*c]struct__CMSG_ENCRYPTED_ENCODE_INFO;
pub const PFN_CMSG_STREAM_OUTPUT = ?fn (?*const c_void, [*c]BYTE, DWORD, BOOL) callconv(.C) BOOL;
pub const struct__CMSG_STREAM_INFO = extern struct {
    cbContent: DWORD,
    pfnStreamOutput: PFN_CMSG_STREAM_OUTPUT,
    pvArg: ?*c_void,
};
pub const CMSG_STREAM_INFO = struct__CMSG_STREAM_INFO;
pub const PCMSG_STREAM_INFO = [*c]struct__CMSG_STREAM_INFO;
pub extern "crypt32" fn CryptMsgOpenToEncode(dwMsgEncodingType: DWORD, dwFlags: DWORD, dwMsgType: DWORD, pvMsgEncodeInfo: ?*const c_void, pszInnerContentObjID: LPSTR, pStreamInfo: PCMSG_STREAM_INFO) callconv(.Stdcall) HCRYPTMSG;
pub extern "crypt32" fn CryptMsgCalculateEncodedLength(dwMsgEncodingType: DWORD, dwFlags: DWORD, dwMsgType: DWORD, pvMsgEncodeInfo: ?*const c_void, pszInnerContentObjID: LPSTR, cbData: DWORD) callconv(.Stdcall) DWORD;
pub extern "crypt32" fn CryptMsgOpenToDecode(dwMsgEncodingType: DWORD, dwFlags: DWORD, dwMsgType: DWORD, hCryptProv: HCRYPTPROV_LEGACY, pRecipientInfo: PCERT_INFO, pStreamInfo: PCMSG_STREAM_INFO) callconv(.Stdcall) HCRYPTMSG;
pub extern "crypt32" fn CryptMsgDuplicate(hCryptMsg: HCRYPTMSG) callconv(.Stdcall) HCRYPTMSG;
pub extern "crypt32" fn CryptMsgClose(hCryptMsg: HCRYPTMSG) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptMsgUpdate(hCryptMsg: HCRYPTMSG, pbData: [*c]const BYTE, cbData: DWORD, fFinal: BOOL) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptMsgGetParam(hCryptMsg: HCRYPTMSG, dwParamType: DWORD, dwIndex: DWORD, pvData: ?*c_void, pcbData: [*c]DWORD) callconv(.Stdcall) BOOL;
pub const struct__CMSG_SIGNER_INFO = extern struct {
    dwVersion: DWORD,
    Issuer: CERT_NAME_BLOB,
    SerialNumber: CRYPT_INTEGER_BLOB,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedHash: CRYPT_DATA_BLOB,
    AuthAttrs: CRYPT_ATTRIBUTES,
    UnauthAttrs: CRYPT_ATTRIBUTES,
};
pub const CMSG_SIGNER_INFO = struct__CMSG_SIGNER_INFO;
pub const PCMSG_SIGNER_INFO = [*c]struct__CMSG_SIGNER_INFO;
pub const struct__CMSG_CMS_SIGNER_INFO = extern struct {
    dwVersion: DWORD,
    SignerId: CERT_ID,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedHash: CRYPT_DATA_BLOB,
    AuthAttrs: CRYPT_ATTRIBUTES,
    UnauthAttrs: CRYPT_ATTRIBUTES,
};
pub const CMSG_CMS_SIGNER_INFO = struct__CMSG_CMS_SIGNER_INFO;
pub const PCMSG_CMS_SIGNER_INFO = [*c]struct__CMSG_CMS_SIGNER_INFO;
pub const CMSG_ATTR = CRYPT_ATTRIBUTES;
pub const PCMSG_ATTR = [*c]CRYPT_ATTRIBUTES;
pub const struct__CMSG_KEY_TRANS_RECIPIENT_INFO = extern struct {
    dwVersion: DWORD,
    RecipientId: CERT_ID,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPT_DATA_BLOB,
};
pub const CMSG_KEY_TRANS_RECIPIENT_INFO = struct__CMSG_KEY_TRANS_RECIPIENT_INFO;
pub const PCMSG_KEY_TRANS_RECIPIENT_INFO = [*c]struct__CMSG_KEY_TRANS_RECIPIENT_INFO;
pub const struct__CMSG_RECIPIENT_ENCRYPTED_KEY_INFO = extern struct {
    RecipientId: CERT_ID,
    EncryptedKey: CRYPT_DATA_BLOB,
    Date: FILETIME,
    pOtherAttr: PCRYPT_ATTRIBUTE_TYPE_VALUE,
};
pub const CMSG_RECIPIENT_ENCRYPTED_KEY_INFO = struct__CMSG_RECIPIENT_ENCRYPTED_KEY_INFO;
pub const PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO = [*c]struct__CMSG_RECIPIENT_ENCRYPTED_KEY_INFO;
pub const struct__CMSG_KEY_AGREE_RECIPIENT_INFO = extern struct {
    dwVersion: DWORD,
    dwOriginatorChoice: DWORD,
    @"": extern union {
        OriginatorCertId: CERT_ID,
        OriginatorPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    },
    UserKeyingMaterial: CRYPT_DATA_BLOB,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    cRecipientEncryptedKeys: DWORD,
    rgpRecipientEncryptedKeys: [*c]PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO,
};
pub const CMSG_KEY_AGREE_RECIPIENT_INFO = struct__CMSG_KEY_AGREE_RECIPIENT_INFO;
pub const PCMSG_KEY_AGREE_RECIPIENT_INFO = [*c]struct__CMSG_KEY_AGREE_RECIPIENT_INFO;
pub const struct__CMSG_MAIL_LIST_RECIPIENT_INFO = extern struct {
    dwVersion: DWORD,
    KeyId: CRYPT_DATA_BLOB,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPT_DATA_BLOB,
    Date: FILETIME,
    pOtherAttr: PCRYPT_ATTRIBUTE_TYPE_VALUE,
};
pub const CMSG_MAIL_LIST_RECIPIENT_INFO = struct__CMSG_MAIL_LIST_RECIPIENT_INFO;
pub const PCMSG_MAIL_LIST_RECIPIENT_INFO = [*c]struct__CMSG_MAIL_LIST_RECIPIENT_INFO;
pub const struct__CMSG_CMS_RECIPIENT_INFO = extern struct {
    dwRecipientChoice: DWORD,
    @"": extern union {
        pKeyTrans: PCMSG_KEY_TRANS_RECIPIENT_INFO,
        pKeyAgree: PCMSG_KEY_AGREE_RECIPIENT_INFO,
        pMailList: PCMSG_MAIL_LIST_RECIPIENT_INFO,
    },
};
pub const CMSG_CMS_RECIPIENT_INFO = struct__CMSG_CMS_RECIPIENT_INFO;
pub const PCMSG_CMS_RECIPIENT_INFO = [*c]struct__CMSG_CMS_RECIPIENT_INFO;
pub extern "crypt32" fn CryptMsgControl(hCryptMsg: HCRYPTMSG, dwFlags: DWORD, dwCtrlType: DWORD, pvCtrlPara: ?*const c_void) callconv(.Stdcall) BOOL;
pub const struct__CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = extern struct {
    cbSize: DWORD,
    hCryptProv: HCRYPTPROV_LEGACY,
    dwSignerIndex: DWORD,
    dwSignerType: DWORD,
    pvSigner: ?*c_void,
};
pub const CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = struct__CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA;
pub const PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = [*c]struct__CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA;
pub const struct__CMSG_CTRL_DECRYPT_PARA = extern struct {
    cbSize: DWORD,
    @"": extern union {
        hCryptProv: HCRYPTPROV,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: DWORD,
    dwRecipientIndex: DWORD,
};
pub const CMSG_CTRL_DECRYPT_PARA = struct__CMSG_CTRL_DECRYPT_PARA;
pub const PCMSG_CTRL_DECRYPT_PARA = [*c]struct__CMSG_CTRL_DECRYPT_PARA;
pub const struct__CMSG_CTRL_KEY_TRANS_DECRYPT_PARA = extern struct {
    cbSize: DWORD,
    @"": extern union {
        hCryptProv: HCRYPTPROV,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: DWORD,
    pKeyTrans: PCMSG_KEY_TRANS_RECIPIENT_INFO,
    dwRecipientIndex: DWORD,
};
pub const CMSG_CTRL_KEY_TRANS_DECRYPT_PARA = struct__CMSG_CTRL_KEY_TRANS_DECRYPT_PARA;
pub const PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA = [*c]struct__CMSG_CTRL_KEY_TRANS_DECRYPT_PARA;
pub const struct__CMSG_CTRL_KEY_AGREE_DECRYPT_PARA = extern struct {
    cbSize: DWORD,
    @"": extern union {
        hCryptProv: HCRYPTPROV,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: DWORD,
    pKeyAgree: PCMSG_KEY_AGREE_RECIPIENT_INFO,
    dwRecipientIndex: DWORD,
    dwRecipientEncryptedKeyIndex: DWORD,
    OriginatorPublicKey: CRYPT_BIT_BLOB,
};
pub const CMSG_CTRL_KEY_AGREE_DECRYPT_PARA = struct__CMSG_CTRL_KEY_AGREE_DECRYPT_PARA;
pub const PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA = [*c]struct__CMSG_CTRL_KEY_AGREE_DECRYPT_PARA;
pub const struct__CMSG_CTRL_MAIL_LIST_DECRYPT_PARA = extern struct {
    cbSize: DWORD,
    hCryptProv: HCRYPTPROV,
    pMailList: PCMSG_MAIL_LIST_RECIPIENT_INFO,
    dwRecipientIndex: DWORD,
    dwKeyChoice: DWORD,
    @"": extern union {
        hKeyEncryptionKey: HCRYPTKEY,
        pvKeyEncryptionKey: ?*c_void,
    },
};
pub const CMSG_CTRL_MAIL_LIST_DECRYPT_PARA = struct__CMSG_CTRL_MAIL_LIST_DECRYPT_PARA;
pub const PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA = [*c]struct__CMSG_CTRL_MAIL_LIST_DECRYPT_PARA;
pub const struct__CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = extern struct {
    cbSize: DWORD,
    dwSignerIndex: DWORD,
    blob: CRYPT_DATA_BLOB,
};
pub const CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = struct__CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA;
pub const PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = [*c]struct__CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA;
pub const struct__CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = extern struct {
    cbSize: DWORD,
    dwSignerIndex: DWORD,
    dwUnauthAttrIndex: DWORD,
};
pub const CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = struct__CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA;
pub const PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = [*c]struct__CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA;
pub extern "crypt32" fn CryptMsgVerifyCountersignatureEncoded(hCryptProv: HCRYPTPROV_LEGACY, dwEncodingType: DWORD, pbSignerInfo: PBYTE, cbSignerInfo: DWORD, pbSignerInfoCountersignature: PBYTE, cbSignerInfoCountersignature: DWORD, pciCountersigner: PCERT_INFO) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptMsgVerifyCountersignatureEncodedEx(hCryptProv: HCRYPTPROV_LEGACY, dwEncodingType: DWORD, pbSignerInfo: PBYTE, cbSignerInfo: DWORD, pbSignerInfoCountersignature: PBYTE, cbSignerInfoCountersignature: DWORD, dwSignerType: DWORD, pvSigner: ?*c_void, dwFlags: DWORD, pvExtra: ?*c_void) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptMsgCountersign(hCryptMsg: HCRYPTMSG, dwIndex: DWORD, cCountersigners: DWORD, rgCountersigners: PCMSG_SIGNER_ENCODE_INFO) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptMsgCountersignEncoded(dwEncodingType: DWORD, pbSignerInfo: PBYTE, cbSignerInfo: DWORD, cCountersigners: DWORD, rgCountersigners: PCMSG_SIGNER_ENCODE_INFO, pbCountersignature: PBYTE, pcbCountersignature: PDWORD) callconv(.Stdcall) BOOL;
pub const PFN_CMSG_ALLOC = ?fn (usize) callconv(.C) ?*c_void;
pub const PFN_CMSG_FREE = ?fn (?*c_void) callconv(.C) void;
pub const PFN_CMSG_GEN_ENCRYPT_KEY = ?fn ([*c]HCRYPTPROV, PCRYPT_ALGORITHM_IDENTIFIER, PVOID, PCERT_PUBLIC_KEY_INFO, PFN_CMSG_ALLOC, [*c]HCRYPTKEY, [*c]PBYTE, PDWORD) callconv(.C) BOOL;
pub const PFN_CMSG_EXPORT_ENCRYPT_KEY = ?fn (HCRYPTPROV, HCRYPTKEY, PCERT_PUBLIC_KEY_INFO, PBYTE, PDWORD) callconv(.C) BOOL;
pub const PFN_CMSG_IMPORT_ENCRYPT_KEY = ?fn (HCRYPTPROV, DWORD, PCRYPT_ALGORITHM_IDENTIFIER, PCRYPT_ALGORITHM_IDENTIFIER, PBYTE, DWORD, [*c]HCRYPTKEY) callconv(.C) BOOL;
pub const struct__CMSG_CONTENT_ENCRYPT_INFO = extern struct {
    cbSize: DWORD,
    hCryptProv: HCRYPTPROV_LEGACY,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: ?*c_void,
    cRecipients: DWORD,
    rgCmsRecipients: PCMSG_RECIPIENT_ENCODE_INFO,
    pfnAlloc: PFN_CMSG_ALLOC,
    pfnFree: PFN_CMSG_FREE,
    dwEncryptFlags: DWORD,
    @"": extern union {
        hContentEncryptKey: HCRYPTKEY,
        hCNGContentEncryptKey: BCRYPT_KEY_HANDLE,
    },
    dwFlags: DWORD,
    fCNG: BOOL,
    pbCNGContentEncryptKeyObject: [*c]BYTE,
    pbContentEncryptKey: [*c]BYTE,
    cbContentEncryptKey: DWORD,
};
pub const CMSG_CONTENT_ENCRYPT_INFO = struct__CMSG_CONTENT_ENCRYPT_INFO;
pub const PCMSG_CONTENT_ENCRYPT_INFO = [*c]struct__CMSG_CONTENT_ENCRYPT_INFO;
pub const PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY = ?fn (PCMSG_CONTENT_ENCRYPT_INFO, DWORD, ?*c_void) callconv(.C) BOOL;
pub const struct__CMSG_KEY_TRANS_ENCRYPT_INFO = extern struct {
    cbSize: DWORD,
    dwRecipientIndex: DWORD,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPT_DATA_BLOB,
    dwFlags: DWORD,
};
pub const CMSG_KEY_TRANS_ENCRYPT_INFO = struct__CMSG_KEY_TRANS_ENCRYPT_INFO;
pub const PCMSG_KEY_TRANS_ENCRYPT_INFO = [*c]struct__CMSG_KEY_TRANS_ENCRYPT_INFO;
pub const PFN_CMSG_EXPORT_KEY_TRANS = ?fn (PCMSG_CONTENT_ENCRYPT_INFO, PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO, PCMSG_KEY_TRANS_ENCRYPT_INFO, DWORD, ?*c_void) callconv(.C) BOOL;
pub const struct__CMSG_KEY_AGREE_KEY_ENCRYPT_INFO = extern struct {
    cbSize: DWORD,
    EncryptedKey: CRYPT_DATA_BLOB,
};
pub const CMSG_KEY_AGREE_KEY_ENCRYPT_INFO = struct__CMSG_KEY_AGREE_KEY_ENCRYPT_INFO;
pub const PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO = [*c]struct__CMSG_KEY_AGREE_KEY_ENCRYPT_INFO;
pub const struct__CMSG_KEY_AGREE_ENCRYPT_INFO = extern struct {
    cbSize: DWORD,
    dwRecipientIndex: DWORD,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    UserKeyingMaterial: CRYPT_DATA_BLOB,
    dwOriginatorChoice: DWORD,
    @"": extern union {
        OriginatorCertId: CERT_ID,
        OriginatorPublicKeyInfo: CERT_PUBLIC_KEY_INFO,
    },
    cKeyAgreeKeyEncryptInfo: DWORD,
    rgpKeyAgreeKeyEncryptInfo: [*c]PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO,
    dwFlags: DWORD,
};
pub const CMSG_KEY_AGREE_ENCRYPT_INFO = struct__CMSG_KEY_AGREE_ENCRYPT_INFO;
pub const PCMSG_KEY_AGREE_ENCRYPT_INFO = [*c]struct__CMSG_KEY_AGREE_ENCRYPT_INFO;
pub const PFN_CMSG_EXPORT_KEY_AGREE = ?fn (PCMSG_CONTENT_ENCRYPT_INFO, PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO, PCMSG_KEY_AGREE_ENCRYPT_INFO, DWORD, ?*c_void) callconv(.C) BOOL;
pub const struct__CMSG_MAIL_LIST_ENCRYPT_INFO = extern struct {
    cbSize: DWORD,
    dwRecipientIndex: DWORD,
    KeyEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    EncryptedKey: CRYPT_DATA_BLOB,
    dwFlags: DWORD,
};
pub const CMSG_MAIL_LIST_ENCRYPT_INFO = struct__CMSG_MAIL_LIST_ENCRYPT_INFO;
pub const PCMSG_MAIL_LIST_ENCRYPT_INFO = [*c]struct__CMSG_MAIL_LIST_ENCRYPT_INFO;
pub const PFN_CMSG_EXPORT_MAIL_LIST = ?fn (PCMSG_CONTENT_ENCRYPT_INFO, PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO, PCMSG_MAIL_LIST_ENCRYPT_INFO, DWORD, ?*c_void) callconv(.C) BOOL;
pub const PFN_CMSG_IMPORT_KEY_TRANS = ?fn (PCRYPT_ALGORITHM_IDENTIFIER, PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA, DWORD, ?*c_void, [*c]HCRYPTKEY) callconv(.C) BOOL;
pub const PFN_CMSG_IMPORT_KEY_AGREE = ?fn (PCRYPT_ALGORITHM_IDENTIFIER, PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA, DWORD, ?*c_void, [*c]HCRYPTKEY) callconv(.C) BOOL;
pub const PFN_CMSG_IMPORT_MAIL_LIST = ?fn (PCRYPT_ALGORITHM_IDENTIFIER, PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA, DWORD, ?*c_void, [*c]HCRYPTKEY) callconv(.C) BOOL;
pub const struct__CMSG_CNG_CONTENT_DECRYPT_INFO = extern struct {
    cbSize: DWORD,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pfnAlloc: PFN_CMSG_ALLOC,
    pfnFree: PFN_CMSG_FREE,
    hNCryptKey: NCRYPT_KEY_HANDLE,
    pbContentEncryptKey: [*c]BYTE,
    cbContentEncryptKey: DWORD,
    hCNGContentEncryptKey: BCRYPT_KEY_HANDLE,
    pbCNGContentEncryptKeyObject: [*c]BYTE,
};
pub const CMSG_CNG_CONTENT_DECRYPT_INFO = struct__CMSG_CNG_CONTENT_DECRYPT_INFO;
pub const PCMSG_CNG_CONTENT_DECRYPT_INFO = [*c]struct__CMSG_CNG_CONTENT_DECRYPT_INFO;
pub const PFN_CMSG_CNG_IMPORT_KEY_TRANS = ?fn (PCMSG_CNG_CONTENT_DECRYPT_INFO, PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA, DWORD, ?*c_void) callconv(.C) BOOL;
pub const PFN_CMSG_CNG_IMPORT_KEY_AGREE = ?fn (PCMSG_CNG_CONTENT_DECRYPT_INFO, PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA, DWORD, ?*c_void) callconv(.C) BOOL;
pub const PFN_CMSG_CNG_IMPORT_CONTENT_ENCRYPT_KEY = ?fn (PCMSG_CNG_CONTENT_DECRYPT_INFO, DWORD, ?*c_void) callconv(.C) BOOL;
pub const HCERTSTORE = ?*c_void;
pub const struct__CERT_CONTEXT = extern struct {
    dwCertEncodingType: DWORD,
    pbCertEncoded: [*c]BYTE,
    cbCertEncoded: DWORD,
    pCertInfo: PCERT_INFO,
    hCertStore: HCERTSTORE,
};
pub const CERT_CONTEXT = struct__CERT_CONTEXT;
pub const PCERT_CONTEXT = [*c]struct__CERT_CONTEXT;
pub const PCCERT_CONTEXT = [*c]const CERT_CONTEXT;
pub const struct__CRL_CONTEXT = extern struct {
    dwCertEncodingType: DWORD,
    pbCrlEncoded: [*c]BYTE,
    cbCrlEncoded: DWORD,
    pCrlInfo: PCRL_INFO,
    hCertStore: HCERTSTORE,
};
pub const CRL_CONTEXT = struct__CRL_CONTEXT;
pub const PCRL_CONTEXT = [*c]struct__CRL_CONTEXT;
pub const PCCRL_CONTEXT = [*c]const CRL_CONTEXT;
pub const struct__CTL_CONTEXT = extern struct {
    dwMsgAndCertEncodingType: DWORD,
    pbCtlEncoded: [*c]BYTE,
    cbCtlEncoded: DWORD,
    pCtlInfo: PCTL_INFO,
    hCertStore: HCERTSTORE,
    hCryptMsg: HCRYPTMSG,
    pbCtlContent: [*c]BYTE,
    cbCtlContent: DWORD,
};
pub const CTL_CONTEXT = struct__CTL_CONTEXT;
pub const PCTL_CONTEXT = [*c]struct__CTL_CONTEXT;
pub const PCCTL_CONTEXT = [*c]const CTL_CONTEXT;
pub const KeyTypeOther = enum_CertKeyType.KeyTypeOther;
pub const KeyTypeVirtualSmartCard = enum_CertKeyType.KeyTypeVirtualSmartCard;
pub const KeyTypePhysicalSmartCard = enum_CertKeyType.KeyTypePhysicalSmartCard;
pub const KeyTypePassport = enum_CertKeyType.KeyTypePassport;
pub const KeyTypePassportRemote = enum_CertKeyType.KeyTypePassportRemote;
pub const KeyTypePassportSmartCard = enum_CertKeyType.KeyTypePassportSmartCard;
pub const KeyTypeHardware = enum_CertKeyType.KeyTypeHardware;
pub const KeyTypeSoftware = enum_CertKeyType.KeyTypeSoftware;
pub const KeyTypeSelfSigned = enum_CertKeyType.KeyTypeSelfSigned;
pub const enum_CertKeyType = extern enum {
    KeyTypeOther = 0,
    KeyTypeVirtualSmartCard = 1,
    KeyTypePhysicalSmartCard = 2,
    KeyTypePassport = 3,
    KeyTypePassportRemote = 4,
    KeyTypePassportSmartCard = 5,
    KeyTypeHardware = 6,
    KeyTypeSoftware = 7,
    KeyTypeSelfSigned = 8,
};
pub const CertKeyType = enum_CertKeyType;
pub const struct__CRYPT_KEY_PROV_PARAM = extern struct {
    dwParam: DWORD,
    pbData: [*c]BYTE,
    cbData: DWORD,
    dwFlags: DWORD,
};
pub const CRYPT_KEY_PROV_PARAM = struct__CRYPT_KEY_PROV_PARAM;
pub const PCRYPT_KEY_PROV_PARAM = [*c]struct__CRYPT_KEY_PROV_PARAM;
pub const struct__CRYPT_KEY_PROV_INFO = extern struct {
    pwszContainerName: LPWSTR,
    pwszProvName: LPWSTR,
    dwProvType: DWORD,
    dwFlags: DWORD,
    cProvParam: DWORD,
    rgProvParam: PCRYPT_KEY_PROV_PARAM,
    dwKeySpec: DWORD,
};
pub const CRYPT_KEY_PROV_INFO = struct__CRYPT_KEY_PROV_INFO;
pub const PCRYPT_KEY_PROV_INFO = [*c]struct__CRYPT_KEY_PROV_INFO;
pub const struct__CERT_KEY_CONTEXT = extern struct {
    cbSize: DWORD,
    @"": extern union {
        hCryptProv: HCRYPTPROV,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: DWORD,
};
pub const CERT_KEY_CONTEXT = struct__CERT_KEY_CONTEXT;
pub const PCERT_KEY_CONTEXT = [*c]struct__CERT_KEY_CONTEXT;
pub const struct__ROOT_INFO_LUID = extern struct {
    LowPart: DWORD,
    HighPart: LONG,
};
pub const ROOT_INFO_LUID = struct__ROOT_INFO_LUID;
pub const PROOT_INFO_LUID = [*c]struct__ROOT_INFO_LUID;
pub const struct__CRYPT_SMART_CARD_ROOT_INFO = extern struct {
    rgbCardID: [16]BYTE,
    luid: ROOT_INFO_LUID,
};
pub const CRYPT_SMART_CARD_ROOT_INFO = struct__CRYPT_SMART_CARD_ROOT_INFO;
pub const PCRYPT_SMART_CARD_ROOT_INFO = [*c]struct__CRYPT_SMART_CARD_ROOT_INFO;
pub const struct__CERT_SYSTEM_STORE_RELOCATE_PARA = extern struct {
    @"": extern union {
        hKeyBase: HKEY,
        pvBase: ?*c_void,
    },
    @"": extern union {
        pvSystemStore: ?*c_void,
        pszSystemStore: LPCSTR,
        pwszSystemStore: LPCWSTR,
    },
};
pub const CERT_SYSTEM_STORE_RELOCATE_PARA = struct__CERT_SYSTEM_STORE_RELOCATE_PARA;
pub const PCERT_SYSTEM_STORE_RELOCATE_PARA = [*c]struct__CERT_SYSTEM_STORE_RELOCATE_PARA;
pub const struct__CERT_REGISTRY_STORE_CLIENT_GPT_PARA = extern struct {
    hKeyBase: HKEY,
    pwszRegPath: LPWSTR,
};
pub const CERT_REGISTRY_STORE_CLIENT_GPT_PARA = struct__CERT_REGISTRY_STORE_CLIENT_GPT_PARA;
pub const PCERT_REGISTRY_STORE_CLIENT_GPT_PARA = [*c]struct__CERT_REGISTRY_STORE_CLIENT_GPT_PARA;
pub const struct__CERT_REGISTRY_STORE_ROAMING_PARA = extern struct {
    hKey: HKEY,
    pwszStoreDirectory: LPWSTR,
};
pub const CERT_REGISTRY_STORE_ROAMING_PARA = struct__CERT_REGISTRY_STORE_ROAMING_PARA;
pub const PCERT_REGISTRY_STORE_ROAMING_PARA = [*c]struct__CERT_REGISTRY_STORE_ROAMING_PARA;
pub const struct__CERT_LDAP_STORE_OPENED_PARA = extern struct {
    pvLdapSessionHandle: ?*c_void,
    pwszLdapUrl: LPCWSTR,
};
pub const CERT_LDAP_STORE_OPENED_PARA = struct__CERT_LDAP_STORE_OPENED_PARA;
pub const PCERT_LDAP_STORE_OPENED_PARA = [*c]struct__CERT_LDAP_STORE_OPENED_PARA;
pub extern "crypt32" fn CertOpenStore(lpszStoreProvider: LPCSTR, dwEncodingType: DWORD, hCryptProv: HCRYPTPROV_LEGACY, dwFlags: DWORD, pvPara: ?*const c_void) callconv(.Stdcall) HCERTSTORE;
pub const HCERTSTOREPROV = ?*c_void;
pub const struct__CERT_STORE_PROV_INFO = extern struct {
    cbSize: DWORD,
    cStoreProvFunc: DWORD,
    rgpvStoreProvFunc: [*c](?*c_void),
    hStoreProv: HCERTSTOREPROV,
    dwStoreProvFlags: DWORD,
    hStoreProvFuncAddr2: HCRYPTOIDFUNCADDR,
};
pub const CERT_STORE_PROV_INFO = struct__CERT_STORE_PROV_INFO;
pub const PCERT_STORE_PROV_INFO = [*c]struct__CERT_STORE_PROV_INFO;
pub const PFN_CERT_DLL_OPEN_STORE_PROV_FUNC = ?fn (LPCSTR, DWORD, HCRYPTPROV_LEGACY, DWORD, ?*const c_void, HCERTSTORE, PCERT_STORE_PROV_INFO) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_CLOSE = ?fn (HCERTSTOREPROV, DWORD) callconv(.C) void;
pub const PFN_CERT_STORE_PROV_READ_CERT = ?fn (HCERTSTOREPROV, PCCERT_CONTEXT, DWORD, [*c]PCCERT_CONTEXT) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_WRITE_CERT = ?fn (HCERTSTOREPROV, PCCERT_CONTEXT, DWORD) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_DELETE_CERT = ?fn (HCERTSTOREPROV, PCCERT_CONTEXT, DWORD) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_SET_CERT_PROPERTY = ?fn (HCERTSTOREPROV, PCCERT_CONTEXT, DWORD, DWORD, ?*const c_void) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_READ_CRL = ?fn (HCERTSTOREPROV, PCCRL_CONTEXT, DWORD, [*c]PCCRL_CONTEXT) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_WRITE_CRL = ?fn (HCERTSTOREPROV, PCCRL_CONTEXT, DWORD) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_DELETE_CRL = ?fn (HCERTSTOREPROV, PCCRL_CONTEXT, DWORD) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_SET_CRL_PROPERTY = ?fn (HCERTSTOREPROV, PCCRL_CONTEXT, DWORD, DWORD, ?*const c_void) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_READ_CTL = ?fn (HCERTSTOREPROV, PCCTL_CONTEXT, DWORD, [*c]PCCTL_CONTEXT) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_WRITE_CTL = ?fn (HCERTSTOREPROV, PCCTL_CONTEXT, DWORD) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_DELETE_CTL = ?fn (HCERTSTOREPROV, PCCTL_CONTEXT, DWORD) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_SET_CTL_PROPERTY = ?fn (HCERTSTOREPROV, PCCTL_CONTEXT, DWORD, DWORD, ?*const c_void) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_CONTROL = ?fn (HCERTSTOREPROV, DWORD, DWORD, ?*const c_void) callconv(.C) BOOL;
pub const struct__CERT_STORE_PROV_FIND_INFO = extern struct {
    cbSize: DWORD,
    dwMsgAndCertEncodingType: DWORD,
    dwFindFlags: DWORD,
    dwFindType: DWORD,
    pvFindPara: ?*const c_void,
};
pub const CERT_STORE_PROV_FIND_INFO = struct__CERT_STORE_PROV_FIND_INFO;
pub const PCERT_STORE_PROV_FIND_INFO = [*c]struct__CERT_STORE_PROV_FIND_INFO;
pub const CCERT_STORE_PROV_FIND_INFO = CERT_STORE_PROV_FIND_INFO;
pub const PCCERT_STORE_PROV_FIND_INFO = [*c]const CERT_STORE_PROV_FIND_INFO;
pub const PFN_CERT_STORE_PROV_FIND_CERT = ?fn (HCERTSTOREPROV, PCCERT_STORE_PROV_FIND_INFO, PCCERT_CONTEXT, DWORD, [*c](?*c_void), [*c]PCCERT_CONTEXT) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_FREE_FIND_CERT = ?fn (HCERTSTOREPROV, PCCERT_CONTEXT, ?*c_void, DWORD) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_GET_CERT_PROPERTY = ?fn (HCERTSTOREPROV, PCCERT_CONTEXT, DWORD, DWORD, ?*c_void, [*c]DWORD) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_FIND_CRL = ?fn (HCERTSTOREPROV, PCCERT_STORE_PROV_FIND_INFO, PCCRL_CONTEXT, DWORD, [*c](?*c_void), [*c]PCCRL_CONTEXT) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_FREE_FIND_CRL = ?fn (HCERTSTOREPROV, PCCRL_CONTEXT, ?*c_void, DWORD) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_GET_CRL_PROPERTY = ?fn (HCERTSTOREPROV, PCCRL_CONTEXT, DWORD, DWORD, ?*c_void, [*c]DWORD) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_FIND_CTL = ?fn (HCERTSTOREPROV, PCCERT_STORE_PROV_FIND_INFO, PCCTL_CONTEXT, DWORD, [*c](?*c_void), [*c]PCCTL_CONTEXT) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_FREE_FIND_CTL = ?fn (HCERTSTOREPROV, PCCTL_CONTEXT, ?*c_void, DWORD) callconv(.C) BOOL;
pub const PFN_CERT_STORE_PROV_GET_CTL_PROPERTY = ?fn (HCERTSTOREPROV, PCCTL_CONTEXT, DWORD, DWORD, ?*c_void, [*c]DWORD) callconv(.C) BOOL;
pub extern "crypt32" fn CertDuplicateStore(hCertStore: HCERTSTORE) callconv(.Stdcall) HCERTSTORE;
pub extern "crypt32" fn CertSaveStore(hCertStore: HCERTSTORE, dwEncodingType: DWORD, dwSaveAs: DWORD, dwSaveTo: DWORD, pvSaveToPara: ?*c_void, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertCloseStore(hCertStore: HCERTSTORE, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertGetSubjectCertificateFromStore(hCertStore: HCERTSTORE, dwCertEncodingType: DWORD, pCertId: PCERT_INFO) callconv(.Stdcall) PCCERT_CONTEXT;
pub extern "crypt32" fn CertEnumCertificatesInStore(hCertStore: HCERTSTORE, pPrevCertContext: PCCERT_CONTEXT) callconv(.Stdcall) PCCERT_CONTEXT;
pub extern "crypt32" fn CertFindCertificateInStore(hCertStore: HCERTSTORE, dwCertEncodingType: DWORD, dwFindFlags: DWORD, dwFindType: DWORD, pvFindPara: ?*const c_void, pPrevCertContext: PCCERT_CONTEXT) callconv(.Stdcall) PCCERT_CONTEXT;
pub extern "crypt32" fn CertGetIssuerCertificateFromStore(hCertStore: HCERTSTORE, pSubjectContext: PCCERT_CONTEXT, pPrevIssuerContext: PCCERT_CONTEXT, pdwFlags: [*c]DWORD) callconv(.Stdcall) PCCERT_CONTEXT;
pub extern "crypt32" fn CertVerifySubjectCertificateContext(pSubject: PCCERT_CONTEXT, pIssuer: PCCERT_CONTEXT, pdwFlags: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertDuplicateCertificateContext(pCertContext: PCCERT_CONTEXT) callconv(.Stdcall) PCCERT_CONTEXT;
pub extern "crypt32" fn CertCreateCertificateContext(dwCertEncodingType: DWORD, pbCertEncoded: [*c]const BYTE, cbCertEncoded: DWORD) callconv(.Stdcall) PCCERT_CONTEXT;
pub extern "crypt32" fn CertFreeCertificateContext(pCertContext: PCCERT_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertSetCertificateContextProperty(pCertContext: PCCERT_CONTEXT, dwPropId: DWORD, dwFlags: DWORD, pvData: ?*const c_void) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertGetCertificateContextProperty(pCertContext: PCCERT_CONTEXT, dwPropId: DWORD, pvData: ?*c_void, pcbData: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertEnumCertificateContextProperties(pCertContext: PCCERT_CONTEXT, dwPropId: DWORD) callconv(.Stdcall) DWORD;
pub extern "crypt32" fn CertCreateCTLEntryFromCertificateContextProperties(pCertContext: PCCERT_CONTEXT, cOptAttr: DWORD, rgOptAttr: PCRYPT_ATTRIBUTE, dwFlags: DWORD, pvReserved: ?*c_void, pCtlEntry: PCTL_ENTRY, pcbCtlEntry: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertSetCertificateContextPropertiesFromCTLEntry(pCertContext: PCCERT_CONTEXT, pCtlEntry: PCTL_ENTRY, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertGetCRLFromStore(hCertStore: HCERTSTORE, pIssuerContext: PCCERT_CONTEXT, pPrevCrlContext: PCCRL_CONTEXT, pdwFlags: [*c]DWORD) callconv(.Stdcall) PCCRL_CONTEXT;
pub extern "crypt32" fn CertEnumCRLsInStore(hCertStore: HCERTSTORE, pPrevCrlContext: PCCRL_CONTEXT) callconv(.Stdcall) PCCRL_CONTEXT;
pub extern "crypt32" fn CertFindCRLInStore(hCertStore: HCERTSTORE, dwCertEncodingType: DWORD, dwFindFlags: DWORD, dwFindType: DWORD, pvFindPara: ?*const c_void, pPrevCrlContext: PCCRL_CONTEXT) callconv(.Stdcall) PCCRL_CONTEXT;
pub const struct__CRL_FIND_ISSUED_FOR_PARA = extern struct {
    pSubjectCert: PCCERT_CONTEXT,
    pIssuerCert: PCCERT_CONTEXT,
};
pub const CRL_FIND_ISSUED_FOR_PARA = struct__CRL_FIND_ISSUED_FOR_PARA;
pub const PCRL_FIND_ISSUED_FOR_PARA = [*c]struct__CRL_FIND_ISSUED_FOR_PARA;
pub extern "crypt32" fn CertDuplicateCRLContext(pCrlContext: PCCRL_CONTEXT) callconv(.Stdcall) PCCRL_CONTEXT;
pub extern "crypt32" fn CertCreateCRLContext(dwCertEncodingType: DWORD, pbCrlEncoded: [*c]const BYTE, cbCrlEncoded: DWORD) callconv(.Stdcall) PCCRL_CONTEXT;
pub extern "crypt32" fn CertFreeCRLContext(pCrlContext: PCCRL_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertSetCRLContextProperty(pCrlContext: PCCRL_CONTEXT, dwPropId: DWORD, dwFlags: DWORD, pvData: ?*const c_void) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertGetCRLContextProperty(pCrlContext: PCCRL_CONTEXT, dwPropId: DWORD, pvData: ?*c_void, pcbData: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertEnumCRLContextProperties(pCrlContext: PCCRL_CONTEXT, dwPropId: DWORD) callconv(.Stdcall) DWORD;
pub extern "crypt32" fn CertFindCertificateInCRL(pCert: PCCERT_CONTEXT, pCrlContext: PCCRL_CONTEXT, dwFlags: DWORD, pvReserved: ?*c_void, ppCrlEntry: [*c]PCRL_ENTRY) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertIsValidCRLForCertificate(pCert: PCCERT_CONTEXT, pCrl: PCCRL_CONTEXT, dwFlags: DWORD, pvReserved: ?*c_void) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertAddEncodedCertificateToStore(hCertStore: HCERTSTORE, dwCertEncodingType: DWORD, pbCertEncoded: [*c]const BYTE, cbCertEncoded: DWORD, dwAddDisposition: DWORD, ppCertContext: [*c]PCCERT_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertAddCertificateContextToStore(hCertStore: HCERTSTORE, pCertContext: PCCERT_CONTEXT, dwAddDisposition: DWORD, ppStoreContext: [*c]PCCERT_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertAddSerializedElementToStore(hCertStore: HCERTSTORE, pbElement: [*c]const BYTE, cbElement: DWORD, dwAddDisposition: DWORD, dwFlags: DWORD, dwContextTypeFlags: DWORD, pdwContextType: [*c]DWORD, ppvContext: [*c](?*const c_void)) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertDeleteCertificateFromStore(pCertContext: PCCERT_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertAddEncodedCRLToStore(hCertStore: HCERTSTORE, dwCertEncodingType: DWORD, pbCrlEncoded: [*c]const BYTE, cbCrlEncoded: DWORD, dwAddDisposition: DWORD, ppCrlContext: [*c]PCCRL_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertAddCRLContextToStore(hCertStore: HCERTSTORE, pCrlContext: PCCRL_CONTEXT, dwAddDisposition: DWORD, ppStoreContext: [*c]PCCRL_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertDeleteCRLFromStore(pCrlContext: PCCRL_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertSerializeCertificateStoreElement(pCertContext: PCCERT_CONTEXT, dwFlags: DWORD, pbElement: [*c]BYTE, pcbElement: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertSerializeCRLStoreElement(pCrlContext: PCCRL_CONTEXT, dwFlags: DWORD, pbElement: [*c]BYTE, pcbElement: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertDuplicateCTLContext(pCtlContext: PCCTL_CONTEXT) callconv(.Stdcall) PCCTL_CONTEXT;
pub extern "crypt32" fn CertCreateCTLContext(dwMsgAndCertEncodingType: DWORD, pbCtlEncoded: [*c]const BYTE, cbCtlEncoded: DWORD) callconv(.Stdcall) PCCTL_CONTEXT;
pub extern "crypt32" fn CertFreeCTLContext(pCtlContext: PCCTL_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertSetCTLContextProperty(pCtlContext: PCCTL_CONTEXT, dwPropId: DWORD, dwFlags: DWORD, pvData: ?*const c_void) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertGetCTLContextProperty(pCtlContext: PCCTL_CONTEXT, dwPropId: DWORD, pvData: ?*c_void, pcbData: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertEnumCTLContextProperties(pCtlContext: PCCTL_CONTEXT, dwPropId: DWORD) callconv(.Stdcall) DWORD;
pub extern "crypt32" fn CertEnumCTLsInStore(hCertStore: HCERTSTORE, pPrevCtlContext: PCCTL_CONTEXT) callconv(.Stdcall) PCCTL_CONTEXT;
pub extern "crypt32" fn CertFindSubjectInCTL(dwEncodingType: DWORD, dwSubjectType: DWORD, pvSubject: ?*c_void, pCtlContext: PCCTL_CONTEXT, dwFlags: DWORD) callconv(.Stdcall) PCTL_ENTRY;
pub const struct__CTL_ANY_SUBJECT_INFO = extern struct {
    SubjectAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    SubjectIdentifier: CRYPT_DATA_BLOB,
};
pub const CTL_ANY_SUBJECT_INFO = struct__CTL_ANY_SUBJECT_INFO;
pub const PCTL_ANY_SUBJECT_INFO = [*c]struct__CTL_ANY_SUBJECT_INFO;
pub extern "crypt32" fn CertFindCTLInStore(hCertStore: HCERTSTORE, dwMsgAndCertEncodingType: DWORD, dwFindFlags: DWORD, dwFindType: DWORD, pvFindPara: ?*const c_void, pPrevCtlContext: PCCTL_CONTEXT) callconv(.Stdcall) PCCTL_CONTEXT;
pub const struct__CTL_FIND_USAGE_PARA = extern struct {
    cbSize: DWORD,
    SubjectUsage: CTL_USAGE,
    ListIdentifier: CRYPT_DATA_BLOB,
    pSigner: PCERT_INFO,
};
pub const CTL_FIND_USAGE_PARA = struct__CTL_FIND_USAGE_PARA;
pub const PCTL_FIND_USAGE_PARA = [*c]struct__CTL_FIND_USAGE_PARA;
pub const struct__CTL_FIND_SUBJECT_PARA = extern struct {
    cbSize: DWORD,
    pUsagePara: PCTL_FIND_USAGE_PARA,
    dwSubjectType: DWORD,
    pvSubject: ?*c_void,
};
pub const CTL_FIND_SUBJECT_PARA = struct__CTL_FIND_SUBJECT_PARA;
pub const PCTL_FIND_SUBJECT_PARA = [*c]struct__CTL_FIND_SUBJECT_PARA;
pub extern "crypt32" fn CertAddEncodedCTLToStore(hCertStore: HCERTSTORE, dwMsgAndCertEncodingType: DWORD, pbCtlEncoded: [*c]const BYTE, cbCtlEncoded: DWORD, dwAddDisposition: DWORD, ppCtlContext: [*c]PCCTL_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertAddCTLContextToStore(hCertStore: HCERTSTORE, pCtlContext: PCCTL_CONTEXT, dwAddDisposition: DWORD, ppStoreContext: [*c]PCCTL_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertSerializeCTLStoreElement(pCtlContext: PCCTL_CONTEXT, dwFlags: DWORD, pbElement: [*c]BYTE, pcbElement: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertDeleteCTLFromStore(pCtlContext: PCCTL_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertAddCertificateLinkToStore(hCertStore: HCERTSTORE, pCertContext: PCCERT_CONTEXT, dwAddDisposition: DWORD, ppStoreContext: [*c]PCCERT_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertAddCRLLinkToStore(hCertStore: HCERTSTORE, pCrlContext: PCCRL_CONTEXT, dwAddDisposition: DWORD, ppStoreContext: [*c]PCCRL_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertAddCTLLinkToStore(hCertStore: HCERTSTORE, pCtlContext: PCCTL_CONTEXT, dwAddDisposition: DWORD, ppStoreContext: [*c]PCCTL_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertAddStoreToCollection(hCollectionStore: HCERTSTORE, hSiblingStore: HCERTSTORE, dwUpdateFlags: DWORD, dwPriority: DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertRemoveStoreFromCollection(hCollectionStore: HCERTSTORE, hSiblingStore: HCERTSTORE) callconv(.Stdcall) void;
pub extern "crypt32" fn CertControlStore(hCertStore: HCERTSTORE, dwFlags: DWORD, dwCtrlType: DWORD, pvCtrlPara: ?*const c_void) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertSetStoreProperty(hCertStore: HCERTSTORE, dwPropId: DWORD, dwFlags: DWORD, pvData: ?*const c_void) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertGetStoreProperty(hCertStore: HCERTSTORE, dwPropId: DWORD, pvData: ?*c_void, pcbData: [*c]DWORD) callconv(.Stdcall) BOOL;
pub const PFN_CERT_CREATE_CONTEXT_SORT_FUNC = ?fn (DWORD, DWORD, DWORD, ?*c_void) callconv(.C) BOOL;
pub const struct__CERT_CREATE_CONTEXT_PARA = extern struct {
    cbSize: DWORD,
    pfnFree: PFN_CRYPT_FREE,
    pvFree: ?*c_void,
    pfnSort: PFN_CERT_CREATE_CONTEXT_SORT_FUNC,
    pvSort: ?*c_void,
};
pub const CERT_CREATE_CONTEXT_PARA = struct__CERT_CREATE_CONTEXT_PARA;
pub const PCERT_CREATE_CONTEXT_PARA = [*c]struct__CERT_CREATE_CONTEXT_PARA;
pub extern "crypt32" fn CertCreateContext(dwContextType: DWORD, dwEncodingType: DWORD, pbEncoded: [*c]const BYTE, cbEncoded: DWORD, dwFlags: DWORD, pCreatePara: PCERT_CREATE_CONTEXT_PARA) callconv(.Stdcall) ?*const c_void;
pub const struct__CERT_SYSTEM_STORE_INFO = extern struct {
    cbSize: DWORD,
};
pub const CERT_SYSTEM_STORE_INFO = struct__CERT_SYSTEM_STORE_INFO;
pub const PCERT_SYSTEM_STORE_INFO = [*c]struct__CERT_SYSTEM_STORE_INFO;
pub const struct__CERT_PHYSICAL_STORE_INFO = extern struct {
    cbSize: DWORD,
    pszOpenStoreProvider: LPSTR,
    dwOpenEncodingType: DWORD,
    dwOpenFlags: DWORD,
    OpenParameters: CRYPT_DATA_BLOB,
    dwFlags: DWORD,
    dwPriority: DWORD,
};
pub const CERT_PHYSICAL_STORE_INFO = struct__CERT_PHYSICAL_STORE_INFO;
pub const PCERT_PHYSICAL_STORE_INFO = [*c]struct__CERT_PHYSICAL_STORE_INFO;
pub extern "crypt32" fn CertRegisterSystemStore(pvSystemStore: ?*const c_void, dwFlags: DWORD, pStoreInfo: PCERT_SYSTEM_STORE_INFO, pvReserved: ?*c_void) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertRegisterPhysicalStore(pvSystemStore: ?*const c_void, dwFlags: DWORD, pwszStoreName: LPCWSTR, pStoreInfo: PCERT_PHYSICAL_STORE_INFO, pvReserved: ?*c_void) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertUnregisterSystemStore(pvSystemStore: ?*const c_void, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertUnregisterPhysicalStore(pvSystemStore: ?*const c_void, dwFlags: DWORD, pwszStoreName: LPCWSTR) callconv(.Stdcall) BOOL;
pub const PFN_CERT_ENUM_SYSTEM_STORE_LOCATION = ?fn (LPCWSTR, DWORD, ?*c_void, ?*c_void) callconv(.C) BOOL;
pub const PFN_CERT_ENUM_SYSTEM_STORE = ?fn (?*const c_void, DWORD, PCERT_SYSTEM_STORE_INFO, ?*c_void, ?*c_void) callconv(.C) BOOL;
pub const PFN_CERT_ENUM_PHYSICAL_STORE = ?fn (?*const c_void, DWORD, LPCWSTR, PCERT_PHYSICAL_STORE_INFO, ?*c_void, ?*c_void) callconv(.C) BOOL;
pub extern "crypt32" fn CertEnumSystemStoreLocation(dwFlags: DWORD, pvArg: ?*c_void, pfnEnum: PFN_CERT_ENUM_SYSTEM_STORE_LOCATION) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertEnumSystemStore(dwFlags: DWORD, pvSystemStoreLocationPara: ?*c_void, pvArg: ?*c_void, pfnEnum: PFN_CERT_ENUM_SYSTEM_STORE) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertEnumPhysicalStore(pvSystemStore: ?*const c_void, dwFlags: DWORD, pvArg: ?*c_void, pfnEnum: PFN_CERT_ENUM_PHYSICAL_STORE) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertGetEnhancedKeyUsage(pCertContext: PCCERT_CONTEXT, dwFlags: DWORD, pUsage: PCERT_ENHKEY_USAGE, pcbUsage: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertSetEnhancedKeyUsage(pCertContext: PCCERT_CONTEXT, pUsage: PCERT_ENHKEY_USAGE) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertAddEnhancedKeyUsageIdentifier(pCertContext: PCCERT_CONTEXT, pszUsageIdentifier: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertRemoveEnhancedKeyUsageIdentifier(pCertContext: PCCERT_CONTEXT, pszUsageIdentifier: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertGetValidUsages(cCerts: DWORD, rghCerts: [*c]PCCERT_CONTEXT, cNumOIDs: [*c]c_int, rghOIDs: [*c]LPSTR, pcbOIDs: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptMsgGetAndVerifySigner(hCryptMsg: HCRYPTMSG, cSignerStore: DWORD, rghSignerStore: [*c]HCERTSTORE, dwFlags: DWORD, ppSigner: [*c]PCCERT_CONTEXT, pdwSignerIndex: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptMsgSignCTL(dwMsgEncodingType: DWORD, pbCtlContent: [*c]BYTE, cbCtlContent: DWORD, pSignInfo: PCMSG_SIGNED_ENCODE_INFO, dwFlags: DWORD, pbEncoded: [*c]BYTE, pcbEncoded: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptMsgEncodeAndSignCTL(dwMsgEncodingType: DWORD, pCtlInfo: PCTL_INFO, pSignInfo: PCMSG_SIGNED_ENCODE_INFO, dwFlags: DWORD, pbEncoded: [*c]BYTE, pcbEncoded: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertFindSubjectInSortedCTL(pSubjectIdentifier: PCRYPT_DATA_BLOB, pCtlContext: PCCTL_CONTEXT, dwFlags: DWORD, pvReserved: ?*c_void, pEncodedAttributes: PCRYPT_DER_BLOB) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertEnumSubjectInSortedCTL(pCtlContext: PCCTL_CONTEXT, ppvNextSubject: [*c](?*c_void), pSubjectIdentifier: PCRYPT_DER_BLOB, pEncodedAttributes: PCRYPT_DER_BLOB) callconv(.Stdcall) BOOL;
pub const struct__CTL_VERIFY_USAGE_PARA = extern struct {
    cbSize: DWORD,
    ListIdentifier: CRYPT_DATA_BLOB,
    cCtlStore: DWORD,
    rghCtlStore: [*c]HCERTSTORE,
    cSignerStore: DWORD,
    rghSignerStore: [*c]HCERTSTORE,
};
pub const CTL_VERIFY_USAGE_PARA = struct__CTL_VERIFY_USAGE_PARA;
pub const PCTL_VERIFY_USAGE_PARA = [*c]struct__CTL_VERIFY_USAGE_PARA;
pub const struct__CTL_VERIFY_USAGE_STATUS = extern struct {
    cbSize: DWORD,
    dwError: DWORD,
    dwFlags: DWORD,
    ppCtl: [*c]PCCTL_CONTEXT,
    dwCtlEntryIndex: DWORD,
    ppSigner: [*c]PCCERT_CONTEXT,
    dwSignerIndex: DWORD,
};
pub const CTL_VERIFY_USAGE_STATUS = struct__CTL_VERIFY_USAGE_STATUS;
pub const PCTL_VERIFY_USAGE_STATUS = [*c]struct__CTL_VERIFY_USAGE_STATUS;
pub extern "crypt32" fn CertVerifyCTLUsage(dwEncodingType: DWORD, dwSubjectType: DWORD, pvSubject: ?*c_void, pSubjectUsage: PCTL_USAGE, dwFlags: DWORD, pVerifyUsagePara: PCTL_VERIFY_USAGE_PARA, pVerifyUsageStatus: PCTL_VERIFY_USAGE_STATUS) callconv(.Stdcall) BOOL;
pub const struct__CERT_REVOCATION_CRL_INFO = extern struct {
    cbSize: DWORD,
    pBaseCrlContext: PCCRL_CONTEXT,
    pDeltaCrlContext: PCCRL_CONTEXT,
    pCrlEntry: PCRL_ENTRY,
    fDeltaCrlEntry: BOOL,
};
pub const CERT_REVOCATION_CRL_INFO = struct__CERT_REVOCATION_CRL_INFO;
pub const PCERT_REVOCATION_CRL_INFO = [*c]struct__CERT_REVOCATION_CRL_INFO;
pub const HCERTCHAINENGINE = HANDLE;
pub const struct__CERT_REVOCATION_CHAIN_PARA = extern struct {
    cbSize: DWORD,
    hChainEngine: HCERTCHAINENGINE,
    hAdditionalStore: HCERTSTORE,
    dwChainFlags: DWORD,
    dwUrlRetrievalTimeout: DWORD,
    pftCurrentTime: LPFILETIME,
    pftCacheResync: LPFILETIME,
    cbMaxUrlRetrievalByteCount: DWORD,
};
pub const CERT_REVOCATION_CHAIN_PARA = struct__CERT_REVOCATION_CHAIN_PARA;
pub const PCERT_REVOCATION_CHAIN_PARA = [*c]struct__CERT_REVOCATION_CHAIN_PARA;
pub const struct__CERT_REVOCATION_PARA = extern struct {
    cbSize: DWORD,
    pIssuerCert: PCCERT_CONTEXT,
    cCertStore: DWORD,
    rgCertStore: [*c]HCERTSTORE,
    hCrlStore: HCERTSTORE,
    pftTimeToUse: LPFILETIME,
};
pub const CERT_REVOCATION_PARA = struct__CERT_REVOCATION_PARA;
pub const PCERT_REVOCATION_PARA = [*c]struct__CERT_REVOCATION_PARA;
pub const struct__CERT_REVOCATION_STATUS = extern struct {
    cbSize: DWORD,
    dwIndex: DWORD,
    dwError: DWORD,
    dwReason: DWORD,
    fHasFreshnessTime: BOOL,
    dwFreshnessTime: DWORD,
};
pub const CERT_REVOCATION_STATUS = struct__CERT_REVOCATION_STATUS;
pub const PCERT_REVOCATION_STATUS = [*c]struct__CERT_REVOCATION_STATUS;
pub extern "crypt32" fn CertVerifyRevocation(dwEncodingType: DWORD, dwRevType: DWORD, cContext: DWORD, rgpvContext: [*c]PVOID, dwFlags: DWORD, pRevPara: PCERT_REVOCATION_PARA, pRevStatus: PCERT_REVOCATION_STATUS) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertCompareIntegerBlob(pInt1: PCRYPT_INTEGER_BLOB, pInt2: PCRYPT_INTEGER_BLOB) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertCompareCertificate(dwCertEncodingType: DWORD, pCertId1: PCERT_INFO, pCertId2: PCERT_INFO) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertCompareCertificateName(dwCertEncodingType: DWORD, pCertName1: PCERT_NAME_BLOB, pCertName2: PCERT_NAME_BLOB) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertIsRDNAttrsInCertificateName(dwCertEncodingType: DWORD, dwFlags: DWORD, pCertName: PCERT_NAME_BLOB, pRDN: PCERT_RDN) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertComparePublicKeyInfo(dwCertEncodingType: DWORD, pPublicKey1: PCERT_PUBLIC_KEY_INFO, pPublicKey2: PCERT_PUBLIC_KEY_INFO) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertGetPublicKeyLength(dwCertEncodingType: DWORD, pPublicKey: PCERT_PUBLIC_KEY_INFO) callconv(.Stdcall) DWORD;
pub extern "crypt32" fn CryptVerifyCertificateSignature(hCryptProv: HCRYPTPROV_LEGACY, dwCertEncodingType: DWORD, pbEncoded: [*c]const BYTE, cbEncoded: DWORD, pPublicKey: PCERT_PUBLIC_KEY_INFO) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptVerifyCertificateSignatureEx(hCryptProv: HCRYPTPROV_LEGACY, dwCertEncodingType: DWORD, dwSubjectType: DWORD, pvSubject: ?*c_void, dwIssuerType: DWORD, pvIssuer: ?*c_void, dwFlags: DWORD, pvExtra: ?*c_void) callconv(.Stdcall) BOOL;
pub const struct__CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO = extern struct {
    CertSignHashCNGAlgPropData: CRYPT_DATA_BLOB,
    CertIssuerPubKeyBitLengthPropData: CRYPT_DATA_BLOB,
};
pub const CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO = struct__CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO;
pub const PCRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO = [*c]struct__CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO;
pub const struct__CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO = extern struct {
    cCNGHashAlgid: DWORD,
    rgpwszCNGHashAlgid: [*c]PCWSTR,
    dwWeakIndex: DWORD,
};
pub const CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO = struct__CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO;
pub const PCRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO = [*c]struct__CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO;
pub extern "crypt32" fn CertIsStrongHashToSign(pStrongSignPara: PCCERT_STRONG_SIGN_PARA, pwszCNGHashAlgid: LPCWSTR, pSigningCert: PCCERT_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptHashToBeSigned(hCryptProv: HCRYPTPROV_LEGACY, dwCertEncodingType: DWORD, pbEncoded: [*c]const BYTE, cbEncoded: DWORD, pbComputedHash: [*c]BYTE, pcbComputedHash: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptHashCertificate(hCryptProv: HCRYPTPROV_LEGACY, Algid: ALG_ID, dwFlags: DWORD, pbEncoded: [*c]const BYTE, cbEncoded: DWORD, pbComputedHash: [*c]BYTE, pcbComputedHash: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptHashCertificate2(pwszCNGHashAlgid: LPCWSTR, dwFlags: DWORD, pvReserved: ?*c_void, pbEncoded: [*c]const BYTE, cbEncoded: DWORD, pbComputedHash: [*c]BYTE, pcbComputedHash: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptSignCertificate(hCryptProvOrNCryptKey: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE, dwKeySpec: DWORD, dwCertEncodingType: DWORD, pbEncodedToBeSigned: [*c]const BYTE, cbEncodedToBeSigned: DWORD, pSignatureAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER, pvHashAuxInfo: ?*const c_void, pbSignature: [*c]BYTE, pcbSignature: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptSignAndEncodeCertificate(hCryptProvOrNCryptKey: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE, dwKeySpec: DWORD, dwCertEncodingType: DWORD, lpszStructType: LPCSTR, pvStructInfo: ?*const c_void, pSignatureAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER, pvHashAuxInfo: ?*const c_void, pbEncoded: [*c]BYTE, pcbEncoded: [*c]DWORD) callconv(.Stdcall) BOOL;
pub const PFN_CRYPT_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC = ?fn (DWORD, PCRYPT_ALGORITHM_IDENTIFIER, [*c](?*c_void), [*c]LPWSTR) callconv(.C) BOOL;
pub const PFN_CRYPT_SIGN_AND_ENCODE_HASH_FUNC = ?fn (NCRYPT_KEY_HANDLE, DWORD, PCRYPT_ALGORITHM_IDENTIFIER, ?*c_void, LPCWSTR, LPCWSTR, [*c]BYTE, DWORD, [*c]BYTE, [*c]DWORD) callconv(.C) BOOL;
pub const PFN_CRYPT_VERIFY_ENCODED_SIGNATURE_FUNC = ?fn (DWORD, PCERT_PUBLIC_KEY_INFO, PCRYPT_ALGORITHM_IDENTIFIER, ?*c_void, LPCWSTR, LPCWSTR, [*c]BYTE, DWORD, [*c]BYTE, DWORD) callconv(.C) BOOL;
pub extern "crypt32" fn CertVerifyTimeValidity(pTimeToVerify: LPFILETIME, pCertInfo: PCERT_INFO) callconv(.Stdcall) LONG;
pub extern "crypt32" fn CertVerifyCRLTimeValidity(pTimeToVerify: LPFILETIME, pCrlInfo: PCRL_INFO) callconv(.Stdcall) LONG;
pub extern "crypt32" fn CertVerifyValidityNesting(pSubjectInfo: PCERT_INFO, pIssuerInfo: PCERT_INFO) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertVerifyCRLRevocation(dwCertEncodingType: DWORD, pCertId: PCERT_INFO, cCrlInfo: DWORD, rgpCrlInfo: [*c]PCRL_INFO) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertAlgIdToOID(dwAlgId: DWORD) callconv(.Stdcall) LPCSTR;
pub extern "crypt32" fn CertOIDToAlgId(pszObjId: LPCSTR) callconv(.Stdcall) DWORD;
pub extern "crypt32" fn CertFindExtension(pszObjId: LPCSTR, cExtensions: DWORD, rgExtensions: [*c]CERT_EXTENSION) callconv(.Stdcall) PCERT_EXTENSION;
pub extern "crypt32" fn CertFindAttribute(pszObjId: LPCSTR, cAttr: DWORD, rgAttr: [*c]CRYPT_ATTRIBUTE) callconv(.Stdcall) PCRYPT_ATTRIBUTE;
pub extern "crypt32" fn CertFindRDNAttr(pszObjId: LPCSTR, pName: PCERT_NAME_INFO) callconv(.Stdcall) PCERT_RDN_ATTR;
pub extern "crypt32" fn CertGetIntendedKeyUsage(dwCertEncodingType: DWORD, pCertInfo: PCERT_INFO, pbKeyUsage: [*c]BYTE, cbKeyUsage: DWORD) callconv(.Stdcall) BOOL;
pub const HCRYPTDEFAULTCONTEXT = ?*c_void;
pub extern "crypt32" fn CryptInstallDefaultContext(hCryptProv: HCRYPTPROV, dwDefaultType: DWORD, pvDefaultPara: ?*const c_void, dwFlags: DWORD, pvReserved: ?*c_void, phDefaultContext: [*c]HCRYPTDEFAULTCONTEXT) callconv(.Stdcall) BOOL;
pub const struct__CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = extern struct {
    cOID: DWORD,
    rgpszOID: [*c]LPSTR,
};
pub const CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = struct__CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA;
pub const PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = [*c]struct__CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA;
pub extern "crypt32" fn CryptUninstallDefaultContext(hDefaultContext: HCRYPTDEFAULTCONTEXT, dwFlags: DWORD, pvReserved: ?*c_void) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptExportPublicKeyInfo(hCryptProvOrNCryptKey: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE, dwKeySpec: DWORD, dwCertEncodingType: DWORD, pInfo: PCERT_PUBLIC_KEY_INFO, pcbInfo: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptExportPublicKeyInfoEx(hCryptProvOrNCryptKey: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE, dwKeySpec: DWORD, dwCertEncodingType: DWORD, pszPublicKeyObjId: LPSTR, dwFlags: DWORD, pvAuxInfo: ?*c_void, pInfo: PCERT_PUBLIC_KEY_INFO, pcbInfo: [*c]DWORD) callconv(.Stdcall) BOOL;
pub const PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC = ?fn (NCRYPT_KEY_HANDLE, DWORD, LPSTR, DWORD, ?*c_void, PCERT_PUBLIC_KEY_INFO, [*c]DWORD) callconv(.C) BOOL;
pub extern "crypt32" fn CryptExportPublicKeyInfoFromBCryptKeyHandle(hBCryptKey: BCRYPT_KEY_HANDLE, dwCertEncodingType: DWORD, pszPublicKeyObjId: LPSTR, dwFlags: DWORD, pvAuxInfo: ?*c_void, pInfo: PCERT_PUBLIC_KEY_INFO, pcbInfo: [*c]DWORD) callconv(.Stdcall) BOOL;
pub const PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC = ?fn (BCRYPT_KEY_HANDLE, DWORD, LPSTR, DWORD, ?*c_void, PCERT_PUBLIC_KEY_INFO, [*c]DWORD) callconv(.C) BOOL;
pub extern "crypt32" fn CryptImportPublicKeyInfo(hCryptProv: HCRYPTPROV, dwCertEncodingType: DWORD, pInfo: PCERT_PUBLIC_KEY_INFO, phKey: [*c]HCRYPTKEY) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptImportPublicKeyInfoEx(hCryptProv: HCRYPTPROV, dwCertEncodingType: DWORD, pInfo: PCERT_PUBLIC_KEY_INFO, aiKeyAlg: ALG_ID, dwFlags: DWORD, pvAuxInfo: ?*c_void, phKey: [*c]HCRYPTKEY) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptImportPublicKeyInfoEx2(dwCertEncodingType: DWORD, pInfo: PCERT_PUBLIC_KEY_INFO, dwFlags: DWORD, pvAuxInfo: ?*c_void, phKey: [*c]BCRYPT_KEY_HANDLE) callconv(.Stdcall) BOOL;
pub const PFN_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC = ?fn (DWORD, PCERT_PUBLIC_KEY_INFO, DWORD, ?*c_void, [*c]BCRYPT_KEY_HANDLE) callconv(.C) BOOL;
pub extern "crypt32" fn CryptAcquireCertificatePrivateKey(pCert: PCCERT_CONTEXT, dwFlags: DWORD, pvParameters: ?*c_void, phCryptProvOrNCryptKey: [*c]HCRYPTPROV_OR_NCRYPT_KEY_HANDLE, pdwKeySpec: [*c]DWORD, pfCallerFreeProvOrNCryptKey: [*c]BOOL) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptFindCertificateKeyProvInfo(pCert: PCCERT_CONTEXT, dwFlags: DWORD, pvReserved: ?*c_void) callconv(.Stdcall) BOOL;
pub const PFN_IMPORT_PRIV_KEY_FUNC = ?fn (HCRYPTPROV, [*c]CRYPT_PRIVATE_KEY_INFO, DWORD, ?*c_void) callconv(.C) BOOL;
pub extern "crypt32" fn CryptImportPKCS8(sPrivateKeyAndParams: CRYPT_PKCS8_IMPORT_PARAMS, dwFlags: DWORD, phCryptProv: [*c]HCRYPTPROV, pvAuxInfo: ?*c_void) callconv(.Stdcall) BOOL;
pub const PFN_EXPORT_PRIV_KEY_FUNC = ?fn (HCRYPTPROV, DWORD, LPSTR, DWORD, ?*c_void, [*c]CRYPT_PRIVATE_KEY_INFO, [*c]DWORD) callconv(.C) BOOL;
pub extern "crypt32" fn CryptExportPKCS8(hCryptProv: HCRYPTPROV, dwKeySpec: DWORD, pszPrivateKeyObjId: LPSTR, dwFlags: DWORD, pvAuxInfo: ?*c_void, pbPrivateKeyBlob: [*c]BYTE, pcbPrivateKeyBlob: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptExportPKCS8Ex(psExportParams: [*c]CRYPT_PKCS8_EXPORT_PARAMS, dwFlags: DWORD, pvAuxInfo: ?*c_void, pbPrivateKeyBlob: [*c]BYTE, pcbPrivateKeyBlob: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptHashPublicKeyInfo(hCryptProv: HCRYPTPROV_LEGACY, Algid: ALG_ID, dwFlags: DWORD, dwCertEncodingType: DWORD, pInfo: PCERT_PUBLIC_KEY_INFO, pbComputedHash: [*c]BYTE, pcbComputedHash: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertRDNValueToStrA(dwValueType: DWORD, pValue: PCERT_RDN_VALUE_BLOB, psz: LPSTR, csz: DWORD) callconv(.Stdcall) DWORD;
pub extern "crypt32" fn CertRDNValueToStrW(dwValueType: DWORD, pValue: PCERT_RDN_VALUE_BLOB, psz: LPWSTR, csz: DWORD) callconv(.Stdcall) DWORD;
pub extern "crypt32" fn CertNameToStrA(dwCertEncodingType: DWORD, pName: PCERT_NAME_BLOB, dwStrType: DWORD, psz: LPSTR, csz: DWORD) callconv(.Stdcall) DWORD;
pub extern "crypt32" fn CertNameToStrW(dwCertEncodingType: DWORD, pName: PCERT_NAME_BLOB, dwStrType: DWORD, psz: LPWSTR, csz: DWORD) callconv(.Stdcall) DWORD;
pub extern "crypt32" fn CertStrToNameA(dwCertEncodingType: DWORD, pszX500: LPCSTR, dwStrType: DWORD, pvReserved: ?*c_void, pbEncoded: [*c]BYTE, pcbEncoded: [*c]DWORD, ppszError: [*c]LPCSTR) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertStrToNameW(dwCertEncodingType: DWORD, pszX500: LPCWSTR, dwStrType: DWORD, pvReserved: ?*c_void, pbEncoded: [*c]BYTE, pcbEncoded: [*c]DWORD, ppszError: [*c]LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertGetNameStringA(pCertContext: PCCERT_CONTEXT, dwType: DWORD, dwFlags: DWORD, pvTypePara: ?*c_void, pszNameString: LPSTR, cchNameString: DWORD) callconv(.Stdcall) DWORD;
pub extern "crypt32" fn CertGetNameStringW(pCertContext: PCCERT_CONTEXT, dwType: DWORD, dwFlags: DWORD, pvTypePara: ?*c_void, pszNameString: LPWSTR, cchNameString: DWORD) callconv(.Stdcall) DWORD;
pub const PFN_CRYPT_GET_SIGNER_CERTIFICATE = ?fn (?*c_void, DWORD, PCERT_INFO, HCERTSTORE) callconv(.C) PCCERT_CONTEXT;
pub const struct__CRYPT_SIGN_MESSAGE_PARA = extern struct {
    cbSize: DWORD,
    dwMsgEncodingType: DWORD,
    pSigningCert: PCCERT_CONTEXT,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*c_void,
    cMsgCert: DWORD,
    rgpMsgCert: [*c]PCCERT_CONTEXT,
    cMsgCrl: DWORD,
    rgpMsgCrl: [*c]PCCRL_CONTEXT,
    cAuthAttr: DWORD,
    rgAuthAttr: PCRYPT_ATTRIBUTE,
    cUnauthAttr: DWORD,
    rgUnauthAttr: PCRYPT_ATTRIBUTE,
    dwFlags: DWORD,
    dwInnerContentType: DWORD,
};
pub const CRYPT_SIGN_MESSAGE_PARA = struct__CRYPT_SIGN_MESSAGE_PARA;
pub const PCRYPT_SIGN_MESSAGE_PARA = [*c]struct__CRYPT_SIGN_MESSAGE_PARA;
pub const struct__CRYPT_VERIFY_MESSAGE_PARA = extern struct {
    cbSize: DWORD,
    dwMsgAndCertEncodingType: DWORD,
    hCryptProv: HCRYPTPROV_LEGACY,
    pfnGetSignerCertificate: PFN_CRYPT_GET_SIGNER_CERTIFICATE,
    pvGetArg: ?*c_void,
};
pub const CRYPT_VERIFY_MESSAGE_PARA = struct__CRYPT_VERIFY_MESSAGE_PARA;
pub const PCRYPT_VERIFY_MESSAGE_PARA = [*c]struct__CRYPT_VERIFY_MESSAGE_PARA;
pub const struct__CRYPT_ENCRYPT_MESSAGE_PARA = extern struct {
    cbSize: DWORD,
    dwMsgEncodingType: DWORD,
    hCryptProv: HCRYPTPROV_LEGACY,
    ContentEncryptionAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvEncryptionAuxInfo: ?*c_void,
    dwFlags: DWORD,
    dwInnerContentType: DWORD,
};
pub const CRYPT_ENCRYPT_MESSAGE_PARA = struct__CRYPT_ENCRYPT_MESSAGE_PARA;
pub const PCRYPT_ENCRYPT_MESSAGE_PARA = [*c]struct__CRYPT_ENCRYPT_MESSAGE_PARA;
pub const struct__CRYPT_DECRYPT_MESSAGE_PARA = extern struct {
    cbSize: DWORD,
    dwMsgAndCertEncodingType: DWORD,
    cCertStore: DWORD,
    rghCertStore: [*c]HCERTSTORE,
};
pub const CRYPT_DECRYPT_MESSAGE_PARA = struct__CRYPT_DECRYPT_MESSAGE_PARA;
pub const PCRYPT_DECRYPT_MESSAGE_PARA = [*c]struct__CRYPT_DECRYPT_MESSAGE_PARA;
pub const struct__CRYPT_HASH_MESSAGE_PARA = extern struct {
    cbSize: DWORD,
    dwMsgEncodingType: DWORD,
    hCryptProv: HCRYPTPROV_LEGACY,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*c_void,
};
pub const CRYPT_HASH_MESSAGE_PARA = struct__CRYPT_HASH_MESSAGE_PARA;
pub const PCRYPT_HASH_MESSAGE_PARA = [*c]struct__CRYPT_HASH_MESSAGE_PARA;
pub const struct__CRYPT_KEY_SIGN_MESSAGE_PARA = extern struct {
    cbSize: DWORD,
    dwMsgAndCertEncodingType: DWORD,
    @"": extern union {
        hCryptProv: HCRYPTPROV,
        hNCryptKey: NCRYPT_KEY_HANDLE,
    },
    dwKeySpec: DWORD,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    pvHashAuxInfo: ?*c_void,
    PubKeyAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
};
pub const CRYPT_KEY_SIGN_MESSAGE_PARA = struct__CRYPT_KEY_SIGN_MESSAGE_PARA;
pub const PCRYPT_KEY_SIGN_MESSAGE_PARA = [*c]struct__CRYPT_KEY_SIGN_MESSAGE_PARA;
pub const struct__CRYPT_KEY_VERIFY_MESSAGE_PARA = extern struct {
    cbSize: DWORD,
    dwMsgEncodingType: DWORD,
    hCryptProv: HCRYPTPROV_LEGACY,
};
pub const CRYPT_KEY_VERIFY_MESSAGE_PARA = struct__CRYPT_KEY_VERIFY_MESSAGE_PARA;
pub const PCRYPT_KEY_VERIFY_MESSAGE_PARA = [*c]struct__CRYPT_KEY_VERIFY_MESSAGE_PARA;
pub extern "crypt32" fn CryptSignMessage(pSignPara: PCRYPT_SIGN_MESSAGE_PARA, fDetachedSignature: BOOL, cToBeSigned: DWORD, rgpbToBeSigned: [*c]([*c]const BYTE), rgcbToBeSigned: [*c]DWORD, pbSignedBlob: [*c]BYTE, pcbSignedBlob: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptVerifyMessageSignature(pVerifyPara: PCRYPT_VERIFY_MESSAGE_PARA, dwSignerIndex: DWORD, pbSignedBlob: [*c]const BYTE, cbSignedBlob: DWORD, pbDecoded: [*c]BYTE, pcbDecoded: [*c]DWORD, ppSignerCert: [*c]PCCERT_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptGetMessageSignerCount(dwMsgEncodingType: DWORD, pbSignedBlob: [*c]const BYTE, cbSignedBlob: DWORD) callconv(.Stdcall) LONG;
pub extern "crypt32" fn CryptGetMessageCertificates(dwMsgAndCertEncodingType: DWORD, hCryptProv: HCRYPTPROV_LEGACY, dwFlags: DWORD, pbSignedBlob: [*c]const BYTE, cbSignedBlob: DWORD) callconv(.Stdcall) HCERTSTORE;
pub extern "crypt32" fn CryptVerifyDetachedMessageSignature(pVerifyPara: PCRYPT_VERIFY_MESSAGE_PARA, dwSignerIndex: DWORD, pbDetachedSignBlob: [*c]const BYTE, cbDetachedSignBlob: DWORD, cToBeSigned: DWORD, rgpbToBeSigned: [*c]([*c]const BYTE), rgcbToBeSigned: [*c]DWORD, ppSignerCert: [*c]PCCERT_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptEncryptMessage(pEncryptPara: PCRYPT_ENCRYPT_MESSAGE_PARA, cRecipientCert: DWORD, rgpRecipientCert: [*c]PCCERT_CONTEXT, pbToBeEncrypted: [*c]const BYTE, cbToBeEncrypted: DWORD, pbEncryptedBlob: [*c]BYTE, pcbEncryptedBlob: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptDecryptMessage(pDecryptPara: PCRYPT_DECRYPT_MESSAGE_PARA, pbEncryptedBlob: [*c]const BYTE, cbEncryptedBlob: DWORD, pbDecrypted: [*c]BYTE, pcbDecrypted: [*c]DWORD, ppXchgCert: [*c]PCCERT_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptSignAndEncryptMessage(pSignPara: PCRYPT_SIGN_MESSAGE_PARA, pEncryptPara: PCRYPT_ENCRYPT_MESSAGE_PARA, cRecipientCert: DWORD, rgpRecipientCert: [*c]PCCERT_CONTEXT, pbToBeSignedAndEncrypted: [*c]const BYTE, cbToBeSignedAndEncrypted: DWORD, pbSignedAndEncryptedBlob: [*c]BYTE, pcbSignedAndEncryptedBlob: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptDecryptAndVerifyMessageSignature(pDecryptPara: PCRYPT_DECRYPT_MESSAGE_PARA, pVerifyPara: PCRYPT_VERIFY_MESSAGE_PARA, dwSignerIndex: DWORD, pbEncryptedBlob: [*c]const BYTE, cbEncryptedBlob: DWORD, pbDecrypted: [*c]BYTE, pcbDecrypted: [*c]DWORD, ppXchgCert: [*c]PCCERT_CONTEXT, ppSignerCert: [*c]PCCERT_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptDecodeMessage(dwMsgTypeFlags: DWORD, pDecryptPara: PCRYPT_DECRYPT_MESSAGE_PARA, pVerifyPara: PCRYPT_VERIFY_MESSAGE_PARA, dwSignerIndex: DWORD, pbEncodedBlob: [*c]const BYTE, cbEncodedBlob: DWORD, dwPrevInnerContentType: DWORD, pdwMsgType: [*c]DWORD, pdwInnerContentType: [*c]DWORD, pbDecoded: [*c]BYTE, pcbDecoded: [*c]DWORD, ppXchgCert: [*c]PCCERT_CONTEXT, ppSignerCert: [*c]PCCERT_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptHashMessage(pHashPara: PCRYPT_HASH_MESSAGE_PARA, fDetachedHash: BOOL, cToBeHashed: DWORD, rgpbToBeHashed: [*c]([*c]const BYTE), rgcbToBeHashed: [*c]DWORD, pbHashedBlob: [*c]BYTE, pcbHashedBlob: [*c]DWORD, pbComputedHash: [*c]BYTE, pcbComputedHash: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptVerifyMessageHash(pHashPara: PCRYPT_HASH_MESSAGE_PARA, pbHashedBlob: [*c]BYTE, cbHashedBlob: DWORD, pbToBeHashed: [*c]BYTE, pcbToBeHashed: [*c]DWORD, pbComputedHash: [*c]BYTE, pcbComputedHash: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptVerifyDetachedMessageHash(pHashPara: PCRYPT_HASH_MESSAGE_PARA, pbDetachedHashBlob: [*c]BYTE, cbDetachedHashBlob: DWORD, cToBeHashed: DWORD, rgpbToBeHashed: [*c]([*c]const BYTE), rgcbToBeHashed: [*c]DWORD, pbComputedHash: [*c]BYTE, pcbComputedHash: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptSignMessageWithKey(pSignPara: PCRYPT_KEY_SIGN_MESSAGE_PARA, pbToBeSigned: [*c]const BYTE, cbToBeSigned: DWORD, pbSignedBlob: [*c]BYTE, pcbSignedBlob: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptVerifyMessageSignatureWithKey(pVerifyPara: PCRYPT_KEY_VERIFY_MESSAGE_PARA, pPublicKeyInfo: PCERT_PUBLIC_KEY_INFO, pbSignedBlob: [*c]const BYTE, cbSignedBlob: DWORD, pbDecoded: [*c]BYTE, pcbDecoded: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertOpenSystemStoreA(hProv: HCRYPTPROV_LEGACY, szSubsystemProtocol: LPCSTR) callconv(.Stdcall) HCERTSTORE;
pub extern "crypt32" fn CertOpenSystemStoreW(hProv: HCRYPTPROV_LEGACY, szSubsystemProtocol: LPCWSTR) callconv(.Stdcall) HCERTSTORE;
pub extern "crypt32" fn CertAddEncodedCertificateToSystemStoreA(szCertStoreName: LPCSTR, pbCertEncoded: [*c]const BYTE, cbCertEncoded: DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertAddEncodedCertificateToSystemStoreW(szCertStoreName: LPCWSTR, pbCertEncoded: [*c]const BYTE, cbCertEncoded: DWORD) callconv(.Stdcall) BOOL;
pub const struct__CERT_CHAIN = extern struct {
    cCerts: DWORD,
    certs: PCERT_BLOB,
    keyLocatorInfo: CRYPT_KEY_PROV_INFO,
};
pub const CERT_CHAIN = struct__CERT_CHAIN;
pub const PCERT_CHAIN = [*c]struct__CERT_CHAIN;
pub extern "crypt32" fn FindCertsByIssuer(pCertChains: PCERT_CHAIN, pcbCertChains: [*c]DWORD, pcCertChains: [*c]DWORD, pbEncodedIssuerName: [*c]BYTE, cbEncodedIssuerName: DWORD, pwszPurpose: LPCWSTR, dwKeySpec: DWORD) callconv(.Stdcall) HRESULT;
pub extern "crypt32" fn CryptQueryObject(dwObjectType: DWORD, pvObject: ?*const c_void, dwExpectedContentTypeFlags: DWORD, dwExpectedFormatTypeFlags: DWORD, dwFlags: DWORD, pdwMsgAndCertEncodingType: [*c]DWORD, pdwContentType: [*c]DWORD, pdwFormatType: [*c]DWORD, phCertStore: [*c]HCERTSTORE, phMsg: [*c]HCRYPTMSG, ppvContext: [*c](?*const c_void)) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptMemAlloc(cbSize: ULONG) callconv(.Stdcall) LPVOID;
pub extern "crypt32" fn CryptMemRealloc(pv: LPVOID, cbSize: ULONG) callconv(.Stdcall) LPVOID;
pub extern "crypt32" fn CryptMemFree(pv: LPVOID) callconv(.Stdcall) void;
pub const HCRYPTASYNC = HANDLE;
pub const PHCRYPTASYNC = [*c]HANDLE;
pub const PFN_CRYPT_ASYNC_PARAM_FREE_FUNC = ?fn (LPSTR, LPVOID) callconv(.C) void;
pub extern "crypt32" fn CryptCreateAsyncHandle(dwFlags: DWORD, phAsync: PHCRYPTASYNC) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptSetAsyncParam(hAsync: HCRYPTASYNC, pszParamOid: LPSTR, pvParam: LPVOID, pfnFree: PFN_CRYPT_ASYNC_PARAM_FREE_FUNC) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptGetAsyncParam(hAsync: HCRYPTASYNC, pszParamOid: LPSTR, ppvParam: [*c]LPVOID, ppfnFree: [*c]PFN_CRYPT_ASYNC_PARAM_FREE_FUNC) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptCloseAsyncHandle(hAsync: HCRYPTASYNC) callconv(.Stdcall) BOOL;
pub const struct__CRYPT_BLOB_ARRAY = extern struct {
    cBlob: DWORD,
    rgBlob: PCRYPT_DATA_BLOB,
};
pub const CRYPT_BLOB_ARRAY = struct__CRYPT_BLOB_ARRAY;
pub const PCRYPT_BLOB_ARRAY = [*c]struct__CRYPT_BLOB_ARRAY;
pub const struct__CRYPT_CREDENTIALS = extern struct {
    cbSize: DWORD,
    pszCredentialsOid: LPCSTR,
    pvCredentials: LPVOID,
};
pub const CRYPT_CREDENTIALS = struct__CRYPT_CREDENTIALS;
pub const PCRYPT_CREDENTIALS = [*c]struct__CRYPT_CREDENTIALS;
pub const struct__CRYPT_PASSWORD_CREDENTIALSA = extern struct {
    cbSize: DWORD,
    pszUsername: LPSTR,
    pszPassword: LPSTR,
};
pub const CRYPT_PASSWORD_CREDENTIALSA = struct__CRYPT_PASSWORD_CREDENTIALSA;
pub const PCRYPT_PASSWORD_CREDENTIALSA = [*c]struct__CRYPT_PASSWORD_CREDENTIALSA;
pub const struct__CRYPT_PASSWORD_CREDENTIALSW = extern struct {
    cbSize: DWORD,
    pszUsername: LPWSTR,
    pszPassword: LPWSTR,
};
pub const CRYPT_PASSWORD_CREDENTIALSW = struct__CRYPT_PASSWORD_CREDENTIALSW;
pub const PCRYPT_PASSWORD_CREDENTIALSW = [*c]struct__CRYPT_PASSWORD_CREDENTIALSW;
pub const CRYPT_PASSWORD_CREDENTIALS = CRYPT_PASSWORD_CREDENTIALSA;
pub const PCRYPT_PASSWORD_CREDENTIALS = PCRYPT_PASSWORD_CREDENTIALSA;
pub const PFN_FREE_ENCODED_OBJECT_FUNC = ?fn (LPCSTR, PCRYPT_BLOB_ARRAY, LPVOID) callconv(.C) void;
pub const struct__CRYPTNET_URL_CACHE_PRE_FETCH_INFO = extern struct {
    cbSize: DWORD,
    dwObjectType: DWORD,
    dwError: DWORD,
    dwReserved: DWORD,
    ThisUpdateTime: FILETIME,
    NextUpdateTime: FILETIME,
    PublishTime: FILETIME,
};
pub const CRYPTNET_URL_CACHE_PRE_FETCH_INFO = struct__CRYPTNET_URL_CACHE_PRE_FETCH_INFO;
pub const PCRYPTNET_URL_CACHE_PRE_FETCH_INFO = [*c]struct__CRYPTNET_URL_CACHE_PRE_FETCH_INFO;
pub const struct__CRYPTNET_URL_CACHE_FLUSH_INFO = extern struct {
    cbSize: DWORD,
    dwExemptSeconds: DWORD,
    ExpireTime: FILETIME,
};
pub const CRYPTNET_URL_CACHE_FLUSH_INFO = struct__CRYPTNET_URL_CACHE_FLUSH_INFO;
pub const PCRYPTNET_URL_CACHE_FLUSH_INFO = [*c]struct__CRYPTNET_URL_CACHE_FLUSH_INFO;
pub const struct__CRYPTNET_URL_CACHE_RESPONSE_INFO = extern struct {
    cbSize: DWORD,
    wResponseType: WORD,
    wResponseFlags: WORD,
    LastModifiedTime: FILETIME,
    dwMaxAge: DWORD,
    pwszETag: LPCWSTR,
    dwProxyId: DWORD,
};
pub const CRYPTNET_URL_CACHE_RESPONSE_INFO = struct__CRYPTNET_URL_CACHE_RESPONSE_INFO;
pub const PCRYPTNET_URL_CACHE_RESPONSE_INFO = [*c]struct__CRYPTNET_URL_CACHE_RESPONSE_INFO;
pub const struct__CRYPT_RETRIEVE_AUX_INFO = extern struct {
    cbSize: DWORD,
    pLastSyncTime: [*c]FILETIME,
    dwMaxUrlRetrievalByteCount: DWORD,
    pPreFetchInfo: PCRYPTNET_URL_CACHE_PRE_FETCH_INFO,
    pFlushInfo: PCRYPTNET_URL_CACHE_FLUSH_INFO,
    ppResponseInfo: [*c]PCRYPTNET_URL_CACHE_RESPONSE_INFO,
    pwszCacheFileNamePrefix: LPWSTR,
    pftCacheResync: LPFILETIME,
    fProxyCacheRetrieval: BOOL,
    dwHttpStatusCode: DWORD,
    ppwszErrorResponseHeaders: [*c]LPWSTR,
    ppErrorContentBlob: [*c]PCRYPT_DATA_BLOB,
};
pub const CRYPT_RETRIEVE_AUX_INFO = struct__CRYPT_RETRIEVE_AUX_INFO;
pub const PCRYPT_RETRIEVE_AUX_INFO = [*c]struct__CRYPT_RETRIEVE_AUX_INFO;
pub extern "crypt32" fn CryptRetrieveObjectByUrlA(pszUrl: LPCSTR, pszObjectOid: LPCSTR, dwRetrievalFlags: DWORD, dwTimeout: DWORD, ppvObject: [*c]LPVOID, hAsyncRetrieve: HCRYPTASYNC, pCredentials: PCRYPT_CREDENTIALS, pvVerify: LPVOID, pAuxInfo: PCRYPT_RETRIEVE_AUX_INFO) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptRetrieveObjectByUrlW(pszUrl: LPCWSTR, pszObjectOid: LPCSTR, dwRetrievalFlags: DWORD, dwTimeout: DWORD, ppvObject: [*c]LPVOID, hAsyncRetrieve: HCRYPTASYNC, pCredentials: PCRYPT_CREDENTIALS, pvVerify: LPVOID, pAuxInfo: PCRYPT_RETRIEVE_AUX_INFO) callconv(.Stdcall) BOOL;
pub const PFN_CRYPT_CANCEL_RETRIEVAL = ?fn (DWORD, ?*c_void) callconv(.C) BOOL;
pub extern "crypt32" fn CryptInstallCancelRetrieval(pfnCancel: PFN_CRYPT_CANCEL_RETRIEVAL, pvArg: ?*const c_void, dwFlags: DWORD, pvReserved: ?*c_void) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptUninstallCancelRetrieval(dwFlags: DWORD, pvReserved: ?*c_void) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptCancelAsyncRetrieval(hAsyncRetrieval: HCRYPTASYNC) callconv(.Stdcall) BOOL;
pub const PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC = ?fn (LPVOID, DWORD, LPCSTR, LPSTR, LPVOID) callconv(.C) void;
pub const struct__CRYPT_ASYNC_RETRIEVAL_COMPLETION = extern struct {
    pfnCompletion: PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC,
    pvCompletion: LPVOID,
};
pub const CRYPT_ASYNC_RETRIEVAL_COMPLETION = struct__CRYPT_ASYNC_RETRIEVAL_COMPLETION;
pub const PCRYPT_ASYNC_RETRIEVAL_COMPLETION = [*c]struct__CRYPT_ASYNC_RETRIEVAL_COMPLETION;
pub const PFN_CANCEL_ASYNC_RETRIEVAL_FUNC = ?fn (HCRYPTASYNC) callconv(.C) BOOL;
pub const struct__CRYPT_URL_ARRAY = extern struct {
    cUrl: DWORD,
    rgwszUrl: [*c]LPWSTR,
};
pub const CRYPT_URL_ARRAY = struct__CRYPT_URL_ARRAY;
pub const PCRYPT_URL_ARRAY = [*c]struct__CRYPT_URL_ARRAY;
pub const struct__CRYPT_URL_INFO = extern struct {
    cbSize: DWORD,
    dwSyncDeltaTime: DWORD,
    cGroup: DWORD,
    rgcGroupEntry: [*c]DWORD,
};
pub const CRYPT_URL_INFO = struct__CRYPT_URL_INFO;
pub const PCRYPT_URL_INFO = [*c]struct__CRYPT_URL_INFO;
pub extern "crypt32" fn CryptGetObjectUrl(pszUrlOid: LPCSTR, pvPara: LPVOID, dwFlags: DWORD, pUrlArray: PCRYPT_URL_ARRAY, pcbUrlArray: [*c]DWORD, pUrlInfo: PCRYPT_URL_INFO, pcbUrlInfo: [*c]DWORD, pvReserved: LPVOID) callconv(.Stdcall) BOOL;
pub const struct__CERT_CRL_CONTEXT_PAIR = extern struct {
    pCertContext: PCCERT_CONTEXT,
    pCrlContext: PCCRL_CONTEXT,
};
pub const CERT_CRL_CONTEXT_PAIR = struct__CERT_CRL_CONTEXT_PAIR;
pub const PCERT_CRL_CONTEXT_PAIR = [*c]struct__CERT_CRL_CONTEXT_PAIR;
pub const PCCERT_CRL_CONTEXT_PAIR = [*c]const CERT_CRL_CONTEXT_PAIR;
pub const struct__CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO = extern struct {
    cbSize: DWORD,
    iDeltaCrlIndicator: c_int,
    pftCacheResync: LPFILETIME,
    pLastSyncTime: LPFILETIME,
    pMaxAgeTime: LPFILETIME,
    pChainPara: PCERT_REVOCATION_CHAIN_PARA,
    pDeltaCrlIndicator: PCRYPT_INTEGER_BLOB,
};
pub const CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO = struct__CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO;
pub const PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO = [*c]struct__CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO;
pub extern "crypt32" fn CryptGetTimeValidObject(pszTimeValidOid: LPCSTR, pvPara: LPVOID, pIssuer: PCCERT_CONTEXT, pftValidFor: LPFILETIME, dwFlags: DWORD, dwTimeout: DWORD, ppvObject: [*c]LPVOID, pCredentials: PCRYPT_CREDENTIALS, pExtraInfo: PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptFlushTimeValidObject(pszFlushTimeValidOid: LPCSTR, pvPara: LPVOID, pIssuer: PCCERT_CONTEXT, dwFlags: DWORD, pvReserved: LPVOID) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertCreateSelfSignCertificate(hCryptProvOrNCryptKey: HCRYPTPROV_OR_NCRYPT_KEY_HANDLE, pSubjectIssuerBlob: PCERT_NAME_BLOB, dwFlags: DWORD, pKeyProvInfo: PCRYPT_KEY_PROV_INFO, pSignatureAlgorithm: PCRYPT_ALGORITHM_IDENTIFIER, pStartTime: PSYSTEMTIME, pEndTime: PSYSTEMTIME, pExtensions: PCERT_EXTENSIONS) callconv(.Stdcall) PCCERT_CONTEXT;
pub extern "crypt32" fn CryptGetKeyIdentifierProperty(pKeyIdentifier: [*c]const CRYPT_HASH_BLOB, dwPropId: DWORD, dwFlags: DWORD, pwszComputerName: LPCWSTR, pvReserved: ?*c_void, pvData: ?*c_void, pcbData: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptSetKeyIdentifierProperty(pKeyIdentifier: [*c]const CRYPT_HASH_BLOB, dwPropId: DWORD, dwFlags: DWORD, pwszComputerName: LPCWSTR, pvReserved: ?*c_void, pvData: ?*const c_void) callconv(.Stdcall) BOOL;
pub const PFN_CRYPT_ENUM_KEYID_PROP = ?fn ([*c]const CRYPT_HASH_BLOB, DWORD, ?*c_void, ?*c_void, DWORD, [*c]DWORD, [*c](?*c_void), [*c]DWORD) callconv(.C) BOOL;
pub extern "crypt32" fn CryptEnumKeyIdentifierProperties(pKeyIdentifier: [*c]const CRYPT_HASH_BLOB, dwPropId: DWORD, dwFlags: DWORD, pwszComputerName: LPCWSTR, pvReserved: ?*c_void, pvArg: ?*c_void, pfnEnum: PFN_CRYPT_ENUM_KEYID_PROP) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptCreateKeyIdentifierFromCSP(dwCertEncodingType: DWORD, pszPubKeyOID: LPCSTR, pPubKeyStruc: [*c]const PUBLICKEYSTRUC, cbPubKeyStruc: DWORD, dwFlags: DWORD, pvReserved: ?*c_void, pbHash: [*c]BYTE, pcbHash: [*c]DWORD) callconv(.Stdcall) BOOL;
pub const struct__CERT_CHAIN_ENGINE_CONFIG = extern struct {
    cbSize: DWORD,
    hRestrictedRoot: HCERTSTORE,
    hRestrictedTrust: HCERTSTORE,
    hRestrictedOther: HCERTSTORE,
    cAdditionalStore: DWORD,
    rghAdditionalStore: [*c]HCERTSTORE,
    dwFlags: DWORD,
    dwUrlRetrievalTimeout: DWORD,
    MaximumCachedCertificates: DWORD,
    CycleDetectionModulus: DWORD,
    hExclusiveRoot: HCERTSTORE,
    hExclusiveTrustedPeople: HCERTSTORE,
    dwExclusiveFlags: DWORD,
};
pub const CERT_CHAIN_ENGINE_CONFIG = struct__CERT_CHAIN_ENGINE_CONFIG;
pub const PCERT_CHAIN_ENGINE_CONFIG = [*c]struct__CERT_CHAIN_ENGINE_CONFIG;
pub extern "crypt32" fn CertCreateCertificateChainEngine(pConfig: PCERT_CHAIN_ENGINE_CONFIG, phChainEngine: [*c]HCERTCHAINENGINE) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertFreeCertificateChainEngine(hChainEngine: HCERTCHAINENGINE) callconv(.Stdcall) void;
pub extern "crypt32" fn CertResyncCertificateChainEngine(hChainEngine: HCERTCHAINENGINE) callconv(.Stdcall) BOOL;
pub const struct__CERT_TRUST_STATUS = extern struct {
    dwErrorStatus: DWORD,
    dwInfoStatus: DWORD,
};
pub const CERT_TRUST_STATUS = struct__CERT_TRUST_STATUS;
pub const PCERT_TRUST_STATUS = [*c]struct__CERT_TRUST_STATUS;
pub const struct__CERT_REVOCATION_INFO = extern struct {
    cbSize: DWORD,
    dwRevocationResult: DWORD,
    pszRevocationOid: LPCSTR,
    pvOidSpecificInfo: LPVOID,
    fHasFreshnessTime: BOOL,
    dwFreshnessTime: DWORD,
    pCrlInfo: PCERT_REVOCATION_CRL_INFO,
};
pub const CERT_REVOCATION_INFO = struct__CERT_REVOCATION_INFO;
pub const PCERT_REVOCATION_INFO = [*c]struct__CERT_REVOCATION_INFO;
pub const struct__CERT_TRUST_LIST_INFO = extern struct {
    cbSize: DWORD,
    pCtlEntry: PCTL_ENTRY,
    pCtlContext: PCCTL_CONTEXT,
};
pub const CERT_TRUST_LIST_INFO = struct__CERT_TRUST_LIST_INFO;
pub const PCERT_TRUST_LIST_INFO = [*c]struct__CERT_TRUST_LIST_INFO;
pub const struct__CERT_CHAIN_ELEMENT = extern struct {
    cbSize: DWORD,
    pCertContext: PCCERT_CONTEXT,
    TrustStatus: CERT_TRUST_STATUS,
    pRevocationInfo: PCERT_REVOCATION_INFO,
    pIssuanceUsage: PCERT_ENHKEY_USAGE,
    pApplicationUsage: PCERT_ENHKEY_USAGE,
    pwszExtendedErrorInfo: LPCWSTR,
};
pub const CERT_CHAIN_ELEMENT = struct__CERT_CHAIN_ELEMENT;
pub const PCERT_CHAIN_ELEMENT = [*c]struct__CERT_CHAIN_ELEMENT;
pub const PCCERT_CHAIN_ELEMENT = [*c]const CERT_CHAIN_ELEMENT;
pub const struct__CERT_SIMPLE_CHAIN = extern struct {
    cbSize: DWORD,
    TrustStatus: CERT_TRUST_STATUS,
    cElement: DWORD,
    rgpElement: [*c]PCERT_CHAIN_ELEMENT,
    pTrustListInfo: PCERT_TRUST_LIST_INFO,
    fHasRevocationFreshnessTime: BOOL,
    dwRevocationFreshnessTime: DWORD,
};
pub const CERT_SIMPLE_CHAIN = struct__CERT_SIMPLE_CHAIN;
pub const PCERT_SIMPLE_CHAIN = [*c]struct__CERT_SIMPLE_CHAIN;
pub const PCCERT_SIMPLE_CHAIN = [*c]const CERT_SIMPLE_CHAIN;
pub const CERT_CHAIN_CONTEXT = struct__CERT_CHAIN_CONTEXT;
pub const PCCERT_CHAIN_CONTEXT = [*c]const CERT_CHAIN_CONTEXT;
pub const struct__CERT_CHAIN_CONTEXT = extern struct {
    cbSize: DWORD,
    TrustStatus: CERT_TRUST_STATUS,
    cChain: DWORD,
    rgpChain: [*c]PCERT_SIMPLE_CHAIN,
    cLowerQualityChainContext: DWORD,
    rgpLowerQualityChainContext: [*c]PCCERT_CHAIN_CONTEXT,
    fHasRevocationFreshnessTime: BOOL,
    dwRevocationFreshnessTime: DWORD,
    dwCreateFlags: DWORD,
    ChainId: GUID,
};
pub const PCERT_CHAIN_CONTEXT = [*c]struct__CERT_CHAIN_CONTEXT;
pub const struct__CERT_USAGE_MATCH = extern struct {
    dwType: DWORD,
    Usage: CERT_ENHKEY_USAGE,
};
pub const CERT_USAGE_MATCH = struct__CERT_USAGE_MATCH;
pub const PCERT_USAGE_MATCH = [*c]struct__CERT_USAGE_MATCH;
pub const struct__CTL_USAGE_MATCH = extern struct {
    dwType: DWORD,
    Usage: CTL_USAGE,
};
pub const CTL_USAGE_MATCH = struct__CTL_USAGE_MATCH;
pub const PCTL_USAGE_MATCH = [*c]struct__CTL_USAGE_MATCH;
pub const struct__CERT_CHAIN_PARA = extern struct {
    cbSize: DWORD,
    RequestedUsage: CERT_USAGE_MATCH,
};
pub const CERT_CHAIN_PARA = struct__CERT_CHAIN_PARA;
pub const PCERT_CHAIN_PARA = [*c]struct__CERT_CHAIN_PARA;
pub extern "crypt32" fn CertGetCertificateChain(hChainEngine: HCERTCHAINENGINE, pCertContext: PCCERT_CONTEXT, pTime: LPFILETIME, hAdditionalStore: HCERTSTORE, pChainPara: PCERT_CHAIN_PARA, dwFlags: DWORD, pvReserved: LPVOID, ppChainContext: [*c]PCCERT_CHAIN_CONTEXT) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertFreeCertificateChain(pChainContext: PCCERT_CHAIN_CONTEXT) callconv(.Stdcall) void;
pub extern "crypt32" fn CertDuplicateCertificateChain(pChainContext: PCCERT_CHAIN_CONTEXT) callconv(.Stdcall) PCCERT_CHAIN_CONTEXT;
pub const struct__CRL_REVOCATION_INFO = extern struct {
    pCrlEntry: PCRL_ENTRY,
    pCrlContext: PCCRL_CONTEXT,
    pCrlIssuerChain: PCCERT_CHAIN_CONTEXT,
};
pub const CRL_REVOCATION_INFO = struct__CRL_REVOCATION_INFO;
pub const PCRL_REVOCATION_INFO = [*c]struct__CRL_REVOCATION_INFO;
pub extern "crypt32" fn CertFindChainInStore(hCertStore: HCERTSTORE, dwCertEncodingType: DWORD, dwFindFlags: DWORD, dwFindType: DWORD, pvFindPara: ?*const c_void, pPrevChainContext: PCCERT_CHAIN_CONTEXT) callconv(.Stdcall) PCCERT_CHAIN_CONTEXT;
pub const PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK = ?fn (PCCERT_CONTEXT, ?*c_void) callconv(.C) BOOL;
pub const struct__CERT_CHAIN_FIND_BY_ISSUER_PARA = extern struct {
    cbSize: DWORD,
    pszUsageIdentifier: LPCSTR,
    dwKeySpec: DWORD,
    dwAcquirePrivateKeyFlags: DWORD,
    cIssuer: DWORD,
    rgIssuer: [*c]CERT_NAME_BLOB,
    pfnFindCallback: PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK,
    pvFindArg: ?*c_void,
};
pub const CERT_CHAIN_FIND_ISSUER_PARA = struct__CERT_CHAIN_FIND_BY_ISSUER_PARA;
pub const PCERT_CHAIN_FIND_ISSUER_PARA = [*c]struct__CERT_CHAIN_FIND_BY_ISSUER_PARA;
pub const CERT_CHAIN_FIND_BY_ISSUER_PARA = struct__CERT_CHAIN_FIND_BY_ISSUER_PARA;
pub const PCERT_CHAIN_FIND_BY_ISSUER_PARA = [*c]struct__CERT_CHAIN_FIND_BY_ISSUER_PARA;
pub const struct__CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: DWORD,
    dwFlags: DWORD,
    pvExtraPolicyPara: ?*c_void,
};
pub const CERT_CHAIN_POLICY_PARA = struct__CERT_CHAIN_POLICY_PARA;
pub const PCERT_CHAIN_POLICY_PARA = [*c]struct__CERT_CHAIN_POLICY_PARA;
pub const struct__CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: DWORD,
    dwError: DWORD,
    lChainIndex: LONG,
    lElementIndex: LONG,
    pvExtraPolicyStatus: ?*c_void,
};
pub const CERT_CHAIN_POLICY_STATUS = struct__CERT_CHAIN_POLICY_STATUS;
pub const PCERT_CHAIN_POLICY_STATUS = [*c]struct__CERT_CHAIN_POLICY_STATUS;
pub extern "crypt32" fn CertVerifyCertificateChainPolicy(pszPolicyOID: LPCSTR, pChainContext: PCCERT_CHAIN_CONTEXT, pPolicyPara: PCERT_CHAIN_POLICY_PARA, pPolicyStatus: PCERT_CHAIN_POLICY_STATUS) callconv(.Stdcall) BOOL;
pub const struct__AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: DWORD,
    dwRegPolicySettings: DWORD,
    pSignerInfo: PCMSG_SIGNER_INFO,
};
pub const AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA = struct__AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA;
pub const PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA = [*c]struct__AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA;
pub const struct__AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: DWORD,
    fCommercial: BOOL,
};
pub const AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS = struct__AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub const PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS = [*c]struct__AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub const struct__AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: DWORD,
    dwRegPolicySettings: DWORD,
    fCommercial: BOOL,
};
pub const AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA = struct__AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA;
pub const PAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA = [*c]struct__AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA;
pub const struct__HTTPSPolicyCallbackData = extern struct {
    @"": extern union {
        cbStruct: DWORD,
        cbSize: DWORD,
    },
    dwAuthType: DWORD,
    fdwChecks: DWORD,
    pwszServerName: [*c]WCHAR,
};
pub const HTTPSPolicyCallbackData = struct__HTTPSPolicyCallbackData;
pub const PHTTPSPolicyCallbackData = [*c]struct__HTTPSPolicyCallbackData;
pub const SSL_EXTRA_CERT_CHAIN_POLICY_PARA = struct__HTTPSPolicyCallbackData;
pub const PSSL_EXTRA_CERT_CHAIN_POLICY_PARA = [*c]struct__HTTPSPolicyCallbackData;
pub const struct__EV_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: DWORD,
    dwRootProgramQualifierFlags: DWORD,
};
pub const EV_EXTRA_CERT_CHAIN_POLICY_PARA = struct__EV_EXTRA_CERT_CHAIN_POLICY_PARA;
pub const PEV_EXTRA_CERT_CHAIN_POLICY_PARA = [*c]struct__EV_EXTRA_CERT_CHAIN_POLICY_PARA;
pub const struct__EV_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: DWORD,
    dwQualifiers: DWORD,
    dwIssuanceUsageIndex: DWORD,
};
pub const EV_EXTRA_CERT_CHAIN_POLICY_STATUS = struct__EV_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub const PEV_EXTRA_CERT_CHAIN_POLICY_STATUS = [*c]struct__EV_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub const struct__SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: DWORD,
    dwErrorLevel: DWORD,
    dwErrorCategory: DWORD,
    dwReserved: DWORD,
    wszErrorText: [256]WCHAR,
};
pub const SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS = struct__SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub const PSSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS = [*c]struct__SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub const struct__SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: DWORD,
    dwReserved: DWORD,
    pwszServerName: LPWSTR,
    rgpszHpkpValue: [2]LPSTR,
};
pub const SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA = struct__SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA;
pub const PSSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA = [*c]struct__SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA;
pub const struct__SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA = extern struct {
    cbSize: DWORD,
    dwReserved: DWORD,
    pwszServerName: PCWSTR,
};
pub const SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA = struct__SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA;
pub const PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA = [*c]struct__SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA;
pub const struct__SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS = extern struct {
    cbSize: DWORD,
    lError: LONG,
    wszErrorText: [512]WCHAR,
};
pub const SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS = struct__SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub const PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS = [*c]struct__SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub extern "crypt32" fn CryptStringToBinaryA(pszString: LPCSTR, cchString: DWORD, dwFlags: DWORD, pbBinary: [*c]BYTE, pcbBinary: [*c]DWORD, pdwSkip: [*c]DWORD, pdwFlags: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptStringToBinaryW(pszString: LPCWSTR, cchString: DWORD, dwFlags: DWORD, pbBinary: [*c]BYTE, pcbBinary: [*c]DWORD, pdwSkip: [*c]DWORD, pdwFlags: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptBinaryToStringA(pbBinary: [*c]const BYTE, cbBinary: DWORD, dwFlags: DWORD, pszString: LPSTR, pcchString: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptBinaryToStringW(pbBinary: [*c]const BYTE, cbBinary: DWORD, dwFlags: DWORD, pszString: LPWSTR, pcchString: [*c]DWORD) callconv(.Stdcall) BOOL;
pub const struct__CRYPT_PKCS12_PBE_PARAMS = extern struct {
    iIterations: c_int,
    cbSalt: ULONG,
};
pub const CRYPT_PKCS12_PBE_PARAMS = struct__CRYPT_PKCS12_PBE_PARAMS;
pub extern "crypt32" fn PFXImportCertStore(pPFX: [*c]CRYPT_DATA_BLOB, szPassword: LPCWSTR, dwFlags: DWORD) callconv(.Stdcall) HCERTSTORE;
pub extern "crypt32" fn PFXIsPFXBlob(pPFX: [*c]CRYPT_DATA_BLOB) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn PFXVerifyPassword(pPFX: [*c]CRYPT_DATA_BLOB, szPassword: LPCWSTR, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn PFXExportCertStoreEx(hStore: HCERTSTORE, pPFX: [*c]CRYPT_DATA_BLOB, szPassword: LPCWSTR, pvPara: ?*c_void, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub const struct__PKCS12_PBES2_EXPORT_PARAMS = extern struct {
    dwSize: DWORD,
    hNcryptDescriptor: PVOID,
    pwszPbes2Alg: LPWSTR,
};
pub const PKCS12_PBES2_EXPORT_PARAMS = struct__PKCS12_PBES2_EXPORT_PARAMS;
pub const PPKCS12_PBES2_EXPORT_PARAMS = [*c]struct__PKCS12_PBES2_EXPORT_PARAMS;
pub extern "crypt32" fn PFXExportCertStore(hStore: HCERTSTORE, pPFX: [*c]CRYPT_DATA_BLOB, szPassword: LPCWSTR, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub const HCERT_SERVER_OCSP_RESPONSE = ?*c_void;
pub const struct__CERT_SERVER_OCSP_RESPONSE_CONTEXT = extern struct {
    cbSize: DWORD,
    pbEncodedOcspResponse: [*c]BYTE,
    cbEncodedOcspResponse: DWORD,
};
pub const CERT_SERVER_OCSP_RESPONSE_CONTEXT = struct__CERT_SERVER_OCSP_RESPONSE_CONTEXT;
pub const PCERT_SERVER_OCSP_RESPONSE_CONTEXT = [*c]struct__CERT_SERVER_OCSP_RESPONSE_CONTEXT;
pub const PCCERT_SERVER_OCSP_RESPONSE_CONTEXT = [*c]const CERT_SERVER_OCSP_RESPONSE_CONTEXT;
pub const PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK = ?fn (PCCERT_CHAIN_CONTEXT, PCCERT_SERVER_OCSP_RESPONSE_CONTEXT, PCCRL_CONTEXT, PCCRL_CONTEXT, PVOID, DWORD) callconv(.C) void;
pub const struct__CERT_SERVER_OCSP_RESPONSE_OPEN_PARA = extern struct {
    cbSize: DWORD,
    dwFlags: DWORD,
    pcbUsedSize: [*c]DWORD,
    pwszOcspDirectory: PWSTR,
    pfnUpdateCallback: PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK,
    pvUpdateCallbackArg: PVOID,
};
pub const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA = struct__CERT_SERVER_OCSP_RESPONSE_OPEN_PARA;
pub const PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA = [*c]struct__CERT_SERVER_OCSP_RESPONSE_OPEN_PARA;
pub extern "crypt32" fn CertOpenServerOcspResponse(pChainContext: PCCERT_CHAIN_CONTEXT, dwFlags: DWORD, pOpenPara: PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA) callconv(.Stdcall) HCERT_SERVER_OCSP_RESPONSE;
pub extern "crypt32" fn CertAddRefServerOcspResponse(hServerOcspResponse: HCERT_SERVER_OCSP_RESPONSE) callconv(.Stdcall) void;
pub extern "crypt32" fn CertCloseServerOcspResponse(hServerOcspResponse: HCERT_SERVER_OCSP_RESPONSE, dwFlags: DWORD) callconv(.Stdcall) void;
pub extern "crypt32" fn CertGetServerOcspResponseContext(hServerOcspResponse: HCERT_SERVER_OCSP_RESPONSE, dwFlags: DWORD, pvReserved: LPVOID) callconv(.Stdcall) PCCERT_SERVER_OCSP_RESPONSE_CONTEXT;
pub extern "crypt32" fn CertAddRefServerOcspResponseContext(pServerOcspResponseContext: PCCERT_SERVER_OCSP_RESPONSE_CONTEXT) callconv(.Stdcall) void;
pub extern "crypt32" fn CertFreeServerOcspResponseContext(pServerOcspResponseContext: PCCERT_SERVER_OCSP_RESPONSE_CONTEXT) callconv(.Stdcall) void;
pub extern "crypt32" fn CertRetrieveLogoOrBiometricInfo(pCertContext: PCCERT_CONTEXT, lpszLogoOrBiometricType: LPCSTR, dwRetrievalFlags: DWORD, dwTimeout: DWORD, dwFlags: DWORD, pvReserved: ?*c_void, ppbData: [*c]([*c]BYTE), pcbData: [*c]DWORD, ppwszMimeType: [*c]LPWSTR) callconv(.Stdcall) BOOL;
pub const struct__CERT_SELECT_CHAIN_PARA = extern struct {
    hChainEngine: HCERTCHAINENGINE,
    pTime: PFILETIME,
    hAdditionalStore: HCERTSTORE,
    pChainPara: PCERT_CHAIN_PARA,
    dwFlags: DWORD,
};
pub const CERT_SELECT_CHAIN_PARA = struct__CERT_SELECT_CHAIN_PARA;
pub const PCERT_SELECT_CHAIN_PARA = [*c]struct__CERT_SELECT_CHAIN_PARA;
pub const PCCERT_SELECT_CHAIN_PARA = [*c]const CERT_SELECT_CHAIN_PARA;
pub const struct__CERT_SELECT_CRITERIA = extern struct {
    dwType: DWORD,
    cPara: DWORD,
    ppPara: [*c](?*c_void),
};
pub const CERT_SELECT_CRITERIA = struct__CERT_SELECT_CRITERIA;
pub const PCERT_SELECT_CRITERIA = [*c]struct__CERT_SELECT_CRITERIA;
pub const PCCERT_SELECT_CRITERIA = [*c]const CERT_SELECT_CRITERIA;
pub extern "crypt32" fn CertSelectCertificateChains(pSelectionContext: LPCGUID, dwFlags: DWORD, pChainParameters: PCCERT_SELECT_CHAIN_PARA, cCriteria: DWORD, rgpCriteria: PCCERT_SELECT_CRITERIA, hStore: HCERTSTORE, pcSelection: PDWORD, pprgpSelection: [*c]([*c]PCCERT_CHAIN_CONTEXT)) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CertFreeCertificateChainList(prgpSelection: [*c]PCCERT_CHAIN_CONTEXT) callconv(.Stdcall) void;
pub const struct__CRYPT_TIMESTAMP_REQUEST = extern struct {
    dwVersion: DWORD,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashedMessage: CRYPT_DER_BLOB,
    pszTSAPolicyId: LPSTR,
    Nonce: CRYPT_INTEGER_BLOB,
    fCertReq: BOOL,
    cExtension: DWORD,
    rgExtension: PCERT_EXTENSION,
};
pub const CRYPT_TIMESTAMP_REQUEST = struct__CRYPT_TIMESTAMP_REQUEST;
pub const PCRYPT_TIMESTAMP_REQUEST = [*c]struct__CRYPT_TIMESTAMP_REQUEST;
pub const struct__CRYPT_TIMESTAMP_RESPONSE = extern struct {
    dwStatus: DWORD,
    cFreeText: DWORD,
    rgFreeText: [*c]LPWSTR,
    FailureInfo: CRYPT_BIT_BLOB,
    ContentInfo: CRYPT_DER_BLOB,
};
pub const CRYPT_TIMESTAMP_RESPONSE = struct__CRYPT_TIMESTAMP_RESPONSE;
pub const PCRYPT_TIMESTAMP_RESPONSE = [*c]struct__CRYPT_TIMESTAMP_RESPONSE;
pub const struct__CRYPT_TIMESTAMP_ACCURACY = extern struct {
    dwSeconds: DWORD,
    dwMillis: DWORD,
    dwMicros: DWORD,
};
pub const CRYPT_TIMESTAMP_ACCURACY = struct__CRYPT_TIMESTAMP_ACCURACY;
pub const PCRYPT_TIMESTAMP_ACCURACY = [*c]struct__CRYPT_TIMESTAMP_ACCURACY;
pub const struct__CRYPT_TIMESTAMP_INFO = extern struct {
    dwVersion: DWORD,
    pszTSAPolicyId: LPSTR,
    HashAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    HashedMessage: CRYPT_DER_BLOB,
    SerialNumber: CRYPT_INTEGER_BLOB,
    ftTime: FILETIME,
    pvAccuracy: PCRYPT_TIMESTAMP_ACCURACY,
    fOrdering: BOOL,
    Nonce: CRYPT_DER_BLOB,
    Tsa: CRYPT_DER_BLOB,
    cExtension: DWORD,
    rgExtension: PCERT_EXTENSION,
};
pub const CRYPT_TIMESTAMP_INFO = struct__CRYPT_TIMESTAMP_INFO;
pub const PCRYPT_TIMESTAMP_INFO = [*c]struct__CRYPT_TIMESTAMP_INFO;
pub const struct__CRYPT_TIMESTAMP_CONTEXT = extern struct {
    cbEncoded: DWORD,
    pbEncoded: [*c]BYTE,
    pTimeStamp: PCRYPT_TIMESTAMP_INFO,
};
pub const CRYPT_TIMESTAMP_CONTEXT = struct__CRYPT_TIMESTAMP_CONTEXT;
pub const PCRYPT_TIMESTAMP_CONTEXT = [*c]struct__CRYPT_TIMESTAMP_CONTEXT;
pub const struct__CRYPT_TIMESTAMP_PARA = extern struct {
    pszTSAPolicyId: LPCSTR,
    fRequestCerts: BOOL,
    Nonce: CRYPT_INTEGER_BLOB,
    cExtension: DWORD,
    rgExtension: PCERT_EXTENSION,
};
pub const CRYPT_TIMESTAMP_PARA = struct__CRYPT_TIMESTAMP_PARA;
pub const PCRYPT_TIMESTAMP_PARA = [*c]struct__CRYPT_TIMESTAMP_PARA;
pub extern "crypt32" fn CryptRetrieveTimeStamp(wszUrl: LPCWSTR, dwRetrievalFlags: DWORD, dwTimeout: DWORD, pszHashId: LPCSTR, pPara: [*c]const CRYPT_TIMESTAMP_PARA, pbData: [*c]const BYTE, cbData: DWORD, ppTsContext: [*c]PCRYPT_TIMESTAMP_CONTEXT, ppTsSigner: [*c]PCCERT_CONTEXT, phStore: [*c]HCERTSTORE) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptVerifyTimeStampSignature(pbTSContentInfo: [*c]const BYTE, cbTSContentInfo: DWORD, pbData: [*c]const BYTE, cbData: DWORD, hAdditionalStore: HCERTSTORE, ppTsContext: [*c]PCRYPT_TIMESTAMP_CONTEXT, ppTsSigner: [*c]PCCERT_CONTEXT, phStore: [*c]HCERTSTORE) callconv(.Stdcall) BOOL;
pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH = ?fn (LPVOID, [*c]PCERT_NAME_BLOB, DWORD) callconv(.C) BOOL;
pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET = ?fn (LPVOID, PCRYPT_DATA_BLOB, DWORD, PCERT_NAME_BLOB, [*c]PBYTE, [*c]DWORD, [*c]PCWSTR, [*c]PCRYPT_DATA_BLOB) callconv(.C) BOOL;
pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE = ?fn (DWORD, LPVOID) callconv(.C) void;
pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD = ?fn (LPVOID, PCWSTR) callconv(.C) void;
pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE = ?fn (LPVOID, PBYTE) callconv(.C) void;
pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER = ?fn (LPVOID, PCRYPT_DATA_BLOB) callconv(.C) void;
pub const struct__CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE = extern struct {
    cbSize: DWORD,
    pfnGet: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET,
    pfnRelease: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE,
    pfnFreePassword: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD,
    pfnFree: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE,
    pfnFreeIdentifier: PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER,
};
pub const CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE = struct__CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE;
pub const PCRYPT_OBJECT_LOCATOR_PROVIDER_TABLE = [*c]struct__CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE;
pub const PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_INITIALIZE = ?fn (PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH, LPVOID, [*c]DWORD, [*c]PCRYPT_OBJECT_LOCATOR_PROVIDER_TABLE, [*c](?*c_void)) callconv(.C) BOOL;
pub extern "crypt32" fn CertIsWeakHash(dwHashUseType: DWORD, pwszCNGHashAlgid: LPCWSTR, dwChainFlags: DWORD, pSignerChainContext: PCCERT_CHAIN_CONTEXT, pTimeStamp: LPFILETIME, pwszFileName: LPCWSTR) callconv(.Stdcall) BOOL;
pub const PFN_CERT_IS_WEAK_HASH = ?fn (DWORD, LPCWSTR, DWORD, PCCERT_CHAIN_CONTEXT, LPFILETIME, LPCWSTR) callconv(.C) BOOL;
pub const struct__CRYPTPROTECT_PROMPTSTRUCT = extern struct {
    cbSize: DWORD,
    dwPromptFlags: DWORD,
    hwndApp: HWND,
    szPrompt: LPCWSTR,
};
pub const CRYPTPROTECT_PROMPTSTRUCT = struct__CRYPTPROTECT_PROMPTSTRUCT;
pub const PCRYPTPROTECT_PROMPTSTRUCT = [*c]struct__CRYPTPROTECT_PROMPTSTRUCT;
pub extern "crypt32" fn CryptProtectData(pDataIn: [*c]DATA_BLOB, szDataDescr: LPCWSTR, pOptionalEntropy: [*c]DATA_BLOB, pvReserved: PVOID, pPromptStruct: [*c]CRYPTPROTECT_PROMPTSTRUCT, dwFlags: DWORD, pDataOut: [*c]DATA_BLOB) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptUnprotectData(pDataIn: [*c]DATA_BLOB, ppszDataDescr: [*c]LPWSTR, pOptionalEntropy: [*c]DATA_BLOB, pvReserved: PVOID, pPromptStruct: [*c]CRYPTPROTECT_PROMPTSTRUCT, dwFlags: DWORD, pDataOut: [*c]DATA_BLOB) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptProtectDataNoUI(pDataIn: [*c]DATA_BLOB, szDataDescr: LPCWSTR, pOptionalEntropy: [*c]DATA_BLOB, pvReserved: PVOID, pPromptStruct: [*c]CRYPTPROTECT_PROMPTSTRUCT, dwFlags: DWORD, pbOptionalPassword: [*c]const BYTE, cbOptionalPassword: DWORD, pDataOut: [*c]DATA_BLOB) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptUnprotectDataNoUI(pDataIn: [*c]DATA_BLOB, ppszDataDescr: [*c]LPWSTR, pOptionalEntropy: [*c]DATA_BLOB, pvReserved: PVOID, pPromptStruct: [*c]CRYPTPROTECT_PROMPTSTRUCT, dwFlags: DWORD, pbOptionalPassword: [*c]const BYTE, cbOptionalPassword: DWORD, pDataOut: [*c]DATA_BLOB) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptUpdateProtectedState(pOldSid: PSID, pwszOldPassword: LPCWSTR, dwFlags: DWORD, pdwSuccessCount: [*c]DWORD, pdwFailureCount: [*c]DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptProtectMemory(pDataIn: LPVOID, cbDataIn: DWORD, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "crypt32" fn CryptUnprotectMemory(pDataIn: LPVOID, cbDataIn: DWORD, dwFlags: DWORD) callconv(.Stdcall) BOOL;
pub const struct__CERTIFICATE_BLOB = extern struct {
    dwCertEncodingType: DWORD,
    cbData: DWORD,
    pbData: PBYTE,
};
pub const EFS_CERTIFICATE_BLOB = struct__CERTIFICATE_BLOB;
pub const PEFS_CERTIFICATE_BLOB = [*c]struct__CERTIFICATE_BLOB;
pub const struct__EFS_HASH_BLOB = extern struct {
    cbData: DWORD,
    pbData: PBYTE,
};
pub const EFS_HASH_BLOB = struct__EFS_HASH_BLOB;
pub const PEFS_HASH_BLOB = [*c]struct__EFS_HASH_BLOB;
pub const struct__EFS_RPC_BLOB = extern struct {
    cbData: DWORD,
    pbData: PBYTE,
};
pub const EFS_RPC_BLOB = struct__EFS_RPC_BLOB;
pub const PEFS_RPC_BLOB = [*c]struct__EFS_RPC_BLOB;
pub const struct__EFS_PIN_BLOB = extern struct {
    cbPadding: DWORD,
    cbData: DWORD,
    pbData: PBYTE,
};
pub const EFS_PIN_BLOB = struct__EFS_PIN_BLOB;
pub const PEFS_PIN_BLOB = [*c]struct__EFS_PIN_BLOB;
pub const struct__EFS_KEY_INFO = extern struct {
    dwVersion: DWORD,
    Entropy: ULONG,
    Algorithm: ALG_ID,
    KeyLength: ULONG,
};
pub const EFS_KEY_INFO = struct__EFS_KEY_INFO;
pub const PEFS_KEY_INFO = [*c]struct__EFS_KEY_INFO;
pub const struct__EFS_COMPATIBILITY_INFO = extern struct {
    EfsVersion: DWORD,
};
pub const EFS_COMPATIBILITY_INFO = struct__EFS_COMPATIBILITY_INFO;
pub const PEFS_COMPATIBILITY_INFO = [*c]struct__EFS_COMPATIBILITY_INFO;
pub const struct__EFS_VERSION_INFO = extern struct {
    EfsVersion: DWORD,
    SubVersion: DWORD,
};
pub const EFS_VERSION_INFO = struct__EFS_VERSION_INFO;
pub const PEFS_VERSION_INFO = [*c]struct__EFS_VERSION_INFO;
pub const struct__EFS_DECRYPTION_STATUS_INFO = extern struct {
    dwDecryptionError: DWORD,
    dwHashOffset: DWORD,
    cbHash: DWORD,
};
pub const EFS_DECRYPTION_STATUS_INFO = struct__EFS_DECRYPTION_STATUS_INFO;
pub const PEFS_DECRYPTION_STATUS_INFO = [*c]struct__EFS_DECRYPTION_STATUS_INFO;
pub const struct__EFS_ENCRYPTION_STATUS_INFO = extern struct {
    bHasCurrentKey: BOOL,
    dwEncryptionError: DWORD,
};
pub const EFS_ENCRYPTION_STATUS_INFO = struct__EFS_ENCRYPTION_STATUS_INFO;
pub const PEFS_ENCRYPTION_STATUS_INFO = [*c]struct__EFS_ENCRYPTION_STATUS_INFO;
pub const struct__ENCRYPTION_CERTIFICATE = extern struct {
    cbTotalLength: DWORD,
    pUserSid: [*c]SID,
    pCertBlob: PEFS_CERTIFICATE_BLOB,
};
pub const ENCRYPTION_CERTIFICATE = struct__ENCRYPTION_CERTIFICATE;
pub const PENCRYPTION_CERTIFICATE = [*c]struct__ENCRYPTION_CERTIFICATE;
pub const struct__ENCRYPTION_CERTIFICATE_HASH = extern struct {
    cbTotalLength: DWORD,
    pUserSid: [*c]SID,
    pHash: PEFS_HASH_BLOB,
    lpDisplayInformation: LPWSTR,
};
pub const ENCRYPTION_CERTIFICATE_HASH = struct__ENCRYPTION_CERTIFICATE_HASH;
pub const PENCRYPTION_CERTIFICATE_HASH = [*c]struct__ENCRYPTION_CERTIFICATE_HASH;
pub const struct__ENCRYPTION_CERTIFICATE_HASH_LIST = extern struct {
    nCert_Hash: DWORD,
    pUsers: [*c]PENCRYPTION_CERTIFICATE_HASH,
};
pub const ENCRYPTION_CERTIFICATE_HASH_LIST = struct__ENCRYPTION_CERTIFICATE_HASH_LIST;
pub const PENCRYPTION_CERTIFICATE_HASH_LIST = [*c]struct__ENCRYPTION_CERTIFICATE_HASH_LIST;
pub const struct__ENCRYPTION_CERTIFICATE_LIST = extern struct {
    nUsers: DWORD,
    pUsers: [*c]PENCRYPTION_CERTIFICATE,
};
pub const ENCRYPTION_CERTIFICATE_LIST = struct__ENCRYPTION_CERTIFICATE_LIST;
pub const PENCRYPTION_CERTIFICATE_LIST = [*c]struct__ENCRYPTION_CERTIFICATE_LIST;
pub const struct__ENCRYPTED_FILE_METADATA_SIGNATURE = extern struct {
    dwEfsAccessType: DWORD,
    pCertificatesAdded: PENCRYPTION_CERTIFICATE_HASH_LIST,
    pEncryptionCertificate: PENCRYPTION_CERTIFICATE,
    pEfsStreamSignature: PEFS_RPC_BLOB,
};
pub const ENCRYPTED_FILE_METADATA_SIGNATURE = struct__ENCRYPTED_FILE_METADATA_SIGNATURE;
pub const PENCRYPTED_FILE_METADATA_SIGNATURE = [*c]struct__ENCRYPTED_FILE_METADATA_SIGNATURE;
pub const struct__ENCRYPTION_PROTECTOR = extern struct {
    cbTotalLength: DWORD,
    pUserSid: [*c]SID,
    lpProtectorDescriptor: LPWSTR,
};
pub const ENCRYPTION_PROTECTOR = struct__ENCRYPTION_PROTECTOR;
pub const PENCRYPTION_PROTECTOR = [*c]struct__ENCRYPTION_PROTECTOR;
pub const struct__ENCRYPTION_PROTECTOR_LIST = extern struct {
    nProtectors: DWORD,
    pProtectors: [*c]PENCRYPTION_PROTECTOR,
};
pub const ENCRYPTION_PROTECTOR_LIST = struct__ENCRYPTION_PROTECTOR_LIST;
pub const PENCRYPTION_PROTECTOR_LIST = [*c]struct__ENCRYPTION_PROTECTOR_LIST;
pub extern "advapi32" fn QueryUsersOnEncryptedFile(lpFileName: LPCWSTR, pUsers: [*c]PENCRYPTION_CERTIFICATE_HASH_LIST) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn QueryRecoveryAgentsOnEncryptedFile(lpFileName: LPCWSTR, pRecoveryAgents: [*c]PENCRYPTION_CERTIFICATE_HASH_LIST) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn RemoveUsersFromEncryptedFile(lpFileName: LPCWSTR, pHashes: PENCRYPTION_CERTIFICATE_HASH_LIST) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn AddUsersToEncryptedFile(lpFileName: LPCWSTR, pEncryptionCertificates: PENCRYPTION_CERTIFICATE_LIST) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn SetUserFileEncryptionKey(pEncryptionCertificate: PENCRYPTION_CERTIFICATE) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn SetUserFileEncryptionKeyEx(pEncryptionCertificate: PENCRYPTION_CERTIFICATE, dwCapabilities: DWORD, dwFlags: DWORD, pvReserved: LPVOID) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn FreeEncryptionCertificateHashList(pUsers: PENCRYPTION_CERTIFICATE_HASH_LIST) callconv(.Stdcall) void;
pub extern "advapi32" fn EncryptionDisable(DirPath: LPCWSTR, Disable: BOOL) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn DuplicateEncryptionInfoFile(SrcFileName: LPCWSTR, DstFileName: LPCWSTR, dwCreationDistribution: DWORD, dwAttributes: DWORD, lpSecurityAttributes: LPSECURITY_ATTRIBUTES) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn GetEncryptedFileMetadata(lpFileName: LPCWSTR, pcbMetadata: PDWORD, ppbMetadata: [*c]PBYTE) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn SetEncryptedFileMetadata(lpFileName: LPCWSTR, pbOldMetadata: PBYTE, pbNewMetadata: PBYTE, pOwnerHash: PENCRYPTION_CERTIFICATE_HASH, dwOperation: DWORD, pCertificatesAdded: PENCRYPTION_CERTIFICATE_HASH_LIST) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn FreeEncryptedFileMetadata(pbMetadata: PBYTE) callconv(.Stdcall) void;
pub const RPC_IMPORT_CONTEXT_P = extern struct {
    LookupContext: RPC_NS_HANDLE,
    ProposedHandle: RPC_BINDING_HANDLE,
    Bindings: [*c]RPC_BINDING_VECTOR,
};
pub const PRPC_IMPORT_CONTEXT_P = [*c]extern struct {
    LookupContext: RPC_NS_HANDLE,
    ProposedHandle: RPC_BINDING_HANDLE,
    Bindings: [*c]RPC_BINDING_VECTOR,
};
pub extern "rpc4ns" fn I_RpcNsGetBuffer(Message: PRPC_MESSAGE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpc4ns" fn I_RpcNsSendReceive(Message: PRPC_MESSAGE, Handle: [*c]RPC_BINDING_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpc4ns" fn I_RpcNsRaiseException(Message: PRPC_MESSAGE, Status: RPC_STATUS) callconv(.Stdcall) void;
pub extern "rpc4ns" fn I_RpcReBindBuffer(Message: PRPC_MESSAGE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpc4ns" fn I_NsServerBindSearch() callconv(.Stdcall) RPC_STATUS;
pub extern "rpc4ns" fn I_NsClientBindSearch() callconv(.Stdcall) RPC_STATUS;
pub extern "rpc4ns" fn I_NsClientBindDone() callconv(.Stdcall) void;
pub const byte = u8;
pub const cs_byte = byte;
pub const boolean = u8;
pub extern fn MIDL_user_allocate(size: usize) ?*c_void;
pub extern fn MIDL_user_free(arg0: ?*c_void) void;
pub extern "rpc4rt" fn I_RpcDefaultAllocate(bh: handle_t, size: usize, RealAlloc: ?fn (usize) callconv(.C) ?*c_void) callconv(.Stdcall) ?*c_void;
pub extern "rpc4rt" fn I_RpcDefaultFree(bh: handle_t, arg1: ?*c_void, RealFree: ?fn (?*c_void) callconv(.C) void) callconv(.Stdcall) void;
pub const NDR_CCONTEXT = ?*c_void;
pub const NDR_SCONTEXT = [*c]extern struct {
    pad: [2](?*c_void),
    userContext: ?*c_void,
};
pub const NDR_RUNDOWN = ?fn (?*c_void) callconv(.C) void;
pub const NDR_NOTIFY_ROUTINE = ?fn () callconv(.C) void;
pub const NDR_NOTIFY2_ROUTINE = ?fn (boolean) callconv(.C) void;
pub const struct__SCONTEXT_QUEUE = extern struct {
    NumberOfObjects: c_ulong,
    ArrayOfObjects: [*c]NDR_SCONTEXT,
};
pub const SCONTEXT_QUEUE = struct__SCONTEXT_QUEUE;
pub const PSCONTEXT_QUEUE = [*c]struct__SCONTEXT_QUEUE;
pub extern "onecore" fn NDRCContextBinding(CContext: NDR_CCONTEXT) callconv(.Stdcall) RPC_BINDING_HANDLE;
pub extern "onecore" fn NDRCContextMarshall(CContext: NDR_CCONTEXT, pBuff: ?*c_void) callconv(.Stdcall) void;
pub extern "onecore" fn NDRCContextUnmarshall(pCContext: [*c]NDR_CCONTEXT, hBinding: RPC_BINDING_HANDLE, pBuff: ?*c_void, DataRepresentation: c_ulong) callconv(.Stdcall) void;
pub extern "onecore" fn NDRCContextUnmarshall2(pCContext: [*c]NDR_CCONTEXT, hBinding: RPC_BINDING_HANDLE, pBuff: ?*c_void, DataRepresentation: c_ulong) callconv(.Stdcall) void;
pub extern "onecore" fn NDRSContextMarshall(CContext: NDR_SCONTEXT, pBuff: ?*c_void, userRunDownIn: NDR_RUNDOWN) callconv(.Stdcall) void;
pub extern "onecore" fn NDRSContextUnmarshall(pBuff: ?*c_void, DataRepresentation: c_ulong) callconv(.Stdcall) NDR_SCONTEXT;
pub extern "onecore" fn NDRSContextMarshallEx(BindingHandle: RPC_BINDING_HANDLE, CContext: NDR_SCONTEXT, pBuff: ?*c_void, userRunDownIn: NDR_RUNDOWN) callconv(.Stdcall) void;
pub extern "onecore" fn NDRSContextMarshall2(BindingHandle: RPC_BINDING_HANDLE, CContext: NDR_SCONTEXT, pBuff: ?*c_void, userRunDownIn: NDR_RUNDOWN, CtxGuard: ?*c_void, Flags: c_ulong) callconv(.Stdcall) void;
pub extern "onecore" fn NDRSContextUnmarshallEx(BindingHandle: RPC_BINDING_HANDLE, pBuff: ?*c_void, DataRepresentation: c_ulong) callconv(.Stdcall) NDR_SCONTEXT;
pub extern "onecore" fn NDRSContextUnmarshall2(BindingHandle: RPC_BINDING_HANDLE, pBuff: ?*c_void, DataRepresentation: c_ulong, CtxGuard: ?*c_void, Flags: c_ulong) callconv(.Stdcall) NDR_SCONTEXT;
pub extern "rpc4rt" fn RpcSsDestroyClientContext(ContextHandle: [*c](?*c_void)) callconv(.Stdcall) void;
pub const error_status_t = c_ulong;
pub const struct__MIDL_STUB_MESSAGE = @OpaqueType();
pub const GENERIC_BINDING_ROUTINE = ?fn (?*c_void) callconv(.C) ?*c_void;
pub const GENERIC_UNBIND_ROUTINE = ?fn (?*c_void, [*c]u8) callconv(.C) void;
pub const struct___GENERIC_BINDING_INFO = extern struct {
    pObj: ?*c_void,
    Size: c_uint,
    pfnBind: GENERIC_BINDING_ROUTINE,
    pfnUnbind: GENERIC_UNBIND_ROUTINE,
};
pub const PGENERIC_BINDING_INFO = [*c]struct___GENERIC_BINDING_INFO;
pub const struct__GENERIC_BINDING_ROUTINE_PAIR = extern struct {
    pfnBind: GENERIC_BINDING_ROUTINE,
    pfnUnbind: GENERIC_UNBIND_ROUTINE,
};
pub const GENERIC_BINDING_ROUTINE_PAIR = struct__GENERIC_BINDING_ROUTINE_PAIR;
pub const EXPR_EVAL = ?fn (?*struct__MIDL_STUB_MESSAGE) callconv(.C) void;
pub const PMIDL_STUB_MESSAGE = ?*struct__MIDL_STUB_MESSAGE;
pub const XMIT_HELPER_ROUTINE = ?fn (PMIDL_STUB_MESSAGE) callconv(.C) void;
pub const struct__XMIT_ROUTINE_QUINTUPLE = extern struct {
    pfnTranslateToXmit: XMIT_HELPER_ROUTINE,
    pfnTranslateFromXmit: XMIT_HELPER_ROUTINE,
    pfnFreeXmit: XMIT_HELPER_ROUTINE,
    pfnFreeInst: XMIT_HELPER_ROUTINE,
};
pub const XMIT_ROUTINE_QUINTUPLE = struct__XMIT_ROUTINE_QUINTUPLE;
pub const struct__MALLOC_FREE_STRUCT = extern struct {
    pfnAllocate: ?fn (usize) callconv(.C) ?*c_void,
    pfnFree: ?fn (?*c_void) callconv(.C) void,
};
pub const MALLOC_FREE_STRUCT = struct__MALLOC_FREE_STRUCT;
pub const struct__COMM_FAULT_OFFSETS = extern struct {
    CommOffset: c_short,
    FaultOffset: c_short,
};
pub const COMM_FAULT_OFFSETS = struct__COMM_FAULT_OFFSETS;
pub const USER_MARSHAL_SIZING_ROUTINE = ?fn ([*c]c_ulong, c_ulong, ?*c_void) callconv(.C) c_ulong;
pub const USER_MARSHAL_MARSHALLING_ROUTINE = ?fn ([*c]c_ulong, [*c]u8, ?*c_void) callconv(.C) [*c]u8;
pub const USER_MARSHAL_UNMARSHALLING_ROUTINE = ?fn ([*c]c_ulong, [*c]u8, ?*c_void) callconv(.C) [*c]u8;
pub const USER_MARSHAL_FREEING_ROUTINE = ?fn ([*c]c_ulong, ?*c_void) callconv(.C) void;
pub const struct__USER_MARSHAL_ROUTINE_QUADRUPLE = extern struct {
    pfnBufferSize: USER_MARSHAL_SIZING_ROUTINE,
    pfnMarshall: USER_MARSHAL_MARSHALLING_ROUTINE,
    pfnUnmarshall: USER_MARSHAL_UNMARSHALLING_ROUTINE,
    pfnFree: USER_MARSHAL_FREEING_ROUTINE,
};
pub const USER_MARSHAL_ROUTINE_QUADRUPLE = struct__USER_MARSHAL_ROUTINE_QUADRUPLE;
pub const IDL_CS_NO_CONVERT = enum__IDL_CS_CONVERT.IDL_CS_NO_CONVERT;
pub const IDL_CS_IN_PLACE_CONVERT = enum__IDL_CS_CONVERT.IDL_CS_IN_PLACE_CONVERT;
pub const IDL_CS_NEW_BUFFER_CONVERT = enum__IDL_CS_CONVERT.IDL_CS_NEW_BUFFER_CONVERT;
pub const enum__IDL_CS_CONVERT = extern enum {
    IDL_CS_NO_CONVERT,
    IDL_CS_IN_PLACE_CONVERT,
    IDL_CS_NEW_BUFFER_CONVERT,
};
pub const IDL_CS_CONVERT = extern enum {
    IDL_CS_NO_CONVERT,
    IDL_CS_IN_PLACE_CONVERT,
    IDL_CS_NEW_BUFFER_CONVERT,
};
pub const CS_TYPE_NET_SIZE_ROUTINE = ?fn (RPC_BINDING_HANDLE, c_ulong, c_ulong, [*c]IDL_CS_CONVERT, [*c]c_ulong, [*c]error_status_t) callconv(.C) void;
pub const CS_TYPE_TO_NETCS_ROUTINE = ?fn (RPC_BINDING_HANDLE, c_ulong, ?*c_void, c_ulong, [*c]byte, [*c]c_ulong, [*c]error_status_t) callconv(.C) void;
pub const CS_TYPE_LOCAL_SIZE_ROUTINE = ?fn (RPC_BINDING_HANDLE, c_ulong, c_ulong, [*c]IDL_CS_CONVERT, [*c]c_ulong, [*c]error_status_t) callconv(.C) void;
pub const CS_TYPE_FROM_NETCS_ROUTINE = ?fn (RPC_BINDING_HANDLE, c_ulong, [*c]byte, c_ulong, c_ulong, ?*c_void, [*c]c_ulong, [*c]error_status_t) callconv(.C) void;
pub const struct__NDR_CS_SIZE_CONVERT_ROUTINES = extern struct {
    pfnNetSize: CS_TYPE_NET_SIZE_ROUTINE,
    pfnToNetCs: CS_TYPE_TO_NETCS_ROUTINE,
    pfnLocalSize: CS_TYPE_LOCAL_SIZE_ROUTINE,
    pfnFromNetCs: CS_TYPE_FROM_NETCS_ROUTINE,
};
pub const NDR_CS_SIZE_CONVERT_ROUTINES = struct__NDR_CS_SIZE_CONVERT_ROUTINES;
pub const CS_TAG_GETTING_ROUTINE = ?fn (RPC_BINDING_HANDLE, c_int, [*c]c_ulong, [*c]c_ulong, [*c]c_ulong, [*c]error_status_t) callconv(.C) void;
pub const struct__NDR_CS_ROUTINES = extern struct {
    pSizeConvertRoutines: [*c]NDR_CS_SIZE_CONVERT_ROUTINES,
    pTagGettingRoutines: [*c]CS_TAG_GETTING_ROUTINE,
};
pub const NDR_CS_ROUTINES = struct__NDR_CS_ROUTINES;
pub const PFORMAT_STRING = [*c]const u8;
pub const struct__NDR_EXPR_DESC = extern struct {
    pOffset: [*c]const c_ushort,
    pFormatExpr: PFORMAT_STRING,
};
pub const NDR_EXPR_DESC = struct__NDR_EXPR_DESC;
pub const struct__MIDL_STUB_DESC = extern struct {
    RpcInterfaceInformation: ?*c_void,
    pfnAllocate: ?fn (usize) callconv(.C) ?*c_void,
    pfnFree: ?fn (?*c_void) callconv(.C) void,
    IMPLICIT_HANDLE_INFO: extern union {
        pAutoHandle: [*c]handle_t,
        pPrimitiveHandle: [*c]handle_t,
        pGenericBindingInfo: PGENERIC_BINDING_INFO,
    },
    apfnNdrRundownRoutines: [*c]const NDR_RUNDOWN,
    aGenericBindingRoutinePairs: [*c]const GENERIC_BINDING_ROUTINE_PAIR,
    apfnExprEval: [*c]const EXPR_EVAL,
    aXmitQuintuple: [*c]const XMIT_ROUTINE_QUINTUPLE,
    pFormatTypes: [*c]const u8,
    fCheckBounds: c_int,
    Version: c_ulong,
    pMallocFreeStruct: [*c]MALLOC_FREE_STRUCT,
    MIDLVersion: c_long,
    CommFaultOffsets: [*c]const COMM_FAULT_OFFSETS,
    aUserMarshalQuadruple: [*c]const USER_MARSHAL_ROUTINE_QUADRUPLE,
    NotifyRoutineTable: [*c]const NDR_NOTIFY_ROUTINE,
    mFlags: ULONG_PTR,
    CsRoutineTables: [*c]const NDR_CS_ROUTINES,
    ProxyServerInfo: ?*c_void,
    pExprInfo: [*c]const NDR_EXPR_DESC,
};
pub const XLAT_SERVER = 1;
pub const XLAT_CLIENT = 2;
pub const XLAT_SIDE = extern enum {
    XLAT_SERVER = 1,
    XLAT_CLIENT = 2,
};
pub const struct__FULL_PTR_XLAT_TABLES = extern struct {
    RefIdToPointer: ?*c_void,
    PointerToRefId: ?*c_void,
    NextRefId: c_ulong,
    XlatSide: XLAT_SIDE,
};
pub const RPC_BUFPTR = [*c]u8;
pub const RPC_LENGTH = c_ulong;
pub const ARRAY_INFO = extern struct {
    Dimension: c_long,
    BufferConformanceMark: [*c]c_ulong,
    BufferVarianceMark: [*c]c_ulong,
    MaxCountArray: [*c]c_ulong,
    OffsetArray: [*c]c_ulong,
    ActualCountArray: [*c]c_ulong,
};
pub const PARRAY_INFO = [*c]extern struct {
    Dimension: c_long,
    BufferConformanceMark: [*c]c_ulong,
    BufferVarianceMark: [*c]c_ulong,
    MaxCountArray: [*c]c_ulong,
    OffsetArray: [*c]c_ulong,
    ActualCountArray: [*c]c_ulong,
};
pub const struct__NDR_ASYNC_MESSAGE = @OpaqueType();
pub const PNDR_ASYNC_MESSAGE = ?*struct__NDR_ASYNC_MESSAGE;
pub const struct__NDR_CORRELATION_INFO = @OpaqueType();
pub const PNDR_CORRELATION_INFO = ?*struct__NDR_CORRELATION_INFO;
pub const struct__MIDL_METHOD_PROPERTY = extern struct {
    Id: c_ulong,
    Value: ULONG_PTR,
};
pub const MIDL_METHOD_PROPERTY = struct__MIDL_METHOD_PROPERTY;
pub const struct__MIDL_METHOD_PROPERTY_MAP = extern struct {
    Count: c_ulong,
    Properties: [*c]const MIDL_METHOD_PROPERTY,
};
pub const MIDL_METHOD_PROPERTY_MAP = struct__MIDL_METHOD_PROPERTY_MAP;
pub const struct__MIDL_INTERFACE_METHOD_PROPERTIES = extern struct {
    MethodCount: c_ushort,
    MethodProperties: [*c]const ([*c]const MIDL_METHOD_PROPERTY_MAP),
};
pub const MIDL_INTERFACE_METHOD_PROPERTIES = struct__MIDL_INTERFACE_METHOD_PROPERTIES;
pub const struct__MIDL_SYNTAX_INFO = extern struct {
    TransferSyntax: RPC_SYNTAX_IDENTIFIER,
    DispatchTable: [*c]RPC_DISPATCH_TABLE,
    ProcString: PFORMAT_STRING,
    FmtStringOffset: [*c]const c_ushort,
    TypeString: PFORMAT_STRING,
    aUserMarshalQuadruple: ?*const c_void,
    pMethodProperties: [*c]const MIDL_INTERFACE_METHOD_PROPERTIES,
    pReserved2: ULONG_PTR,
};
pub const MIDL_SYNTAX_INFO = struct__MIDL_SYNTAX_INFO;
pub const PMIDL_SYNTAX_INFO = [*c]struct__MIDL_SYNTAX_INFO;
pub const struct_NDR_ALLOC_ALL_NODES_CONTEXT = @OpaqueType();
pub const struct_NDR_POINTER_QUEUE_STATE = @OpaqueType();
pub const struct__NDR_PROC_CONTEXT = @OpaqueType();
pub const MIDL_STUB_MESSAGE = struct__MIDL_STUB_MESSAGE;
pub const PGENERIC_BINDING_ROUTINE_PAIR = [*c]struct__GENERIC_BINDING_ROUTINE_PAIR;
pub const GENERIC_BINDING_INFO = struct___GENERIC_BINDING_INFO;
pub const PXMIT_ROUTINE_QUINTUPLE = [*c]struct__XMIT_ROUTINE_QUINTUPLE;
pub const USER_MARSHAL_CB_BUFFER_SIZE = enum__USER_MARSHAL_CB_TYPE.USER_MARSHAL_CB_BUFFER_SIZE;
pub const USER_MARSHAL_CB_MARSHALL = enum__USER_MARSHAL_CB_TYPE.USER_MARSHAL_CB_MARSHALL;
pub const USER_MARSHAL_CB_UNMARSHALL = enum__USER_MARSHAL_CB_TYPE.USER_MARSHAL_CB_UNMARSHALL;
pub const USER_MARSHAL_CB_FREE = enum__USER_MARSHAL_CB_TYPE.USER_MARSHAL_CB_FREE;
pub const enum__USER_MARSHAL_CB_TYPE = extern enum {
    USER_MARSHAL_CB_BUFFER_SIZE,
    USER_MARSHAL_CB_MARSHALL,
    USER_MARSHAL_CB_UNMARSHALL,
    USER_MARSHAL_CB_FREE,
};
pub const USER_MARSHAL_CB_TYPE = enum__USER_MARSHAL_CB_TYPE;
pub const struct__USER_MARSHAL_CB = extern struct {
    Flags: c_ulong,
    pStubMsg: PMIDL_STUB_MESSAGE,
    pReserve: PFORMAT_STRING,
    Signature: c_ulong,
    CBType: USER_MARSHAL_CB_TYPE,
    pFormat: PFORMAT_STRING,
    pTypeFormat: PFORMAT_STRING,
};
pub const USER_MARSHAL_CB = struct__USER_MARSHAL_CB;
pub extern fn RpcCsGetTags(hBinding: RPC_BINDING_HANDLE, fServerSide: c_int, pulSendingTag: [*c]c_ulong, pulDesiredReceivingTag: [*c]c_ulong, pulReceivingTag: [*c]c_ulong, pStatus: [*c]error_status_t) void;
pub const MIDL_STUB_DESC = struct__MIDL_STUB_DESC;
pub const PMIDL_STUB_DESC = [*c]const MIDL_STUB_DESC;
pub const PMIDL_XMIT_TYPE = ?*c_void;
pub const struct__MIDL_FORMAT_STRING = extern struct {
    Pad: c_short,
    Format: [*c]u8,
};
pub const MIDL_FORMAT_STRING = struct__MIDL_FORMAT_STRING;
pub const STUB_THUNK = ?fn (PMIDL_STUB_MESSAGE) callconv(.C) void;
pub const SERVER_ROUTINE = [*c]fn () callconv(.C) c_long;
pub const PMIDL_METHOD_PROPERTY = [*c]struct__MIDL_METHOD_PROPERTY;
pub const PMIDL_METHOD_PROPERTY_MAP = [*c]struct__MIDL_METHOD_PROPERTY_MAP;
pub const struct__MIDL_SERVER_INFO_ = extern struct {
    pStubDesc: PMIDL_STUB_DESC,
    DispatchTable: [*c]const SERVER_ROUTINE,
    ProcString: PFORMAT_STRING,
    FmtStringOffset: [*c]const c_ushort,
    ThunkTable: [*c]const STUB_THUNK,
    pTransferSyntax: PRPC_SYNTAX_IDENTIFIER,
    nCount: ULONG_PTR,
    pSyntaxInfo: PMIDL_SYNTAX_INFO,
};
pub const MIDL_SERVER_INFO = struct__MIDL_SERVER_INFO_;
pub const PMIDL_SERVER_INFO = [*c]struct__MIDL_SERVER_INFO_;
pub const struct__MIDL_STUBLESS_PROXY_INFO = extern struct {
    pStubDesc: PMIDL_STUB_DESC,
    ProcFormatString: PFORMAT_STRING,
    FormatStringOffset: [*c]const c_ushort,
    pTransferSyntax: PRPC_SYNTAX_IDENTIFIER,
    nCount: ULONG_PTR,
    pSyntaxInfo: PMIDL_SYNTAX_INFO,
};
pub const MIDL_STUBLESS_PROXY_INFO = struct__MIDL_STUBLESS_PROXY_INFO;
pub const PMIDL_STUBLESS_PROXY_INFO = [*c]MIDL_STUBLESS_PROXY_INFO;
pub const PARAM_OFFSETTABLE = [*c]c_ushort;
pub const PPARAM_OFFSETTABLE = [*c]c_ushort;
pub const union__CLIENT_CALL_RETURN = extern union {
    Pointer: ?*c_void,
    Simple: LONG_PTR,
};
pub const CLIENT_CALL_RETURN = union__CLIENT_CALL_RETURN;
pub const FULL_PTR_XLAT_TABLES = struct__FULL_PTR_XLAT_TABLES;
pub const PFULL_PTR_XLAT_TABLES = [*c]struct__FULL_PTR_XLAT_TABLES;
pub const SYSTEM_HANDLE_FILE = enum__system_handle_t.SYSTEM_HANDLE_FILE;
pub const SYSTEM_HANDLE_SEMAPHORE = enum__system_handle_t.SYSTEM_HANDLE_SEMAPHORE;
pub const SYSTEM_HANDLE_EVENT = enum__system_handle_t.SYSTEM_HANDLE_EVENT;
pub const SYSTEM_HANDLE_MUTEX = enum__system_handle_t.SYSTEM_HANDLE_MUTEX;
pub const SYSTEM_HANDLE_PROCESS = enum__system_handle_t.SYSTEM_HANDLE_PROCESS;
pub const SYSTEM_HANDLE_TOKEN = enum__system_handle_t.SYSTEM_HANDLE_TOKEN;
pub const SYSTEM_HANDLE_SECTION = enum__system_handle_t.SYSTEM_HANDLE_SECTION;
pub const SYSTEM_HANDLE_REG_KEY = enum__system_handle_t.SYSTEM_HANDLE_REG_KEY;
pub const SYSTEM_HANDLE_THREAD = enum__system_handle_t.SYSTEM_HANDLE_THREAD;
pub const SYSTEM_HANDLE_COMPOSITION_OBJECT = enum__system_handle_t.SYSTEM_HANDLE_COMPOSITION_OBJECT;
pub const SYSTEM_HANDLE_SOCKET = enum__system_handle_t.SYSTEM_HANDLE_SOCKET;
pub const SYSTEM_HANDLE_JOB = enum__system_handle_t.SYSTEM_HANDLE_JOB;
pub const SYSTEM_HANDLE_PIPE = enum__system_handle_t.SYSTEM_HANDLE_PIPE;
pub const SYSTEM_HANDLE_MAX = enum__system_handle_t.SYSTEM_HANDLE_MAX;
pub const SYSTEM_HANDLE_INVALID = enum__system_handle_t.SYSTEM_HANDLE_INVALID;
pub const enum__system_handle_t = extern enum {
    SYSTEM_HANDLE_FILE = 0,
    SYSTEM_HANDLE_SEMAPHORE = 1,
    SYSTEM_HANDLE_EVENT = 2,
    SYSTEM_HANDLE_MUTEX = 3,
    SYSTEM_HANDLE_PROCESS = 4,
    SYSTEM_HANDLE_TOKEN = 5,
    SYSTEM_HANDLE_SECTION = 6,
    SYSTEM_HANDLE_REG_KEY = 7,
    SYSTEM_HANDLE_THREAD = 8,
    SYSTEM_HANDLE_COMPOSITION_OBJECT = 9,
    SYSTEM_HANDLE_SOCKET = 10,
    SYSTEM_HANDLE_JOB = 11,
    SYSTEM_HANDLE_PIPE = 12,
    SYSTEM_HANDLE_MAX = 12,
    SYSTEM_HANDLE_INVALID = 255,
};
pub const system_handle_t = enum__system_handle_t;
pub const MidlInterceptionInfoVersionOne = 1;
pub const MidlWinrtTypeSerializationInfoVersionOne = 1;
pub const struct__MIDL_INTERCEPTION_INFO = extern struct {
    Version: c_ulong,
    ProcString: PFORMAT_STRING,
    ProcFormatOffsetTable: [*c]const c_ushort,
    ProcCount: c_ulong,
    TypeString: PFORMAT_STRING,
};
pub const MIDL_INTERCEPTION_INFO = struct__MIDL_INTERCEPTION_INFO;
pub const PMIDL_INTERCEPTION_INFO = [*c]struct__MIDL_INTERCEPTION_INFO;
pub const struct__MIDL_WINRT_TYPE_SERIALIZATION_INFO = extern struct {
    Version: c_ulong,
    TypeFormatString: PFORMAT_STRING,
    FormatStringSize: c_ushort,
    TypeOffset: c_ushort,
    StubDesc: PMIDL_STUB_DESC,
};
pub const MIDL_WINRT_TYPE_SERIALIZATION_INFO = struct__MIDL_WINRT_TYPE_SERIALIZATION_INFO;
pub const PMIDL_WINRT_TYPE_SERIALIZATION_INFO = [*c]struct__MIDL_WINRT_TYPE_SERIALIZATION_INFO;
pub extern "rpcrt4" fn NdrClientGetSupportedSyntaxes(pInf: [*c]RPC_CLIENT_INTERFACE, pCount: [*c]c_ulong, pArr: [*c]([*c]MIDL_SYNTAX_INFO)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn NdrServerGetSupportedSyntaxes(pInf: [*c]RPC_SERVER_INTERFACE, pCount: [*c]c_ulong, pArr: [*c]([*c]MIDL_SYNTAX_INFO), pPreferSyntaxIndex: [*c]c_ulong) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn NdrSimpleTypeMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, FormatChar: u8) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrPointerMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrCsArrayMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrCsTagMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrSimpleStructMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrConformantStructMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrConformantVaryingStructMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrComplexStructMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrFixedArrayMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrConformantArrayMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrConformantVaryingArrayMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrVaryingArrayMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrComplexArrayMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrNonConformantStringMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrConformantStringMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrEncapsulatedUnionMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrNonEncapsulatedUnionMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrByteCountPointerMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrXmitOrRepAsMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrUserMarshalMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrInterfacePointerMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrClientContextMarshall(pStubMsg: PMIDL_STUB_MESSAGE, ContextHandle: NDR_CCONTEXT, fCheck: c_int) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrServerContextMarshall(pStubMsg: PMIDL_STUB_MESSAGE, ContextHandle: NDR_SCONTEXT, RundownRoutine: NDR_RUNDOWN) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrServerContextNewMarshall(pStubMsg: PMIDL_STUB_MESSAGE, ContextHandle: NDR_SCONTEXT, RundownRoutine: NDR_RUNDOWN, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrSimpleTypeUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, FormatChar: u8) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrCsArrayUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrCsTagUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrRangeUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrCorrelationInitialize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: ?*c_void, CacheSize: c_ulong, flags: c_ulong) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrCorrelationPass(pStubMsg: PMIDL_STUB_MESSAGE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrCorrelationFree(pStubMsg: PMIDL_STUB_MESSAGE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrPointerUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrSimpleStructUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrConformantStructUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrConformantVaryingStructUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrComplexStructUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrFixedArrayUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrConformantArrayUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrConformantVaryingArrayUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrVaryingArrayUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrComplexArrayUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrNonConformantStringUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrConformantStringUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrEncapsulatedUnionUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrNonEncapsulatedUnionUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrByteCountPointerUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrXmitOrRepAsUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrUserMarshalUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrInterfacePointerUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c]([*c]u8), pFormat: PFORMAT_STRING, fMustAlloc: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrClientContextUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, pContextHandle: [*c]NDR_CCONTEXT, BindHandle: RPC_BINDING_HANDLE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrServerContextUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE) callconv(.Stdcall) NDR_SCONTEXT;
pub extern "rpcrt4" fn NdrContextHandleInitialize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) NDR_SCONTEXT;
pub extern "rpcrt4" fn NdrServerContextNewUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) NDR_SCONTEXT;
pub extern "rpcrt4" fn NdrPointerBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrCsArrayBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrCsTagBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrSimpleStructBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrConformantStructBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrConformantVaryingStructBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrComplexStructBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrFixedArrayBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrConformantArrayBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrConformantVaryingArrayBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrVaryingArrayBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrComplexArrayBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrConformantStringBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrNonConformantStringBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrEncapsulatedUnionBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrNonEncapsulatedUnionBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrByteCountPointerBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrXmitOrRepAsBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrUserMarshalBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrInterfacePointerBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrContextHandleSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrPointerMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrContextHandleMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrCsArrayMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrCsTagMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrSimpleStructMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrConformantStructMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrConformantVaryingStructMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrComplexStructMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrFixedArrayMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrConformantArrayMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrConformantVaryingArrayMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrVaryingArrayMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrComplexArrayMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrConformantStringMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrNonConformantStringMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrEncapsulatedUnionMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrNonEncapsulatedUnionMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrXmitOrRepAsMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrUserMarshalMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrInterfacePointerMemorySize(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) c_ulong;
pub extern "rpcrt4" fn NdrPointerFree(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrCsArrayFree(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrSimpleStructFree(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrConformantStructFree(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrConformantVaryingStructFree(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrComplexStructFree(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrFixedArrayFree(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrConformantArrayFree(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrConformantVaryingArrayFree(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrVaryingArrayFree(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrComplexArrayFree(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrEncapsulatedUnionFree(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrNonEncapsulatedUnionFree(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrByteCountPointerFree(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrXmitOrRepAsFree(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrUserMarshalFree(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrInterfacePointerFree(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: [*c]u8, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrConvert2(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING, NumberParams: c_long) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrConvert(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrUserMarshalSimpleTypeConvert(pFlags: [*c]c_ulong, pBuffer: [*c]u8, FormatChar: u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrClientInitializeNew(pRpcMsg: PRPC_MESSAGE, pStubMsg: PMIDL_STUB_MESSAGE, pStubDescriptor: PMIDL_STUB_DESC, ProcNum: c_uint) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrServerInitializeNew(pRpcMsg: PRPC_MESSAGE, pStubMsg: PMIDL_STUB_MESSAGE, pStubDescriptor: PMIDL_STUB_DESC) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrServerInitializePartial(pRpcMsg: PRPC_MESSAGE, pStubMsg: PMIDL_STUB_MESSAGE, pStubDescriptor: PMIDL_STUB_DESC, RequestedBufferSize: c_ulong) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrClientInitialize(pRpcMsg: PRPC_MESSAGE, pStubMsg: PMIDL_STUB_MESSAGE, pStubDescriptor: PMIDL_STUB_DESC, ProcNum: c_uint) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrServerInitialize(pRpcMsg: PRPC_MESSAGE, pStubMsg: PMIDL_STUB_MESSAGE, pStubDescriptor: PMIDL_STUB_DESC) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrServerInitializeUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, pStubDescriptor: PMIDL_STUB_DESC, pRpcMsg: PRPC_MESSAGE) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrServerInitializeMarshall(pRpcMsg: PRPC_MESSAGE, pStubMsg: PMIDL_STUB_MESSAGE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrGetBuffer(pStubMsg: PMIDL_STUB_MESSAGE, BufferLength: c_ulong, Handle: RPC_BINDING_HANDLE) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrNsGetBuffer(pStubMsg: PMIDL_STUB_MESSAGE, BufferLength: c_ulong, Handle: RPC_BINDING_HANDLE) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrSendReceive(pStubMsg: PMIDL_STUB_MESSAGE, pBufferEnd: [*c]u8) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrNsSendReceive(pStubMsg: PMIDL_STUB_MESSAGE, pBufferEnd: [*c]u8, pAutoHandle: [*c]RPC_BINDING_HANDLE) callconv(.Stdcall) [*c]u8;
pub extern "rpcrt4" fn NdrFreeBuffer(pStubMsg: PMIDL_STUB_MESSAGE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrGetDcomProtocolVersion(pStubMsg: PMIDL_STUB_MESSAGE, pVersion: [*c]RPC_VERSION) callconv(.Stdcall) HRESULT;
pub extern "rpcrt4" fn NdrClientCall2(pStubDescriptor: PMIDL_STUB_DESC, pFormat: PFORMAT_STRING, ...) callconv(.Stdcall) CLIENT_CALL_RETURN;
pub extern "rpcrt4" fn NdrClientCall(pStubDescriptor: PMIDL_STUB_DESC, pFormat: PFORMAT_STRING, ...) callconv(.Stdcall) CLIENT_CALL_RETURN;
pub extern "rpcrt4" fn NdrAsyncClientCall(pStubDescriptor: PMIDL_STUB_DESC, pFormat: PFORMAT_STRING, ...) callconv(.Stdcall) CLIENT_CALL_RETURN;
pub extern "rpcrt4" fn NdrDcomAsyncClientCall(pStubDescriptor: PMIDL_STUB_DESC, pFormat: PFORMAT_STRING, ...) callconv(.Stdcall) CLIENT_CALL_RETURN;
pub const STUB_UNMARSHAL = 0;
pub const STUB_CALL_SERVER = 1;
pub const STUB_MARSHAL = 2;
pub const STUB_CALL_SERVER_NO_HRESULT = 3;
pub const STUB_PHASE = extern enum {
    STUB_UNMARSHAL = 0,
    STUB_CALL_SERVER = 1,
    STUB_MARSHAL = 2,
    STUB_CALL_SERVER_NO_HRESULT = 3,
};
pub const PROXY_CALCSIZE = 0;
pub const PROXY_GETBUFFER = 1;
pub const PROXY_MARSHAL = 2;
pub const PROXY_SENDRECEIVE = 3;
pub const PROXY_UNMARSHAL = 4;
pub const PROXY_PHASE = extern enum {
    PROXY_CALCSIZE = 0,
    PROXY_GETBUFFER = 1,
    PROXY_MARSHAL = 2,
    PROXY_SENDRECEIVE = 3,
    PROXY_UNMARSHAL = 4,
};
pub const IRpcStubBuffer = struct_IRpcStubBuffer;
pub const struct_IUnknownVtbl = extern struct {
    QueryInterface: ?fn ([*c]IUnknown, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IUnknown) callconv(.C) ULONG,
    Release: ?fn ([*c]IUnknown) callconv(.C) ULONG,
};
pub const struct_IUnknown = extern struct {
    lpVtbl: [*c]struct_IUnknownVtbl,
};
pub const IUnknown = struct_IUnknown;
pub const RPCOLEDATAREP = ULONG;
pub const struct_tagRPCOLEMESSAGE = extern struct {
    reserved1: ?*c_void,
    dataRepresentation: RPCOLEDATAREP,
    Buffer: ?*c_void,
    cbBuffer: ULONG,
    iMethod: ULONG,
    reserved2: [5](?*c_void),
    rpcFlags: ULONG,
};
pub const RPCOLEMESSAGE = struct_tagRPCOLEMESSAGE;
pub const struct_IRpcChannelBufferVtbl = extern struct {
    QueryInterface: ?fn ([*c]IRpcChannelBuffer, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IRpcChannelBuffer) callconv(.C) ULONG,
    Release: ?fn ([*c]IRpcChannelBuffer) callconv(.C) ULONG,
    GetBuffer: ?fn ([*c]IRpcChannelBuffer, [*c]RPCOLEMESSAGE, [*c]const IID) callconv(.C) HRESULT,
    SendReceive: ?fn ([*c]IRpcChannelBuffer, [*c]RPCOLEMESSAGE, [*c]ULONG) callconv(.C) HRESULT,
    FreeBuffer: ?fn ([*c]IRpcChannelBuffer, [*c]RPCOLEMESSAGE) callconv(.C) HRESULT,
    GetDestCtx: ?fn ([*c]IRpcChannelBuffer, [*c]DWORD, [*c](?*c_void)) callconv(.C) HRESULT,
    IsConnected: ?fn ([*c]IRpcChannelBuffer) callconv(.C) HRESULT,
};
pub const struct_IRpcChannelBuffer = extern struct {
    lpVtbl: [*c]struct_IRpcChannelBufferVtbl,
};
pub const IRpcChannelBuffer = struct_IRpcChannelBuffer;
pub const struct_IRpcStubBufferVtbl = extern struct {
    QueryInterface: ?fn ([*c]IRpcStubBuffer, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IRpcStubBuffer) callconv(.C) ULONG,
    Release: ?fn ([*c]IRpcStubBuffer) callconv(.C) ULONG,
    Connect: ?fn ([*c]IRpcStubBuffer, [*c]IUnknown) callconv(.C) HRESULT,
    Disconnect: ?fn ([*c]IRpcStubBuffer) callconv(.C) void,
    Invoke: ?fn ([*c]IRpcStubBuffer, [*c]RPCOLEMESSAGE, [*c]IRpcChannelBuffer) callconv(.C) HRESULT,
    IsIIDSupported: ?fn ([*c]IRpcStubBuffer, [*c]const IID) callconv(.C) [*c]IRpcStubBuffer,
    CountRefs: ?fn ([*c]IRpcStubBuffer) callconv(.C) ULONG,
    DebugServerQueryInterface: ?fn ([*c]IRpcStubBuffer, [*c](?*c_void)) callconv(.C) HRESULT,
    DebugServerRelease: ?fn ([*c]IRpcStubBuffer, ?*c_void) callconv(.C) void,
};
pub const struct_IRpcStubBuffer = extern struct {
    lpVtbl: [*c]struct_IRpcStubBufferVtbl,
};
pub extern "rpcrt4" fn NdrAsyncServerCall(pRpcMsg: PRPC_MESSAGE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrAsyncStubCall(pThis: [*c]struct_IRpcStubBuffer, pChannel: [*c]struct_IRpcChannelBuffer, pRpcMsg: PRPC_MESSAGE, pdwStubPhase: [*c]c_ulong) callconv(.Stdcall) c_long;
pub extern "rpcrt4" fn NdrDcomAsyncStubCall(pThis: [*c]struct_IRpcStubBuffer, pChannel: [*c]struct_IRpcChannelBuffer, pRpcMsg: PRPC_MESSAGE, pdwStubPhase: [*c]c_ulong) callconv(.Stdcall) c_long;
pub extern "rpcrt4" fn NdrStubCall2(pThis: ?*c_void, pChannel: ?*c_void, pRpcMsg: PRPC_MESSAGE, pdwStubPhase: [*c]c_ulong) callconv(.Stdcall) c_long;
pub extern "rpcrt4" fn NdrServerCall2(pRpcMsg: PRPC_MESSAGE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrStubCall(pThis: ?*c_void, pChannel: ?*c_void, pRpcMsg: PRPC_MESSAGE, pdwStubPhase: [*c]c_ulong) callconv(.Stdcall) c_long;
pub extern "rpcrt4" fn NdrServerCall(pRpcMsg: PRPC_MESSAGE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrServerUnmarshall(pChannel: ?*c_void, pRpcMsg: PRPC_MESSAGE, pStubMsg: PMIDL_STUB_MESSAGE, pStubDescriptor: PMIDL_STUB_DESC, pFormat: PFORMAT_STRING, pParamList: ?*c_void) callconv(.Stdcall) c_int;
pub extern "rpcrt4" fn NdrServerMarshall(pThis: ?*c_void, pChannel: ?*c_void, pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrMapCommAndFaultStatus(pStubMsg: PMIDL_STUB_MESSAGE, pCommStatus: [*c]c_ulong, pFaultStatus: [*c]c_ulong, Status: RPC_STATUS) callconv(.Stdcall) RPC_STATUS;
pub const RPC_SS_THREAD_HANDLE = ?*c_void;
pub const RPC_CLIENT_ALLOC = fn (usize) callconv(.C) ?*c_void;
pub const RPC_CLIENT_FREE = fn (?*c_void) callconv(.C) void;
pub extern "rpcrt4" fn RpcSsAllocate(Size: usize) callconv(.Stdcall) ?*c_void;
pub extern "rpcrt4" fn RpcSsDisableAllocate() callconv(.Stdcall) void;
pub extern "rpcrt4" fn RpcSsEnableAllocate() callconv(.Stdcall) void;
pub extern "rpcrt4" fn RpcSsFree(NodeToFree: ?*c_void) callconv(.Stdcall) void;
pub extern "rpcrt4" fn RpcSsGetThreadHandle() callconv(.Stdcall) RPC_SS_THREAD_HANDLE;
pub extern "rpcrt4" fn RpcSsSetClientAllocFree(ClientAlloc: [*c]RPC_CLIENT_ALLOC, ClientFree: [*c]RPC_CLIENT_FREE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn RpcSsSetThreadHandle(Id: RPC_SS_THREAD_HANDLE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn RpcSsSwapClientAllocFree(ClientAlloc: [*c]RPC_CLIENT_ALLOC, ClientFree: [*c]RPC_CLIENT_FREE, OldClientAlloc: [*c]([*c]RPC_CLIENT_ALLOC), OldClientFree: [*c]([*c]RPC_CLIENT_FREE)) callconv(.Stdcall) void;
pub extern "rpcrt4" fn RpcSmAllocate(Size: usize, pStatus: [*c]RPC_STATUS) callconv(.Stdcall) ?*c_void;
pub extern "rpcrt4" fn RpcSmClientFree(pNodeToFree: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcSmDestroyClientContext(ContextHandle: [*c](?*c_void)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcSmDisableAllocate() callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcSmEnableAllocate() callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcSmFree(NodeToFree: ?*c_void) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcSmGetThreadHandle(pStatus: [*c]RPC_STATUS) callconv(.Stdcall) RPC_SS_THREAD_HANDLE;
pub extern "rpcrt4" fn RpcSmSetClientAllocFree(ClientAlloc: [*c]RPC_CLIENT_ALLOC, ClientFree: [*c]RPC_CLIENT_FREE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcSmSetThreadHandle(Id: RPC_SS_THREAD_HANDLE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn RpcSmSwapClientAllocFree(ClientAlloc: [*c]RPC_CLIENT_ALLOC, ClientFree: [*c]RPC_CLIENT_FREE, OldClientAlloc: [*c]([*c]RPC_CLIENT_ALLOC), OldClientFree: [*c]([*c]RPC_CLIENT_FREE)) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn NdrRpcSsEnableAllocate(pMessage: PMIDL_STUB_MESSAGE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrRpcSsDisableAllocate(pMessage: PMIDL_STUB_MESSAGE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrRpcSmSetClientToOsf(pMessage: PMIDL_STUB_MESSAGE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrRpcSmClientAllocate(Size: usize) callconv(.Stdcall) ?*c_void;
pub extern "rpcrt4" fn NdrRpcSmClientFree(NodeToFree: ?*c_void) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrRpcSsDefaultAllocate(Size: usize) callconv(.Stdcall) ?*c_void;
pub extern "rpcrt4" fn NdrRpcSsDefaultFree(NodeToFree: ?*c_void) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrFullPointerXlatInit(NumberOfPointers: c_ulong, XlatSide: XLAT_SIDE) callconv(.Stdcall) PFULL_PTR_XLAT_TABLES;
pub extern "rpcrt4" fn NdrFullPointerXlatFree(pXlatTables: PFULL_PTR_XLAT_TABLES) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrAllocate(pStubMsg: PMIDL_STUB_MESSAGE, Len: usize) callconv(.Stdcall) ?*c_void;
pub extern "rpcrt4" fn NdrClearOutParameters(pStubMsg: PMIDL_STUB_MESSAGE, pFormat: PFORMAT_STRING, ArgAddr: ?*c_void) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrOleAllocate(Size: usize) callconv(.Stdcall) ?*c_void;
pub extern "rpcrt4" fn NdrOleFree(NodeToFree: ?*c_void) callconv(.Stdcall) void;
pub const struct__NDR_USER_MARSHAL_INFO_LEVEL1 = extern struct {
    Buffer: ?*c_void,
    BufferSize: c_ulong,
    pfnAllocate: ?fn (usize) callconv(.C) ?*c_void,
    pfnFree: ?fn (?*c_void) callconv(.C) void,
    pRpcChannelBuffer: [*c]struct_IRpcChannelBuffer,
    Reserved: [5]ULONG_PTR,
};
pub const NDR_USER_MARSHAL_INFO_LEVEL1 = struct__NDR_USER_MARSHAL_INFO_LEVEL1;
pub const struct__NDR_USER_MARSHAL_INFO = extern struct {
    InformationLevel: c_ulong,
    @"": extern union {
        Level1: NDR_USER_MARSHAL_INFO_LEVEL1,
    },
};
pub const NDR_USER_MARSHAL_INFO = struct__NDR_USER_MARSHAL_INFO;
pub extern "rpcrt4" fn NdrGetUserMarshalInfo(pFlags: [*c]c_ulong, InformationLevel: c_ulong, pMarshalInfo: [*c]NDR_USER_MARSHAL_INFO) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn NdrCreateServerInterfaceFromStub(pStub: [*c]struct_IRpcStubBuffer, pServerIf: [*c]RPC_SERVER_INTERFACE) callconv(.Stdcall) RPC_STATUS;
pub extern "rpcrt4" fn NdrClientCall3(pProxyInfo: [*c]MIDL_STUBLESS_PROXY_INFO, nProcNum: c_ulong, pReturnValue: ?*c_void, ...) callconv(.Stdcall) CLIENT_CALL_RETURN;
pub extern "rpcrt4" fn Ndr64AsyncClientCall(pProxyInfo: [*c]MIDL_STUBLESS_PROXY_INFO, nProcNum: c_ulong, pReturnValue: ?*c_void, ...) callconv(.Stdcall) CLIENT_CALL_RETURN;
pub extern "rpcrt4" fn Ndr64DcomAsyncClientCall(pProxyInfo: [*c]MIDL_STUBLESS_PROXY_INFO, nProcNum: c_ulong, pReturnValue: ?*c_void, ...) callconv(.Stdcall) CLIENT_CALL_RETURN;
pub extern "rpcrt4" fn Ndr64AsyncServerCall(pRpcMsg: PRPC_MESSAGE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn Ndr64AsyncServerCall64(pRpcMsg: PRPC_MESSAGE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn Ndr64AsyncServerCallAll(pRpcMsg: PRPC_MESSAGE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn Ndr64AsyncStubCall(pThis: [*c]struct_IRpcStubBuffer, pChannel: [*c]struct_IRpcChannelBuffer, pRpcMsg: PRPC_MESSAGE, pdwStubPhase: [*c]c_ulong) callconv(.Stdcall) c_long;
pub extern "rpcrt4" fn Ndr64DcomAsyncStubCall(pThis: [*c]struct_IRpcStubBuffer, pChannel: [*c]struct_IRpcChannelBuffer, pRpcMsg: PRPC_MESSAGE, pdwStubPhase: [*c]c_ulong) callconv(.Stdcall) c_long;
pub extern "rpcrt4" fn NdrStubCall3(pThis: ?*c_void, pChannel: ?*c_void, pRpcMsg: PRPC_MESSAGE, pdwStubPhase: [*c]c_ulong) callconv(.Stdcall) c_long;
pub extern "rpcrt4" fn NdrServerCallAll(pRpcMsg: PRPC_MESSAGE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrServerCallNdr64(pRpcMsg: PRPC_MESSAGE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrServerCall3(pRpcMsg: PRPC_MESSAGE) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrPartialIgnoreClientMarshall(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: ?*c_void) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrPartialIgnoreServerUnmarshall(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c](?*c_void)) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrPartialIgnoreClientBufferSize(pStubMsg: PMIDL_STUB_MESSAGE, pMemory: ?*c_void) callconv(.Stdcall) void;
pub extern "rpcrt4" fn NdrPartialIgnoreServerInitialize(pStubMsg: PMIDL_STUB_MESSAGE, ppMemory: [*c](?*c_void), pFormat: PFORMAT_STRING) callconv(.Stdcall) void;
pub extern "rpcrt4" fn RpcUserFree(AsyncHandle: handle_t, pBuffer: ?*c_void) callconv(.Stdcall) void;
pub extern var __MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const OLECHAR = WCHAR;
pub const LPOLESTR = [*c]OLECHAR;
pub const LPCOLESTR = [*c]const OLECHAR;
pub const DOUBLE = f64;
pub const struct__COAUTHIDENTITY = extern struct {
    User: [*c]USHORT,
    UserLength: ULONG,
    Domain: [*c]USHORT,
    DomainLength: ULONG,
    Password: [*c]USHORT,
    PasswordLength: ULONG,
    Flags: ULONG,
};
pub const COAUTHIDENTITY = struct__COAUTHIDENTITY;
pub const struct__COAUTHINFO = extern struct {
    dwAuthnSvc: DWORD,
    dwAuthzSvc: DWORD,
    pwszServerPrincName: LPWSTR,
    dwAuthnLevel: DWORD,
    dwImpersonationLevel: DWORD,
    pAuthIdentityData: [*c]COAUTHIDENTITY,
    dwCapabilities: DWORD,
};
pub const COAUTHINFO = struct__COAUTHINFO;
pub const SCODE = LONG;
pub const PSCODE = [*c]SCODE;
pub const MEMCTX_TASK = enum_tagMEMCTX.MEMCTX_TASK;
pub const MEMCTX_SHARED = enum_tagMEMCTX.MEMCTX_SHARED;
pub const MEMCTX_MACSYSTEM = enum_tagMEMCTX.MEMCTX_MACSYSTEM;
pub const MEMCTX_UNKNOWN = enum_tagMEMCTX.MEMCTX_UNKNOWN;
pub const MEMCTX_SAME = enum_tagMEMCTX.MEMCTX_SAME;
pub const enum_tagMEMCTX = extern enum {
    MEMCTX_TASK = 1,
    MEMCTX_SHARED = 2,
    MEMCTX_MACSYSTEM = 3,
    MEMCTX_UNKNOWN = -1,
    MEMCTX_SAME = -2,
};
pub const MEMCTX = enum_tagMEMCTX;
pub const CLSCTX_INPROC_SERVER = enum_tagCLSCTX.CLSCTX_INPROC_SERVER;
pub const CLSCTX_INPROC_HANDLER = enum_tagCLSCTX.CLSCTX_INPROC_HANDLER;
pub const CLSCTX_LOCAL_SERVER = enum_tagCLSCTX.CLSCTX_LOCAL_SERVER;
pub const CLSCTX_INPROC_SERVER16 = enum_tagCLSCTX.CLSCTX_INPROC_SERVER16;
pub const CLSCTX_REMOTE_SERVER = enum_tagCLSCTX.CLSCTX_REMOTE_SERVER;
pub const CLSCTX_INPROC_HANDLER16 = enum_tagCLSCTX.CLSCTX_INPROC_HANDLER16;
pub const CLSCTX_RESERVED1 = enum_tagCLSCTX.CLSCTX_RESERVED1;
pub const CLSCTX_RESERVED2 = enum_tagCLSCTX.CLSCTX_RESERVED2;
pub const CLSCTX_RESERVED3 = enum_tagCLSCTX.CLSCTX_RESERVED3;
pub const CLSCTX_RESERVED4 = enum_tagCLSCTX.CLSCTX_RESERVED4;
pub const CLSCTX_NO_CODE_DOWNLOAD = enum_tagCLSCTX.CLSCTX_NO_CODE_DOWNLOAD;
pub const CLSCTX_RESERVED5 = enum_tagCLSCTX.CLSCTX_RESERVED5;
pub const CLSCTX_NO_CUSTOM_MARSHAL = enum_tagCLSCTX.CLSCTX_NO_CUSTOM_MARSHAL;
pub const CLSCTX_ENABLE_CODE_DOWNLOAD = enum_tagCLSCTX.CLSCTX_ENABLE_CODE_DOWNLOAD;
pub const CLSCTX_NO_FAILURE_LOG = enum_tagCLSCTX.CLSCTX_NO_FAILURE_LOG;
pub const CLSCTX_DISABLE_AAA = enum_tagCLSCTX.CLSCTX_DISABLE_AAA;
pub const CLSCTX_ENABLE_AAA = enum_tagCLSCTX.CLSCTX_ENABLE_AAA;
pub const CLSCTX_FROM_DEFAULT_CONTEXT = enum_tagCLSCTX.CLSCTX_FROM_DEFAULT_CONTEXT;
pub const CLSCTX_ACTIVATE_X86_SERVER = enum_tagCLSCTX.CLSCTX_ACTIVATE_X86_SERVER;
pub const CLSCTX_ACTIVATE_32_BIT_SERVER = enum_tagCLSCTX.CLSCTX_ACTIVATE_32_BIT_SERVER;
pub const CLSCTX_ACTIVATE_64_BIT_SERVER = enum_tagCLSCTX.CLSCTX_ACTIVATE_64_BIT_SERVER;
pub const CLSCTX_ENABLE_CLOAKING = enum_tagCLSCTX.CLSCTX_ENABLE_CLOAKING;
pub const CLSCTX_APPCONTAINER = enum_tagCLSCTX.CLSCTX_APPCONTAINER;
pub const CLSCTX_ACTIVATE_AAA_AS_IU = enum_tagCLSCTX.CLSCTX_ACTIVATE_AAA_AS_IU;
pub const CLSCTX_RESERVED6 = enum_tagCLSCTX.CLSCTX_RESERVED6;
pub const CLSCTX_ACTIVATE_ARM32_SERVER = enum_tagCLSCTX.CLSCTX_ACTIVATE_ARM32_SERVER;
pub const CLSCTX_PS_DLL = enum_tagCLSCTX.CLSCTX_PS_DLL;
pub const enum_tagCLSCTX = extern enum {
    CLSCTX_INPROC_SERVER = 1,
    CLSCTX_INPROC_HANDLER = 2,
    CLSCTX_LOCAL_SERVER = 4,
    CLSCTX_INPROC_SERVER16 = 8,
    CLSCTX_REMOTE_SERVER = 16,
    CLSCTX_INPROC_HANDLER16 = 32,
    CLSCTX_RESERVED1 = 64,
    CLSCTX_RESERVED2 = 128,
    CLSCTX_RESERVED3 = 256,
    CLSCTX_RESERVED4 = 512,
    CLSCTX_NO_CODE_DOWNLOAD = 1024,
    CLSCTX_RESERVED5 = 2048,
    CLSCTX_NO_CUSTOM_MARSHAL = 4096,
    CLSCTX_ENABLE_CODE_DOWNLOAD = 8192,
    CLSCTX_NO_FAILURE_LOG = 16384,
    CLSCTX_DISABLE_AAA = 32768,
    CLSCTX_ENABLE_AAA = 65536,
    CLSCTX_FROM_DEFAULT_CONTEXT = 131072,
    CLSCTX_ACTIVATE_X86_SERVER = 262144,
    CLSCTX_ACTIVATE_32_BIT_SERVER = 262144,
    CLSCTX_ACTIVATE_64_BIT_SERVER = 524288,
    CLSCTX_ENABLE_CLOAKING = 1048576,
    CLSCTX_APPCONTAINER = 4194304,
    CLSCTX_ACTIVATE_AAA_AS_IU = 8388608,
    CLSCTX_RESERVED6 = 16777216,
    CLSCTX_ACTIVATE_ARM32_SERVER = 33554432,
    CLSCTX_PS_DLL = -2147483648,
};
pub const CLSCTX = enum_tagCLSCTX;
pub const MSHLFLAGS_NORMAL = enum_tagMSHLFLAGS.MSHLFLAGS_NORMAL;
pub const MSHLFLAGS_TABLESTRONG = enum_tagMSHLFLAGS.MSHLFLAGS_TABLESTRONG;
pub const MSHLFLAGS_TABLEWEAK = enum_tagMSHLFLAGS.MSHLFLAGS_TABLEWEAK;
pub const MSHLFLAGS_NOPING = enum_tagMSHLFLAGS.MSHLFLAGS_NOPING;
pub const MSHLFLAGS_RESERVED1 = enum_tagMSHLFLAGS.MSHLFLAGS_RESERVED1;
pub const MSHLFLAGS_RESERVED2 = enum_tagMSHLFLAGS.MSHLFLAGS_RESERVED2;
pub const MSHLFLAGS_RESERVED3 = enum_tagMSHLFLAGS.MSHLFLAGS_RESERVED3;
pub const MSHLFLAGS_RESERVED4 = enum_tagMSHLFLAGS.MSHLFLAGS_RESERVED4;
pub const enum_tagMSHLFLAGS = extern enum {
    MSHLFLAGS_NORMAL = 0,
    MSHLFLAGS_TABLESTRONG = 1,
    MSHLFLAGS_TABLEWEAK = 2,
    MSHLFLAGS_NOPING = 4,
    MSHLFLAGS_RESERVED1 = 8,
    MSHLFLAGS_RESERVED2 = 16,
    MSHLFLAGS_RESERVED3 = 32,
    MSHLFLAGS_RESERVED4 = 64,
};
pub const MSHLFLAGS = enum_tagMSHLFLAGS;
pub const MSHCTX_LOCAL = enum_tagMSHCTX.MSHCTX_LOCAL;
pub const MSHCTX_NOSHAREDMEM = enum_tagMSHCTX.MSHCTX_NOSHAREDMEM;
pub const MSHCTX_DIFFERENTMACHINE = enum_tagMSHCTX.MSHCTX_DIFFERENTMACHINE;
pub const MSHCTX_INPROC = enum_tagMSHCTX.MSHCTX_INPROC;
pub const MSHCTX_CROSSCTX = enum_tagMSHCTX.MSHCTX_CROSSCTX;
pub const MSHCTX_RESERVED1 = enum_tagMSHCTX.MSHCTX_RESERVED1;
pub const enum_tagMSHCTX = extern enum {
    MSHCTX_LOCAL = 0,
    MSHCTX_NOSHAREDMEM = 1,
    MSHCTX_DIFFERENTMACHINE = 2,
    MSHCTX_INPROC = 3,
    MSHCTX_CROSSCTX = 4,
    MSHCTX_RESERVED1 = 5,
};
pub const MSHCTX = enum_tagMSHCTX;
pub const struct__BYTE_BLOB = extern struct {
    clSize: ULONG,
    abData: [1]byte,
};
pub const BYTE_BLOB = struct__BYTE_BLOB;
pub const UP_BYTE_BLOB = [*c]BYTE_BLOB;
pub const struct__WORD_BLOB = extern struct {
    clSize: ULONG,
    asData: [1]c_ushort,
};
pub const WORD_BLOB = struct__WORD_BLOB;
pub const UP_WORD_BLOB = [*c]WORD_BLOB;
pub const struct__DWORD_BLOB = extern struct {
    clSize: ULONG,
    alData: [1]ULONG,
};
pub const DWORD_BLOB = struct__DWORD_BLOB;
pub const UP_DWORD_BLOB = [*c]DWORD_BLOB;
pub const struct__FLAGGED_BYTE_BLOB = extern struct {
    fFlags: ULONG,
    clSize: ULONG,
    abData: [1]byte,
};
pub const FLAGGED_BYTE_BLOB = struct__FLAGGED_BYTE_BLOB;
pub const UP_FLAGGED_BYTE_BLOB = [*c]FLAGGED_BYTE_BLOB;
pub const struct__FLAGGED_WORD_BLOB = extern struct {
    fFlags: ULONG,
    clSize: ULONG,
    asData: [1]c_ushort,
};
pub const FLAGGED_WORD_BLOB = struct__FLAGGED_WORD_BLOB;
pub const UP_FLAGGED_WORD_BLOB = [*c]FLAGGED_WORD_BLOB;
pub const struct__BYTE_SIZEDARR = extern struct {
    clSize: ULONG,
    pData: [*c]byte,
};
pub const BYTE_SIZEDARR = struct__BYTE_SIZEDARR;
pub const struct__SHORT_SIZEDARR = extern struct {
    clSize: ULONG,
    pData: [*c]c_ushort,
};
pub const WORD_SIZEDARR = struct__SHORT_SIZEDARR;
pub const struct__LONG_SIZEDARR = extern struct {
    clSize: ULONG,
    pData: [*c]ULONG,
};
pub const DWORD_SIZEDARR = struct__LONG_SIZEDARR;
pub const struct__HYPER_SIZEDARR = extern struct {
    clSize: ULONG,
    pData: [*c]c_longlong,
};
pub const HYPER_SIZEDARR = struct__HYPER_SIZEDARR;
pub extern var IWinTypesBase_v0_1_c_ifspec: RPC_IF_HANDLE;
pub extern var IWinTypesBase_v0_1_s_ifspec: RPC_IF_HANDLE;
pub const struct_tagBLOB = extern struct {
    cbSize: ULONG,
    pBlobData: [*c]BYTE,
};
pub const BLOB = struct_tagBLOB;
pub const LPBLOB = [*c]struct_tagBLOB;
pub extern var __MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const struct_tagRemHGLOBAL = extern struct {
    fNullHGlobal: LONG,
    cbData: ULONG,
    data: [1]byte,
};
pub const RemHGLOBAL = struct_tagRemHGLOBAL;
pub const struct_tagRemHMETAFILEPICT = extern struct {
    mm: LONG,
    xExt: LONG,
    yExt: LONG,
    cbData: ULONG,
    data: [1]byte,
};
pub const RemHMETAFILEPICT = struct_tagRemHMETAFILEPICT;
pub const struct_tagRemHENHMETAFILE = extern struct {
    cbData: ULONG,
    data: [1]byte,
};
pub const RemHENHMETAFILE = struct_tagRemHENHMETAFILE;
pub const struct_tagRemHBITMAP = extern struct {
    cbData: ULONG,
    data: [1]byte,
};
pub const RemHBITMAP = struct_tagRemHBITMAP;
pub const struct_tagRemHPALETTE = extern struct {
    cbData: ULONG,
    data: [1]byte,
};
pub const RemHPALETTE = struct_tagRemHPALETTE;
pub const struct_tagRemBRUSH = extern struct {
    cbData: ULONG,
    data: [1]byte,
};
pub const RemHBRUSH = struct_tagRemBRUSH;
pub const DVASPECT_CONTENT = enum_tagDVASPECT.DVASPECT_CONTENT;
pub const DVASPECT_THUMBNAIL = enum_tagDVASPECT.DVASPECT_THUMBNAIL;
pub const DVASPECT_ICON = enum_tagDVASPECT.DVASPECT_ICON;
pub const DVASPECT_DOCPRINT = enum_tagDVASPECT.DVASPECT_DOCPRINT;
pub const enum_tagDVASPECT = extern enum {
    DVASPECT_CONTENT = 1,
    DVASPECT_THUMBNAIL = 2,
    DVASPECT_ICON = 4,
    DVASPECT_DOCPRINT = 8,
};
pub const DVASPECT = enum_tagDVASPECT;
pub const STGC_DEFAULT = enum_tagSTGC.STGC_DEFAULT;
pub const STGC_OVERWRITE = enum_tagSTGC.STGC_OVERWRITE;
pub const STGC_ONLYIFCURRENT = enum_tagSTGC.STGC_ONLYIFCURRENT;
pub const STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = enum_tagSTGC.STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE;
pub const STGC_CONSOLIDATE = enum_tagSTGC.STGC_CONSOLIDATE;
pub const enum_tagSTGC = extern enum {
    STGC_DEFAULT = 0,
    STGC_OVERWRITE = 1,
    STGC_ONLYIFCURRENT = 2,
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4,
    STGC_CONSOLIDATE = 8,
};
pub const STGC = enum_tagSTGC;
pub const STGMOVE_MOVE = enum_tagSTGMOVE.STGMOVE_MOVE;
pub const STGMOVE_COPY = enum_tagSTGMOVE.STGMOVE_COPY;
pub const STGMOVE_SHALLOWCOPY = enum_tagSTGMOVE.STGMOVE_SHALLOWCOPY;
pub const enum_tagSTGMOVE = extern enum {
    STGMOVE_MOVE = 0,
    STGMOVE_COPY = 1,
    STGMOVE_SHALLOWCOPY = 2,
};
pub const STGMOVE = enum_tagSTGMOVE;
pub const STATFLAG_DEFAULT = enum_tagSTATFLAG.STATFLAG_DEFAULT;
pub const STATFLAG_NONAME = enum_tagSTATFLAG.STATFLAG_NONAME;
pub const STATFLAG_NOOPEN = enum_tagSTATFLAG.STATFLAG_NOOPEN;
pub const enum_tagSTATFLAG = extern enum {
    STATFLAG_DEFAULT = 0,
    STATFLAG_NONAME = 1,
    STATFLAG_NOOPEN = 2,
};
pub const STATFLAG = enum_tagSTATFLAG;
pub const HCONTEXT = ?*c_void;
pub const union___MIDL_IWinTypes_0001 = extern union {
    dwValue: DWORD,
    pwszName: [*c]wchar_t,
};
pub const struct__userCLIPFORMAT = extern struct {
    fContext: LONG,
    u: union___MIDL_IWinTypes_0001,
};
pub const userCLIPFORMAT = struct__userCLIPFORMAT;
pub const wireCLIPFORMAT = [*c]userCLIPFORMAT;
pub const CLIPFORMAT = WORD;
pub const union___MIDL_IWinTypes_0002 = extern union {
    hInproc: LONG,
    hRemote: [*c]DWORD_BLOB,
};
pub const struct__GDI_NONREMOTE = extern struct {
    fContext: LONG,
    u: union___MIDL_IWinTypes_0002,
};
pub const GDI_NONREMOTE = struct__GDI_NONREMOTE;
pub const union___MIDL_IWinTypes_0003 = extern union {
    hInproc: LONG,
    hRemote: [*c]FLAGGED_BYTE_BLOB,
    hInproc64: c_longlong,
};
pub const struct__userHGLOBAL = extern struct {
    fContext: LONG,
    u: union___MIDL_IWinTypes_0003,
};
pub const userHGLOBAL = struct__userHGLOBAL;
pub const wireHGLOBAL = [*c]userHGLOBAL;
pub const union___MIDL_IWinTypes_0004 = extern union {
    hInproc: LONG,
    hRemote: [*c]BYTE_BLOB,
    hInproc64: c_longlong,
};
pub const struct__userHMETAFILE = extern struct {
    fContext: LONG,
    u: union___MIDL_IWinTypes_0004,
};
pub const userHMETAFILE = struct__userHMETAFILE;
pub const struct__remoteMETAFILEPICT = extern struct {
    mm: LONG,
    xExt: LONG,
    yExt: LONG,
    hMF: [*c]userHMETAFILE,
};
pub const remoteMETAFILEPICT = struct__remoteMETAFILEPICT;
pub const union___MIDL_IWinTypes_0005 = extern union {
    hInproc: LONG,
    hRemote: [*c]remoteMETAFILEPICT,
    hInproc64: c_longlong,
};
pub const struct__userHMETAFILEPICT = extern struct {
    fContext: LONG,
    u: union___MIDL_IWinTypes_0005,
};
pub const userHMETAFILEPICT = struct__userHMETAFILEPICT;
pub const union___MIDL_IWinTypes_0006 = extern union {
    hInproc: LONG,
    hRemote: [*c]BYTE_BLOB,
    hInproc64: c_longlong,
};
pub const struct__userHENHMETAFILE = extern struct {
    fContext: LONG,
    u: union___MIDL_IWinTypes_0006,
};
pub const userHENHMETAFILE = struct__userHENHMETAFILE;
pub const struct__userBITMAP = extern struct {
    bmType: LONG,
    bmWidth: LONG,
    bmHeight: LONG,
    bmWidthBytes: LONG,
    bmPlanes: WORD,
    bmBitsPixel: WORD,
    cbSize: ULONG,
    pBuffer: [1]byte,
};
pub const userBITMAP = struct__userBITMAP;
pub const union___MIDL_IWinTypes_0007 = extern union {
    hInproc: LONG,
    hRemote: [*c]userBITMAP,
    hInproc64: c_longlong,
};
pub const struct__userHBITMAP = extern struct {
    fContext: LONG,
    u: union___MIDL_IWinTypes_0007,
};
pub const userHBITMAP = struct__userHBITMAP;
pub const union___MIDL_IWinTypes_0008 = extern union {
    hInproc: LONG,
    hRemote: [*c]LOGPALETTE,
    hInproc64: c_longlong,
};
pub const struct__userHPALETTE = extern struct {
    fContext: LONG,
    u: union___MIDL_IWinTypes_0008,
};
pub const userHPALETTE = struct__userHPALETTE;
pub const union___MIDL_IWinTypes_0009 = extern union {
    hInproc: LONG,
    hRemote: LONG,
};
pub const struct__RemotableHandle = extern struct {
    fContext: LONG,
    u: union___MIDL_IWinTypes_0009,
};
pub const RemotableHandle = struct__RemotableHandle;
pub const wireHWND = [*c]RemotableHandle;
pub const wireHMENU = [*c]RemotableHandle;
pub const wireHACCEL = [*c]RemotableHandle;
pub const wireHBRUSH = [*c]RemotableHandle;
pub const wireHFONT = [*c]RemotableHandle;
pub const wireHDC = [*c]RemotableHandle;
pub const wireHICON = [*c]RemotableHandle;
pub const wireHRGN = [*c]RemotableHandle;
pub const wireHMONITOR = [*c]RemotableHandle;
pub const wireHBITMAP = [*c]userHBITMAP;
pub const wireHPALETTE = [*c]userHPALETTE;
pub const wireHENHMETAFILE = [*c]userHENHMETAFILE;
pub const wireHMETAFILE = [*c]userHMETAFILE;
pub const wireHMETAFILEPICT = [*c]userHMETAFILEPICT;
pub const HMETAFILEPICT = ?*c_void;
pub extern var IWinTypes_v0_1_c_ifspec: RPC_IF_HANDLE;
pub extern var IWinTypes_v0_1_s_ifspec: RPC_IF_HANDLE;
pub const DATE = f64;
pub const union_tagCY = extern union {
    @"": extern struct {
        Lo: ULONG,
        Hi: LONG,
    },
    int64: LONGLONG,
};
pub const CY = union_tagCY;
pub const LPCY = [*c]CY;
pub const struct_tagDEC = extern struct {
    wReserved: USHORT,
    @"": extern union {
        @"": extern struct {
            scale: BYTE,
            sign: BYTE,
        },
        signscale: USHORT,
    },
    Hi32: ULONG,
    @"": extern union {
        @"": extern struct {
            Lo32: ULONG,
            Mid32: ULONG,
        },
        Lo64: ULONGLONG,
    },
};
pub const DECIMAL = struct_tagDEC;
pub const LPDECIMAL = [*c]DECIMAL;
pub const wireBSTR = [*c]FLAGGED_WORD_BLOB;
pub const BSTR = [*c]OLECHAR;
pub const LPBSTR = [*c]BSTR;
pub const VARIANT_BOOL = c_short;
pub const struct_tagBSTRBLOB = extern struct {
    cbSize: ULONG,
    pData: [*c]BYTE,
};
pub const BSTRBLOB = struct_tagBSTRBLOB;
pub const LPBSTRBLOB = [*c]struct_tagBSTRBLOB;
pub const struct_tagCLIPDATA = extern struct {
    cbSize: ULONG,
    ulClipFmt: LONG,
    pClipData: [*c]BYTE,
};
pub const CLIPDATA = struct_tagCLIPDATA;
pub const VARTYPE = c_ushort;
pub const VT_EMPTY = enum_VARENUM.VT_EMPTY;
pub const VT_NULL = enum_VARENUM.VT_NULL;
pub const VT_I2 = enum_VARENUM.VT_I2;
pub const VT_I4 = enum_VARENUM.VT_I4;
pub const VT_R4 = enum_VARENUM.VT_R4;
pub const VT_R8 = enum_VARENUM.VT_R8;
pub const VT_CY = enum_VARENUM.VT_CY;
pub const VT_DATE = enum_VARENUM.VT_DATE;
pub const VT_BSTR = enum_VARENUM.VT_BSTR;
pub const VT_DISPATCH = enum_VARENUM.VT_DISPATCH;
pub const VT_ERROR = enum_VARENUM.VT_ERROR;
pub const VT_BOOL = enum_VARENUM.VT_BOOL;
pub const VT_VARIANT = enum_VARENUM.VT_VARIANT;
pub const VT_UNKNOWN = enum_VARENUM.VT_UNKNOWN;
pub const VT_DECIMAL = enum_VARENUM.VT_DECIMAL;
pub const VT_I1 = enum_VARENUM.VT_I1;
pub const VT_UI1 = enum_VARENUM.VT_UI1;
pub const VT_UI2 = enum_VARENUM.VT_UI2;
pub const VT_UI4 = enum_VARENUM.VT_UI4;
pub const VT_I8 = enum_VARENUM.VT_I8;
pub const VT_UI8 = enum_VARENUM.VT_UI8;
pub const VT_INT = enum_VARENUM.VT_INT;
pub const VT_UINT = enum_VARENUM.VT_UINT;
pub const VT_VOID = enum_VARENUM.VT_VOID;
pub const VT_HRESULT = enum_VARENUM.VT_HRESULT;
pub const VT_PTR = enum_VARENUM.VT_PTR;
pub const VT_SAFEARRAY = enum_VARENUM.VT_SAFEARRAY;
pub const VT_CARRAY = enum_VARENUM.VT_CARRAY;
pub const VT_USERDEFINED = enum_VARENUM.VT_USERDEFINED;
pub const VT_LPSTR = enum_VARENUM.VT_LPSTR;
pub const VT_LPWSTR = enum_VARENUM.VT_LPWSTR;
pub const VT_RECORD = enum_VARENUM.VT_RECORD;
pub const VT_INT_PTR = enum_VARENUM.VT_INT_PTR;
pub const VT_UINT_PTR = enum_VARENUM.VT_UINT_PTR;
pub const VT_FILETIME = enum_VARENUM.VT_FILETIME;
pub const VT_BLOB = enum_VARENUM.VT_BLOB;
pub const VT_STREAM = enum_VARENUM.VT_STREAM;
pub const VT_STORAGE = enum_VARENUM.VT_STORAGE;
pub const VT_STREAMED_OBJECT = enum_VARENUM.VT_STREAMED_OBJECT;
pub const VT_STORED_OBJECT = enum_VARENUM.VT_STORED_OBJECT;
pub const VT_BLOB_OBJECT = enum_VARENUM.VT_BLOB_OBJECT;
pub const VT_CF = enum_VARENUM.VT_CF;
pub const VT_CLSID = enum_VARENUM.VT_CLSID;
pub const VT_VERSIONED_STREAM = enum_VARENUM.VT_VERSIONED_STREAM;
pub const VT_BSTR_BLOB = enum_VARENUM.VT_BSTR_BLOB;
pub const VT_VECTOR = enum_VARENUM.VT_VECTOR;
pub const VT_ARRAY = enum_VARENUM.VT_ARRAY;
pub const VT_BYREF = enum_VARENUM.VT_BYREF;
pub const VT_RESERVED = enum_VARENUM.VT_RESERVED;
pub const VT_ILLEGAL = enum_VARENUM.VT_ILLEGAL;
pub const VT_ILLEGALMASKED = enum_VARENUM.VT_ILLEGALMASKED;
pub const VT_TYPEMASK = enum_VARENUM.VT_TYPEMASK;
pub const enum_VARENUM = extern enum {
    VT_EMPTY = 0,
    VT_NULL = 1,
    VT_I2 = 2,
    VT_I4 = 3,
    VT_R4 = 4,
    VT_R8 = 5,
    VT_CY = 6,
    VT_DATE = 7,
    VT_BSTR = 8,
    VT_DISPATCH = 9,
    VT_ERROR = 10,
    VT_BOOL = 11,
    VT_VARIANT = 12,
    VT_UNKNOWN = 13,
    VT_DECIMAL = 14,
    VT_I1 = 16,
    VT_UI1 = 17,
    VT_UI2 = 18,
    VT_UI4 = 19,
    VT_I8 = 20,
    VT_UI8 = 21,
    VT_INT = 22,
    VT_UINT = 23,
    VT_VOID = 24,
    VT_HRESULT = 25,
    VT_PTR = 26,
    VT_SAFEARRAY = 27,
    VT_CARRAY = 28,
    VT_USERDEFINED = 29,
    VT_LPSTR = 30,
    VT_LPWSTR = 31,
    VT_RECORD = 36,
    VT_INT_PTR = 37,
    VT_UINT_PTR = 38,
    VT_FILETIME = 64,
    VT_BLOB = 65,
    VT_STREAM = 66,
    VT_STORAGE = 67,
    VT_STREAMED_OBJECT = 68,
    VT_STORED_OBJECT = 69,
    VT_BLOB_OBJECT = 70,
    VT_CF = 71,
    VT_CLSID = 72,
    VT_VERSIONED_STREAM = 73,
    VT_BSTR_BLOB = 4095,
    VT_VECTOR = 4096,
    VT_ARRAY = 8192,
    VT_BYREF = 16384,
    VT_RESERVED = 32768,
    VT_ILLEGAL = 65535,
    VT_ILLEGALMASKED = 4095,
    VT_TYPEMASK = 4095,
};
pub const PROPID = ULONG;
pub const struct__tagpropertykey = extern struct {
    fmtid: GUID,
    pid: DWORD,
};
pub const PROPERTYKEY = struct__tagpropertykey;
pub const struct_tagCSPLATFORM = extern struct {
    dwPlatformId: DWORD,
    dwVersionHi: DWORD,
    dwVersionLo: DWORD,
    dwProcessorArch: DWORD,
};
pub const CSPLATFORM = struct_tagCSPLATFORM;
pub const struct_tagQUERYCONTEXT = extern struct {
    dwContext: DWORD,
    Platform: CSPLATFORM,
    Locale: LCID,
    dwVersionHi: DWORD,
    dwVersionLo: DWORD,
};
pub const QUERYCONTEXT = struct_tagQUERYCONTEXT;
pub const TYSPEC_CLSID = enum_tagTYSPEC.TYSPEC_CLSID;
pub const TYSPEC_FILEEXT = enum_tagTYSPEC.TYSPEC_FILEEXT;
pub const TYSPEC_MIMETYPE = enum_tagTYSPEC.TYSPEC_MIMETYPE;
pub const TYSPEC_FILENAME = enum_tagTYSPEC.TYSPEC_FILENAME;
pub const TYSPEC_PROGID = enum_tagTYSPEC.TYSPEC_PROGID;
pub const TYSPEC_PACKAGENAME = enum_tagTYSPEC.TYSPEC_PACKAGENAME;
pub const TYSPEC_OBJECTID = enum_tagTYSPEC.TYSPEC_OBJECTID;
pub const enum_tagTYSPEC = extern enum {
    TYSPEC_CLSID = 0,
    TYSPEC_FILEEXT = 1,
    TYSPEC_MIMETYPE = 2,
    TYSPEC_FILENAME = 3,
    TYSPEC_PROGID = 4,
    TYSPEC_PACKAGENAME = 5,
    TYSPEC_OBJECTID = 6,
};
pub const TYSPEC = enum_tagTYSPEC;
pub const union___MIDL___MIDL_itf_wtypes_0000_0001_0005 = extern union {
    clsid: CLSID,
    pFileExt: LPOLESTR,
    pMimeType: LPOLESTR,
    pProgId: LPOLESTR,
    pFileName: LPOLESTR,
    ByName: extern struct {
        pPackageName: LPOLESTR,
        PolicyId: GUID,
    },
    ByObjectId: extern struct {
        ObjectId: GUID,
        PolicyId: GUID,
    },
};
pub const struct___MIDL___MIDL_itf_wtypes_0000_0001_0001 = extern struct {
    tyspec: DWORD,
    tagged_union: union___MIDL___MIDL_itf_wtypes_0000_0001_0005,
};
pub const uCLSSPEC = struct___MIDL___MIDL_itf_wtypes_0000_0001_0001;
pub extern var __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const GUID_DEVINTERFACE_DISK: GUID;
pub extern const GUID_DEVINTERFACE_CDROM: GUID;
pub extern const GUID_DEVINTERFACE_PARTITION: GUID;
pub extern const GUID_DEVINTERFACE_TAPE: GUID;
pub extern const GUID_DEVINTERFACE_WRITEONCEDISK: GUID;
pub extern const GUID_DEVINTERFACE_VOLUME: GUID;
pub extern const GUID_DEVINTERFACE_MEDIUMCHANGER: GUID;
pub extern const GUID_DEVINTERFACE_FLOPPY: GUID;
pub extern const GUID_DEVINTERFACE_CDCHANGER: GUID;
pub extern const GUID_DEVINTERFACE_STORAGEPORT: GUID;
pub extern const GUID_DEVINTERFACE_VMLUN: GUID;
pub extern const GUID_DEVINTERFACE_SES: GUID;
pub extern const GUID_DEVINTERFACE_SERVICE_VOLUME: GUID;
pub extern const GUID_DEVINTERFACE_HIDDEN_VOLUME: GUID;
pub extern const GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB: GUID;
pub extern const GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE: GUID;
pub extern const GUID_SCM_PD_HEALTH_NOTIFICATION: GUID;
pub extern const GUID_SCM_PD_PASSTHROUGH_INVDIMM: GUID;
pub extern const GUID_DEVINTERFACE_COMPORT: GUID;
pub extern const GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR: GUID;
pub const struct__STORAGE_HOTPLUG_INFO = extern struct {
    Size: DWORD,
    MediaRemovable: BOOLEAN,
    MediaHotplug: BOOLEAN,
    DeviceHotplug: BOOLEAN,
    WriteCacheEnableOverride: BOOLEAN,
};
pub const STORAGE_HOTPLUG_INFO = struct__STORAGE_HOTPLUG_INFO;
pub const PSTORAGE_HOTPLUG_INFO = [*c]struct__STORAGE_HOTPLUG_INFO;
pub const struct__STORAGE_DEVICE_NUMBER = extern struct {
    DeviceType: DWORD,
    DeviceNumber: DWORD,
    PartitionNumber: DWORD,
};
pub const STORAGE_DEVICE_NUMBER = struct__STORAGE_DEVICE_NUMBER;
pub const PSTORAGE_DEVICE_NUMBER = [*c]struct__STORAGE_DEVICE_NUMBER;
pub const struct__STORAGE_DEVICE_NUMBERS = extern struct {
    Version: DWORD,
    Size: DWORD,
    NumberOfDevices: DWORD,
    Devices: [1]STORAGE_DEVICE_NUMBER,
};
pub const STORAGE_DEVICE_NUMBERS = struct__STORAGE_DEVICE_NUMBERS;
pub const PSTORAGE_DEVICE_NUMBERS = [*c]struct__STORAGE_DEVICE_NUMBERS;
pub const struct__STORAGE_DEVICE_NUMBER_EX = extern struct {
    Version: DWORD,
    Size: DWORD,
    Flags: DWORD,
    DeviceType: DWORD,
    DeviceNumber: DWORD,
    DeviceGuid: GUID,
    PartitionNumber: DWORD,
};
pub const STORAGE_DEVICE_NUMBER_EX = struct__STORAGE_DEVICE_NUMBER_EX;
pub const PSTORAGE_DEVICE_NUMBER_EX = [*c]struct__STORAGE_DEVICE_NUMBER_EX;
pub const struct__STORAGE_BUS_RESET_REQUEST = extern struct {
    PathId: BYTE,
};
pub const STORAGE_BUS_RESET_REQUEST = struct__STORAGE_BUS_RESET_REQUEST;
pub const PSTORAGE_BUS_RESET_REQUEST = [*c]struct__STORAGE_BUS_RESET_REQUEST;
pub const struct_STORAGE_BREAK_RESERVATION_REQUEST = extern struct {
    Length: DWORD,
    _unused: BYTE,
    PathId: BYTE,
    TargetId: BYTE,
    Lun: BYTE,
};
pub const STORAGE_BREAK_RESERVATION_REQUEST = struct_STORAGE_BREAK_RESERVATION_REQUEST;
pub const PSTORAGE_BREAK_RESERVATION_REQUEST = [*c]struct_STORAGE_BREAK_RESERVATION_REQUEST;
pub const struct__PREVENT_MEDIA_REMOVAL = extern struct {
    PreventMediaRemoval: BOOLEAN,
};
pub const PREVENT_MEDIA_REMOVAL = struct__PREVENT_MEDIA_REMOVAL;
pub const PPREVENT_MEDIA_REMOVAL = [*c]struct__PREVENT_MEDIA_REMOVAL;
pub const struct__CLASS_MEDIA_CHANGE_CONTEXT = extern struct {
    MediaChangeCount: DWORD,
    NewState: DWORD,
};
pub const CLASS_MEDIA_CHANGE_CONTEXT = struct__CLASS_MEDIA_CHANGE_CONTEXT;
pub const PCLASS_MEDIA_CHANGE_CONTEXT = [*c]struct__CLASS_MEDIA_CHANGE_CONTEXT;
pub const struct__TAPE_STATISTICS = extern struct {
    Version: DWORD,
    Flags: DWORD,
    RecoveredWrites: LARGE_INTEGER,
    UnrecoveredWrites: LARGE_INTEGER,
    RecoveredReads: LARGE_INTEGER,
    UnrecoveredReads: LARGE_INTEGER,
    CompressionRatioReads: BYTE,
    CompressionRatioWrites: BYTE,
};
pub const TAPE_STATISTICS = struct__TAPE_STATISTICS;
pub const PTAPE_STATISTICS = [*c]struct__TAPE_STATISTICS;
pub const struct__TAPE_GET_STATISTICS = extern struct {
    Operation: DWORD,
};
pub const TAPE_GET_STATISTICS = struct__TAPE_GET_STATISTICS;
pub const PTAPE_GET_STATISTICS = [*c]struct__TAPE_GET_STATISTICS;
pub const DDS_4mm = enum__STORAGE_MEDIA_TYPE.DDS_4mm;
pub const MiniQic = enum__STORAGE_MEDIA_TYPE.MiniQic;
pub const Travan = enum__STORAGE_MEDIA_TYPE.Travan;
pub const QIC = enum__STORAGE_MEDIA_TYPE.QIC;
pub const MP_8mm = enum__STORAGE_MEDIA_TYPE.MP_8mm;
pub const AME_8mm = enum__STORAGE_MEDIA_TYPE.AME_8mm;
pub const AIT1_8mm = enum__STORAGE_MEDIA_TYPE.AIT1_8mm;
pub const DLT = enum__STORAGE_MEDIA_TYPE.DLT;
pub const NCTP = enum__STORAGE_MEDIA_TYPE.NCTP;
pub const IBM_3480 = enum__STORAGE_MEDIA_TYPE.IBM_3480;
pub const IBM_3490E = enum__STORAGE_MEDIA_TYPE.IBM_3490E;
pub const IBM_Magstar_3590 = enum__STORAGE_MEDIA_TYPE.IBM_Magstar_3590;
pub const IBM_Magstar_MP = enum__STORAGE_MEDIA_TYPE.IBM_Magstar_MP;
pub const STK_DATA_D3 = enum__STORAGE_MEDIA_TYPE.STK_DATA_D3;
pub const SONY_DTF = enum__STORAGE_MEDIA_TYPE.SONY_DTF;
pub const DV_6mm = enum__STORAGE_MEDIA_TYPE.DV_6mm;
pub const DMI = enum__STORAGE_MEDIA_TYPE.DMI;
pub const SONY_D2 = enum__STORAGE_MEDIA_TYPE.SONY_D2;
pub const CLEANER_CARTRIDGE = enum__STORAGE_MEDIA_TYPE.CLEANER_CARTRIDGE;
pub const CD_ROM = enum__STORAGE_MEDIA_TYPE.CD_ROM;
pub const CD_R = enum__STORAGE_MEDIA_TYPE.CD_R;
pub const CD_RW = enum__STORAGE_MEDIA_TYPE.CD_RW;
pub const DVD_ROM = enum__STORAGE_MEDIA_TYPE.DVD_ROM;
pub const DVD_R = enum__STORAGE_MEDIA_TYPE.DVD_R;
pub const DVD_RW = enum__STORAGE_MEDIA_TYPE.DVD_RW;
pub const MO_3_RW = enum__STORAGE_MEDIA_TYPE.MO_3_RW;
pub const MO_5_WO = enum__STORAGE_MEDIA_TYPE.MO_5_WO;
pub const MO_5_RW = enum__STORAGE_MEDIA_TYPE.MO_5_RW;
pub const MO_5_LIMDOW = enum__STORAGE_MEDIA_TYPE.MO_5_LIMDOW;
pub const PC_5_WO = enum__STORAGE_MEDIA_TYPE.PC_5_WO;
pub const PC_5_RW = enum__STORAGE_MEDIA_TYPE.PC_5_RW;
pub const PD_5_RW = enum__STORAGE_MEDIA_TYPE.PD_5_RW;
pub const ABL_5_WO = enum__STORAGE_MEDIA_TYPE.ABL_5_WO;
pub const PINNACLE_APEX_5_RW = enum__STORAGE_MEDIA_TYPE.PINNACLE_APEX_5_RW;
pub const SONY_12_WO = enum__STORAGE_MEDIA_TYPE.SONY_12_WO;
pub const PHILIPS_12_WO = enum__STORAGE_MEDIA_TYPE.PHILIPS_12_WO;
pub const HITACHI_12_WO = enum__STORAGE_MEDIA_TYPE.HITACHI_12_WO;
pub const CYGNET_12_WO = enum__STORAGE_MEDIA_TYPE.CYGNET_12_WO;
pub const KODAK_14_WO = enum__STORAGE_MEDIA_TYPE.KODAK_14_WO;
pub const MO_NFR_525 = enum__STORAGE_MEDIA_TYPE.MO_NFR_525;
pub const NIKON_12_RW = enum__STORAGE_MEDIA_TYPE.NIKON_12_RW;
pub const IOMEGA_ZIP = enum__STORAGE_MEDIA_TYPE.IOMEGA_ZIP;
pub const IOMEGA_JAZ = enum__STORAGE_MEDIA_TYPE.IOMEGA_JAZ;
pub const SYQUEST_EZ135 = enum__STORAGE_MEDIA_TYPE.SYQUEST_EZ135;
pub const SYQUEST_EZFLYER = enum__STORAGE_MEDIA_TYPE.SYQUEST_EZFLYER;
pub const SYQUEST_SYJET = enum__STORAGE_MEDIA_TYPE.SYQUEST_SYJET;
pub const AVATAR_F2 = enum__STORAGE_MEDIA_TYPE.AVATAR_F2;
pub const MP2_8mm = enum__STORAGE_MEDIA_TYPE.MP2_8mm;
pub const DST_S = enum__STORAGE_MEDIA_TYPE.DST_S;
pub const DST_M = enum__STORAGE_MEDIA_TYPE.DST_M;
pub const DST_L = enum__STORAGE_MEDIA_TYPE.DST_L;
pub const VXATape_1 = enum__STORAGE_MEDIA_TYPE.VXATape_1;
pub const VXATape_2 = enum__STORAGE_MEDIA_TYPE.VXATape_2;
pub const STK_9840 = enum__STORAGE_MEDIA_TYPE.STK_9840;
pub const LTO_Ultrium = enum__STORAGE_MEDIA_TYPE.LTO_Ultrium;
pub const LTO_Accelis = enum__STORAGE_MEDIA_TYPE.LTO_Accelis;
pub const DVD_RAM = enum__STORAGE_MEDIA_TYPE.DVD_RAM;
pub const AIT_8mm = enum__STORAGE_MEDIA_TYPE.AIT_8mm;
pub const ADR_1 = enum__STORAGE_MEDIA_TYPE.ADR_1;
pub const ADR_2 = enum__STORAGE_MEDIA_TYPE.ADR_2;
pub const STK_9940 = enum__STORAGE_MEDIA_TYPE.STK_9940;
pub const SAIT = enum__STORAGE_MEDIA_TYPE.SAIT;
pub const VXATape = enum__STORAGE_MEDIA_TYPE.VXATape;
pub const enum__STORAGE_MEDIA_TYPE = extern enum {
    DDS_4mm = 32,
    MiniQic = 33,
    Travan = 34,
    QIC = 35,
    MP_8mm = 36,
    AME_8mm = 37,
    AIT1_8mm = 38,
    DLT = 39,
    NCTP = 40,
    IBM_3480 = 41,
    IBM_3490E = 42,
    IBM_Magstar_3590 = 43,
    IBM_Magstar_MP = 44,
    STK_DATA_D3 = 45,
    SONY_DTF = 46,
    DV_6mm = 47,
    DMI = 48,
    SONY_D2 = 49,
    CLEANER_CARTRIDGE = 50,
    CD_ROM = 51,
    CD_R = 52,
    CD_RW = 53,
    DVD_ROM = 54,
    DVD_R = 55,
    DVD_RW = 56,
    MO_3_RW = 57,
    MO_5_WO = 58,
    MO_5_RW = 59,
    MO_5_LIMDOW = 60,
    PC_5_WO = 61,
    PC_5_RW = 62,
    PD_5_RW = 63,
    ABL_5_WO = 64,
    PINNACLE_APEX_5_RW = 65,
    SONY_12_WO = 66,
    PHILIPS_12_WO = 67,
    HITACHI_12_WO = 68,
    CYGNET_12_WO = 69,
    KODAK_14_WO = 70,
    MO_NFR_525 = 71,
    NIKON_12_RW = 72,
    IOMEGA_ZIP = 73,
    IOMEGA_JAZ = 74,
    SYQUEST_EZ135 = 75,
    SYQUEST_EZFLYER = 76,
    SYQUEST_SYJET = 77,
    AVATAR_F2 = 78,
    MP2_8mm = 79,
    DST_S = 80,
    DST_M = 81,
    DST_L = 82,
    VXATape_1 = 83,
    VXATape_2 = 84,
    STK_9840 = 85,
    LTO_Ultrium = 86,
    LTO_Accelis = 87,
    DVD_RAM = 88,
    AIT_8mm = 89,
    ADR_1 = 90,
    ADR_2 = 91,
    STK_9940 = 92,
    SAIT = 93,
    VXATape = 94,
};
pub const STORAGE_MEDIA_TYPE = enum__STORAGE_MEDIA_TYPE;
pub const PSTORAGE_MEDIA_TYPE = [*c]enum__STORAGE_MEDIA_TYPE;
pub const BusTypeUnknown = enum__STORAGE_BUS_TYPE.BusTypeUnknown;
pub const BusTypeScsi = enum__STORAGE_BUS_TYPE.BusTypeScsi;
pub const BusTypeAtapi = enum__STORAGE_BUS_TYPE.BusTypeAtapi;
pub const BusTypeAta = enum__STORAGE_BUS_TYPE.BusTypeAta;
pub const BusType1394 = enum__STORAGE_BUS_TYPE.BusType1394;
pub const BusTypeSsa = enum__STORAGE_BUS_TYPE.BusTypeSsa;
pub const BusTypeFibre = enum__STORAGE_BUS_TYPE.BusTypeFibre;
pub const BusTypeUsb = enum__STORAGE_BUS_TYPE.BusTypeUsb;
pub const BusTypeRAID = enum__STORAGE_BUS_TYPE.BusTypeRAID;
pub const BusTypeiScsi = enum__STORAGE_BUS_TYPE.BusTypeiScsi;
pub const BusTypeSas = enum__STORAGE_BUS_TYPE.BusTypeSas;
pub const BusTypeSata = enum__STORAGE_BUS_TYPE.BusTypeSata;
pub const BusTypeSd = enum__STORAGE_BUS_TYPE.BusTypeSd;
pub const BusTypeMmc = enum__STORAGE_BUS_TYPE.BusTypeMmc;
pub const BusTypeVirtual = enum__STORAGE_BUS_TYPE.BusTypeVirtual;
pub const BusTypeFileBackedVirtual = enum__STORAGE_BUS_TYPE.BusTypeFileBackedVirtual;
pub const BusTypeSpaces = enum__STORAGE_BUS_TYPE.BusTypeSpaces;
pub const BusTypeNvme = enum__STORAGE_BUS_TYPE.BusTypeNvme;
pub const BusTypeSCM = enum__STORAGE_BUS_TYPE.BusTypeSCM;
pub const BusTypeUfs = enum__STORAGE_BUS_TYPE.BusTypeUfs;
pub const BusTypeMax = enum__STORAGE_BUS_TYPE.BusTypeMax;
pub const BusTypeMaxReserved = enum__STORAGE_BUS_TYPE.BusTypeMaxReserved;
pub const enum__STORAGE_BUS_TYPE = extern enum {
    BusTypeUnknown = 0,
    BusTypeScsi = 1,
    BusTypeAtapi = 2,
    BusTypeAta = 3,
    BusType1394 = 4,
    BusTypeSsa = 5,
    BusTypeFibre = 6,
    BusTypeUsb = 7,
    BusTypeRAID = 8,
    BusTypeiScsi = 9,
    BusTypeSas = 10,
    BusTypeSata = 11,
    BusTypeSd = 12,
    BusTypeMmc = 13,
    BusTypeVirtual = 14,
    BusTypeFileBackedVirtual = 15,
    BusTypeSpaces = 16,
    BusTypeNvme = 17,
    BusTypeSCM = 18,
    BusTypeUfs = 19,
    BusTypeMax = 20,
    BusTypeMaxReserved = 127,
};
pub const STORAGE_BUS_TYPE = enum__STORAGE_BUS_TYPE;
pub const PSTORAGE_BUS_TYPE = [*c]enum__STORAGE_BUS_TYPE;
pub const struct__DEVICE_MEDIA_INFO = extern struct {
    DeviceSpecific: extern union {
        DiskInfo: extern struct {
            Cylinders: LARGE_INTEGER,
            MediaType: STORAGE_MEDIA_TYPE,
            TracksPerCylinder: DWORD,
            SectorsPerTrack: DWORD,
            BytesPerSector: DWORD,
            NumberMediaSides: DWORD,
            MediaCharacteristics: DWORD,
        },
        RemovableDiskInfo: extern struct {
            Cylinders: LARGE_INTEGER,
            MediaType: STORAGE_MEDIA_TYPE,
            TracksPerCylinder: DWORD,
            SectorsPerTrack: DWORD,
            BytesPerSector: DWORD,
            NumberMediaSides: DWORD,
            MediaCharacteristics: DWORD,
        },
        TapeInfo: extern struct {
            MediaType: STORAGE_MEDIA_TYPE,
            MediaCharacteristics: DWORD,
            CurrentBlockSize: DWORD,
            BusType: STORAGE_BUS_TYPE,
            BusSpecificData: extern union {
                ScsiInformation: extern struct {
                    MediumType: BYTE,
                    DensityCode: BYTE,
                },
            },
        },
    },
};
pub const DEVICE_MEDIA_INFO = struct__DEVICE_MEDIA_INFO;
pub const PDEVICE_MEDIA_INFO = [*c]struct__DEVICE_MEDIA_INFO;
pub const struct__GET_MEDIA_TYPES = extern struct {
    DeviceType: DWORD,
    MediaInfoCount: DWORD,
    MediaInfo: [1]DEVICE_MEDIA_INFO,
};
pub const GET_MEDIA_TYPES = struct__GET_MEDIA_TYPES;
pub const PGET_MEDIA_TYPES = [*c]struct__GET_MEDIA_TYPES;
pub const struct__STORAGE_PREDICT_FAILURE = extern struct {
    PredictFailure: DWORD,
    VendorSpecific: [512]BYTE,
};
pub const STORAGE_PREDICT_FAILURE = struct__STORAGE_PREDICT_FAILURE;
pub const PSTORAGE_PREDICT_FAILURE = [*c]struct__STORAGE_PREDICT_FAILURE;
pub const struct__STORAGE_FAILURE_PREDICTION_CONFIG = extern struct {
    Version: DWORD,
    Size: DWORD,
    Set: BOOLEAN,
    Enabled: BOOLEAN,
    Reserved: WORD,
};
pub const STORAGE_FAILURE_PREDICTION_CONFIG = struct__STORAGE_FAILURE_PREDICTION_CONFIG;
pub const PSTORAGE_FAILURE_PREDICTION_CONFIG = [*c]struct__STORAGE_FAILURE_PREDICTION_CONFIG;
pub const PropertyStandardQuery = enum__STORAGE_QUERY_TYPE.PropertyStandardQuery;
pub const PropertyExistsQuery = enum__STORAGE_QUERY_TYPE.PropertyExistsQuery;
pub const PropertyMaskQuery = enum__STORAGE_QUERY_TYPE.PropertyMaskQuery;
pub const PropertyQueryMaxDefined = enum__STORAGE_QUERY_TYPE.PropertyQueryMaxDefined;
pub const enum__STORAGE_QUERY_TYPE = extern enum {
    PropertyStandardQuery = 0,
    PropertyExistsQuery = 1,
    PropertyMaskQuery = 2,
    PropertyQueryMaxDefined = 3,
};
pub const STORAGE_QUERY_TYPE = enum__STORAGE_QUERY_TYPE;
pub const PSTORAGE_QUERY_TYPE = [*c]enum__STORAGE_QUERY_TYPE;
pub const PropertyStandardSet = enum__STORAGE_SET_TYPE.PropertyStandardSet;
pub const PropertyExistsSet = enum__STORAGE_SET_TYPE.PropertyExistsSet;
pub const PropertySetMaxDefined = enum__STORAGE_SET_TYPE.PropertySetMaxDefined;
pub const enum__STORAGE_SET_TYPE = extern enum {
    PropertyStandardSet = 0,
    PropertyExistsSet = 1,
    PropertySetMaxDefined = 2,
};
pub const STORAGE_SET_TYPE = enum__STORAGE_SET_TYPE;
pub const PSTORAGE_SET_TYPE = [*c]enum__STORAGE_SET_TYPE;
pub const StorageDeviceProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceProperty;
pub const StorageAdapterProperty = enum__STORAGE_PROPERTY_ID.StorageAdapterProperty;
pub const StorageDeviceIdProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceIdProperty;
pub const StorageDeviceUniqueIdProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceUniqueIdProperty;
pub const StorageDeviceWriteCacheProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceWriteCacheProperty;
pub const StorageMiniportProperty = enum__STORAGE_PROPERTY_ID.StorageMiniportProperty;
pub const StorageAccessAlignmentProperty = enum__STORAGE_PROPERTY_ID.StorageAccessAlignmentProperty;
pub const StorageDeviceSeekPenaltyProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceSeekPenaltyProperty;
pub const StorageDeviceTrimProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceTrimProperty;
pub const StorageDeviceWriteAggregationProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceWriteAggregationProperty;
pub const StorageDeviceDeviceTelemetryProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceDeviceTelemetryProperty;
pub const StorageDeviceLBProvisioningProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceLBProvisioningProperty;
pub const StorageDevicePowerProperty = enum__STORAGE_PROPERTY_ID.StorageDevicePowerProperty;
pub const StorageDeviceCopyOffloadProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceCopyOffloadProperty;
pub const StorageDeviceResiliencyProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceResiliencyProperty;
pub const StorageDeviceMediumProductType = enum__STORAGE_PROPERTY_ID.StorageDeviceMediumProductType;
pub const StorageAdapterRpmbProperty = enum__STORAGE_PROPERTY_ID.StorageAdapterRpmbProperty;
pub const StorageAdapterCryptoProperty = enum__STORAGE_PROPERTY_ID.StorageAdapterCryptoProperty;
pub const StorageDeviceIoCapabilityProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceIoCapabilityProperty;
pub const StorageAdapterProtocolSpecificProperty = enum__STORAGE_PROPERTY_ID.StorageAdapterProtocolSpecificProperty;
pub const StorageDeviceProtocolSpecificProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceProtocolSpecificProperty;
pub const StorageAdapterTemperatureProperty = enum__STORAGE_PROPERTY_ID.StorageAdapterTemperatureProperty;
pub const StorageDeviceTemperatureProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceTemperatureProperty;
pub const StorageAdapterPhysicalTopologyProperty = enum__STORAGE_PROPERTY_ID.StorageAdapterPhysicalTopologyProperty;
pub const StorageDevicePhysicalTopologyProperty = enum__STORAGE_PROPERTY_ID.StorageDevicePhysicalTopologyProperty;
pub const StorageDeviceAttributesProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceAttributesProperty;
pub const StorageDeviceManagementStatus = enum__STORAGE_PROPERTY_ID.StorageDeviceManagementStatus;
pub const StorageAdapterSerialNumberProperty = enum__STORAGE_PROPERTY_ID.StorageAdapterSerialNumberProperty;
pub const StorageDeviceLocationProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceLocationProperty;
pub const StorageDeviceNumaProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceNumaProperty;
pub const StorageDeviceZonedDeviceProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceZonedDeviceProperty;
pub const StorageDeviceUnsafeShutdownCount = enum__STORAGE_PROPERTY_ID.StorageDeviceUnsafeShutdownCount;
pub const StorageDeviceEnduranceProperty = enum__STORAGE_PROPERTY_ID.StorageDeviceEnduranceProperty;
pub const enum__STORAGE_PROPERTY_ID = extern enum {
    StorageDeviceProperty = 0,
    StorageAdapterProperty = 1,
    StorageDeviceIdProperty = 2,
    StorageDeviceUniqueIdProperty = 3,
    StorageDeviceWriteCacheProperty = 4,
    StorageMiniportProperty = 5,
    StorageAccessAlignmentProperty = 6,
    StorageDeviceSeekPenaltyProperty = 7,
    StorageDeviceTrimProperty = 8,
    StorageDeviceWriteAggregationProperty = 9,
    StorageDeviceDeviceTelemetryProperty = 10,
    StorageDeviceLBProvisioningProperty = 11,
    StorageDevicePowerProperty = 12,
    StorageDeviceCopyOffloadProperty = 13,
    StorageDeviceResiliencyProperty = 14,
    StorageDeviceMediumProductType = 15,
    StorageAdapterRpmbProperty = 16,
    StorageAdapterCryptoProperty = 17,
    StorageDeviceIoCapabilityProperty = 48,
    StorageAdapterProtocolSpecificProperty = 49,
    StorageDeviceProtocolSpecificProperty = 50,
    StorageAdapterTemperatureProperty = 51,
    StorageDeviceTemperatureProperty = 52,
    StorageAdapterPhysicalTopologyProperty = 53,
    StorageDevicePhysicalTopologyProperty = 54,
    StorageDeviceAttributesProperty = 55,
    StorageDeviceManagementStatus = 56,
    StorageAdapterSerialNumberProperty = 57,
    StorageDeviceLocationProperty = 58,
    StorageDeviceNumaProperty = 59,
    StorageDeviceZonedDeviceProperty = 60,
    StorageDeviceUnsafeShutdownCount = 61,
    StorageDeviceEnduranceProperty = 62,
};
pub const STORAGE_PROPERTY_ID = enum__STORAGE_PROPERTY_ID;
pub const PSTORAGE_PROPERTY_ID = [*c]enum__STORAGE_PROPERTY_ID;
pub const struct__STORAGE_PROPERTY_QUERY = extern struct {
    PropertyId: STORAGE_PROPERTY_ID,
    QueryType: STORAGE_QUERY_TYPE,
    AdditionalParameters: [1]BYTE,
};
pub const STORAGE_PROPERTY_QUERY = struct__STORAGE_PROPERTY_QUERY;
pub const PSTORAGE_PROPERTY_QUERY = [*c]struct__STORAGE_PROPERTY_QUERY;
pub const struct__STORAGE_PROPERTY_SET = extern struct {
    PropertyId: STORAGE_PROPERTY_ID,
    SetType: STORAGE_SET_TYPE,
    AdditionalParameters: [1]BYTE,
};
pub const STORAGE_PROPERTY_SET = struct__STORAGE_PROPERTY_SET;
pub const PSTORAGE_PROPERTY_SET = [*c]struct__STORAGE_PROPERTY_SET;
pub const struct__STORAGE_DESCRIPTOR_HEADER = extern struct {
    Version: DWORD,
    Size: DWORD,
};
pub const STORAGE_DESCRIPTOR_HEADER = struct__STORAGE_DESCRIPTOR_HEADER;
pub const PSTORAGE_DESCRIPTOR_HEADER = [*c]struct__STORAGE_DESCRIPTOR_HEADER;
pub const struct__STORAGE_DEVICE_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    DeviceType: BYTE,
    DeviceTypeModifier: BYTE,
    RemovableMedia: BOOLEAN,
    CommandQueueing: BOOLEAN,
    VendorIdOffset: DWORD,
    ProductIdOffset: DWORD,
    ProductRevisionOffset: DWORD,
    SerialNumberOffset: DWORD,
    BusType: STORAGE_BUS_TYPE,
    RawPropertiesLength: DWORD,
    RawDeviceProperties: [1]BYTE,
};
pub const STORAGE_DEVICE_DESCRIPTOR = struct__STORAGE_DEVICE_DESCRIPTOR;
pub const PSTORAGE_DEVICE_DESCRIPTOR = [*c]struct__STORAGE_DEVICE_DESCRIPTOR;
pub const struct__STORAGE_ADAPTER_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    MaximumTransferLength: DWORD,
    MaximumPhysicalPages: DWORD,
    AlignmentMask: DWORD,
    AdapterUsesPio: BOOLEAN,
    AdapterScansDown: BOOLEAN,
    CommandQueueing: BOOLEAN,
    AcceleratedTransfer: BOOLEAN,
    BusType: BYTE,
    BusMajorVersion: WORD,
    BusMinorVersion: WORD,
    SrbType: BYTE,
    AddressType: BYTE,
};
pub const STORAGE_ADAPTER_DESCRIPTOR = struct__STORAGE_ADAPTER_DESCRIPTOR;
pub const PSTORAGE_ADAPTER_DESCRIPTOR = [*c]struct__STORAGE_ADAPTER_DESCRIPTOR;
pub const struct__STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    BytesPerCacheLine: DWORD,
    BytesOffsetForCacheAlignment: DWORD,
    BytesPerLogicalSector: DWORD,
    BytesPerPhysicalSector: DWORD,
    BytesOffsetForSectorAlignment: DWORD,
};
pub const STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR = struct__STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR;
pub const PSTORAGE_ACCESS_ALIGNMENT_DESCRIPTOR = [*c]struct__STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR;
pub const struct__STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    MediumProductType: DWORD,
};
pub const STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR = struct__STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR;
pub const PSTORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR = [*c]struct__STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR;
pub const StoragePortCodeSetReserved = enum__STORAGE_PORT_CODE_SET.StoragePortCodeSetReserved;
pub const StoragePortCodeSetStorport = enum__STORAGE_PORT_CODE_SET.StoragePortCodeSetStorport;
pub const StoragePortCodeSetSCSIport = enum__STORAGE_PORT_CODE_SET.StoragePortCodeSetSCSIport;
pub const StoragePortCodeSetSpaceport = enum__STORAGE_PORT_CODE_SET.StoragePortCodeSetSpaceport;
pub const StoragePortCodeSetATAport = enum__STORAGE_PORT_CODE_SET.StoragePortCodeSetATAport;
pub const StoragePortCodeSetUSBport = enum__STORAGE_PORT_CODE_SET.StoragePortCodeSetUSBport;
pub const StoragePortCodeSetSBP2port = enum__STORAGE_PORT_CODE_SET.StoragePortCodeSetSBP2port;
pub const StoragePortCodeSetSDport = enum__STORAGE_PORT_CODE_SET.StoragePortCodeSetSDport;
pub const enum__STORAGE_PORT_CODE_SET = extern enum {
    StoragePortCodeSetReserved = 0,
    StoragePortCodeSetStorport = 1,
    StoragePortCodeSetSCSIport = 2,
    StoragePortCodeSetSpaceport = 3,
    StoragePortCodeSetATAport = 4,
    StoragePortCodeSetUSBport = 5,
    StoragePortCodeSetSBP2port = 6,
    StoragePortCodeSetSDport = 7,
};
pub const STORAGE_PORT_CODE_SET = enum__STORAGE_PORT_CODE_SET;
pub const PSTORAGE_PORT_CODE_SET = [*c]enum__STORAGE_PORT_CODE_SET;
pub const struct__STORAGE_MINIPORT_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    Portdriver: STORAGE_PORT_CODE_SET,
    LUNResetSupported: BOOLEAN,
    TargetResetSupported: BOOLEAN,
    IoTimeoutValue: WORD,
    ExtraIoInfoSupported: BOOLEAN,
    Reserved0: [3]BYTE,
    Reserved1: DWORD,
};
pub const STORAGE_MINIPORT_DESCRIPTOR = struct__STORAGE_MINIPORT_DESCRIPTOR;
pub const PSTORAGE_MINIPORT_DESCRIPTOR = [*c]struct__STORAGE_MINIPORT_DESCRIPTOR;
pub const StorageIdCodeSetReserved = enum__STORAGE_IDENTIFIER_CODE_SET.StorageIdCodeSetReserved;
pub const StorageIdCodeSetBinary = enum__STORAGE_IDENTIFIER_CODE_SET.StorageIdCodeSetBinary;
pub const StorageIdCodeSetAscii = enum__STORAGE_IDENTIFIER_CODE_SET.StorageIdCodeSetAscii;
pub const StorageIdCodeSetUtf8 = enum__STORAGE_IDENTIFIER_CODE_SET.StorageIdCodeSetUtf8;
pub const enum__STORAGE_IDENTIFIER_CODE_SET = extern enum {
    StorageIdCodeSetReserved = 0,
    StorageIdCodeSetBinary = 1,
    StorageIdCodeSetAscii = 2,
    StorageIdCodeSetUtf8 = 3,
};
pub const STORAGE_IDENTIFIER_CODE_SET = enum__STORAGE_IDENTIFIER_CODE_SET;
pub const PSTORAGE_IDENTIFIER_CODE_SET = [*c]enum__STORAGE_IDENTIFIER_CODE_SET;
pub const StorageIdTypeVendorSpecific = enum__STORAGE_IDENTIFIER_TYPE.StorageIdTypeVendorSpecific;
pub const StorageIdTypeVendorId = enum__STORAGE_IDENTIFIER_TYPE.StorageIdTypeVendorId;
pub const StorageIdTypeEUI64 = enum__STORAGE_IDENTIFIER_TYPE.StorageIdTypeEUI64;
pub const StorageIdTypeFCPHName = enum__STORAGE_IDENTIFIER_TYPE.StorageIdTypeFCPHName;
pub const StorageIdTypePortRelative = enum__STORAGE_IDENTIFIER_TYPE.StorageIdTypePortRelative;
pub const StorageIdTypeTargetPortGroup = enum__STORAGE_IDENTIFIER_TYPE.StorageIdTypeTargetPortGroup;
pub const StorageIdTypeLogicalUnitGroup = enum__STORAGE_IDENTIFIER_TYPE.StorageIdTypeLogicalUnitGroup;
pub const StorageIdTypeMD5LogicalUnitIdentifier = enum__STORAGE_IDENTIFIER_TYPE.StorageIdTypeMD5LogicalUnitIdentifier;
pub const StorageIdTypeScsiNameString = enum__STORAGE_IDENTIFIER_TYPE.StorageIdTypeScsiNameString;
pub const enum__STORAGE_IDENTIFIER_TYPE = extern enum {
    StorageIdTypeVendorSpecific = 0,
    StorageIdTypeVendorId = 1,
    StorageIdTypeEUI64 = 2,
    StorageIdTypeFCPHName = 3,
    StorageIdTypePortRelative = 4,
    StorageIdTypeTargetPortGroup = 5,
    StorageIdTypeLogicalUnitGroup = 6,
    StorageIdTypeMD5LogicalUnitIdentifier = 7,
    StorageIdTypeScsiNameString = 8,
};
pub const STORAGE_IDENTIFIER_TYPE = enum__STORAGE_IDENTIFIER_TYPE;
pub const PSTORAGE_IDENTIFIER_TYPE = [*c]enum__STORAGE_IDENTIFIER_TYPE;
pub const StorageIdNAAFormatIEEEExtended = enum__STORAGE_ID_NAA_FORMAT.StorageIdNAAFormatIEEEExtended;
pub const StorageIdNAAFormatIEEERegistered = enum__STORAGE_ID_NAA_FORMAT.StorageIdNAAFormatIEEERegistered;
pub const StorageIdNAAFormatIEEEERegisteredExtended = enum__STORAGE_ID_NAA_FORMAT.StorageIdNAAFormatIEEEERegisteredExtended;
pub const enum__STORAGE_ID_NAA_FORMAT = extern enum {
    StorageIdNAAFormatIEEEExtended = 2,
    StorageIdNAAFormatIEEERegistered = 3,
    StorageIdNAAFormatIEEEERegisteredExtended = 5,
};
pub const STORAGE_ID_NAA_FORMAT = enum__STORAGE_ID_NAA_FORMAT;
pub const PSTORAGE_ID_NAA_FORMAT = [*c]enum__STORAGE_ID_NAA_FORMAT;
pub const StorageIdAssocDevice = enum__STORAGE_ASSOCIATION_TYPE.StorageIdAssocDevice;
pub const StorageIdAssocPort = enum__STORAGE_ASSOCIATION_TYPE.StorageIdAssocPort;
pub const StorageIdAssocTarget = enum__STORAGE_ASSOCIATION_TYPE.StorageIdAssocTarget;
pub const enum__STORAGE_ASSOCIATION_TYPE = extern enum {
    StorageIdAssocDevice = 0,
    StorageIdAssocPort = 1,
    StorageIdAssocTarget = 2,
};
pub const STORAGE_ASSOCIATION_TYPE = enum__STORAGE_ASSOCIATION_TYPE;
pub const PSTORAGE_ASSOCIATION_TYPE = [*c]enum__STORAGE_ASSOCIATION_TYPE;
pub const struct__STORAGE_IDENTIFIER = extern struct {
    CodeSet: STORAGE_IDENTIFIER_CODE_SET,
    Type: STORAGE_IDENTIFIER_TYPE,
    IdentifierSize: WORD,
    NextOffset: WORD,
    Association: STORAGE_ASSOCIATION_TYPE,
    Identifier: [1]BYTE,
};
pub const STORAGE_IDENTIFIER = struct__STORAGE_IDENTIFIER;
pub const PSTORAGE_IDENTIFIER = [*c]struct__STORAGE_IDENTIFIER;
pub const struct__STORAGE_DEVICE_ID_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    NumberOfIdentifiers: DWORD,
    Identifiers: [1]BYTE,
};
pub const STORAGE_DEVICE_ID_DESCRIPTOR = struct__STORAGE_DEVICE_ID_DESCRIPTOR;
pub const PSTORAGE_DEVICE_ID_DESCRIPTOR = [*c]struct__STORAGE_DEVICE_ID_DESCRIPTOR;
pub const struct__DEVICE_SEEK_PENALTY_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    IncursSeekPenalty: BOOLEAN,
};
pub const DEVICE_SEEK_PENALTY_DESCRIPTOR = struct__DEVICE_SEEK_PENALTY_DESCRIPTOR;
pub const PDEVICE_SEEK_PENALTY_DESCRIPTOR = [*c]struct__DEVICE_SEEK_PENALTY_DESCRIPTOR;
pub const struct__DEVICE_WRITE_AGGREGATION_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    BenefitsFromWriteAggregation: BOOLEAN,
};
pub const DEVICE_WRITE_AGGREGATION_DESCRIPTOR = struct__DEVICE_WRITE_AGGREGATION_DESCRIPTOR;
pub const PDEVICE_WRITE_AGGREGATION_DESCRIPTOR = [*c]struct__DEVICE_WRITE_AGGREGATION_DESCRIPTOR;
pub const struct__DEVICE_TRIM_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    TrimEnabled: BOOLEAN,
};
pub const DEVICE_TRIM_DESCRIPTOR = struct__DEVICE_TRIM_DESCRIPTOR;
pub const PDEVICE_TRIM_DESCRIPTOR = [*c]struct__DEVICE_TRIM_DESCRIPTOR;
pub const struct__DEVICE_LB_PROVISIONING_DESCRIPTOR = @OpaqueType();
pub const DEVICE_LB_PROVISIONING_DESCRIPTOR = struct__DEVICE_LB_PROVISIONING_DESCRIPTOR;
pub const PDEVICE_LB_PROVISIONING_DESCRIPTOR = ?*struct__DEVICE_LB_PROVISIONING_DESCRIPTOR;
pub const struct__STORAGE_LB_PROVISIONING_MAP_RESOURCES = @OpaqueType();
pub const STORAGE_LB_PROVISIONING_MAP_RESOURCES = struct__STORAGE_LB_PROVISIONING_MAP_RESOURCES;
pub const PSTORAGE_LB_PROVISIONING_MAP_RESOURCES = ?*struct__STORAGE_LB_PROVISIONING_MAP_RESOURCES;
pub const struct__DEVICE_POWER_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    DeviceAttentionSupported: BOOLEAN,
    AsynchronousNotificationSupported: BOOLEAN,
    IdlePowerManagementEnabled: BOOLEAN,
    D3ColdEnabled: BOOLEAN,
    D3ColdSupported: BOOLEAN,
    NoVerifyDuringIdlePower: BOOLEAN,
    Reserved: [2]BYTE,
    IdleTimeoutInMS: DWORD,
};
pub const DEVICE_POWER_DESCRIPTOR = struct__DEVICE_POWER_DESCRIPTOR;
pub const PDEVICE_POWER_DESCRIPTOR = [*c]struct__DEVICE_POWER_DESCRIPTOR;
pub const struct__DEVICE_COPY_OFFLOAD_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    MaximumTokenLifetime: DWORD,
    DefaultTokenLifetime: DWORD,
    MaximumTransferSize: DWORDLONG,
    OptimalTransferCount: DWORDLONG,
    MaximumDataDescriptors: DWORD,
    MaximumTransferLengthPerDescriptor: DWORD,
    OptimalTransferLengthPerDescriptor: DWORD,
    OptimalTransferLengthGranularity: WORD,
    Reserved: [2]BYTE,
};
pub const DEVICE_COPY_OFFLOAD_DESCRIPTOR = struct__DEVICE_COPY_OFFLOAD_DESCRIPTOR;
pub const PDEVICE_COPY_OFFLOAD_DESCRIPTOR = [*c]struct__DEVICE_COPY_OFFLOAD_DESCRIPTOR;
pub const struct__STORAGE_DEVICE_RESILIENCY_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    NameOffset: DWORD,
    NumberOfLogicalCopies: DWORD,
    NumberOfPhysicalCopies: DWORD,
    PhysicalDiskRedundancy: DWORD,
    NumberOfColumns: DWORD,
    Interleave: DWORD,
};
pub const STORAGE_DEVICE_RESILIENCY_DESCRIPTOR = struct__STORAGE_DEVICE_RESILIENCY_DESCRIPTOR;
pub const PSTORAGE_DEVICE_RESILIENCY_DESCRIPTOR = [*c]struct__STORAGE_DEVICE_RESILIENCY_DESCRIPTOR;
pub const StorageRpmbFrameTypeUnknown = enum__STORAGE_RPMB_FRAME_TYPE.StorageRpmbFrameTypeUnknown;
pub const StorageRpmbFrameTypeStandard = enum__STORAGE_RPMB_FRAME_TYPE.StorageRpmbFrameTypeStandard;
pub const StorageRpmbFrameTypeMax = enum__STORAGE_RPMB_FRAME_TYPE.StorageRpmbFrameTypeMax;
pub const enum__STORAGE_RPMB_FRAME_TYPE = extern enum {
    StorageRpmbFrameTypeUnknown = 0,
    StorageRpmbFrameTypeStandard = 1,
    StorageRpmbFrameTypeMax = 2,
};
pub const STORAGE_RPMB_FRAME_TYPE = enum__STORAGE_RPMB_FRAME_TYPE;
pub const PSTORAGE_RPMB_FRAME_TYPE = [*c]enum__STORAGE_RPMB_FRAME_TYPE;
pub const struct__STORAGE_RPMB_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    SizeInBytes: DWORD,
    MaxReliableWriteSizeInBytes: DWORD,
    FrameFormat: STORAGE_RPMB_FRAME_TYPE,
};
pub const STORAGE_RPMB_DESCRIPTOR = struct__STORAGE_RPMB_DESCRIPTOR;
pub const PSTORAGE_RPMB_DESCRIPTOR = [*c]struct__STORAGE_RPMB_DESCRIPTOR;
pub const StorageCryptoAlgorithmUnknown = enum__STORAGE_CRYPTO_ALGORITHM_ID.StorageCryptoAlgorithmUnknown;
pub const StorageCryptoAlgorithmXTSAES = enum__STORAGE_CRYPTO_ALGORITHM_ID.StorageCryptoAlgorithmXTSAES;
pub const StorageCryptoAlgorithmBitlockerAESCBC = enum__STORAGE_CRYPTO_ALGORITHM_ID.StorageCryptoAlgorithmBitlockerAESCBC;
pub const StorageCryptoAlgorithmAESECB = enum__STORAGE_CRYPTO_ALGORITHM_ID.StorageCryptoAlgorithmAESECB;
pub const StorageCryptoAlgorithmESSIVAESCBC = enum__STORAGE_CRYPTO_ALGORITHM_ID.StorageCryptoAlgorithmESSIVAESCBC;
pub const StorageCryptoAlgorithmMax = enum__STORAGE_CRYPTO_ALGORITHM_ID.StorageCryptoAlgorithmMax;
pub const enum__STORAGE_CRYPTO_ALGORITHM_ID = extern enum {
    StorageCryptoAlgorithmUnknown = 0,
    StorageCryptoAlgorithmXTSAES = 1,
    StorageCryptoAlgorithmBitlockerAESCBC = 2,
    StorageCryptoAlgorithmAESECB = 3,
    StorageCryptoAlgorithmESSIVAESCBC = 4,
    StorageCryptoAlgorithmMax = 5,
};
pub const STORAGE_CRYPTO_ALGORITHM_ID = enum__STORAGE_CRYPTO_ALGORITHM_ID;
pub const PSTORAGE_CRYPTO_ALGORITHM_ID = [*c]enum__STORAGE_CRYPTO_ALGORITHM_ID;
pub const StorageCryptoKeySizeUnknown = enum__STORAGE_CRYPTO_KEY_SIZE.StorageCryptoKeySizeUnknown;
pub const StorageCryptoKeySize128Bits = enum__STORAGE_CRYPTO_KEY_SIZE.StorageCryptoKeySize128Bits;
pub const StorageCryptoKeySize192Bits = enum__STORAGE_CRYPTO_KEY_SIZE.StorageCryptoKeySize192Bits;
pub const StorageCryptoKeySize256Bits = enum__STORAGE_CRYPTO_KEY_SIZE.StorageCryptoKeySize256Bits;
pub const StorageCryptoKeySize512Bits = enum__STORAGE_CRYPTO_KEY_SIZE.StorageCryptoKeySize512Bits;
pub const enum__STORAGE_CRYPTO_KEY_SIZE = extern enum {
    StorageCryptoKeySizeUnknown = 0,
    StorageCryptoKeySize128Bits = 1,
    StorageCryptoKeySize192Bits = 2,
    StorageCryptoKeySize256Bits = 3,
    StorageCryptoKeySize512Bits = 4,
};
pub const STORAGE_CRYPTO_KEY_SIZE = enum__STORAGE_CRYPTO_KEY_SIZE;
pub const PSTORAGE_CRYPTO_KEY_SIZE = [*c]enum__STORAGE_CRYPTO_KEY_SIZE;
pub const struct__STORAGE_CRYPTO_CAPABILITY = extern struct {
    Version: DWORD,
    Size: DWORD,
    CryptoCapabilityIndex: DWORD,
    AlgorithmId: STORAGE_CRYPTO_ALGORITHM_ID,
    KeySize: STORAGE_CRYPTO_KEY_SIZE,
    DataUnitSizeBitmask: DWORD,
};
pub const STORAGE_CRYPTO_CAPABILITY = struct__STORAGE_CRYPTO_CAPABILITY;
pub const PSTORAGE_CRYPTO_CAPABILITY = [*c]struct__STORAGE_CRYPTO_CAPABILITY;
pub const struct__STORAGE_CRYPTO_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    NumKeysSupported: DWORD,
    NumCryptoCapabilities: DWORD,
    CryptoCapabilities: [1]STORAGE_CRYPTO_CAPABILITY,
};
pub const STORAGE_CRYPTO_DESCRIPTOR = struct__STORAGE_CRYPTO_DESCRIPTOR;
pub const PSTORAGE_CRYPTO_DESCRIPTOR = [*c]struct__STORAGE_CRYPTO_DESCRIPTOR;
pub const StorageTierMediaTypeUnspecified = enum__STORAGE_TIER_MEDIA_TYPE.StorageTierMediaTypeUnspecified;
pub const StorageTierMediaTypeDisk = enum__STORAGE_TIER_MEDIA_TYPE.StorageTierMediaTypeDisk;
pub const StorageTierMediaTypeSsd = enum__STORAGE_TIER_MEDIA_TYPE.StorageTierMediaTypeSsd;
pub const StorageTierMediaTypeScm = enum__STORAGE_TIER_MEDIA_TYPE.StorageTierMediaTypeScm;
pub const StorageTierMediaTypeMax = enum__STORAGE_TIER_MEDIA_TYPE.StorageTierMediaTypeMax;
pub const enum__STORAGE_TIER_MEDIA_TYPE = extern enum {
    StorageTierMediaTypeUnspecified = 0,
    StorageTierMediaTypeDisk = 1,
    StorageTierMediaTypeSsd = 2,
    StorageTierMediaTypeScm = 4,
    StorageTierMediaTypeMax = 5,
};
pub const STORAGE_TIER_MEDIA_TYPE = enum__STORAGE_TIER_MEDIA_TYPE;
pub const PSTORAGE_TIER_MEDIA_TYPE = [*c]enum__STORAGE_TIER_MEDIA_TYPE;
pub const StorageTierClassUnspecified = enum__STORAGE_TIER_CLASS.StorageTierClassUnspecified;
pub const StorageTierClassCapacity = enum__STORAGE_TIER_CLASS.StorageTierClassCapacity;
pub const StorageTierClassPerformance = enum__STORAGE_TIER_CLASS.StorageTierClassPerformance;
pub const StorageTierClassMax = enum__STORAGE_TIER_CLASS.StorageTierClassMax;
pub const enum__STORAGE_TIER_CLASS = extern enum {
    StorageTierClassUnspecified = 0,
    StorageTierClassCapacity = 1,
    StorageTierClassPerformance = 2,
    StorageTierClassMax = 3,
};
pub const STORAGE_TIER_CLASS = enum__STORAGE_TIER_CLASS;
pub const PSTORAGE_TIER_CLASS = [*c]enum__STORAGE_TIER_CLASS;
pub const struct__STORAGE_TIER = extern struct {
    Id: GUID,
    Name: [256]WCHAR,
    Description: [256]WCHAR,
    Flags: DWORDLONG,
    ProvisionedCapacity: DWORDLONG,
    MediaType: STORAGE_TIER_MEDIA_TYPE,
    Class: STORAGE_TIER_CLASS,
};
pub const STORAGE_TIER = struct__STORAGE_TIER;
pub const PSTORAGE_TIER = [*c]struct__STORAGE_TIER;
pub const struct__STORAGE_DEVICE_TIERING_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    Flags: DWORD,
    TotalNumberOfTiers: DWORD,
    NumberOfTiersReturned: DWORD,
    Tiers: [1]STORAGE_TIER,
};
pub const STORAGE_DEVICE_TIERING_DESCRIPTOR = struct__STORAGE_DEVICE_TIERING_DESCRIPTOR;
pub const PSTORAGE_DEVICE_TIERING_DESCRIPTOR = [*c]struct__STORAGE_DEVICE_TIERING_DESCRIPTOR;
pub const struct__STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    NumberOfFaultDomains: DWORD,
    FaultDomainIds: [1]GUID,
};
pub const STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR = struct__STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR;
pub const PSTORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR = [*c]struct__STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR;
pub const ProtocolTypeUnknown = enum__STORAGE_PROTOCOL_TYPE.ProtocolTypeUnknown;
pub const ProtocolTypeScsi = enum__STORAGE_PROTOCOL_TYPE.ProtocolTypeScsi;
pub const ProtocolTypeAta = enum__STORAGE_PROTOCOL_TYPE.ProtocolTypeAta;
pub const ProtocolTypeNvme = enum__STORAGE_PROTOCOL_TYPE.ProtocolTypeNvme;
pub const ProtocolTypeSd = enum__STORAGE_PROTOCOL_TYPE.ProtocolTypeSd;
pub const ProtocolTypeUfs = enum__STORAGE_PROTOCOL_TYPE.ProtocolTypeUfs;
pub const ProtocolTypeProprietary = enum__STORAGE_PROTOCOL_TYPE.ProtocolTypeProprietary;
pub const ProtocolTypeMaxReserved = enum__STORAGE_PROTOCOL_TYPE.ProtocolTypeMaxReserved;
pub const enum__STORAGE_PROTOCOL_TYPE = extern enum {
    ProtocolTypeUnknown = 0,
    ProtocolTypeScsi = 1,
    ProtocolTypeAta = 2,
    ProtocolTypeNvme = 3,
    ProtocolTypeSd = 4,
    ProtocolTypeUfs = 5,
    ProtocolTypeProprietary = 126,
    ProtocolTypeMaxReserved = 127,
};
pub const STORAGE_PROTOCOL_TYPE = enum__STORAGE_PROTOCOL_TYPE;
pub const PSTORAGE_PROTOCOL_TYPE = [*c]enum__STORAGE_PROTOCOL_TYPE;
pub const NVMeDataTypeUnknown = enum__STORAGE_PROTOCOL_NVME_DATA_TYPE.NVMeDataTypeUnknown;
pub const NVMeDataTypeIdentify = enum__STORAGE_PROTOCOL_NVME_DATA_TYPE.NVMeDataTypeIdentify;
pub const NVMeDataTypeLogPage = enum__STORAGE_PROTOCOL_NVME_DATA_TYPE.NVMeDataTypeLogPage;
pub const NVMeDataTypeFeature = enum__STORAGE_PROTOCOL_NVME_DATA_TYPE.NVMeDataTypeFeature;
pub const enum__STORAGE_PROTOCOL_NVME_DATA_TYPE = extern enum {
    NVMeDataTypeUnknown = 0,
    NVMeDataTypeIdentify = 1,
    NVMeDataTypeLogPage = 2,
    NVMeDataTypeFeature = 3,
};
pub const STORAGE_PROTOCOL_NVME_DATA_TYPE = enum__STORAGE_PROTOCOL_NVME_DATA_TYPE;
pub const PSTORAGE_PROTOCOL_NVME_DATA_TYPE = [*c]enum__STORAGE_PROTOCOL_NVME_DATA_TYPE;
pub const AtaDataTypeUnknown = enum__STORAGE_PROTOCOL_ATA_DATA_TYPE.AtaDataTypeUnknown;
pub const AtaDataTypeIdentify = enum__STORAGE_PROTOCOL_ATA_DATA_TYPE.AtaDataTypeIdentify;
pub const AtaDataTypeLogPage = enum__STORAGE_PROTOCOL_ATA_DATA_TYPE.AtaDataTypeLogPage;
pub const enum__STORAGE_PROTOCOL_ATA_DATA_TYPE = extern enum {
    AtaDataTypeUnknown = 0,
    AtaDataTypeIdentify = 1,
    AtaDataTypeLogPage = 2,
};
pub const STORAGE_PROTOCOL_ATA_DATA_TYPE = enum__STORAGE_PROTOCOL_ATA_DATA_TYPE;
pub const PSTORAGE_PROTOCOL_ATA_DATA_TYPE = [*c]enum__STORAGE_PROTOCOL_ATA_DATA_TYPE;
pub const UfsDataTypeUnknown = enum__STORAGE_PROTOCOL_UFS_DATA_TYPE.UfsDataTypeUnknown;
pub const UfsDataTypeQueryDescriptor = enum__STORAGE_PROTOCOL_UFS_DATA_TYPE.UfsDataTypeQueryDescriptor;
pub const UfsDataTypeMax = enum__STORAGE_PROTOCOL_UFS_DATA_TYPE.UfsDataTypeMax;
pub const enum__STORAGE_PROTOCOL_UFS_DATA_TYPE = extern enum {
    UfsDataTypeUnknown = 0,
    UfsDataTypeQueryDescriptor = 1,
    UfsDataTypeMax = 2,
};
pub const STORAGE_PROTOCOL_UFS_DATA_TYPE = enum__STORAGE_PROTOCOL_UFS_DATA_TYPE;
pub const PSTORAGE_PROTOCOL_UFS_DATA_TYPE = [*c]enum__STORAGE_PROTOCOL_UFS_DATA_TYPE;
pub const struct__STORAGE_PROTOCOL_SPECIFIC_DATA = extern struct {
    ProtocolType: STORAGE_PROTOCOL_TYPE,
    DataType: DWORD,
    ProtocolDataRequestValue: DWORD,
    ProtocolDataRequestSubValue: DWORD,
    ProtocolDataOffset: DWORD,
    ProtocolDataLength: DWORD,
    FixedProtocolReturnData: DWORD,
    ProtocolDataRequestSubValue2: DWORD,
    ProtocolDataRequestSubValue3: DWORD,
    Reserved: DWORD,
};
pub const STORAGE_PROTOCOL_SPECIFIC_DATA = struct__STORAGE_PROTOCOL_SPECIFIC_DATA;
pub const PSTORAGE_PROTOCOL_SPECIFIC_DATA = [*c]struct__STORAGE_PROTOCOL_SPECIFIC_DATA;
pub const struct__STORAGE_PROTOCOL_SPECIFIC_DATA_EXT = extern struct {
    ProtocolType: STORAGE_PROTOCOL_TYPE,
    DataType: DWORD,
    ProtocolDataValue: DWORD,
    ProtocolDataSubValue: DWORD,
    ProtocolDataOffset: DWORD,
    ProtocolDataLength: DWORD,
    FixedProtocolReturnData: DWORD,
    ProtocolDataSubValue2: DWORD,
    ProtocolDataSubValue3: DWORD,
    ProtocolDataSubValue4: DWORD,
    ProtocolDataSubValue5: DWORD,
    Reserved: [5]DWORD,
};
pub const STORAGE_PROTOCOL_SPECIFIC_DATA_EXT = struct__STORAGE_PROTOCOL_SPECIFIC_DATA_EXT;
pub const PSTORAGE_PROTOCOL_SPECIFIC_DATA_EXT = [*c]struct__STORAGE_PROTOCOL_SPECIFIC_DATA_EXT;
pub const struct__STORAGE_PROTOCOL_DATA_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    ProtocolSpecificData: STORAGE_PROTOCOL_SPECIFIC_DATA,
};
pub const STORAGE_PROTOCOL_DATA_DESCRIPTOR = struct__STORAGE_PROTOCOL_DATA_DESCRIPTOR;
pub const PSTORAGE_PROTOCOL_DATA_DESCRIPTOR = [*c]struct__STORAGE_PROTOCOL_DATA_DESCRIPTOR;
pub const struct__STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT = extern struct {
    Version: DWORD,
    Size: DWORD,
    ProtocolSpecificData: STORAGE_PROTOCOL_SPECIFIC_DATA_EXT,
};
pub const STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT = struct__STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT;
pub const PSTORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT = [*c]struct__STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT;
pub const struct__STORAGE_TEMPERATURE_INFO = extern struct {
    Index: WORD,
    Temperature: SHORT,
    OverThreshold: SHORT,
    UnderThreshold: SHORT,
    OverThresholdChangable: BOOLEAN,
    UnderThresholdChangable: BOOLEAN,
    EventGenerated: BOOLEAN,
    Reserved0: BYTE,
    Reserved1: DWORD,
};
pub const STORAGE_TEMPERATURE_INFO = struct__STORAGE_TEMPERATURE_INFO;
pub const PSTORAGE_TEMPERATURE_INFO = [*c]struct__STORAGE_TEMPERATURE_INFO;
pub const struct__STORAGE_TEMPERATURE_DATA_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    CriticalTemperature: SHORT,
    WarningTemperature: SHORT,
    InfoCount: WORD,
    Reserved0: [2]BYTE,
    Reserved1: [2]DWORD,
    TemperatureInfo: [1]STORAGE_TEMPERATURE_INFO,
};
pub const STORAGE_TEMPERATURE_DATA_DESCRIPTOR = struct__STORAGE_TEMPERATURE_DATA_DESCRIPTOR;
pub const PSTORAGE_TEMPERATURE_DATA_DESCRIPTOR = [*c]struct__STORAGE_TEMPERATURE_DATA_DESCRIPTOR;
pub const struct__STORAGE_TEMPERATURE_THRESHOLD = extern struct {
    Version: DWORD,
    Size: DWORD,
    Flags: WORD,
    Index: WORD,
    Threshold: SHORT,
    OverThreshold: BOOLEAN,
    Reserved: BYTE,
};
pub const STORAGE_TEMPERATURE_THRESHOLD = struct__STORAGE_TEMPERATURE_THRESHOLD;
pub const PSTORAGE_TEMPERATURE_THRESHOLD = [*c]struct__STORAGE_TEMPERATURE_THRESHOLD;
pub const FormFactorUnknown = enum__STORAGE_DEVICE_FORM_FACTOR.FormFactorUnknown;
pub const FormFactor3_5 = enum__STORAGE_DEVICE_FORM_FACTOR.FormFactor3_5;
pub const FormFactor2_5 = enum__STORAGE_DEVICE_FORM_FACTOR.FormFactor2_5;
pub const FormFactor1_8 = enum__STORAGE_DEVICE_FORM_FACTOR.FormFactor1_8;
pub const FormFactor1_8Less = enum__STORAGE_DEVICE_FORM_FACTOR.FormFactor1_8Less;
pub const FormFactorEmbedded = enum__STORAGE_DEVICE_FORM_FACTOR.FormFactorEmbedded;
pub const FormFactorMemoryCard = enum__STORAGE_DEVICE_FORM_FACTOR.FormFactorMemoryCard;
pub const FormFactormSata = enum__STORAGE_DEVICE_FORM_FACTOR.FormFactormSata;
pub const FormFactorM_2 = enum__STORAGE_DEVICE_FORM_FACTOR.FormFactorM_2;
pub const FormFactorPCIeBoard = enum__STORAGE_DEVICE_FORM_FACTOR.FormFactorPCIeBoard;
pub const FormFactorDimm = enum__STORAGE_DEVICE_FORM_FACTOR.FormFactorDimm;
pub const enum__STORAGE_DEVICE_FORM_FACTOR = extern enum {
    FormFactorUnknown = 0,
    FormFactor3_5 = 1,
    FormFactor2_5 = 2,
    FormFactor1_8 = 3,
    FormFactor1_8Less = 4,
    FormFactorEmbedded = 5,
    FormFactorMemoryCard = 6,
    FormFactormSata = 7,
    FormFactorM_2 = 8,
    FormFactorPCIeBoard = 9,
    FormFactorDimm = 10,
};
pub const STORAGE_DEVICE_FORM_FACTOR = enum__STORAGE_DEVICE_FORM_FACTOR;
pub const PSTORAGE_DEVICE_FORM_FACTOR = [*c]enum__STORAGE_DEVICE_FORM_FACTOR;
pub const HealthStatusUnknown = enum__STORAGE_COMPONENT_HEALTH_STATUS.HealthStatusUnknown;
pub const HealthStatusNormal = enum__STORAGE_COMPONENT_HEALTH_STATUS.HealthStatusNormal;
pub const HealthStatusThrottled = enum__STORAGE_COMPONENT_HEALTH_STATUS.HealthStatusThrottled;
pub const HealthStatusWarning = enum__STORAGE_COMPONENT_HEALTH_STATUS.HealthStatusWarning;
pub const HealthStatusDisabled = enum__STORAGE_COMPONENT_HEALTH_STATUS.HealthStatusDisabled;
pub const HealthStatusFailed = enum__STORAGE_COMPONENT_HEALTH_STATUS.HealthStatusFailed;
pub const enum__STORAGE_COMPONENT_HEALTH_STATUS = extern enum {
    HealthStatusUnknown = 0,
    HealthStatusNormal = 1,
    HealthStatusThrottled = 2,
    HealthStatusWarning = 3,
    HealthStatusDisabled = 4,
    HealthStatusFailed = 5,
};
pub const STORAGE_COMPONENT_HEALTH_STATUS = enum__STORAGE_COMPONENT_HEALTH_STATUS;
pub const PSTORAGE_COMPONENT_HEALTH_STATUS = [*c]enum__STORAGE_COMPONENT_HEALTH_STATUS;
pub const union__STORAGE_SPEC_VERSION = extern union {
    @"": extern struct {
        MinorVersion: extern union {
            @"": extern struct {
                SubMinor: BYTE,
                Minor: BYTE,
            },
            AsUshort: WORD,
        },
        MajorVersion: WORD,
    },
    AsUlong: DWORD,
};
pub const STORAGE_SPEC_VERSION = union__STORAGE_SPEC_VERSION;
pub const PSTORAGE_SPEC_VERSION = [*c]union__STORAGE_SPEC_VERSION;
pub const struct__STORAGE_PHYSICAL_DEVICE_DATA = extern struct {
    DeviceId: DWORD,
    Role: DWORD,
    HealthStatus: STORAGE_COMPONENT_HEALTH_STATUS,
    CommandProtocol: STORAGE_PROTOCOL_TYPE,
    SpecVersion: STORAGE_SPEC_VERSION,
    FormFactor: STORAGE_DEVICE_FORM_FACTOR,
    Vendor: [8]BYTE,
    Model: [40]BYTE,
    FirmwareRevision: [16]BYTE,
    Capacity: DWORDLONG,
    PhysicalLocation: [32]BYTE,
    Reserved: [2]DWORD,
};
pub const STORAGE_PHYSICAL_DEVICE_DATA = struct__STORAGE_PHYSICAL_DEVICE_DATA;
pub const PSTORAGE_PHYSICAL_DEVICE_DATA = [*c]struct__STORAGE_PHYSICAL_DEVICE_DATA;
pub const struct__STORAGE_PHYSICAL_ADAPTER_DATA = extern struct {
    AdapterId: DWORD,
    HealthStatus: STORAGE_COMPONENT_HEALTH_STATUS,
    CommandProtocol: STORAGE_PROTOCOL_TYPE,
    SpecVersion: STORAGE_SPEC_VERSION,
    Vendor: [8]BYTE,
    Model: [40]BYTE,
    FirmwareRevision: [16]BYTE,
    PhysicalLocation: [32]BYTE,
    ExpanderConnected: BOOLEAN,
    Reserved0: [3]BYTE,
    Reserved1: [3]DWORD,
};
pub const STORAGE_PHYSICAL_ADAPTER_DATA = struct__STORAGE_PHYSICAL_ADAPTER_DATA;
pub const PSTORAGE_PHYSICAL_ADAPTER_DATA = [*c]struct__STORAGE_PHYSICAL_ADAPTER_DATA;
pub const struct__STORAGE_PHYSICAL_NODE_DATA = extern struct {
    NodeId: DWORD,
    AdapterCount: DWORD,
    AdapterDataLength: DWORD,
    AdapterDataOffset: DWORD,
    DeviceCount: DWORD,
    DeviceDataLength: DWORD,
    DeviceDataOffset: DWORD,
    Reserved: [3]DWORD,
};
pub const STORAGE_PHYSICAL_NODE_DATA = struct__STORAGE_PHYSICAL_NODE_DATA;
pub const PSTORAGE_PHYSICAL_NODE_DATA = [*c]struct__STORAGE_PHYSICAL_NODE_DATA;
pub const struct__STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    NodeCount: DWORD,
    Reserved: DWORD,
    Node: [1]STORAGE_PHYSICAL_NODE_DATA,
};
pub const STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR = struct__STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR;
pub const PSTORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR = [*c]struct__STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR;
pub const struct__STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    LunMaxIoCount: DWORD,
    AdapterMaxIoCount: DWORD,
};
pub const STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR = struct__STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR;
pub const PSTORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR = [*c]struct__STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR;
pub const struct__STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    Attributes: DWORD64,
};
pub const STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR = struct__STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR;
pub const PSTORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR = [*c]struct__STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR;
pub const DiskHealthUnknown = enum__STORAGE_DISK_HEALTH_STATUS.DiskHealthUnknown;
pub const DiskHealthUnhealthy = enum__STORAGE_DISK_HEALTH_STATUS.DiskHealthUnhealthy;
pub const DiskHealthWarning = enum__STORAGE_DISK_HEALTH_STATUS.DiskHealthWarning;
pub const DiskHealthHealthy = enum__STORAGE_DISK_HEALTH_STATUS.DiskHealthHealthy;
pub const DiskHealthMax = enum__STORAGE_DISK_HEALTH_STATUS.DiskHealthMax;
pub const enum__STORAGE_DISK_HEALTH_STATUS = extern enum {
    DiskHealthUnknown = 0,
    DiskHealthUnhealthy = 1,
    DiskHealthWarning = 2,
    DiskHealthHealthy = 3,
    DiskHealthMax = 4,
};
pub const STORAGE_DISK_HEALTH_STATUS = enum__STORAGE_DISK_HEALTH_STATUS;
pub const PSTORAGE_DISK_HEALTH_STATUS = [*c]enum__STORAGE_DISK_HEALTH_STATUS;
pub const DiskOpStatusNone = enum__STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusNone;
pub const DiskOpStatusUnknown = enum__STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusUnknown;
pub const DiskOpStatusOk = enum__STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusOk;
pub const DiskOpStatusPredictingFailure = enum__STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusPredictingFailure;
pub const DiskOpStatusInService = enum__STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusInService;
pub const DiskOpStatusHardwareError = enum__STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusHardwareError;
pub const DiskOpStatusNotUsable = enum__STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusNotUsable;
pub const DiskOpStatusTransientError = enum__STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusTransientError;
pub const DiskOpStatusMissing = enum__STORAGE_DISK_OPERATIONAL_STATUS.DiskOpStatusMissing;
pub const enum__STORAGE_DISK_OPERATIONAL_STATUS = extern enum {
    DiskOpStatusNone = 0,
    DiskOpStatusUnknown = 1,
    DiskOpStatusOk = 2,
    DiskOpStatusPredictingFailure = 3,
    DiskOpStatusInService = 4,
    DiskOpStatusHardwareError = 5,
    DiskOpStatusNotUsable = 6,
    DiskOpStatusTransientError = 7,
    DiskOpStatusMissing = 8,
};
pub const STORAGE_DISK_OPERATIONAL_STATUS = enum__STORAGE_DISK_OPERATIONAL_STATUS;
pub const PSTORAGE_DISK_OPERATIONAL_STATUS = [*c]enum__STORAGE_DISK_OPERATIONAL_STATUS;
pub const DiskOpReasonUnknown = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonUnknown;
pub const DiskOpReasonScsiSenseCode = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonScsiSenseCode;
pub const DiskOpReasonMedia = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonMedia;
pub const DiskOpReasonIo = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonIo;
pub const DiskOpReasonThresholdExceeded = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonThresholdExceeded;
pub const DiskOpReasonLostData = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonLostData;
pub const DiskOpReasonEnergySource = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonEnergySource;
pub const DiskOpReasonConfiguration = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonConfiguration;
pub const DiskOpReasonDeviceController = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonDeviceController;
pub const DiskOpReasonMediaController = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonMediaController;
pub const DiskOpReasonComponent = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonComponent;
pub const DiskOpReasonNVDIMM_N = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonNVDIMM_N;
pub const DiskOpReasonBackgroundOperation = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonBackgroundOperation;
pub const DiskOpReasonInvalidFirmware = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonInvalidFirmware;
pub const DiskOpReasonHealthCheck = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonHealthCheck;
pub const DiskOpReasonLostDataPersistence = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonLostDataPersistence;
pub const DiskOpReasonDisabledByPlatform = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonDisabledByPlatform;
pub const DiskOpReasonLostWritePersistence = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonLostWritePersistence;
pub const DiskOpReasonDataPersistenceLossImminent = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonDataPersistenceLossImminent;
pub const DiskOpReasonWritePersistenceLossImminent = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonWritePersistenceLossImminent;
pub const DiskOpReasonMax = enum__STORAGE_OPERATIONAL_STATUS_REASON.DiskOpReasonMax;
pub const enum__STORAGE_OPERATIONAL_STATUS_REASON = extern enum {
    DiskOpReasonUnknown = 0,
    DiskOpReasonScsiSenseCode = 1,
    DiskOpReasonMedia = 2,
    DiskOpReasonIo = 3,
    DiskOpReasonThresholdExceeded = 4,
    DiskOpReasonLostData = 5,
    DiskOpReasonEnergySource = 6,
    DiskOpReasonConfiguration = 7,
    DiskOpReasonDeviceController = 8,
    DiskOpReasonMediaController = 9,
    DiskOpReasonComponent = 10,
    DiskOpReasonNVDIMM_N = 11,
    DiskOpReasonBackgroundOperation = 12,
    DiskOpReasonInvalidFirmware = 13,
    DiskOpReasonHealthCheck = 14,
    DiskOpReasonLostDataPersistence = 15,
    DiskOpReasonDisabledByPlatform = 16,
    DiskOpReasonLostWritePersistence = 17,
    DiskOpReasonDataPersistenceLossImminent = 18,
    DiskOpReasonWritePersistenceLossImminent = 19,
    DiskOpReasonMax = 20,
};
pub const STORAGE_OPERATIONAL_STATUS_REASON = enum__STORAGE_OPERATIONAL_STATUS_REASON;
pub const PSTORAGE_OPERATIONAL_STATUS_REASON = [*c]enum__STORAGE_OPERATIONAL_STATUS_REASON;
pub const struct__STORAGE_OPERATIONAL_REASON = extern struct {
    Version: DWORD,
    Size: DWORD,
    Reason: STORAGE_OPERATIONAL_STATUS_REASON,
    RawBytes: extern union {
        ScsiSenseKey: extern struct {
            SenseKey: BYTE,
            ASC: BYTE,
            ASCQ: BYTE,
            Reserved: BYTE,
        },
        NVDIMM_N: extern struct {
            CriticalHealth: BYTE,
            ModuleHealth: [2]BYTE,
            ErrorThresholdStatus: BYTE,
        },
        AsUlong: DWORD,
    },
};
pub const STORAGE_OPERATIONAL_REASON = struct__STORAGE_OPERATIONAL_REASON;
pub const PSTORAGE_OPERATIONAL_REASON = [*c]struct__STORAGE_OPERATIONAL_REASON;
pub const struct__STORAGE_DEVICE_MANAGEMENT_STATUS = extern struct {
    Version: DWORD,
    Size: DWORD,
    Health: STORAGE_DISK_HEALTH_STATUS,
    NumberOfOperationalStatus: DWORD,
    NumberOfAdditionalReasons: DWORD,
    OperationalStatus: [16]STORAGE_DISK_OPERATIONAL_STATUS,
    AdditionalReasons: [1]STORAGE_OPERATIONAL_REASON,
};
pub const STORAGE_DEVICE_MANAGEMENT_STATUS = struct__STORAGE_DEVICE_MANAGEMENT_STATUS;
pub const PSTORAGE_DEVICE_MANAGEMENT_STATUS = [*c]struct__STORAGE_DEVICE_MANAGEMENT_STATUS;
pub const struct__STORAGE_ADAPTER_SERIAL_NUMBER = extern struct {
    Version: DWORD,
    Size: DWORD,
    SerialNumber: [128]WCHAR,
};
pub const STORAGE_ADAPTER_SERIAL_NUMBER = struct__STORAGE_ADAPTER_SERIAL_NUMBER;
pub const PSTORAGE_ADAPTER_SERIAL_NUMBER = [*c]struct__STORAGE_ADAPTER_SERIAL_NUMBER;
pub const ZonedDeviceTypeUnknown = enum__STORAGE_ZONED_DEVICE_TYPES.ZonedDeviceTypeUnknown;
pub const ZonedDeviceTypeHostManaged = enum__STORAGE_ZONED_DEVICE_TYPES.ZonedDeviceTypeHostManaged;
pub const ZonedDeviceTypeHostAware = enum__STORAGE_ZONED_DEVICE_TYPES.ZonedDeviceTypeHostAware;
pub const ZonedDeviceTypeDeviceManaged = enum__STORAGE_ZONED_DEVICE_TYPES.ZonedDeviceTypeDeviceManaged;
pub const enum__STORAGE_ZONED_DEVICE_TYPES = extern enum {
    ZonedDeviceTypeUnknown = 0,
    ZonedDeviceTypeHostManaged = 1,
    ZonedDeviceTypeHostAware = 2,
    ZonedDeviceTypeDeviceManaged = 3,
};
pub const STORAGE_ZONED_DEVICE_TYPES = enum__STORAGE_ZONED_DEVICE_TYPES;
pub const PSTORAGE_ZONED_DEVICE_TYPES = [*c]enum__STORAGE_ZONED_DEVICE_TYPES;
pub const ZoneTypeUnknown = enum__STORAGE_ZONE_TYPES.ZoneTypeUnknown;
pub const ZoneTypeConventional = enum__STORAGE_ZONE_TYPES.ZoneTypeConventional;
pub const ZoneTypeSequentialWriteRequired = enum__STORAGE_ZONE_TYPES.ZoneTypeSequentialWriteRequired;
pub const ZoneTypeSequentialWritePreferred = enum__STORAGE_ZONE_TYPES.ZoneTypeSequentialWritePreferred;
pub const ZoneTypeMax = enum__STORAGE_ZONE_TYPES.ZoneTypeMax;
pub const enum__STORAGE_ZONE_TYPES = extern enum {
    ZoneTypeUnknown = 0,
    ZoneTypeConventional = 1,
    ZoneTypeSequentialWriteRequired = 2,
    ZoneTypeSequentialWritePreferred = 3,
    ZoneTypeMax = 4,
};
pub const STORAGE_ZONE_TYPES = enum__STORAGE_ZONE_TYPES;
pub const PSTORAGE_ZONE_TYPES = [*c]enum__STORAGE_ZONE_TYPES;
pub const struct__STORAGE_ZONE_GROUP = extern struct {
    ZoneCount: DWORD,
    ZoneType: STORAGE_ZONE_TYPES,
    ZoneSize: DWORDLONG,
};
pub const STORAGE_ZONE_GROUP = struct__STORAGE_ZONE_GROUP;
pub const PSTORAGE_ZONE_GROUP = [*c]struct__STORAGE_ZONE_GROUP;
pub const struct__STORAGE_ZONED_DEVICE_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    DeviceType: STORAGE_ZONED_DEVICE_TYPES,
    ZoneCount: DWORD,
    ZoneAttributes: extern union {
        SequentialRequiredZone: extern struct {
            MaxOpenZoneCount: DWORD,
            UnrestrictedRead: BOOLEAN,
            Reserved: [3]BYTE,
        },
        SequentialPreferredZone: extern struct {
            OptimalOpenZoneCount: DWORD,
            Reserved: DWORD,
        },
    },
    ZoneGroupCount: DWORD,
    ZoneGroup: [1]STORAGE_ZONE_GROUP,
};
pub const STORAGE_ZONED_DEVICE_DESCRIPTOR = struct__STORAGE_ZONED_DEVICE_DESCRIPTOR;
pub const PSTORAGE_ZONED_DEVICE_DESCRIPTOR = [*c]struct__STORAGE_ZONED_DEVICE_DESCRIPTOR;
pub const struct__DEVICE_LOCATION = extern struct {
    Socket: DWORD,
    Slot: DWORD,
    Adapter: DWORD,
    Port: DWORD,
    @"": extern union {
        @"": extern struct {
            Channel: DWORD,
            Device: DWORD,
        },
        @"": extern struct {
            Target: DWORD,
            Lun: DWORD,
        },
    },
};
pub const DEVICE_LOCATION = struct__DEVICE_LOCATION;
pub const PDEVICE_LOCATION = [*c]struct__DEVICE_LOCATION;
pub const struct__STORAGE_DEVICE_LOCATION_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    Location: DEVICE_LOCATION,
    StringOffset: DWORD,
};
pub const STORAGE_DEVICE_LOCATION_DESCRIPTOR = struct__STORAGE_DEVICE_LOCATION_DESCRIPTOR;
pub const PSTORAGE_DEVICE_LOCATION_DESCRIPTOR = [*c]struct__STORAGE_DEVICE_LOCATION_DESCRIPTOR;
pub const struct__STORAGE_DEVICE_NUMA_PROPERTY = extern struct {
    Version: DWORD,
    Size: DWORD,
    NumaNode: DWORD,
};
pub const STORAGE_DEVICE_NUMA_PROPERTY = struct__STORAGE_DEVICE_NUMA_PROPERTY;
pub const PSTORAGE_DEVICE_NUMA_PROPERTY = [*c]struct__STORAGE_DEVICE_NUMA_PROPERTY;
pub const struct__STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT = extern struct {
    Version: DWORD,
    Size: DWORD,
    UnsafeShutdownCount: DWORD,
};
pub const STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT = struct__STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT;
pub const PSTORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT = [*c]struct__STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT;
pub const struct__STORAGE_HW_ENDURANCE_INFO = extern struct {
    ValidFields: DWORD,
    GroupId: DWORD,
    Flags: @OpaqueType(),
    LifePercentage: DWORD,
    BytesReadCount: [16]BYTE,
    ByteWriteCount: [16]BYTE,
};
pub const STORAGE_HW_ENDURANCE_INFO = struct__STORAGE_HW_ENDURANCE_INFO;
pub const PSTORAGE_HW_ENDURANCE_INFO = [*c]struct__STORAGE_HW_ENDURANCE_INFO;
pub const struct__STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    EnduranceInfo: STORAGE_HW_ENDURANCE_INFO,
};
pub const STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR = struct__STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR;
pub const PSTORAGE_HW_ENDURANCE_DATA_DESCRIPTOR = [*c]struct__STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR;
pub const DEVICE_DATA_MANAGEMENT_SET_ACTION = DWORD;
pub const DEVICE_DSM_ACTION = DWORD;
pub const struct__DEVICE_DATA_SET_RANGE = extern struct {
    StartingOffset: LONGLONG,
    LengthInBytes: DWORDLONG,
};
pub const DEVICE_DATA_SET_RANGE = struct__DEVICE_DATA_SET_RANGE;
pub const PDEVICE_DATA_SET_RANGE = [*c]struct__DEVICE_DATA_SET_RANGE;
pub const DEVICE_DSM_RANGE = struct__DEVICE_DATA_SET_RANGE;
pub const PDEVICE_DSM_RANGE = [*c]struct__DEVICE_DATA_SET_RANGE;
pub const struct__DEVICE_MANAGE_DATA_SET_ATTRIBUTES = extern struct {
    Size: DWORD,
    Action: DEVICE_DSM_ACTION,
    Flags: DWORD,
    ParameterBlockOffset: DWORD,
    ParameterBlockLength: DWORD,
    DataSetRangesOffset: DWORD,
    DataSetRangesLength: DWORD,
};
pub const DEVICE_MANAGE_DATA_SET_ATTRIBUTES = struct__DEVICE_MANAGE_DATA_SET_ATTRIBUTES;
pub const PDEVICE_MANAGE_DATA_SET_ATTRIBUTES = [*c]struct__DEVICE_MANAGE_DATA_SET_ATTRIBUTES;
pub const DEVICE_DSM_INPUT = struct__DEVICE_MANAGE_DATA_SET_ATTRIBUTES;
pub const PDEVICE_DSM_INPUT = [*c]struct__DEVICE_MANAGE_DATA_SET_ATTRIBUTES;
pub const struct__DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT = extern struct {
    Size: DWORD,
    Action: DEVICE_DSM_ACTION,
    Flags: DWORD,
    OperationStatus: DWORD,
    ExtendedError: DWORD,
    TargetDetailedError: DWORD,
    ReservedStatus: DWORD,
    OutputBlockOffset: DWORD,
    OutputBlockLength: DWORD,
};
pub const DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT = struct__DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT;
pub const PDEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT = [*c]struct__DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT;
pub const DEVICE_DSM_OUTPUT = struct__DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT;
pub const PDEVICE_DSM_OUTPUT = [*c]struct__DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT;
pub const struct__DEVICE_DSM_DEFINITION = extern struct {
    Action: DEVICE_DSM_ACTION,
    SingleRange: BOOLEAN,
    ParameterBlockAlignment: DWORD,
    ParameterBlockLength: DWORD,
    HasOutput: BOOLEAN,
    OutputBlockAlignment: DWORD,
    OutputBlockLength: DWORD,
};
pub const DEVICE_DSM_DEFINITION = struct__DEVICE_DSM_DEFINITION;
pub const PDEVICE_DSM_DEFINITION = [*c]struct__DEVICE_DSM_DEFINITION;
pub const struct__DEVICE_DSM_NOTIFICATION_PARAMETERS = extern struct {
    Size: DWORD,
    Flags: DWORD,
    NumFileTypeIDs: DWORD,
    FileTypeID: [1]GUID,
};
pub const DEVICE_DSM_NOTIFICATION_PARAMETERS = struct__DEVICE_DSM_NOTIFICATION_PARAMETERS;
pub const PDEVICE_DSM_NOTIFICATION_PARAMETERS = [*c]struct__DEVICE_DSM_NOTIFICATION_PARAMETERS;
pub const struct__STORAGE_OFFLOAD_TOKEN = extern struct {
    TokenType: [4]BYTE,
    Reserved: [2]BYTE,
    TokenIdLength: [2]BYTE,
    @"": extern union {
        StorageOffloadZeroDataToken: extern struct {
            Reserved2: [504]BYTE,
        },
        Token: [504]BYTE,
    },
};
pub const STORAGE_OFFLOAD_TOKEN = struct__STORAGE_OFFLOAD_TOKEN;
pub const PSTORAGE_OFFLOAD_TOKEN = [*c]struct__STORAGE_OFFLOAD_TOKEN;
pub const struct__DEVICE_DSM_OFFLOAD_READ_PARAMETERS = extern struct {
    Flags: DWORD,
    TimeToLive: DWORD,
    Reserved: [2]DWORD,
};
pub const DEVICE_DSM_OFFLOAD_READ_PARAMETERS = struct__DEVICE_DSM_OFFLOAD_READ_PARAMETERS;
pub const PDEVICE_DSM_OFFLOAD_READ_PARAMETERS = [*c]struct__DEVICE_DSM_OFFLOAD_READ_PARAMETERS;
pub const struct__STORAGE_OFFLOAD_READ_OUTPUT = extern struct {
    OffloadReadFlags: DWORD,
    Reserved: DWORD,
    LengthProtected: DWORDLONG,
    TokenLength: DWORD,
    Token: STORAGE_OFFLOAD_TOKEN,
};
pub const STORAGE_OFFLOAD_READ_OUTPUT = struct__STORAGE_OFFLOAD_READ_OUTPUT;
pub const PSTORAGE_OFFLOAD_READ_OUTPUT = [*c]struct__STORAGE_OFFLOAD_READ_OUTPUT;
pub const struct__DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS = extern struct {
    Flags: DWORD,
    Reserved: DWORD,
    TokenOffset: DWORDLONG,
    Token: STORAGE_OFFLOAD_TOKEN,
};
pub const DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS = struct__DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS;
pub const PDEVICE_DSM_OFFLOAD_WRITE_PARAMETERS = [*c]struct__DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS;
pub const struct__STORAGE_OFFLOAD_WRITE_OUTPUT = extern struct {
    OffloadWriteFlags: DWORD,
    Reserved: DWORD,
    LengthCopied: DWORDLONG,
};
pub const STORAGE_OFFLOAD_WRITE_OUTPUT = struct__STORAGE_OFFLOAD_WRITE_OUTPUT;
pub const PSTORAGE_OFFLOAD_WRITE_OUTPUT = [*c]struct__STORAGE_OFFLOAD_WRITE_OUTPUT;
pub const struct__DEVICE_DATA_SET_LBP_STATE_PARAMETERS = extern struct {
    Version: DWORD,
    Size: DWORD,
    Flags: DWORD,
    OutputVersion: DWORD,
};
pub const DEVICE_DATA_SET_LBP_STATE_PARAMETERS = struct__DEVICE_DATA_SET_LBP_STATE_PARAMETERS;
pub const PDEVICE_DATA_SET_LBP_STATE_PARAMETERS = [*c]struct__DEVICE_DATA_SET_LBP_STATE_PARAMETERS;
pub const DEVICE_DSM_ALLOCATION_PARAMETERS = struct__DEVICE_DATA_SET_LBP_STATE_PARAMETERS;
pub const PDEVICE_DSM_ALLOCATION_PARAMETERS = [*c]struct__DEVICE_DATA_SET_LBP_STATE_PARAMETERS;
pub const struct__DEVICE_DATA_SET_LB_PROVISIONING_STATE = extern struct {
    Size: DWORD,
    Version: DWORD,
    SlabSizeInBytes: DWORDLONG,
    SlabOffsetDeltaInBytes: DWORD,
    SlabAllocationBitMapBitCount: DWORD,
    SlabAllocationBitMapLength: DWORD,
    SlabAllocationBitMap: [1]DWORD,
};
pub const DEVICE_DATA_SET_LB_PROVISIONING_STATE = struct__DEVICE_DATA_SET_LB_PROVISIONING_STATE;
pub const PDEVICE_DATA_SET_LB_PROVISIONING_STATE = [*c]struct__DEVICE_DATA_SET_LB_PROVISIONING_STATE;
pub const DEVICE_DSM_ALLOCATION_OUTPUT = struct__DEVICE_DATA_SET_LB_PROVISIONING_STATE;
pub const PDEVICE_DSM_ALLOCATION_OUTPUT = [*c]struct__DEVICE_DATA_SET_LB_PROVISIONING_STATE;
pub const struct__DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 = extern struct {
    Size: DWORD,
    Version: DWORD,
    SlabSizeInBytes: DWORDLONG,
    SlabOffsetDeltaInBytes: DWORDLONG,
    SlabAllocationBitMapBitCount: DWORD,
    SlabAllocationBitMapLength: DWORD,
    SlabAllocationBitMap: [1]DWORD,
};
pub const DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 = struct__DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2;
pub const PDEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 = [*c]struct__DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2;
pub const DEVICE_DSM_ALLOCATION_OUTPUT2 = struct__DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2;
pub const PDEVICE_DSM_ALLOCATION_OUTPUT2 = [*c]struct__DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2;
pub const struct__DEVICE_DATA_SET_REPAIR_PARAMETERS = extern struct {
    NumberOfRepairCopies: DWORD,
    SourceCopy: DWORD,
    RepairCopies: [1]DWORD,
};
pub const DEVICE_DATA_SET_REPAIR_PARAMETERS = struct__DEVICE_DATA_SET_REPAIR_PARAMETERS;
pub const PDEVICE_DATA_SET_REPAIR_PARAMETERS = [*c]struct__DEVICE_DATA_SET_REPAIR_PARAMETERS;
pub const DEVICE_DSM_REPAIR_PARAMETERS = struct__DEVICE_DATA_SET_REPAIR_PARAMETERS;
pub const PDEVICE_DSM_REPAIR_PARAMETERS = [*c]struct__DEVICE_DATA_SET_REPAIR_PARAMETERS;
pub const struct__DEVICE_DATA_SET_REPAIR_OUTPUT = extern struct {
    ParityExtent: DEVICE_DSM_RANGE,
};
pub const DEVICE_DATA_SET_REPAIR_OUTPUT = struct__DEVICE_DATA_SET_REPAIR_OUTPUT;
pub const PDEVICE_DATA_SET_REPAIR_OUTPUT = [*c]struct__DEVICE_DATA_SET_REPAIR_OUTPUT;
pub const DEVICE_DSM_REPAIR_OUTPUT = struct__DEVICE_DATA_SET_REPAIR_OUTPUT;
pub const PDEVICE_DSM_REPAIR_OUTPUT = [*c]struct__DEVICE_DATA_SET_REPAIR_OUTPUT;
pub const struct__DEVICE_DATA_SET_SCRUB_OUTPUT = extern struct {
    BytesProcessed: DWORDLONG,
    BytesRepaired: DWORDLONG,
    BytesFailed: DWORDLONG,
};
pub const DEVICE_DATA_SET_SCRUB_OUTPUT = struct__DEVICE_DATA_SET_SCRUB_OUTPUT;
pub const PDEVICE_DATA_SET_SCRUB_OUTPUT = [*c]struct__DEVICE_DATA_SET_SCRUB_OUTPUT;
pub const DEVICE_DSM_SCRUB_OUTPUT = struct__DEVICE_DATA_SET_SCRUB_OUTPUT;
pub const PDEVICE_DSM_SCRUB_OUTPUT = [*c]struct__DEVICE_DATA_SET_SCRUB_OUTPUT;
pub const struct__DEVICE_DATA_SET_SCRUB_EX_OUTPUT = extern struct {
    BytesProcessed: DWORDLONG,
    BytesRepaired: DWORDLONG,
    BytesFailed: DWORDLONG,
    ParityExtent: DEVICE_DSM_RANGE,
};
pub const DEVICE_DATA_SET_SCRUB_EX_OUTPUT = struct__DEVICE_DATA_SET_SCRUB_EX_OUTPUT;
pub const PDEVICE_DATA_SET_SCRUB_EX_OUTPUT = [*c]struct__DEVICE_DATA_SET_SCRUB_EX_OUTPUT;
pub const DEVICE_DSM_SCRUB_OUTPUT2 = struct__DEVICE_DATA_SET_SCRUB_EX_OUTPUT;
pub const PDEVICE_DSM_SCRUB_OUTPUT2 = [*c]struct__DEVICE_DATA_SET_SCRUB_EX_OUTPUT;
pub const struct__DEVICE_DSM_TIERING_QUERY_INPUT = extern struct {
    Version: DWORD,
    Size: DWORD,
    Flags: DWORD,
    NumberOfTierIds: DWORD,
    TierIds: [1]GUID,
};
pub const DEVICE_DSM_TIERING_QUERY_INPUT = struct__DEVICE_DSM_TIERING_QUERY_INPUT;
pub const PDEVICE_DSM_TIERING_QUERY_INPUT = [*c]struct__DEVICE_DSM_TIERING_QUERY_INPUT;
pub const DEVICE_DSM_TIERING_QUERY_PARAMETERS = struct__DEVICE_DSM_TIERING_QUERY_INPUT;
pub const PDEVICE_DSM_TIERING_QUERY_PARAMETERS = [*c]struct__DEVICE_DSM_TIERING_QUERY_INPUT;
pub const struct__STORAGE_TIER_REGION = extern struct {
    TierId: GUID,
    Offset: DWORDLONG,
    Length: DWORDLONG,
};
pub const STORAGE_TIER_REGION = struct__STORAGE_TIER_REGION;
pub const PSTORAGE_TIER_REGION = [*c]struct__STORAGE_TIER_REGION;
pub const struct__DEVICE_DSM_TIERING_QUERY_OUTPUT = extern struct {
    Version: DWORD,
    Size: DWORD,
    Flags: DWORD,
    Reserved: DWORD,
    Alignment: DWORDLONG,
    TotalNumberOfRegions: DWORD,
    NumberOfRegionsReturned: DWORD,
    Regions: [1]STORAGE_TIER_REGION,
};
pub const DEVICE_DSM_TIERING_QUERY_OUTPUT = struct__DEVICE_DSM_TIERING_QUERY_OUTPUT;
pub const PDEVICE_DSM_TIERING_QUERY_OUTPUT = [*c]struct__DEVICE_DSM_TIERING_QUERY_OUTPUT;
pub const struct__DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS = extern struct {
    Size: DWORD,
    TargetPriority: BYTE,
    Reserved: [3]BYTE,
};
pub const DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS = struct__DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS;
pub const PDEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS = [*c]struct__DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS;
pub const struct__DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT = extern struct {
    TopologyRangeBytes: DWORDLONG,
    TopologyId: [16]BYTE,
};
pub const DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT = struct__DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT;
pub const PDEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT = [*c]struct__DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT;
pub const DEVICE_DSM_TOPOLOGY_ID_QUERY_OUTPUT = struct__DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT;
pub const PDEVICE_DSM_TOPOLOGY_ID_QUERY_OUTPUT = [*c]struct__DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT;
pub const struct__DEVICE_STORAGE_ADDRESS_RANGE = extern struct {
    StartAddress: LONGLONG,
    LengthInBytes: DWORDLONG,
};
pub const DEVICE_STORAGE_ADDRESS_RANGE = struct__DEVICE_STORAGE_ADDRESS_RANGE;
pub const PDEVICE_STORAGE_ADDRESS_RANGE = [*c]struct__DEVICE_STORAGE_ADDRESS_RANGE;
pub const struct__DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT = extern struct {
    Version: DWORD,
    Flags: DWORD,
    TotalNumberOfRanges: DWORD,
    NumberOfRangesReturned: DWORD,
    Ranges: [1]DEVICE_STORAGE_ADDRESS_RANGE,
};
pub const DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT = struct__DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT;
pub const PDEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT = [*c]struct__DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT;
pub const struct__DEVICE_DSM_REPORT_ZONES_PARAMETERS = extern struct {
    Size: DWORD,
    ReportOption: BYTE,
    Partial: BYTE,
    Reserved: [2]BYTE,
};
pub const DEVICE_DSM_REPORT_ZONES_PARAMETERS = struct__DEVICE_DSM_REPORT_ZONES_PARAMETERS;
pub const PDEVICE_DSM_REPORT_ZONES_PARAMETERS = [*c]struct__DEVICE_DSM_REPORT_ZONES_PARAMETERS;
pub const ZonesAttributeTypeAndLengthMayDifferent = enum__STORAGE_ZONES_ATTRIBUTES.ZonesAttributeTypeAndLengthMayDifferent;
pub const ZonesAttributeTypeSameLengthSame = enum__STORAGE_ZONES_ATTRIBUTES.ZonesAttributeTypeSameLengthSame;
pub const ZonesAttributeTypeSameLastZoneLengthDifferent = enum__STORAGE_ZONES_ATTRIBUTES.ZonesAttributeTypeSameLastZoneLengthDifferent;
pub const ZonesAttributeTypeMayDifferentLengthSame = enum__STORAGE_ZONES_ATTRIBUTES.ZonesAttributeTypeMayDifferentLengthSame;
pub const enum__STORAGE_ZONES_ATTRIBUTES = extern enum {
    ZonesAttributeTypeAndLengthMayDifferent = 0,
    ZonesAttributeTypeSameLengthSame = 1,
    ZonesAttributeTypeSameLastZoneLengthDifferent = 2,
    ZonesAttributeTypeMayDifferentLengthSame = 3,
};
pub const STORAGE_ZONES_ATTRIBUTES = enum__STORAGE_ZONES_ATTRIBUTES;
pub const PSTORAGE_ZONES_ATTRIBUTES = [*c]enum__STORAGE_ZONES_ATTRIBUTES;
pub const ZoneConditionConventional = enum__STORAGE_ZONE_CONDITION.ZoneConditionConventional;
pub const ZoneConditionEmpty = enum__STORAGE_ZONE_CONDITION.ZoneConditionEmpty;
pub const ZoneConditionImplicitlyOpened = enum__STORAGE_ZONE_CONDITION.ZoneConditionImplicitlyOpened;
pub const ZoneConditionExplicitlyOpened = enum__STORAGE_ZONE_CONDITION.ZoneConditionExplicitlyOpened;
pub const ZoneConditionClosed = enum__STORAGE_ZONE_CONDITION.ZoneConditionClosed;
pub const ZoneConditionReadOnly = enum__STORAGE_ZONE_CONDITION.ZoneConditionReadOnly;
pub const ZoneConditionFull = enum__STORAGE_ZONE_CONDITION.ZoneConditionFull;
pub const ZoneConditionOffline = enum__STORAGE_ZONE_CONDITION.ZoneConditionOffline;
pub const enum__STORAGE_ZONE_CONDITION = extern enum {
    ZoneConditionConventional = 0,
    ZoneConditionEmpty = 1,
    ZoneConditionImplicitlyOpened = 2,
    ZoneConditionExplicitlyOpened = 3,
    ZoneConditionClosed = 4,
    ZoneConditionReadOnly = 13,
    ZoneConditionFull = 14,
    ZoneConditionOffline = 15,
};
pub const STORAGE_ZONE_CONDITION = enum__STORAGE_ZONE_CONDITION;
pub const PSTORAGE_ZONE_CONDITION = [*c]enum__STORAGE_ZONE_CONDITION;
pub const struct__STORAGE_ZONE_DESCRIPTOR = extern struct {
    Size: DWORD,
    ZoneType: STORAGE_ZONE_TYPES,
    ZoneCondition: STORAGE_ZONE_CONDITION,
    ResetWritePointerRecommend: BOOLEAN,
    Reserved0: [3]BYTE,
    ZoneSize: DWORDLONG,
    WritePointerOffset: DWORDLONG,
};
pub const STORAGE_ZONE_DESCRIPTOR = struct__STORAGE_ZONE_DESCRIPTOR;
pub const PSTORAGE_ZONE_DESCRIPTOR = [*c]struct__STORAGE_ZONE_DESCRIPTOR;
pub const struct__DEVICE_DSM_REPORT_ZONES_DATA = extern struct {
    Size: DWORD,
    ZoneCount: DWORD,
    Attributes: STORAGE_ZONES_ATTRIBUTES,
    Reserved0: DWORD,
    ZoneDescriptors: [1]STORAGE_ZONE_DESCRIPTOR,
};
pub const DEVICE_DSM_REPORT_ZONES_DATA = struct__DEVICE_DSM_REPORT_ZONES_DATA;
pub const PDEVICE_DSM_REPORT_ZONES_DATA = [*c]struct__DEVICE_DSM_REPORT_ZONES_DATA;
pub const DEVICE_DSM_REPORT_ZONES_OUTPUT = struct__DEVICE_DSM_REPORT_ZONES_DATA;
pub const PDEVICE_DSM_REPORT_ZONES_OUTPUT = [*c]struct__DEVICE_DSM_REPORT_ZONES_DATA;
pub const struct__DEVICE_STORAGE_RANGE_ATTRIBUTES = extern struct {
    LengthInBytes: DWORDLONG,
    @"": extern union {
        AllFlags: DWORD,
        @"": @OpaqueType(),
    },
    Reserved: DWORD,
};
pub const DEVICE_STORAGE_RANGE_ATTRIBUTES = struct__DEVICE_STORAGE_RANGE_ATTRIBUTES;
pub const PDEVICE_STORAGE_RANGE_ATTRIBUTES = [*c]struct__DEVICE_STORAGE_RANGE_ATTRIBUTES;
pub const struct__DEVICE_DSM_RANGE_ERROR_INFO = extern struct {
    Version: DWORD,
    Flags: DWORD,
    TotalNumberOfRanges: DWORD,
    NumberOfRangesReturned: DWORD,
    Ranges: [1]DEVICE_STORAGE_RANGE_ATTRIBUTES,
};
pub const DEVICE_DSM_RANGE_ERROR_INFO = struct__DEVICE_DSM_RANGE_ERROR_INFO;
pub const PDEVICE_DSM_RANGE_ERROR_INFO = [*c]struct__DEVICE_DSM_RANGE_ERROR_INFO;
pub const DEVICE_DSM_RANGE_ERROR_OUTPUT = struct__DEVICE_DSM_RANGE_ERROR_INFO;
pub const PDEVICE_DSM_RANGE_ERROR_OUTPUT = [*c]struct__DEVICE_DSM_RANGE_ERROR_INFO;
pub const struct__DEVICE_DSM_LOST_QUERY_PARAMETERS = extern struct {
    Version: DWORD,
    Granularity: DWORDLONG,
};
pub const DEVICE_DSM_LOST_QUERY_PARAMETERS = struct__DEVICE_DSM_LOST_QUERY_PARAMETERS;
pub const PDEVICE_DSM_LOST_QUERY_PARAMETERS = [*c]struct__DEVICE_DSM_LOST_QUERY_PARAMETERS;
pub const struct__DEVICE_DSM_LOST_QUERY_OUTPUT = extern struct {
    Version: DWORD,
    Size: DWORD,
    Alignment: DWORDLONG,
    NumberOfBits: DWORD,
    BitMap: [1]DWORD,
};
pub const DEVICE_DSM_LOST_QUERY_OUTPUT = struct__DEVICE_DSM_LOST_QUERY_OUTPUT;
pub const PDEVICE_DSM_LOST_QUERY_OUTPUT = [*c]struct__DEVICE_DSM_LOST_QUERY_OUTPUT;
pub const struct__DEVICE_DSM_FREE_SPACE_OUTPUT = extern struct {
    Version: DWORD,
    FreeSpace: DWORDLONG,
};
pub const DEVICE_DSM_FREE_SPACE_OUTPUT = struct__DEVICE_DSM_FREE_SPACE_OUTPUT;
pub const PDEVICE_DSM_FREE_SPACE_OUTPUT = [*c]struct__DEVICE_DSM_FREE_SPACE_OUTPUT;
pub const struct__DEVICE_DSM_CONVERSION_OUTPUT = extern struct {
    Version: DWORD,
    Source: GUID,
};
pub const DEVICE_DSM_CONVERSION_OUTPUT = struct__DEVICE_DSM_CONVERSION_OUTPUT;
pub const PDEVICE_DSM_CONVERSION_OUTPUT = [*c]struct__DEVICE_DSM_CONVERSION_OUTPUT;
pub fn DeviceDsmParameterBlock(Input: PDEVICE_DSM_INPUT) PVOID {
    return @intToPtr(PVOID, DWORD_PTR(@ptrToInt(Input)) +% @as(c_ulonglong, Input.?.ParameterBlockOffset));
}
pub fn DeviceDsmDataSetRanges(Input: PDEVICE_DSM_INPUT) PDEVICE_DSM_RANGE {
    return @intToPtr(PDEVICE_DSM_RANGE, DWORD_PTR(@ptrToInt(Input)) +% @as(c_ulonglong, Input.?.DataSetRangesOffset));
}
pub fn DeviceDsmNumberOfDataSetRanges(Input: PDEVICE_DSM_INPUT) DWORD {
    return DWORD(@as(c_ulonglong, Input.?.DataSetRangesLength) / @sizeOf(DEVICE_DSM_RANGE));
}
pub fn DeviceDsmGetInputLength(Definition: PDEVICE_DSM_DEFINITION, ParameterBlockLength: DWORD, NumberOfDataSetRanges: DWORD) DWORD {
    var Bytes: DWORD = DWORD(@sizeOf(DEVICE_DSM_INPUT));
    if (ParameterBlockLength != @as(c_ulong, 0)) {
        Bytes = (((Bytes +% (Definition.?.ParameterBlockAlignment -% @as(c_ulong, 1))) / Definition.?.ParameterBlockAlignment) *% Definition.?.ParameterBlockAlignment);
        Bytes +%= ParameterBlockLength;
    }
    if (NumberOfDataSetRanges != @as(c_ulong, 0)) {
        Bytes = DWORD(((@as(c_ulonglong, Bytes) +% (@sizeOf(DEVICE_DSM_RANGE) -% @as(c_ulonglong, 1))) / @sizeOf(DEVICE_DSM_RANGE)) *% @sizeOf(DEVICE_DSM_RANGE));
        Bytes +%= (@sizeOf(DEVICE_DSM_RANGE) *% @as(c_ulonglong, NumberOfDataSetRanges));
    }
    return Bytes;
}
pub fn DeviceDsmGetNumberOfDataSetRanges(Definition: PDEVICE_DSM_DEFINITION, InputLength: DWORD, ParameterBlockLength: DWORD) DWORD {
    var Bytes: DWORD = DWORD(@sizeOf(DEVICE_DSM_INPUT));
    if (ParameterBlockLength != @as(c_ulong, 0)) {
        Bytes = (((Bytes +% (Definition.?.ParameterBlockAlignment -% @as(c_ulong, 1))) / Definition.?.ParameterBlockAlignment) *% Definition.?.ParameterBlockAlignment);
        Bytes +%= ParameterBlockLength;
    }
    Bytes = DWORD(((@as(c_ulonglong, Bytes) +% (@sizeOf(DEVICE_DSM_RANGE) -% @as(c_ulonglong, 1))) / @sizeOf(DEVICE_DSM_RANGE)) *% @sizeOf(DEVICE_DSM_RANGE));
    Bytes = (InputLength -% Bytes);
    return DWORD(@as(c_ulonglong, Bytes) / @sizeOf(DEVICE_DSM_RANGE));
}
pub fn DeviceDsmOutputBlock(Output: PDEVICE_DSM_OUTPUT) PVOID {
    return @intToPtr(PVOID, DWORD_PTR(@ptrToInt(Output)) +% @as(c_ulonglong, Output.?.OutputBlockOffset));
}
pub fn DeviceDsmValidateOutputLength(Definition: PDEVICE_DSM_DEFINITION, OutputLength: DWORD) BOOLEAN {
    var Bytes: DWORD = DeviceDsmGetOutputLength(Definition, DWORD(0));
    return BOOLEAN(OutputLength >= Bytes);
}
pub fn DeviceDsmInitializeOutput(Definition: PDEVICE_DSM_DEFINITION, Output: PDEVICE_DSM_OUTPUT, OutputLength: DWORD, Flags: DWORD) void {
    var Bytes: DWORD = DWORD(@sizeOf(DEVICE_DSM_OUTPUT));
    _ = memset(@ptrCast(?*c_void, Output), 0, @as(c_ulonglong, OutputLength));
    Output.?.Size = Bytes;
    Output.?.Action = Definition.?.Action;
    Output.?.Flags = Flags;
    if (Definition.?.OutputBlockLength != @as(c_ulong, 0)) {
        Bytes = (((Bytes +% (Definition.?.OutputBlockAlignment -% @as(c_ulong, 1))) / Definition.?.OutputBlockAlignment) *% Definition.?.OutputBlockAlignment);
        Output.?.OutputBlockOffset = Bytes;
        Output.?.OutputBlockLength = (OutputLength -% Bytes);
    }
    return;
}
pub const struct__STORAGE_GET_BC_PROPERTIES_OUTPUT = extern struct {
    MaximumRequestsPerPeriod: DWORD,
    MinimumPeriod: DWORD,
    MaximumRequestSize: DWORDLONG,
    EstimatedTimePerRequest: DWORD,
    NumOutStandingRequests: DWORD,
    RequestSize: DWORDLONG,
};
pub const STORAGE_GET_BC_PROPERTIES_OUTPUT = struct__STORAGE_GET_BC_PROPERTIES_OUTPUT;
pub const PSTORAGE_GET_BC_PROPERTIES_OUTPUT = [*c]struct__STORAGE_GET_BC_PROPERTIES_OUTPUT;
pub const struct__STORAGE_ALLOCATE_BC_STREAM_INPUT = extern struct {
    Version: DWORD,
    RequestsPerPeriod: DWORD,
    Period: DWORD,
    RetryFailures: BOOLEAN,
    Discardable: BOOLEAN,
    Reserved1: [2]BOOLEAN,
    AccessType: DWORD,
    AccessMode: DWORD,
};
pub const STORAGE_ALLOCATE_BC_STREAM_INPUT = struct__STORAGE_ALLOCATE_BC_STREAM_INPUT;
pub const PSTORAGE_ALLOCATE_BC_STREAM_INPUT = [*c]struct__STORAGE_ALLOCATE_BC_STREAM_INPUT;
pub const struct__STORAGE_ALLOCATE_BC_STREAM_OUTPUT = extern struct {
    RequestSize: DWORDLONG,
    NumOutStandingRequests: DWORD,
};
pub const STORAGE_ALLOCATE_BC_STREAM_OUTPUT = struct__STORAGE_ALLOCATE_BC_STREAM_OUTPUT;
pub const PSTORAGE_ALLOCATE_BC_STREAM_OUTPUT = [*c]struct__STORAGE_ALLOCATE_BC_STREAM_OUTPUT;
pub const struct__STORAGE_PRIORITY_HINT_SUPPORT = extern struct {
    SupportFlags: DWORD,
};
pub const STORAGE_PRIORITY_HINT_SUPPORT = struct__STORAGE_PRIORITY_HINT_SUPPORT;
pub const PSTORAGE_PRIORITY_HINT_SUPPORT = [*c]struct__STORAGE_PRIORITY_HINT_SUPPORT;
pub const StorageDiagnosticLevelDefault = enum__STORAGE_DIAGNOSTIC_LEVEL.StorageDiagnosticLevelDefault;
pub const StorageDiagnosticLevelMax = enum__STORAGE_DIAGNOSTIC_LEVEL.StorageDiagnosticLevelMax;
pub const enum__STORAGE_DIAGNOSTIC_LEVEL = extern enum {
    StorageDiagnosticLevelDefault = 0,
    StorageDiagnosticLevelMax = 1,
};
pub const STORAGE_DIAGNOSTIC_LEVEL = enum__STORAGE_DIAGNOSTIC_LEVEL;
pub const PSTORAGE_DIAGNOSTIC_LEVEL = [*c]enum__STORAGE_DIAGNOSTIC_LEVEL;
pub const StorageDiagnosticTargetTypeUndefined = enum__STORAGE_DIAGNOSTIC_TARGET_TYPE.StorageDiagnosticTargetTypeUndefined;
pub const StorageDiagnosticTargetTypePort = enum__STORAGE_DIAGNOSTIC_TARGET_TYPE.StorageDiagnosticTargetTypePort;
pub const StorageDiagnosticTargetTypeMiniport = enum__STORAGE_DIAGNOSTIC_TARGET_TYPE.StorageDiagnosticTargetTypeMiniport;
pub const StorageDiagnosticTargetTypeHbaFirmware = enum__STORAGE_DIAGNOSTIC_TARGET_TYPE.StorageDiagnosticTargetTypeHbaFirmware;
pub const StorageDiagnosticTargetTypeMax = enum__STORAGE_DIAGNOSTIC_TARGET_TYPE.StorageDiagnosticTargetTypeMax;
pub const enum__STORAGE_DIAGNOSTIC_TARGET_TYPE = extern enum {
    StorageDiagnosticTargetTypeUndefined = 0,
    StorageDiagnosticTargetTypePort = 1,
    StorageDiagnosticTargetTypeMiniport = 2,
    StorageDiagnosticTargetTypeHbaFirmware = 3,
    StorageDiagnosticTargetTypeMax = 4,
};
pub const STORAGE_DIAGNOSTIC_TARGET_TYPE = enum__STORAGE_DIAGNOSTIC_TARGET_TYPE;
pub const PSTORAGE_DIAGNOSTIC_TARGET_TYPE = [*c]enum__STORAGE_DIAGNOSTIC_TARGET_TYPE;
pub const struct__STORAGE_DIAGNOSTIC_REQUEST = extern struct {
    Version: DWORD,
    Size: DWORD,
    Reserved: DWORD,
    TargetType: STORAGE_DIAGNOSTIC_TARGET_TYPE,
    Level: STORAGE_DIAGNOSTIC_LEVEL,
};
pub const STORAGE_DIAGNOSTIC_REQUEST = struct__STORAGE_DIAGNOSTIC_REQUEST;
pub const PSTORAGE_DIAGNOSTIC_REQUEST = [*c]struct__STORAGE_DIAGNOSTIC_REQUEST;
pub const struct__STORAGE_DIAGNOSTIC_DATA = extern struct {
    Version: DWORD,
    Size: DWORD,
    ProviderId: GUID,
    BufferSize: DWORD,
    Reserved: DWORD,
    DiagnosticDataBuffer: [1]BYTE,
};
pub const STORAGE_DIAGNOSTIC_DATA = struct__STORAGE_DIAGNOSTIC_DATA;
pub const PSTORAGE_DIAGNOSTIC_DATA = [*c]struct__STORAGE_DIAGNOSTIC_DATA;
pub const struct__PHYSICAL_ELEMENT_STATUS_REQUEST = extern struct {
    Version: DWORD,
    Size: DWORD,
    StartingElement: DWORD,
    Filter: BYTE,
    ReportType: BYTE,
    Reserved: [2]BYTE,
};
pub const PHYSICAL_ELEMENT_STATUS_REQUEST = struct__PHYSICAL_ELEMENT_STATUS_REQUEST;
pub const PPHYSICAL_ELEMENT_STATUS_REQUEST = [*c]struct__PHYSICAL_ELEMENT_STATUS_REQUEST;
pub const struct__PHYSICAL_ELEMENT_STATUS_DESCRIPTOR = extern struct {
    Version: DWORD,
    Size: DWORD,
    ElementIdentifier: DWORD,
    PhysicalElementType: BYTE,
    PhysicalElementHealth: BYTE,
    Reserved1: [2]BYTE,
    AssociatedCapacity: DWORDLONG,
    Reserved2: [4]DWORD,
};
pub const PHYSICAL_ELEMENT_STATUS_DESCRIPTOR = struct__PHYSICAL_ELEMENT_STATUS_DESCRIPTOR;
pub const PPHYSICAL_ELEMENT_STATUS_DESCRIPTOR = [*c]struct__PHYSICAL_ELEMENT_STATUS_DESCRIPTOR;
pub const struct__PHYSICAL_ELEMENT_STATUS = extern struct {
    Version: DWORD,
    Size: DWORD,
    DescriptorCount: DWORD,
    ReturnedDescriptorCount: DWORD,
    ElementIdentifierBeingDepoped: DWORD,
    Reserved: DWORD,
    Descriptors: [1]PHYSICAL_ELEMENT_STATUS_DESCRIPTOR,
};
pub const PHYSICAL_ELEMENT_STATUS = struct__PHYSICAL_ELEMENT_STATUS;
pub const PPHYSICAL_ELEMENT_STATUS = [*c]struct__PHYSICAL_ELEMENT_STATUS;
pub const struct__REMOVE_ELEMENT_AND_TRUNCATE_REQUEST = extern struct {
    Version: DWORD,
    Size: DWORD,
    RequestCapacity: DWORDLONG,
    ElementIdentifier: DWORD,
    Reserved: DWORD,
};
pub const REMOVE_ELEMENT_AND_TRUNCATE_REQUEST = struct__REMOVE_ELEMENT_AND_TRUNCATE_REQUEST;
pub const PREMOVE_ELEMENT_AND_TRUNCATE_REQUEST = [*c]struct__REMOVE_ELEMENT_AND_TRUNCATE_REQUEST;
pub const struct__STORAGE_MEDIA_SERIAL_NUMBER_DATA = extern struct {
    Reserved: WORD,
    SerialNumberLength: WORD,
    SerialNumber: [0]BYTE,
};
pub const STORAGE_MEDIA_SERIAL_NUMBER_DATA = struct__STORAGE_MEDIA_SERIAL_NUMBER_DATA;
pub const PSTORAGE_MEDIA_SERIAL_NUMBER_DATA = [*c]struct__STORAGE_MEDIA_SERIAL_NUMBER_DATA;
pub const struct__STORAGE_READ_CAPACITY = extern struct {
    Version: DWORD,
    Size: DWORD,
    BlockLength: DWORD,
    NumberOfBlocks: LARGE_INTEGER,
    DiskLength: LARGE_INTEGER,
};
pub const STORAGE_READ_CAPACITY = struct__STORAGE_READ_CAPACITY;
pub const PSTORAGE_READ_CAPACITY = [*c]struct__STORAGE_READ_CAPACITY;
pub const WriteCacheTypeUnknown = enum__WRITE_CACHE_TYPE.WriteCacheTypeUnknown;
pub const WriteCacheTypeNone = enum__WRITE_CACHE_TYPE.WriteCacheTypeNone;
pub const WriteCacheTypeWriteBack = enum__WRITE_CACHE_TYPE.WriteCacheTypeWriteBack;
pub const WriteCacheTypeWriteThrough = enum__WRITE_CACHE_TYPE.WriteCacheTypeWriteThrough;
pub const enum__WRITE_CACHE_TYPE = extern enum {
    WriteCacheTypeUnknown,
    WriteCacheTypeNone,
    WriteCacheTypeWriteBack,
    WriteCacheTypeWriteThrough,
};
pub const WRITE_CACHE_TYPE = enum__WRITE_CACHE_TYPE;
pub const WriteCacheEnableUnknown = enum__WRITE_CACHE_ENABLE.WriteCacheEnableUnknown;
pub const WriteCacheDisabled = enum__WRITE_CACHE_ENABLE.WriteCacheDisabled;
pub const WriteCacheEnabled = enum__WRITE_CACHE_ENABLE.WriteCacheEnabled;
pub const enum__WRITE_CACHE_ENABLE = extern enum {
    WriteCacheEnableUnknown,
    WriteCacheDisabled,
    WriteCacheEnabled,
};
pub const WRITE_CACHE_ENABLE = enum__WRITE_CACHE_ENABLE;
pub const WriteCacheChangeUnknown = enum__WRITE_CACHE_CHANGE.WriteCacheChangeUnknown;
pub const WriteCacheNotChangeable = enum__WRITE_CACHE_CHANGE.WriteCacheNotChangeable;
pub const WriteCacheChangeable = enum__WRITE_CACHE_CHANGE.WriteCacheChangeable;
pub const enum__WRITE_CACHE_CHANGE = extern enum {
    WriteCacheChangeUnknown,
    WriteCacheNotChangeable,
    WriteCacheChangeable,
};
pub const WRITE_CACHE_CHANGE = enum__WRITE_CACHE_CHANGE;
pub const WriteThroughUnknown = enum__WRITE_THROUGH.WriteThroughUnknown;
pub const WriteThroughNotSupported = enum__WRITE_THROUGH.WriteThroughNotSupported;
pub const WriteThroughSupported = enum__WRITE_THROUGH.WriteThroughSupported;
pub const enum__WRITE_THROUGH = extern enum {
    WriteThroughUnknown,
    WriteThroughNotSupported,
    WriteThroughSupported,
};
pub const WRITE_THROUGH = enum__WRITE_THROUGH;
pub const struct__STORAGE_WRITE_CACHE_PROPERTY = extern struct {
    Version: DWORD,
    Size: DWORD,
    WriteCacheType: WRITE_CACHE_TYPE,
    WriteCacheEnabled: WRITE_CACHE_ENABLE,
    WriteCacheChangeable: WRITE_CACHE_CHANGE,
    WriteThroughSupported: WRITE_THROUGH,
    FlushCacheSupported: BOOLEAN,
    UserDefinedPowerProtection: BOOLEAN,
    NVCacheEnabled: BOOLEAN,
};
pub const STORAGE_WRITE_CACHE_PROPERTY = struct__STORAGE_WRITE_CACHE_PROPERTY;
pub const PSTORAGE_WRITE_CACHE_PROPERTY = [*c]struct__STORAGE_WRITE_CACHE_PROPERTY;
pub const struct__PERSISTENT_RESERVE_COMMAND = extern struct {
    Version: DWORD,
    Size: DWORD,
    @"": extern union {
        PR_IN: @OpaqueType(),
        PR_OUT: @OpaqueType(),
    },
};
pub const PERSISTENT_RESERVE_COMMAND = struct__PERSISTENT_RESERVE_COMMAND;
pub const PPERSISTENT_RESERVE_COMMAND = [*c]struct__PERSISTENT_RESERVE_COMMAND;
pub const TCCollectionBugCheck = enum__DEVICEDUMP_COLLECTION_TYPE.TCCollectionBugCheck;
pub const TCCollectionApplicationRequested = enum__DEVICEDUMP_COLLECTION_TYPE.TCCollectionApplicationRequested;
pub const TCCollectionDeviceRequested = enum__DEVICEDUMP_COLLECTION_TYPE.TCCollectionDeviceRequested;
pub const enum__DEVICEDUMP_COLLECTION_TYPE = extern enum {
    TCCollectionBugCheck = 1,
    TCCollectionApplicationRequested = 2,
    TCCollectionDeviceRequested = 3,
};
pub const DEVICEDUMP_COLLECTION_TYPEIDE_NOTIFICATION_TYPE = enum__DEVICEDUMP_COLLECTION_TYPE;
pub const PDEVICEDUMP_COLLECTION_TYPE = [*c]enum__DEVICEDUMP_COLLECTION_TYPE;
pub const struct__DEVICEDUMP_SUBSECTION_POINTER = extern struct {
    dwSize: DWORD,
    dwFlags: DWORD,
    dwOffset: DWORD,
};
pub const DEVICEDUMP_SUBSECTION_POINTER = struct__DEVICEDUMP_SUBSECTION_POINTER;
pub const PDEVICEDUMP_SUBSECTION_POINTER = [*c]struct__DEVICEDUMP_SUBSECTION_POINTER;
pub const struct__DEVICEDUMP_STRUCTURE_VERSION = extern struct {
    dwSignature: DWORD,
    dwVersion: DWORD,
    dwSize: DWORD,
};
pub const DEVICEDUMP_STRUCTURE_VERSION = struct__DEVICEDUMP_STRUCTURE_VERSION;
pub const PDEVICEDUMP_STRUCTURE_VERSION = [*c]struct__DEVICEDUMP_STRUCTURE_VERSION;
pub const struct__DEVICEDUMP_SECTION_HEADER = extern struct {
    guidDeviceDataId: GUID,
    sOrganizationID: [16]BYTE,
    dwFirmwareRevision: DWORD,
    sModelNumber: [32]BYTE,
    szDeviceManufacturingID: [32]BYTE,
    dwFlags: DWORD,
    bRestrictedPrivateDataVersion: DWORD,
    dwFirmwareIssueId: DWORD,
    szIssueDescriptionString: [132]BYTE,
};
pub const DEVICEDUMP_SECTION_HEADER = struct__DEVICEDUMP_SECTION_HEADER;
pub const PDEVICEDUMP_SECTION_HEADER = [*c]struct__DEVICEDUMP_SECTION_HEADER;
pub const struct__GP_LOG_PAGE_DESCRIPTOR = extern struct {
    LogAddress: WORD,
    LogSectors: WORD,
};
pub const GP_LOG_PAGE_DESCRIPTOR = struct__GP_LOG_PAGE_DESCRIPTOR;
pub const PGP_LOG_PAGE_DESCRIPTOR = [*c]struct__GP_LOG_PAGE_DESCRIPTOR;
pub const struct__DEVICEDUMP_PUBLIC_SUBSECTION = extern struct {
    dwFlags: DWORD,
    GPLogTable: [16]GP_LOG_PAGE_DESCRIPTOR,
    szDescription: [16]CHAR,
    bData: [1]BYTE,
};
pub const DEVICEDUMP_PUBLIC_SUBSECTION = struct__DEVICEDUMP_PUBLIC_SUBSECTION;
pub const PDEVICEDUMP_PUBLIC_SUBSECTION = [*c]struct__DEVICEDUMP_PUBLIC_SUBSECTION;
pub const struct__DEVICEDUMP_RESTRICTED_SUBSECTION = extern struct {
    bData: [1]BYTE,
};
pub const DEVICEDUMP_RESTRICTED_SUBSECTION = struct__DEVICEDUMP_RESTRICTED_SUBSECTION;
pub const PDEVICEDUMP_RESTRICTED_SUBSECTION = [*c]struct__DEVICEDUMP_RESTRICTED_SUBSECTION;
pub const struct__DEVICEDUMP_PRIVATE_SUBSECTION = extern struct {
    dwFlags: DWORD,
    GPLogId: GP_LOG_PAGE_DESCRIPTOR,
    bData: [1]BYTE,
};
pub const DEVICEDUMP_PRIVATE_SUBSECTION = struct__DEVICEDUMP_PRIVATE_SUBSECTION;
pub const PDEVICEDUMP_PRIVATE_SUBSECTION = [*c]struct__DEVICEDUMP_PRIVATE_SUBSECTION;
pub const struct__DEVICEDUMP_STORAGEDEVICE_DATA = extern struct {
    Descriptor: DEVICEDUMP_STRUCTURE_VERSION,
    SectionHeader: DEVICEDUMP_SECTION_HEADER,
    dwBufferSize: DWORD,
    dwReasonForCollection: DWORD,
    PublicData: DEVICEDUMP_SUBSECTION_POINTER,
    RestrictedData: DEVICEDUMP_SUBSECTION_POINTER,
    PrivateData: DEVICEDUMP_SUBSECTION_POINTER,
};
pub const DEVICEDUMP_STORAGEDEVICE_DATA = struct__DEVICEDUMP_STORAGEDEVICE_DATA;
pub const PDEVICEDUMP_STORAGEDEVICE_DATA = [*c]struct__DEVICEDUMP_STORAGEDEVICE_DATA;
pub const struct__DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD = extern struct {
    Cdb: [16]BYTE,
    Command: [16]BYTE,
    StartTime: DWORDLONG,
    EndTime: DWORDLONG,
    OperationStatus: DWORD,
    OperationError: DWORD,
    StackSpecific: extern union {
        ExternalStack: extern struct {
            dwReserved: DWORD,
        },
        AtaPort: extern struct {
            dwAtaPortSpecific: DWORD,
        },
        StorPort: extern struct {
            SrbTag: DWORD,
        },
    },
};
pub const DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD = struct__DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD;
pub const PDEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD = [*c]struct__DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD;
pub const struct__DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP = extern struct {
    Descriptor: DEVICEDUMP_STRUCTURE_VERSION,
    dwReasonForCollection: DWORD,
    cDriverName: [16]BYTE,
    uiNumRecords: DWORD,
    RecordArray: [1]DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD,
};
pub const DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP = struct__DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP;
pub const PDEVICEDUMP_STORAGESTACK_PUBLIC_DUMP = [*c]struct__DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP;
pub const struct__STORAGE_IDLE_POWER = @OpaqueType();
pub const STORAGE_IDLE_POWER = struct__STORAGE_IDLE_POWER;
pub const PSTORAGE_IDLE_POWER = ?*struct__STORAGE_IDLE_POWER;
pub const StoragePowerupUnknown = enum__STORAGE_POWERUP_REASON_TYPE.StoragePowerupUnknown;
pub const StoragePowerupIO = enum__STORAGE_POWERUP_REASON_TYPE.StoragePowerupIO;
pub const StoragePowerupDeviceAttention = enum__STORAGE_POWERUP_REASON_TYPE.StoragePowerupDeviceAttention;
pub const enum__STORAGE_POWERUP_REASON_TYPE = extern enum {
    StoragePowerupUnknown = 0,
    StoragePowerupIO = 1,
    StoragePowerupDeviceAttention = 2,
};
pub const STORAGE_POWERUP_REASON_TYPE = enum__STORAGE_POWERUP_REASON_TYPE;
pub const PSTORAGE_POWERUP_REASON_TYPE = [*c]enum__STORAGE_POWERUP_REASON_TYPE;
pub const struct__STORAGE_IDLE_POWERUP_REASON = extern struct {
    Version: DWORD,
    Size: DWORD,
    PowerupReason: STORAGE_POWERUP_REASON_TYPE,
};
pub const STORAGE_IDLE_POWERUP_REASON = struct__STORAGE_IDLE_POWERUP_REASON;
pub const PSTORAGE_IDLE_POWERUP_REASON = [*c]struct__STORAGE_IDLE_POWERUP_REASON;
pub const StorageDevicePowerCapUnitsPercent = enum__STORAGE_DEVICE_POWER_CAP_UNITS.StorageDevicePowerCapUnitsPercent;
pub const StorageDevicePowerCapUnitsMilliwatts = enum__STORAGE_DEVICE_POWER_CAP_UNITS.StorageDevicePowerCapUnitsMilliwatts;
pub const enum__STORAGE_DEVICE_POWER_CAP_UNITS = extern enum {
    StorageDevicePowerCapUnitsPercent,
    StorageDevicePowerCapUnitsMilliwatts,
};
pub const STORAGE_DEVICE_POWER_CAP_UNITS = enum__STORAGE_DEVICE_POWER_CAP_UNITS;
pub const PSTORAGE_DEVICE_POWER_CAP_UNITS = [*c]enum__STORAGE_DEVICE_POWER_CAP_UNITS;
pub const struct__STORAGE_DEVICE_POWER_CAP = extern struct {
    Version: DWORD,
    Size: DWORD,
    Units: STORAGE_DEVICE_POWER_CAP_UNITS,
    MaxPower: DWORDLONG,
};
pub const STORAGE_DEVICE_POWER_CAP = struct__STORAGE_DEVICE_POWER_CAP;
pub const PSTORAGE_DEVICE_POWER_CAP = [*c]struct__STORAGE_DEVICE_POWER_CAP;
pub const struct__STORAGE_RPMB_DATA_FRAME = extern struct {
    Stuff: [196]BYTE,
    KeyOrMAC: [32]BYTE,
    Data: [256]BYTE,
    Nonce: [16]BYTE,
    WriteCounter: [4]BYTE,
    Address: [2]BYTE,
    BlockCount: [2]BYTE,
    OperationResult: [2]BYTE,
    RequestOrResponseType: [2]BYTE,
};
pub const STORAGE_RPMB_DATA_FRAME = struct__STORAGE_RPMB_DATA_FRAME;
pub const PSTORAGE_RPMB_DATA_FRAME = [*c]struct__STORAGE_RPMB_DATA_FRAME;
pub const StorRpmbProgramAuthKey = enum__STORAGE_RPMB_COMMAND_TYPE.StorRpmbProgramAuthKey;
pub const StorRpmbQueryWriteCounter = enum__STORAGE_RPMB_COMMAND_TYPE.StorRpmbQueryWriteCounter;
pub const StorRpmbAuthenticatedWrite = enum__STORAGE_RPMB_COMMAND_TYPE.StorRpmbAuthenticatedWrite;
pub const StorRpmbAuthenticatedRead = enum__STORAGE_RPMB_COMMAND_TYPE.StorRpmbAuthenticatedRead;
pub const StorRpmbReadResultRequest = enum__STORAGE_RPMB_COMMAND_TYPE.StorRpmbReadResultRequest;
pub const StorRpmbAuthenticatedDeviceConfigWrite = enum__STORAGE_RPMB_COMMAND_TYPE.StorRpmbAuthenticatedDeviceConfigWrite;
pub const StorRpmbAuthenticatedDeviceConfigRead = enum__STORAGE_RPMB_COMMAND_TYPE.StorRpmbAuthenticatedDeviceConfigRead;
pub const enum__STORAGE_RPMB_COMMAND_TYPE = extern enum {
    StorRpmbProgramAuthKey = 1,
    StorRpmbQueryWriteCounter = 2,
    StorRpmbAuthenticatedWrite = 3,
    StorRpmbAuthenticatedRead = 4,
    StorRpmbReadResultRequest = 5,
    StorRpmbAuthenticatedDeviceConfigWrite = 6,
    StorRpmbAuthenticatedDeviceConfigRead = 7,
};
pub const STORAGE_RPMB_COMMAND_TYPE = enum__STORAGE_RPMB_COMMAND_TYPE;
pub const PSTORAGE_RPMB_COMMAND_TYPE = [*c]enum__STORAGE_RPMB_COMMAND_TYPE;
pub const struct__STORAGE_EVENT_NOTIFICATION = extern struct {
    Version: DWORD,
    Size: DWORD,
    Events: DWORDLONG,
};
pub const STORAGE_EVENT_NOTIFICATION = struct__STORAGE_EVENT_NOTIFICATION;
pub const PSTORAGE_EVENT_NOTIFICATION = [*c]struct__STORAGE_EVENT_NOTIFICATION;
pub const StorageCounterTypeUnknown = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeUnknown;
pub const StorageCounterTypeTemperatureCelsius = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeTemperatureCelsius;
pub const StorageCounterTypeTemperatureCelsiusMax = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeTemperatureCelsiusMax;
pub const StorageCounterTypeReadErrorsTotal = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeReadErrorsTotal;
pub const StorageCounterTypeReadErrorsCorrected = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeReadErrorsCorrected;
pub const StorageCounterTypeReadErrorsUncorrected = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeReadErrorsUncorrected;
pub const StorageCounterTypeWriteErrorsTotal = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeWriteErrorsTotal;
pub const StorageCounterTypeWriteErrorsCorrected = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeWriteErrorsCorrected;
pub const StorageCounterTypeWriteErrorsUncorrected = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeWriteErrorsUncorrected;
pub const StorageCounterTypeManufactureDate = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeManufactureDate;
pub const StorageCounterTypeStartStopCycleCount = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeStartStopCycleCount;
pub const StorageCounterTypeStartStopCycleCountMax = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeStartStopCycleCountMax;
pub const StorageCounterTypeLoadUnloadCycleCount = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeLoadUnloadCycleCount;
pub const StorageCounterTypeLoadUnloadCycleCountMax = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeLoadUnloadCycleCountMax;
pub const StorageCounterTypeWearPercentage = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeWearPercentage;
pub const StorageCounterTypeWearPercentageWarning = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeWearPercentageWarning;
pub const StorageCounterTypeWearPercentageMax = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeWearPercentageMax;
pub const StorageCounterTypePowerOnHours = enum__STORAGE_COUNTER_TYPE.StorageCounterTypePowerOnHours;
pub const StorageCounterTypeReadLatency100NSMax = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeReadLatency100NSMax;
pub const StorageCounterTypeWriteLatency100NSMax = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeWriteLatency100NSMax;
pub const StorageCounterTypeFlushLatency100NSMax = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeFlushLatency100NSMax;
pub const StorageCounterTypeMax = enum__STORAGE_COUNTER_TYPE.StorageCounterTypeMax;
pub const enum__STORAGE_COUNTER_TYPE = extern enum {
    StorageCounterTypeUnknown = 0,
    StorageCounterTypeTemperatureCelsius = 1,
    StorageCounterTypeTemperatureCelsiusMax = 2,
    StorageCounterTypeReadErrorsTotal = 3,
    StorageCounterTypeReadErrorsCorrected = 4,
    StorageCounterTypeReadErrorsUncorrected = 5,
    StorageCounterTypeWriteErrorsTotal = 6,
    StorageCounterTypeWriteErrorsCorrected = 7,
    StorageCounterTypeWriteErrorsUncorrected = 8,
    StorageCounterTypeManufactureDate = 9,
    StorageCounterTypeStartStopCycleCount = 10,
    StorageCounterTypeStartStopCycleCountMax = 11,
    StorageCounterTypeLoadUnloadCycleCount = 12,
    StorageCounterTypeLoadUnloadCycleCountMax = 13,
    StorageCounterTypeWearPercentage = 14,
    StorageCounterTypeWearPercentageWarning = 15,
    StorageCounterTypeWearPercentageMax = 16,
    StorageCounterTypePowerOnHours = 17,
    StorageCounterTypeReadLatency100NSMax = 18,
    StorageCounterTypeWriteLatency100NSMax = 19,
    StorageCounterTypeFlushLatency100NSMax = 20,
    StorageCounterTypeMax = 21,
};
pub const STORAGE_COUNTER_TYPE = enum__STORAGE_COUNTER_TYPE;
pub const PSTORAGE_COUNTER_TYPE = [*c]enum__STORAGE_COUNTER_TYPE;
pub const struct__STORAGE_COUNTER = extern struct {
    Type: STORAGE_COUNTER_TYPE,
    Value: extern union {
        ManufactureDate: extern struct {
            Week: DWORD,
            Year: DWORD,
        },
        AsUlonglong: DWORDLONG,
    },
};
pub const STORAGE_COUNTER = struct__STORAGE_COUNTER;
pub const PSTORAGE_COUNTER = [*c]struct__STORAGE_COUNTER;
pub const struct__STORAGE_COUNTERS = extern struct {
    Version: DWORD,
    Size: DWORD,
    NumberOfCounters: DWORD,
    Counters: [1]STORAGE_COUNTER,
};
pub const STORAGE_COUNTERS = struct__STORAGE_COUNTERS;
pub const PSTORAGE_COUNTERS = [*c]struct__STORAGE_COUNTERS;
pub const struct__STORAGE_HW_FIRMWARE_INFO_QUERY = extern struct {
    Version: DWORD,
    Size: DWORD,
    Flags: DWORD,
    Reserved: DWORD,
};
pub const STORAGE_HW_FIRMWARE_INFO_QUERY = struct__STORAGE_HW_FIRMWARE_INFO_QUERY;
pub const PSTORAGE_HW_FIRMWARE_INFO_QUERY = [*c]struct__STORAGE_HW_FIRMWARE_INFO_QUERY;
pub const struct__STORAGE_HW_FIRMWARE_SLOT_INFO = @OpaqueType();
pub const STORAGE_HW_FIRMWARE_SLOT_INFO = struct__STORAGE_HW_FIRMWARE_SLOT_INFO;
pub const PSTORAGE_HW_FIRMWARE_SLOT_INFO = ?*struct__STORAGE_HW_FIRMWARE_SLOT_INFO;
pub const struct__STORAGE_HW_FIRMWARE_INFO = @OpaqueType();
pub const STORAGE_HW_FIRMWARE_INFO = struct__STORAGE_HW_FIRMWARE_INFO;
pub const PSTORAGE_HW_FIRMWARE_INFO = ?*struct__STORAGE_HW_FIRMWARE_INFO;
pub const struct__STORAGE_HW_FIRMWARE_DOWNLOAD = extern struct {
    Version: DWORD,
    Size: DWORD,
    Flags: DWORD,
    Slot: BYTE,
    Reserved: [3]BYTE,
    Offset: DWORDLONG,
    BufferSize: DWORDLONG,
    ImageBuffer: [1]BYTE,
};
pub const STORAGE_HW_FIRMWARE_DOWNLOAD = struct__STORAGE_HW_FIRMWARE_DOWNLOAD;
pub const PSTORAGE_HW_FIRMWARE_DOWNLOAD = [*c]struct__STORAGE_HW_FIRMWARE_DOWNLOAD;
pub const struct__STORAGE_HW_FIRMWARE_DOWNLOAD_V2 = extern struct {
    Version: DWORD,
    Size: DWORD,
    Flags: DWORD,
    Slot: BYTE,
    Reserved: [3]BYTE,
    Offset: DWORDLONG,
    BufferSize: DWORDLONG,
    ImageSize: DWORD,
    Reserved2: DWORD,
    ImageBuffer: [1]BYTE,
};
pub const STORAGE_HW_FIRMWARE_DOWNLOAD_V2 = struct__STORAGE_HW_FIRMWARE_DOWNLOAD_V2;
pub const PSTORAGE_HW_FIRMWARE_DOWNLOAD_V2 = [*c]struct__STORAGE_HW_FIRMWARE_DOWNLOAD_V2;
pub const struct__STORAGE_HW_FIRMWARE_ACTIVATE = extern struct {
    Version: DWORD,
    Size: DWORD,
    Flags: DWORD,
    Slot: BYTE,
    Reserved0: [3]BYTE,
};
pub const STORAGE_HW_FIRMWARE_ACTIVATE = struct__STORAGE_HW_FIRMWARE_ACTIVATE;
pub const PSTORAGE_HW_FIRMWARE_ACTIVATE = [*c]struct__STORAGE_HW_FIRMWARE_ACTIVATE;
pub const struct__STORAGE_PROTOCOL_COMMAND = extern struct {
    Version: DWORD,
    Length: DWORD,
    ProtocolType: STORAGE_PROTOCOL_TYPE,
    Flags: DWORD,
    ReturnStatus: DWORD,
    ErrorCode: DWORD,
    CommandLength: DWORD,
    ErrorInfoLength: DWORD,
    DataToDeviceTransferLength: DWORD,
    DataFromDeviceTransferLength: DWORD,
    TimeOutValue: DWORD,
    ErrorInfoOffset: DWORD,
    DataToDeviceBufferOffset: DWORD,
    DataFromDeviceBufferOffset: DWORD,
    CommandSpecific: DWORD,
    Reserved0: DWORD,
    FixedProtocolReturnData: DWORD,
    Reserved1: [3]DWORD,
    Command: [1]BYTE,
};
pub const STORAGE_PROTOCOL_COMMAND = struct__STORAGE_PROTOCOL_COMMAND;
pub const PSTORAGE_PROTOCOL_COMMAND = [*c]struct__STORAGE_PROTOCOL_COMMAND;
pub const StorAttributeMgmt_ClearAttribute = enum__STORAGE_ATTRIBUTE_MGMT_ACTION.StorAttributeMgmt_ClearAttribute;
pub const StorAttributeMgmt_SetAttribute = enum__STORAGE_ATTRIBUTE_MGMT_ACTION.StorAttributeMgmt_SetAttribute;
pub const StorAttributeMgmt_ResetAttribute = enum__STORAGE_ATTRIBUTE_MGMT_ACTION.StorAttributeMgmt_ResetAttribute;
pub const enum__STORAGE_ATTRIBUTE_MGMT_ACTION = extern enum {
    StorAttributeMgmt_ClearAttribute = 0,
    StorAttributeMgmt_SetAttribute = 1,
    StorAttributeMgmt_ResetAttribute = 2,
};
pub const STORAGE_ATTRIBUTE_MGMT_ACTION = enum__STORAGE_ATTRIBUTE_MGMT_ACTION;
pub const PSTORAGE_ATTRIBUTE_MGMT_ACTION = [*c]enum__STORAGE_ATTRIBUTE_MGMT_ACTION;
pub const struct__STORAGE_ATTRIBUTE_MGMT = extern struct {
    Version: DWORD,
    Size: DWORD,
    Action: STORAGE_ATTRIBUTE_MGMT_ACTION,
    Attribute: DWORD,
};
pub const STORAGE_ATTRIBUTE_MGMT = struct__STORAGE_ATTRIBUTE_MGMT;
pub const PSTORAGE_ATTRIBUTE_MGMT = [*c]struct__STORAGE_ATTRIBUTE_MGMT;
pub const struct__SCM_PD_HEALTH_NOTIFICATION_DATA = extern struct {
    DeviceGuid: GUID,
};
pub const SCM_PD_HEALTH_NOTIFICATION_DATA = struct__SCM_PD_HEALTH_NOTIFICATION_DATA;
pub const PSCM_PD_HEALTH_NOTIFICATION_DATA = [*c]struct__SCM_PD_HEALTH_NOTIFICATION_DATA;
pub const struct__SCM_LOGICAL_DEVICE_INSTANCE = extern struct {
    Version: DWORD,
    Size: DWORD,
    DeviceGuid: GUID,
    SymbolicLink: [256]WCHAR,
};
pub const SCM_LOGICAL_DEVICE_INSTANCE = struct__SCM_LOGICAL_DEVICE_INSTANCE;
pub const PSCM_LOGICAL_DEVICE_INSTANCE = [*c]struct__SCM_LOGICAL_DEVICE_INSTANCE;
pub const struct__SCM_LOGICAL_DEVICES = extern struct {
    Version: DWORD,
    Size: DWORD,
    DeviceCount: DWORD,
    Devices: [1]SCM_LOGICAL_DEVICE_INSTANCE,
};
pub const SCM_LOGICAL_DEVICES = struct__SCM_LOGICAL_DEVICES;
pub const PSCM_LOGICAL_DEVICES = [*c]struct__SCM_LOGICAL_DEVICES;
pub const struct__SCM_PHYSICAL_DEVICE_INSTANCE = extern struct {
    Version: DWORD,
    Size: DWORD,
    NfitHandle: DWORD,
    SymbolicLink: [256]WCHAR,
};
pub const SCM_PHYSICAL_DEVICE_INSTANCE = struct__SCM_PHYSICAL_DEVICE_INSTANCE;
pub const PSCM_PHYSICAL_DEVICE_INSTANCE = [*c]struct__SCM_PHYSICAL_DEVICE_INSTANCE;
pub const struct__SCM_PHYSICAL_DEVICES = extern struct {
    Version: DWORD,
    Size: DWORD,
    DeviceCount: DWORD,
    Devices: [1]SCM_PHYSICAL_DEVICE_INSTANCE,
};
pub const SCM_PHYSICAL_DEVICES = struct__SCM_PHYSICAL_DEVICES;
pub const PSCM_PHYSICAL_DEVICES = [*c]struct__SCM_PHYSICAL_DEVICES;
pub const ScmRegionFlagNone = enum__SCM_REGION_FLAG.ScmRegionFlagNone;
pub const ScmRegionFlagLabel = enum__SCM_REGION_FLAG.ScmRegionFlagLabel;
pub const enum__SCM_REGION_FLAG = extern enum {
    ScmRegionFlagNone = 0,
    ScmRegionFlagLabel = 1,
};
pub const SCM_REGION_FLAG = enum__SCM_REGION_FLAG;
pub const PSCM_REGION_FLAG = [*c]enum__SCM_REGION_FLAG;
pub const struct__SCM_REGION = extern struct {
    Version: DWORD,
    Size: DWORD,
    Flags: DWORD,
    NfitHandle: DWORD,
    LogicalDeviceGuid: GUID,
    AddressRangeType: GUID,
    AssociatedId: DWORD,
    Length: DWORD64,
    StartingDPA: DWORD64,
    BaseSPA: DWORD64,
    SPAOffset: DWORD64,
    RegionOffset: DWORD64,
};
pub const SCM_REGION = struct__SCM_REGION;
pub const PSCM_REGION = [*c]struct__SCM_REGION;
pub const struct__SCM_REGIONS = extern struct {
    Version: DWORD,
    Size: DWORD,
    RegionCount: DWORD,
    Regions: [1]SCM_REGION,
};
pub const SCM_REGIONS = struct__SCM_REGIONS;
pub const PSCM_REGIONS = [*c]struct__SCM_REGIONS;
pub const struct__SCM_INTERLEAVED_PD_INFO = extern struct {
    DeviceHandle: DWORD,
    DeviceGuid: GUID,
};
pub const SCM_INTERLEAVED_PD_INFO = struct__SCM_INTERLEAVED_PD_INFO;
pub const PSCM_INTERLEAVED_PD_INFO = [*c]struct__SCM_INTERLEAVED_PD_INFO;
pub const struct__SCM_LD_INTERLEAVE_SET_INFO = extern struct {
    Version: DWORD,
    Size: DWORD,
    InterleaveSetSize: DWORD,
    InterleaveSet: [1]SCM_INTERLEAVED_PD_INFO,
};
pub const SCM_LD_INTERLEAVE_SET_INFO = struct__SCM_LD_INTERLEAVE_SET_INFO;
pub const PSCM_LD_INTERLEAVE_SET_INFO = [*c]struct__SCM_LD_INTERLEAVE_SET_INFO;
pub const ScmPhysicalDeviceQuery_Descriptor = enum__SCM_PD_QUERY_TYPE.ScmPhysicalDeviceQuery_Descriptor;
pub const ScmPhysicalDeviceQuery_IsSupported = enum__SCM_PD_QUERY_TYPE.ScmPhysicalDeviceQuery_IsSupported;
pub const ScmPhysicalDeviceQuery_Max = enum__SCM_PD_QUERY_TYPE.ScmPhysicalDeviceQuery_Max;
pub const enum__SCM_PD_QUERY_TYPE = extern enum {
    ScmPhysicalDeviceQuery_Descriptor = 0,
    ScmPhysicalDeviceQuery_IsSupported = 1,
    ScmPhysicalDeviceQuery_Max = 2,
};
pub const SCM_PD_QUERY_TYPE = enum__SCM_PD_QUERY_TYPE;
pub const PSCM_PD_QUERY_TYPE = [*c]enum__SCM_PD_QUERY_TYPE;
pub const ScmPhysicalDeviceProperty_DeviceInfo = enum__SCM_PD_PROPERTY_ID.ScmPhysicalDeviceProperty_DeviceInfo;
pub const ScmPhysicalDeviceProperty_ManagementStatus = enum__SCM_PD_PROPERTY_ID.ScmPhysicalDeviceProperty_ManagementStatus;
pub const ScmPhysicalDeviceProperty_FirmwareInfo = enum__SCM_PD_PROPERTY_ID.ScmPhysicalDeviceProperty_FirmwareInfo;
pub const ScmPhysicalDeviceProperty_LocationString = enum__SCM_PD_PROPERTY_ID.ScmPhysicalDeviceProperty_LocationString;
pub const ScmPhysicalDeviceProperty_DeviceSpecificInfo = enum__SCM_PD_PROPERTY_ID.ScmPhysicalDeviceProperty_DeviceSpecificInfo;
pub const ScmPhysicalDeviceProperty_DeviceHandle = enum__SCM_PD_PROPERTY_ID.ScmPhysicalDeviceProperty_DeviceHandle;
pub const ScmPhysicalDeviceProperty_Max = enum__SCM_PD_PROPERTY_ID.ScmPhysicalDeviceProperty_Max;
pub const enum__SCM_PD_PROPERTY_ID = extern enum {
    ScmPhysicalDeviceProperty_DeviceInfo = 0,
    ScmPhysicalDeviceProperty_ManagementStatus = 1,
    ScmPhysicalDeviceProperty_FirmwareInfo = 2,
    ScmPhysicalDeviceProperty_LocationString = 3,
    ScmPhysicalDeviceProperty_DeviceSpecificInfo = 4,
    ScmPhysicalDeviceProperty_DeviceHandle = 5,
    ScmPhysicalDeviceProperty_Max = 6,
};
pub const SCM_PD_PROPERTY_ID = enum__SCM_PD_PROPERTY_ID;
pub const PSCM_PD_PROPERTY_ID = [*c]enum__SCM_PD_PROPERTY_ID;
pub const struct__SCM_PD_PROPERTY_QUERY = extern struct {
    Version: DWORD,
    Size: DWORD,
    PropertyId: SCM_PD_PROPERTY_ID,
    QueryType: SCM_PD_QUERY_TYPE,
    AdditionalParameters: [1]BYTE,
};
pub const SCM_PD_PROPERTY_QUERY = struct__SCM_PD_PROPERTY_QUERY;
pub const PSCM_PD_PROPERTY_QUERY = [*c]struct__SCM_PD_PROPERTY_QUERY;
pub const struct__SCM_PD_DESCRIPTOR_HEADER = extern struct {
    Version: DWORD,
    Size: DWORD,
};
pub const SCM_PD_DESCRIPTOR_HEADER = struct__SCM_PD_DESCRIPTOR_HEADER;
pub const PSCM_PD_DESCRIPTOR_HEADER = [*c]struct__SCM_PD_DESCRIPTOR_HEADER;
pub const struct__SCM_PD_DEVICE_HANDLE = extern struct {
    Version: DWORD,
    Size: DWORD,
    DeviceGuid: GUID,
    DeviceHandle: DWORD,
};
pub const SCM_PD_DEVICE_HANDLE = struct__SCM_PD_DEVICE_HANDLE;
pub const PSCM_PD_DEVICE_HANDLE = [*c]struct__SCM_PD_DEVICE_HANDLE;
pub const struct__SCM_PD_DEVICE_INFO = extern struct {
    Version: DWORD,
    Size: DWORD,
    DeviceGuid: GUID,
    UnsafeShutdownCount: DWORD,
    PersistentMemorySizeInBytes: DWORD64,
    VolatileMemorySizeInBytes: DWORD64,
    TotalMemorySizeInBytes: DWORD64,
    SlotNumber: DWORD,
    DeviceHandle: DWORD,
    PhysicalId: WORD,
    NumberOfFormatInterfaceCodes: BYTE,
    FormatInterfaceCodes: [8]WORD,
    VendorId: DWORD,
    ProductId: DWORD,
    SubsystemDeviceId: DWORD,
    SubsystemVendorId: DWORD,
    ManufacturingLocation: BYTE,
    ManufacturingWeek: BYTE,
    ManufacturingYear: BYTE,
    SerialNumber4Byte: DWORD,
    SerialNumberLengthInChars: DWORD,
    SerialNumber: [1]CHAR,
};
pub const SCM_PD_DEVICE_INFO = struct__SCM_PD_DEVICE_INFO;
pub const PSCM_PD_DEVICE_INFO = [*c]struct__SCM_PD_DEVICE_INFO;
pub const struct__SCM_PD_DEVICE_SPECIFIC_PROPERTY = extern struct {
    Name: [128]WCHAR,
    Value: LONGLONG,
};
pub const SCM_PD_DEVICE_SPECIFIC_PROPERTY = struct__SCM_PD_DEVICE_SPECIFIC_PROPERTY;
pub const PSCM_PD_DEVICE_SPECIFIC_PROPERTY = [*c]struct__SCM_PD_DEVICE_SPECIFIC_PROPERTY;
pub const struct__SCM_PD_DEVICE_SPECIFIC_INFO = extern struct {
    Version: DWORD,
    Size: DWORD,
    NumberOfProperties: DWORD,
    DeviceSpecificProperties: [1]SCM_PD_DEVICE_SPECIFIC_PROPERTY,
};
pub const SCM_PD_DEVICE_SPECIFIC_INFO = struct__SCM_PD_DEVICE_SPECIFIC_INFO;
pub const PSCM_PD_DEVICE_SPECIFIC_INFO = [*c]struct__SCM_PD_DEVICE_SPECIFIC_INFO;
pub const struct__SCM_PD_FIRMWARE_SLOT_INFO = @OpaqueType();
pub const SCM_PD_FIRMWARE_SLOT_INFO = struct__SCM_PD_FIRMWARE_SLOT_INFO;
pub const PSCM_PD_FIRMWARE_SLOT_INFO = ?*struct__SCM_PD_FIRMWARE_SLOT_INFO;
pub const struct__SCM_PD_FIRMWARE_INFO = extern struct {
    Version: DWORD,
    Size: DWORD,
    ActiveSlot: BYTE,
    NextActiveSlot: BYTE,
    SlotCount: BYTE,
    Slots: [1]SCM_PD_FIRMWARE_SLOT_INFO,
};
pub const SCM_PD_FIRMWARE_INFO = struct__SCM_PD_FIRMWARE_INFO;
pub const PSCM_PD_FIRMWARE_INFO = [*c]struct__SCM_PD_FIRMWARE_INFO;
pub const ScmPhysicalDeviceHealth_Unknown = enum__SCM_PD_HEALTH_STATUS.ScmPhysicalDeviceHealth_Unknown;
pub const ScmPhysicalDeviceHealth_Unhealthy = enum__SCM_PD_HEALTH_STATUS.ScmPhysicalDeviceHealth_Unhealthy;
pub const ScmPhysicalDeviceHealth_Warning = enum__SCM_PD_HEALTH_STATUS.ScmPhysicalDeviceHealth_Warning;
pub const ScmPhysicalDeviceHealth_Healthy = enum__SCM_PD_HEALTH_STATUS.ScmPhysicalDeviceHealth_Healthy;
pub const ScmPhysicalDeviceHealth_Max = enum__SCM_PD_HEALTH_STATUS.ScmPhysicalDeviceHealth_Max;
pub const enum__SCM_PD_HEALTH_STATUS = extern enum {
    ScmPhysicalDeviceHealth_Unknown = 0,
    ScmPhysicalDeviceHealth_Unhealthy = 1,
    ScmPhysicalDeviceHealth_Warning = 2,
    ScmPhysicalDeviceHealth_Healthy = 3,
    ScmPhysicalDeviceHealth_Max = 4,
};
pub const SCM_PD_HEALTH_STATUS = enum__SCM_PD_HEALTH_STATUS;
pub const PSCM_PD_HEALTH_STATUS = [*c]enum__SCM_PD_HEALTH_STATUS;
pub const ScmPhysicalDeviceOpStatus_Unknown = enum__SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_Unknown;
pub const ScmPhysicalDeviceOpStatus_Ok = enum__SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_Ok;
pub const ScmPhysicalDeviceOpStatus_PredictingFailure = enum__SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_PredictingFailure;
pub const ScmPhysicalDeviceOpStatus_InService = enum__SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_InService;
pub const ScmPhysicalDeviceOpStatus_HardwareError = enum__SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_HardwareError;
pub const ScmPhysicalDeviceOpStatus_NotUsable = enum__SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_NotUsable;
pub const ScmPhysicalDeviceOpStatus_TransientError = enum__SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_TransientError;
pub const ScmPhysicalDeviceOpStatus_Missing = enum__SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_Missing;
pub const ScmPhysicalDeviceOpStatus_Max = enum__SCM_PD_OPERATIONAL_STATUS.ScmPhysicalDeviceOpStatus_Max;
pub const enum__SCM_PD_OPERATIONAL_STATUS = extern enum {
    ScmPhysicalDeviceOpStatus_Unknown = 0,
    ScmPhysicalDeviceOpStatus_Ok = 1,
    ScmPhysicalDeviceOpStatus_PredictingFailure = 2,
    ScmPhysicalDeviceOpStatus_InService = 3,
    ScmPhysicalDeviceOpStatus_HardwareError = 4,
    ScmPhysicalDeviceOpStatus_NotUsable = 5,
    ScmPhysicalDeviceOpStatus_TransientError = 6,
    ScmPhysicalDeviceOpStatus_Missing = 7,
    ScmPhysicalDeviceOpStatus_Max = 8,
};
pub const SCM_PD_OPERATIONAL_STATUS = enum__SCM_PD_OPERATIONAL_STATUS;
pub const PSCM_PD_OPERATIONAL_STATUS = [*c]enum__SCM_PD_OPERATIONAL_STATUS;
pub const ScmPhysicalDeviceOpReason_Unknown = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_Unknown;
pub const ScmPhysicalDeviceOpReason_Media = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_Media;
pub const ScmPhysicalDeviceOpReason_ThresholdExceeded = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_ThresholdExceeded;
pub const ScmPhysicalDeviceOpReason_LostData = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_LostData;
pub const ScmPhysicalDeviceOpReason_EnergySource = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_EnergySource;
pub const ScmPhysicalDeviceOpReason_Configuration = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_Configuration;
pub const ScmPhysicalDeviceOpReason_DeviceController = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_DeviceController;
pub const ScmPhysicalDeviceOpReason_MediaController = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_MediaController;
pub const ScmPhysicalDeviceOpReason_Component = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_Component;
pub const ScmPhysicalDeviceOpReason_BackgroundOperation = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_BackgroundOperation;
pub const ScmPhysicalDeviceOpReason_InvalidFirmware = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_InvalidFirmware;
pub const ScmPhysicalDeviceOpReason_HealthCheck = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_HealthCheck;
pub const ScmPhysicalDeviceOpReason_LostDataPersistence = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_LostDataPersistence;
pub const ScmPhysicalDeviceOpReason_DisabledByPlatform = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_DisabledByPlatform;
pub const ScmPhysicalDeviceOpReason_PermanentError = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_PermanentError;
pub const ScmPhysicalDeviceOpReason_LostWritePersistence = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_LostWritePersistence;
pub const ScmPhysicalDeviceOpReason_FatalError = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_FatalError;
pub const ScmPhysicalDeviceOpReason_DataPersistenceLossImminent = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_DataPersistenceLossImminent;
pub const ScmPhysicalDeviceOpReason_WritePersistenceLossImminent = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_WritePersistenceLossImminent;
pub const ScmPhysicalDeviceOpReason_MediaRemainingSpareBlock = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_MediaRemainingSpareBlock;
pub const ScmPhysicalDeviceOpReason_PerformanceDegradation = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_PerformanceDegradation;
pub const ScmPhysicalDeviceOpReason_ExcessiveTemperature = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_ExcessiveTemperature;
pub const ScmPhysicalDeviceOpReason_Max = enum__SCM_PD_OPERATIONAL_STATUS_REASON.ScmPhysicalDeviceOpReason_Max;
pub const enum__SCM_PD_OPERATIONAL_STATUS_REASON = extern enum {
    ScmPhysicalDeviceOpReason_Unknown = 0,
    ScmPhysicalDeviceOpReason_Media = 1,
    ScmPhysicalDeviceOpReason_ThresholdExceeded = 2,
    ScmPhysicalDeviceOpReason_LostData = 3,
    ScmPhysicalDeviceOpReason_EnergySource = 4,
    ScmPhysicalDeviceOpReason_Configuration = 5,
    ScmPhysicalDeviceOpReason_DeviceController = 6,
    ScmPhysicalDeviceOpReason_MediaController = 7,
    ScmPhysicalDeviceOpReason_Component = 8,
    ScmPhysicalDeviceOpReason_BackgroundOperation = 9,
    ScmPhysicalDeviceOpReason_InvalidFirmware = 10,
    ScmPhysicalDeviceOpReason_HealthCheck = 11,
    ScmPhysicalDeviceOpReason_LostDataPersistence = 12,
    ScmPhysicalDeviceOpReason_DisabledByPlatform = 13,
    ScmPhysicalDeviceOpReason_PermanentError = 14,
    ScmPhysicalDeviceOpReason_LostWritePersistence = 15,
    ScmPhysicalDeviceOpReason_FatalError = 16,
    ScmPhysicalDeviceOpReason_DataPersistenceLossImminent = 17,
    ScmPhysicalDeviceOpReason_WritePersistenceLossImminent = 18,
    ScmPhysicalDeviceOpReason_MediaRemainingSpareBlock = 19,
    ScmPhysicalDeviceOpReason_PerformanceDegradation = 20,
    ScmPhysicalDeviceOpReason_ExcessiveTemperature = 21,
    ScmPhysicalDeviceOpReason_Max = 22,
};
pub const SCM_PD_OPERATIONAL_STATUS_REASON = enum__SCM_PD_OPERATIONAL_STATUS_REASON;
pub const PSCM_PD_OPERATIONAL_STATUS_REASON = [*c]enum__SCM_PD_OPERATIONAL_STATUS_REASON;
pub const struct__SCM_PD_MANAGEMENT_STATUS = extern struct {
    Version: DWORD,
    Size: DWORD,
    Health: SCM_PD_HEALTH_STATUS,
    NumberOfOperationalStatus: DWORD,
    NumberOfAdditionalReasons: DWORD,
    OperationalStatus: [16]SCM_PD_OPERATIONAL_STATUS,
    AdditionalReasons: [1]SCM_PD_OPERATIONAL_STATUS_REASON,
};
pub const SCM_PD_MANAGEMENT_STATUS = struct__SCM_PD_MANAGEMENT_STATUS;
pub const PSCM_PD_MANAGEMENT_STATUS = [*c]struct__SCM_PD_MANAGEMENT_STATUS;
pub const struct__SCM_PD_LOCATION_STRING = extern struct {
    Version: DWORD,
    Size: DWORD,
    Location: [1]WCHAR,
};
pub const SCM_PD_LOCATION_STRING = struct__SCM_PD_LOCATION_STRING;
pub const PSCM_PD_LOCATION_STRING = [*c]struct__SCM_PD_LOCATION_STRING;
pub const struct__SCM_PD_FIRMWARE_DOWNLOAD = extern struct {
    Version: DWORD,
    Size: DWORD,
    Flags: DWORD,
    Slot: BYTE,
    Reserved: [3]BYTE,
    Offset: DWORD64,
    FirmwareImageSizeInBytes: DWORD,
    FirmwareImage: [1]BYTE,
};
pub const SCM_PD_FIRMWARE_DOWNLOAD = struct__SCM_PD_FIRMWARE_DOWNLOAD;
pub const PSCM_PD_FIRMWARE_DOWNLOAD = [*c]struct__SCM_PD_FIRMWARE_DOWNLOAD;
pub const struct__SCM_PD_FIRMWARE_ACTIVATE = extern struct {
    Version: DWORD,
    Size: DWORD,
    Flags: DWORD,
    Slot: BYTE,
};
pub const SCM_PD_FIRMWARE_ACTIVATE = struct__SCM_PD_FIRMWARE_ACTIVATE;
pub const PSCM_PD_FIRMWARE_ACTIVATE = [*c]struct__SCM_PD_FIRMWARE_ACTIVATE;
pub const struct__SCM_PD_PASSTHROUGH_INPUT = extern struct {
    Version: DWORD,
    Size: DWORD,
    ProtocolGuid: GUID,
    DataSize: DWORD,
    Data: [1]BYTE,
};
pub const SCM_PD_PASSTHROUGH_INPUT = struct__SCM_PD_PASSTHROUGH_INPUT;
pub const PSCM_PD_PASSTHROUGH_INPUT = [*c]struct__SCM_PD_PASSTHROUGH_INPUT;
pub const struct__SCM_PD_PASSTHROUGH_OUTPUT = extern struct {
    Version: DWORD,
    Size: DWORD,
    ProtocolGuid: GUID,
    DataSize: DWORD,
    Data: [1]BYTE,
};
pub const SCM_PD_PASSTHROUGH_OUTPUT = struct__SCM_PD_PASSTHROUGH_OUTPUT;
pub const PSCM_PD_PASSTHROUGH_OUTPUT = [*c]struct__SCM_PD_PASSTHROUGH_OUTPUT;
pub const struct__SCM_PD_PASSTHROUGH_INVDIMM_INPUT = extern struct {
    Opcode: DWORD,
    OpcodeParametersLength: DWORD,
    OpcodeParameters: [1]BYTE,
};
pub const SCM_PD_PASSTHROUGH_INVDIMM_INPUT = struct__SCM_PD_PASSTHROUGH_INVDIMM_INPUT;
pub const PSCM_PD_PASSTHROUGH_INVDIMM_INPUT = [*c]struct__SCM_PD_PASSTHROUGH_INVDIMM_INPUT;
pub const struct__SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT = extern struct {
    GeneralStatus: WORD,
    ExtendedStatus: WORD,
    OutputDataLength: DWORD,
    OutputData: [1]BYTE,
};
pub const SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT = struct__SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT;
pub const PSCM_PD_PASSTHROUGH_INVDIMM_OUTPUT = [*c]struct__SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT;
pub const struct__SCM_PD_REINITIALIZE_MEDIA_INPUT = extern struct {
    Version: DWORD,
    Size: DWORD,
    Options: @OpaqueType(),
};
pub const SCM_PD_REINITIALIZE_MEDIA_INPUT = struct__SCM_PD_REINITIALIZE_MEDIA_INPUT;
pub const PSCM_PD_REINITIALIZE_MEDIA_INPUT = [*c]struct__SCM_PD_REINITIALIZE_MEDIA_INPUT;
pub const ScmPhysicalDeviceReinit_Success = enum__SCM_PD_MEDIA_REINITIALIZATION_STATUS.ScmPhysicalDeviceReinit_Success;
pub const ScmPhysicalDeviceReinit_RebootNeeded = enum__SCM_PD_MEDIA_REINITIALIZATION_STATUS.ScmPhysicalDeviceReinit_RebootNeeded;
pub const ScmPhysicalDeviceReinit_ColdBootNeeded = enum__SCM_PD_MEDIA_REINITIALIZATION_STATUS.ScmPhysicalDeviceReinit_ColdBootNeeded;
pub const ScmPhysicalDeviceReinit_Max = enum__SCM_PD_MEDIA_REINITIALIZATION_STATUS.ScmPhysicalDeviceReinit_Max;
pub const enum__SCM_PD_MEDIA_REINITIALIZATION_STATUS = extern enum {
    ScmPhysicalDeviceReinit_Success = 0,
    ScmPhysicalDeviceReinit_RebootNeeded = 1,
    ScmPhysicalDeviceReinit_ColdBootNeeded = 2,
    ScmPhysicalDeviceReinit_Max = 3,
};
pub const SCM_PD_MEDIA_REINITIALIZATION_STATUS = enum__SCM_PD_MEDIA_REINITIALIZATION_STATUS;
pub const PSCM_PD_MEDIA_REINITIALIZATION_STATUS = [*c]enum__SCM_PD_MEDIA_REINITIALIZATION_STATUS;
pub const struct__SCM_PD_REINITIALIZE_MEDIA_OUTPUT = extern struct {
    Version: DWORD,
    Size: DWORD,
    Status: SCM_PD_MEDIA_REINITIALIZATION_STATUS,
};
pub const SCM_PD_REINITIALIZE_MEDIA_OUTPUT = struct__SCM_PD_REINITIALIZE_MEDIA_OUTPUT;
pub const PSCM_PD_REINITIALIZE_MEDIA_OUTPUT = [*c]struct__SCM_PD_REINITIALIZE_MEDIA_OUTPUT;
pub const Unknown = enum__MEDIA_TYPE.Unknown;
pub const F5_1Pt2_512 = enum__MEDIA_TYPE.F5_1Pt2_512;
pub const F3_1Pt44_512 = enum__MEDIA_TYPE.F3_1Pt44_512;
pub const F3_2Pt88_512 = enum__MEDIA_TYPE.F3_2Pt88_512;
pub const F3_20Pt8_512 = enum__MEDIA_TYPE.F3_20Pt8_512;
pub const F3_720_512 = enum__MEDIA_TYPE.F3_720_512;
pub const F5_360_512 = enum__MEDIA_TYPE.F5_360_512;
pub const F5_320_512 = enum__MEDIA_TYPE.F5_320_512;
pub const F5_320_1024 = enum__MEDIA_TYPE.F5_320_1024;
pub const F5_180_512 = enum__MEDIA_TYPE.F5_180_512;
pub const F5_160_512 = enum__MEDIA_TYPE.F5_160_512;
pub const RemovableMedia = enum__MEDIA_TYPE.RemovableMedia;
pub const FixedMedia = enum__MEDIA_TYPE.FixedMedia;
pub const F3_120M_512 = enum__MEDIA_TYPE.F3_120M_512;
pub const F3_640_512 = enum__MEDIA_TYPE.F3_640_512;
pub const F5_640_512 = enum__MEDIA_TYPE.F5_640_512;
pub const F5_720_512 = enum__MEDIA_TYPE.F5_720_512;
pub const F3_1Pt2_512 = enum__MEDIA_TYPE.F3_1Pt2_512;
pub const F3_1Pt23_1024 = enum__MEDIA_TYPE.F3_1Pt23_1024;
pub const F5_1Pt23_1024 = enum__MEDIA_TYPE.F5_1Pt23_1024;
pub const F3_128Mb_512 = enum__MEDIA_TYPE.F3_128Mb_512;
pub const F3_230Mb_512 = enum__MEDIA_TYPE.F3_230Mb_512;
pub const F8_256_128 = enum__MEDIA_TYPE.F8_256_128;
pub const F3_200Mb_512 = enum__MEDIA_TYPE.F3_200Mb_512;
pub const F3_240M_512 = enum__MEDIA_TYPE.F3_240M_512;
pub const F3_32M_512 = enum__MEDIA_TYPE.F3_32M_512;
pub const enum__MEDIA_TYPE = extern enum {
    Unknown,
    F5_1Pt2_512,
    F3_1Pt44_512,
    F3_2Pt88_512,
    F3_20Pt8_512,
    F3_720_512,
    F5_360_512,
    F5_320_512,
    F5_320_1024,
    F5_180_512,
    F5_160_512,
    RemovableMedia,
    FixedMedia,
    F3_120M_512,
    F3_640_512,
    F5_640_512,
    F5_720_512,
    F3_1Pt2_512,
    F3_1Pt23_1024,
    F5_1Pt23_1024,
    F3_128Mb_512,
    F3_230Mb_512,
    F8_256_128,
    F3_200Mb_512,
    F3_240M_512,
    F3_32M_512,
};
pub const MEDIA_TYPE = enum__MEDIA_TYPE;
pub const PMEDIA_TYPE = [*c]enum__MEDIA_TYPE;
pub const struct__FORMAT_PARAMETERS = extern struct {
    MediaType: MEDIA_TYPE,
    StartCylinderNumber: DWORD,
    EndCylinderNumber: DWORD,
    StartHeadNumber: DWORD,
    EndHeadNumber: DWORD,
};
pub const FORMAT_PARAMETERS = struct__FORMAT_PARAMETERS;
pub const PFORMAT_PARAMETERS = [*c]struct__FORMAT_PARAMETERS;
pub const BAD_TRACK_NUMBER = WORD;
pub const PBAD_TRACK_NUMBER = [*c]WORD;
pub const struct__FORMAT_EX_PARAMETERS = extern struct {
    MediaType: MEDIA_TYPE,
    StartCylinderNumber: DWORD,
    EndCylinderNumber: DWORD,
    StartHeadNumber: DWORD,
    EndHeadNumber: DWORD,
    FormatGapLength: WORD,
    SectorsPerTrack: WORD,
    SectorNumber: [1]WORD,
};
pub const FORMAT_EX_PARAMETERS = struct__FORMAT_EX_PARAMETERS;
pub const PFORMAT_EX_PARAMETERS = [*c]struct__FORMAT_EX_PARAMETERS;
pub const struct__DISK_GEOMETRY = extern struct {
    Cylinders: LARGE_INTEGER,
    MediaType: MEDIA_TYPE,
    TracksPerCylinder: DWORD,
    SectorsPerTrack: DWORD,
    BytesPerSector: DWORD,
};
pub const DISK_GEOMETRY = struct__DISK_GEOMETRY;
pub const PDISK_GEOMETRY = [*c]struct__DISK_GEOMETRY;
pub const struct__PARTITION_INFORMATION = extern struct {
    StartingOffset: LARGE_INTEGER,
    PartitionLength: LARGE_INTEGER,
    HiddenSectors: DWORD,
    PartitionNumber: DWORD,
    PartitionType: BYTE,
    BootIndicator: BOOLEAN,
    RecognizedPartition: BOOLEAN,
    RewritePartition: BOOLEAN,
};
pub const PARTITION_INFORMATION = struct__PARTITION_INFORMATION;
pub const PPARTITION_INFORMATION = [*c]struct__PARTITION_INFORMATION;
pub const struct__SET_PARTITION_INFORMATION = extern struct {
    PartitionType: BYTE,
};
pub const SET_PARTITION_INFORMATION = struct__SET_PARTITION_INFORMATION;
pub const PSET_PARTITION_INFORMATION = [*c]struct__SET_PARTITION_INFORMATION;
pub const struct__DRIVE_LAYOUT_INFORMATION = extern struct {
    PartitionCount: DWORD,
    Signature: DWORD,
    PartitionEntry: [1]PARTITION_INFORMATION,
};
pub const DRIVE_LAYOUT_INFORMATION = struct__DRIVE_LAYOUT_INFORMATION;
pub const PDRIVE_LAYOUT_INFORMATION = [*c]struct__DRIVE_LAYOUT_INFORMATION;
pub const struct__VERIFY_INFORMATION = extern struct {
    StartingOffset: LARGE_INTEGER,
    Length: DWORD,
};
pub const VERIFY_INFORMATION = struct__VERIFY_INFORMATION;
pub const PVERIFY_INFORMATION = [*c]struct__VERIFY_INFORMATION;
pub const struct__REASSIGN_BLOCKS = extern struct {
    Reserved: WORD,
    Count: WORD,
    BlockNumber: [1]DWORD,
};
pub const REASSIGN_BLOCKS = struct__REASSIGN_BLOCKS;
pub const PREASSIGN_BLOCKS = [*c]struct__REASSIGN_BLOCKS;
pub const struct__REASSIGN_BLOCKS_EX = extern struct {
    Reserved: WORD,
    Count: WORD,
    BlockNumber: [1]LARGE_INTEGER,
};
pub const REASSIGN_BLOCKS_EX = struct__REASSIGN_BLOCKS_EX;
pub const PREASSIGN_BLOCKS_EX = [*c]struct__REASSIGN_BLOCKS_EX;
pub const PARTITION_STYLE_MBR = enum__PARTITION_STYLE.PARTITION_STYLE_MBR;
pub const PARTITION_STYLE_GPT = enum__PARTITION_STYLE.PARTITION_STYLE_GPT;
pub const PARTITION_STYLE_RAW = enum__PARTITION_STYLE.PARTITION_STYLE_RAW;
pub const enum__PARTITION_STYLE = extern enum {
    PARTITION_STYLE_MBR,
    PARTITION_STYLE_GPT,
    PARTITION_STYLE_RAW,
};
pub const PARTITION_STYLE = enum__PARTITION_STYLE;
pub const struct__PARTITION_INFORMATION_GPT = extern struct {
    PartitionType: GUID,
    PartitionId: GUID,
    Attributes: DWORD64,
    Name: [36]WCHAR,
};
pub const PARTITION_INFORMATION_GPT = struct__PARTITION_INFORMATION_GPT;
pub const PPARTITION_INFORMATION_GPT = [*c]struct__PARTITION_INFORMATION_GPT;
pub const struct__PARTITION_INFORMATION_MBR = extern struct {
    PartitionType: BYTE,
    BootIndicator: BOOLEAN,
    RecognizedPartition: BOOLEAN,
    HiddenSectors: DWORD,
    PartitionId: GUID,
};
pub const PARTITION_INFORMATION_MBR = struct__PARTITION_INFORMATION_MBR;
pub const PPARTITION_INFORMATION_MBR = [*c]struct__PARTITION_INFORMATION_MBR;
pub const SET_PARTITION_INFORMATION_MBR = SET_PARTITION_INFORMATION;
pub const SET_PARTITION_INFORMATION_GPT = PARTITION_INFORMATION_GPT;
pub const struct__SET_PARTITION_INFORMATION_EX = extern struct {
    PartitionStyle: PARTITION_STYLE,
    @"": extern union {
        Mbr: SET_PARTITION_INFORMATION_MBR,
        Gpt: SET_PARTITION_INFORMATION_GPT,
    },
};
pub const SET_PARTITION_INFORMATION_EX = struct__SET_PARTITION_INFORMATION_EX;
pub const PSET_PARTITION_INFORMATION_EX = [*c]struct__SET_PARTITION_INFORMATION_EX;
pub const struct__CREATE_DISK_GPT = extern struct {
    DiskId: GUID,
    MaxPartitionCount: DWORD,
};
pub const CREATE_DISK_GPT = struct__CREATE_DISK_GPT;
pub const PCREATE_DISK_GPT = [*c]struct__CREATE_DISK_GPT;
pub const struct__CREATE_DISK_MBR = extern struct {
    Signature: DWORD,
};
pub const CREATE_DISK_MBR = struct__CREATE_DISK_MBR;
pub const PCREATE_DISK_MBR = [*c]struct__CREATE_DISK_MBR;
pub const struct__CREATE_DISK = extern struct {
    PartitionStyle: PARTITION_STYLE,
    @"": extern union {
        Mbr: CREATE_DISK_MBR,
        Gpt: CREATE_DISK_GPT,
    },
};
pub const CREATE_DISK = struct__CREATE_DISK;
pub const PCREATE_DISK = [*c]struct__CREATE_DISK;
pub const struct__GET_LENGTH_INFORMATION = extern struct {
    Length: LARGE_INTEGER,
};
pub const GET_LENGTH_INFORMATION = struct__GET_LENGTH_INFORMATION;
pub const PGET_LENGTH_INFORMATION = [*c]struct__GET_LENGTH_INFORMATION;
pub const struct__PARTITION_INFORMATION_EX = extern struct {
    PartitionStyle: PARTITION_STYLE,
    StartingOffset: LARGE_INTEGER,
    PartitionLength: LARGE_INTEGER,
    PartitionNumber: DWORD,
    RewritePartition: BOOLEAN,
    IsServicePartition: BOOLEAN,
    @"": extern union {
        Mbr: PARTITION_INFORMATION_MBR,
        Gpt: PARTITION_INFORMATION_GPT,
    },
};
pub const PARTITION_INFORMATION_EX = struct__PARTITION_INFORMATION_EX;
pub const PPARTITION_INFORMATION_EX = [*c]struct__PARTITION_INFORMATION_EX;
pub const struct__DRIVE_LAYOUT_INFORMATION_GPT = extern struct {
    DiskId: GUID,
    StartingUsableOffset: LARGE_INTEGER,
    UsableLength: LARGE_INTEGER,
    MaxPartitionCount: DWORD,
};
pub const DRIVE_LAYOUT_INFORMATION_GPT = struct__DRIVE_LAYOUT_INFORMATION_GPT;
pub const PDRIVE_LAYOUT_INFORMATION_GPT = [*c]struct__DRIVE_LAYOUT_INFORMATION_GPT;
pub const struct__DRIVE_LAYOUT_INFORMATION_MBR = extern struct {
    Signature: DWORD,
    CheckSum: DWORD,
};
pub const DRIVE_LAYOUT_INFORMATION_MBR = struct__DRIVE_LAYOUT_INFORMATION_MBR;
pub const PDRIVE_LAYOUT_INFORMATION_MBR = [*c]struct__DRIVE_LAYOUT_INFORMATION_MBR;
pub const struct__DRIVE_LAYOUT_INFORMATION_EX = extern struct {
    PartitionStyle: DWORD,
    PartitionCount: DWORD,
    @"": extern union {
        Mbr: DRIVE_LAYOUT_INFORMATION_MBR,
        Gpt: DRIVE_LAYOUT_INFORMATION_GPT,
    },
    PartitionEntry: [1]PARTITION_INFORMATION_EX,
};
pub const DRIVE_LAYOUT_INFORMATION_EX = struct__DRIVE_LAYOUT_INFORMATION_EX;
pub const PDRIVE_LAYOUT_INFORMATION_EX = [*c]struct__DRIVE_LAYOUT_INFORMATION_EX;
pub const DetectNone = enum__DETECTION_TYPE.DetectNone;
pub const DetectInt13 = enum__DETECTION_TYPE.DetectInt13;
pub const DetectExInt13 = enum__DETECTION_TYPE.DetectExInt13;
pub const enum__DETECTION_TYPE = extern enum {
    DetectNone,
    DetectInt13,
    DetectExInt13,
};
pub const DETECTION_TYPE = enum__DETECTION_TYPE;
pub const struct__DISK_INT13_INFO = extern struct {
    DriveSelect: WORD,
    MaxCylinders: DWORD,
    SectorsPerTrack: WORD,
    MaxHeads: WORD,
    NumberDrives: WORD,
};
pub const DISK_INT13_INFO = struct__DISK_INT13_INFO;
pub const PDISK_INT13_INFO = [*c]struct__DISK_INT13_INFO;
pub const struct__DISK_EX_INT13_INFO = extern struct {
    ExBufferSize: WORD,
    ExFlags: WORD,
    ExCylinders: DWORD,
    ExHeads: DWORD,
    ExSectorsPerTrack: DWORD,
    ExSectorsPerDrive: DWORD64,
    ExSectorSize: WORD,
    ExReserved: WORD,
};
pub const DISK_EX_INT13_INFO = struct__DISK_EX_INT13_INFO;
pub const PDISK_EX_INT13_INFO = [*c]struct__DISK_EX_INT13_INFO;
pub const struct__DISK_DETECTION_INFO = extern struct {
    SizeOfDetectInfo: DWORD,
    DetectionType: DETECTION_TYPE,
    @"": extern union {
        @"": extern struct {
            Int13: DISK_INT13_INFO,
            ExInt13: DISK_EX_INT13_INFO,
        },
    },
};
pub const DISK_DETECTION_INFO = struct__DISK_DETECTION_INFO;
pub const PDISK_DETECTION_INFO = [*c]struct__DISK_DETECTION_INFO;
pub const struct__DISK_PARTITION_INFO = extern struct {
    SizeOfPartitionInfo: DWORD,
    PartitionStyle: PARTITION_STYLE,
    @"": extern union {
        Mbr: extern struct {
            Signature: DWORD,
            CheckSum: DWORD,
        },
        Gpt: extern struct {
            DiskId: GUID,
        },
    },
};
pub const DISK_PARTITION_INFO = struct__DISK_PARTITION_INFO;
pub const PDISK_PARTITION_INFO = [*c]struct__DISK_PARTITION_INFO;
pub const struct__DISK_GEOMETRY_EX = extern struct {
    Geometry: DISK_GEOMETRY,
    DiskSize: LARGE_INTEGER,
    Data: [1]BYTE,
};
pub const DISK_GEOMETRY_EX = struct__DISK_GEOMETRY_EX;
pub const PDISK_GEOMETRY_EX = [*c]struct__DISK_GEOMETRY_EX;
pub const struct__DISK_CONTROLLER_NUMBER = extern struct {
    ControllerNumber: DWORD,
    DiskNumber: DWORD,
};
pub const DISK_CONTROLLER_NUMBER = struct__DISK_CONTROLLER_NUMBER;
pub const PDISK_CONTROLLER_NUMBER = [*c]struct__DISK_CONTROLLER_NUMBER;
pub const EqualPriority = 0;
pub const KeepPrefetchedData = 1;
pub const KeepReadData = 2;
pub const DISK_CACHE_RETENTION_PRIORITY = extern enum {
    EqualPriority = 0,
    KeepPrefetchedData = 1,
    KeepReadData = 2,
};
pub const struct__DISK_CACHE_INFORMATION = extern struct {
    ParametersSavable: BOOLEAN,
    ReadCacheEnabled: BOOLEAN,
    WriteCacheEnabled: BOOLEAN,
    ReadRetentionPriority: DISK_CACHE_RETENTION_PRIORITY,
    WriteRetentionPriority: DISK_CACHE_RETENTION_PRIORITY,
    DisablePrefetchTransferLength: WORD,
    PrefetchScalar: BOOLEAN,
    @"": extern union {
        ScalarPrefetch: extern struct {
            Minimum: WORD,
            Maximum: WORD,
            MaximumBlocks: WORD,
        },
        BlockPrefetch: extern struct {
            Minimum: WORD,
            Maximum: WORD,
        },
    },
};
pub const DISK_CACHE_INFORMATION = struct__DISK_CACHE_INFORMATION;
pub const PDISK_CACHE_INFORMATION = [*c]struct__DISK_CACHE_INFORMATION;
pub const struct__DISK_GROW_PARTITION = extern struct {
    PartitionNumber: DWORD,
    BytesToGrow: LARGE_INTEGER,
};
pub const DISK_GROW_PARTITION = struct__DISK_GROW_PARTITION;
pub const PDISK_GROW_PARTITION = [*c]struct__DISK_GROW_PARTITION;
pub const struct__HISTOGRAM_BUCKET = extern struct {
    Reads: DWORD,
    Writes: DWORD,
};
pub const HISTOGRAM_BUCKET = struct__HISTOGRAM_BUCKET;
pub const PHISTOGRAM_BUCKET = [*c]struct__HISTOGRAM_BUCKET;
pub const struct__DISK_HISTOGRAM = extern struct {
    DiskSize: LARGE_INTEGER,
    Start: LARGE_INTEGER,
    End: LARGE_INTEGER,
    Average: LARGE_INTEGER,
    AverageRead: LARGE_INTEGER,
    AverageWrite: LARGE_INTEGER,
    Granularity: DWORD,
    Size: DWORD,
    ReadCount: DWORD,
    WriteCount: DWORD,
    Histogram: PHISTOGRAM_BUCKET,
};
pub const DISK_HISTOGRAM = struct__DISK_HISTOGRAM;
pub const PDISK_HISTOGRAM = [*c]struct__DISK_HISTOGRAM;
pub const struct__DISK_PERFORMANCE = extern struct {
    BytesRead: LARGE_INTEGER,
    BytesWritten: LARGE_INTEGER,
    ReadTime: LARGE_INTEGER,
    WriteTime: LARGE_INTEGER,
    IdleTime: LARGE_INTEGER,
    ReadCount: DWORD,
    WriteCount: DWORD,
    QueueDepth: DWORD,
    SplitCount: DWORD,
    QueryTime: LARGE_INTEGER,
    StorageDeviceNumber: DWORD,
    StorageManagerName: [8]WCHAR,
};
pub const DISK_PERFORMANCE = struct__DISK_PERFORMANCE;
pub const PDISK_PERFORMANCE = [*c]struct__DISK_PERFORMANCE;
pub const struct__DISK_RECORD = extern struct {
    ByteOffset: LARGE_INTEGER,
    StartTime: LARGE_INTEGER,
    EndTime: LARGE_INTEGER,
    VirtualAddress: PVOID,
    NumberOfBytes: DWORD,
    DeviceNumber: BYTE,
    ReadRequest: BOOLEAN,
};
pub const DISK_RECORD = struct__DISK_RECORD;
pub const PDISK_RECORD = [*c]struct__DISK_RECORD;
pub const struct__DISK_LOGGING = extern struct {
    Function: BYTE,
    BufferAddress: PVOID,
    BufferSize: DWORD,
};
pub const DISK_LOGGING = struct__DISK_LOGGING;
pub const PDISK_LOGGING = [*c]struct__DISK_LOGGING;
pub const RequestSize = enum__BIN_TYPES.RequestSize;
pub const RequestLocation = enum__BIN_TYPES.RequestLocation;
pub const enum__BIN_TYPES = extern enum {
    RequestSize,
    RequestLocation,
};
pub const BIN_TYPES = enum__BIN_TYPES;
pub const struct__BIN_RANGE = extern struct {
    StartValue: LARGE_INTEGER,
    Length: LARGE_INTEGER,
};
pub const BIN_RANGE = struct__BIN_RANGE;
pub const PBIN_RANGE = [*c]struct__BIN_RANGE;
pub const struct__PERF_BIN = extern struct {
    NumberOfBins: DWORD,
    TypeOfBin: DWORD,
    BinsRanges: [1]BIN_RANGE,
};
pub const PERF_BIN = struct__PERF_BIN;
pub const PPERF_BIN = [*c]struct__PERF_BIN;
pub const struct__BIN_COUNT = extern struct {
    BinRange: BIN_RANGE,
    BinCount: DWORD,
};
pub const BIN_COUNT = struct__BIN_COUNT;
pub const PBIN_COUNT = [*c]struct__BIN_COUNT;
pub const struct__BIN_RESULTS = extern struct {
    NumberOfBins: DWORD,
    BinCounts: [1]BIN_COUNT,
};
pub const BIN_RESULTS = struct__BIN_RESULTS;
pub const PBIN_RESULTS = [*c]struct__BIN_RESULTS;
pub const struct__GETVERSIONINPARAMS = extern struct {
    bVersion: BYTE,
    bRevision: BYTE,
    bReserved: BYTE,
    bIDEDeviceMap: BYTE,
    fCapabilities: DWORD,
    dwReserved: [4]DWORD,
};
pub const GETVERSIONINPARAMS = struct__GETVERSIONINPARAMS;
pub const PGETVERSIONINPARAMS = [*c]struct__GETVERSIONINPARAMS;
pub const LPGETVERSIONINPARAMS = [*c]struct__GETVERSIONINPARAMS;
pub const struct__IDEREGS = extern struct {
    bFeaturesReg: BYTE,
    bSectorCountReg: BYTE,
    bSectorNumberReg: BYTE,
    bCylLowReg: BYTE,
    bCylHighReg: BYTE,
    bDriveHeadReg: BYTE,
    bCommandReg: BYTE,
    bReserved: BYTE,
};
pub const IDEREGS = struct__IDEREGS;
pub const PIDEREGS = [*c]struct__IDEREGS;
pub const LPIDEREGS = [*c]struct__IDEREGS;
pub const struct__SENDCMDINPARAMS = extern struct {
    cBufferSize: DWORD,
    irDriveRegs: IDEREGS,
    bDriveNumber: BYTE,
    bReserved: [3]BYTE,
    dwReserved: [4]DWORD,
    bBuffer: [1]BYTE,
};
pub const SENDCMDINPARAMS = struct__SENDCMDINPARAMS;
pub const PSENDCMDINPARAMS = [*c]struct__SENDCMDINPARAMS;
pub const LPSENDCMDINPARAMS = [*c]struct__SENDCMDINPARAMS;
pub const struct__DRIVERSTATUS = extern struct {
    bDriverError: BYTE,
    bIDEError: BYTE,
    bReserved: [2]BYTE,
    dwReserved: [2]DWORD,
};
pub const DRIVERSTATUS = struct__DRIVERSTATUS;
pub const PDRIVERSTATUS = [*c]struct__DRIVERSTATUS;
pub const LPDRIVERSTATUS = [*c]struct__DRIVERSTATUS;
pub const struct__SENDCMDOUTPARAMS = extern struct {
    cBufferSize: DWORD,
    DriverStatus: DRIVERSTATUS,
    bBuffer: [1]BYTE,
};
pub const SENDCMDOUTPARAMS = struct__SENDCMDOUTPARAMS;
pub const PSENDCMDOUTPARAMS = [*c]struct__SENDCMDOUTPARAMS;
pub const LPSENDCMDOUTPARAMS = [*c]struct__SENDCMDOUTPARAMS;
pub const struct__GET_DISK_ATTRIBUTES = extern struct {
    Version: DWORD,
    Reserved1: DWORD,
    Attributes: DWORDLONG,
};
pub const GET_DISK_ATTRIBUTES = struct__GET_DISK_ATTRIBUTES;
pub const PGET_DISK_ATTRIBUTES = [*c]struct__GET_DISK_ATTRIBUTES;
pub const struct__SET_DISK_ATTRIBUTES = extern struct {
    Version: DWORD,
    Persist: BOOLEAN,
    Reserved1: [3]BYTE,
    Attributes: DWORDLONG,
    AttributesMask: DWORDLONG,
    Reserved2: [4]DWORD,
};
pub const SET_DISK_ATTRIBUTES = struct__SET_DISK_ATTRIBUTES;
pub const PSET_DISK_ATTRIBUTES = [*c]struct__SET_DISK_ATTRIBUTES;
pub const AllElements = enum__ELEMENT_TYPE.AllElements;
pub const ChangerTransport = enum__ELEMENT_TYPE.ChangerTransport;
pub const ChangerSlot = enum__ELEMENT_TYPE.ChangerSlot;
pub const ChangerIEPort = enum__ELEMENT_TYPE.ChangerIEPort;
pub const ChangerDrive = enum__ELEMENT_TYPE.ChangerDrive;
pub const ChangerDoor = enum__ELEMENT_TYPE.ChangerDoor;
pub const ChangerKeypad = enum__ELEMENT_TYPE.ChangerKeypad;
pub const ChangerMaxElement = enum__ELEMENT_TYPE.ChangerMaxElement;
pub const enum__ELEMENT_TYPE = extern enum {
    AllElements,
    ChangerTransport,
    ChangerSlot,
    ChangerIEPort,
    ChangerDrive,
    ChangerDoor,
    ChangerKeypad,
    ChangerMaxElement,
};
pub const ELEMENT_TYPE = enum__ELEMENT_TYPE;
pub const PELEMENT_TYPE = [*c]enum__ELEMENT_TYPE;
pub const struct__CHANGER_ELEMENT = extern struct {
    ElementType: ELEMENT_TYPE,
    ElementAddress: DWORD,
};
pub const CHANGER_ELEMENT = struct__CHANGER_ELEMENT;
pub const PCHANGER_ELEMENT = [*c]struct__CHANGER_ELEMENT;
pub const struct__CHANGER_ELEMENT_LIST = extern struct {
    Element: CHANGER_ELEMENT,
    NumberOfElements: DWORD,
};
pub const CHANGER_ELEMENT_LIST = struct__CHANGER_ELEMENT_LIST;
pub const PCHANGER_ELEMENT_LIST = [*c]struct__CHANGER_ELEMENT_LIST;
pub const struct__GET_CHANGER_PARAMETERS = extern struct {
    Size: DWORD,
    NumberTransportElements: WORD,
    NumberStorageElements: WORD,
    NumberCleanerSlots: WORD,
    NumberIEElements: WORD,
    NumberDataTransferElements: WORD,
    NumberOfDoors: WORD,
    FirstSlotNumber: WORD,
    FirstDriveNumber: WORD,
    FirstTransportNumber: WORD,
    FirstIEPortNumber: WORD,
    FirstCleanerSlotAddress: WORD,
    MagazineSize: WORD,
    DriveCleanTimeout: DWORD,
    Features0: DWORD,
    Features1: DWORD,
    MoveFromTransport: BYTE,
    MoveFromSlot: BYTE,
    MoveFromIePort: BYTE,
    MoveFromDrive: BYTE,
    ExchangeFromTransport: BYTE,
    ExchangeFromSlot: BYTE,
    ExchangeFromIePort: BYTE,
    ExchangeFromDrive: BYTE,
    LockUnlockCapabilities: BYTE,
    PositionCapabilities: BYTE,
    Reserved1: [2]BYTE,
    Reserved2: [2]DWORD,
};
pub const GET_CHANGER_PARAMETERS = struct__GET_CHANGER_PARAMETERS;
pub const PGET_CHANGER_PARAMETERS = [*c]struct__GET_CHANGER_PARAMETERS;
pub const struct__CHANGER_PRODUCT_DATA = extern struct {
    VendorId: [8]BYTE,
    ProductId: [16]BYTE,
    Revision: [4]BYTE,
    SerialNumber: [32]BYTE,
    DeviceType: BYTE,
};
pub const CHANGER_PRODUCT_DATA = struct__CHANGER_PRODUCT_DATA;
pub const PCHANGER_PRODUCT_DATA = [*c]struct__CHANGER_PRODUCT_DATA;
pub const struct__CHANGER_SET_ACCESS = extern struct {
    Element: CHANGER_ELEMENT,
    Control: DWORD,
};
pub const CHANGER_SET_ACCESS = struct__CHANGER_SET_ACCESS;
pub const PCHANGER_SET_ACCESS = [*c]struct__CHANGER_SET_ACCESS;
pub const struct__CHANGER_READ_ELEMENT_STATUS = extern struct {
    ElementList: CHANGER_ELEMENT_LIST,
    VolumeTagInfo: BOOLEAN,
};
pub const CHANGER_READ_ELEMENT_STATUS = struct__CHANGER_READ_ELEMENT_STATUS;
pub const PCHANGER_READ_ELEMENT_STATUS = [*c]struct__CHANGER_READ_ELEMENT_STATUS;
pub const struct__CHANGER_ELEMENT_STATUS = extern struct {
    Element: CHANGER_ELEMENT,
    SrcElementAddress: CHANGER_ELEMENT,
    Flags: DWORD,
    ExceptionCode: DWORD,
    TargetId: BYTE,
    Lun: BYTE,
    Reserved: WORD,
    PrimaryVolumeID: [36]BYTE,
    AlternateVolumeID: [36]BYTE,
};
pub const CHANGER_ELEMENT_STATUS = struct__CHANGER_ELEMENT_STATUS;
pub const PCHANGER_ELEMENT_STATUS = [*c]struct__CHANGER_ELEMENT_STATUS;
pub const struct__CHANGER_ELEMENT_STATUS_EX = extern struct {
    Element: CHANGER_ELEMENT,
    SrcElementAddress: CHANGER_ELEMENT,
    Flags: DWORD,
    ExceptionCode: DWORD,
    TargetId: BYTE,
    Lun: BYTE,
    Reserved: WORD,
    PrimaryVolumeID: [36]BYTE,
    AlternateVolumeID: [36]BYTE,
    VendorIdentification: [8]BYTE,
    ProductIdentification: [16]BYTE,
    SerialNumber: [32]BYTE,
};
pub const CHANGER_ELEMENT_STATUS_EX = struct__CHANGER_ELEMENT_STATUS_EX;
pub const PCHANGER_ELEMENT_STATUS_EX = [*c]struct__CHANGER_ELEMENT_STATUS_EX;
pub const struct__CHANGER_INITIALIZE_ELEMENT_STATUS = extern struct {
    ElementList: CHANGER_ELEMENT_LIST,
    BarCodeScan: BOOLEAN,
};
pub const CHANGER_INITIALIZE_ELEMENT_STATUS = struct__CHANGER_INITIALIZE_ELEMENT_STATUS;
pub const PCHANGER_INITIALIZE_ELEMENT_STATUS = [*c]struct__CHANGER_INITIALIZE_ELEMENT_STATUS;
pub const struct__CHANGER_SET_POSITION = extern struct {
    Transport: CHANGER_ELEMENT,
    Destination: CHANGER_ELEMENT,
    Flip: BOOLEAN,
};
pub const CHANGER_SET_POSITION = struct__CHANGER_SET_POSITION;
pub const PCHANGER_SET_POSITION = [*c]struct__CHANGER_SET_POSITION;
pub const struct__CHANGER_EXCHANGE_MEDIUM = extern struct {
    Transport: CHANGER_ELEMENT,
    Source: CHANGER_ELEMENT,
    Destination1: CHANGER_ELEMENT,
    Destination2: CHANGER_ELEMENT,
    Flip1: BOOLEAN,
    Flip2: BOOLEAN,
};
pub const CHANGER_EXCHANGE_MEDIUM = struct__CHANGER_EXCHANGE_MEDIUM;
pub const PCHANGER_EXCHANGE_MEDIUM = [*c]struct__CHANGER_EXCHANGE_MEDIUM;
pub const struct__CHANGER_MOVE_MEDIUM = extern struct {
    Transport: CHANGER_ELEMENT,
    Source: CHANGER_ELEMENT,
    Destination: CHANGER_ELEMENT,
    Flip: BOOLEAN,
};
pub const CHANGER_MOVE_MEDIUM = struct__CHANGER_MOVE_MEDIUM;
pub const PCHANGER_MOVE_MEDIUM = [*c]struct__CHANGER_MOVE_MEDIUM;
pub const struct__CHANGER_SEND_VOLUME_TAG_INFORMATION = extern struct {
    StartingElement: CHANGER_ELEMENT,
    ActionCode: DWORD,
    VolumeIDTemplate: [40]BYTE,
};
pub const CHANGER_SEND_VOLUME_TAG_INFORMATION = struct__CHANGER_SEND_VOLUME_TAG_INFORMATION;
pub const PCHANGER_SEND_VOLUME_TAG_INFORMATION = [*c]struct__CHANGER_SEND_VOLUME_TAG_INFORMATION;
pub const struct__READ_ELEMENT_ADDRESS_INFO = extern struct {
    NumberOfElements: DWORD,
    ElementStatus: [1]CHANGER_ELEMENT_STATUS,
};
pub const READ_ELEMENT_ADDRESS_INFO = struct__READ_ELEMENT_ADDRESS_INFO;
pub const PREAD_ELEMENT_ADDRESS_INFO = [*c]struct__READ_ELEMENT_ADDRESS_INFO;
pub const DeviceProblemNone = enum__CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemNone;
pub const DeviceProblemHardware = enum__CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemHardware;
pub const DeviceProblemCHMError = enum__CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemCHMError;
pub const DeviceProblemDoorOpen = enum__CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemDoorOpen;
pub const DeviceProblemCalibrationError = enum__CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemCalibrationError;
pub const DeviceProblemTargetFailure = enum__CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemTargetFailure;
pub const DeviceProblemCHMMoveError = enum__CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemCHMMoveError;
pub const DeviceProblemCHMZeroError = enum__CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemCHMZeroError;
pub const DeviceProblemCartridgeInsertError = enum__CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemCartridgeInsertError;
pub const DeviceProblemPositionError = enum__CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemPositionError;
pub const DeviceProblemSensorError = enum__CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemSensorError;
pub const DeviceProblemCartridgeEjectError = enum__CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemCartridgeEjectError;
pub const DeviceProblemGripperError = enum__CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemGripperError;
pub const DeviceProblemDriveError = enum__CHANGER_DEVICE_PROBLEM_TYPE.DeviceProblemDriveError;
pub const enum__CHANGER_DEVICE_PROBLEM_TYPE = extern enum {
    DeviceProblemNone,
    DeviceProblemHardware,
    DeviceProblemCHMError,
    DeviceProblemDoorOpen,
    DeviceProblemCalibrationError,
    DeviceProblemTargetFailure,
    DeviceProblemCHMMoveError,
    DeviceProblemCHMZeroError,
    DeviceProblemCartridgeInsertError,
    DeviceProblemPositionError,
    DeviceProblemSensorError,
    DeviceProblemCartridgeEjectError,
    DeviceProblemGripperError,
    DeviceProblemDriveError,
};
pub const CHANGER_DEVICE_PROBLEM_TYPE = enum__CHANGER_DEVICE_PROBLEM_TYPE;
pub const PCHANGER_DEVICE_PROBLEM_TYPE = [*c]enum__CHANGER_DEVICE_PROBLEM_TYPE;
pub const struct__PATHNAME_BUFFER = extern struct {
    PathNameLength: DWORD,
    Name: [1]WCHAR,
};
pub const PATHNAME_BUFFER = struct__PATHNAME_BUFFER;
pub const PPATHNAME_BUFFER = [*c]struct__PATHNAME_BUFFER;
pub const struct__FSCTL_QUERY_FAT_BPB_BUFFER = extern struct {
    First0x24BytesOfBootSector: [36]BYTE,
};
pub const FSCTL_QUERY_FAT_BPB_BUFFER = struct__FSCTL_QUERY_FAT_BPB_BUFFER;
pub const PFSCTL_QUERY_FAT_BPB_BUFFER = [*c]struct__FSCTL_QUERY_FAT_BPB_BUFFER;
pub const NTFS_VOLUME_DATA_BUFFER = extern struct {
    VolumeSerialNumber: LARGE_INTEGER,
    NumberSectors: LARGE_INTEGER,
    TotalClusters: LARGE_INTEGER,
    FreeClusters: LARGE_INTEGER,
    TotalReserved: LARGE_INTEGER,
    BytesPerSector: DWORD,
    BytesPerCluster: DWORD,
    BytesPerFileRecordSegment: DWORD,
    ClustersPerFileRecordSegment: DWORD,
    MftValidDataLength: LARGE_INTEGER,
    MftStartLcn: LARGE_INTEGER,
    Mft2StartLcn: LARGE_INTEGER,
    MftZoneStart: LARGE_INTEGER,
    MftZoneEnd: LARGE_INTEGER,
};
pub const PNTFS_VOLUME_DATA_BUFFER = [*c]extern struct {
    VolumeSerialNumber: LARGE_INTEGER,
    NumberSectors: LARGE_INTEGER,
    TotalClusters: LARGE_INTEGER,
    FreeClusters: LARGE_INTEGER,
    TotalReserved: LARGE_INTEGER,
    BytesPerSector: DWORD,
    BytesPerCluster: DWORD,
    BytesPerFileRecordSegment: DWORD,
    ClustersPerFileRecordSegment: DWORD,
    MftValidDataLength: LARGE_INTEGER,
    MftStartLcn: LARGE_INTEGER,
    Mft2StartLcn: LARGE_INTEGER,
    MftZoneStart: LARGE_INTEGER,
    MftZoneEnd: LARGE_INTEGER,
};
pub const NTFS_EXTENDED_VOLUME_DATA = extern struct {
    ByteCount: DWORD,
    MajorVersion: WORD,
    MinorVersion: WORD,
    BytesPerPhysicalSector: DWORD,
    LfsMajorVersion: WORD,
    LfsMinorVersion: WORD,
    MaxDeviceTrimExtentCount: DWORD,
    MaxDeviceTrimByteCount: DWORD,
    MaxVolumeTrimExtentCount: DWORD,
    MaxVolumeTrimByteCount: DWORD,
};
pub const PNTFS_EXTENDED_VOLUME_DATA = [*c]extern struct {
    ByteCount: DWORD,
    MajorVersion: WORD,
    MinorVersion: WORD,
    BytesPerPhysicalSector: DWORD,
    LfsMajorVersion: WORD,
    LfsMinorVersion: WORD,
    MaxDeviceTrimExtentCount: DWORD,
    MaxDeviceTrimByteCount: DWORD,
    MaxVolumeTrimExtentCount: DWORD,
    MaxVolumeTrimByteCount: DWORD,
};
pub const REFS_VOLUME_DATA_BUFFER = extern struct {
    ByteCount: DWORD,
    MajorVersion: DWORD,
    MinorVersion: DWORD,
    BytesPerPhysicalSector: DWORD,
    VolumeSerialNumber: LARGE_INTEGER,
    NumberSectors: LARGE_INTEGER,
    TotalClusters: LARGE_INTEGER,
    FreeClusters: LARGE_INTEGER,
    TotalReserved: LARGE_INTEGER,
    BytesPerSector: DWORD,
    BytesPerCluster: DWORD,
    MaximumSizeOfResidentFile: LARGE_INTEGER,
    Reserved: [10]LARGE_INTEGER,
};
pub const PREFS_VOLUME_DATA_BUFFER = [*c]extern struct {
    ByteCount: DWORD,
    MajorVersion: DWORD,
    MinorVersion: DWORD,
    BytesPerPhysicalSector: DWORD,
    VolumeSerialNumber: LARGE_INTEGER,
    NumberSectors: LARGE_INTEGER,
    TotalClusters: LARGE_INTEGER,
    FreeClusters: LARGE_INTEGER,
    TotalReserved: LARGE_INTEGER,
    BytesPerSector: DWORD,
    BytesPerCluster: DWORD,
    MaximumSizeOfResidentFile: LARGE_INTEGER,
    Reserved: [10]LARGE_INTEGER,
};
pub const STARTING_LCN_INPUT_BUFFER = extern struct {
    StartingLcn: LARGE_INTEGER,
};
pub const PSTARTING_LCN_INPUT_BUFFER = [*c]extern struct {
    StartingLcn: LARGE_INTEGER,
};
pub const STARTING_LCN_INPUT_BUFFER_EX = extern struct {
    StartingLcn: LARGE_INTEGER,
    Flags: DWORD,
};
pub const PSTARTING_LCN_INPUT_BUFFER_EX = [*c]extern struct {
    StartingLcn: LARGE_INTEGER,
    Flags: DWORD,
};
pub const VOLUME_BITMAP_BUFFER = extern struct {
    StartingLcn: LARGE_INTEGER,
    BitmapSize: LARGE_INTEGER,
    Buffer: [1]BYTE,
};
pub const PVOLUME_BITMAP_BUFFER = [*c]extern struct {
    StartingLcn: LARGE_INTEGER,
    BitmapSize: LARGE_INTEGER,
    Buffer: [1]BYTE,
};
pub const STARTING_VCN_INPUT_BUFFER = extern struct {
    StartingVcn: LARGE_INTEGER,
};
pub const PSTARTING_VCN_INPUT_BUFFER = [*c]extern struct {
    StartingVcn: LARGE_INTEGER,
};
pub const struct_RETRIEVAL_POINTERS_BUFFER = extern struct {
    ExtentCount: DWORD,
    StartingVcn: LARGE_INTEGER,
    Extents: [1]extern struct {
        NextVcn: LARGE_INTEGER,
        Lcn: LARGE_INTEGER,
    },
};
pub const RETRIEVAL_POINTERS_BUFFER = struct_RETRIEVAL_POINTERS_BUFFER;
pub const PRETRIEVAL_POINTERS_BUFFER = [*c]struct_RETRIEVAL_POINTERS_BUFFER;
pub const struct_RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER = extern struct {
    ExtentCount: DWORD,
    StartingVcn: LARGE_INTEGER,
    Extents: [1]extern struct {
        NextVcn: LARGE_INTEGER,
        Lcn: LARGE_INTEGER,
        ReferenceCount: DWORD,
    },
};
pub const RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER = struct_RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER;
pub const PRETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER = [*c]struct_RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER;
pub const struct_RETRIEVAL_POINTER_COUNT = extern struct {
    ExtentCount: DWORD,
};
pub const RETRIEVAL_POINTER_COUNT = struct_RETRIEVAL_POINTER_COUNT;
pub const PRETRIEVAL_POINTER_COUNT = [*c]struct_RETRIEVAL_POINTER_COUNT;
pub const NTFS_FILE_RECORD_INPUT_BUFFER = extern struct {
    FileReferenceNumber: LARGE_INTEGER,
};
pub const PNTFS_FILE_RECORD_INPUT_BUFFER = [*c]extern struct {
    FileReferenceNumber: LARGE_INTEGER,
};
pub const NTFS_FILE_RECORD_OUTPUT_BUFFER = extern struct {
    FileReferenceNumber: LARGE_INTEGER,
    FileRecordLength: DWORD,
    FileRecordBuffer: [1]BYTE,
};
pub const PNTFS_FILE_RECORD_OUTPUT_BUFFER = [*c]extern struct {
    FileReferenceNumber: LARGE_INTEGER,
    FileRecordLength: DWORD,
    FileRecordBuffer: [1]BYTE,
};
pub const MOVE_FILE_DATA = extern struct {
    FileHandle: HANDLE,
    StartingVcn: LARGE_INTEGER,
    StartingLcn: LARGE_INTEGER,
    ClusterCount: DWORD,
};
pub const PMOVE_FILE_DATA = [*c]extern struct {
    FileHandle: HANDLE,
    StartingVcn: LARGE_INTEGER,
    StartingLcn: LARGE_INTEGER,
    ClusterCount: DWORD,
};
pub const MOVE_FILE_RECORD_DATA = extern struct {
    FileHandle: HANDLE,
    SourceFileRecord: LARGE_INTEGER,
    TargetFileRecord: LARGE_INTEGER,
};
pub const PMOVE_FILE_RECORD_DATA = [*c]extern struct {
    FileHandle: HANDLE,
    SourceFileRecord: LARGE_INTEGER,
    TargetFileRecord: LARGE_INTEGER,
};
pub const struct__MOVE_FILE_DATA32 = extern struct {
    FileHandle: UINT32,
    StartingVcn: LARGE_INTEGER,
    StartingLcn: LARGE_INTEGER,
    ClusterCount: DWORD,
};
pub const MOVE_FILE_DATA32 = struct__MOVE_FILE_DATA32;
pub const PMOVE_FILE_DATA32 = [*c]struct__MOVE_FILE_DATA32;
pub const FIND_BY_SID_DATA = extern struct {
    Restart: DWORD,
    Sid: SID,
};
pub const PFIND_BY_SID_DATA = [*c]extern struct {
    Restart: DWORD,
    Sid: SID,
};
pub const FIND_BY_SID_OUTPUT = extern struct {
    NextEntryOffset: DWORD,
    FileIndex: DWORD,
    FileNameLength: DWORD,
    FileName: [1]WCHAR,
};
pub const PFIND_BY_SID_OUTPUT = [*c]extern struct {
    NextEntryOffset: DWORD,
    FileIndex: DWORD,
    FileNameLength: DWORD,
    FileName: [1]WCHAR,
};
pub const MFT_ENUM_DATA_V0 = extern struct {
    StartFileReferenceNumber: DWORDLONG,
    LowUsn: USN,
    HighUsn: USN,
};
pub const PMFT_ENUM_DATA_V0 = [*c]extern struct {
    StartFileReferenceNumber: DWORDLONG,
    LowUsn: USN,
    HighUsn: USN,
};
pub const MFT_ENUM_DATA_V1 = extern struct {
    StartFileReferenceNumber: DWORDLONG,
    LowUsn: USN,
    HighUsn: USN,
    MinMajorVersion: WORD,
    MaxMajorVersion: WORD,
};
pub const PMFT_ENUM_DATA_V1 = [*c]extern struct {
    StartFileReferenceNumber: DWORDLONG,
    LowUsn: USN,
    HighUsn: USN,
    MinMajorVersion: WORD,
    MaxMajorVersion: WORD,
};
pub const MFT_ENUM_DATA = MFT_ENUM_DATA_V1;
pub const PMFT_ENUM_DATA = [*c]MFT_ENUM_DATA_V1;
pub const CREATE_USN_JOURNAL_DATA = extern struct {
    MaximumSize: DWORDLONG,
    AllocationDelta: DWORDLONG,
};
pub const PCREATE_USN_JOURNAL_DATA = [*c]extern struct {
    MaximumSize: DWORDLONG,
    AllocationDelta: DWORDLONG,
};
pub const READ_FILE_USN_DATA = extern struct {
    MinMajorVersion: WORD,
    MaxMajorVersion: WORD,
};
pub const PREAD_FILE_USN_DATA = [*c]extern struct {
    MinMajorVersion: WORD,
    MaxMajorVersion: WORD,
};
pub const READ_USN_JOURNAL_DATA_V0 = extern struct {
    StartUsn: USN,
    ReasonMask: DWORD,
    ReturnOnlyOnClose: DWORD,
    Timeout: DWORDLONG,
    BytesToWaitFor: DWORDLONG,
    UsnJournalID: DWORDLONG,
};
pub const PREAD_USN_JOURNAL_DATA_V0 = [*c]extern struct {
    StartUsn: USN,
    ReasonMask: DWORD,
    ReturnOnlyOnClose: DWORD,
    Timeout: DWORDLONG,
    BytesToWaitFor: DWORDLONG,
    UsnJournalID: DWORDLONG,
};
pub const READ_USN_JOURNAL_DATA_V1 = extern struct {
    StartUsn: USN,
    ReasonMask: DWORD,
    ReturnOnlyOnClose: DWORD,
    Timeout: DWORDLONG,
    BytesToWaitFor: DWORDLONG,
    UsnJournalID: DWORDLONG,
    MinMajorVersion: WORD,
    MaxMajorVersion: WORD,
};
pub const PREAD_USN_JOURNAL_DATA_V1 = [*c]extern struct {
    StartUsn: USN,
    ReasonMask: DWORD,
    ReturnOnlyOnClose: DWORD,
    Timeout: DWORDLONG,
    BytesToWaitFor: DWORDLONG,
    UsnJournalID: DWORDLONG,
    MinMajorVersion: WORD,
    MaxMajorVersion: WORD,
};
pub const READ_USN_JOURNAL_DATA = READ_USN_JOURNAL_DATA_V1;
pub const PREAD_USN_JOURNAL_DATA = [*c]READ_USN_JOURNAL_DATA_V1;
pub const USN_TRACK_MODIFIED_RANGES = extern struct {
    Flags: DWORD,
    Unused: DWORD,
    ChunkSize: DWORDLONG,
    FileSizeThreshold: LONGLONG,
};
pub const PUSN_TRACK_MODIFIED_RANGES = [*c]extern struct {
    Flags: DWORD,
    Unused: DWORD,
    ChunkSize: DWORDLONG,
    FileSizeThreshold: LONGLONG,
};
pub const USN_RANGE_TRACK_OUTPUT = extern struct {
    Usn: USN,
};
pub const PUSN_RANGE_TRACK_OUTPUT = [*c]extern struct {
    Usn: USN,
};
pub const USN_RECORD_V2 = extern struct {
    RecordLength: DWORD,
    MajorVersion: WORD,
    MinorVersion: WORD,
    FileReferenceNumber: DWORDLONG,
    ParentFileReferenceNumber: DWORDLONG,
    Usn: USN,
    TimeStamp: LARGE_INTEGER,
    Reason: DWORD,
    SourceInfo: DWORD,
    SecurityId: DWORD,
    FileAttributes: DWORD,
    FileNameLength: WORD,
    FileNameOffset: WORD,
    FileName: [1]WCHAR,
};
pub const PUSN_RECORD_V2 = [*c]extern struct {
    RecordLength: DWORD,
    MajorVersion: WORD,
    MinorVersion: WORD,
    FileReferenceNumber: DWORDLONG,
    ParentFileReferenceNumber: DWORDLONG,
    Usn: USN,
    TimeStamp: LARGE_INTEGER,
    Reason: DWORD,
    SourceInfo: DWORD,
    SecurityId: DWORD,
    FileAttributes: DWORD,
    FileNameLength: WORD,
    FileNameOffset: WORD,
    FileName: [1]WCHAR,
};
pub const USN_RECORD_V3 = extern struct {
    RecordLength: DWORD,
    MajorVersion: WORD,
    MinorVersion: WORD,
    FileReferenceNumber: FILE_ID_128,
    ParentFileReferenceNumber: FILE_ID_128,
    Usn: USN,
    TimeStamp: LARGE_INTEGER,
    Reason: DWORD,
    SourceInfo: DWORD,
    SecurityId: DWORD,
    FileAttributes: DWORD,
    FileNameLength: WORD,
    FileNameOffset: WORD,
    FileName: [1]WCHAR,
};
pub const PUSN_RECORD_V3 = [*c]extern struct {
    RecordLength: DWORD,
    MajorVersion: WORD,
    MinorVersion: WORD,
    FileReferenceNumber: FILE_ID_128,
    ParentFileReferenceNumber: FILE_ID_128,
    Usn: USN,
    TimeStamp: LARGE_INTEGER,
    Reason: DWORD,
    SourceInfo: DWORD,
    SecurityId: DWORD,
    FileAttributes: DWORD,
    FileNameLength: WORD,
    FileNameOffset: WORD,
    FileName: [1]WCHAR,
};
pub const USN_RECORD = USN_RECORD_V2;
pub const PUSN_RECORD = [*c]USN_RECORD_V2;
pub const USN_RECORD_COMMON_HEADER = extern struct {
    RecordLength: DWORD,
    MajorVersion: WORD,
    MinorVersion: WORD,
};
pub const PUSN_RECORD_COMMON_HEADER = [*c]extern struct {
    RecordLength: DWORD,
    MajorVersion: WORD,
    MinorVersion: WORD,
};
pub const USN_RECORD_EXTENT = extern struct {
    Offset: LONGLONG,
    Length: LONGLONG,
};
pub const PUSN_RECORD_EXTENT = [*c]extern struct {
    Offset: LONGLONG,
    Length: LONGLONG,
};
pub const USN_RECORD_V4 = extern struct {
    Header: USN_RECORD_COMMON_HEADER,
    FileReferenceNumber: FILE_ID_128,
    ParentFileReferenceNumber: FILE_ID_128,
    Usn: USN,
    Reason: DWORD,
    SourceInfo: DWORD,
    RemainingExtents: DWORD,
    NumberOfExtents: WORD,
    ExtentSize: WORD,
    Extents: [1]USN_RECORD_EXTENT,
};
pub const PUSN_RECORD_V4 = [*c]extern struct {
    Header: USN_RECORD_COMMON_HEADER,
    FileReferenceNumber: FILE_ID_128,
    ParentFileReferenceNumber: FILE_ID_128,
    Usn: USN,
    Reason: DWORD,
    SourceInfo: DWORD,
    RemainingExtents: DWORD,
    NumberOfExtents: WORD,
    ExtentSize: WORD,
    Extents: [1]USN_RECORD_EXTENT,
};
pub const USN_RECORD_UNION = extern union {
    Header: USN_RECORD_COMMON_HEADER,
    V2: USN_RECORD_V2,
    V3: USN_RECORD_V3,
    V4: USN_RECORD_V4,
};
pub const PUSN_RECORD_UNION = [*c]extern union {
    Header: USN_RECORD_COMMON_HEADER,
    V2: USN_RECORD_V2,
    V3: USN_RECORD_V3,
    V4: USN_RECORD_V4,
};
pub const USN_JOURNAL_DATA_V0 = extern struct {
    UsnJournalID: DWORDLONG,
    FirstUsn: USN,
    NextUsn: USN,
    LowestValidUsn: USN,
    MaxUsn: USN,
    MaximumSize: DWORDLONG,
    AllocationDelta: DWORDLONG,
};
pub const PUSN_JOURNAL_DATA_V0 = [*c]extern struct {
    UsnJournalID: DWORDLONG,
    FirstUsn: USN,
    NextUsn: USN,
    LowestValidUsn: USN,
    MaxUsn: USN,
    MaximumSize: DWORDLONG,
    AllocationDelta: DWORDLONG,
};
pub const USN_JOURNAL_DATA_V1 = extern struct {
    UsnJournalID: DWORDLONG,
    FirstUsn: USN,
    NextUsn: USN,
    LowestValidUsn: USN,
    MaxUsn: USN,
    MaximumSize: DWORDLONG,
    AllocationDelta: DWORDLONG,
    MinSupportedMajorVersion: WORD,
    MaxSupportedMajorVersion: WORD,
};
pub const PUSN_JOURNAL_DATA_V1 = [*c]extern struct {
    UsnJournalID: DWORDLONG,
    FirstUsn: USN,
    NextUsn: USN,
    LowestValidUsn: USN,
    MaxUsn: USN,
    MaximumSize: DWORDLONG,
    AllocationDelta: DWORDLONG,
    MinSupportedMajorVersion: WORD,
    MaxSupportedMajorVersion: WORD,
};
pub const USN_JOURNAL_DATA_V2 = extern struct {
    UsnJournalID: DWORDLONG,
    FirstUsn: USN,
    NextUsn: USN,
    LowestValidUsn: USN,
    MaxUsn: USN,
    MaximumSize: DWORDLONG,
    AllocationDelta: DWORDLONG,
    MinSupportedMajorVersion: WORD,
    MaxSupportedMajorVersion: WORD,
    Flags: DWORD,
    RangeTrackChunkSize: DWORDLONG,
    RangeTrackFileSizeThreshold: LONGLONG,
};
pub const PUSN_JOURNAL_DATA_V2 = [*c]extern struct {
    UsnJournalID: DWORDLONG,
    FirstUsn: USN,
    NextUsn: USN,
    LowestValidUsn: USN,
    MaxUsn: USN,
    MaximumSize: DWORDLONG,
    AllocationDelta: DWORDLONG,
    MinSupportedMajorVersion: WORD,
    MaxSupportedMajorVersion: WORD,
    Flags: DWORD,
    RangeTrackChunkSize: DWORDLONG,
    RangeTrackFileSizeThreshold: LONGLONG,
};
pub const USN_JOURNAL_DATA = USN_JOURNAL_DATA_V1;
pub const PUSN_JOURNAL_DATA = [*c]USN_JOURNAL_DATA_V1;
pub const DELETE_USN_JOURNAL_DATA = extern struct {
    UsnJournalID: DWORDLONG,
    DeleteFlags: DWORD,
};
pub const PDELETE_USN_JOURNAL_DATA = [*c]extern struct {
    UsnJournalID: DWORDLONG,
    DeleteFlags: DWORD,
};
pub const MARK_HANDLE_INFO = extern struct {
    @"": extern union {
        UsnSourceInfo: DWORD,
        CopyNumber: DWORD,
    },
    VolumeHandle: HANDLE,
    HandleInfo: DWORD,
};
pub const PMARK_HANDLE_INFO = [*c]extern struct {
    @"": extern union {
        UsnSourceInfo: DWORD,
        CopyNumber: DWORD,
    },
    VolumeHandle: HANDLE,
    HandleInfo: DWORD,
};
pub const MARK_HANDLE_INFO32 = extern struct {
    @"": extern union {
        UsnSourceInfo: DWORD,
        CopyNumber: DWORD,
    },
    VolumeHandle: UINT32,
    HandleInfo: DWORD,
};
pub const PMARK_HANDLE_INFO32 = [*c]extern struct {
    @"": extern union {
        UsnSourceInfo: DWORD,
        CopyNumber: DWORD,
    },
    VolumeHandle: UINT32,
    HandleInfo: DWORD,
};
pub const BULK_SECURITY_TEST_DATA = extern struct {
    DesiredAccess: ACCESS_MASK,
    SecurityIds: [1]DWORD,
};
pub const PBULK_SECURITY_TEST_DATA = [*c]extern struct {
    DesiredAccess: ACCESS_MASK,
    SecurityIds: [1]DWORD,
};
pub const struct__FILE_PREFETCH = extern struct {
    Type: DWORD,
    Count: DWORD,
    Prefetch: [1]DWORDLONG,
};
pub const FILE_PREFETCH = struct__FILE_PREFETCH;
pub const PFILE_PREFETCH = [*c]struct__FILE_PREFETCH;
pub const struct__FILE_PREFETCH_EX = extern struct {
    Type: DWORD,
    Count: DWORD,
    Context: PVOID,
    Prefetch: [1]DWORDLONG,
};
pub const FILE_PREFETCH_EX = struct__FILE_PREFETCH_EX;
pub const PFILE_PREFETCH_EX = [*c]struct__FILE_PREFETCH_EX;
pub const struct__FILESYSTEM_STATISTICS = extern struct {
    FileSystemType: WORD,
    Version: WORD,
    SizeOfCompleteStructure: DWORD,
    UserFileReads: DWORD,
    UserFileReadBytes: DWORD,
    UserDiskReads: DWORD,
    UserFileWrites: DWORD,
    UserFileWriteBytes: DWORD,
    UserDiskWrites: DWORD,
    MetaDataReads: DWORD,
    MetaDataReadBytes: DWORD,
    MetaDataDiskReads: DWORD,
    MetaDataWrites: DWORD,
    MetaDataWriteBytes: DWORD,
    MetaDataDiskWrites: DWORD,
};
pub const FILESYSTEM_STATISTICS = struct__FILESYSTEM_STATISTICS;
pub const PFILESYSTEM_STATISTICS = [*c]struct__FILESYSTEM_STATISTICS;
pub const struct__FAT_STATISTICS = extern struct {
    CreateHits: DWORD,
    SuccessfulCreates: DWORD,
    FailedCreates: DWORD,
    NonCachedReads: DWORD,
    NonCachedReadBytes: DWORD,
    NonCachedWrites: DWORD,
    NonCachedWriteBytes: DWORD,
    NonCachedDiskReads: DWORD,
    NonCachedDiskWrites: DWORD,
};
pub const FAT_STATISTICS = struct__FAT_STATISTICS;
pub const PFAT_STATISTICS = [*c]struct__FAT_STATISTICS;
pub const struct__EXFAT_STATISTICS = extern struct {
    CreateHits: DWORD,
    SuccessfulCreates: DWORD,
    FailedCreates: DWORD,
    NonCachedReads: DWORD,
    NonCachedReadBytes: DWORD,
    NonCachedWrites: DWORD,
    NonCachedWriteBytes: DWORD,
    NonCachedDiskReads: DWORD,
    NonCachedDiskWrites: DWORD,
};
pub const EXFAT_STATISTICS = struct__EXFAT_STATISTICS;
pub const PEXFAT_STATISTICS = [*c]struct__EXFAT_STATISTICS;
pub const struct__NTFS_STATISTICS = extern struct {
    LogFileFullExceptions: DWORD,
    OtherExceptions: DWORD,
    MftReads: DWORD,
    MftReadBytes: DWORD,
    MftWrites: DWORD,
    MftWriteBytes: DWORD,
    MftWritesUserLevel: extern struct {
        Write: WORD,
        Create: WORD,
        SetInfo: WORD,
        Flush: WORD,
    },
    MftWritesFlushForLogFileFull: WORD,
    MftWritesLazyWriter: WORD,
    MftWritesUserRequest: WORD,
    Mft2Writes: DWORD,
    Mft2WriteBytes: DWORD,
    Mft2WritesUserLevel: extern struct {
        Write: WORD,
        Create: WORD,
        SetInfo: WORD,
        Flush: WORD,
    },
    Mft2WritesFlushForLogFileFull: WORD,
    Mft2WritesLazyWriter: WORD,
    Mft2WritesUserRequest: WORD,
    RootIndexReads: DWORD,
    RootIndexReadBytes: DWORD,
    RootIndexWrites: DWORD,
    RootIndexWriteBytes: DWORD,
    BitmapReads: DWORD,
    BitmapReadBytes: DWORD,
    BitmapWrites: DWORD,
    BitmapWriteBytes: DWORD,
    BitmapWritesFlushForLogFileFull: WORD,
    BitmapWritesLazyWriter: WORD,
    BitmapWritesUserRequest: WORD,
    BitmapWritesUserLevel: extern struct {
        Write: WORD,
        Create: WORD,
        SetInfo: WORD,
    },
    MftBitmapReads: DWORD,
    MftBitmapReadBytes: DWORD,
    MftBitmapWrites: DWORD,
    MftBitmapWriteBytes: DWORD,
    MftBitmapWritesFlushForLogFileFull: WORD,
    MftBitmapWritesLazyWriter: WORD,
    MftBitmapWritesUserRequest: WORD,
    MftBitmapWritesUserLevel: extern struct {
        Write: WORD,
        Create: WORD,
        SetInfo: WORD,
        Flush: WORD,
    },
    UserIndexReads: DWORD,
    UserIndexReadBytes: DWORD,
    UserIndexWrites: DWORD,
    UserIndexWriteBytes: DWORD,
    LogFileReads: DWORD,
    LogFileReadBytes: DWORD,
    LogFileWrites: DWORD,
    LogFileWriteBytes: DWORD,
    Allocate: extern struct {
        Calls: DWORD,
        Clusters: DWORD,
        Hints: DWORD,
        RunsReturned: DWORD,
        HintsHonored: DWORD,
        HintsClusters: DWORD,
        Cache: DWORD,
        CacheClusters: DWORD,
        CacheMiss: DWORD,
        CacheMissClusters: DWORD,
    },
    DiskResourcesExhausted: DWORD,
};
pub const NTFS_STATISTICS = struct__NTFS_STATISTICS;
pub const PNTFS_STATISTICS = [*c]struct__NTFS_STATISTICS;
pub const struct__FILESYSTEM_STATISTICS_EX = extern struct {
    FileSystemType: WORD,
    Version: WORD,
    SizeOfCompleteStructure: DWORD,
    UserFileReads: DWORDLONG,
    UserFileReadBytes: DWORDLONG,
    UserDiskReads: DWORDLONG,
    UserFileWrites: DWORDLONG,
    UserFileWriteBytes: DWORDLONG,
    UserDiskWrites: DWORDLONG,
    MetaDataReads: DWORDLONG,
    MetaDataReadBytes: DWORDLONG,
    MetaDataDiskReads: DWORDLONG,
    MetaDataWrites: DWORDLONG,
    MetaDataWriteBytes: DWORDLONG,
    MetaDataDiskWrites: DWORDLONG,
};
pub const FILESYSTEM_STATISTICS_EX = struct__FILESYSTEM_STATISTICS_EX;
pub const PFILESYSTEM_STATISTICS_EX = [*c]struct__FILESYSTEM_STATISTICS_EX;
pub const struct__NTFS_STATISTICS_EX = extern struct {
    LogFileFullExceptions: DWORD,
    OtherExceptions: DWORD,
    MftReads: DWORDLONG,
    MftReadBytes: DWORDLONG,
    MftWrites: DWORDLONG,
    MftWriteBytes: DWORDLONG,
    MftWritesUserLevel: extern struct {
        Write: DWORD,
        Create: DWORD,
        SetInfo: DWORD,
        Flush: DWORD,
    },
    MftWritesFlushForLogFileFull: DWORD,
    MftWritesLazyWriter: DWORD,
    MftWritesUserRequest: DWORD,
    Mft2Writes: DWORDLONG,
    Mft2WriteBytes: DWORDLONG,
    Mft2WritesUserLevel: extern struct {
        Write: DWORD,
        Create: DWORD,
        SetInfo: DWORD,
        Flush: DWORD,
    },
    Mft2WritesFlushForLogFileFull: DWORD,
    Mft2WritesLazyWriter: DWORD,
    Mft2WritesUserRequest: DWORD,
    RootIndexReads: DWORDLONG,
    RootIndexReadBytes: DWORDLONG,
    RootIndexWrites: DWORDLONG,
    RootIndexWriteBytes: DWORDLONG,
    BitmapReads: DWORDLONG,
    BitmapReadBytes: DWORDLONG,
    BitmapWrites: DWORDLONG,
    BitmapWriteBytes: DWORDLONG,
    BitmapWritesFlushForLogFileFull: DWORD,
    BitmapWritesLazyWriter: DWORD,
    BitmapWritesUserRequest: DWORD,
    BitmapWritesUserLevel: extern struct {
        Write: DWORD,
        Create: DWORD,
        SetInfo: DWORD,
        Flush: DWORD,
    },
    MftBitmapReads: DWORDLONG,
    MftBitmapReadBytes: DWORDLONG,
    MftBitmapWrites: DWORDLONG,
    MftBitmapWriteBytes: DWORDLONG,
    MftBitmapWritesFlushForLogFileFull: DWORD,
    MftBitmapWritesLazyWriter: DWORD,
    MftBitmapWritesUserRequest: DWORD,
    MftBitmapWritesUserLevel: extern struct {
        Write: DWORD,
        Create: DWORD,
        SetInfo: DWORD,
        Flush: DWORD,
    },
    UserIndexReads: DWORDLONG,
    UserIndexReadBytes: DWORDLONG,
    UserIndexWrites: DWORDLONG,
    UserIndexWriteBytes: DWORDLONG,
    LogFileReads: DWORDLONG,
    LogFileReadBytes: DWORDLONG,
    LogFileWrites: DWORDLONG,
    LogFileWriteBytes: DWORDLONG,
    Allocate: extern struct {
        Calls: DWORD,
        RunsReturned: DWORD,
        Hints: DWORD,
        HintsHonored: DWORD,
        Cache: DWORD,
        CacheMiss: DWORD,
        Clusters: DWORDLONG,
        HintsClusters: DWORDLONG,
        CacheClusters: DWORDLONG,
        CacheMissClusters: DWORDLONG,
    },
    DiskResourcesExhausted: DWORD,
    VolumeTrimCount: DWORDLONG,
    VolumeTrimTime: DWORDLONG,
    VolumeTrimByteCount: DWORDLONG,
    FileLevelTrimCount: DWORDLONG,
    FileLevelTrimTime: DWORDLONG,
    FileLevelTrimByteCount: DWORDLONG,
    VolumeTrimSkippedCount: DWORDLONG,
    VolumeTrimSkippedByteCount: DWORDLONG,
    NtfsFillStatInfoFromMftRecordCalledCount: DWORDLONG,
    NtfsFillStatInfoFromMftRecordBailedBecauseOfAttributeListCount: DWORDLONG,
    NtfsFillStatInfoFromMftRecordBailedBecauseOfNonResReparsePointCount: DWORDLONG,
};
pub const NTFS_STATISTICS_EX = struct__NTFS_STATISTICS_EX;
pub const PNTFS_STATISTICS_EX = [*c]struct__NTFS_STATISTICS_EX;
pub const struct__FILE_OBJECTID_BUFFER = extern struct {
    ObjectId: [16]BYTE,
    @"": extern union {
        @"": extern struct {
            BirthVolumeId: [16]BYTE,
            BirthObjectId: [16]BYTE,
            DomainId: [16]BYTE,
        },
        ExtendedInfo: [48]BYTE,
    },
};
pub const FILE_OBJECTID_BUFFER = struct__FILE_OBJECTID_BUFFER;
pub const PFILE_OBJECTID_BUFFER = [*c]struct__FILE_OBJECTID_BUFFER;
pub const struct__FILE_SET_SPARSE_BUFFER = extern struct {
    SetSparse: BOOLEAN,
};
pub const FILE_SET_SPARSE_BUFFER = struct__FILE_SET_SPARSE_BUFFER;
pub const PFILE_SET_SPARSE_BUFFER = [*c]struct__FILE_SET_SPARSE_BUFFER;
pub const struct__FILE_ZERO_DATA_INFORMATION = extern struct {
    FileOffset: LARGE_INTEGER,
    BeyondFinalZero: LARGE_INTEGER,
};
pub const FILE_ZERO_DATA_INFORMATION = struct__FILE_ZERO_DATA_INFORMATION;
pub const PFILE_ZERO_DATA_INFORMATION = [*c]struct__FILE_ZERO_DATA_INFORMATION;
pub const struct__FILE_ZERO_DATA_INFORMATION_EX = extern struct {
    FileOffset: LARGE_INTEGER,
    BeyondFinalZero: LARGE_INTEGER,
    Flags: DWORD,
};
pub const FILE_ZERO_DATA_INFORMATION_EX = struct__FILE_ZERO_DATA_INFORMATION_EX;
pub const PFILE_ZERO_DATA_INFORMATION_EX = [*c]struct__FILE_ZERO_DATA_INFORMATION_EX;
pub const struct__FILE_ALLOCATED_RANGE_BUFFER = extern struct {
    FileOffset: LARGE_INTEGER,
    Length: LARGE_INTEGER,
};
pub const FILE_ALLOCATED_RANGE_BUFFER = struct__FILE_ALLOCATED_RANGE_BUFFER;
pub const PFILE_ALLOCATED_RANGE_BUFFER = [*c]struct__FILE_ALLOCATED_RANGE_BUFFER;
pub const struct__ENCRYPTION_BUFFER = extern struct {
    EncryptionOperation: DWORD,
    Private: [1]BYTE,
};
pub const ENCRYPTION_BUFFER = struct__ENCRYPTION_BUFFER;
pub const PENCRYPTION_BUFFER = [*c]struct__ENCRYPTION_BUFFER;
pub const struct__DECRYPTION_STATUS_BUFFER = extern struct {
    NoEncryptedStreams: BOOLEAN,
};
pub const DECRYPTION_STATUS_BUFFER = struct__DECRYPTION_STATUS_BUFFER;
pub const PDECRYPTION_STATUS_BUFFER = [*c]struct__DECRYPTION_STATUS_BUFFER;
pub const struct__REQUEST_RAW_ENCRYPTED_DATA = extern struct {
    FileOffset: LONGLONG,
    Length: DWORD,
};
pub const REQUEST_RAW_ENCRYPTED_DATA = struct__REQUEST_RAW_ENCRYPTED_DATA;
pub const PREQUEST_RAW_ENCRYPTED_DATA = [*c]struct__REQUEST_RAW_ENCRYPTED_DATA;
pub const struct__ENCRYPTED_DATA_INFO = extern struct {
    StartingFileOffset: DWORDLONG,
    OutputBufferOffset: DWORD,
    BytesWithinFileSize: DWORD,
    BytesWithinValidDataLength: DWORD,
    CompressionFormat: WORD,
    DataUnitShift: BYTE,
    ChunkShift: BYTE,
    ClusterShift: BYTE,
    EncryptionFormat: BYTE,
    NumberOfDataBlocks: WORD,
    DataBlockSize: [1]DWORD,
};
pub const ENCRYPTED_DATA_INFO = struct__ENCRYPTED_DATA_INFO;
pub const PENCRYPTED_DATA_INFO = [*c]struct__ENCRYPTED_DATA_INFO;
pub const struct__EXTENDED_ENCRYPTED_DATA_INFO = extern struct {
    ExtendedCode: DWORD,
    Length: DWORD,
    Flags: DWORD,
    Reserved: DWORD,
};
pub const EXTENDED_ENCRYPTED_DATA_INFO = struct__EXTENDED_ENCRYPTED_DATA_INFO;
pub const PEXTENDED_ENCRYPTED_DATA_INFO = [*c]struct__EXTENDED_ENCRYPTED_DATA_INFO;
pub const struct__PLEX_READ_DATA_REQUEST = extern struct {
    ByteOffset: LARGE_INTEGER,
    ByteLength: DWORD,
    PlexNumber: DWORD,
};
pub const PLEX_READ_DATA_REQUEST = struct__PLEX_READ_DATA_REQUEST;
pub const PPLEX_READ_DATA_REQUEST = [*c]struct__PLEX_READ_DATA_REQUEST;
pub const struct__SI_COPYFILE = extern struct {
    SourceFileNameLength: DWORD,
    DestinationFileNameLength: DWORD,
    Flags: DWORD,
    FileNameBuffer: [1]WCHAR,
};
pub const SI_COPYFILE = struct__SI_COPYFILE;
pub const PSI_COPYFILE = [*c]struct__SI_COPYFILE;
pub const struct__FILE_MAKE_COMPATIBLE_BUFFER = extern struct {
    CloseDisc: BOOLEAN,
};
pub const FILE_MAKE_COMPATIBLE_BUFFER = struct__FILE_MAKE_COMPATIBLE_BUFFER;
pub const PFILE_MAKE_COMPATIBLE_BUFFER = [*c]struct__FILE_MAKE_COMPATIBLE_BUFFER;
pub const struct__FILE_SET_DEFECT_MGMT_BUFFER = extern struct {
    Disable: BOOLEAN,
};
pub const FILE_SET_DEFECT_MGMT_BUFFER = struct__FILE_SET_DEFECT_MGMT_BUFFER;
pub const PFILE_SET_DEFECT_MGMT_BUFFER = [*c]struct__FILE_SET_DEFECT_MGMT_BUFFER;
pub const struct__FILE_QUERY_SPARING_BUFFER = extern struct {
    SparingUnitBytes: DWORD,
    SoftwareSparing: BOOLEAN,
    TotalSpareBlocks: DWORD,
    FreeSpareBlocks: DWORD,
};
pub const FILE_QUERY_SPARING_BUFFER = struct__FILE_QUERY_SPARING_BUFFER;
pub const PFILE_QUERY_SPARING_BUFFER = [*c]struct__FILE_QUERY_SPARING_BUFFER;
pub const struct__FILE_QUERY_ON_DISK_VOL_INFO_BUFFER = extern struct {
    DirectoryCount: LARGE_INTEGER,
    FileCount: LARGE_INTEGER,
    FsFormatMajVersion: WORD,
    FsFormatMinVersion: WORD,
    FsFormatName: [12]WCHAR,
    FormatTime: LARGE_INTEGER,
    LastUpdateTime: LARGE_INTEGER,
    CopyrightInfo: [34]WCHAR,
    AbstractInfo: [34]WCHAR,
    FormattingImplementationInfo: [34]WCHAR,
    LastModifyingImplementationInfo: [34]WCHAR,
};
pub const FILE_QUERY_ON_DISK_VOL_INFO_BUFFER = struct__FILE_QUERY_ON_DISK_VOL_INFO_BUFFER;
pub const PFILE_QUERY_ON_DISK_VOL_INFO_BUFFER = [*c]struct__FILE_QUERY_ON_DISK_VOL_INFO_BUFFER;
pub const CLSN = DWORDLONG;
pub const struct__FILE_INITIATE_REPAIR_OUTPUT_BUFFER = extern struct {
    Hint1: DWORDLONG,
    Hint2: DWORDLONG,
    Clsn: CLSN,
    Status: DWORD,
};
pub const FILE_INITIATE_REPAIR_OUTPUT_BUFFER = struct__FILE_INITIATE_REPAIR_OUTPUT_BUFFER;
pub const PFILE_INITIATE_REPAIR_OUTPUT_BUFFER = [*c]struct__FILE_INITIATE_REPAIR_OUTPUT_BUFFER;
pub const ShrinkPrepare = enum__SHRINK_VOLUME_REQUEST_TYPES.ShrinkPrepare;
pub const ShrinkCommit = enum__SHRINK_VOLUME_REQUEST_TYPES.ShrinkCommit;
pub const ShrinkAbort = enum__SHRINK_VOLUME_REQUEST_TYPES.ShrinkAbort;
pub const enum__SHRINK_VOLUME_REQUEST_TYPES = extern enum {
    ShrinkPrepare = 1,
    ShrinkCommit = 2,
    ShrinkAbort = 3,
};
pub const SHRINK_VOLUME_REQUEST_TYPES = enum__SHRINK_VOLUME_REQUEST_TYPES;
pub const PSHRINK_VOLUME_REQUEST_TYPES = [*c]enum__SHRINK_VOLUME_REQUEST_TYPES;
pub const struct__SHRINK_VOLUME_INFORMATION = extern struct {
    ShrinkRequestType: SHRINK_VOLUME_REQUEST_TYPES,
    Flags: DWORDLONG,
    NewNumberOfSectors: LONGLONG,
};
pub const SHRINK_VOLUME_INFORMATION = struct__SHRINK_VOLUME_INFORMATION;
pub const PSHRINK_VOLUME_INFORMATION = [*c]struct__SHRINK_VOLUME_INFORMATION;
pub const struct__TXFS_MODIFY_RM = extern struct {
    Flags: DWORD,
    LogContainerCountMax: DWORD,
    LogContainerCountMin: DWORD,
    LogContainerCount: DWORD,
    LogGrowthIncrement: DWORD,
    LogAutoShrinkPercentage: DWORD,
    Reserved: DWORDLONG,
    LoggingMode: WORD,
};
pub const TXFS_MODIFY_RM = struct__TXFS_MODIFY_RM;
pub const PTXFS_MODIFY_RM = [*c]struct__TXFS_MODIFY_RM;
pub const struct__TXFS_QUERY_RM_INFORMATION = extern struct {
    BytesRequired: DWORD,
    TailLsn: DWORDLONG,
    CurrentLsn: DWORDLONG,
    ArchiveTailLsn: DWORDLONG,
    LogContainerSize: DWORDLONG,
    HighestVirtualClock: LARGE_INTEGER,
    LogContainerCount: DWORD,
    LogContainerCountMax: DWORD,
    LogContainerCountMin: DWORD,
    LogGrowthIncrement: DWORD,
    LogAutoShrinkPercentage: DWORD,
    Flags: DWORD,
    LoggingMode: WORD,
    Reserved: WORD,
    RmState: DWORD,
    LogCapacity: DWORDLONG,
    LogFree: DWORDLONG,
    TopsSize: DWORDLONG,
    TopsUsed: DWORDLONG,
    TransactionCount: DWORDLONG,
    OnePCCount: DWORDLONG,
    TwoPCCount: DWORDLONG,
    NumberLogFileFull: DWORDLONG,
    OldestTransactionAge: DWORDLONG,
    RMName: GUID,
    TmLogPathOffset: DWORD,
};
pub const TXFS_QUERY_RM_INFORMATION = struct__TXFS_QUERY_RM_INFORMATION;
pub const PTXFS_QUERY_RM_INFORMATION = [*c]struct__TXFS_QUERY_RM_INFORMATION;
pub const struct__TXFS_ROLLFORWARD_REDO_INFORMATION = extern struct {
    LastVirtualClock: LARGE_INTEGER,
    LastRedoLsn: DWORDLONG,
    HighestRecoveryLsn: DWORDLONG,
    Flags: DWORD,
};
pub const TXFS_ROLLFORWARD_REDO_INFORMATION = struct__TXFS_ROLLFORWARD_REDO_INFORMATION;
pub const PTXFS_ROLLFORWARD_REDO_INFORMATION = [*c]struct__TXFS_ROLLFORWARD_REDO_INFORMATION;
pub const struct__TXFS_START_RM_INFORMATION = extern struct {
    Flags: DWORD,
    LogContainerSize: DWORDLONG,
    LogContainerCountMin: DWORD,
    LogContainerCountMax: DWORD,
    LogGrowthIncrement: DWORD,
    LogAutoShrinkPercentage: DWORD,
    TmLogPathOffset: DWORD,
    TmLogPathLength: WORD,
    LoggingMode: WORD,
    LogPathLength: WORD,
    Reserved: WORD,
    LogPath: [1]WCHAR,
};
pub const TXFS_START_RM_INFORMATION = struct__TXFS_START_RM_INFORMATION;
pub const PTXFS_START_RM_INFORMATION = [*c]struct__TXFS_START_RM_INFORMATION;
pub const struct__TXFS_GET_METADATA_INFO_OUT = extern struct {
    TxfFileId: extern struct {
        LowPart: LONGLONG,
        HighPart: LONGLONG,
    },
    LockingTransaction: GUID,
    LastLsn: DWORDLONG,
    TransactionState: DWORD,
};
pub const TXFS_GET_METADATA_INFO_OUT = struct__TXFS_GET_METADATA_INFO_OUT;
pub const PTXFS_GET_METADATA_INFO_OUT = [*c]struct__TXFS_GET_METADATA_INFO_OUT;
pub const struct__TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY = extern struct {
    Offset: DWORDLONG,
    NameFlags: DWORD,
    FileId: LONGLONG,
    Reserved1: DWORD,
    Reserved2: DWORD,
    Reserved3: LONGLONG,
    FileName: [1]WCHAR,
};
pub const TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY = struct__TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY;
pub const PTXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY = [*c]struct__TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY;
pub const struct__TXFS_LIST_TRANSACTION_LOCKED_FILES = extern struct {
    KtmTransaction: GUID,
    NumberOfFiles: DWORDLONG,
    BufferSizeRequired: DWORDLONG,
    Offset: DWORDLONG,
};
pub const TXFS_LIST_TRANSACTION_LOCKED_FILES = struct__TXFS_LIST_TRANSACTION_LOCKED_FILES;
pub const PTXFS_LIST_TRANSACTION_LOCKED_FILES = [*c]struct__TXFS_LIST_TRANSACTION_LOCKED_FILES;
pub const struct__TXFS_LIST_TRANSACTIONS_ENTRY = extern struct {
    TransactionId: GUID,
    TransactionState: DWORD,
    Reserved1: DWORD,
    Reserved2: DWORD,
    Reserved3: LONGLONG,
};
pub const TXFS_LIST_TRANSACTIONS_ENTRY = struct__TXFS_LIST_TRANSACTIONS_ENTRY;
pub const PTXFS_LIST_TRANSACTIONS_ENTRY = [*c]struct__TXFS_LIST_TRANSACTIONS_ENTRY;
pub const struct__TXFS_LIST_TRANSACTIONS = extern struct {
    NumberOfTransactions: DWORDLONG,
    BufferSizeRequired: DWORDLONG,
};
pub const TXFS_LIST_TRANSACTIONS = struct__TXFS_LIST_TRANSACTIONS;
pub const PTXFS_LIST_TRANSACTIONS = [*c]struct__TXFS_LIST_TRANSACTIONS;
pub const struct__TXFS_READ_BACKUP_INFORMATION_OUT = extern struct {
    @"": extern union {
        BufferLength: DWORD,
        Buffer: [1]BYTE,
    },
};
pub const TXFS_READ_BACKUP_INFORMATION_OUT = struct__TXFS_READ_BACKUP_INFORMATION_OUT;
pub const PTXFS_READ_BACKUP_INFORMATION_OUT = [*c]struct__TXFS_READ_BACKUP_INFORMATION_OUT;
pub const struct__TXFS_WRITE_BACKUP_INFORMATION = extern struct {
    Buffer: [1]BYTE,
};
pub const TXFS_WRITE_BACKUP_INFORMATION = struct__TXFS_WRITE_BACKUP_INFORMATION;
pub const PTXFS_WRITE_BACKUP_INFORMATION = [*c]struct__TXFS_WRITE_BACKUP_INFORMATION;
pub const struct__TXFS_GET_TRANSACTED_VERSION = extern struct {
    ThisBaseVersion: DWORD,
    LatestVersion: DWORD,
    ThisMiniVersion: WORD,
    FirstMiniVersion: WORD,
    LatestMiniVersion: WORD,
};
pub const TXFS_GET_TRANSACTED_VERSION = struct__TXFS_GET_TRANSACTED_VERSION;
pub const PTXFS_GET_TRANSACTED_VERSION = [*c]struct__TXFS_GET_TRANSACTED_VERSION;
pub const struct__TXFS_SAVEPOINT_INFORMATION = extern struct {
    KtmTransaction: HANDLE,
    ActionCode: DWORD,
    SavepointId: DWORD,
};
pub const TXFS_SAVEPOINT_INFORMATION = struct__TXFS_SAVEPOINT_INFORMATION;
pub const PTXFS_SAVEPOINT_INFORMATION = [*c]struct__TXFS_SAVEPOINT_INFORMATION;
pub const struct__TXFS_CREATE_MINIVERSION_INFO = extern struct {
    StructureVersion: WORD,
    StructureLength: WORD,
    BaseVersion: DWORD,
    MiniVersion: WORD,
};
pub const TXFS_CREATE_MINIVERSION_INFO = struct__TXFS_CREATE_MINIVERSION_INFO;
pub const PTXFS_CREATE_MINIVERSION_INFO = [*c]struct__TXFS_CREATE_MINIVERSION_INFO;
pub const struct__TXFS_TRANSACTION_ACTIVE_INFO = extern struct {
    TransactionsActiveAtSnapshot: BOOLEAN,
};
pub const TXFS_TRANSACTION_ACTIVE_INFO = struct__TXFS_TRANSACTION_ACTIVE_INFO;
pub const PTXFS_TRANSACTION_ACTIVE_INFO = [*c]struct__TXFS_TRANSACTION_ACTIVE_INFO;
pub const struct__BOOT_AREA_INFO = extern struct {
    BootSectorCount: DWORD,
    BootSectors: [2]extern struct {
        Offset: LARGE_INTEGER,
    },
};
pub const BOOT_AREA_INFO = struct__BOOT_AREA_INFO;
pub const PBOOT_AREA_INFO = [*c]struct__BOOT_AREA_INFO;
pub const struct__RETRIEVAL_POINTER_BASE = extern struct {
    FileAreaOffset: LARGE_INTEGER,
};
pub const RETRIEVAL_POINTER_BASE = struct__RETRIEVAL_POINTER_BASE;
pub const PRETRIEVAL_POINTER_BASE = [*c]struct__RETRIEVAL_POINTER_BASE;
pub const struct__FILE_FS_PERSISTENT_VOLUME_INFORMATION = extern struct {
    VolumeFlags: DWORD,
    FlagMask: DWORD,
    Version: DWORD,
    Reserved: DWORD,
};
pub const FILE_FS_PERSISTENT_VOLUME_INFORMATION = struct__FILE_FS_PERSISTENT_VOLUME_INFORMATION;
pub const PFILE_FS_PERSISTENT_VOLUME_INFORMATION = [*c]struct__FILE_FS_PERSISTENT_VOLUME_INFORMATION;
pub const struct__FILE_SYSTEM_RECOGNITION_INFORMATION = extern struct {
    FileSystem: [9]CHAR,
};
pub const FILE_SYSTEM_RECOGNITION_INFORMATION = struct__FILE_SYSTEM_RECOGNITION_INFORMATION;
pub const PFILE_SYSTEM_RECOGNITION_INFORMATION = [*c]struct__FILE_SYSTEM_RECOGNITION_INFORMATION;
pub const struct__REQUEST_OPLOCK_INPUT_BUFFER = extern struct {
    StructureVersion: WORD,
    StructureLength: WORD,
    RequestedOplockLevel: DWORD,
    Flags: DWORD,
};
pub const REQUEST_OPLOCK_INPUT_BUFFER = struct__REQUEST_OPLOCK_INPUT_BUFFER;
pub const PREQUEST_OPLOCK_INPUT_BUFFER = [*c]struct__REQUEST_OPLOCK_INPUT_BUFFER;
pub const struct__REQUEST_OPLOCK_OUTPUT_BUFFER = extern struct {
    StructureVersion: WORD,
    StructureLength: WORD,
    OriginalOplockLevel: DWORD,
    NewOplockLevel: DWORD,
    Flags: DWORD,
    AccessMode: ACCESS_MASK,
    ShareMode: WORD,
};
pub const REQUEST_OPLOCK_OUTPUT_BUFFER = struct__REQUEST_OPLOCK_OUTPUT_BUFFER;
pub const PREQUEST_OPLOCK_OUTPUT_BUFFER = [*c]struct__REQUEST_OPLOCK_OUTPUT_BUFFER;
pub const struct__VIRTUAL_STORAGE_TYPE = extern struct {
    DeviceId: DWORD,
    VendorId: GUID,
};
pub const VIRTUAL_STORAGE_TYPE = struct__VIRTUAL_STORAGE_TYPE;
pub const PVIRTUAL_STORAGE_TYPE = [*c]struct__VIRTUAL_STORAGE_TYPE;
pub const struct__STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST = extern struct {
    RequestLevel: DWORD,
    RequestFlags: DWORD,
};
pub const STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST = struct__STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST;
pub const PSTORAGE_QUERY_DEPENDENT_VOLUME_REQUEST = [*c]struct__STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST;
pub const struct__STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY = extern struct {
    EntryLength: DWORD,
    DependencyTypeFlags: DWORD,
    ProviderSpecificFlags: DWORD,
    VirtualStorageType: VIRTUAL_STORAGE_TYPE,
};
pub const STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY = struct__STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY;
pub const PSTORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY = [*c]struct__STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY;
pub const struct__STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY = extern struct {
    EntryLength: DWORD,
    DependencyTypeFlags: DWORD,
    ProviderSpecificFlags: DWORD,
    VirtualStorageType: VIRTUAL_STORAGE_TYPE,
    AncestorLevel: DWORD,
    HostVolumeNameOffset: DWORD,
    HostVolumeNameSize: DWORD,
    DependentVolumeNameOffset: DWORD,
    DependentVolumeNameSize: DWORD,
    RelativePathOffset: DWORD,
    RelativePathSize: DWORD,
    DependentDeviceNameOffset: DWORD,
    DependentDeviceNameSize: DWORD,
};
pub const STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY = struct__STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY;
pub const PSTORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY = [*c]struct__STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY;
pub const struct__STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE = extern struct {
    ResponseLevel: DWORD,
    NumberEntries: DWORD,
    @"": extern union {
        Lev1Depends: [*c]STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY,
        Lev2Depends: [*c]STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY,
    },
};
pub const STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE = struct__STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE;
pub const PSTORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE = [*c]struct__STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE;
pub const struct__SD_CHANGE_MACHINE_SID_INPUT = extern struct {
    CurrentMachineSIDOffset: WORD,
    CurrentMachineSIDLength: WORD,
    NewMachineSIDOffset: WORD,
    NewMachineSIDLength: WORD,
};
pub const SD_CHANGE_MACHINE_SID_INPUT = struct__SD_CHANGE_MACHINE_SID_INPUT;
pub const PSD_CHANGE_MACHINE_SID_INPUT = [*c]struct__SD_CHANGE_MACHINE_SID_INPUT;
pub const struct__SD_CHANGE_MACHINE_SID_OUTPUT = extern struct {
    NumSDChangedSuccess: DWORDLONG,
    NumSDChangedFail: DWORDLONG,
    NumSDUnused: DWORDLONG,
    NumSDTotal: DWORDLONG,
    NumMftSDChangedSuccess: DWORDLONG,
    NumMftSDChangedFail: DWORDLONG,
    NumMftSDTotal: DWORDLONG,
};
pub const SD_CHANGE_MACHINE_SID_OUTPUT = struct__SD_CHANGE_MACHINE_SID_OUTPUT;
pub const PSD_CHANGE_MACHINE_SID_OUTPUT = [*c]struct__SD_CHANGE_MACHINE_SID_OUTPUT;
pub const struct__SD_QUERY_STATS_INPUT = extern struct {
    Reserved: DWORD,
};
pub const SD_QUERY_STATS_INPUT = struct__SD_QUERY_STATS_INPUT;
pub const PSD_QUERY_STATS_INPUT = [*c]struct__SD_QUERY_STATS_INPUT;
pub const struct__SD_QUERY_STATS_OUTPUT = extern struct {
    SdsStreamSize: DWORDLONG,
    SdsAllocationSize: DWORDLONG,
    SiiStreamSize: DWORDLONG,
    SiiAllocationSize: DWORDLONG,
    SdhStreamSize: DWORDLONG,
    SdhAllocationSize: DWORDLONG,
    NumSDTotal: DWORDLONG,
    NumSDUnused: DWORDLONG,
};
pub const SD_QUERY_STATS_OUTPUT = struct__SD_QUERY_STATS_OUTPUT;
pub const PSD_QUERY_STATS_OUTPUT = [*c]struct__SD_QUERY_STATS_OUTPUT;
pub const struct__SD_ENUM_SDS_INPUT = extern struct {
    StartingOffset: DWORDLONG,
    MaxSDEntriesToReturn: DWORDLONG,
};
pub const SD_ENUM_SDS_INPUT = struct__SD_ENUM_SDS_INPUT;
pub const PSD_ENUM_SDS_INPUT = [*c]struct__SD_ENUM_SDS_INPUT;
pub const struct__SD_ENUM_SDS_ENTRY = extern struct {
    Hash: DWORD,
    SecurityId: DWORD,
    Offset: DWORDLONG,
    Length: DWORD,
    Descriptor: [1]BYTE,
};
pub const SD_ENUM_SDS_ENTRY = struct__SD_ENUM_SDS_ENTRY;
pub const PSD_ENUM_SDS_ENTRY = [*c]struct__SD_ENUM_SDS_ENTRY;
pub const struct__SD_ENUM_SDS_OUTPUT = extern struct {
    NextOffset: DWORDLONG,
    NumSDEntriesReturned: DWORDLONG,
    NumSDBytesReturned: DWORDLONG,
    SDEntry: [1]SD_ENUM_SDS_ENTRY,
};
pub const SD_ENUM_SDS_OUTPUT = struct__SD_ENUM_SDS_OUTPUT;
pub const PSD_ENUM_SDS_OUTPUT = [*c]struct__SD_ENUM_SDS_OUTPUT;
pub const struct__SD_GLOBAL_CHANGE_INPUT = extern struct {
    Flags: DWORD,
    ChangeType: DWORD,
    @"": extern union {
        SdChange: SD_CHANGE_MACHINE_SID_INPUT,
        SdQueryStats: SD_QUERY_STATS_INPUT,
        SdEnumSds: SD_ENUM_SDS_INPUT,
    },
};
pub const SD_GLOBAL_CHANGE_INPUT = struct__SD_GLOBAL_CHANGE_INPUT;
pub const PSD_GLOBAL_CHANGE_INPUT = [*c]struct__SD_GLOBAL_CHANGE_INPUT;
pub const struct__SD_GLOBAL_CHANGE_OUTPUT = extern struct {
    Flags: DWORD,
    ChangeType: DWORD,
    @"": extern union {
        SdChange: SD_CHANGE_MACHINE_SID_OUTPUT,
        SdQueryStats: SD_QUERY_STATS_OUTPUT,
        SdEnumSds: SD_ENUM_SDS_OUTPUT,
    },
};
pub const SD_GLOBAL_CHANGE_OUTPUT = struct__SD_GLOBAL_CHANGE_OUTPUT;
pub const PSD_GLOBAL_CHANGE_OUTPUT = [*c]struct__SD_GLOBAL_CHANGE_OUTPUT;
pub const struct__LOOKUP_STREAM_FROM_CLUSTER_INPUT = extern struct {
    Flags: DWORD,
    NumberOfClusters: DWORD,
    Cluster: [1]LARGE_INTEGER,
};
pub const LOOKUP_STREAM_FROM_CLUSTER_INPUT = struct__LOOKUP_STREAM_FROM_CLUSTER_INPUT;
pub const PLOOKUP_STREAM_FROM_CLUSTER_INPUT = [*c]struct__LOOKUP_STREAM_FROM_CLUSTER_INPUT;
pub const struct__LOOKUP_STREAM_FROM_CLUSTER_OUTPUT = extern struct {
    Offset: DWORD,
    NumberOfMatches: DWORD,
    BufferSizeRequired: DWORD,
};
pub const LOOKUP_STREAM_FROM_CLUSTER_OUTPUT = struct__LOOKUP_STREAM_FROM_CLUSTER_OUTPUT;
pub const PLOOKUP_STREAM_FROM_CLUSTER_OUTPUT = [*c]struct__LOOKUP_STREAM_FROM_CLUSTER_OUTPUT;
pub const struct__LOOKUP_STREAM_FROM_CLUSTER_ENTRY = extern struct {
    OffsetToNext: DWORD,
    Flags: DWORD,
    Reserved: LARGE_INTEGER,
    Cluster: LARGE_INTEGER,
    FileName: [1]WCHAR,
};
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY = struct__LOOKUP_STREAM_FROM_CLUSTER_ENTRY;
pub const PLOOKUP_STREAM_FROM_CLUSTER_ENTRY = [*c]struct__LOOKUP_STREAM_FROM_CLUSTER_ENTRY;
pub const struct__FILE_TYPE_NOTIFICATION_INPUT = extern struct {
    Flags: DWORD,
    NumFileTypeIDs: DWORD,
    FileTypeID: [1]GUID,
};
pub const FILE_TYPE_NOTIFICATION_INPUT = struct__FILE_TYPE_NOTIFICATION_INPUT;
pub const PFILE_TYPE_NOTIFICATION_INPUT = [*c]struct__FILE_TYPE_NOTIFICATION_INPUT;
pub extern const FILE_TYPE_NOTIFICATION_GUID_PAGE_FILE: GUID;
pub extern const FILE_TYPE_NOTIFICATION_GUID_HIBERNATION_FILE: GUID;
pub extern const FILE_TYPE_NOTIFICATION_GUID_CRASHDUMP_FILE: GUID;
pub const struct__CSV_MGMT_LOCK = extern struct {
    Flags: DWORD,
};
pub const CSV_MGMT_LOCK = struct__CSV_MGMT_LOCK;
pub const PCSV_MGMT_LOCK = [*c]struct__CSV_MGMT_LOCK;
pub const struct__CSV_NAMESPACE_INFO = extern struct {
    Version: DWORD,
    DeviceNumber: DWORD,
    StartingOffset: LARGE_INTEGER,
    SectorSize: DWORD,
};
pub const CSV_NAMESPACE_INFO = struct__CSV_NAMESPACE_INFO;
pub const PCSV_NAMESPACE_INFO = [*c]struct__CSV_NAMESPACE_INFO;
pub const CsvControlStartRedirectFile = enum__CSV_CONTROL_OP.CsvControlStartRedirectFile;
pub const CsvControlStopRedirectFile = enum__CSV_CONTROL_OP.CsvControlStopRedirectFile;
pub const CsvControlQueryRedirectState = enum__CSV_CONTROL_OP.CsvControlQueryRedirectState;
pub const CsvControlQueryFileRevision = enum__CSV_CONTROL_OP.CsvControlQueryFileRevision;
pub const CsvControlQueryMdsPath = enum__CSV_CONTROL_OP.CsvControlQueryMdsPath;
pub const CsvControlQueryFileRevisionFileId128 = enum__CSV_CONTROL_OP.CsvControlQueryFileRevisionFileId128;
pub const CsvControlQueryVolumeRedirectState = enum__CSV_CONTROL_OP.CsvControlQueryVolumeRedirectState;
pub const CsvControlEnableUSNRangeModificationTracking = enum__CSV_CONTROL_OP.CsvControlEnableUSNRangeModificationTracking;
pub const CsvControlMarkHandleLocalVolumeMount = enum__CSV_CONTROL_OP.CsvControlMarkHandleLocalVolumeMount;
pub const CsvControlUnmarkHandleLocalVolumeMount = enum__CSV_CONTROL_OP.CsvControlUnmarkHandleLocalVolumeMount;
pub const CsvControlGetCsvFsMdsPathV2 = enum__CSV_CONTROL_OP.CsvControlGetCsvFsMdsPathV2;
pub const CsvControlDisableCaching = enum__CSV_CONTROL_OP.CsvControlDisableCaching;
pub const CsvControlEnableCaching = enum__CSV_CONTROL_OP.CsvControlEnableCaching;
pub const enum__CSV_CONTROL_OP = extern enum {
    CsvControlStartRedirectFile = 2,
    CsvControlStopRedirectFile = 3,
    CsvControlQueryRedirectState = 4,
    CsvControlQueryFileRevision = 6,
    CsvControlQueryMdsPath = 8,
    CsvControlQueryFileRevisionFileId128 = 9,
    CsvControlQueryVolumeRedirectState = 10,
    CsvControlEnableUSNRangeModificationTracking = 13,
    CsvControlMarkHandleLocalVolumeMount = 14,
    CsvControlUnmarkHandleLocalVolumeMount = 15,
    CsvControlGetCsvFsMdsPathV2 = 18,
    CsvControlDisableCaching = 19,
    CsvControlEnableCaching = 20,
};
pub const CSV_CONTROL_OP = enum__CSV_CONTROL_OP;
pub const PCSV_CONTROL_OP = [*c]enum__CSV_CONTROL_OP;
pub const struct__CSV_CONTROL_PARAM = extern struct {
    Operation: CSV_CONTROL_OP,
    Unused: LONGLONG,
};
pub const CSV_CONTROL_PARAM = struct__CSV_CONTROL_PARAM;
pub const PCSV_CONTROL_PARAM = [*c]struct__CSV_CONTROL_PARAM;
pub const struct__CSV_QUERY_REDIRECT_STATE = extern struct {
    MdsNodeId: DWORD,
    DsNodeId: DWORD,
    FileRedirected: BOOLEAN,
};
pub const CSV_QUERY_REDIRECT_STATE = struct__CSV_QUERY_REDIRECT_STATE;
pub const PCSV_QUERY_REDIRECT_STATE = [*c]struct__CSV_QUERY_REDIRECT_STATE;
pub const struct__CSV_QUERY_FILE_REVISION = extern struct {
    FileId: LONGLONG,
    FileRevision: [3]LONGLONG,
};
pub const CSV_QUERY_FILE_REVISION = struct__CSV_QUERY_FILE_REVISION;
pub const PCSV_QUERY_FILE_REVISION = [*c]struct__CSV_QUERY_FILE_REVISION;
pub const struct__CSV_QUERY_FILE_REVISION_FILE_ID_128 = extern struct {
    FileId: FILE_ID_128,
    FileRevision: [3]LONGLONG,
};
pub const CSV_QUERY_FILE_REVISION_FILE_ID_128 = struct__CSV_QUERY_FILE_REVISION_FILE_ID_128;
pub const PCSV_QUERY_FILE_REVISION_FILE_ID_128 = [*c]struct__CSV_QUERY_FILE_REVISION_FILE_ID_128;
pub const struct__CSV_QUERY_MDS_PATH = extern struct {
    MdsNodeId: DWORD,
    DsNodeId: DWORD,
    PathLength: DWORD,
    Path: [1]WCHAR,
};
pub const CSV_QUERY_MDS_PATH = struct__CSV_QUERY_MDS_PATH;
pub const PCSV_QUERY_MDS_PATH = [*c]struct__CSV_QUERY_MDS_PATH;
pub const CsvFsDiskConnectivityNone = enum__CSVFS_DISK_CONNECTIVITY.CsvFsDiskConnectivityNone;
pub const CsvFsDiskConnectivityMdsNodeOnly = enum__CSVFS_DISK_CONNECTIVITY.CsvFsDiskConnectivityMdsNodeOnly;
pub const CsvFsDiskConnectivitySubsetOfNodes = enum__CSVFS_DISK_CONNECTIVITY.CsvFsDiskConnectivitySubsetOfNodes;
pub const CsvFsDiskConnectivityAllNodes = enum__CSVFS_DISK_CONNECTIVITY.CsvFsDiskConnectivityAllNodes;
pub const enum__CSVFS_DISK_CONNECTIVITY = extern enum {
    CsvFsDiskConnectivityNone = 0,
    CsvFsDiskConnectivityMdsNodeOnly = 1,
    CsvFsDiskConnectivitySubsetOfNodes = 2,
    CsvFsDiskConnectivityAllNodes = 3,
};
pub const CSVFS_DISK_CONNECTIVITY = enum__CSVFS_DISK_CONNECTIVITY;
pub const PCSVFS_DISK_CONNECTIVITY = [*c]enum__CSVFS_DISK_CONNECTIVITY;
pub const struct__CSV_QUERY_VOLUME_REDIRECT_STATE = extern struct {
    MdsNodeId: DWORD,
    DsNodeId: DWORD,
    IsDiskConnected: BOOLEAN,
    ClusterEnableDirectIo: BOOLEAN,
    DiskConnectivity: CSVFS_DISK_CONNECTIVITY,
};
pub const CSV_QUERY_VOLUME_REDIRECT_STATE = struct__CSV_QUERY_VOLUME_REDIRECT_STATE;
pub const PCSV_QUERY_VOLUME_REDIRECT_STATE = [*c]struct__CSV_QUERY_VOLUME_REDIRECT_STATE;
pub const struct__CSV_QUERY_MDS_PATH_V2 = extern struct {
    Version: LONGLONG,
    RequiredSize: DWORD,
    MdsNodeId: DWORD,
    DsNodeId: DWORD,
    Flags: DWORD,
    DiskConnectivity: CSVFS_DISK_CONNECTIVITY,
    VolumeId: GUID,
    IpAddressOffset: DWORD,
    IpAddressLength: DWORD,
    PathOffset: DWORD,
    PathLength: DWORD,
};
pub const CSV_QUERY_MDS_PATH_V2 = struct__CSV_QUERY_MDS_PATH_V2;
pub const PCSV_QUERY_MDS_PATH_V2 = [*c]struct__CSV_QUERY_MDS_PATH_V2;
pub const struct__CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT = extern struct {
    VetoedFromAltitudeIntegral: DWORDLONG,
    VetoedFromAltitudeDecimal: DWORDLONG,
    Reason: [256]WCHAR,
};
pub const CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT = struct__CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT;
pub const PCSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT = [*c]struct__CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT;
pub const StorageReserveIdNone = enum__STORAGE_RESERVE_ID.StorageReserveIdNone;
pub const StorageReserveIdHard = enum__STORAGE_RESERVE_ID.StorageReserveIdHard;
pub const StorageReserveIdSoft = enum__STORAGE_RESERVE_ID.StorageReserveIdSoft;
pub const StorageReserveIdUpdateScratch = enum__STORAGE_RESERVE_ID.StorageReserveIdUpdateScratch;
pub const StorageReserveIdMax = enum__STORAGE_RESERVE_ID.StorageReserveIdMax;
pub const enum__STORAGE_RESERVE_ID = extern enum {
    StorageReserveIdNone = 0,
    StorageReserveIdHard = 1,
    StorageReserveIdSoft = 2,
    StorageReserveIdUpdateScratch = 3,
    StorageReserveIdMax = 4,
};
pub const STORAGE_RESERVE_ID = enum__STORAGE_RESERVE_ID;
pub const PSTORAGE_RESERVE_ID = [*c]enum__STORAGE_RESERVE_ID;
pub const struct__CSV_IS_OWNED_BY_CSVFS = extern struct {
    OwnedByCSVFS: BOOLEAN,
};
pub const CSV_IS_OWNED_BY_CSVFS = struct__CSV_IS_OWNED_BY_CSVFS;
pub const PCSV_IS_OWNED_BY_CSVFS = [*c]struct__CSV_IS_OWNED_BY_CSVFS;
pub const struct__FILE_LEVEL_TRIM_RANGE = extern struct {
    Offset: DWORDLONG,
    Length: DWORDLONG,
};
pub const FILE_LEVEL_TRIM_RANGE = struct__FILE_LEVEL_TRIM_RANGE;
pub const PFILE_LEVEL_TRIM_RANGE = [*c]struct__FILE_LEVEL_TRIM_RANGE;
pub const struct__FILE_LEVEL_TRIM = extern struct {
    Key: DWORD,
    NumRanges: DWORD,
    Ranges: [1]FILE_LEVEL_TRIM_RANGE,
};
pub const FILE_LEVEL_TRIM = struct__FILE_LEVEL_TRIM;
pub const PFILE_LEVEL_TRIM = [*c]struct__FILE_LEVEL_TRIM;
pub const struct__FILE_LEVEL_TRIM_OUTPUT = extern struct {
    NumRangesProcessed: DWORD,
};
pub const FILE_LEVEL_TRIM_OUTPUT = struct__FILE_LEVEL_TRIM_OUTPUT;
pub const PFILE_LEVEL_TRIM_OUTPUT = [*c]struct__FILE_LEVEL_TRIM_OUTPUT;
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_NONE = enum__QUERY_FILE_LAYOUT_FILTER_TYPE.QUERY_FILE_LAYOUT_FILTER_TYPE_NONE;
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_CLUSTERS = enum__QUERY_FILE_LAYOUT_FILTER_TYPE.QUERY_FILE_LAYOUT_FILTER_TYPE_CLUSTERS;
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_FILEID = enum__QUERY_FILE_LAYOUT_FILTER_TYPE.QUERY_FILE_LAYOUT_FILTER_TYPE_FILEID;
pub const QUERY_FILE_LAYOUT_FILTER_TYPE_STORAGE_RESERVE_ID = enum__QUERY_FILE_LAYOUT_FILTER_TYPE.QUERY_FILE_LAYOUT_FILTER_TYPE_STORAGE_RESERVE_ID;
pub const QUERY_FILE_LAYOUT_NUM_FILTER_TYPES = enum__QUERY_FILE_LAYOUT_FILTER_TYPE.QUERY_FILE_LAYOUT_NUM_FILTER_TYPES;
pub const enum__QUERY_FILE_LAYOUT_FILTER_TYPE = extern enum {
    QUERY_FILE_LAYOUT_FILTER_TYPE_NONE = 0,
    QUERY_FILE_LAYOUT_FILTER_TYPE_CLUSTERS = 1,
    QUERY_FILE_LAYOUT_FILTER_TYPE_FILEID = 2,
    QUERY_FILE_LAYOUT_FILTER_TYPE_STORAGE_RESERVE_ID = 3,
    QUERY_FILE_LAYOUT_NUM_FILTER_TYPES = 4,
};
pub const QUERY_FILE_LAYOUT_FILTER_TYPE = enum__QUERY_FILE_LAYOUT_FILTER_TYPE;
pub const struct__CLUSTER_RANGE = extern struct {
    StartingCluster: LARGE_INTEGER,
    ClusterCount: LARGE_INTEGER,
};
pub const CLUSTER_RANGE = struct__CLUSTER_RANGE;
pub const PCLUSTER_RANGE = [*c]struct__CLUSTER_RANGE;
pub const struct__FILE_REFERENCE_RANGE = extern struct {
    StartingFileReferenceNumber: DWORDLONG,
    EndingFileReferenceNumber: DWORDLONG,
};
pub const FILE_REFERENCE_RANGE = struct__FILE_REFERENCE_RANGE;
pub const PFILE_REFERENCE_RANGE = [*c]struct__FILE_REFERENCE_RANGE;
pub const struct__QUERY_FILE_LAYOUT_INPUT = extern struct {
    @"": extern union {
        FilterEntryCount: DWORD,
        NumberOfPairs: DWORD,
    },
    Flags: DWORD,
    FilterType: QUERY_FILE_LAYOUT_FILTER_TYPE,
    Reserved: DWORD,
    Filter: extern union {
        ClusterRanges: [1]CLUSTER_RANGE,
        FileReferenceRanges: [1]FILE_REFERENCE_RANGE,
        StorageReserveIds: [1]STORAGE_RESERVE_ID,
    },
};
pub const QUERY_FILE_LAYOUT_INPUT = struct__QUERY_FILE_LAYOUT_INPUT;
pub const PQUERY_FILE_LAYOUT_INPUT = [*c]struct__QUERY_FILE_LAYOUT_INPUT;
pub const struct__QUERY_FILE_LAYOUT_OUTPUT = extern struct {
    FileEntryCount: DWORD,
    FirstFileOffset: DWORD,
    Flags: DWORD,
    Reserved: DWORD,
};
pub const QUERY_FILE_LAYOUT_OUTPUT = struct__QUERY_FILE_LAYOUT_OUTPUT;
pub const PQUERY_FILE_LAYOUT_OUTPUT = [*c]struct__QUERY_FILE_LAYOUT_OUTPUT;
pub const struct__FILE_LAYOUT_ENTRY = extern struct {
    Version: DWORD,
    NextFileOffset: DWORD,
    Flags: DWORD,
    FileAttributes: DWORD,
    FileReferenceNumber: DWORDLONG,
    FirstNameOffset: DWORD,
    FirstStreamOffset: DWORD,
    ExtraInfoOffset: DWORD,
    ExtraInfoLength: DWORD,
};
pub const FILE_LAYOUT_ENTRY = struct__FILE_LAYOUT_ENTRY;
pub const PFILE_LAYOUT_ENTRY = [*c]struct__FILE_LAYOUT_ENTRY;
pub const struct__FILE_LAYOUT_NAME_ENTRY = extern struct {
    NextNameOffset: DWORD,
    Flags: DWORD,
    ParentFileReferenceNumber: DWORDLONG,
    FileNameLength: DWORD,
    Reserved: DWORD,
    FileName: [1]WCHAR,
};
pub const FILE_LAYOUT_NAME_ENTRY = struct__FILE_LAYOUT_NAME_ENTRY;
pub const PFILE_LAYOUT_NAME_ENTRY = [*c]struct__FILE_LAYOUT_NAME_ENTRY;
pub const struct__FILE_LAYOUT_INFO_ENTRY = extern struct {
    BasicInformation: extern struct {
        CreationTime: LARGE_INTEGER,
        LastAccessTime: LARGE_INTEGER,
        LastWriteTime: LARGE_INTEGER,
        ChangeTime: LARGE_INTEGER,
        FileAttributes: DWORD,
    },
    OwnerId: DWORD,
    SecurityId: DWORD,
    Usn: USN,
    StorageReserveId: STORAGE_RESERVE_ID,
};
pub const FILE_LAYOUT_INFO_ENTRY = struct__FILE_LAYOUT_INFO_ENTRY;
pub const PFILE_LAYOUT_INFO_ENTRY = [*c]struct__FILE_LAYOUT_INFO_ENTRY;
pub const struct__STREAM_LAYOUT_ENTRY = extern struct {
    Version: DWORD,
    NextStreamOffset: DWORD,
    Flags: DWORD,
    ExtentInformationOffset: DWORD,
    AllocationSize: LARGE_INTEGER,
    EndOfFile: LARGE_INTEGER,
    StreamInformationOffset: DWORD,
    AttributeTypeCode: DWORD,
    AttributeFlags: DWORD,
    StreamIdentifierLength: DWORD,
    StreamIdentifier: [1]WCHAR,
};
pub const STREAM_LAYOUT_ENTRY = struct__STREAM_LAYOUT_ENTRY;
pub const PSTREAM_LAYOUT_ENTRY = [*c]struct__STREAM_LAYOUT_ENTRY;
pub const struct__STREAM_EXTENT_ENTRY = extern struct {
    Flags: DWORD,
    ExtentInformation: extern union {
        RetrievalPointers: RETRIEVAL_POINTERS_BUFFER,
    },
};
pub const STREAM_EXTENT_ENTRY = struct__STREAM_EXTENT_ENTRY;
pub const PSTREAM_EXTENT_ENTRY = [*c]struct__STREAM_EXTENT_ENTRY;
pub const struct__FSCTL_GET_INTEGRITY_INFORMATION_BUFFER = extern struct {
    ChecksumAlgorithm: WORD,
    Reserved: WORD,
    Flags: DWORD,
    ChecksumChunkSizeInBytes: DWORD,
    ClusterSizeInBytes: DWORD,
};
pub const FSCTL_GET_INTEGRITY_INFORMATION_BUFFER = struct__FSCTL_GET_INTEGRITY_INFORMATION_BUFFER;
pub const PFSCTL_GET_INTEGRITY_INFORMATION_BUFFER = [*c]struct__FSCTL_GET_INTEGRITY_INFORMATION_BUFFER;
pub const struct__FSCTL_SET_INTEGRITY_INFORMATION_BUFFER = extern struct {
    ChecksumAlgorithm: WORD,
    Reserved: WORD,
    Flags: DWORD,
};
pub const FSCTL_SET_INTEGRITY_INFORMATION_BUFFER = struct__FSCTL_SET_INTEGRITY_INFORMATION_BUFFER;
pub const PFSCTL_SET_INTEGRITY_INFORMATION_BUFFER = [*c]struct__FSCTL_SET_INTEGRITY_INFORMATION_BUFFER;
pub const struct__FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX = extern struct {
    EnableIntegrity: BYTE,
    KeepIntegrityStateUnchanged: BYTE,
    Reserved: WORD,
    Flags: DWORD,
    Version: BYTE,
    Reserved2: [7]BYTE,
};
pub const FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX = struct__FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX;
pub const PFSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX = [*c]struct__FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX;
pub const struct__FSCTL_OFFLOAD_READ_INPUT = extern struct {
    Size: DWORD,
    Flags: DWORD,
    TokenTimeToLive: DWORD,
    Reserved: DWORD,
    FileOffset: DWORDLONG,
    CopyLength: DWORDLONG,
};
pub const FSCTL_OFFLOAD_READ_INPUT = struct__FSCTL_OFFLOAD_READ_INPUT;
pub const PFSCTL_OFFLOAD_READ_INPUT = [*c]struct__FSCTL_OFFLOAD_READ_INPUT;
pub const struct__FSCTL_OFFLOAD_READ_OUTPUT = extern struct {
    Size: DWORD,
    Flags: DWORD,
    TransferLength: DWORDLONG,
    Token: [512]BYTE,
};
pub const FSCTL_OFFLOAD_READ_OUTPUT = struct__FSCTL_OFFLOAD_READ_OUTPUT;
pub const PFSCTL_OFFLOAD_READ_OUTPUT = [*c]struct__FSCTL_OFFLOAD_READ_OUTPUT;
pub const struct__FSCTL_OFFLOAD_WRITE_INPUT = extern struct {
    Size: DWORD,
    Flags: DWORD,
    FileOffset: DWORDLONG,
    CopyLength: DWORDLONG,
    TransferOffset: DWORDLONG,
    Token: [512]BYTE,
};
pub const FSCTL_OFFLOAD_WRITE_INPUT = struct__FSCTL_OFFLOAD_WRITE_INPUT;
pub const PFSCTL_OFFLOAD_WRITE_INPUT = [*c]struct__FSCTL_OFFLOAD_WRITE_INPUT;
pub const struct__FSCTL_OFFLOAD_WRITE_OUTPUT = extern struct {
    Size: DWORD,
    Flags: DWORD,
    LengthWritten: DWORDLONG,
};
pub const FSCTL_OFFLOAD_WRITE_OUTPUT = struct__FSCTL_OFFLOAD_WRITE_OUTPUT;
pub const PFSCTL_OFFLOAD_WRITE_OUTPUT = [*c]struct__FSCTL_OFFLOAD_WRITE_OUTPUT;
pub const struct__SET_PURGE_FAILURE_MODE_INPUT = extern struct {
    Flags: DWORD,
};
pub const SET_PURGE_FAILURE_MODE_INPUT = struct__SET_PURGE_FAILURE_MODE_INPUT;
pub const PSET_PURGE_FAILURE_MODE_INPUT = [*c]struct__SET_PURGE_FAILURE_MODE_INPUT;
pub const struct__REPAIR_COPIES_INPUT = extern struct {
    Size: DWORD,
    Flags: DWORD,
    FileOffset: LARGE_INTEGER,
    Length: DWORD,
    SourceCopy: DWORD,
    NumberOfRepairCopies: DWORD,
    RepairCopies: [1]DWORD,
};
pub const REPAIR_COPIES_INPUT = struct__REPAIR_COPIES_INPUT;
pub const PREPAIR_COPIES_INPUT = [*c]struct__REPAIR_COPIES_INPUT;
pub const struct__REPAIR_COPIES_OUTPUT = extern struct {
    Size: DWORD,
    Status: DWORD,
    ResumeFileOffset: LARGE_INTEGER,
};
pub const REPAIR_COPIES_OUTPUT = struct__REPAIR_COPIES_OUTPUT;
pub const PREPAIR_COPIES_OUTPUT = [*c]struct__REPAIR_COPIES_OUTPUT;
pub const struct__FILE_REGION_INFO = extern struct {
    FileOffset: LONGLONG,
    Length: LONGLONG,
    Usage: DWORD,
    Reserved: DWORD,
};
pub const FILE_REGION_INFO = struct__FILE_REGION_INFO;
pub const PFILE_REGION_INFO = [*c]struct__FILE_REGION_INFO;
pub const struct__FILE_REGION_OUTPUT = extern struct {
    Flags: DWORD,
    TotalRegionEntryCount: DWORD,
    RegionEntryCount: DWORD,
    Reserved: DWORD,
    Region: [1]FILE_REGION_INFO,
};
pub const FILE_REGION_OUTPUT = struct__FILE_REGION_OUTPUT;
pub const PFILE_REGION_OUTPUT = [*c]struct__FILE_REGION_OUTPUT;
pub const struct__FILE_REGION_INPUT = extern struct {
    FileOffset: LONGLONG,
    Length: LONGLONG,
    DesiredUsage: DWORD,
};
pub const FILE_REGION_INPUT = struct__FILE_REGION_INPUT;
pub const PFILE_REGION_INPUT = [*c]struct__FILE_REGION_INPUT;
pub const struct__WRITE_USN_REASON_INPUT = extern struct {
    Flags: DWORD,
    UsnReasonToWrite: DWORD,
};
pub const WRITE_USN_REASON_INPUT = struct__WRITE_USN_REASON_INPUT;
pub const PWRITE_USN_REASON_INPUT = [*c]struct__WRITE_USN_REASON_INPUT;
pub const FileStorageTierMediaTypeUnspecified = enum__FILE_STORAGE_TIER_MEDIA_TYPE.FileStorageTierMediaTypeUnspecified;
pub const FileStorageTierMediaTypeDisk = enum__FILE_STORAGE_TIER_MEDIA_TYPE.FileStorageTierMediaTypeDisk;
pub const FileStorageTierMediaTypeSsd = enum__FILE_STORAGE_TIER_MEDIA_TYPE.FileStorageTierMediaTypeSsd;
pub const FileStorageTierMediaTypeScm = enum__FILE_STORAGE_TIER_MEDIA_TYPE.FileStorageTierMediaTypeScm;
pub const FileStorageTierMediaTypeMax = enum__FILE_STORAGE_TIER_MEDIA_TYPE.FileStorageTierMediaTypeMax;
pub const enum__FILE_STORAGE_TIER_MEDIA_TYPE = extern enum {
    FileStorageTierMediaTypeUnspecified = 0,
    FileStorageTierMediaTypeDisk = 1,
    FileStorageTierMediaTypeSsd = 2,
    FileStorageTierMediaTypeScm = 4,
    FileStorageTierMediaTypeMax = 5,
};
pub const FILE_STORAGE_TIER_MEDIA_TYPE = enum__FILE_STORAGE_TIER_MEDIA_TYPE;
pub const PFILE_STORAGE_TIER_MEDIA_TYPE = [*c]enum__FILE_STORAGE_TIER_MEDIA_TYPE;
pub const FileStorageTierClassUnspecified = enum__FILE_STORAGE_TIER_CLASS.FileStorageTierClassUnspecified;
pub const FileStorageTierClassCapacity = enum__FILE_STORAGE_TIER_CLASS.FileStorageTierClassCapacity;
pub const FileStorageTierClassPerformance = enum__FILE_STORAGE_TIER_CLASS.FileStorageTierClassPerformance;
pub const FileStorageTierClassMax = enum__FILE_STORAGE_TIER_CLASS.FileStorageTierClassMax;
pub const enum__FILE_STORAGE_TIER_CLASS = extern enum {
    FileStorageTierClassUnspecified = 0,
    FileStorageTierClassCapacity = 1,
    FileStorageTierClassPerformance = 2,
    FileStorageTierClassMax = 3,
};
pub const FILE_STORAGE_TIER_CLASS = enum__FILE_STORAGE_TIER_CLASS;
pub const PFILE_STORAGE_TIER_CLASS = [*c]enum__FILE_STORAGE_TIER_CLASS;
pub const struct__FILE_STORAGE_TIER = extern struct {
    Id: GUID,
    Name: [256]WCHAR,
    Description: [256]WCHAR,
    Flags: DWORDLONG,
    ProvisionedCapacity: DWORDLONG,
    MediaType: FILE_STORAGE_TIER_MEDIA_TYPE,
    Class: FILE_STORAGE_TIER_CLASS,
};
pub const FILE_STORAGE_TIER = struct__FILE_STORAGE_TIER;
pub const PFILE_STORAGE_TIER = [*c]struct__FILE_STORAGE_TIER;
pub const struct__FSCTL_QUERY_STORAGE_CLASSES_OUTPUT = extern struct {
    Version: DWORD,
    Size: DWORD,
    Flags: DWORD,
    TotalNumberOfTiers: DWORD,
    NumberOfTiersReturned: DWORD,
    Tiers: [1]FILE_STORAGE_TIER,
};
pub const FSCTL_QUERY_STORAGE_CLASSES_OUTPUT = struct__FSCTL_QUERY_STORAGE_CLASSES_OUTPUT;
pub const PFSCTL_QUERY_STORAGE_CLASSES_OUTPUT = [*c]struct__FSCTL_QUERY_STORAGE_CLASSES_OUTPUT;
pub const struct__DesiredStorageClass = extern struct {
    Class: FILE_STORAGE_TIER_CLASS,
    Flags: DWORD,
};
pub const union__StreamInformation = extern union {
    DesiredStorageClass: struct__DesiredStorageClass,
};
pub const struct__STREAM_INFORMATION_ENTRY = extern struct {
    Version: DWORD,
    Flags: DWORD,
    StreamInformation: union__StreamInformation,
};
pub const STREAM_INFORMATION_ENTRY = struct__STREAM_INFORMATION_ENTRY;
pub const PSTREAM_INFORMATION_ENTRY = [*c]struct__STREAM_INFORMATION_ENTRY;
pub const struct__FSCTL_QUERY_REGION_INFO_INPUT = extern struct {
    Version: DWORD,
    Size: DWORD,
    Flags: DWORD,
    NumberOfTierIds: DWORD,
    TierIds: [1]GUID,
};
pub const FSCTL_QUERY_REGION_INFO_INPUT = struct__FSCTL_QUERY_REGION_INFO_INPUT;
pub const PFSCTL_QUERY_REGION_INFO_INPUT = [*c]struct__FSCTL_QUERY_REGION_INFO_INPUT;
pub const struct__FILE_STORAGE_TIER_REGION = extern struct {
    TierId: GUID,
    Offset: DWORDLONG,
    Length: DWORDLONG,
};
pub const FILE_STORAGE_TIER_REGION = struct__FILE_STORAGE_TIER_REGION;
pub const PFILE_STORAGE_TIER_REGION = [*c]struct__FILE_STORAGE_TIER_REGION;
pub const struct__FSCTL_QUERY_REGION_INFO_OUTPUT = extern struct {
    Version: DWORD,
    Size: DWORD,
    Flags: DWORD,
    Reserved: DWORD,
    Alignment: DWORDLONG,
    TotalNumberOfRegions: DWORD,
    NumberOfRegionsReturned: DWORD,
    Regions: [1]FILE_STORAGE_TIER_REGION,
};
pub const FSCTL_QUERY_REGION_INFO_OUTPUT = struct__FSCTL_QUERY_REGION_INFO_OUTPUT;
pub const PFSCTL_QUERY_REGION_INFO_OUTPUT = [*c]struct__FSCTL_QUERY_REGION_INFO_OUTPUT;
pub const struct__FILE_DESIRED_STORAGE_CLASS_INFORMATION = extern struct {
    Class: FILE_STORAGE_TIER_CLASS,
    Flags: DWORD,
};
pub const FILE_DESIRED_STORAGE_CLASS_INFORMATION = struct__FILE_DESIRED_STORAGE_CLASS_INFORMATION;
pub const PFILE_DESIRED_STORAGE_CLASS_INFORMATION = [*c]struct__FILE_DESIRED_STORAGE_CLASS_INFORMATION;
pub const struct__DUPLICATE_EXTENTS_DATA = extern struct {
    FileHandle: HANDLE,
    SourceFileOffset: LARGE_INTEGER,
    TargetFileOffset: LARGE_INTEGER,
    ByteCount: LARGE_INTEGER,
};
pub const DUPLICATE_EXTENTS_DATA = struct__DUPLICATE_EXTENTS_DATA;
pub const PDUPLICATE_EXTENTS_DATA = [*c]struct__DUPLICATE_EXTENTS_DATA;
pub const struct__DUPLICATE_EXTENTS_DATA32 = extern struct {
    FileHandle: UINT32,
    SourceFileOffset: LARGE_INTEGER,
    TargetFileOffset: LARGE_INTEGER,
    ByteCount: LARGE_INTEGER,
};
pub const DUPLICATE_EXTENTS_DATA32 = struct__DUPLICATE_EXTENTS_DATA32;
pub const PDUPLICATE_EXTENTS_DATA32 = [*c]struct__DUPLICATE_EXTENTS_DATA32;
pub const struct__DUPLICATE_EXTENTS_DATA_EX = extern struct {
    Size: SIZE_T,
    FileHandle: HANDLE,
    SourceFileOffset: LARGE_INTEGER,
    TargetFileOffset: LARGE_INTEGER,
    ByteCount: LARGE_INTEGER,
    Flags: DWORD,
};
pub const DUPLICATE_EXTENTS_DATA_EX = struct__DUPLICATE_EXTENTS_DATA_EX;
pub const PDUPLICATE_EXTENTS_DATA_EX = [*c]struct__DUPLICATE_EXTENTS_DATA_EX;
pub const struct__DUPLICATE_EXTENTS_DATA_EX32 = extern struct {
    Size: DWORD32,
    FileHandle: DWORD32,
    SourceFileOffset: LARGE_INTEGER,
    TargetFileOffset: LARGE_INTEGER,
    ByteCount: LARGE_INTEGER,
    Flags: DWORD,
};
pub const DUPLICATE_EXTENTS_DATA_EX32 = struct__DUPLICATE_EXTENTS_DATA_EX32;
pub const PDUPLICATE_EXTENTS_DATA_EX32 = [*c]struct__DUPLICATE_EXTENTS_DATA_EX32;
pub const SmrGcStateInactive = enum__REFS_SMR_VOLUME_GC_STATE.SmrGcStateInactive;
pub const SmrGcStatePaused = enum__REFS_SMR_VOLUME_GC_STATE.SmrGcStatePaused;
pub const SmrGcStateActive = enum__REFS_SMR_VOLUME_GC_STATE.SmrGcStateActive;
pub const SmrGcStateActiveFullSpeed = enum__REFS_SMR_VOLUME_GC_STATE.SmrGcStateActiveFullSpeed;
pub const enum__REFS_SMR_VOLUME_GC_STATE = extern enum {
    SmrGcStateInactive = 0,
    SmrGcStatePaused = 1,
    SmrGcStateActive = 2,
    SmrGcStateActiveFullSpeed = 3,
};
pub const REFS_SMR_VOLUME_GC_STATE = enum__REFS_SMR_VOLUME_GC_STATE;
pub const PREFS_SMR_VOLUME_GC_STATE = [*c]enum__REFS_SMR_VOLUME_GC_STATE;
pub const struct__REFS_SMR_VOLUME_INFO_OUTPUT = extern struct {
    Version: DWORD,
    Flags: DWORD,
    SizeOfRandomlyWritableTier: LARGE_INTEGER,
    FreeSpaceInRandomlyWritableTier: LARGE_INTEGER,
    SizeofSMRTier: LARGE_INTEGER,
    FreeSpaceInSMRTier: LARGE_INTEGER,
    UsableFreeSpaceInSMRTier: LARGE_INTEGER,
    VolumeGcState: REFS_SMR_VOLUME_GC_STATE,
    VolumeGcLastStatus: DWORD,
    Unused: [7]DWORDLONG,
};
pub const REFS_SMR_VOLUME_INFO_OUTPUT = struct__REFS_SMR_VOLUME_INFO_OUTPUT;
pub const PREFS_SMR_VOLUME_INFO_OUTPUT = [*c]struct__REFS_SMR_VOLUME_INFO_OUTPUT;
pub const SmrGcActionStart = enum__REFS_SMR_VOLUME_GC_ACTION.SmrGcActionStart;
pub const SmrGcActionStartFullSpeed = enum__REFS_SMR_VOLUME_GC_ACTION.SmrGcActionStartFullSpeed;
pub const SmrGcActionPause = enum__REFS_SMR_VOLUME_GC_ACTION.SmrGcActionPause;
pub const SmrGcActionStop = enum__REFS_SMR_VOLUME_GC_ACTION.SmrGcActionStop;
pub const enum__REFS_SMR_VOLUME_GC_ACTION = extern enum {
    SmrGcActionStart = 1,
    SmrGcActionStartFullSpeed = 2,
    SmrGcActionPause = 3,
    SmrGcActionStop = 4,
};
pub const REFS_SMR_VOLUME_GC_ACTION = enum__REFS_SMR_VOLUME_GC_ACTION;
pub const PREFS_SMR_VOLUME_GC_ACTION = [*c]enum__REFS_SMR_VOLUME_GC_ACTION;
pub const SmrGcMethodCompaction = enum__REFS_SMR_VOLUME_GC_METHOD.SmrGcMethodCompaction;
pub const SmrGcMethodCompression = enum__REFS_SMR_VOLUME_GC_METHOD.SmrGcMethodCompression;
pub const SmrGcMethodRotation = enum__REFS_SMR_VOLUME_GC_METHOD.SmrGcMethodRotation;
pub const enum__REFS_SMR_VOLUME_GC_METHOD = extern enum {
    SmrGcMethodCompaction = 1,
    SmrGcMethodCompression = 2,
    SmrGcMethodRotation = 3,
};
pub const REFS_SMR_VOLUME_GC_METHOD = enum__REFS_SMR_VOLUME_GC_METHOD;
pub const PREFS_SMR_VOLUME_GC_METHOD = [*c]enum__REFS_SMR_VOLUME_GC_METHOD;
pub const struct__REFS_SMR_VOLUME_GC_PARAMETERS = extern struct {
    Version: DWORD,
    Flags: DWORD,
    Action: REFS_SMR_VOLUME_GC_ACTION,
    Method: REFS_SMR_VOLUME_GC_METHOD,
    IoGranularity: DWORD,
    CompressionFormat: DWORD,
    Unused: [8]DWORDLONG,
};
pub const REFS_SMR_VOLUME_GC_PARAMETERS = struct__REFS_SMR_VOLUME_GC_PARAMETERS;
pub const PREFS_SMR_VOLUME_GC_PARAMETERS = [*c]struct__REFS_SMR_VOLUME_GC_PARAMETERS;
pub const struct__STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER = extern struct {
    OptimalWriteSize: DWORD,
    StreamGranularitySize: DWORD,
    StreamIdMin: DWORD,
    StreamIdMax: DWORD,
};
pub const STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER = struct__STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER;
pub const PSTREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER = [*c]struct__STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER;
pub const struct__STREAMS_ASSOCIATE_ID_INPUT_BUFFER = extern struct {
    Flags: DWORD,
    StreamId: DWORD,
};
pub const STREAMS_ASSOCIATE_ID_INPUT_BUFFER = struct__STREAMS_ASSOCIATE_ID_INPUT_BUFFER;
pub const PSTREAMS_ASSOCIATE_ID_INPUT_BUFFER = [*c]struct__STREAMS_ASSOCIATE_ID_INPUT_BUFFER;
pub const struct__STREAMS_QUERY_ID_OUTPUT_BUFFER = extern struct {
    StreamId: DWORD,
};
pub const STREAMS_QUERY_ID_OUTPUT_BUFFER = struct__STREAMS_QUERY_ID_OUTPUT_BUFFER;
pub const PSTREAMS_QUERY_ID_OUTPUT_BUFFER = [*c]struct__STREAMS_QUERY_ID_OUTPUT_BUFFER;
pub const struct__QUERY_BAD_RANGES_INPUT_RANGE = extern struct {
    StartOffset: DWORDLONG,
    LengthInBytes: DWORDLONG,
};
pub const QUERY_BAD_RANGES_INPUT_RANGE = struct__QUERY_BAD_RANGES_INPUT_RANGE;
pub const PQUERY_BAD_RANGES_INPUT_RANGE = [*c]struct__QUERY_BAD_RANGES_INPUT_RANGE;
pub const struct__QUERY_BAD_RANGES_INPUT = extern struct {
    Flags: DWORD,
    NumRanges: DWORD,
    Ranges: [1]QUERY_BAD_RANGES_INPUT_RANGE,
};
pub const QUERY_BAD_RANGES_INPUT = struct__QUERY_BAD_RANGES_INPUT;
pub const PQUERY_BAD_RANGES_INPUT = [*c]struct__QUERY_BAD_RANGES_INPUT;
pub const struct__QUERY_BAD_RANGES_OUTPUT_RANGE = extern struct {
    Flags: DWORD,
    Reserved: DWORD,
    StartOffset: DWORDLONG,
    LengthInBytes: DWORDLONG,
};
pub const QUERY_BAD_RANGES_OUTPUT_RANGE = struct__QUERY_BAD_RANGES_OUTPUT_RANGE;
pub const PQUERY_BAD_RANGES_OUTPUT_RANGE = [*c]struct__QUERY_BAD_RANGES_OUTPUT_RANGE;
pub const struct__QUERY_BAD_RANGES_OUTPUT = extern struct {
    Flags: DWORD,
    NumBadRanges: DWORD,
    NextOffsetToLookUp: DWORDLONG,
    BadRanges: [1]QUERY_BAD_RANGES_OUTPUT_RANGE,
};
pub const QUERY_BAD_RANGES_OUTPUT = struct__QUERY_BAD_RANGES_OUTPUT;
pub const PQUERY_BAD_RANGES_OUTPUT = [*c]struct__QUERY_BAD_RANGES_OUTPUT;
pub const struct__SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT = extern struct {
    Flags: DWORD,
    AlignmentShift: DWORD,
    FileOffsetToAlign: DWORDLONG,
    FallbackAlignmentShift: DWORD,
};
pub const SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT = struct__SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT;
pub const PSET_DAX_ALLOC_ALIGNMENT_HINT_INPUT = [*c]struct__SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT;
pub const VirtualStorageBehaviorUndefined = enum__VIRTUAL_STORAGE_BEHAVIOR_CODE.VirtualStorageBehaviorUndefined;
pub const VirtualStorageBehaviorCacheWriteThrough = enum__VIRTUAL_STORAGE_BEHAVIOR_CODE.VirtualStorageBehaviorCacheWriteThrough;
pub const VirtualStorageBehaviorCacheWriteBack = enum__VIRTUAL_STORAGE_BEHAVIOR_CODE.VirtualStorageBehaviorCacheWriteBack;
pub const enum__VIRTUAL_STORAGE_BEHAVIOR_CODE = extern enum {
    VirtualStorageBehaviorUndefined = 0,
    VirtualStorageBehaviorCacheWriteThrough = 1,
    VirtualStorageBehaviorCacheWriteBack = 2,
};
pub const VIRTUAL_STORAGE_BEHAVIOR_CODE = enum__VIRTUAL_STORAGE_BEHAVIOR_CODE;
pub const PVIRTUAL_STORAGE_BEHAVIOR_CODE = [*c]enum__VIRTUAL_STORAGE_BEHAVIOR_CODE;
pub const struct__VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT = extern struct {
    Size: DWORD,
    BehaviorCode: VIRTUAL_STORAGE_BEHAVIOR_CODE,
};
pub const VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT = struct__VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT;
pub const PVIRTUAL_STORAGE_SET_BEHAVIOR_INPUT = [*c]struct__VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT;
pub const struct__ENCRYPTION_KEY_CTRL_INPUT = extern struct {
    HeaderSize: DWORD,
    StructureSize: DWORD,
    KeyOffset: WORD,
    KeySize: WORD,
    DplLock: DWORD,
    DplUserId: DWORDLONG,
    DplCredentialId: DWORDLONG,
};
pub const ENCRYPTION_KEY_CTRL_INPUT = struct__ENCRYPTION_KEY_CTRL_INPUT;
pub const PENCRYPTION_KEY_CTRL_INPUT = [*c]struct__ENCRYPTION_KEY_CTRL_INPUT;
pub const struct__WOF_EXTERNAL_INFO = extern struct {
    Version: DWORD,
    Provider: DWORD,
};
pub const WOF_EXTERNAL_INFO = struct__WOF_EXTERNAL_INFO;
pub const PWOF_EXTERNAL_INFO = [*c]struct__WOF_EXTERNAL_INFO;
pub const struct__WOF_EXTERNAL_FILE_ID = extern struct {
    FileId: FILE_ID_128,
};
pub const WOF_EXTERNAL_FILE_ID = struct__WOF_EXTERNAL_FILE_ID;
pub const PWOF_EXTERNAL_FILE_ID = [*c]struct__WOF_EXTERNAL_FILE_ID;
pub const struct__WOF_VERSION_INFO = extern struct {
    WofVersion: DWORD,
};
pub const WOF_VERSION_INFO = struct__WOF_VERSION_INFO;
pub const PWOF_VERSION_INFO = [*c]struct__WOF_VERSION_INFO;
pub const struct__WIM_PROVIDER_EXTERNAL_INFO = extern struct {
    Version: DWORD,
    Flags: DWORD,
    DataSourceId: LARGE_INTEGER,
    ResourceHash: [20]BYTE,
};
pub const WIM_PROVIDER_EXTERNAL_INFO = struct__WIM_PROVIDER_EXTERNAL_INFO;
pub const PWIM_PROVIDER_EXTERNAL_INFO = [*c]struct__WIM_PROVIDER_EXTERNAL_INFO;
pub const struct__WIM_PROVIDER_ADD_OVERLAY_INPUT = extern struct {
    WimType: DWORD,
    WimIndex: DWORD,
    WimFileNameOffset: DWORD,
    WimFileNameLength: DWORD,
};
pub const WIM_PROVIDER_ADD_OVERLAY_INPUT = struct__WIM_PROVIDER_ADD_OVERLAY_INPUT;
pub const PWIM_PROVIDER_ADD_OVERLAY_INPUT = [*c]struct__WIM_PROVIDER_ADD_OVERLAY_INPUT;
pub const struct__WIM_PROVIDER_UPDATE_OVERLAY_INPUT = extern struct {
    DataSourceId: LARGE_INTEGER,
    WimFileNameOffset: DWORD,
    WimFileNameLength: DWORD,
};
pub const WIM_PROVIDER_UPDATE_OVERLAY_INPUT = struct__WIM_PROVIDER_UPDATE_OVERLAY_INPUT;
pub const PWIM_PROVIDER_UPDATE_OVERLAY_INPUT = [*c]struct__WIM_PROVIDER_UPDATE_OVERLAY_INPUT;
pub const struct__WIM_PROVIDER_REMOVE_OVERLAY_INPUT = extern struct {
    DataSourceId: LARGE_INTEGER,
};
pub const WIM_PROVIDER_REMOVE_OVERLAY_INPUT = struct__WIM_PROVIDER_REMOVE_OVERLAY_INPUT;
pub const PWIM_PROVIDER_REMOVE_OVERLAY_INPUT = [*c]struct__WIM_PROVIDER_REMOVE_OVERLAY_INPUT;
pub const struct__WIM_PROVIDER_SUSPEND_OVERLAY_INPUT = extern struct {
    DataSourceId: LARGE_INTEGER,
};
pub const WIM_PROVIDER_SUSPEND_OVERLAY_INPUT = struct__WIM_PROVIDER_SUSPEND_OVERLAY_INPUT;
pub const PWIM_PROVIDER_SUSPEND_OVERLAY_INPUT = [*c]struct__WIM_PROVIDER_SUSPEND_OVERLAY_INPUT;
pub const struct__WIM_PROVIDER_OVERLAY_ENTRY = extern struct {
    NextEntryOffset: DWORD,
    DataSourceId: LARGE_INTEGER,
    WimGuid: GUID,
    WimFileNameOffset: DWORD,
    WimType: DWORD,
    WimIndex: DWORD,
    Flags: DWORD,
};
pub const WIM_PROVIDER_OVERLAY_ENTRY = struct__WIM_PROVIDER_OVERLAY_ENTRY;
pub const PWIM_PROVIDER_OVERLAY_ENTRY = [*c]struct__WIM_PROVIDER_OVERLAY_ENTRY;
pub const struct__FILE_PROVIDER_EXTERNAL_INFO_V0 = extern struct {
    Version: DWORD,
    Algorithm: DWORD,
};
pub const FILE_PROVIDER_EXTERNAL_INFO_V0 = struct__FILE_PROVIDER_EXTERNAL_INFO_V0;
pub const PFILE_PROVIDER_EXTERNAL_INFO_V0 = [*c]struct__FILE_PROVIDER_EXTERNAL_INFO_V0;
pub const struct__FILE_PROVIDER_EXTERNAL_INFO_V1 = extern struct {
    Version: DWORD,
    Algorithm: DWORD,
    Flags: DWORD,
};
pub const FILE_PROVIDER_EXTERNAL_INFO_V1 = struct__FILE_PROVIDER_EXTERNAL_INFO_V1;
pub const PFILE_PROVIDER_EXTERNAL_INFO_V1 = [*c]struct__FILE_PROVIDER_EXTERNAL_INFO_V1;
pub const FILE_PROVIDER_EXTERNAL_INFO = FILE_PROVIDER_EXTERNAL_INFO_V1;
pub const PFILE_PROVIDER_EXTERNAL_INFO = PFILE_PROVIDER_EXTERNAL_INFO_V1;
pub const struct__CONTAINER_VOLUME_STATE = extern struct {
    Flags: DWORD,
};
pub const CONTAINER_VOLUME_STATE = struct__CONTAINER_VOLUME_STATE;
pub const PCONTAINER_VOLUME_STATE = [*c]struct__CONTAINER_VOLUME_STATE;
pub const struct__CONTAINER_ROOT_INFO_INPUT = extern struct {
    Flags: DWORD,
};
pub const CONTAINER_ROOT_INFO_INPUT = struct__CONTAINER_ROOT_INFO_INPUT;
pub const PCONTAINER_ROOT_INFO_INPUT = [*c]struct__CONTAINER_ROOT_INFO_INPUT;
pub const struct__CONTAINER_ROOT_INFO_OUTPUT = extern struct {
    ContainerRootIdLength: WORD,
    ContainerRootId: [1]BYTE,
};
pub const CONTAINER_ROOT_INFO_OUTPUT = struct__CONTAINER_ROOT_INFO_OUTPUT;
pub const PCONTAINER_ROOT_INFO_OUTPUT = [*c]struct__CONTAINER_ROOT_INFO_OUTPUT;
pub const struct__VIRTUALIZATION_INSTANCE_INFO_INPUT = extern struct {
    NumberOfWorkerThreads: DWORD,
    Flags: DWORD,
};
pub const VIRTUALIZATION_INSTANCE_INFO_INPUT = struct__VIRTUALIZATION_INSTANCE_INFO_INPUT;
pub const PVIRTUALIZATION_INSTANCE_INFO_INPUT = [*c]struct__VIRTUALIZATION_INSTANCE_INFO_INPUT;
pub const struct__VIRTUALIZATION_INSTANCE_INFO_INPUT_EX = extern struct {
    HeaderSize: WORD,
    Flags: DWORD,
    NotificationInfoSize: DWORD,
    NotificationInfoOffset: WORD,
    ProviderMajorVersion: WORD,
};
pub const VIRTUALIZATION_INSTANCE_INFO_INPUT_EX = struct__VIRTUALIZATION_INSTANCE_INFO_INPUT_EX;
pub const PVIRTUALIZATION_INSTANCE_INFO_INPUT_EX = [*c]struct__VIRTUALIZATION_INSTANCE_INFO_INPUT_EX;
pub const struct__VIRTUALIZATION_INSTANCE_INFO_OUTPUT = extern struct {
    VirtualizationInstanceID: GUID,
};
pub const VIRTUALIZATION_INSTANCE_INFO_OUTPUT = struct__VIRTUALIZATION_INSTANCE_INFO_OUTPUT;
pub const PVIRTUALIZATION_INSTANCE_INFO_OUTPUT = [*c]struct__VIRTUALIZATION_INSTANCE_INFO_OUTPUT;
pub const struct__GET_FILTER_FILE_IDENTIFIER_INPUT = extern struct {
    AltitudeLength: WORD,
    Altitude: [1]WCHAR,
};
pub const GET_FILTER_FILE_IDENTIFIER_INPUT = struct__GET_FILTER_FILE_IDENTIFIER_INPUT;
pub const PGET_FILTER_FILE_IDENTIFIER_INPUT = [*c]struct__GET_FILTER_FILE_IDENTIFIER_INPUT;
pub const struct__GET_FILTER_FILE_IDENTIFIER_OUTPUT = extern struct {
    FilterFileIdentifierLength: WORD,
    FilterFileIdentifier: [1]BYTE,
};
pub const GET_FILTER_FILE_IDENTIFIER_OUTPUT = struct__GET_FILTER_FILE_IDENTIFIER_OUTPUT;
pub const PGET_FILTER_FILE_IDENTIFIER_OUTPUT = [*c]struct__GET_FILTER_FILE_IDENTIFIER_OUTPUT;
pub const struct__DISK_EXTENT = extern struct {
    DiskNumber: DWORD,
    StartingOffset: LARGE_INTEGER,
    ExtentLength: LARGE_INTEGER,
};
pub const DISK_EXTENT = struct__DISK_EXTENT;
pub const PDISK_EXTENT = [*c]struct__DISK_EXTENT;
pub const struct__VOLUME_DISK_EXTENTS = extern struct {
    NumberOfDiskExtents: DWORD,
    Extents: [1]DISK_EXTENT,
};
pub const VOLUME_DISK_EXTENTS = struct__VOLUME_DISK_EXTENTS;
pub const PVOLUME_DISK_EXTENTS = [*c]struct__VOLUME_DISK_EXTENTS;
pub const struct__VOLUME_GET_GPT_ATTRIBUTES_INFORMATION = extern struct {
    GptAttributes: DWORDLONG,
};
pub const VOLUME_GET_GPT_ATTRIBUTES_INFORMATION = struct__VOLUME_GET_GPT_ATTRIBUTES_INFORMATION;
pub const PVOLUME_GET_GPT_ATTRIBUTES_INFORMATION = [*c]struct__VOLUME_GET_GPT_ATTRIBUTES_INFORMATION;
pub const PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK = ?fn ([*c]struct__IO_IRP_EXT_TRACK_OFFSET_HEADER, [*c]struct__IO_IRP_EXT_TRACK_OFFSET_HEADER, LONGLONG) callconv(.C) void;
pub const struct__IO_IRP_EXT_TRACK_OFFSET_HEADER = extern struct {
    Validation: WORD,
    Flags: WORD,
    TrackedOffsetCallback: PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK,
};
pub const IO_IRP_EXT_TRACK_OFFSET_HEADER = struct__IO_IRP_EXT_TRACK_OFFSET_HEADER;
pub const PIO_IRP_EXT_TRACK_OFFSET_HEADER = [*c]struct__IO_IRP_EXT_TRACK_OFFSET_HEADER;
pub const UWORD = WORD;
pub extern const GUID_DEVINTERFACE_SMARTCARD_READER: GUID;
pub const struct__SCARD_IO_REQUEST = extern struct {
    dwProtocol: DWORD,
    cbPciLength: DWORD,
};
pub const SCARD_IO_REQUEST = struct__SCARD_IO_REQUEST;
pub const PSCARD_IO_REQUEST = [*c]struct__SCARD_IO_REQUEST;
pub const LPSCARD_IO_REQUEST = [*c]struct__SCARD_IO_REQUEST;
pub const LPCSCARD_IO_REQUEST = [*c]const SCARD_IO_REQUEST;
pub const struct__SCARD_T0_COMMAND = extern struct {
    bCla: BYTE,
    bIns: BYTE,
    bP1: BYTE,
    bP2: BYTE,
    bP3: BYTE,
};
pub const SCARD_T0_COMMAND = struct__SCARD_T0_COMMAND;
pub const LPSCARD_T0_COMMAND = [*c]struct__SCARD_T0_COMMAND;
pub const struct__SCARD_T0_REQUEST = extern struct {
    ioRequest: SCARD_IO_REQUEST,
    bSw1: BYTE,
    bSw2: BYTE,
    @"": extern union {
        CmdBytes: SCARD_T0_COMMAND,
        rgbHeader: [5]BYTE,
    },
};
pub const SCARD_T0_REQUEST = struct__SCARD_T0_REQUEST;
pub const PSCARD_T0_REQUEST = [*c]SCARD_T0_REQUEST;
pub const LPSCARD_T0_REQUEST = [*c]SCARD_T0_REQUEST;
pub const struct__SCARD_T1_REQUEST = extern struct {
    ioRequest: SCARD_IO_REQUEST,
};
pub const SCARD_T1_REQUEST = struct__SCARD_T1_REQUEST;
pub const PSCARD_T1_REQUEST = [*c]SCARD_T1_REQUEST;
pub const LPSCARD_T1_REQUEST = [*c]SCARD_T1_REQUEST;
pub const LPCBYTE = [*c]const BYTE;
pub extern const g_rgSCardT0Pci: SCARD_IO_REQUEST;
pub extern const g_rgSCardT1Pci: SCARD_IO_REQUEST;
pub extern const g_rgSCardRawPci: SCARD_IO_REQUEST;
pub const SCARDCONTEXT = ULONG_PTR;
pub const PSCARDCONTEXT = [*c]SCARDCONTEXT;
pub const LPSCARDCONTEXT = [*c]SCARDCONTEXT;
pub const SCARDHANDLE = ULONG_PTR;
pub const PSCARDHANDLE = [*c]SCARDHANDLE;
pub const LPSCARDHANDLE = [*c]SCARDHANDLE;
pub extern "winscard" fn SCardEstablishContext(dwScope: DWORD, pvReserved1: LPCVOID, pvReserved2: LPCVOID, phContext: LPSCARDCONTEXT) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardReleaseContext(hContext: SCARDCONTEXT) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardIsValidContext(hContext: SCARDCONTEXT) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardListReaderGroupsA(hContext: SCARDCONTEXT, mszGroups: LPSTR, pcchGroups: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardListReaderGroupsW(hContext: SCARDCONTEXT, mszGroups: LPWSTR, pcchGroups: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardListReadersA(hContext: SCARDCONTEXT, mszGroups: LPCSTR, mszReaders: LPSTR, pcchReaders: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardListReadersW(hContext: SCARDCONTEXT, mszGroups: LPCWSTR, mszReaders: LPWSTR, pcchReaders: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardListCardsA(hContext: SCARDCONTEXT, pbAtr: LPCBYTE, rgquidInterfaces: LPCGUID, cguidInterfaceCount: DWORD, mszCards: [*c]CHAR, pcchCards: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardListCardsW(hContext: SCARDCONTEXT, pbAtr: LPCBYTE, rgquidInterfaces: LPCGUID, cguidInterfaceCount: DWORD, mszCards: [*c]WCHAR, pcchCards: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardListInterfacesA(hContext: SCARDCONTEXT, szCard: LPCSTR, pguidInterfaces: LPGUID, pcguidInterfaces: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardListInterfacesW(hContext: SCARDCONTEXT, szCard: LPCWSTR, pguidInterfaces: LPGUID, pcguidInterfaces: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardGetProviderIdA(hContext: SCARDCONTEXT, szCard: LPCSTR, pguidProviderId: LPGUID) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardGetProviderIdW(hContext: SCARDCONTEXT, szCard: LPCWSTR, pguidProviderId: LPGUID) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardGetCardTypeProviderNameA(hContext: SCARDCONTEXT, szCardName: LPCSTR, dwProviderId: DWORD, szProvider: [*c]CHAR, pcchProvider: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardGetCardTypeProviderNameW(hContext: SCARDCONTEXT, szCardName: LPCWSTR, dwProviderId: DWORD, szProvider: [*c]WCHAR, pcchProvider: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardIntroduceReaderGroupA(hContext: SCARDCONTEXT, szGroupName: LPCSTR) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardIntroduceReaderGroupW(hContext: SCARDCONTEXT, szGroupName: LPCWSTR) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardForgetReaderGroupA(hContext: SCARDCONTEXT, szGroupName: LPCSTR) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardForgetReaderGroupW(hContext: SCARDCONTEXT, szGroupName: LPCWSTR) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardIntroduceReaderA(hContext: SCARDCONTEXT, szReaderName: LPCSTR, szDeviceName: LPCSTR) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardIntroduceReaderW(hContext: SCARDCONTEXT, szReaderName: LPCWSTR, szDeviceName: LPCWSTR) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardForgetReaderA(hContext: SCARDCONTEXT, szReaderName: LPCSTR) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardForgetReaderW(hContext: SCARDCONTEXT, szReaderName: LPCWSTR) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardAddReaderToGroupA(hContext: SCARDCONTEXT, szReaderName: LPCSTR, szGroupName: LPCSTR) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardAddReaderToGroupW(hContext: SCARDCONTEXT, szReaderName: LPCWSTR, szGroupName: LPCWSTR) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardRemoveReaderFromGroupA(hContext: SCARDCONTEXT, szReaderName: LPCSTR, szGroupName: LPCSTR) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardRemoveReaderFromGroupW(hContext: SCARDCONTEXT, szReaderName: LPCWSTR, szGroupName: LPCWSTR) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardIntroduceCardTypeA(hContext: SCARDCONTEXT, szCardName: LPCSTR, pguidPrimaryProvider: LPCGUID, rgguidInterfaces: LPCGUID, dwInterfaceCount: DWORD, pbAtr: LPCBYTE, pbAtrMask: LPCBYTE, cbAtrLen: DWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardIntroduceCardTypeW(hContext: SCARDCONTEXT, szCardName: LPCWSTR, pguidPrimaryProvider: LPCGUID, rgguidInterfaces: LPCGUID, dwInterfaceCount: DWORD, pbAtr: LPCBYTE, pbAtrMask: LPCBYTE, cbAtrLen: DWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardSetCardTypeProviderNameA(hContext: SCARDCONTEXT, szCardName: LPCSTR, dwProviderId: DWORD, szProvider: LPCSTR) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardSetCardTypeProviderNameW(hContext: SCARDCONTEXT, szCardName: LPCWSTR, dwProviderId: DWORD, szProvider: LPCWSTR) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardForgetCardTypeA(hContext: SCARDCONTEXT, szCardName: LPCSTR) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardForgetCardTypeW(hContext: SCARDCONTEXT, szCardName: LPCWSTR) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardFreeMemory(hContext: SCARDCONTEXT, pvMem: LPCVOID) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardAccessStartedEvent() callconv(.Stdcall) HANDLE;
pub extern "winscard" fn SCardReleaseStartedEvent() callconv(.Stdcall) void;
pub const SCARD_READERSTATEA = extern struct {
    szReader: LPCSTR,
    pvUserData: LPVOID,
    dwCurrentState: DWORD,
    dwEventState: DWORD,
    cbAtr: DWORD,
    rgbAtr: [36]BYTE,
};
pub const PSCARD_READERSTATEA = [*c]extern struct {
    szReader: LPCSTR,
    pvUserData: LPVOID,
    dwCurrentState: DWORD,
    dwEventState: DWORD,
    cbAtr: DWORD,
    rgbAtr: [36]BYTE,
};
pub const LPSCARD_READERSTATEA = [*c]extern struct {
    szReader: LPCSTR,
    pvUserData: LPVOID,
    dwCurrentState: DWORD,
    dwEventState: DWORD,
    cbAtr: DWORD,
    rgbAtr: [36]BYTE,
};
pub const SCARD_READERSTATEW = extern struct {
    szReader: LPCWSTR,
    pvUserData: LPVOID,
    dwCurrentState: DWORD,
    dwEventState: DWORD,
    cbAtr: DWORD,
    rgbAtr: [36]BYTE,
};
pub const PSCARD_READERSTATEW = [*c]extern struct {
    szReader: LPCWSTR,
    pvUserData: LPVOID,
    dwCurrentState: DWORD,
    dwEventState: DWORD,
    cbAtr: DWORD,
    rgbAtr: [36]BYTE,
};
pub const LPSCARD_READERSTATEW = [*c]extern struct {
    szReader: LPCWSTR,
    pvUserData: LPVOID,
    dwCurrentState: DWORD,
    dwEventState: DWORD,
    cbAtr: DWORD,
    rgbAtr: [36]BYTE,
};
pub const SCARD_READERSTATE = SCARD_READERSTATEA;
pub const PSCARD_READERSTATE = PSCARD_READERSTATEA;
pub const LPSCARD_READERSTATE = LPSCARD_READERSTATEA;
pub extern "winscard" fn SCardLocateCardsA(hContext: SCARDCONTEXT, mszCards: LPCSTR, rgReaderStates: LPSCARD_READERSTATEA, cReaders: DWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardLocateCardsW(hContext: SCARDCONTEXT, mszCards: LPCWSTR, rgReaderStates: LPSCARD_READERSTATEW, cReaders: DWORD) callconv(.Stdcall) LONG;
pub const struct__SCARD_ATRMASK = extern struct {
    cbAtr: DWORD,
    rgbAtr: [36]BYTE,
    rgbMask: [36]BYTE,
};
pub const SCARD_ATRMASK = struct__SCARD_ATRMASK;
pub const PSCARD_ATRMASK = [*c]struct__SCARD_ATRMASK;
pub const LPSCARD_ATRMASK = [*c]struct__SCARD_ATRMASK;
pub extern "winscard" fn SCardLocateCardsByATRA(hContext: SCARDCONTEXT, rgAtrMasks: LPSCARD_ATRMASK, cAtrs: DWORD, rgReaderStates: LPSCARD_READERSTATEA, cReaders: DWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardLocateCardsByATRW(hContext: SCARDCONTEXT, rgAtrMasks: LPSCARD_ATRMASK, cAtrs: DWORD, rgReaderStates: LPSCARD_READERSTATEW, cReaders: DWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardGetStatusChangeA(hContext: SCARDCONTEXT, dwTimeout: DWORD, rgReaderStates: LPSCARD_READERSTATEA, cReaders: DWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardGetStatusChangeW(hContext: SCARDCONTEXT, dwTimeout: DWORD, rgReaderStates: LPSCARD_READERSTATEW, cReaders: DWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardCancel(hContext: SCARDCONTEXT) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardConnectA(hContext: SCARDCONTEXT, szReader: LPCSTR, dwShareMode: DWORD, dwPreferredProtocols: DWORD, phCard: LPSCARDHANDLE, pdwActiveProtocol: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardConnectW(hContext: SCARDCONTEXT, szReader: LPCWSTR, dwShareMode: DWORD, dwPreferredProtocols: DWORD, phCard: LPSCARDHANDLE, pdwActiveProtocol: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardReconnect(hCard: SCARDHANDLE, dwShareMode: DWORD, dwPreferredProtocols: DWORD, dwInitialization: DWORD, pdwActiveProtocol: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardDisconnect(hCard: SCARDHANDLE, dwDisposition: DWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardBeginTransaction(hCard: SCARDHANDLE) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardEndTransaction(hCard: SCARDHANDLE, dwDisposition: DWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardCancelTransaction(hCard: SCARDHANDLE) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardState(hCard: SCARDHANDLE, pdwState: LPDWORD, pdwProtocol: LPDWORD, pbAtr: LPBYTE, pcbAtrLen: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardStatusA(hCard: SCARDHANDLE, mszReaderNames: LPSTR, pcchReaderLen: LPDWORD, pdwState: LPDWORD, pdwProtocol: LPDWORD, pbAtr: LPBYTE, pcbAtrLen: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardStatusW(hCard: SCARDHANDLE, mszReaderNames: LPWSTR, pcchReaderLen: LPDWORD, pdwState: LPDWORD, pdwProtocol: LPDWORD, pbAtr: LPBYTE, pcbAtrLen: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardTransmit(hCard: SCARDHANDLE, pioSendPci: LPCSCARD_IO_REQUEST, pbSendBuffer: LPCBYTE, cbSendLength: DWORD, pioRecvPci: LPSCARD_IO_REQUEST, pbRecvBuffer: LPBYTE, pcbRecvLength: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardGetTransmitCount(hCard: SCARDHANDLE, pcTransmitCount: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardControl(hCard: SCARDHANDLE, dwControlCode: DWORD, lpInBuffer: LPCVOID, cbInBufferSize: DWORD, lpOutBuffer: LPVOID, cbOutBufferSize: DWORD, lpBytesReturned: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardGetAttrib(hCard: SCARDHANDLE, dwAttrId: DWORD, pbAttr: LPBYTE, pcbAttrLen: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardSetAttrib(hCard: SCARDHANDLE, dwAttrId: DWORD, pbAttr: LPCBYTE, cbAttrLen: DWORD) callconv(.Stdcall) LONG;
pub const LPOCNCONNPROCA = ?fn (SCARDCONTEXT, LPSTR, LPSTR, PVOID) callconv(.C) SCARDHANDLE;
pub const LPOCNCONNPROCW = ?fn (SCARDCONTEXT, LPWSTR, LPWSTR, PVOID) callconv(.C) SCARDHANDLE;
pub const LPOCNCHKPROC = ?fn (SCARDCONTEXT, SCARDHANDLE, PVOID) callconv(.C) BOOL;
pub const LPOCNDSCPROC = ?fn (SCARDCONTEXT, SCARDHANDLE, PVOID) callconv(.C) void;
pub const OPENCARD_SEARCH_CRITERIAA = extern struct {
    dwStructSize: DWORD,
    lpstrGroupNames: LPSTR,
    nMaxGroupNames: DWORD,
    rgguidInterfaces: LPCGUID,
    cguidInterfaces: DWORD,
    lpstrCardNames: LPSTR,
    nMaxCardNames: DWORD,
    lpfnCheck: LPOCNCHKPROC,
    lpfnConnect: LPOCNCONNPROCA,
    lpfnDisconnect: LPOCNDSCPROC,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
};
pub const POPENCARD_SEARCH_CRITERIAA = [*c]extern struct {
    dwStructSize: DWORD,
    lpstrGroupNames: LPSTR,
    nMaxGroupNames: DWORD,
    rgguidInterfaces: LPCGUID,
    cguidInterfaces: DWORD,
    lpstrCardNames: LPSTR,
    nMaxCardNames: DWORD,
    lpfnCheck: LPOCNCHKPROC,
    lpfnConnect: LPOCNCONNPROCA,
    lpfnDisconnect: LPOCNDSCPROC,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
};
pub const LPOPENCARD_SEARCH_CRITERIAA = [*c]extern struct {
    dwStructSize: DWORD,
    lpstrGroupNames: LPSTR,
    nMaxGroupNames: DWORD,
    rgguidInterfaces: LPCGUID,
    cguidInterfaces: DWORD,
    lpstrCardNames: LPSTR,
    nMaxCardNames: DWORD,
    lpfnCheck: LPOCNCHKPROC,
    lpfnConnect: LPOCNCONNPROCA,
    lpfnDisconnect: LPOCNDSCPROC,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
};
pub const OPENCARD_SEARCH_CRITERIAW = extern struct {
    dwStructSize: DWORD,
    lpstrGroupNames: LPWSTR,
    nMaxGroupNames: DWORD,
    rgguidInterfaces: LPCGUID,
    cguidInterfaces: DWORD,
    lpstrCardNames: LPWSTR,
    nMaxCardNames: DWORD,
    lpfnCheck: LPOCNCHKPROC,
    lpfnConnect: LPOCNCONNPROCW,
    lpfnDisconnect: LPOCNDSCPROC,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
};
pub const POPENCARD_SEARCH_CRITERIAW = [*c]extern struct {
    dwStructSize: DWORD,
    lpstrGroupNames: LPWSTR,
    nMaxGroupNames: DWORD,
    rgguidInterfaces: LPCGUID,
    cguidInterfaces: DWORD,
    lpstrCardNames: LPWSTR,
    nMaxCardNames: DWORD,
    lpfnCheck: LPOCNCHKPROC,
    lpfnConnect: LPOCNCONNPROCW,
    lpfnDisconnect: LPOCNDSCPROC,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
};
pub const LPOPENCARD_SEARCH_CRITERIAW = [*c]extern struct {
    dwStructSize: DWORD,
    lpstrGroupNames: LPWSTR,
    nMaxGroupNames: DWORD,
    rgguidInterfaces: LPCGUID,
    cguidInterfaces: DWORD,
    lpstrCardNames: LPWSTR,
    nMaxCardNames: DWORD,
    lpfnCheck: LPOCNCHKPROC,
    lpfnConnect: LPOCNCONNPROCW,
    lpfnDisconnect: LPOCNDSCPROC,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
};
pub const OPENCARD_SEARCH_CRITERIA = OPENCARD_SEARCH_CRITERIAA;
pub const POPENCARD_SEARCH_CRITERIA = POPENCARD_SEARCH_CRITERIAA;
pub const LPOPENCARD_SEARCH_CRITERIA = LPOPENCARD_SEARCH_CRITERIAA;
pub const OPENCARDNAME_EXA = extern struct {
    dwStructSize: DWORD,
    hSCardContext: SCARDCONTEXT,
    hwndOwner: HWND,
    dwFlags: DWORD,
    lpstrTitle: LPCSTR,
    lpstrSearchDesc: LPCSTR,
    hIcon: HICON,
    pOpenCardSearchCriteria: POPENCARD_SEARCH_CRITERIAA,
    lpfnConnect: LPOCNCONNPROCA,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    lpstrRdr: LPSTR,
    nMaxRdr: DWORD,
    lpstrCard: LPSTR,
    nMaxCard: DWORD,
    dwActiveProtocol: DWORD,
    hCardHandle: SCARDHANDLE,
};
pub const POPENCARDNAME_EXA = [*c]extern struct {
    dwStructSize: DWORD,
    hSCardContext: SCARDCONTEXT,
    hwndOwner: HWND,
    dwFlags: DWORD,
    lpstrTitle: LPCSTR,
    lpstrSearchDesc: LPCSTR,
    hIcon: HICON,
    pOpenCardSearchCriteria: POPENCARD_SEARCH_CRITERIAA,
    lpfnConnect: LPOCNCONNPROCA,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    lpstrRdr: LPSTR,
    nMaxRdr: DWORD,
    lpstrCard: LPSTR,
    nMaxCard: DWORD,
    dwActiveProtocol: DWORD,
    hCardHandle: SCARDHANDLE,
};
pub const LPOPENCARDNAME_EXA = [*c]extern struct {
    dwStructSize: DWORD,
    hSCardContext: SCARDCONTEXT,
    hwndOwner: HWND,
    dwFlags: DWORD,
    lpstrTitle: LPCSTR,
    lpstrSearchDesc: LPCSTR,
    hIcon: HICON,
    pOpenCardSearchCriteria: POPENCARD_SEARCH_CRITERIAA,
    lpfnConnect: LPOCNCONNPROCA,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    lpstrRdr: LPSTR,
    nMaxRdr: DWORD,
    lpstrCard: LPSTR,
    nMaxCard: DWORD,
    dwActiveProtocol: DWORD,
    hCardHandle: SCARDHANDLE,
};
pub const OPENCARDNAME_EXW = extern struct {
    dwStructSize: DWORD,
    hSCardContext: SCARDCONTEXT,
    hwndOwner: HWND,
    dwFlags: DWORD,
    lpstrTitle: LPCWSTR,
    lpstrSearchDesc: LPCWSTR,
    hIcon: HICON,
    pOpenCardSearchCriteria: POPENCARD_SEARCH_CRITERIAW,
    lpfnConnect: LPOCNCONNPROCW,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    lpstrRdr: LPWSTR,
    nMaxRdr: DWORD,
    lpstrCard: LPWSTR,
    nMaxCard: DWORD,
    dwActiveProtocol: DWORD,
    hCardHandle: SCARDHANDLE,
};
pub const POPENCARDNAME_EXW = [*c]extern struct {
    dwStructSize: DWORD,
    hSCardContext: SCARDCONTEXT,
    hwndOwner: HWND,
    dwFlags: DWORD,
    lpstrTitle: LPCWSTR,
    lpstrSearchDesc: LPCWSTR,
    hIcon: HICON,
    pOpenCardSearchCriteria: POPENCARD_SEARCH_CRITERIAW,
    lpfnConnect: LPOCNCONNPROCW,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    lpstrRdr: LPWSTR,
    nMaxRdr: DWORD,
    lpstrCard: LPWSTR,
    nMaxCard: DWORD,
    dwActiveProtocol: DWORD,
    hCardHandle: SCARDHANDLE,
};
pub const LPOPENCARDNAME_EXW = [*c]extern struct {
    dwStructSize: DWORD,
    hSCardContext: SCARDCONTEXT,
    hwndOwner: HWND,
    dwFlags: DWORD,
    lpstrTitle: LPCWSTR,
    lpstrSearchDesc: LPCWSTR,
    hIcon: HICON,
    pOpenCardSearchCriteria: POPENCARD_SEARCH_CRITERIAW,
    lpfnConnect: LPOCNCONNPROCW,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    lpstrRdr: LPWSTR,
    nMaxRdr: DWORD,
    lpstrCard: LPWSTR,
    nMaxCard: DWORD,
    dwActiveProtocol: DWORD,
    hCardHandle: SCARDHANDLE,
};
pub const OPENCARDNAME_EX = OPENCARDNAME_EXA;
pub const POPENCARDNAME_EX = POPENCARDNAME_EXA;
pub const LPOPENCARDNAME_EX = LPOPENCARDNAME_EXA;
pub const RSR_MATCH_TYPE_READER_AND_CONTAINER = 1;
pub const RSR_MATCH_TYPE_SERIAL_NUMBER = 2;
pub const RSR_MATCH_TYPE_ALL_CARDS = 3;
pub const READER_SEL_REQUEST_MATCH_TYPE = extern enum {
    RSR_MATCH_TYPE_READER_AND_CONTAINER = 1,
    RSR_MATCH_TYPE_SERIAL_NUMBER = 2,
    RSR_MATCH_TYPE_ALL_CARDS = 3,
};
pub const READER_SEL_REQUEST = extern struct {
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    MatchType: READER_SEL_REQUEST_MATCH_TYPE,
    @"": extern union {
        ReaderAndContainerParameter: extern struct {
            cbReaderNameOffset: DWORD,
            cchReaderNameLength: DWORD,
            cbContainerNameOffset: DWORD,
            cchContainerNameLength: DWORD,
            dwDesiredCardModuleVersion: DWORD,
            dwCspFlags: DWORD,
        },
        SerialNumberParameter: extern struct {
            cbSerialNumberOffset: DWORD,
            cbSerialNumberLength: DWORD,
            dwDesiredCardModuleVersion: DWORD,
        },
    },
};
pub const PREADER_SEL_REQUEST = [*c]extern struct {
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    MatchType: READER_SEL_REQUEST_MATCH_TYPE,
    @"": extern union {
        ReaderAndContainerParameter: extern struct {
            cbReaderNameOffset: DWORD,
            cchReaderNameLength: DWORD,
            cbContainerNameOffset: DWORD,
            cchContainerNameLength: DWORD,
            dwDesiredCardModuleVersion: DWORD,
            dwCspFlags: DWORD,
        },
        SerialNumberParameter: extern struct {
            cbSerialNumberOffset: DWORD,
            cbSerialNumberLength: DWORD,
            dwDesiredCardModuleVersion: DWORD,
        },
    },
};
pub const READER_SEL_RESPONSE = extern struct {
    cbReaderNameOffset: DWORD,
    cchReaderNameLength: DWORD,
    cbCardNameOffset: DWORD,
    cchCardNameLength: DWORD,
};
pub const PREADER_SEL_RESPONSE = [*c]extern struct {
    cbReaderNameOffset: DWORD,
    cchReaderNameLength: DWORD,
    cbCardNameOffset: DWORD,
    cchCardNameLength: DWORD,
};
pub extern "winscard" fn SCardUIDlgSelectCardA(arg0: LPOPENCARDNAME_EXA) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardUIDlgSelectCardW(arg0: LPOPENCARDNAME_EXW) callconv(.Stdcall) LONG;
pub const OPENCARDNAMEA = extern struct {
    dwStructSize: DWORD,
    hwndOwner: HWND,
    hSCardContext: SCARDCONTEXT,
    lpstrGroupNames: LPSTR,
    nMaxGroupNames: DWORD,
    lpstrCardNames: LPSTR,
    nMaxCardNames: DWORD,
    rgguidInterfaces: LPCGUID,
    cguidInterfaces: DWORD,
    lpstrRdr: LPSTR,
    nMaxRdr: DWORD,
    lpstrCard: LPSTR,
    nMaxCard: DWORD,
    lpstrTitle: LPCSTR,
    dwFlags: DWORD,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    dwActiveProtocol: DWORD,
    lpfnConnect: LPOCNCONNPROCA,
    lpfnCheck: LPOCNCHKPROC,
    lpfnDisconnect: LPOCNDSCPROC,
    hCardHandle: SCARDHANDLE,
};
pub const POPENCARDNAMEA = [*c]extern struct {
    dwStructSize: DWORD,
    hwndOwner: HWND,
    hSCardContext: SCARDCONTEXT,
    lpstrGroupNames: LPSTR,
    nMaxGroupNames: DWORD,
    lpstrCardNames: LPSTR,
    nMaxCardNames: DWORD,
    rgguidInterfaces: LPCGUID,
    cguidInterfaces: DWORD,
    lpstrRdr: LPSTR,
    nMaxRdr: DWORD,
    lpstrCard: LPSTR,
    nMaxCard: DWORD,
    lpstrTitle: LPCSTR,
    dwFlags: DWORD,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    dwActiveProtocol: DWORD,
    lpfnConnect: LPOCNCONNPROCA,
    lpfnCheck: LPOCNCHKPROC,
    lpfnDisconnect: LPOCNDSCPROC,
    hCardHandle: SCARDHANDLE,
};
pub const LPOPENCARDNAMEA = [*c]extern struct {
    dwStructSize: DWORD,
    hwndOwner: HWND,
    hSCardContext: SCARDCONTEXT,
    lpstrGroupNames: LPSTR,
    nMaxGroupNames: DWORD,
    lpstrCardNames: LPSTR,
    nMaxCardNames: DWORD,
    rgguidInterfaces: LPCGUID,
    cguidInterfaces: DWORD,
    lpstrRdr: LPSTR,
    nMaxRdr: DWORD,
    lpstrCard: LPSTR,
    nMaxCard: DWORD,
    lpstrTitle: LPCSTR,
    dwFlags: DWORD,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    dwActiveProtocol: DWORD,
    lpfnConnect: LPOCNCONNPROCA,
    lpfnCheck: LPOCNCHKPROC,
    lpfnDisconnect: LPOCNDSCPROC,
    hCardHandle: SCARDHANDLE,
};
pub const OPENCARDNAMEW = extern struct {
    dwStructSize: DWORD,
    hwndOwner: HWND,
    hSCardContext: SCARDCONTEXT,
    lpstrGroupNames: LPWSTR,
    nMaxGroupNames: DWORD,
    lpstrCardNames: LPWSTR,
    nMaxCardNames: DWORD,
    rgguidInterfaces: LPCGUID,
    cguidInterfaces: DWORD,
    lpstrRdr: LPWSTR,
    nMaxRdr: DWORD,
    lpstrCard: LPWSTR,
    nMaxCard: DWORD,
    lpstrTitle: LPCWSTR,
    dwFlags: DWORD,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    dwActiveProtocol: DWORD,
    lpfnConnect: LPOCNCONNPROCW,
    lpfnCheck: LPOCNCHKPROC,
    lpfnDisconnect: LPOCNDSCPROC,
    hCardHandle: SCARDHANDLE,
};
pub const POPENCARDNAMEW = [*c]extern struct {
    dwStructSize: DWORD,
    hwndOwner: HWND,
    hSCardContext: SCARDCONTEXT,
    lpstrGroupNames: LPWSTR,
    nMaxGroupNames: DWORD,
    lpstrCardNames: LPWSTR,
    nMaxCardNames: DWORD,
    rgguidInterfaces: LPCGUID,
    cguidInterfaces: DWORD,
    lpstrRdr: LPWSTR,
    nMaxRdr: DWORD,
    lpstrCard: LPWSTR,
    nMaxCard: DWORD,
    lpstrTitle: LPCWSTR,
    dwFlags: DWORD,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    dwActiveProtocol: DWORD,
    lpfnConnect: LPOCNCONNPROCW,
    lpfnCheck: LPOCNCHKPROC,
    lpfnDisconnect: LPOCNDSCPROC,
    hCardHandle: SCARDHANDLE,
};
pub const LPOPENCARDNAMEW = [*c]extern struct {
    dwStructSize: DWORD,
    hwndOwner: HWND,
    hSCardContext: SCARDCONTEXT,
    lpstrGroupNames: LPWSTR,
    nMaxGroupNames: DWORD,
    lpstrCardNames: LPWSTR,
    nMaxCardNames: DWORD,
    rgguidInterfaces: LPCGUID,
    cguidInterfaces: DWORD,
    lpstrRdr: LPWSTR,
    nMaxRdr: DWORD,
    lpstrCard: LPWSTR,
    nMaxCard: DWORD,
    lpstrTitle: LPCWSTR,
    dwFlags: DWORD,
    pvUserData: LPVOID,
    dwShareMode: DWORD,
    dwPreferredProtocols: DWORD,
    dwActiveProtocol: DWORD,
    lpfnConnect: LPOCNCONNPROCW,
    lpfnCheck: LPOCNCHKPROC,
    lpfnDisconnect: LPOCNDSCPROC,
    hCardHandle: SCARDHANDLE,
};
pub const OPENCARDNAME = OPENCARDNAMEA;
pub const POPENCARDNAME = POPENCARDNAMEA;
pub const LPOPENCARDNAME = LPOPENCARDNAMEA;
pub extern "winscard" fn GetOpenCardNameA(arg0: LPOPENCARDNAMEA) callconv(.Stdcall) LONG;
pub extern "winscard" fn GetOpenCardNameW(arg0: LPOPENCARDNAMEW) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardDlgExtendedError() callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardReadCacheA(hContext: SCARDCONTEXT, CardIdentifier: [*c]UUID, FreshnessCounter: DWORD, LookupName: LPSTR, Data: PBYTE, DataLen: [*c]DWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardReadCacheW(hContext: SCARDCONTEXT, CardIdentifier: [*c]UUID, FreshnessCounter: DWORD, LookupName: LPWSTR, Data: PBYTE, DataLen: [*c]DWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardWriteCacheA(hContext: SCARDCONTEXT, CardIdentifier: [*c]UUID, FreshnessCounter: DWORD, LookupName: LPSTR, Data: PBYTE, DataLen: DWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardWriteCacheW(hContext: SCARDCONTEXT, CardIdentifier: [*c]UUID, FreshnessCounter: DWORD, LookupName: LPWSTR, Data: PBYTE, DataLen: DWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardGetReaderIconA(hContext: SCARDCONTEXT, szReaderName: LPCSTR, pbIcon: LPBYTE, pcbIcon: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardGetReaderIconW(hContext: SCARDCONTEXT, szReaderName: LPCWSTR, pbIcon: LPBYTE, pcbIcon: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardGetDeviceTypeIdA(hContext: SCARDCONTEXT, szReaderName: LPCSTR, pdwDeviceTypeId: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardGetDeviceTypeIdW(hContext: SCARDCONTEXT, szReaderName: LPCWSTR, pdwDeviceTypeId: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardGetReaderDeviceInstanceIdA(hContext: SCARDCONTEXT, szReaderName: LPCSTR, szDeviceInstanceId: LPSTR, pcchDeviceInstanceId: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardGetReaderDeviceInstanceIdW(hContext: SCARDCONTEXT, szReaderName: LPCWSTR, szDeviceInstanceId: LPWSTR, pcchDeviceInstanceId: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardListReadersWithDeviceInstanceIdA(hContext: SCARDCONTEXT, szDeviceInstanceId: LPCSTR, mszReaders: LPSTR, pcchReaders: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardListReadersWithDeviceInstanceIdW(hContext: SCARDCONTEXT, szDeviceInstanceId: LPCWSTR, mszReaders: LPWSTR, pcchReaders: LPDWORD) callconv(.Stdcall) LONG;
pub extern "winscard" fn SCardAudit(hContext: SCARDCONTEXT, dwEvent: DWORD) callconv(.Stdcall) LONG;
pub const struct__PSP = @OpaqueType();
pub const HPROPSHEETPAGE = ?*struct__PSP;
pub const PROPSHEETPAGE_RESOURCE = LPCDLGTEMPLATE;
pub const LPFNPSPCALLBACKA = ?fn (HWND, UINT, [*c]struct__PROPSHEETPAGEA) callconv(.C) UINT;
pub const struct__PROPSHEETPAGEA = extern struct {
    dwSize: DWORD,
    dwFlags: DWORD,
    hInstance: HINSTANCE,
    @"": extern union {
        pszTemplate: LPCSTR,
        pResource: PROPSHEETPAGE_RESOURCE,
    },
    @"": extern union {
        hIcon: HICON,
        pszIcon: LPCSTR,
    },
    pszTitle: LPCSTR,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKA,
    pcRefParent: [*c]UINT,
    pszHeaderTitle: LPCSTR,
    pszHeaderSubTitle: LPCSTR,
    hActCtx: HANDLE,
    @"": extern union {
        hbmHeader: HBITMAP,
        pszbmHeader: LPCSTR,
    },
};
pub const LPFNPSPCALLBACKW = ?fn (HWND, UINT, [*c]struct__PROPSHEETPAGEW) callconv(.C) UINT;
pub const struct__PROPSHEETPAGEW = extern struct {
    dwSize: DWORD,
    dwFlags: DWORD,
    hInstance: HINSTANCE,
    @"": extern union {
        pszTemplate: LPCWSTR,
        pResource: PROPSHEETPAGE_RESOURCE,
    },
    @"": extern union {
        hIcon: HICON,
        pszIcon: LPCWSTR,
    },
    pszTitle: LPCWSTR,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKW,
    pcRefParent: [*c]UINT,
    pszHeaderTitle: LPCWSTR,
    pszHeaderSubTitle: LPCWSTR,
    hActCtx: HANDLE,
    @"": extern union {
        hbmHeader: HBITMAP,
        pszbmHeader: LPCWSTR,
    },
};
pub const struct__PROPSHEETPAGEA_V1 = extern struct {
    dwSize: DWORD,
    dwFlags: DWORD,
    hInstance: HINSTANCE,
    @"": extern union {
        pszTemplate: LPCSTR,
        pResource: PROPSHEETPAGE_RESOURCE,
    },
    @"": extern union {
        hIcon: HICON,
        pszIcon: LPCSTR,
    },
    pszTitle: LPCSTR,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKA,
    pcRefParent: [*c]UINT,
};
pub const PROPSHEETPAGEA_V1 = struct__PROPSHEETPAGEA_V1;
pub const LPPROPSHEETPAGEA_V1 = [*c]struct__PROPSHEETPAGEA_V1;
pub const LPCPROPSHEETPAGEA_V1 = [*c]const PROPSHEETPAGEA_V1;
pub const struct__PROPSHEETPAGEA_V2 = extern struct {
    dwSize: DWORD,
    dwFlags: DWORD,
    hInstance: HINSTANCE,
    @"": extern union {
        pszTemplate: LPCSTR,
        pResource: PROPSHEETPAGE_RESOURCE,
    },
    @"": extern union {
        hIcon: HICON,
        pszIcon: LPCSTR,
    },
    pszTitle: LPCSTR,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKA,
    pcRefParent: [*c]UINT,
    pszHeaderTitle: LPCSTR,
    pszHeaderSubTitle: LPCSTR,
};
pub const PROPSHEETPAGEA_V2 = struct__PROPSHEETPAGEA_V2;
pub const LPPROPSHEETPAGEA_V2 = [*c]struct__PROPSHEETPAGEA_V2;
pub const LPCPROPSHEETPAGEA_V2 = [*c]const PROPSHEETPAGEA_V2;
pub const struct__PROPSHEETPAGEA_V3 = extern struct {
    dwSize: DWORD,
    dwFlags: DWORD,
    hInstance: HINSTANCE,
    @"": extern union {
        pszTemplate: LPCSTR,
        pResource: PROPSHEETPAGE_RESOURCE,
    },
    @"": extern union {
        hIcon: HICON,
        pszIcon: LPCSTR,
    },
    pszTitle: LPCSTR,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKA,
    pcRefParent: [*c]UINT,
    pszHeaderTitle: LPCSTR,
    pszHeaderSubTitle: LPCSTR,
    hActCtx: HANDLE,
};
pub const PROPSHEETPAGEA_V3 = struct__PROPSHEETPAGEA_V3;
pub const LPPROPSHEETPAGEA_V3 = [*c]struct__PROPSHEETPAGEA_V3;
pub const LPCPROPSHEETPAGEA_V3 = [*c]const PROPSHEETPAGEA_V3;
pub const PROPSHEETPAGEA_V4 = struct__PROPSHEETPAGEA;
pub const LPPROPSHEETPAGEA_V4 = [*c]struct__PROPSHEETPAGEA;
pub const LPCPROPSHEETPAGEA_V4 = [*c]const PROPSHEETPAGEA_V4;
pub const struct__PROPSHEETPAGEW_V1 = extern struct {
    dwSize: DWORD,
    dwFlags: DWORD,
    hInstance: HINSTANCE,
    @"": extern union {
        pszTemplate: LPCWSTR,
        pResource: PROPSHEETPAGE_RESOURCE,
    },
    @"": extern union {
        hIcon: HICON,
        pszIcon: LPCWSTR,
    },
    pszTitle: LPCWSTR,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKW,
    pcRefParent: [*c]UINT,
};
pub const PROPSHEETPAGEW_V1 = struct__PROPSHEETPAGEW_V1;
pub const LPPROPSHEETPAGEW_V1 = [*c]struct__PROPSHEETPAGEW_V1;
pub const LPCPROPSHEETPAGEW_V1 = [*c]const PROPSHEETPAGEW_V1;
pub const struct__PROPSHEETPAGEW_V2 = extern struct {
    dwSize: DWORD,
    dwFlags: DWORD,
    hInstance: HINSTANCE,
    @"": extern union {
        pszTemplate: LPCWSTR,
        pResource: PROPSHEETPAGE_RESOURCE,
    },
    @"": extern union {
        hIcon: HICON,
        pszIcon: LPCWSTR,
    },
    pszTitle: LPCWSTR,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKW,
    pcRefParent: [*c]UINT,
    pszHeaderTitle: LPCWSTR,
    pszHeaderSubTitle: LPCWSTR,
};
pub const PROPSHEETPAGEW_V2 = struct__PROPSHEETPAGEW_V2;
pub const LPPROPSHEETPAGEW_V2 = [*c]struct__PROPSHEETPAGEW_V2;
pub const LPCPROPSHEETPAGEW_V2 = [*c]const PROPSHEETPAGEW_V2;
pub const struct__PROPSHEETPAGEW_V3 = extern struct {
    dwSize: DWORD,
    dwFlags: DWORD,
    hInstance: HINSTANCE,
    @"": extern union {
        pszTemplate: LPCWSTR,
        pResource: PROPSHEETPAGE_RESOURCE,
    },
    @"": extern union {
        hIcon: HICON,
        pszIcon: LPCWSTR,
    },
    pszTitle: LPCWSTR,
    pfnDlgProc: DLGPROC,
    lParam: LPARAM,
    pfnCallback: LPFNPSPCALLBACKW,
    pcRefParent: [*c]UINT,
    pszHeaderTitle: LPCWSTR,
    pszHeaderSubTitle: LPCWSTR,
    hActCtx: HANDLE,
};
pub const PROPSHEETPAGEW_V3 = struct__PROPSHEETPAGEW_V3;
pub const LPPROPSHEETPAGEW_V3 = [*c]struct__PROPSHEETPAGEW_V3;
pub const LPCPROPSHEETPAGEW_V3 = [*c]const PROPSHEETPAGEW_V3;
pub const PROPSHEETPAGEW_V4 = struct__PROPSHEETPAGEW;
pub const LPPROPSHEETPAGEW_V4 = [*c]struct__PROPSHEETPAGEW;
pub const LPCPROPSHEETPAGEW_V4 = [*c]const PROPSHEETPAGEW_V4;
pub const PROPSHEETPAGEA_LATEST = PROPSHEETPAGEA_V4;
pub const PROPSHEETPAGEW_LATEST = PROPSHEETPAGEW_V4;
pub const LPPROPSHEETPAGEA_LATEST = LPPROPSHEETPAGEA_V4;
pub const LPPROPSHEETPAGEW_LATEST = LPPROPSHEETPAGEW_V4;
pub const LPCPROPSHEETPAGEA_LATEST = LPCPROPSHEETPAGEA_V4;
pub const LPCPROPSHEETPAGEW_LATEST = LPCPROPSHEETPAGEW_V4;
pub const PROPSHEETPAGEA = PROPSHEETPAGEA_V4;
pub const PROPSHEETPAGEW = PROPSHEETPAGEW_V4;
pub const LPPROPSHEETPAGEA = LPPROPSHEETPAGEA_V4;
pub const LPPROPSHEETPAGEW = LPPROPSHEETPAGEW_V4;
pub const LPCPROPSHEETPAGEA = LPCPROPSHEETPAGEA_V4;
pub const LPCPROPSHEETPAGEW = LPCPROPSHEETPAGEW_V4;
pub const PFNPROPSHEETCALLBACK = ?fn (HWND, UINT, LPARAM) callconv(.C) c_int;
pub const struct__PROPSHEETHEADERA_V1 = extern struct {
    dwSize: DWORD,
    dwFlags: DWORD,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    @"": extern union {
        hIcon: HICON,
        pszIcon: LPCSTR,
    },
    pszCaption: LPCSTR,
    nPages: UINT,
    @"": extern union {
        nStartPage: UINT,
        pStartPage: LPCSTR,
    },
    @"": extern union {
        ppsp: LPCPROPSHEETPAGEA,
        phpage: [*c]HPROPSHEETPAGE,
    },
    pfnCallback: PFNPROPSHEETCALLBACK,
};
pub const PROPSHEETHEADERA_V1 = struct__PROPSHEETHEADERA_V1;
pub const LPPROPSHEETHEADERA_V1 = [*c]struct__PROPSHEETHEADERA_V1;
pub const LPCPROPSHEETHEADERA_V1 = [*c]const PROPSHEETHEADERA_V1;
pub const struct__PROPSHEETHEADERA_V2 = extern struct {
    dwSize: DWORD,
    dwFlags: DWORD,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    @"": extern union {
        hIcon: HICON,
        pszIcon: LPCSTR,
    },
    pszCaption: LPCSTR,
    nPages: UINT,
    @"": extern union {
        nStartPage: UINT,
        pStartPage: LPCSTR,
    },
    @"": extern union {
        ppsp: LPCPROPSHEETPAGEA,
        phpage: [*c]HPROPSHEETPAGE,
    },
    pfnCallback: PFNPROPSHEETCALLBACK,
    @"": extern union {
        hbmWatermark: HBITMAP,
        pszbmWatermark: LPCSTR,
    },
    hplWatermark: HPALETTE,
    @"": extern union {
        hbmHeader: HBITMAP,
        pszbmHeader: LPCSTR,
    },
};
pub const PROPSHEETHEADERA_V2 = struct__PROPSHEETHEADERA_V2;
pub const LPPROPSHEETHEADERA_V2 = [*c]struct__PROPSHEETHEADERA_V2;
pub const LPCPROPSHEETHEADERA_V2 = [*c]const PROPSHEETHEADERA_V2;
pub const struct__PROPSHEETHEADERW_V1 = extern struct {
    dwSize: DWORD,
    dwFlags: DWORD,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    @"": extern union {
        hIcon: HICON,
        pszIcon: LPCWSTR,
    },
    pszCaption: LPCWSTR,
    nPages: UINT,
    @"": extern union {
        nStartPage: UINT,
        pStartPage: LPCWSTR,
    },
    @"": extern union {
        ppsp: LPCPROPSHEETPAGEW,
        phpage: [*c]HPROPSHEETPAGE,
    },
    pfnCallback: PFNPROPSHEETCALLBACK,
};
pub const PROPSHEETHEADERW_V1 = struct__PROPSHEETHEADERW_V1;
pub const LPPROPSHEETHEADERW_V1 = [*c]struct__PROPSHEETHEADERW_V1;
pub const LPCPROPSHEETHEADERW_V1 = [*c]const PROPSHEETHEADERW_V1;
pub const struct__PROPSHEETHEADERW_V2 = extern struct {
    dwSize: DWORD,
    dwFlags: DWORD,
    hwndParent: HWND,
    hInstance: HINSTANCE,
    @"": extern union {
        hIcon: HICON,
        pszIcon: LPCWSTR,
    },
    pszCaption: LPCWSTR,
    nPages: UINT,
    @"": extern union {
        nStartPage: UINT,
        pStartPage: LPCWSTR,
    },
    @"": extern union {
        ppsp: LPCPROPSHEETPAGEW,
        phpage: [*c]HPROPSHEETPAGE,
    },
    pfnCallback: PFNPROPSHEETCALLBACK,
    @"": extern union {
        hbmWatermark: HBITMAP,
        pszbmWatermark: LPCWSTR,
    },
    hplWatermark: HPALETTE,
    @"": extern union {
        hbmHeader: HBITMAP,
        pszbmHeader: LPCWSTR,
    },
};
pub const PROPSHEETHEADERW_V2 = struct__PROPSHEETHEADERW_V2;
pub const LPPROPSHEETHEADERW_V2 = [*c]struct__PROPSHEETHEADERW_V2;
pub const LPCPROPSHEETHEADERW_V2 = [*c]const PROPSHEETHEADERW_V2;
pub const PROPSHEETHEADERA = PROPSHEETHEADERA_V2;
pub const PROPSHEETHEADERW = PROPSHEETHEADERW_V2;
pub const LPPROPSHEETHEADERA = LPPROPSHEETHEADERA_V2;
pub const LPPROPSHEETHEADERW = LPPROPSHEETHEADERW_V2;
pub const LPCPROPSHEETHEADERA = LPCPROPSHEETHEADERA_V2;
pub const LPCPROPSHEETHEADERW = LPCPROPSHEETHEADERW_V2;
pub extern "comctl32" fn CreatePropertySheetPageA(constPropSheetPagePointer: LPCPROPSHEETPAGEA) callconv(.Stdcall) HPROPSHEETPAGE;
pub extern "comctl32" fn CreatePropertySheetPageW(constPropSheetPagePointer: LPCPROPSHEETPAGEW) callconv(.Stdcall) HPROPSHEETPAGE;
pub extern "comctl32" fn DestroyPropertySheetPage(arg0: HPROPSHEETPAGE) callconv(.Stdcall) BOOL;
pub extern "comctl32" fn PropertySheetA(arg0: LPCPROPSHEETHEADERA) callconv(.Stdcall) INT_PTR;
pub extern "comctl32" fn PropertySheetW(arg0: LPCPROPSHEETHEADERW) callconv(.Stdcall) INT_PTR;
pub const LPFNADDPROPSHEETPAGE = ?fn (HPROPSHEETPAGE, LPARAM) callconv(.C) BOOL;
pub const LPFNADDPROPSHEETPAGES = ?fn (LPVOID, LPFNADDPROPSHEETPAGE, LPARAM) callconv(.C) BOOL;
pub const struct__PSHNOTIFY = extern struct {
    hdr: NMHDR,
    lParam: LPARAM,
};
pub const PSHNOTIFY = struct__PSHNOTIFY;
pub const LPPSHNOTIFY = [*c]struct__PSHNOTIFY;
pub const struct__PRINTER_INFO_1A = extern struct {
    Flags: DWORD,
    pDescription: LPSTR,
    pName: LPSTR,
    pComment: LPSTR,
};
pub const PRINTER_INFO_1A = struct__PRINTER_INFO_1A;
pub const PPRINTER_INFO_1A = [*c]struct__PRINTER_INFO_1A;
pub const LPPRINTER_INFO_1A = [*c]struct__PRINTER_INFO_1A;
pub const struct__PRINTER_INFO_1W = extern struct {
    Flags: DWORD,
    pDescription: LPWSTR,
    pName: LPWSTR,
    pComment: LPWSTR,
};
pub const PRINTER_INFO_1W = struct__PRINTER_INFO_1W;
pub const PPRINTER_INFO_1W = [*c]struct__PRINTER_INFO_1W;
pub const LPPRINTER_INFO_1W = [*c]struct__PRINTER_INFO_1W;
pub const PRINTER_INFO_1 = PRINTER_INFO_1A;
pub const PPRINTER_INFO_1 = PPRINTER_INFO_1A;
pub const LPPRINTER_INFO_1 = LPPRINTER_INFO_1A;
pub const struct__PRINTER_INFO_2A = extern struct {
    pServerName: LPSTR,
    pPrinterName: LPSTR,
    pShareName: LPSTR,
    pPortName: LPSTR,
    pDriverName: LPSTR,
    pComment: LPSTR,
    pLocation: LPSTR,
    pDevMode: LPDEVMODEA,
    pSepFile: LPSTR,
    pPrintProcessor: LPSTR,
    pDatatype: LPSTR,
    pParameters: LPSTR,
    pSecurityDescriptor: PSECURITY_DESCRIPTOR,
    Attributes: DWORD,
    Priority: DWORD,
    DefaultPriority: DWORD,
    StartTime: DWORD,
    UntilTime: DWORD,
    Status: DWORD,
    cJobs: DWORD,
    AveragePPM: DWORD,
};
pub const PRINTER_INFO_2A = struct__PRINTER_INFO_2A;
pub const PPRINTER_INFO_2A = [*c]struct__PRINTER_INFO_2A;
pub const LPPRINTER_INFO_2A = [*c]struct__PRINTER_INFO_2A;
pub const struct__PRINTER_INFO_2W = extern struct {
    pServerName: LPWSTR,
    pPrinterName: LPWSTR,
    pShareName: LPWSTR,
    pPortName: LPWSTR,
    pDriverName: LPWSTR,
    pComment: LPWSTR,
    pLocation: LPWSTR,
    pDevMode: LPDEVMODEW,
    pSepFile: LPWSTR,
    pPrintProcessor: LPWSTR,
    pDatatype: LPWSTR,
    pParameters: LPWSTR,
    pSecurityDescriptor: PSECURITY_DESCRIPTOR,
    Attributes: DWORD,
    Priority: DWORD,
    DefaultPriority: DWORD,
    StartTime: DWORD,
    UntilTime: DWORD,
    Status: DWORD,
    cJobs: DWORD,
    AveragePPM: DWORD,
};
pub const PRINTER_INFO_2W = struct__PRINTER_INFO_2W;
pub const PPRINTER_INFO_2W = [*c]struct__PRINTER_INFO_2W;
pub const LPPRINTER_INFO_2W = [*c]struct__PRINTER_INFO_2W;
pub const PRINTER_INFO_2 = PRINTER_INFO_2A;
pub const PPRINTER_INFO_2 = PPRINTER_INFO_2A;
pub const LPPRINTER_INFO_2 = LPPRINTER_INFO_2A;
pub const struct__PRINTER_INFO_3 = extern struct {
    pSecurityDescriptor: PSECURITY_DESCRIPTOR,
};
pub const PRINTER_INFO_3 = struct__PRINTER_INFO_3;
pub const PPRINTER_INFO_3 = [*c]struct__PRINTER_INFO_3;
pub const LPPRINTER_INFO_3 = [*c]struct__PRINTER_INFO_3;
pub const struct__PRINTER_INFO_4A = extern struct {
    pPrinterName: LPSTR,
    pServerName: LPSTR,
    Attributes: DWORD,
};
pub const PRINTER_INFO_4A = struct__PRINTER_INFO_4A;
pub const PPRINTER_INFO_4A = [*c]struct__PRINTER_INFO_4A;
pub const LPPRINTER_INFO_4A = [*c]struct__PRINTER_INFO_4A;
pub const struct__PRINTER_INFO_4W = extern struct {
    pPrinterName: LPWSTR,
    pServerName: LPWSTR,
    Attributes: DWORD,
};
pub const PRINTER_INFO_4W = struct__PRINTER_INFO_4W;
pub const PPRINTER_INFO_4W = [*c]struct__PRINTER_INFO_4W;
pub const LPPRINTER_INFO_4W = [*c]struct__PRINTER_INFO_4W;
pub const PRINTER_INFO_4 = PRINTER_INFO_4A;
pub const PPRINTER_INFO_4 = PPRINTER_INFO_4A;
pub const LPPRINTER_INFO_4 = LPPRINTER_INFO_4A;
pub const struct__PRINTER_INFO_5A = extern struct {
    pPrinterName: LPSTR,
    pPortName: LPSTR,
    Attributes: DWORD,
    DeviceNotSelectedTimeout: DWORD,
    TransmissionRetryTimeout: DWORD,
};
pub const PRINTER_INFO_5A = struct__PRINTER_INFO_5A;
pub const PPRINTER_INFO_5A = [*c]struct__PRINTER_INFO_5A;
pub const LPPRINTER_INFO_5A = [*c]struct__PRINTER_INFO_5A;
pub const struct__PRINTER_INFO_5W = extern struct {
    pPrinterName: LPWSTR,
    pPortName: LPWSTR,
    Attributes: DWORD,
    DeviceNotSelectedTimeout: DWORD,
    TransmissionRetryTimeout: DWORD,
};
pub const PRINTER_INFO_5W = struct__PRINTER_INFO_5W;
pub const PPRINTER_INFO_5W = [*c]struct__PRINTER_INFO_5W;
pub const LPPRINTER_INFO_5W = [*c]struct__PRINTER_INFO_5W;
pub const PRINTER_INFO_5 = PRINTER_INFO_5A;
pub const PPRINTER_INFO_5 = PPRINTER_INFO_5A;
pub const LPPRINTER_INFO_5 = LPPRINTER_INFO_5A;
pub const struct__PRINTER_INFO_6 = extern struct {
    dwStatus: DWORD,
};
pub const PRINTER_INFO_6 = struct__PRINTER_INFO_6;
pub const PPRINTER_INFO_6 = [*c]struct__PRINTER_INFO_6;
pub const LPPRINTER_INFO_6 = [*c]struct__PRINTER_INFO_6;
pub const struct__PRINTER_INFO_7A = extern struct {
    pszObjectGUID: LPSTR,
    dwAction: DWORD,
};
pub const PRINTER_INFO_7A = struct__PRINTER_INFO_7A;
pub const PPRINTER_INFO_7A = [*c]struct__PRINTER_INFO_7A;
pub const LPPRINTER_INFO_7A = [*c]struct__PRINTER_INFO_7A;
pub const struct__PRINTER_INFO_7W = extern struct {
    pszObjectGUID: LPWSTR,
    dwAction: DWORD,
};
pub const PRINTER_INFO_7W = struct__PRINTER_INFO_7W;
pub const PPRINTER_INFO_7W = [*c]struct__PRINTER_INFO_7W;
pub const LPPRINTER_INFO_7W = [*c]struct__PRINTER_INFO_7W;
pub const PRINTER_INFO_7 = PRINTER_INFO_7A;
pub const PPRINTER_INFO_7 = PPRINTER_INFO_7A;
pub const LPPRINTER_INFO_7 = LPPRINTER_INFO_7A;
pub const struct__PRINTER_INFO_8A = extern struct {
    pDevMode: LPDEVMODEA,
};
pub const PRINTER_INFO_8A = struct__PRINTER_INFO_8A;
pub const PPRINTER_INFO_8A = [*c]struct__PRINTER_INFO_8A;
pub const LPPRINTER_INFO_8A = [*c]struct__PRINTER_INFO_8A;
pub const struct__PRINTER_INFO_8W = extern struct {
    pDevMode: LPDEVMODEW,
};
pub const PRINTER_INFO_8W = struct__PRINTER_INFO_8W;
pub const PPRINTER_INFO_8W = [*c]struct__PRINTER_INFO_8W;
pub const LPPRINTER_INFO_8W = [*c]struct__PRINTER_INFO_8W;
pub const PRINTER_INFO_8 = PRINTER_INFO_8A;
pub const PPRINTER_INFO_8 = PPRINTER_INFO_8A;
pub const LPPRINTER_INFO_8 = LPPRINTER_INFO_8A;
pub const struct__PRINTER_INFO_9A = extern struct {
    pDevMode: LPDEVMODEA,
};
pub const PRINTER_INFO_9A = struct__PRINTER_INFO_9A;
pub const PPRINTER_INFO_9A = [*c]struct__PRINTER_INFO_9A;
pub const LPPRINTER_INFO_9A = [*c]struct__PRINTER_INFO_9A;
pub const struct__PRINTER_INFO_9W = extern struct {
    pDevMode: LPDEVMODEW,
};
pub const PRINTER_INFO_9W = struct__PRINTER_INFO_9W;
pub const PPRINTER_INFO_9W = [*c]struct__PRINTER_INFO_9W;
pub const LPPRINTER_INFO_9W = [*c]struct__PRINTER_INFO_9W;
pub const PRINTER_INFO_9 = PRINTER_INFO_9A;
pub const PPRINTER_INFO_9 = PPRINTER_INFO_9A;
pub const LPPRINTER_INFO_9 = LPPRINTER_INFO_9A;
pub const struct__JOB_INFO_1A = extern struct {
    JobId: DWORD,
    pPrinterName: LPSTR,
    pMachineName: LPSTR,
    pUserName: LPSTR,
    pDocument: LPSTR,
    pDatatype: LPSTR,
    pStatus: LPSTR,
    Status: DWORD,
    Priority: DWORD,
    Position: DWORD,
    TotalPages: DWORD,
    PagesPrinted: DWORD,
    Submitted: SYSTEMTIME,
};
pub const JOB_INFO_1A = struct__JOB_INFO_1A;
pub const PJOB_INFO_1A = [*c]struct__JOB_INFO_1A;
pub const LPJOB_INFO_1A = [*c]struct__JOB_INFO_1A;
pub const struct__JOB_INFO_1W = extern struct {
    JobId: DWORD,
    pPrinterName: LPWSTR,
    pMachineName: LPWSTR,
    pUserName: LPWSTR,
    pDocument: LPWSTR,
    pDatatype: LPWSTR,
    pStatus: LPWSTR,
    Status: DWORD,
    Priority: DWORD,
    Position: DWORD,
    TotalPages: DWORD,
    PagesPrinted: DWORD,
    Submitted: SYSTEMTIME,
};
pub const JOB_INFO_1W = struct__JOB_INFO_1W;
pub const PJOB_INFO_1W = [*c]struct__JOB_INFO_1W;
pub const LPJOB_INFO_1W = [*c]struct__JOB_INFO_1W;
pub const JOB_INFO_1 = JOB_INFO_1A;
pub const PJOB_INFO_1 = PJOB_INFO_1A;
pub const LPJOB_INFO_1 = LPJOB_INFO_1A;
pub const struct__JOB_INFO_2A = extern struct {
    JobId: DWORD,
    pPrinterName: LPSTR,
    pMachineName: LPSTR,
    pUserName: LPSTR,
    pDocument: LPSTR,
    pNotifyName: LPSTR,
    pDatatype: LPSTR,
    pPrintProcessor: LPSTR,
    pParameters: LPSTR,
    pDriverName: LPSTR,
    pDevMode: LPDEVMODEA,
    pStatus: LPSTR,
    pSecurityDescriptor: PSECURITY_DESCRIPTOR,
    Status: DWORD,
    Priority: DWORD,
    Position: DWORD,
    StartTime: DWORD,
    UntilTime: DWORD,
    TotalPages: DWORD,
    Size: DWORD,
    Submitted: SYSTEMTIME,
    Time: DWORD,
    PagesPrinted: DWORD,
};
pub const JOB_INFO_2A = struct__JOB_INFO_2A;
pub const PJOB_INFO_2A = [*c]struct__JOB_INFO_2A;
pub const LPJOB_INFO_2A = [*c]struct__JOB_INFO_2A;
pub const struct__JOB_INFO_2W = extern struct {
    JobId: DWORD,
    pPrinterName: LPWSTR,
    pMachineName: LPWSTR,
    pUserName: LPWSTR,
    pDocument: LPWSTR,
    pNotifyName: LPWSTR,
    pDatatype: LPWSTR,
    pPrintProcessor: LPWSTR,
    pParameters: LPWSTR,
    pDriverName: LPWSTR,
    pDevMode: LPDEVMODEW,
    pStatus: LPWSTR,
    pSecurityDescriptor: PSECURITY_DESCRIPTOR,
    Status: DWORD,
    Priority: DWORD,
    Position: DWORD,
    StartTime: DWORD,
    UntilTime: DWORD,
    TotalPages: DWORD,
    Size: DWORD,
    Submitted: SYSTEMTIME,
    Time: DWORD,
    PagesPrinted: DWORD,
};
pub const JOB_INFO_2W = struct__JOB_INFO_2W;
pub const PJOB_INFO_2W = [*c]struct__JOB_INFO_2W;
pub const LPJOB_INFO_2W = [*c]struct__JOB_INFO_2W;
pub const JOB_INFO_2 = JOB_INFO_2A;
pub const PJOB_INFO_2 = PJOB_INFO_2A;
pub const LPJOB_INFO_2 = LPJOB_INFO_2A;
pub const struct__JOB_INFO_3 = extern struct {
    JobId: DWORD,
    NextJobId: DWORD,
    Reserved: DWORD,
};
pub const JOB_INFO_3 = struct__JOB_INFO_3;
pub const PJOB_INFO_3 = [*c]struct__JOB_INFO_3;
pub const LPJOB_INFO_3 = [*c]struct__JOB_INFO_3;
pub const struct__JOB_INFO_4A = extern struct {
    JobId: DWORD,
    pPrinterName: LPSTR,
    pMachineName: LPSTR,
    pUserName: LPSTR,
    pDocument: LPSTR,
    pNotifyName: LPSTR,
    pDatatype: LPSTR,
    pPrintProcessor: LPSTR,
    pParameters: LPSTR,
    pDriverName: LPSTR,
    pDevMode: LPDEVMODEA,
    pStatus: LPSTR,
    pSecurityDescriptor: PSECURITY_DESCRIPTOR,
    Status: DWORD,
    Priority: DWORD,
    Position: DWORD,
    StartTime: DWORD,
    UntilTime: DWORD,
    TotalPages: DWORD,
    Size: DWORD,
    Submitted: SYSTEMTIME,
    Time: DWORD,
    PagesPrinted: DWORD,
    SizeHigh: LONG,
};
pub const JOB_INFO_4A = struct__JOB_INFO_4A;
pub const PJOB_INFO_4A = [*c]struct__JOB_INFO_4A;
pub const LPJOB_INFO_4A = [*c]struct__JOB_INFO_4A;
pub const struct__JOB_INFO_4W = extern struct {
    JobId: DWORD,
    pPrinterName: LPWSTR,
    pMachineName: LPWSTR,
    pUserName: LPWSTR,
    pDocument: LPWSTR,
    pNotifyName: LPWSTR,
    pDatatype: LPWSTR,
    pPrintProcessor: LPWSTR,
    pParameters: LPWSTR,
    pDriverName: LPWSTR,
    pDevMode: LPDEVMODEW,
    pStatus: LPWSTR,
    pSecurityDescriptor: PSECURITY_DESCRIPTOR,
    Status: DWORD,
    Priority: DWORD,
    Position: DWORD,
    StartTime: DWORD,
    UntilTime: DWORD,
    TotalPages: DWORD,
    Size: DWORD,
    Submitted: SYSTEMTIME,
    Time: DWORD,
    PagesPrinted: DWORD,
    SizeHigh: LONG,
};
pub const JOB_INFO_4W = struct__JOB_INFO_4W;
pub const PJOB_INFO_4W = [*c]struct__JOB_INFO_4W;
pub const LPJOB_INFO_4W = [*c]struct__JOB_INFO_4W;
pub const JOB_INFO_4 = JOB_INFO_4A;
pub const PJOB_INFO_4 = PJOB_INFO_4A;
pub const LPJOB_INFO_4 = LPJOB_INFO_4A;
pub const struct__ADDJOB_INFO_1A = extern struct {
    Path: LPSTR,
    JobId: DWORD,
};
pub const ADDJOB_INFO_1A = struct__ADDJOB_INFO_1A;
pub const PADDJOB_INFO_1A = [*c]struct__ADDJOB_INFO_1A;
pub const LPADDJOB_INFO_1A = [*c]struct__ADDJOB_INFO_1A;
pub const struct__ADDJOB_INFO_1W = extern struct {
    Path: LPWSTR,
    JobId: DWORD,
};
pub const ADDJOB_INFO_1W = struct__ADDJOB_INFO_1W;
pub const PADDJOB_INFO_1W = [*c]struct__ADDJOB_INFO_1W;
pub const LPADDJOB_INFO_1W = [*c]struct__ADDJOB_INFO_1W;
pub const ADDJOB_INFO_1 = ADDJOB_INFO_1A;
pub const PADDJOB_INFO_1 = PADDJOB_INFO_1A;
pub const LPADDJOB_INFO_1 = LPADDJOB_INFO_1A;
pub const struct__DRIVER_INFO_1A = extern struct {
    pName: LPSTR,
};
pub const DRIVER_INFO_1A = struct__DRIVER_INFO_1A;
pub const PDRIVER_INFO_1A = [*c]struct__DRIVER_INFO_1A;
pub const LPDRIVER_INFO_1A = [*c]struct__DRIVER_INFO_1A;
pub const struct__DRIVER_INFO_1W = extern struct {
    pName: LPWSTR,
};
pub const DRIVER_INFO_1W = struct__DRIVER_INFO_1W;
pub const PDRIVER_INFO_1W = [*c]struct__DRIVER_INFO_1W;
pub const LPDRIVER_INFO_1W = [*c]struct__DRIVER_INFO_1W;
pub const DRIVER_INFO_1 = DRIVER_INFO_1A;
pub const PDRIVER_INFO_1 = PDRIVER_INFO_1A;
pub const LPDRIVER_INFO_1 = LPDRIVER_INFO_1A;
pub const struct__DRIVER_INFO_2A = extern struct {
    cVersion: DWORD,
    pName: LPSTR,
    pEnvironment: LPSTR,
    pDriverPath: LPSTR,
    pDataFile: LPSTR,
    pConfigFile: LPSTR,
};
pub const DRIVER_INFO_2A = struct__DRIVER_INFO_2A;
pub const PDRIVER_INFO_2A = [*c]struct__DRIVER_INFO_2A;
pub const LPDRIVER_INFO_2A = [*c]struct__DRIVER_INFO_2A;
pub const struct__DRIVER_INFO_2W = extern struct {
    cVersion: DWORD,
    pName: LPWSTR,
    pEnvironment: LPWSTR,
    pDriverPath: LPWSTR,
    pDataFile: LPWSTR,
    pConfigFile: LPWSTR,
};
pub const DRIVER_INFO_2W = struct__DRIVER_INFO_2W;
pub const PDRIVER_INFO_2W = [*c]struct__DRIVER_INFO_2W;
pub const LPDRIVER_INFO_2W = [*c]struct__DRIVER_INFO_2W;
pub const DRIVER_INFO_2 = DRIVER_INFO_2A;
pub const PDRIVER_INFO_2 = PDRIVER_INFO_2A;
pub const LPDRIVER_INFO_2 = LPDRIVER_INFO_2A;
pub const struct__DRIVER_INFO_3A = extern struct {
    cVersion: DWORD,
    pName: LPSTR,
    pEnvironment: LPSTR,
    pDriverPath: LPSTR,
    pDataFile: LPSTR,
    pConfigFile: LPSTR,
    pHelpFile: LPSTR,
    pDependentFiles: LPSTR,
    pMonitorName: LPSTR,
    pDefaultDataType: LPSTR,
};
pub const DRIVER_INFO_3A = struct__DRIVER_INFO_3A;
pub const PDRIVER_INFO_3A = [*c]struct__DRIVER_INFO_3A;
pub const LPDRIVER_INFO_3A = [*c]struct__DRIVER_INFO_3A;
pub const struct__DRIVER_INFO_3W = extern struct {
    cVersion: DWORD,
    pName: LPWSTR,
    pEnvironment: LPWSTR,
    pDriverPath: LPWSTR,
    pDataFile: LPWSTR,
    pConfigFile: LPWSTR,
    pHelpFile: LPWSTR,
    pDependentFiles: LPWSTR,
    pMonitorName: LPWSTR,
    pDefaultDataType: LPWSTR,
};
pub const DRIVER_INFO_3W = struct__DRIVER_INFO_3W;
pub const PDRIVER_INFO_3W = [*c]struct__DRIVER_INFO_3W;
pub const LPDRIVER_INFO_3W = [*c]struct__DRIVER_INFO_3W;
pub const DRIVER_INFO_3 = DRIVER_INFO_3A;
pub const PDRIVER_INFO_3 = PDRIVER_INFO_3A;
pub const LPDRIVER_INFO_3 = LPDRIVER_INFO_3A;
pub const struct__DRIVER_INFO_4A = extern struct {
    cVersion: DWORD,
    pName: LPSTR,
    pEnvironment: LPSTR,
    pDriverPath: LPSTR,
    pDataFile: LPSTR,
    pConfigFile: LPSTR,
    pHelpFile: LPSTR,
    pDependentFiles: LPSTR,
    pMonitorName: LPSTR,
    pDefaultDataType: LPSTR,
    pszzPreviousNames: LPSTR,
};
pub const DRIVER_INFO_4A = struct__DRIVER_INFO_4A;
pub const PDRIVER_INFO_4A = [*c]struct__DRIVER_INFO_4A;
pub const LPDRIVER_INFO_4A = [*c]struct__DRIVER_INFO_4A;
pub const struct__DRIVER_INFO_4W = extern struct {
    cVersion: DWORD,
    pName: LPWSTR,
    pEnvironment: LPWSTR,
    pDriverPath: LPWSTR,
    pDataFile: LPWSTR,
    pConfigFile: LPWSTR,
    pHelpFile: LPWSTR,
    pDependentFiles: LPWSTR,
    pMonitorName: LPWSTR,
    pDefaultDataType: LPWSTR,
    pszzPreviousNames: LPWSTR,
};
pub const DRIVER_INFO_4W = struct__DRIVER_INFO_4W;
pub const PDRIVER_INFO_4W = [*c]struct__DRIVER_INFO_4W;
pub const LPDRIVER_INFO_4W = [*c]struct__DRIVER_INFO_4W;
pub const DRIVER_INFO_4 = DRIVER_INFO_4A;
pub const PDRIVER_INFO_4 = PDRIVER_INFO_4A;
pub const LPDRIVER_INFO_4 = LPDRIVER_INFO_4A;
pub const struct__DRIVER_INFO_5A = extern struct {
    cVersion: DWORD,
    pName: LPSTR,
    pEnvironment: LPSTR,
    pDriverPath: LPSTR,
    pDataFile: LPSTR,
    pConfigFile: LPSTR,
    dwDriverAttributes: DWORD,
    dwConfigVersion: DWORD,
    dwDriverVersion: DWORD,
};
pub const DRIVER_INFO_5A = struct__DRIVER_INFO_5A;
pub const PDRIVER_INFO_5A = [*c]struct__DRIVER_INFO_5A;
pub const LPDRIVER_INFO_5A = [*c]struct__DRIVER_INFO_5A;
pub const struct__DRIVER_INFO_5W = extern struct {
    cVersion: DWORD,
    pName: LPWSTR,
    pEnvironment: LPWSTR,
    pDriverPath: LPWSTR,
    pDataFile: LPWSTR,
    pConfigFile: LPWSTR,
    dwDriverAttributes: DWORD,
    dwConfigVersion: DWORD,
    dwDriverVersion: DWORD,
};
pub const DRIVER_INFO_5W = struct__DRIVER_INFO_5W;
pub const PDRIVER_INFO_5W = [*c]struct__DRIVER_INFO_5W;
pub const LPDRIVER_INFO_5W = [*c]struct__DRIVER_INFO_5W;
pub const DRIVER_INFO_5 = DRIVER_INFO_5A;
pub const PDRIVER_INFO_5 = PDRIVER_INFO_5A;
pub const LPDRIVER_INFO_5 = LPDRIVER_INFO_5A;
pub const struct__DRIVER_INFO_6A = extern struct {
    cVersion: DWORD,
    pName: LPSTR,
    pEnvironment: LPSTR,
    pDriverPath: LPSTR,
    pDataFile: LPSTR,
    pConfigFile: LPSTR,
    pHelpFile: LPSTR,
    pDependentFiles: LPSTR,
    pMonitorName: LPSTR,
    pDefaultDataType: LPSTR,
    pszzPreviousNames: LPSTR,
    ftDriverDate: FILETIME,
    dwlDriverVersion: DWORDLONG,
    pszMfgName: LPSTR,
    pszOEMUrl: LPSTR,
    pszHardwareID: LPSTR,
    pszProvider: LPSTR,
};
pub const DRIVER_INFO_6A = struct__DRIVER_INFO_6A;
pub const PDRIVER_INFO_6A = [*c]struct__DRIVER_INFO_6A;
pub const LPDRIVER_INFO_6A = [*c]struct__DRIVER_INFO_6A;
pub const struct__DRIVER_INFO_6W = extern struct {
    cVersion: DWORD,
    pName: LPWSTR,
    pEnvironment: LPWSTR,
    pDriverPath: LPWSTR,
    pDataFile: LPWSTR,
    pConfigFile: LPWSTR,
    pHelpFile: LPWSTR,
    pDependentFiles: LPWSTR,
    pMonitorName: LPWSTR,
    pDefaultDataType: LPWSTR,
    pszzPreviousNames: LPWSTR,
    ftDriverDate: FILETIME,
    dwlDriverVersion: DWORDLONG,
    pszMfgName: LPWSTR,
    pszOEMUrl: LPWSTR,
    pszHardwareID: LPWSTR,
    pszProvider: LPWSTR,
};
pub const DRIVER_INFO_6W = struct__DRIVER_INFO_6W;
pub const PDRIVER_INFO_6W = [*c]struct__DRIVER_INFO_6W;
pub const LPDRIVER_INFO_6W = [*c]struct__DRIVER_INFO_6W;
pub const DRIVER_INFO_6 = DRIVER_INFO_6A;
pub const PDRIVER_INFO_6 = PDRIVER_INFO_6A;
pub const LPDRIVER_INFO_6 = LPDRIVER_INFO_6A;
pub const struct__DRIVER_INFO_8A = extern struct {
    cVersion: DWORD,
    pName: LPSTR,
    pEnvironment: LPSTR,
    pDriverPath: LPSTR,
    pDataFile: LPSTR,
    pConfigFile: LPSTR,
    pHelpFile: LPSTR,
    pDependentFiles: LPSTR,
    pMonitorName: LPSTR,
    pDefaultDataType: LPSTR,
    pszzPreviousNames: LPSTR,
    ftDriverDate: FILETIME,
    dwlDriverVersion: DWORDLONG,
    pszMfgName: LPSTR,
    pszOEMUrl: LPSTR,
    pszHardwareID: LPSTR,
    pszProvider: LPSTR,
    pszPrintProcessor: LPSTR,
    pszVendorSetup: LPSTR,
    pszzColorProfiles: LPSTR,
    pszInfPath: LPSTR,
    dwPrinterDriverAttributes: DWORD,
    pszzCoreDriverDependencies: LPSTR,
    ftMinInboxDriverVerDate: FILETIME,
    dwlMinInboxDriverVerVersion: DWORDLONG,
};
pub const DRIVER_INFO_8A = struct__DRIVER_INFO_8A;
pub const PDRIVER_INFO_8A = [*c]struct__DRIVER_INFO_8A;
pub const LPDRIVER_INFO_8A = [*c]struct__DRIVER_INFO_8A;
pub const struct__DRIVER_INFO_8W = extern struct {
    cVersion: DWORD,
    pName: LPWSTR,
    pEnvironment: LPWSTR,
    pDriverPath: LPWSTR,
    pDataFile: LPWSTR,
    pConfigFile: LPWSTR,
    pHelpFile: LPWSTR,
    pDependentFiles: LPWSTR,
    pMonitorName: LPWSTR,
    pDefaultDataType: LPWSTR,
    pszzPreviousNames: LPWSTR,
    ftDriverDate: FILETIME,
    dwlDriverVersion: DWORDLONG,
    pszMfgName: LPWSTR,
    pszOEMUrl: LPWSTR,
    pszHardwareID: LPWSTR,
    pszProvider: LPWSTR,
    pszPrintProcessor: LPWSTR,
    pszVendorSetup: LPWSTR,
    pszzColorProfiles: LPWSTR,
    pszInfPath: LPWSTR,
    dwPrinterDriverAttributes: DWORD,
    pszzCoreDriverDependencies: LPWSTR,
    ftMinInboxDriverVerDate: FILETIME,
    dwlMinInboxDriverVerVersion: DWORDLONG,
};
pub const DRIVER_INFO_8W = struct__DRIVER_INFO_8W;
pub const PDRIVER_INFO_8W = [*c]struct__DRIVER_INFO_8W;
pub const LPDRIVER_INFO_8W = [*c]struct__DRIVER_INFO_8W;
pub const DRIVER_INFO_8 = DRIVER_INFO_8A;
pub const PDRIVER_INFO_8 = PDRIVER_INFO_8A;
pub const LPDRIVER_INFO_8 = LPDRIVER_INFO_8A;
pub const struct__DOC_INFO_1A = extern struct {
    pDocName: LPSTR,
    pOutputFile: LPSTR,
    pDatatype: LPSTR,
};
pub const DOC_INFO_1A = struct__DOC_INFO_1A;
pub const PDOC_INFO_1A = [*c]struct__DOC_INFO_1A;
pub const LPDOC_INFO_1A = [*c]struct__DOC_INFO_1A;
pub const struct__DOC_INFO_1W = extern struct {
    pDocName: LPWSTR,
    pOutputFile: LPWSTR,
    pDatatype: LPWSTR,
};
pub const DOC_INFO_1W = struct__DOC_INFO_1W;
pub const PDOC_INFO_1W = [*c]struct__DOC_INFO_1W;
pub const LPDOC_INFO_1W = [*c]struct__DOC_INFO_1W;
pub const DOC_INFO_1 = DOC_INFO_1A;
pub const PDOC_INFO_1 = PDOC_INFO_1A;
pub const LPDOC_INFO_1 = LPDOC_INFO_1A;
pub const struct__FORM_INFO_1A = extern struct {
    Flags: DWORD,
    pName: LPSTR,
    Size: SIZEL,
    ImageableArea: RECTL,
};
pub const FORM_INFO_1A = struct__FORM_INFO_1A;
pub const PFORM_INFO_1A = [*c]struct__FORM_INFO_1A;
pub const LPFORM_INFO_1A = [*c]struct__FORM_INFO_1A;
pub const struct__FORM_INFO_1W = extern struct {
    Flags: DWORD,
    pName: LPWSTR,
    Size: SIZEL,
    ImageableArea: RECTL,
};
pub const FORM_INFO_1W = struct__FORM_INFO_1W;
pub const PFORM_INFO_1W = [*c]struct__FORM_INFO_1W;
pub const LPFORM_INFO_1W = [*c]struct__FORM_INFO_1W;
pub const FORM_INFO_1 = FORM_INFO_1A;
pub const PFORM_INFO_1 = PFORM_INFO_1A;
pub const LPFORM_INFO_1 = LPFORM_INFO_1A;
pub const struct__FORM_INFO_2A = extern struct {
    Flags: DWORD,
    pName: LPCSTR,
    Size: SIZEL,
    ImageableArea: RECTL,
    pKeyword: LPCSTR,
    StringType: DWORD,
    pMuiDll: LPCSTR,
    dwResourceId: DWORD,
    pDisplayName: LPCSTR,
    wLangId: LANGID,
};
pub const FORM_INFO_2A = struct__FORM_INFO_2A;
pub const PFORM_INFO_2A = [*c]struct__FORM_INFO_2A;
pub const LPFORM_INFO_2A = [*c]struct__FORM_INFO_2A;
pub const struct__FORM_INFO_2W = extern struct {
    Flags: DWORD,
    pName: LPCWSTR,
    Size: SIZEL,
    ImageableArea: RECTL,
    pKeyword: LPCSTR,
    StringType: DWORD,
    pMuiDll: LPCWSTR,
    dwResourceId: DWORD,
    pDisplayName: LPCWSTR,
    wLangId: LANGID,
};
pub const FORM_INFO_2W = struct__FORM_INFO_2W;
pub const PFORM_INFO_2W = [*c]struct__FORM_INFO_2W;
pub const LPFORM_INFO_2W = [*c]struct__FORM_INFO_2W;
pub const FORM_INFO_2 = FORM_INFO_2A;
pub const PFORM_INFO_2 = PFORM_INFO_2A;
pub const LPFORM_INFO_2 = LPFORM_INFO_2A;
pub const struct__DOC_INFO_2A = extern struct {
    pDocName: LPSTR,
    pOutputFile: LPSTR,
    pDatatype: LPSTR,
    dwMode: DWORD,
    JobId: DWORD,
};
pub const DOC_INFO_2A = struct__DOC_INFO_2A;
pub const PDOC_INFO_2A = [*c]struct__DOC_INFO_2A;
pub const LPDOC_INFO_2A = [*c]struct__DOC_INFO_2A;
pub const struct__DOC_INFO_2W = extern struct {
    pDocName: LPWSTR,
    pOutputFile: LPWSTR,
    pDatatype: LPWSTR,
    dwMode: DWORD,
    JobId: DWORD,
};
pub const DOC_INFO_2W = struct__DOC_INFO_2W;
pub const PDOC_INFO_2W = [*c]struct__DOC_INFO_2W;
pub const LPDOC_INFO_2W = [*c]struct__DOC_INFO_2W;
pub const DOC_INFO_2 = DOC_INFO_2A;
pub const PDOC_INFO_2 = PDOC_INFO_2A;
pub const LPDOC_INFO_2 = LPDOC_INFO_2A;
pub const struct__DOC_INFO_3A = extern struct {
    pDocName: LPSTR,
    pOutputFile: LPSTR,
    pDatatype: LPSTR,
    dwFlags: DWORD,
};
pub const DOC_INFO_3A = struct__DOC_INFO_3A;
pub const PDOC_INFO_3A = [*c]struct__DOC_INFO_3A;
pub const LPDOC_INFO_3A = [*c]struct__DOC_INFO_3A;
pub const struct__DOC_INFO_3W = extern struct {
    pDocName: LPWSTR,
    pOutputFile: LPWSTR,
    pDatatype: LPWSTR,
    dwFlags: DWORD,
};
pub const DOC_INFO_3W = struct__DOC_INFO_3W;
pub const PDOC_INFO_3W = [*c]struct__DOC_INFO_3W;
pub const LPDOC_INFO_3W = [*c]struct__DOC_INFO_3W;
pub const DOC_INFO_3 = DOC_INFO_3A;
pub const PDOC_INFO_3 = PDOC_INFO_3A;
pub const LPDOC_INFO_3 = LPDOC_INFO_3A;
pub const struct__PRINTPROCESSOR_INFO_1A = extern struct {
    pName: LPSTR,
};
pub const PRINTPROCESSOR_INFO_1A = struct__PRINTPROCESSOR_INFO_1A;
pub const PPRINTPROCESSOR_INFO_1A = [*c]struct__PRINTPROCESSOR_INFO_1A;
pub const LPPRINTPROCESSOR_INFO_1A = [*c]struct__PRINTPROCESSOR_INFO_1A;
pub const struct__PRINTPROCESSOR_INFO_1W = extern struct {
    pName: LPWSTR,
};
pub const PRINTPROCESSOR_INFO_1W = struct__PRINTPROCESSOR_INFO_1W;
pub const PPRINTPROCESSOR_INFO_1W = [*c]struct__PRINTPROCESSOR_INFO_1W;
pub const LPPRINTPROCESSOR_INFO_1W = [*c]struct__PRINTPROCESSOR_INFO_1W;
pub const PRINTPROCESSOR_INFO_1 = PRINTPROCESSOR_INFO_1A;
pub const PPRINTPROCESSOR_INFO_1 = PPRINTPROCESSOR_INFO_1A;
pub const LPPRINTPROCESSOR_INFO_1 = LPPRINTPROCESSOR_INFO_1A;
pub const struct__PRINTPROCESSOR_CAPS_1 = extern struct {
    dwLevel: DWORD,
    dwNupOptions: DWORD,
    dwPageOrderFlags: DWORD,
    dwNumberOfCopies: DWORD,
};
pub const PRINTPROCESSOR_CAPS_1 = struct__PRINTPROCESSOR_CAPS_1;
pub const PPRINTPROCESSOR_CAPS_1 = [*c]struct__PRINTPROCESSOR_CAPS_1;
pub const struct__PRINTPROCESSOR_CAPS_2 = extern struct {
    dwLevel: DWORD,
    dwNupOptions: DWORD,
    dwPageOrderFlags: DWORD,
    dwNumberOfCopies: DWORD,
    dwDuplexHandlingCaps: DWORD,
    dwNupDirectionCaps: DWORD,
    dwNupBorderCaps: DWORD,
    dwBookletHandlingCaps: DWORD,
    dwScalingCaps: DWORD,
};
pub const PRINTPROCESSOR_CAPS_2 = struct__PRINTPROCESSOR_CAPS_2;
pub const PPRINTPROCESSOR_CAPS_2 = [*c]struct__PRINTPROCESSOR_CAPS_2;
pub const struct__PORT_INFO_1A = extern struct {
    pName: LPSTR,
};
pub const PORT_INFO_1A = struct__PORT_INFO_1A;
pub const PPORT_INFO_1A = [*c]struct__PORT_INFO_1A;
pub const LPPORT_INFO_1A = [*c]struct__PORT_INFO_1A;
pub const struct__PORT_INFO_1W = extern struct {
    pName: LPWSTR,
};
pub const PORT_INFO_1W = struct__PORT_INFO_1W;
pub const PPORT_INFO_1W = [*c]struct__PORT_INFO_1W;
pub const LPPORT_INFO_1W = [*c]struct__PORT_INFO_1W;
pub const PORT_INFO_1 = PORT_INFO_1A;
pub const PPORT_INFO_1 = PPORT_INFO_1A;
pub const LPPORT_INFO_1 = LPPORT_INFO_1A;
pub const struct__PORT_INFO_2A = extern struct {
    pPortName: LPSTR,
    pMonitorName: LPSTR,
    pDescription: LPSTR,
    fPortType: DWORD,
    Reserved: DWORD,
};
pub const PORT_INFO_2A = struct__PORT_INFO_2A;
pub const PPORT_INFO_2A = [*c]struct__PORT_INFO_2A;
pub const LPPORT_INFO_2A = [*c]struct__PORT_INFO_2A;
pub const struct__PORT_INFO_2W = extern struct {
    pPortName: LPWSTR,
    pMonitorName: LPWSTR,
    pDescription: LPWSTR,
    fPortType: DWORD,
    Reserved: DWORD,
};
pub const PORT_INFO_2W = struct__PORT_INFO_2W;
pub const PPORT_INFO_2W = [*c]struct__PORT_INFO_2W;
pub const LPPORT_INFO_2W = [*c]struct__PORT_INFO_2W;
pub const PORT_INFO_2 = PORT_INFO_2A;
pub const PPORT_INFO_2 = PPORT_INFO_2A;
pub const LPPORT_INFO_2 = LPPORT_INFO_2A;
pub const struct__PORT_INFO_3A = extern struct {
    dwStatus: DWORD,
    pszStatus: LPSTR,
    dwSeverity: DWORD,
};
pub const PORT_INFO_3A = struct__PORT_INFO_3A;
pub const PPORT_INFO_3A = [*c]struct__PORT_INFO_3A;
pub const LPPORT_INFO_3A = [*c]struct__PORT_INFO_3A;
pub const struct__PORT_INFO_3W = extern struct {
    dwStatus: DWORD,
    pszStatus: LPWSTR,
    dwSeverity: DWORD,
};
pub const PORT_INFO_3W = struct__PORT_INFO_3W;
pub const PPORT_INFO_3W = [*c]struct__PORT_INFO_3W;
pub const LPPORT_INFO_3W = [*c]struct__PORT_INFO_3W;
pub const PORT_INFO_3 = PORT_INFO_3A;
pub const PPORT_INFO_3 = PPORT_INFO_3A;
pub const LPPORT_INFO_3 = LPPORT_INFO_3A;
pub const struct__MONITOR_INFO_1A = extern struct {
    pName: LPSTR,
};
pub const MONITOR_INFO_1A = struct__MONITOR_INFO_1A;
pub const PMONITOR_INFO_1A = [*c]struct__MONITOR_INFO_1A;
pub const LPMONITOR_INFO_1A = [*c]struct__MONITOR_INFO_1A;
pub const struct__MONITOR_INFO_1W = extern struct {
    pName: LPWSTR,
};
pub const MONITOR_INFO_1W = struct__MONITOR_INFO_1W;
pub const PMONITOR_INFO_1W = [*c]struct__MONITOR_INFO_1W;
pub const LPMONITOR_INFO_1W = [*c]struct__MONITOR_INFO_1W;
pub const MONITOR_INFO_1 = MONITOR_INFO_1A;
pub const PMONITOR_INFO_1 = PMONITOR_INFO_1A;
pub const LPMONITOR_INFO_1 = LPMONITOR_INFO_1A;
pub const struct__MONITOR_INFO_2A = extern struct {
    pName: LPSTR,
    pEnvironment: LPSTR,
    pDLLName: LPSTR,
};
pub const MONITOR_INFO_2A = struct__MONITOR_INFO_2A;
pub const PMONITOR_INFO_2A = [*c]struct__MONITOR_INFO_2A;
pub const LPMONITOR_INFO_2A = [*c]struct__MONITOR_INFO_2A;
pub const struct__MONITOR_INFO_2W = extern struct {
    pName: LPWSTR,
    pEnvironment: LPWSTR,
    pDLLName: LPWSTR,
};
pub const MONITOR_INFO_2W = struct__MONITOR_INFO_2W;
pub const PMONITOR_INFO_2W = [*c]struct__MONITOR_INFO_2W;
pub const LPMONITOR_INFO_2W = [*c]struct__MONITOR_INFO_2W;
pub const MONITOR_INFO_2 = MONITOR_INFO_2A;
pub const PMONITOR_INFO_2 = PMONITOR_INFO_2A;
pub const LPMONITOR_INFO_2 = LPMONITOR_INFO_2A;
pub const struct__DATATYPES_INFO_1A = extern struct {
    pName: LPSTR,
};
pub const DATATYPES_INFO_1A = struct__DATATYPES_INFO_1A;
pub const PDATATYPES_INFO_1A = [*c]struct__DATATYPES_INFO_1A;
pub const LPDATATYPES_INFO_1A = [*c]struct__DATATYPES_INFO_1A;
pub const struct__DATATYPES_INFO_1W = extern struct {
    pName: LPWSTR,
};
pub const DATATYPES_INFO_1W = struct__DATATYPES_INFO_1W;
pub const PDATATYPES_INFO_1W = [*c]struct__DATATYPES_INFO_1W;
pub const LPDATATYPES_INFO_1W = [*c]struct__DATATYPES_INFO_1W;
pub const DATATYPES_INFO_1 = DATATYPES_INFO_1A;
pub const PDATATYPES_INFO_1 = PDATATYPES_INFO_1A;
pub const LPDATATYPES_INFO_1 = LPDATATYPES_INFO_1A;
pub const struct__PRINTER_DEFAULTSA = extern struct {
    pDatatype: LPSTR,
    pDevMode: LPDEVMODEA,
    DesiredAccess: ACCESS_MASK,
};
pub const PRINTER_DEFAULTSA = struct__PRINTER_DEFAULTSA;
pub const PPRINTER_DEFAULTSA = [*c]struct__PRINTER_DEFAULTSA;
pub const LPPRINTER_DEFAULTSA = [*c]struct__PRINTER_DEFAULTSA;
pub const struct__PRINTER_DEFAULTSW = extern struct {
    pDatatype: LPWSTR,
    pDevMode: LPDEVMODEW,
    DesiredAccess: ACCESS_MASK,
};
pub const PRINTER_DEFAULTSW = struct__PRINTER_DEFAULTSW;
pub const PPRINTER_DEFAULTSW = [*c]struct__PRINTER_DEFAULTSW;
pub const LPPRINTER_DEFAULTSW = [*c]struct__PRINTER_DEFAULTSW;
pub const PRINTER_DEFAULTS = PRINTER_DEFAULTSA;
pub const PPRINTER_DEFAULTS = PPRINTER_DEFAULTSA;
pub const LPPRINTER_DEFAULTS = LPPRINTER_DEFAULTSA;
pub const struct__PRINTER_ENUM_VALUESA = extern struct {
    pValueName: LPSTR,
    cbValueName: DWORD,
    dwType: DWORD,
    pData: LPBYTE,
    cbData: DWORD,
};
pub const PRINTER_ENUM_VALUESA = struct__PRINTER_ENUM_VALUESA;
pub const PPRINTER_ENUM_VALUESA = [*c]struct__PRINTER_ENUM_VALUESA;
pub const LPPRINTER_ENUM_VALUESA = [*c]struct__PRINTER_ENUM_VALUESA;
pub const struct__PRINTER_ENUM_VALUESW = extern struct {
    pValueName: LPWSTR,
    cbValueName: DWORD,
    dwType: DWORD,
    pData: LPBYTE,
    cbData: DWORD,
};
pub const PRINTER_ENUM_VALUESW = struct__PRINTER_ENUM_VALUESW;
pub const PPRINTER_ENUM_VALUESW = [*c]struct__PRINTER_ENUM_VALUESW;
pub const LPPRINTER_ENUM_VALUESW = [*c]struct__PRINTER_ENUM_VALUESW;
pub const PRINTER_ENUM_VALUES = PRINTER_ENUM_VALUESA;
pub const PPRINTER_ENUM_VALUES = PPRINTER_ENUM_VALUESA;
pub const LPPRINTER_ENUM_VALUES = LPPRINTER_ENUM_VALUESA;
pub extern "winspool" fn EnumPrintersA(Flags: DWORD, Name: LPSTR, Level: DWORD, pPrinterEnum: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD, pcReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn EnumPrintersW(Flags: DWORD, Name: LPWSTR, Level: DWORD, pPrinterEnum: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD, pcReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn GetSpoolFileHandle(hPrinter: HANDLE) callconv(.Stdcall) HANDLE;
pub extern "winspool" fn CommitSpoolData(hPrinter: HANDLE, hSpoolFile: HANDLE, cbCommit: DWORD) callconv(.Stdcall) HANDLE;
pub extern "winspool" fn CloseSpoolFileHandle(hPrinter: HANDLE, hSpoolFile: HANDLE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn OpenPrinterA(pPrinterName: LPSTR, phPrinter: LPHANDLE, pDefault: LPPRINTER_DEFAULTSA) callconv(.Stdcall) BOOL;
pub extern "winspool" fn OpenPrinterW(pPrinterName: LPWSTR, phPrinter: LPHANDLE, pDefault: LPPRINTER_DEFAULTSW) callconv(.Stdcall) BOOL;
pub extern "winspool" fn ResetPrinterA(hPrinter: HANDLE, pDefault: LPPRINTER_DEFAULTSA) callconv(.Stdcall) BOOL;
pub extern "winspool" fn ResetPrinterW(hPrinter: HANDLE, pDefault: LPPRINTER_DEFAULTSW) callconv(.Stdcall) BOOL;
pub extern "winspool" fn SetJobA(hPrinter: HANDLE, JobId: DWORD, Level: DWORD, pJob: LPBYTE, Command: DWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn SetJobW(hPrinter: HANDLE, JobId: DWORD, Level: DWORD, pJob: LPBYTE, Command: DWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn GetJobA(hPrinter: HANDLE, JobId: DWORD, Level: DWORD, pJob: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn GetJobW(hPrinter: HANDLE, JobId: DWORD, Level: DWORD, pJob: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn EnumJobsA(hPrinter: HANDLE, FirstJob: DWORD, NoJobs: DWORD, Level: DWORD, pJob: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD, pcReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn EnumJobsW(hPrinter: HANDLE, FirstJob: DWORD, NoJobs: DWORD, Level: DWORD, pJob: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD, pcReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddPrinterA(pName: LPSTR, Level: DWORD, pPrinter: LPBYTE) callconv(.Stdcall) HANDLE;
pub extern "winspool" fn AddPrinterW(pName: LPWSTR, Level: DWORD, pPrinter: LPBYTE) callconv(.Stdcall) HANDLE;
pub extern "winspool" fn DeletePrinter(hPrinter: HANDLE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn SetPrinterA(hPrinter: HANDLE, Level: DWORD, pPrinter: LPBYTE, Command: DWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn SetPrinterW(hPrinter: HANDLE, Level: DWORD, pPrinter: LPBYTE, Command: DWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn GetPrinterA(hPrinter: HANDLE, Level: DWORD, pPrinter: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn GetPrinterW(hPrinter: HANDLE, Level: DWORD, pPrinter: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddPrinterDriverA(pName: LPSTR, Level: DWORD, pDriverInfo: LPBYTE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddPrinterDriverW(pName: LPWSTR, Level: DWORD, pDriverInfo: LPBYTE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddPrinterDriverExA(pName: LPSTR, Level: DWORD, lpbDriverInfo: PBYTE, dwFileCopyFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddPrinterDriverExW(pName: LPWSTR, Level: DWORD, lpbDriverInfo: PBYTE, dwFileCopyFlags: DWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn EnumPrinterDriversA(pName: LPSTR, pEnvironment: LPSTR, Level: DWORD, pDriverInfo: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD, pcReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn EnumPrinterDriversW(pName: LPWSTR, pEnvironment: LPWSTR, Level: DWORD, pDriverInfo: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD, pcReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn GetPrinterDriverA(hPrinter: HANDLE, pEnvironment: LPSTR, Level: DWORD, pDriverInfo: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn GetPrinterDriverW(hPrinter: HANDLE, pEnvironment: LPWSTR, Level: DWORD, pDriverInfo: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn GetPrinterDriverDirectoryA(pName: LPSTR, pEnvironment: LPSTR, Level: DWORD, pDriverDirectory: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn GetPrinterDriverDirectoryW(pName: LPWSTR, pEnvironment: LPWSTR, Level: DWORD, pDriverDirectory: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn DeletePrinterDriverA(pName: LPSTR, pEnvironment: LPSTR, pDriverName: LPSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn DeletePrinterDriverW(pName: LPWSTR, pEnvironment: LPWSTR, pDriverName: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn DeletePrinterDriverExA(pName: LPSTR, pEnvironment: LPSTR, pDriverName: LPSTR, dwDeleteFlag: DWORD, dwVersionFlag: DWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn DeletePrinterDriverExW(pName: LPWSTR, pEnvironment: LPWSTR, pDriverName: LPWSTR, dwDeleteFlag: DWORD, dwVersionFlag: DWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddPrintProcessorA(pName: LPSTR, pEnvironment: LPSTR, pPathName: LPSTR, pPrintProcessorName: LPSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddPrintProcessorW(pName: LPWSTR, pEnvironment: LPWSTR, pPathName: LPWSTR, pPrintProcessorName: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn EnumPrintProcessorsA(pName: LPSTR, pEnvironment: LPSTR, Level: DWORD, pPrintProcessorInfo: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD, pcReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn EnumPrintProcessorsW(pName: LPWSTR, pEnvironment: LPWSTR, Level: DWORD, pPrintProcessorInfo: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD, pcReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn GetPrintProcessorDirectoryA(pName: LPSTR, pEnvironment: LPSTR, Level: DWORD, pPrintProcessorInfo: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn GetPrintProcessorDirectoryW(pName: LPWSTR, pEnvironment: LPWSTR, Level: DWORD, pPrintProcessorInfo: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn EnumPrintProcessorDatatypesA(pName: LPSTR, pPrintProcessorName: LPSTR, Level: DWORD, pDatatypes: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD, pcReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn EnumPrintProcessorDatatypesW(pName: LPWSTR, pPrintProcessorName: LPWSTR, Level: DWORD, pDatatypes: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD, pcReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn DeletePrintProcessorA(pName: LPSTR, pEnvironment: LPSTR, pPrintProcessorName: LPSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn DeletePrintProcessorW(pName: LPWSTR, pEnvironment: LPWSTR, pPrintProcessorName: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn StartDocPrinterA(hPrinter: HANDLE, Level: DWORD, pDocInfo: LPBYTE) callconv(.Stdcall) DWORD;
pub extern "winspool" fn StartDocPrinterW(hPrinter: HANDLE, Level: DWORD, pDocInfo: LPBYTE) callconv(.Stdcall) DWORD;
pub extern "winspool" fn StartPagePrinter(hPrinter: HANDLE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn WritePrinter(hPrinter: HANDLE, pBuf: LPVOID, cbBuf: DWORD, pcWritten: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn FlushPrinter(hPrinter: HANDLE, pBuf: LPVOID, cbBuf: DWORD, pcWritten: LPDWORD, cSleep: DWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn EndPagePrinter(hPrinter: HANDLE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AbortPrinter(hPrinter: HANDLE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn ReadPrinter(hPrinter: HANDLE, pBuf: LPVOID, cbBuf: DWORD, pNoBytesRead: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn EndDocPrinter(hPrinter: HANDLE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddJobA(hPrinter: HANDLE, Level: DWORD, pData: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddJobW(hPrinter: HANDLE, Level: DWORD, pData: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn ScheduleJob(hPrinter: HANDLE, JobId: DWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn PrinterProperties(hWnd: HWND, hPrinter: HANDLE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn DocumentPropertiesA(hWnd: HWND, hPrinter: HANDLE, pDeviceName: LPSTR, pDevModeOutput: PDEVMODEA, pDevModeInput: PDEVMODEA, fMode: DWORD) callconv(.Stdcall) LONG;
pub extern "winspool" fn DocumentPropertiesW(hWnd: HWND, hPrinter: HANDLE, pDeviceName: LPWSTR, pDevModeOutput: PDEVMODEW, pDevModeInput: PDEVMODEW, fMode: DWORD) callconv(.Stdcall) LONG;
pub extern "winspool" fn AdvancedDocumentPropertiesA(hWnd: HWND, hPrinter: HANDLE, pDeviceName: LPSTR, pDevModeOutput: PDEVMODEA, pDevModeInput: PDEVMODEA) callconv(.Stdcall) LONG;
pub extern "winspool" fn AdvancedDocumentPropertiesW(hWnd: HWND, hPrinter: HANDLE, pDeviceName: LPWSTR, pDevModeOutput: PDEVMODEW, pDevModeInput: PDEVMODEW) callconv(.Stdcall) LONG;
pub extern "winspool" fn ExtDeviceMode(hWnd: HWND, hInst: HANDLE, pDevModeOutput: LPDEVMODEA, pDeviceName: LPSTR, pPort: LPSTR, pDevModeInput: LPDEVMODEA, pProfile: LPSTR, fMode: DWORD) callconv(.Stdcall) LONG;
pub extern "winspool" fn GetPrinterDataA(hPrinter: HANDLE, pValueName: LPSTR, pType: LPDWORD, pData: LPBYTE, nSize: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "winspool" fn GetPrinterDataW(hPrinter: HANDLE, pValueName: LPWSTR, pType: LPDWORD, pData: LPBYTE, nSize: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "winspool" fn GetPrinterDataExA(hPrinter: HANDLE, pKeyName: LPCSTR, pValueName: LPCSTR, pType: LPDWORD, pData: LPBYTE, nSize: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "winspool" fn GetPrinterDataExW(hPrinter: HANDLE, pKeyName: LPCWSTR, pValueName: LPCWSTR, pType: LPDWORD, pData: LPBYTE, nSize: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "winspool" fn EnumPrinterDataA(hPrinter: HANDLE, dwIndex: DWORD, pValueName: LPSTR, cbValueName: DWORD, pcbValueName: LPDWORD, pType: LPDWORD, pData: LPBYTE, cbData: DWORD, pcbData: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "winspool" fn EnumPrinterDataW(hPrinter: HANDLE, dwIndex: DWORD, pValueName: LPWSTR, cbValueName: DWORD, pcbValueName: LPDWORD, pType: LPDWORD, pData: LPBYTE, cbData: DWORD, pcbData: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "winspool" fn EnumPrinterDataExA(hPrinter: HANDLE, pKeyName: LPCSTR, pEnumValues: LPBYTE, cbEnumValues: DWORD, pcbEnumValues: LPDWORD, pnEnumValues: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "winspool" fn EnumPrinterDataExW(hPrinter: HANDLE, pKeyName: LPCWSTR, pEnumValues: LPBYTE, cbEnumValues: DWORD, pcbEnumValues: LPDWORD, pnEnumValues: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "winspool" fn EnumPrinterKeyA(hPrinter: HANDLE, pKeyName: LPCSTR, pSubkey: LPSTR, cbSubkey: DWORD, pcbSubkey: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "winspool" fn EnumPrinterKeyW(hPrinter: HANDLE, pKeyName: LPCWSTR, pSubkey: LPWSTR, cbSubkey: DWORD, pcbSubkey: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "winspool" fn SetPrinterDataA(hPrinter: HANDLE, pValueName: LPSTR, Type: DWORD, pData: LPBYTE, cbData: DWORD) callconv(.Stdcall) DWORD;
pub extern "winspool" fn SetPrinterDataW(hPrinter: HANDLE, pValueName: LPWSTR, Type: DWORD, pData: LPBYTE, cbData: DWORD) callconv(.Stdcall) DWORD;
pub extern "winspool" fn SetPrinterDataExA(hPrinter: HANDLE, pKeyName: LPCSTR, pValueName: LPCSTR, Type: DWORD, pData: LPBYTE, cbData: DWORD) callconv(.Stdcall) DWORD;
pub extern "winspool" fn SetPrinterDataExW(hPrinter: HANDLE, pKeyName: LPCWSTR, pValueName: LPCWSTR, Type: DWORD, pData: LPBYTE, cbData: DWORD) callconv(.Stdcall) DWORD;
pub extern "winspool" fn DeletePrinterDataA(hPrinter: HANDLE, pValueName: LPSTR) callconv(.Stdcall) DWORD;
pub extern "winspool" fn DeletePrinterDataW(hPrinter: HANDLE, pValueName: LPWSTR) callconv(.Stdcall) DWORD;
pub extern "winspool" fn DeletePrinterDataExA(hPrinter: HANDLE, pKeyName: LPCSTR, pValueName: LPCSTR) callconv(.Stdcall) DWORD;
pub extern "winspool" fn DeletePrinterDataExW(hPrinter: HANDLE, pKeyName: LPCWSTR, pValueName: LPCWSTR) callconv(.Stdcall) DWORD;
pub extern "winspool" fn DeletePrinterKeyA(hPrinter: HANDLE, pKeyName: LPCSTR) callconv(.Stdcall) DWORD;
pub extern "winspool" fn DeletePrinterKeyW(hPrinter: HANDLE, pKeyName: LPCWSTR) callconv(.Stdcall) DWORD;
pub const struct__PRINTER_NOTIFY_OPTIONS_TYPE = extern struct {
    Type: WORD,
    Reserved0: WORD,
    Reserved1: DWORD,
    Reserved2: DWORD,
    Count: DWORD,
    pFields: PWORD,
};
pub const PRINTER_NOTIFY_OPTIONS_TYPE = struct__PRINTER_NOTIFY_OPTIONS_TYPE;
pub const PPRINTER_NOTIFY_OPTIONS_TYPE = [*c]struct__PRINTER_NOTIFY_OPTIONS_TYPE;
pub const LPPRINTER_NOTIFY_OPTIONS_TYPE = [*c]struct__PRINTER_NOTIFY_OPTIONS_TYPE;
pub const struct__PRINTER_NOTIFY_OPTIONS = extern struct {
    Version: DWORD,
    Flags: DWORD,
    Count: DWORD,
    pTypes: PPRINTER_NOTIFY_OPTIONS_TYPE,
};
pub const PRINTER_NOTIFY_OPTIONS = struct__PRINTER_NOTIFY_OPTIONS;
pub const PPRINTER_NOTIFY_OPTIONS = [*c]struct__PRINTER_NOTIFY_OPTIONS;
pub const LPPRINTER_NOTIFY_OPTIONS = [*c]struct__PRINTER_NOTIFY_OPTIONS;
pub const struct__PRINTER_NOTIFY_INFO_DATA = extern struct {
    Type: WORD,
    Field: WORD,
    Reserved: DWORD,
    Id: DWORD,
    NotifyData: extern union {
        adwData: [2]DWORD,
        Data: extern struct {
            cbBuf: DWORD,
            pBuf: LPVOID,
        },
    },
};
pub const PRINTER_NOTIFY_INFO_DATA = struct__PRINTER_NOTIFY_INFO_DATA;
pub const PPRINTER_NOTIFY_INFO_DATA = [*c]struct__PRINTER_NOTIFY_INFO_DATA;
pub const LPPRINTER_NOTIFY_INFO_DATA = [*c]struct__PRINTER_NOTIFY_INFO_DATA;
pub const struct__PRINTER_NOTIFY_INFO = extern struct {
    Version: DWORD,
    Flags: DWORD,
    Count: DWORD,
    aData: [1]PRINTER_NOTIFY_INFO_DATA,
};
pub const PRINTER_NOTIFY_INFO = struct__PRINTER_NOTIFY_INFO;
pub const PPRINTER_NOTIFY_INFO = [*c]struct__PRINTER_NOTIFY_INFO;
pub const LPPRINTER_NOTIFY_INFO = [*c]struct__PRINTER_NOTIFY_INFO;
pub const struct__BINARY_CONTAINER = extern struct {
    cbBuf: DWORD,
    pData: LPBYTE,
};
pub const BINARY_CONTAINER = struct__BINARY_CONTAINER;
pub const PBINARY_CONTAINER = [*c]struct__BINARY_CONTAINER;
pub const struct__BIDI_DATA = extern struct {
    dwBidiType: DWORD,
    u: extern union {
        bData: BOOL,
        iData: LONG,
        sData: LPWSTR,
        fData: FLOAT,
        biData: BINARY_CONTAINER,
    },
};
pub const BIDI_DATA = struct__BIDI_DATA;
pub const PBIDI_DATA = [*c]struct__BIDI_DATA;
pub const LPBIDI_DATA = [*c]struct__BIDI_DATA;
pub const struct__BIDI_REQUEST_DATA = extern struct {
    dwReqNumber: DWORD,
    pSchema: LPWSTR,
    data: BIDI_DATA,
};
pub const BIDI_REQUEST_DATA = struct__BIDI_REQUEST_DATA;
pub const PBIDI_REQUEST_DATA = [*c]struct__BIDI_REQUEST_DATA;
pub const LPBIDI_REQUEST_DATA = [*c]struct__BIDI_REQUEST_DATA;
pub const struct__BIDI_REQUEST_CONTAINER = extern struct {
    Version: DWORD,
    Flags: DWORD,
    Count: DWORD,
    aData: [1]BIDI_REQUEST_DATA,
};
pub const BIDI_REQUEST_CONTAINER = struct__BIDI_REQUEST_CONTAINER;
pub const PBIDI_REQUEST_CONTAINER = [*c]struct__BIDI_REQUEST_CONTAINER;
pub const LPBIDI_REQUEST_CONTAINER = [*c]struct__BIDI_REQUEST_CONTAINER;
pub const struct__BIDI_RESPONSE_DATA = extern struct {
    dwResult: DWORD,
    dwReqNumber: DWORD,
    pSchema: LPWSTR,
    data: BIDI_DATA,
};
pub const BIDI_RESPONSE_DATA = struct__BIDI_RESPONSE_DATA;
pub const PBIDI_RESPONSE_DATA = [*c]struct__BIDI_RESPONSE_DATA;
pub const LPBIDI_RESPONSE_DATA = [*c]struct__BIDI_RESPONSE_DATA;
pub const struct__BIDI_RESPONSE_CONTAINER = extern struct {
    Version: DWORD,
    Flags: DWORD,
    Count: DWORD,
    aData: [1]BIDI_RESPONSE_DATA,
};
pub const BIDI_RESPONSE_CONTAINER = struct__BIDI_RESPONSE_CONTAINER;
pub const PBIDI_RESPONSE_CONTAINER = [*c]struct__BIDI_RESPONSE_CONTAINER;
pub const LPBIDI_RESPONSE_CONTAINER = [*c]struct__BIDI_RESPONSE_CONTAINER;
pub const BIDI_NULL = 0;
pub const BIDI_INT = 1;
pub const BIDI_FLOAT = 2;
pub const BIDI_BOOL = 3;
pub const BIDI_STRING = 4;
pub const BIDI_TEXT = 5;
pub const BIDI_ENUM = 6;
pub const BIDI_BLOB = 7;
pub const BIDI_TYPE = extern enum {
    BIDI_NULL = 0,
    BIDI_INT = 1,
    BIDI_FLOAT = 2,
    BIDI_BOOL = 3,
    BIDI_STRING = 4,
    BIDI_TEXT = 5,
    BIDI_ENUM = 6,
    BIDI_BLOB = 7,
};
pub extern "winspool" fn WaitForPrinterChange(hPrinter: HANDLE, Flags: DWORD) callconv(.Stdcall) DWORD;
pub extern "winspool" fn FindFirstPrinterChangeNotification(hPrinter: HANDLE, fdwFilter: DWORD, fdwOptions: DWORD, pPrinterNotifyOptions: PVOID) callconv(.Stdcall) HANDLE;
pub extern "winspool" fn FindNextPrinterChangeNotification(hChange: HANDLE, pdwChange: PDWORD, pvReserved: LPVOID, ppPrinterNotifyInfo: [*c]LPVOID) callconv(.Stdcall) BOOL;
pub extern "winspool" fn FreePrinterNotifyInfo(pPrinterNotifyInfo: PPRINTER_NOTIFY_INFO) callconv(.Stdcall) BOOL;
pub extern "winspool" fn FindClosePrinterChangeNotification(hChange: HANDLE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn PrinterMessageBoxA(hPrinter: HANDLE, Error: DWORD, hWnd: HWND, pText: LPSTR, pCaption: LPSTR, dwType: DWORD) callconv(.Stdcall) DWORD;
pub extern "winspool" fn PrinterMessageBoxW(hPrinter: HANDLE, Error: DWORD, hWnd: HWND, pText: LPWSTR, pCaption: LPWSTR, dwType: DWORD) callconv(.Stdcall) DWORD;
pub extern "winspool" fn ClosePrinter(hPrinter: HANDLE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddFormA(hPrinter: HANDLE, Level: DWORD, pForm: LPBYTE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddFormW(hPrinter: HANDLE, Level: DWORD, pForm: LPBYTE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn DeleteFormA(hPrinter: HANDLE, pFormName: LPSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn DeleteFormW(hPrinter: HANDLE, pFormName: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn GetFormA(hPrinter: HANDLE, pFormName: LPSTR, Level: DWORD, pForm: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn GetFormW(hPrinter: HANDLE, pFormName: LPWSTR, Level: DWORD, pForm: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn SetFormA(hPrinter: HANDLE, pFormName: LPSTR, Level: DWORD, pForm: LPBYTE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn SetFormW(hPrinter: HANDLE, pFormName: LPWSTR, Level: DWORD, pForm: LPBYTE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn EnumFormsA(hPrinter: HANDLE, Level: DWORD, pForm: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD, pcReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn EnumFormsW(hPrinter: HANDLE, Level: DWORD, pForm: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD, pcReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn EnumMonitorsA(pName: LPSTR, Level: DWORD, pMonitor: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD, pcReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn EnumMonitorsW(pName: LPWSTR, Level: DWORD, pMonitor: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD, pcReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddMonitorA(pName: LPSTR, Level: DWORD, pMonitors: LPBYTE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddMonitorW(pName: LPWSTR, Level: DWORD, pMonitors: LPBYTE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn DeleteMonitorA(pName: LPSTR, pEnvironment: LPSTR, pMonitorName: LPSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn DeleteMonitorW(pName: LPWSTR, pEnvironment: LPWSTR, pMonitorName: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn EnumPortsA(pName: LPSTR, Level: DWORD, pPort: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD, pcReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn EnumPortsW(pName: LPWSTR, Level: DWORD, pPort: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD, pcReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddPortA(pName: LPSTR, hWnd: HWND, pMonitorName: LPSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddPortW(pName: LPWSTR, hWnd: HWND, pMonitorName: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn ConfigurePortA(pName: LPSTR, hWnd: HWND, pPortName: LPSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn ConfigurePortW(pName: LPWSTR, hWnd: HWND, pPortName: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn DeletePortA(pName: LPSTR, hWnd: HWND, pPortName: LPSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn DeletePortW(pName: LPWSTR, hWnd: HWND, pPortName: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn XcvDataW(hXcv: HANDLE, pszDataName: PCWSTR, pInputData: PBYTE, cbInputData: DWORD, pOutputData: PBYTE, cbOutputData: DWORD, pcbOutputNeeded: PDWORD, pdwStatus: PDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn GetDefaultPrinterA(pszBuffer: LPSTR, pcchBuffer: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn GetDefaultPrinterW(pszBuffer: LPWSTR, pcchBuffer: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn SetDefaultPrinterA(pszPrinter: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn SetDefaultPrinterW(pszPrinter: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn SetPortA(pName: LPSTR, pPortName: LPSTR, dwLevel: DWORD, pPortInfo: LPBYTE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn SetPortW(pName: LPWSTR, pPortName: LPWSTR, dwLevel: DWORD, pPortInfo: LPBYTE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddPrinterConnectionA(pName: LPSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddPrinterConnectionW(pName: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn DeletePrinterConnectionA(pName: LPSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn DeletePrinterConnectionW(pName: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn ConnectToPrinterDlg(hwnd: HWND, Flags: DWORD) callconv(.Stdcall) HANDLE;
pub const struct__PROVIDOR_INFO_1A = extern struct {
    pName: LPSTR,
    pEnvironment: LPSTR,
    pDLLName: LPSTR,
};
pub const PROVIDOR_INFO_1A = struct__PROVIDOR_INFO_1A;
pub const PPROVIDOR_INFO_1A = [*c]struct__PROVIDOR_INFO_1A;
pub const LPPROVIDOR_INFO_1A = [*c]struct__PROVIDOR_INFO_1A;
pub const struct__PROVIDOR_INFO_1W = extern struct {
    pName: LPWSTR,
    pEnvironment: LPWSTR,
    pDLLName: LPWSTR,
};
pub const PROVIDOR_INFO_1W = struct__PROVIDOR_INFO_1W;
pub const PPROVIDOR_INFO_1W = [*c]struct__PROVIDOR_INFO_1W;
pub const LPPROVIDOR_INFO_1W = [*c]struct__PROVIDOR_INFO_1W;
pub const PROVIDOR_INFO_1 = PROVIDOR_INFO_1A;
pub const PPROVIDOR_INFO_1 = PPROVIDOR_INFO_1A;
pub const LPPROVIDOR_INFO_1 = LPPROVIDOR_INFO_1A;
pub const struct__PROVIDOR_INFO_2A = extern struct {
    pOrder: LPSTR,
};
pub const PROVIDOR_INFO_2A = struct__PROVIDOR_INFO_2A;
pub const PPROVIDOR_INFO_2A = [*c]struct__PROVIDOR_INFO_2A;
pub const LPPROVIDOR_INFO_2A = [*c]struct__PROVIDOR_INFO_2A;
pub const struct__PROVIDOR_INFO_2W = extern struct {
    pOrder: LPWSTR,
};
pub const PROVIDOR_INFO_2W = struct__PROVIDOR_INFO_2W;
pub const PPROVIDOR_INFO_2W = [*c]struct__PROVIDOR_INFO_2W;
pub const LPPROVIDOR_INFO_2W = [*c]struct__PROVIDOR_INFO_2W;
pub const PROVIDOR_INFO_2 = PROVIDOR_INFO_2A;
pub const PPROVIDOR_INFO_2 = PPROVIDOR_INFO_2A;
pub const LPPROVIDOR_INFO_2 = LPPROVIDOR_INFO_2A;
pub extern "winspool" fn AddPrintProvidorA(pName: LPSTR, Level: DWORD, pProvidorInfo: LPBYTE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddPrintProvidorW(pName: LPWSTR, Level: DWORD, pProvidorInfo: LPBYTE) callconv(.Stdcall) BOOL;
pub extern "winspool" fn DeletePrintProvidorA(pName: LPSTR, pEnvironment: LPSTR, pPrintProvidorName: LPSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn DeletePrintProvidorW(pName: LPWSTR, pEnvironment: LPWSTR, pPrintProvidorName: LPWSTR) callconv(.Stdcall) BOOL;
pub extern "winspool" fn IsValidDevmodeA(pDevmode: PDEVMODEA, DevmodeSize: usize) callconv(.Stdcall) BOOL;
pub extern "winspool" fn IsValidDevmodeW(pDevmode: PDEVMODEW, DevmodeSize: usize) callconv(.Stdcall) BOOL;
pub const PRINTER_OPTION_NO_CACHE = enum__PRINTER_OPTION_FLAGS.PRINTER_OPTION_NO_CACHE;
pub const PRINTER_OPTION_CACHE = enum__PRINTER_OPTION_FLAGS.PRINTER_OPTION_CACHE;
pub const PRINTER_OPTION_CLIENT_CHANGE = enum__PRINTER_OPTION_FLAGS.PRINTER_OPTION_CLIENT_CHANGE;
pub const PRINTER_OPTION_NO_CLIENT_DATA = enum__PRINTER_OPTION_FLAGS.PRINTER_OPTION_NO_CLIENT_DATA;
pub const enum__PRINTER_OPTION_FLAGS = extern enum {
    PRINTER_OPTION_NO_CACHE = 1,
    PRINTER_OPTION_CACHE = 2,
    PRINTER_OPTION_CLIENT_CHANGE = 4,
    PRINTER_OPTION_NO_CLIENT_DATA = 8,
};
pub const PRINTER_OPTION_FLAGS = enum__PRINTER_OPTION_FLAGS;
pub const struct__PRINTER_OPTIONSA = extern struct {
    cbSize: UINT,
    dwFlags: DWORD,
};
pub const PRINTER_OPTIONSA = struct__PRINTER_OPTIONSA;
pub const PPRINTER_OPTIONSA = [*c]struct__PRINTER_OPTIONSA;
pub const LPPRINTER_OPTIONSA = [*c]struct__PRINTER_OPTIONSA;
pub const struct__PRINTER_OPTIONSW = extern struct {
    cbSize: UINT,
    dwFlags: DWORD,
};
pub const PRINTER_OPTIONSW = struct__PRINTER_OPTIONSW;
pub const PPRINTER_OPTIONSW = [*c]struct__PRINTER_OPTIONSW;
pub const LPPRINTER_OPTIONSW = [*c]struct__PRINTER_OPTIONSW;
pub const PRINTER_OPTIONS = PRINTER_OPTIONSA;
pub const PPRINTER_OPTIONS = PPRINTER_OPTIONSA;
pub const LPPRINTER_OPTIONS = LPPRINTER_OPTIONSA;
pub extern "winspool" fn OpenPrinter2A(pPrinterName: LPCSTR, phPrinter: LPHANDLE, pDefault: PPRINTER_DEFAULTSA, pOptions: PPRINTER_OPTIONSA) callconv(.Stdcall) BOOL;
pub extern "winspool" fn OpenPrinter2W(pPrinterName: LPCWSTR, phPrinter: LPHANDLE, pDefault: PPRINTER_DEFAULTSW, pOptions: PPRINTER_OPTIONSW) callconv(.Stdcall) BOOL;
pub const struct__PRINTER_CONNECTION_INFO_1A = extern struct {
    dwFlags: DWORD,
    pszDriverName: LPSTR,
};
pub const PRINTER_CONNECTION_INFO_1A = struct__PRINTER_CONNECTION_INFO_1A;
pub const PPRINTER_CONNECTION_INFO_1A = [*c]struct__PRINTER_CONNECTION_INFO_1A;
pub const struct__PRINTER_CONNECTION_INFO_1W = extern struct {
    dwFlags: DWORD,
    pszDriverName: LPWSTR,
};
pub const PRINTER_CONNECTION_INFO_1W = struct__PRINTER_CONNECTION_INFO_1W;
pub const PPRINTER_CONNECTION_INFO_1W = [*c]struct__PRINTER_CONNECTION_INFO_1W;
pub const PRINTER_CONNECTION_INFO_1 = PRINTER_CONNECTION_INFO_1A;
pub const PPRINTER_CONNECTION_INFO_1 = PPRINTER_CONNECTION_INFO_1A;
pub extern "winspool" fn AddPrinterConnection2A(hWnd: HWND, pszName: LPCSTR, dwLevel: DWORD, pConnectionInfo: PVOID) callconv(.Stdcall) BOOL;
pub extern "winspool" fn AddPrinterConnection2W(hWnd: HWND, pszName: LPCWSTR, dwLevel: DWORD, pConnectionInfo: PVOID) callconv(.Stdcall) BOOL;
pub extern "winspool" fn InstallPrinterDriverFromPackageA(pszServer: LPCSTR, pszInfPath: LPCSTR, pszDriverName: LPCSTR, pszEnvironment: LPCSTR, dwFlags: DWORD) callconv(.Stdcall) HRESULT;
pub extern "winspool" fn InstallPrinterDriverFromPackageW(pszServer: LPCWSTR, pszInfPath: LPCWSTR, pszDriverName: LPCWSTR, pszEnvironment: LPCWSTR, dwFlags: DWORD) callconv(.Stdcall) HRESULT;
pub extern "winspool" fn UploadPrinterDriverPackageA(pszServer: LPCSTR, pszInfPath: LPCSTR, pszEnvironment: LPCSTR, dwFlags: DWORD, hwnd: HWND, pszDestInfPath: LPSTR, pcchDestInfPath: PULONG) callconv(.Stdcall) HRESULT;
pub extern "winspool" fn UploadPrinterDriverPackageW(pszServer: LPCWSTR, pszInfPath: LPCWSTR, pszEnvironment: LPCWSTR, dwFlags: DWORD, hwnd: HWND, pszDestInfPath: LPWSTR, pcchDestInfPath: PULONG) callconv(.Stdcall) HRESULT;
pub const struct__CORE_PRINTER_DRIVERA = extern struct {
    CoreDriverGUID: GUID,
    ftDriverDate: FILETIME,
    dwlDriverVersion: DWORDLONG,
    szPackageID: [260]CHAR,
};
pub const CORE_PRINTER_DRIVERA = struct__CORE_PRINTER_DRIVERA;
pub const PCORE_PRINTER_DRIVERA = [*c]struct__CORE_PRINTER_DRIVERA;
pub const struct__CORE_PRINTER_DRIVERW = extern struct {
    CoreDriverGUID: GUID,
    ftDriverDate: FILETIME,
    dwlDriverVersion: DWORDLONG,
    szPackageID: [260]WCHAR,
};
pub const CORE_PRINTER_DRIVERW = struct__CORE_PRINTER_DRIVERW;
pub const PCORE_PRINTER_DRIVERW = [*c]struct__CORE_PRINTER_DRIVERW;
pub const CORE_PRINTER_DRIVER = CORE_PRINTER_DRIVERA;
pub const PCORE_PRINTER_DRIVER = PCORE_PRINTER_DRIVERA;
pub extern "winspool" fn GetCorePrinterDriversA(pszServer: LPCSTR, pszEnvironment: LPCSTR, pszzCoreDriverDependencies: LPCSTR, cCorePrinterDrivers: DWORD, pCorePrinterDrivers: PCORE_PRINTER_DRIVERA) callconv(.Stdcall) HRESULT;
pub extern "winspool" fn GetCorePrinterDriversW(pszServer: LPCWSTR, pszEnvironment: LPCWSTR, pszzCoreDriverDependencies: LPCWSTR, cCorePrinterDrivers: DWORD, pCorePrinterDrivers: PCORE_PRINTER_DRIVERW) callconv(.Stdcall) HRESULT;
pub extern "winspool" fn CorePrinterDriverInstalledA(pszServer: LPCSTR, pszEnvironment: LPCSTR, CoreDriverGUID: GUID, ftDriverDate: FILETIME, dwlDriverVersion: DWORDLONG, pbDriverInstalled: [*c]BOOL) callconv(.Stdcall) HRESULT;
pub extern "winspool" fn CorePrinterDriverInstalledW(pszServer: LPCWSTR, pszEnvironment: LPCWSTR, CoreDriverGUID: GUID, ftDriverDate: FILETIME, dwlDriverVersion: DWORDLONG, pbDriverInstalled: [*c]BOOL) callconv(.Stdcall) HRESULT;
pub extern "winspool" fn GetPrinterDriverPackagePathA(pszServer: LPCSTR, pszEnvironment: LPCSTR, pszLanguage: LPCSTR, pszPackageID: LPCSTR, pszDriverPackageCab: LPSTR, cchDriverPackageCab: DWORD, pcchRequiredSize: LPDWORD) callconv(.Stdcall) HRESULT;
pub extern "winspool" fn GetPrinterDriverPackagePathW(pszServer: LPCWSTR, pszEnvironment: LPCWSTR, pszLanguage: LPCWSTR, pszPackageID: LPCWSTR, pszDriverPackageCab: LPWSTR, cchDriverPackageCab: DWORD, pcchRequiredSize: LPDWORD) callconv(.Stdcall) HRESULT;
pub extern "winspool" fn DeletePrinterDriverPackageA(pszServer: LPCSTR, pszInfPath: LPCSTR, pszEnvironment: LPCSTR) callconv(.Stdcall) HRESULT;
pub extern "winspool" fn DeletePrinterDriverPackageW(pszServer: LPCWSTR, pszInfPath: LPCWSTR, pszEnvironment: LPCWSTR) callconv(.Stdcall) HRESULT;
pub const kPropertyTypeString = 1;
pub const kPropertyTypeInt32 = 2;
pub const kPropertyTypeInt64 = 3;
pub const kPropertyTypeByte = 4;
pub const kPropertyTypeTime = 5;
pub const kPropertyTypeDevMode = 6;
pub const kPropertyTypeSD = 7;
pub const kPropertyTypeNotificationReply = 8;
pub const kPropertyTypeNotificationOptions = 9;
pub const kPropertyTypeBuffer = 10;
pub const EPrintPropertyType = extern enum {
    kPropertyTypeString = 1,
    kPropertyTypeInt32 = 2,
    kPropertyTypeInt64 = 3,
    kPropertyTypeByte = 4,
    kPropertyTypeTime = 5,
    kPropertyTypeDevMode = 6,
    kPropertyTypeSD = 7,
    kPropertyTypeNotificationReply = 8,
    kPropertyTypeNotificationOptions = 9,
    kPropertyTypeBuffer = 10,
};
pub const kAddingDocumentSequence = 0;
pub const kDocumentSequenceAdded = 1;
pub const kAddingFixedDocument = 2;
pub const kFixedDocumentAdded = 3;
pub const kAddingFixedPage = 4;
pub const kFixedPageAdded = 5;
pub const kResourceAdded = 6;
pub const kFontAdded = 7;
pub const kImageAdded = 8;
pub const kXpsDocumentCommitted = 9;
pub const EPrintXPSJobProgress = extern enum {
    kAddingDocumentSequence = 0,
    kDocumentSequenceAdded = 1,
    kAddingFixedDocument = 2,
    kFixedDocumentAdded = 3,
    kAddingFixedPage = 4,
    kFixedPageAdded = 5,
    kResourceAdded = 6,
    kFontAdded = 7,
    kImageAdded = 8,
    kXpsDocumentCommitted = 9,
};
pub const kJobProduction = 1;
pub const kJobConsumption = 2;
pub const EPrintXPSJobOperation = extern enum {
    kJobProduction = 1,
    kJobConsumption = 2,
};
pub const PrintPropertyValue = extern struct {
    ePropertyType: EPrintPropertyType,
    value: extern union {
        propertyByte: BYTE,
        propertyString: PWSTR,
        propertyInt32: LONG,
        propertyInt64: LONGLONG,
        propertyBlob: extern struct {
            cbBuf: DWORD,
            pBuf: LPVOID,
        },
    },
};
pub const PrintNamedProperty = extern struct {
    propertyName: [*c]WCHAR,
    propertyValue: PrintPropertyValue,
};
pub const PrintPropertiesCollection = extern struct {
    numberOfProperties: ULONG,
    propertiesCollection: [*c]PrintNamedProperty,
};
pub extern "winspool" fn ReportJobProcessingProgress(printerHandle: HANDLE, jobId: ULONG, jobOperation: EPrintXPSJobOperation, jobProgress: EPrintXPSJobProgress) callconv(.Stdcall) HRESULT;
pub extern "winspool" fn GetPrinterDriver2A(hWnd: HWND, hPrinter: HANDLE, pEnvironment: LPSTR, Level: DWORD, pDriverInfo: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "winspool" fn GetPrinterDriver2W(hWnd: HWND, hPrinter: HANDLE, pEnvironment: LPWSTR, Level: DWORD, pDriverInfo: LPBYTE, cbBuf: DWORD, pcbNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub const PRINT_EXECUTION_CONTEXT_APPLICATION = 0;
pub const PRINT_EXECUTION_CONTEXT_SPOOLER_SERVICE = 1;
pub const PRINT_EXECUTION_CONTEXT_SPOOLER_ISOLATION_HOST = 2;
pub const PRINT_EXECUTION_CONTEXT_FILTER_PIPELINE = 3;
pub const PRINT_EXECUTION_CONTEXT_WOW64 = 4;
pub const PRINT_EXECUTION_CONTEXT = extern enum {
    PRINT_EXECUTION_CONTEXT_APPLICATION = 0,
    PRINT_EXECUTION_CONTEXT_SPOOLER_SERVICE = 1,
    PRINT_EXECUTION_CONTEXT_SPOOLER_ISOLATION_HOST = 2,
    PRINT_EXECUTION_CONTEXT_FILTER_PIPELINE = 3,
    PRINT_EXECUTION_CONTEXT_WOW64 = 4,
};
pub const PRINT_EXECUTION_DATA = extern struct {
    context: PRINT_EXECUTION_CONTEXT,
    clientAppPID: DWORD,
};
pub extern "winspool" fn GetPrintExecutionData(pData: [*c]PRINT_EXECUTION_DATA) callconv(.Stdcall) BOOL;
pub extern "winspool" fn GetJobNamedPropertyValue(hPrinter: HANDLE, JobId: DWORD, pszName: PCWSTR, pValue: [*c]PrintPropertyValue) callconv(.Stdcall) DWORD;
pub extern "winspool" fn FreePrintPropertyValue(pValue: [*c]PrintPropertyValue) callconv(.Stdcall) void;
pub extern "winspool" fn FreePrintNamedPropertyArray(cProperties: DWORD, ppProperties: [*c]([*c]PrintNamedProperty)) callconv(.Stdcall) void;
pub extern "winspool" fn SetJobNamedProperty(hPrinter: HANDLE, JobId: DWORD, pProperty: [*c]const PrintNamedProperty) callconv(.Stdcall) DWORD;
pub extern "winspool" fn DeleteJobNamedProperty(hPrinter: HANDLE, JobId: DWORD, pszName: PCWSTR) callconv(.Stdcall) DWORD;
pub extern "winspool" fn EnumJobNamedProperties(hPrinter: HANDLE, JobId: DWORD, pcProperties: [*c]DWORD, ppProperties: [*c]([*c]PrintNamedProperty)) callconv(.Stdcall) DWORD;
pub extern "winspool" fn GetPrintOutputInfo(hWnd: HWND, pszPrinter: PCWSTR, phFile: [*c]HANDLE, ppszOutputFile: [*c]PWSTR) callconv(.Stdcall) HRESULT;
pub extern fn _calloc_base(_Count: usize, _Size: usize) ?*c_void;
pub extern fn calloc(_Count: c_ulonglong, _Size: c_ulonglong) ?*c_void;
pub extern fn _callnewh(_Size: usize) c_int;
pub extern fn _expand(_Block: ?*c_void, _Size: usize) ?*c_void;
pub extern fn _free_base(_Block: ?*c_void) void;
pub extern fn free(_Block: ?*c_void) void;
pub extern fn _malloc_base(_Size: usize) ?*c_void;
pub extern fn malloc(_Size: c_ulonglong) ?*c_void;
pub extern fn _msize_base(_Block: ?*c_void) usize;
pub extern fn _msize(_Block: ?*c_void) usize;
pub extern fn _realloc_base(_Block: ?*c_void, _Size: usize) ?*c_void;
pub extern fn realloc(_Block: ?*c_void, _Size: c_ulonglong) ?*c_void;
pub extern fn _recalloc_base(_Block: ?*c_void, _Count: usize, _Size: usize) ?*c_void;
pub extern fn _recalloc(_Block: ?*c_void, _Count: usize, _Size: usize) ?*c_void;
pub extern fn _aligned_free(_Block: ?*c_void) void;
pub extern fn _aligned_malloc(_Size: usize, _Alignment: usize) ?*c_void;
pub extern fn _aligned_offset_malloc(_Size: usize, _Alignment: usize, _Offset: usize) ?*c_void;
pub extern fn _aligned_msize(_Block: ?*c_void, _Alignment: usize, _Offset: usize) usize;
pub extern fn _aligned_offset_realloc(_Block: ?*c_void, _Size: usize, _Alignment: usize, _Offset: usize) ?*c_void;
pub extern fn _aligned_offset_recalloc(_Block: ?*c_void, _Count: usize, _Size: usize, _Alignment: usize, _Offset: usize) ?*c_void;
pub extern fn _aligned_realloc(_Block: ?*c_void, _Size: usize, _Alignment: usize) ?*c_void;
pub extern fn _aligned_recalloc(_Block: ?*c_void, _Count: usize, _Size: usize, _Alignment: usize) ?*c_void;
pub const max_align_t = f64;
pub const _CoreCrtSecureSearchSortCompareFunction = ?fn (?*c_void, ?*const c_void, ?*const c_void) callconv(.C) c_int;
pub const _CoreCrtNonSecureSearchSortCompareFunction = ?fn (?*const c_void, ?*const c_void) callconv(.C) c_int;
pub extern fn bsearch_s(_Key: ?*const c_void, _Base: ?*const c_void, _NumOfElements: rsize_t, _SizeOfElements: rsize_t, _CompareFunction: _CoreCrtSecureSearchSortCompareFunction, _Context: ?*c_void) ?*c_void;
pub extern fn qsort_s(_Base: ?*c_void, _NumOfElements: rsize_t, _SizeOfElements: rsize_t, _CompareFunction: _CoreCrtSecureSearchSortCompareFunction, _Context: ?*c_void) void;
pub extern fn bsearch(_Key: ?*const c_void, _Base: ?*const c_void, _NumOfElements: usize, _SizeOfElements: usize, _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction) ?*c_void;
pub extern fn qsort(_Base: ?*c_void, _NumOfElements: usize, _SizeOfElements: usize, _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction) void;
pub extern fn _lfind_s(_Key: ?*const c_void, _Base: ?*const c_void, _NumOfElements: [*c]c_uint, _SizeOfElements: usize, _CompareFunction: _CoreCrtSecureSearchSortCompareFunction, _Context: ?*c_void) ?*c_void;
pub extern fn _lfind(_Key: ?*const c_void, _Base: ?*const c_void, _NumOfElements: [*c]c_uint, _SizeOfElements: c_uint, _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction) ?*c_void;
pub extern fn _lsearch_s(_Key: ?*const c_void, _Base: ?*c_void, _NumOfElements: [*c]c_uint, _SizeOfElements: usize, _CompareFunction: _CoreCrtSecureSearchSortCompareFunction, _Context: ?*c_void) ?*c_void;
pub extern fn _lsearch(_Key: ?*const c_void, _Base: ?*c_void, _NumOfElements: [*c]c_uint, _SizeOfElements: c_uint, _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction) ?*c_void;
pub extern fn lfind(_Key: ?*const c_void, _Base: ?*const c_void, _NumOfElements: [*c]c_uint, _SizeOfElements: c_uint, _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction) ?*c_void;
pub extern fn lsearch(_Key: ?*const c_void, _Base: ?*c_void, _NumOfElements: [*c]c_uint, _SizeOfElements: c_uint, _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction) ?*c_void;
pub extern fn _itow_s(_Value: c_int, _Buffer: [*c]wchar_t, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _itow(_Value: c_int, _Buffer: [*c]wchar_t, _Radix: c_int) [*c]wchar_t;
pub extern fn _ltow_s(_Value: c_long, _Buffer: [*c]wchar_t, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _ltow(_Value: c_long, _Buffer: [*c]wchar_t, _Radix: c_int) [*c]wchar_t;
pub extern fn _ultow_s(_Value: c_ulong, _Buffer: [*c]wchar_t, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _ultow(_Value: c_ulong, _Buffer: [*c]wchar_t, _Radix: c_int) [*c]wchar_t;
pub extern fn wcstod(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t)) f64;
pub extern fn _wcstod_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Locale: _locale_t) f64;
pub extern fn wcstol(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int) c_long;
pub extern fn _wcstol_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int, _Locale: _locale_t) c_long;
pub extern fn wcstoll(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int) c_longlong;
pub extern fn _wcstoll_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int, _Locale: _locale_t) c_longlong;
pub extern fn wcstoul(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int) c_ulong;
pub extern fn _wcstoul_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int, _Locale: _locale_t) c_ulong;
pub extern fn wcstoull(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int) c_ulonglong;
pub extern fn _wcstoull_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int, _Locale: _locale_t) c_ulonglong;
pub extern fn wcstold(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t)) c_longdouble;
pub extern fn _wcstold_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Locale: _locale_t) c_longdouble;
pub extern fn wcstof(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t)) f32;
pub extern fn _wcstof_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Locale: _locale_t) f32;
pub extern fn _wtof(_String: [*c]const wchar_t) f64;
pub extern fn _wtof_l(_String: [*c]const wchar_t, _Locale: _locale_t) f64;
pub extern fn _wtoi(_String: [*c]const wchar_t) c_int;
pub extern fn _wtoi_l(_String: [*c]const wchar_t, _Locale: _locale_t) c_int;
pub extern fn _wtol(_String: [*c]const wchar_t) c_long;
pub extern fn _wtol_l(_String: [*c]const wchar_t, _Locale: _locale_t) c_long;
pub extern fn _wtoll(_String: [*c]const wchar_t) c_longlong;
pub extern fn _wtoll_l(_String: [*c]const wchar_t, _Locale: _locale_t) c_longlong;
pub extern fn _i64tow_s(_Value: c_longlong, _Buffer: [*c]wchar_t, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _i64tow(_Value: c_longlong, _Buffer: [*c]wchar_t, _Radix: c_int) [*c]wchar_t;
pub extern fn _ui64tow_s(_Value: c_ulonglong, _Buffer: [*c]wchar_t, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _ui64tow(_Value: c_ulonglong, _Buffer: [*c]wchar_t, _Radix: c_int) [*c]wchar_t;
pub extern fn _wtoi64(_String: [*c]const wchar_t) c_longlong;
pub extern fn _wtoi64_l(_String: [*c]const wchar_t, _Locale: _locale_t) c_longlong;
pub extern fn _wcstoi64(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int) c_longlong;
pub extern fn _wcstoi64_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int, _Locale: _locale_t) c_longlong;
pub extern fn _wcstoui64(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int) c_ulonglong;
pub extern fn _wcstoui64_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int, _Locale: _locale_t) c_ulonglong;
pub extern fn _wfullpath(_Buffer: [*c]wchar_t, _Path: [*c]const wchar_t, _BufferCount: usize) [*c]wchar_t;
pub extern fn _wmakepath_s(_Buffer: [*c]wchar_t, _BufferCount: usize, _Drive: [*c]const wchar_t, _Dir: [*c]const wchar_t, _Filename: [*c]const wchar_t, _Ext: [*c]const wchar_t) errno_t;
pub extern fn _wmakepath(_Buffer: [*c]wchar_t, _Drive: [*c]const wchar_t, _Dir: [*c]const wchar_t, _Filename: [*c]const wchar_t, _Ext: [*c]const wchar_t) void;
pub extern fn _wperror(_ErrorMessage: [*c]const wchar_t) void;
pub extern fn _wsplitpath(_FullPath: [*c]const wchar_t, _Drive: [*c]wchar_t, _Dir: [*c]wchar_t, _Filename: [*c]wchar_t, _Ext: [*c]wchar_t) void;
pub extern fn _wsplitpath_s(_FullPath: [*c]const wchar_t, _Drive: [*c]wchar_t, _DriveCount: usize, _Dir: [*c]wchar_t, _DirCount: usize, _Filename: [*c]wchar_t, _FilenameCount: usize, _Ext: [*c]wchar_t, _ExtCount: usize) errno_t;
pub extern fn _wdupenv_s(_Buffer: [*c]([*c]wchar_t), _BufferCount: [*c]usize, _VarName: [*c]const wchar_t) errno_t;
pub extern fn _wgetenv(_VarName: [*c]const wchar_t) [*c]wchar_t;
pub extern fn _wgetenv_s(_RequiredCount: [*c]usize, _Buffer: [*c]wchar_t, _BufferCount: usize, _VarName: [*c]const wchar_t) errno_t;
pub extern fn _wputenv(_EnvString: [*c]const wchar_t) c_int;
pub extern fn _wputenv_s(_Name: [*c]const wchar_t, _Value: [*c]const wchar_t) errno_t;
pub extern fn _wsearchenv_s(_Filename: [*c]const wchar_t, _VarName: [*c]const wchar_t, _Buffer: [*c]wchar_t, _BufferCount: usize) errno_t;
pub extern fn _wsearchenv(_Filename: [*c]const wchar_t, _VarName: [*c]const wchar_t, _ResultPath: [*c]wchar_t) void;
pub extern fn _wsystem(_Command: [*c]const wchar_t) c_int;
pub extern fn _swab(_Buf1: [*c]u8, _Buf2: [*c]u8, _SizeInBytes: c_int) void;
pub extern fn exit(_Code: c_int) noreturn;
pub extern fn _exit(_Code: c_int) noreturn;
pub extern fn _Exit(_Code: c_int) noreturn;
pub extern fn quick_exit(_Code: c_int) noreturn;
pub extern fn abort() noreturn;
pub extern fn _set_abort_behavior(_Flags: c_uint, _Mask: c_uint) c_uint;
pub const _onexit_t = ?fn () callconv(.C) c_int;
pub extern fn atexit(arg0: ?fn () callconv(.C) void) c_int;
pub extern fn _onexit(_Func: _onexit_t) _onexit_t;
pub extern fn at_quick_exit(arg0: ?fn () callconv(.C) void) c_int;
pub const _purecall_handler = ?fn () callconv(.C) void;
pub const _invalid_parameter_handler = ?fn ([*c]const wchar_t, [*c]const wchar_t, [*c]const wchar_t, c_uint, usize) callconv(.C) void;
pub extern fn _set_purecall_handler(_Handler: _purecall_handler) _purecall_handler;
pub extern fn _get_purecall_handler() _purecall_handler;
pub extern fn _set_invalid_parameter_handler(_Handler: _invalid_parameter_handler) _invalid_parameter_handler;
pub extern fn _get_invalid_parameter_handler() _invalid_parameter_handler;
pub extern fn _set_thread_local_invalid_parameter_handler(_Handler: _invalid_parameter_handler) _invalid_parameter_handler;
pub extern fn _get_thread_local_invalid_parameter_handler() _invalid_parameter_handler;
pub extern fn _set_error_mode(_Mode: c_int) c_int;
pub extern fn __sys_errlist() [*c]([*c]u8);
pub extern fn __sys_nerr() [*c]c_int;
pub extern fn perror(_ErrMsg: [*c]const u8) void;
pub extern fn __p__pgmptr() [*c]([*c]u8);
pub extern fn __p__wpgmptr() [*c]([*c]wchar_t);
pub extern fn __p__fmode() [*c]c_int;
pub extern fn _get_pgmptr(_Value: [*c]([*c]u8)) errno_t;
pub extern fn _get_wpgmptr(_Value: [*c]([*c]wchar_t)) errno_t;
pub extern fn _set_fmode(_Mode: c_int) errno_t;
pub extern fn _get_fmode(_PMode: [*c]c_int) errno_t;
pub const struct__div_t = extern struct {
    quot: c_int,
    rem: c_int,
};
pub const div_t = struct__div_t;
pub const struct__ldiv_t = extern struct {
    quot: c_long,
    rem: c_long,
};
pub const ldiv_t = struct__ldiv_t;
pub const struct__lldiv_t = extern struct {
    quot: c_longlong,
    rem: c_longlong,
};
pub const lldiv_t = struct__lldiv_t;
pub extern fn abs(_Number: c_int) c_int;
pub extern fn labs(_Number: c_long) c_long;
pub extern fn llabs(_Number: c_longlong) c_longlong;
pub extern fn _abs64(_Number: c_longlong) c_longlong;
pub extern fn _byteswap_ushort(_Number: c_ushort) c_ushort;
pub extern fn _byteswap_ulong(_Number: c_ulong) c_ulong;
pub extern fn _byteswap_uint64(_Number: c_ulonglong) c_ulonglong;
pub extern fn div(_Numerator: c_int, _Denominator: c_int) div_t;
pub extern fn ldiv(_Numerator: c_long, _Denominator: c_long) ldiv_t;
pub extern fn lldiv(_Numerator: c_longlong, _Denominator: c_longlong) lldiv_t;
pub extern fn _lrotl(_Value: c_ulong, _Shift: c_int) c_ulong;
pub extern fn _lrotr(_Value: c_ulong, _Shift: c_int) c_ulong;
pub extern fn srand(_Seed: c_uint) void;
pub extern fn rand() c_int;
pub const _LDOUBLE = extern struct {
    ld: [10]u8,
};
pub const _CRT_DOUBLE = extern struct {
    x: f64,
};
pub const _CRT_FLOAT = extern struct {
    f: f32,
};
pub const _LONGDOUBLE = extern struct {
    x: c_longdouble,
};
pub const _LDBL12 = extern struct {
    ld12: [12]u8,
};
pub extern fn atof(_String: [*c]const u8) f64;
pub extern fn atoi(_String: [*c]const u8) c_int;
pub extern fn atol(_String: [*c]const u8) c_long;
pub extern fn atoll(_String: [*c]const u8) c_longlong;
pub extern fn _atoi64(_String: [*c]const u8) c_longlong;
pub extern fn _atof_l(_String: [*c]const u8, _Locale: _locale_t) f64;
pub extern fn _atoi_l(_String: [*c]const u8, _Locale: _locale_t) c_int;
pub extern fn _atol_l(_String: [*c]const u8, _Locale: _locale_t) c_long;
pub extern fn _atoll_l(_String: [*c]const u8, _Locale: _locale_t) c_longlong;
pub extern fn _atoi64_l(_String: [*c]const u8, _Locale: _locale_t) c_longlong;
pub extern fn _atoflt(_Result: [*c]_CRT_FLOAT, _String: [*c]const u8) c_int;
pub extern fn _atodbl(_Result: [*c]_CRT_DOUBLE, _String: [*c]u8) c_int;
pub extern fn _atoldbl(_Result: [*c]_LDOUBLE, _String: [*c]u8) c_int;
pub extern fn _atoflt_l(_Result: [*c]_CRT_FLOAT, _String: [*c]const u8, _Locale: _locale_t) c_int;
pub extern fn _atodbl_l(_Result: [*c]_CRT_DOUBLE, _String: [*c]u8, _Locale: _locale_t) c_int;
pub extern fn _atoldbl_l(_Result: [*c]_LDOUBLE, _String: [*c]u8, _Locale: _locale_t) c_int;
pub extern fn strtof(_String: [*c]const u8, _EndPtr: [*c]([*c]u8)) f32;
pub extern fn _strtof_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Locale: _locale_t) f32;
pub extern fn strtod(_String: [*c]const u8, _EndPtr: [*c]([*c]u8)) f64;
pub extern fn _strtod_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Locale: _locale_t) f64;
pub extern fn strtold(_String: [*c]const u8, _EndPtr: [*c]([*c]u8)) c_longdouble;
pub extern fn _strtold_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Locale: _locale_t) c_longdouble;
pub extern fn strtol(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int) c_long;
pub extern fn _strtol_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int, _Locale: _locale_t) c_long;
pub extern fn strtoll(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int) c_longlong;
pub extern fn _strtoll_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int, _Locale: _locale_t) c_longlong;
pub extern fn strtoul(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int) c_ulong;
pub extern fn _strtoul_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int, _Locale: _locale_t) c_ulong;
pub extern fn strtoull(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int) c_ulonglong;
pub extern fn _strtoull_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int, _Locale: _locale_t) c_ulonglong;
pub extern fn _strtoi64(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int) c_longlong;
pub extern fn _strtoi64_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int, _Locale: _locale_t) c_longlong;
pub extern fn _strtoui64(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int) c_ulonglong;
pub extern fn _strtoui64_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int, _Locale: _locale_t) c_ulonglong;
pub extern fn _itoa_s(_Value: c_int, _Buffer: [*c]u8, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _itoa(_Value: c_int, _Buffer: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn _ltoa_s(_Value: c_long, _Buffer: [*c]u8, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _ltoa(_Value: c_long, _Buffer: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn _ultoa_s(_Value: c_ulong, _Buffer: [*c]u8, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _ultoa(_Value: c_ulong, _Buffer: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn _i64toa_s(_Value: c_longlong, _Buffer: [*c]u8, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _i64toa(_Value: c_longlong, _Buffer: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn _ui64toa_s(_Value: c_ulonglong, _Buffer: [*c]u8, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _ui64toa(_Value: c_ulonglong, _Buffer: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn _ecvt_s(_Buffer: [*c]u8, _BufferCount: usize, _Value: f64, _DigitCount: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) errno_t;
pub extern fn _ecvt(_Value: f64, _DigitCount: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) [*c]u8;
pub extern fn _fcvt_s(_Buffer: [*c]u8, _BufferCount: usize, _Value: f64, _FractionalDigitCount: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) errno_t;
pub extern fn _fcvt(_Value: f64, _FractionalDigitCount: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) [*c]u8;
pub extern fn _gcvt_s(_Buffer: [*c]u8, _BufferCount: usize, _Value: f64, _DigitCount: c_int) errno_t;
pub extern fn _gcvt(_Value: f64, _DigitCount: c_int, _Buffer: [*c]u8) [*c]u8;
pub extern fn mblen(_Ch: [*c]const u8, _MaxCount: usize) c_int;
pub extern fn _mblen_l(_Ch: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn _mbstrlen(_String: [*c]const u8) usize;
pub extern fn _mbstrlen_l(_String: [*c]const u8, _Locale: _locale_t) usize;
pub extern fn _mbstrnlen(_String: [*c]const u8, _MaxCount: usize) usize;
pub extern fn _mbstrnlen_l(_String: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) usize;
pub extern fn mbtowc(_DstCh: [*c]wchar_t, _SrcCh: [*c]const u8, _SrcSizeInBytes: usize) c_int;
pub extern fn _mbtowc_l(_DstCh: [*c]wchar_t, _SrcCh: [*c]const u8, _SrcSizeInBytes: usize, _Locale: _locale_t) c_int;
pub extern fn mbstowcs_s(_PtNumOfCharConverted: [*c]usize, _DstBuf: [*c]wchar_t, _SizeInWords: usize, _SrcBuf: [*c]const u8, _MaxCount: usize) errno_t;
pub extern fn mbstowcs(_Dest: [*c]wchar_t, _Source: [*c]const u8, _MaxCount: usize) usize;
pub extern fn _mbstowcs_s_l(_PtNumOfCharConverted: [*c]usize, _DstBuf: [*c]wchar_t, _SizeInWords: usize, _SrcBuf: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) errno_t;
pub extern fn _mbstowcs_l(_Dest: [*c]wchar_t, _Source: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) usize;
pub extern fn wctomb(_MbCh: [*c]u8, _WCh: wchar_t) c_int;
pub extern fn _wctomb_l(_MbCh: [*c]u8, _WCh: wchar_t, _Locale: _locale_t) c_int;
pub extern fn wctomb_s(_SizeConverted: [*c]c_int, _MbCh: [*c]u8, _SizeInBytes: rsize_t, _WCh: wchar_t) errno_t;
pub extern fn _wctomb_s_l(_SizeConverted: [*c]c_int, _MbCh: [*c]u8, _SizeInBytes: usize, _WCh: wchar_t, _Locale: _locale_t) errno_t;
pub extern fn wcstombs_s(_PtNumOfCharConverted: [*c]usize, _Dst: [*c]u8, _DstSizeInBytes: usize, _Src: [*c]const wchar_t, _MaxCountInBytes: usize) errno_t;
pub extern fn wcstombs(_Dest: [*c]u8, _Source: [*c]const wchar_t, _MaxCount: usize) usize;
pub extern fn _wcstombs_s_l(_PtNumOfCharConverted: [*c]usize, _Dst: [*c]u8, _DstSizeInBytes: usize, _Src: [*c]const wchar_t, _MaxCountInBytes: usize, _Locale: _locale_t) errno_t;
pub extern fn _wcstombs_l(_Dest: [*c]u8, _Source: [*c]const wchar_t, _MaxCount: usize, _Locale: _locale_t) usize;
pub extern fn _fullpath(_Buffer: [*c]u8, _Path: [*c]const u8, _BufferCount: usize) [*c]u8;
pub extern fn _makepath_s(_Buffer: [*c]u8, _BufferCount: usize, _Drive: [*c]const u8, _Dir: [*c]const u8, _Filename: [*c]const u8, _Ext: [*c]const u8) errno_t;
pub extern fn _makepath(_Buffer: [*c]u8, _Drive: [*c]const u8, _Dir: [*c]const u8, _Filename: [*c]const u8, _Ext: [*c]const u8) void;
pub extern fn _splitpath(_FullPath: [*c]const u8, _Drive: [*c]u8, _Dir: [*c]u8, _Filename: [*c]u8, _Ext: [*c]u8) void;
pub extern fn _splitpath_s(_FullPath: [*c]const u8, _Drive: [*c]u8, _DriveCount: usize, _Dir: [*c]u8, _DirCount: usize, _Filename: [*c]u8, _FilenameCount: usize, _Ext: [*c]u8, _ExtCount: usize) errno_t;
pub extern fn getenv_s(_RequiredCount: [*c]usize, _Buffer: [*c]u8, _BufferCount: rsize_t, _VarName: [*c]const u8) errno_t;
pub extern fn __p___argc() [*c]c_int;
pub extern fn __p___argv() [*c]([*c]([*c]u8));
pub extern fn __p___wargv() [*c]([*c]([*c]wchar_t));
pub extern fn __p__environ() [*c]([*c]([*c]u8));
pub extern fn __p__wenviron() [*c]([*c]([*c]wchar_t));
pub extern fn getenv(_VarName: [*c]const u8) [*c]u8;
pub extern fn _dupenv_s(_Buffer: [*c]([*c]u8), _BufferCount: [*c]usize, _VarName: [*c]const u8) errno_t;
pub extern fn system(_Command: [*c]const u8) c_int;
pub extern fn _putenv(_EnvString: [*c]const u8) c_int;
pub extern fn _putenv_s(_Name: [*c]const u8, _Value: [*c]const u8) errno_t;
pub extern fn _searchenv_s(_Filename: [*c]const u8, _VarName: [*c]const u8, _Buffer: [*c]u8, _BufferCount: usize) errno_t;
pub extern fn _searchenv(_Filename: [*c]const u8, _VarName: [*c]const u8, _Buffer: [*c]u8) void;
pub extern fn _seterrormode(_Mode: c_int) void;
pub extern fn _beep(_Frequency: c_uint, _Duration: c_uint) void;
pub extern fn _sleep(_Duration: c_ulong) void;
pub extern fn ecvt(_Value: f64, _DigitCount: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) [*c]u8;
pub extern fn fcvt(_Value: f64, _FractionalDigitCount: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) [*c]u8;
pub extern fn gcvt(_Value: f64, _DigitCount: c_int, _DstBuf: [*c]u8) [*c]u8;
pub extern fn itoa(_Value: c_int, _Buffer: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn ltoa(_Value: c_long, _Buffer: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn swab(_Buf1: [*c]u8, _Buf2: [*c]u8, _SizeInBytes: c_int) void;
pub extern fn ultoa(_Value: c_ulong, _Buffer: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn putenv(_EnvString: [*c]const u8) c_int;
pub extern fn onexit(_Func: _onexit_t) _onexit_t;
pub const REGCLS_SINGLEUSE = enum_tagREGCLS.REGCLS_SINGLEUSE;
pub const REGCLS_MULTIPLEUSE = enum_tagREGCLS.REGCLS_MULTIPLEUSE;
pub const REGCLS_MULTI_SEPARATE = enum_tagREGCLS.REGCLS_MULTI_SEPARATE;
pub const REGCLS_SUSPENDED = enum_tagREGCLS.REGCLS_SUSPENDED;
pub const REGCLS_SURROGATE = enum_tagREGCLS.REGCLS_SURROGATE;
pub const REGCLS_AGILE = enum_tagREGCLS.REGCLS_AGILE;
pub const enum_tagREGCLS = extern enum {
    REGCLS_SINGLEUSE = 0,
    REGCLS_MULTIPLEUSE = 1,
    REGCLS_MULTI_SEPARATE = 2,
    REGCLS_SUSPENDED = 4,
    REGCLS_SURROGATE = 8,
    REGCLS_AGILE = 16,
};
pub const REGCLS = enum_tagREGCLS;
pub const COINITBASE_MULTITHREADED = enum_tagCOINITBASE.COINITBASE_MULTITHREADED;
pub const enum_tagCOINITBASE = extern enum {
    COINITBASE_MULTITHREADED = 0,
};
pub const COINITBASE = enum_tagCOINITBASE;
pub const AsyncIUnknown = struct_AsyncIUnknown;
pub const struct_AsyncIUnknownVtbl = extern struct {
    QueryInterface: ?fn ([*c]AsyncIUnknown, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]AsyncIUnknown) callconv(.C) ULONG,
    Release: ?fn ([*c]AsyncIUnknown) callconv(.C) ULONG,
    Begin_QueryInterface: ?fn ([*c]AsyncIUnknown, [*c]const IID) callconv(.C) HRESULT,
    Finish_QueryInterface: ?fn ([*c]AsyncIUnknown, [*c](?*c_void)) callconv(.C) HRESULT,
    Begin_AddRef: ?fn ([*c]AsyncIUnknown) callconv(.C) HRESULT,
    Finish_AddRef: ?fn ([*c]AsyncIUnknown) callconv(.C) ULONG,
    Begin_Release: ?fn ([*c]AsyncIUnknown) callconv(.C) HRESULT,
    Finish_Release: ?fn ([*c]AsyncIUnknown) callconv(.C) ULONG,
};
pub const struct_AsyncIUnknown = extern struct {
    lpVtbl: [*c]struct_AsyncIUnknownVtbl,
};
pub const IClassFactory = struct_IClassFactory;
pub const struct_IClassFactoryVtbl = extern struct {
    QueryInterface: ?fn ([*c]IClassFactory, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IClassFactory) callconv(.C) ULONG,
    Release: ?fn ([*c]IClassFactory) callconv(.C) ULONG,
    CreateInstance: ?fn ([*c]IClassFactory, [*c]IUnknown, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    LockServer: ?fn ([*c]IClassFactory, BOOL) callconv(.C) HRESULT,
};
pub const struct_IClassFactory = extern struct {
    lpVtbl: [*c]struct_IClassFactoryVtbl,
};
pub extern var __MIDL_itf_unknwnbase_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_unknwnbase_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPUNKNOWN = [*c]IUnknown;
pub extern const IID_IUnknown: IID;
pub const IUnknownVtbl = struct_IUnknownVtbl;
pub extern "rpcrt4" fn IUnknown_QueryInterface_Proxy(This: [*c]IUnknown, riid: [*c]const IID, ppvObject: [*c](?*c_void)) callconv(.Stdcall) HRESULT;
pub extern "rpcrt4" fn IUnknown_QueryInterface_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) callconv(.Stdcall) void;
pub extern "rpcrt4" fn IUnknown_AddRef_Proxy(This: [*c]IUnknown) callconv(.Stdcall) ULONG;
pub extern "rpcrt4" fn IUnknown_AddRef_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) callconv(.Stdcall) void;
pub extern "rpcrt4" fn IUnknown_Release_Proxy(This: [*c]IUnknown) callconv(.Stdcall) ULONG;
pub extern "rpcrt4" fn IUnknown_Release_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) callconv(.Stdcall) void;
pub extern var __MIDL_itf_unknwnbase_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_unknwnbase_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_AsyncIUnknown: IID;
pub const AsyncIUnknownVtbl = struct_AsyncIUnknownVtbl;
pub extern var __MIDL_itf_unknwnbase_0000_0002_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_unknwnbase_0000_0002_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPCLASSFACTORY = [*c]IClassFactory;
pub extern const IID_IClassFactory: IID;
pub const IClassFactoryVtbl = struct_IClassFactoryVtbl;
pub extern fn IClassFactory_RemoteCreateInstance_Proxy(This: [*c]IClassFactory, riid: [*c]const IID, ppvObject: [*c]([*c]IUnknown)) HRESULT;
pub extern fn IClassFactory_RemoteCreateInstance_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IClassFactory_RemoteLockServer_Proxy(This: [*c]IClassFactory, fLock: BOOL) HRESULT;
pub extern fn IClassFactory_RemoteLockServer_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_unknwnbase_0000_0003_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_unknwnbase_0000_0003_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern fn IClassFactory_CreateInstance_Proxy(This: [*c]IClassFactory, pUnkOuter: [*c]IUnknown, riid: [*c]const IID, ppvObject: [*c](?*c_void)) HRESULT;
pub extern fn IClassFactory_CreateInstance_Stub(This: [*c]IClassFactory, riid: [*c]const IID, ppvObject: [*c]([*c]IUnknown)) HRESULT;
pub extern fn IClassFactory_LockServer_Proxy(This: [*c]IClassFactory, fLock: BOOL) HRESULT;
pub extern fn IClassFactory_LockServer_Stub(This: [*c]IClassFactory, fLock: BOOL) HRESULT;
pub const IMarshal = struct_IMarshal;
pub const struct_tagSTATSTG = extern struct {
    pwcsName: LPOLESTR,
    type: DWORD,
    cbSize: ULARGE_INTEGER,
    mtime: FILETIME,
    ctime: FILETIME,
    atime: FILETIME,
    grfMode: DWORD,
    grfLocksSupported: DWORD,
    clsid: CLSID,
    grfStateBits: DWORD,
    reserved: DWORD,
};
pub const STATSTG = struct_tagSTATSTG;
pub const struct_IStreamVtbl = extern struct {
    QueryInterface: ?fn ([*c]IStream, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IStream) callconv(.C) ULONG,
    Release: ?fn ([*c]IStream) callconv(.C) ULONG,
    Read: ?fn ([*c]IStream, ?*c_void, ULONG, [*c]ULONG) callconv(.C) HRESULT,
    Write: ?fn ([*c]IStream, ?*const c_void, ULONG, [*c]ULONG) callconv(.C) HRESULT,
    Seek: ?fn ([*c]IStream, LARGE_INTEGER, DWORD, [*c]ULARGE_INTEGER) callconv(.C) HRESULT,
    SetSize: ?fn ([*c]IStream, ULARGE_INTEGER) callconv(.C) HRESULT,
    CopyTo: ?fn ([*c]IStream, [*c]IStream, ULARGE_INTEGER, [*c]ULARGE_INTEGER, [*c]ULARGE_INTEGER) callconv(.C) HRESULT,
    Commit: ?fn ([*c]IStream, DWORD) callconv(.C) HRESULT,
    Revert: ?fn ([*c]IStream) callconv(.C) HRESULT,
    LockRegion: ?fn ([*c]IStream, ULARGE_INTEGER, ULARGE_INTEGER, DWORD) callconv(.C) HRESULT,
    UnlockRegion: ?fn ([*c]IStream, ULARGE_INTEGER, ULARGE_INTEGER, DWORD) callconv(.C) HRESULT,
    Stat: ?fn ([*c]IStream, [*c]STATSTG, DWORD) callconv(.C) HRESULT,
    Clone: ?fn ([*c]IStream, [*c]([*c]IStream)) callconv(.C) HRESULT,
};
pub const struct_IStream = extern struct {
    lpVtbl: [*c]struct_IStreamVtbl,
};
pub const IStream = struct_IStream;
pub const struct_IMarshalVtbl = extern struct {
    QueryInterface: ?fn ([*c]IMarshal, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IMarshal) callconv(.C) ULONG,
    Release: ?fn ([*c]IMarshal) callconv(.C) ULONG,
    GetUnmarshalClass: ?fn ([*c]IMarshal, [*c]const IID, ?*c_void, DWORD, ?*c_void, DWORD, [*c]CLSID) callconv(.C) HRESULT,
    GetMarshalSizeMax: ?fn ([*c]IMarshal, [*c]const IID, ?*c_void, DWORD, ?*c_void, DWORD, [*c]DWORD) callconv(.C) HRESULT,
    MarshalInterface: ?fn ([*c]IMarshal, [*c]IStream, [*c]const IID, ?*c_void, DWORD, ?*c_void, DWORD) callconv(.C) HRESULT,
    UnmarshalInterface: ?fn ([*c]IMarshal, [*c]IStream, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    ReleaseMarshalData: ?fn ([*c]IMarshal, [*c]IStream) callconv(.C) HRESULT,
    DisconnectObject: ?fn ([*c]IMarshal, DWORD) callconv(.C) HRESULT,
};
pub const struct_IMarshal = extern struct {
    lpVtbl: [*c]struct_IMarshalVtbl,
};
pub const INoMarshal = struct_INoMarshal;
pub const struct_INoMarshalVtbl = extern struct {
    QueryInterface: ?fn ([*c]INoMarshal, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]INoMarshal) callconv(.C) ULONG,
    Release: ?fn ([*c]INoMarshal) callconv(.C) ULONG,
};
pub const struct_INoMarshal = extern struct {
    lpVtbl: [*c]struct_INoMarshalVtbl,
};
pub const IAgileObject = struct_IAgileObject;
pub const struct_IAgileObjectVtbl = extern struct {
    QueryInterface: ?fn ([*c]IAgileObject, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IAgileObject) callconv(.C) ULONG,
    Release: ?fn ([*c]IAgileObject) callconv(.C) ULONG,
};
pub const struct_IAgileObject = extern struct {
    lpVtbl: [*c]struct_IAgileObjectVtbl,
};
pub const IActivationFilter = struct_IActivationFilter;
pub const struct_IActivationFilterVtbl = extern struct {
    QueryInterface: ?fn ([*c]IActivationFilter, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IActivationFilter) callconv(.C) ULONG,
    Release: ?fn ([*c]IActivationFilter) callconv(.C) ULONG,
    HandleActivation: ?fn ([*c]IActivationFilter, DWORD, [*c]const IID, [*c]CLSID) callconv(.C) HRESULT,
};
pub const struct_IActivationFilter = extern struct {
    lpVtbl: [*c]struct_IActivationFilterVtbl,
};
pub const IMarshal2 = struct_IMarshal2;
pub const struct_IMarshal2Vtbl = extern struct {
    QueryInterface: ?fn ([*c]IMarshal2, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IMarshal2) callconv(.C) ULONG,
    Release: ?fn ([*c]IMarshal2) callconv(.C) ULONG,
    GetUnmarshalClass: ?fn ([*c]IMarshal2, [*c]const IID, ?*c_void, DWORD, ?*c_void, DWORD, [*c]CLSID) callconv(.C) HRESULT,
    GetMarshalSizeMax: ?fn ([*c]IMarshal2, [*c]const IID, ?*c_void, DWORD, ?*c_void, DWORD, [*c]DWORD) callconv(.C) HRESULT,
    MarshalInterface: ?fn ([*c]IMarshal2, [*c]IStream, [*c]const IID, ?*c_void, DWORD, ?*c_void, DWORD) callconv(.C) HRESULT,
    UnmarshalInterface: ?fn ([*c]IMarshal2, [*c]IStream, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    ReleaseMarshalData: ?fn ([*c]IMarshal2, [*c]IStream) callconv(.C) HRESULT,
    DisconnectObject: ?fn ([*c]IMarshal2, DWORD) callconv(.C) HRESULT,
};
pub const struct_IMarshal2 = extern struct {
    lpVtbl: [*c]struct_IMarshal2Vtbl,
};
pub const IMalloc = struct_IMalloc;
pub const struct_IMallocVtbl = extern struct {
    QueryInterface: ?fn ([*c]IMalloc, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IMalloc) callconv(.C) ULONG,
    Release: ?fn ([*c]IMalloc) callconv(.C) ULONG,
    Alloc: ?fn ([*c]IMalloc, SIZE_T) callconv(.C) ?*c_void,
    Realloc: ?fn ([*c]IMalloc, ?*c_void, SIZE_T) callconv(.C) ?*c_void,
    Free: ?fn ([*c]IMalloc, ?*c_void) callconv(.C) void,
    GetSize: ?fn ([*c]IMalloc, ?*c_void) callconv(.C) SIZE_T,
    DidAlloc: ?fn ([*c]IMalloc, ?*c_void) callconv(.C) c_int,
    HeapMinimize: ?fn ([*c]IMalloc) callconv(.C) void,
};
pub const struct_IMalloc = extern struct {
    lpVtbl: [*c]struct_IMallocVtbl,
};
pub const IStdMarshalInfo = struct_IStdMarshalInfo;
pub const struct_IStdMarshalInfoVtbl = extern struct {
    QueryInterface: ?fn ([*c]IStdMarshalInfo, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IStdMarshalInfo) callconv(.C) ULONG,
    Release: ?fn ([*c]IStdMarshalInfo) callconv(.C) ULONG,
    GetClassForHandler: ?fn ([*c]IStdMarshalInfo, DWORD, ?*c_void, [*c]CLSID) callconv(.C) HRESULT,
};
pub const struct_IStdMarshalInfo = extern struct {
    lpVtbl: [*c]struct_IStdMarshalInfoVtbl,
};
pub const IExternalConnection = struct_IExternalConnection;
pub const struct_IExternalConnectionVtbl = extern struct {
    QueryInterface: ?fn ([*c]IExternalConnection, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IExternalConnection) callconv(.C) ULONG,
    Release: ?fn ([*c]IExternalConnection) callconv(.C) ULONG,
    AddConnection: ?fn ([*c]IExternalConnection, DWORD, DWORD) callconv(.C) DWORD,
    ReleaseConnection: ?fn ([*c]IExternalConnection, DWORD, DWORD, BOOL) callconv(.C) DWORD,
};
pub const struct_IExternalConnection = extern struct {
    lpVtbl: [*c]struct_IExternalConnectionVtbl,
};
pub const IMultiQI = struct_IMultiQI;
pub const struct_tagMULTI_QI = extern struct {
    pIID: [*c]const IID,
    pItf: [*c]IUnknown,
    hr: HRESULT,
};
pub const MULTI_QI = struct_tagMULTI_QI;
pub const struct_IMultiQIVtbl = extern struct {
    QueryInterface: ?fn ([*c]IMultiQI, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IMultiQI) callconv(.C) ULONG,
    Release: ?fn ([*c]IMultiQI) callconv(.C) ULONG,
    QueryMultipleInterfaces: ?fn ([*c]IMultiQI, ULONG, [*c]MULTI_QI) callconv(.C) HRESULT,
};
pub const struct_IMultiQI = extern struct {
    lpVtbl: [*c]struct_IMultiQIVtbl,
};
pub const AsyncIMultiQI = struct_AsyncIMultiQI;
pub const struct_AsyncIMultiQIVtbl = extern struct {
    QueryInterface: ?fn ([*c]AsyncIMultiQI, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]AsyncIMultiQI) callconv(.C) ULONG,
    Release: ?fn ([*c]AsyncIMultiQI) callconv(.C) ULONG,
    Begin_QueryMultipleInterfaces: ?fn ([*c]AsyncIMultiQI, ULONG, [*c]MULTI_QI) callconv(.C) HRESULT,
    Finish_QueryMultipleInterfaces: ?fn ([*c]AsyncIMultiQI, [*c]MULTI_QI) callconv(.C) HRESULT,
};
pub const struct_AsyncIMultiQI = extern struct {
    lpVtbl: [*c]struct_AsyncIMultiQIVtbl,
};
pub const IInternalUnknown = struct_IInternalUnknown;
pub const struct_IInternalUnknownVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternalUnknown, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternalUnknown) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternalUnknown) callconv(.C) ULONG,
    QueryInternalInterface: ?fn ([*c]IInternalUnknown, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
};
pub const struct_IInternalUnknown = extern struct {
    lpVtbl: [*c]struct_IInternalUnknownVtbl,
};
pub const IEnumUnknown = struct_IEnumUnknown;
pub const struct_IEnumUnknownVtbl = extern struct {
    QueryInterface: ?fn ([*c]IEnumUnknown, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IEnumUnknown) callconv(.C) ULONG,
    Release: ?fn ([*c]IEnumUnknown) callconv(.C) ULONG,
    Next: ?fn ([*c]IEnumUnknown, ULONG, [*c]([*c]IUnknown), [*c]ULONG) callconv(.C) HRESULT,
    Skip: ?fn ([*c]IEnumUnknown, ULONG) callconv(.C) HRESULT,
    Reset: ?fn ([*c]IEnumUnknown) callconv(.C) HRESULT,
    Clone: ?fn ([*c]IEnumUnknown, [*c]([*c]IEnumUnknown)) callconv(.C) HRESULT,
};
pub const struct_IEnumUnknown = extern struct {
    lpVtbl: [*c]struct_IEnumUnknownVtbl,
};
pub const IEnumString = struct_IEnumString;
pub const struct_IEnumStringVtbl = extern struct {
    QueryInterface: ?fn ([*c]IEnumString, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IEnumString) callconv(.C) ULONG,
    Release: ?fn ([*c]IEnumString) callconv(.C) ULONG,
    Next: ?fn ([*c]IEnumString, ULONG, [*c]LPOLESTR, [*c]ULONG) callconv(.C) HRESULT,
    Skip: ?fn ([*c]IEnumString, ULONG) callconv(.C) HRESULT,
    Reset: ?fn ([*c]IEnumString) callconv(.C) HRESULT,
    Clone: ?fn ([*c]IEnumString, [*c]([*c]IEnumString)) callconv(.C) HRESULT,
};
pub const struct_IEnumString = extern struct {
    lpVtbl: [*c]struct_IEnumStringVtbl,
};
pub const ISequentialStream = struct_ISequentialStream;
pub const struct_ISequentialStreamVtbl = extern struct {
    QueryInterface: ?fn ([*c]ISequentialStream, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ISequentialStream) callconv(.C) ULONG,
    Release: ?fn ([*c]ISequentialStream) callconv(.C) ULONG,
    Read: ?fn ([*c]ISequentialStream, ?*c_void, ULONG, [*c]ULONG) callconv(.C) HRESULT,
    Write: ?fn ([*c]ISequentialStream, ?*const c_void, ULONG, [*c]ULONG) callconv(.C) HRESULT,
};
pub const struct_ISequentialStream = extern struct {
    lpVtbl: [*c]struct_ISequentialStreamVtbl,
};
pub const IRpcChannelBuffer2 = struct_IRpcChannelBuffer2;
pub const struct_IRpcChannelBuffer2Vtbl = extern struct {
    QueryInterface: ?fn ([*c]IRpcChannelBuffer2, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IRpcChannelBuffer2) callconv(.C) ULONG,
    Release: ?fn ([*c]IRpcChannelBuffer2) callconv(.C) ULONG,
    GetBuffer: ?fn ([*c]IRpcChannelBuffer2, [*c]RPCOLEMESSAGE, [*c]const IID) callconv(.C) HRESULT,
    SendReceive: ?fn ([*c]IRpcChannelBuffer2, [*c]RPCOLEMESSAGE, [*c]ULONG) callconv(.C) HRESULT,
    FreeBuffer: ?fn ([*c]IRpcChannelBuffer2, [*c]RPCOLEMESSAGE) callconv(.C) HRESULT,
    GetDestCtx: ?fn ([*c]IRpcChannelBuffer2, [*c]DWORD, [*c](?*c_void)) callconv(.C) HRESULT,
    IsConnected: ?fn ([*c]IRpcChannelBuffer2) callconv(.C) HRESULT,
    GetProtocolVersion: ?fn ([*c]IRpcChannelBuffer2, [*c]DWORD) callconv(.C) HRESULT,
};
pub const struct_IRpcChannelBuffer2 = extern struct {
    lpVtbl: [*c]struct_IRpcChannelBuffer2Vtbl,
};
pub const IAsyncRpcChannelBuffer = struct_IAsyncRpcChannelBuffer;
pub const struct_ISynchronizeVtbl = extern struct {
    QueryInterface: ?fn ([*c]ISynchronize, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ISynchronize) callconv(.C) ULONG,
    Release: ?fn ([*c]ISynchronize) callconv(.C) ULONG,
    Wait: ?fn ([*c]ISynchronize, DWORD, DWORD) callconv(.C) HRESULT,
    Signal: ?fn ([*c]ISynchronize) callconv(.C) HRESULT,
    Reset: ?fn ([*c]ISynchronize) callconv(.C) HRESULT,
};
pub const struct_ISynchronize = extern struct {
    lpVtbl: [*c]struct_ISynchronizeVtbl,
};
pub const ISynchronize = struct_ISynchronize;
pub const struct_IAsyncRpcChannelBufferVtbl = extern struct {
    QueryInterface: ?fn ([*c]IAsyncRpcChannelBuffer, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IAsyncRpcChannelBuffer) callconv(.C) ULONG,
    Release: ?fn ([*c]IAsyncRpcChannelBuffer) callconv(.C) ULONG,
    GetBuffer: ?fn ([*c]IAsyncRpcChannelBuffer, [*c]RPCOLEMESSAGE, [*c]const IID) callconv(.C) HRESULT,
    SendReceive: ?fn ([*c]IAsyncRpcChannelBuffer, [*c]RPCOLEMESSAGE, [*c]ULONG) callconv(.C) HRESULT,
    FreeBuffer: ?fn ([*c]IAsyncRpcChannelBuffer, [*c]RPCOLEMESSAGE) callconv(.C) HRESULT,
    GetDestCtx: ?fn ([*c]IAsyncRpcChannelBuffer, [*c]DWORD, [*c](?*c_void)) callconv(.C) HRESULT,
    IsConnected: ?fn ([*c]IAsyncRpcChannelBuffer) callconv(.C) HRESULT,
    GetProtocolVersion: ?fn ([*c]IAsyncRpcChannelBuffer, [*c]DWORD) callconv(.C) HRESULT,
    Send: ?fn ([*c]IAsyncRpcChannelBuffer, [*c]RPCOLEMESSAGE, [*c]ISynchronize, [*c]ULONG) callconv(.C) HRESULT,
    Receive: ?fn ([*c]IAsyncRpcChannelBuffer, [*c]RPCOLEMESSAGE, [*c]ULONG) callconv(.C) HRESULT,
    GetDestCtxEx: ?fn ([*c]IAsyncRpcChannelBuffer, [*c]RPCOLEMESSAGE, [*c]DWORD, [*c](?*c_void)) callconv(.C) HRESULT,
};
pub const struct_IAsyncRpcChannelBuffer = extern struct {
    lpVtbl: [*c]struct_IAsyncRpcChannelBufferVtbl,
};
pub const IRpcChannelBuffer3 = struct_IRpcChannelBuffer3;
pub const struct_IAsyncManagerVtbl = extern struct {
    QueryInterface: ?fn ([*c]IAsyncManager, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IAsyncManager) callconv(.C) ULONG,
    Release: ?fn ([*c]IAsyncManager) callconv(.C) ULONG,
    CompleteCall: ?fn ([*c]IAsyncManager, HRESULT) callconv(.C) HRESULT,
    GetCallContext: ?fn ([*c]IAsyncManager, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    GetState: ?fn ([*c]IAsyncManager, [*c]ULONG) callconv(.C) HRESULT,
};
pub const struct_IAsyncManager = extern struct {
    lpVtbl: [*c]struct_IAsyncManagerVtbl,
};
pub const IAsyncManager = struct_IAsyncManager;
pub const struct_IRpcChannelBuffer3Vtbl = extern struct {
    QueryInterface: ?fn ([*c]IRpcChannelBuffer3, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IRpcChannelBuffer3) callconv(.C) ULONG,
    Release: ?fn ([*c]IRpcChannelBuffer3) callconv(.C) ULONG,
    GetBuffer: ?fn ([*c]IRpcChannelBuffer3, [*c]RPCOLEMESSAGE, [*c]const IID) callconv(.C) HRESULT,
    SendReceive: ?fn ([*c]IRpcChannelBuffer3, [*c]RPCOLEMESSAGE, [*c]ULONG) callconv(.C) HRESULT,
    FreeBuffer: ?fn ([*c]IRpcChannelBuffer3, [*c]RPCOLEMESSAGE) callconv(.C) HRESULT,
    GetDestCtx: ?fn ([*c]IRpcChannelBuffer3, [*c]DWORD, [*c](?*c_void)) callconv(.C) HRESULT,
    IsConnected: ?fn ([*c]IRpcChannelBuffer3) callconv(.C) HRESULT,
    GetProtocolVersion: ?fn ([*c]IRpcChannelBuffer3, [*c]DWORD) callconv(.C) HRESULT,
    Send: ?fn ([*c]IRpcChannelBuffer3, [*c]RPCOLEMESSAGE, [*c]ULONG) callconv(.C) HRESULT,
    Receive: ?fn ([*c]IRpcChannelBuffer3, [*c]RPCOLEMESSAGE, ULONG, [*c]ULONG) callconv(.C) HRESULT,
    Cancel: ?fn ([*c]IRpcChannelBuffer3, [*c]RPCOLEMESSAGE) callconv(.C) HRESULT,
    GetCallContext: ?fn ([*c]IRpcChannelBuffer3, [*c]RPCOLEMESSAGE, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    GetDestCtxEx: ?fn ([*c]IRpcChannelBuffer3, [*c]RPCOLEMESSAGE, [*c]DWORD, [*c](?*c_void)) callconv(.C) HRESULT,
    GetState: ?fn ([*c]IRpcChannelBuffer3, [*c]RPCOLEMESSAGE, [*c]DWORD) callconv(.C) HRESULT,
    RegisterAsync: ?fn ([*c]IRpcChannelBuffer3, [*c]RPCOLEMESSAGE, [*c]IAsyncManager) callconv(.C) HRESULT,
};
pub const struct_IRpcChannelBuffer3 = extern struct {
    lpVtbl: [*c]struct_IRpcChannelBuffer3Vtbl,
};
pub const IRpcSyntaxNegotiate = struct_IRpcSyntaxNegotiate;
pub const struct_IRpcSyntaxNegotiateVtbl = extern struct {
    QueryInterface: ?fn ([*c]IRpcSyntaxNegotiate, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IRpcSyntaxNegotiate) callconv(.C) ULONG,
    Release: ?fn ([*c]IRpcSyntaxNegotiate) callconv(.C) ULONG,
    NegotiateSyntax: ?fn ([*c]IRpcSyntaxNegotiate, [*c]RPCOLEMESSAGE) callconv(.C) HRESULT,
};
pub const struct_IRpcSyntaxNegotiate = extern struct {
    lpVtbl: [*c]struct_IRpcSyntaxNegotiateVtbl,
};
pub const IRpcProxyBuffer = struct_IRpcProxyBuffer;
pub const struct_IRpcProxyBufferVtbl = extern struct {
    QueryInterface: ?fn ([*c]IRpcProxyBuffer, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IRpcProxyBuffer) callconv(.C) ULONG,
    Release: ?fn ([*c]IRpcProxyBuffer) callconv(.C) ULONG,
    Connect: ?fn ([*c]IRpcProxyBuffer, [*c]IRpcChannelBuffer) callconv(.C) HRESULT,
    Disconnect: ?fn ([*c]IRpcProxyBuffer) callconv(.C) void,
};
pub const struct_IRpcProxyBuffer = extern struct {
    lpVtbl: [*c]struct_IRpcProxyBufferVtbl,
};
pub const IPSFactoryBuffer = struct_IPSFactoryBuffer;
pub const struct_IPSFactoryBufferVtbl = extern struct {
    QueryInterface: ?fn ([*c]IPSFactoryBuffer, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IPSFactoryBuffer) callconv(.C) ULONG,
    Release: ?fn ([*c]IPSFactoryBuffer) callconv(.C) ULONG,
    CreateProxy: ?fn ([*c]IPSFactoryBuffer, [*c]IUnknown, [*c]const IID, [*c]([*c]IRpcProxyBuffer), [*c](?*c_void)) callconv(.C) HRESULT,
    CreateStub: ?fn ([*c]IPSFactoryBuffer, [*c]const IID, [*c]IUnknown, [*c]([*c]IRpcStubBuffer)) callconv(.C) HRESULT,
};
pub const struct_IPSFactoryBuffer = extern struct {
    lpVtbl: [*c]struct_IPSFactoryBufferVtbl,
};
pub const IChannelHook = struct_IChannelHook;
pub const struct_IChannelHookVtbl = extern struct {
    QueryInterface: ?fn ([*c]IChannelHook, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IChannelHook) callconv(.C) ULONG,
    Release: ?fn ([*c]IChannelHook) callconv(.C) ULONG,
    ClientGetSize: ?fn ([*c]IChannelHook, [*c]const GUID, [*c]const IID, [*c]ULONG) callconv(.C) void,
    ClientFillBuffer: ?fn ([*c]IChannelHook, [*c]const GUID, [*c]const IID, [*c]ULONG, ?*c_void) callconv(.C) void,
    ClientNotify: ?fn ([*c]IChannelHook, [*c]const GUID, [*c]const IID, ULONG, ?*c_void, DWORD, HRESULT) callconv(.C) void,
    ServerNotify: ?fn ([*c]IChannelHook, [*c]const GUID, [*c]const IID, ULONG, ?*c_void, DWORD) callconv(.C) void,
    ServerGetSize: ?fn ([*c]IChannelHook, [*c]const GUID, [*c]const IID, HRESULT, [*c]ULONG) callconv(.C) void,
    ServerFillBuffer: ?fn ([*c]IChannelHook, [*c]const GUID, [*c]const IID, [*c]ULONG, ?*c_void, HRESULT) callconv(.C) void,
};
pub const struct_IChannelHook = extern struct {
    lpVtbl: [*c]struct_IChannelHookVtbl,
};
pub const IClientSecurity = struct_IClientSecurity;
pub const struct_IClientSecurityVtbl = extern struct {
    QueryInterface: ?fn ([*c]IClientSecurity, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IClientSecurity) callconv(.C) ULONG,
    Release: ?fn ([*c]IClientSecurity) callconv(.C) ULONG,
    QueryBlanket: ?fn ([*c]IClientSecurity, [*c]IUnknown, [*c]DWORD, [*c]DWORD, [*c]([*c]OLECHAR), [*c]DWORD, [*c]DWORD, [*c](?*c_void), [*c]DWORD) callconv(.C) HRESULT,
    SetBlanket: ?fn ([*c]IClientSecurity, [*c]IUnknown, DWORD, DWORD, [*c]OLECHAR, DWORD, DWORD, ?*c_void, DWORD) callconv(.C) HRESULT,
    CopyProxy: ?fn ([*c]IClientSecurity, [*c]IUnknown, [*c]([*c]IUnknown)) callconv(.C) HRESULT,
};
pub const struct_IClientSecurity = extern struct {
    lpVtbl: [*c]struct_IClientSecurityVtbl,
};
pub const IServerSecurity = struct_IServerSecurity;
pub const struct_IServerSecurityVtbl = extern struct {
    QueryInterface: ?fn ([*c]IServerSecurity, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IServerSecurity) callconv(.C) ULONG,
    Release: ?fn ([*c]IServerSecurity) callconv(.C) ULONG,
    QueryBlanket: ?fn ([*c]IServerSecurity, [*c]DWORD, [*c]DWORD, [*c]([*c]OLECHAR), [*c]DWORD, [*c]DWORD, [*c](?*c_void), [*c]DWORD) callconv(.C) HRESULT,
    ImpersonateClient: ?fn ([*c]IServerSecurity) callconv(.C) HRESULT,
    RevertToSelf: ?fn ([*c]IServerSecurity) callconv(.C) HRESULT,
    IsImpersonating: ?fn ([*c]IServerSecurity) callconv(.C) BOOL,
};
pub const struct_IServerSecurity = extern struct {
    lpVtbl: [*c]struct_IServerSecurityVtbl,
};
pub const IRpcOptions = struct_IRpcOptions;
pub const COMBND_RPCTIMEOUT = enum_tagRPCOPT_PROPERTIES.COMBND_RPCTIMEOUT;
pub const COMBND_SERVER_LOCALITY = enum_tagRPCOPT_PROPERTIES.COMBND_SERVER_LOCALITY;
pub const COMBND_RESERVED1 = enum_tagRPCOPT_PROPERTIES.COMBND_RESERVED1;
pub const COMBND_RESERVED2 = enum_tagRPCOPT_PROPERTIES.COMBND_RESERVED2;
pub const COMBND_RESERVED3 = enum_tagRPCOPT_PROPERTIES.COMBND_RESERVED3;
pub const COMBND_RESERVED4 = enum_tagRPCOPT_PROPERTIES.COMBND_RESERVED4;
pub const enum_tagRPCOPT_PROPERTIES = extern enum {
    COMBND_RPCTIMEOUT = 1,
    COMBND_SERVER_LOCALITY = 2,
    COMBND_RESERVED1 = 4,
    COMBND_RESERVED2 = 5,
    COMBND_RESERVED3 = 8,
    COMBND_RESERVED4 = 16,
};
pub const RPCOPT_PROPERTIES = extern enum {
    COMBND_RPCTIMEOUT = 1,
    COMBND_SERVER_LOCALITY = 2,
    COMBND_RESERVED1 = 4,
    COMBND_RESERVED2 = 5,
    COMBND_RESERVED3 = 8,
    COMBND_RESERVED4 = 16,
};
pub const struct_IRpcOptionsVtbl = extern struct {
    QueryInterface: ?fn ([*c]IRpcOptions, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IRpcOptions) callconv(.C) ULONG,
    Release: ?fn ([*c]IRpcOptions) callconv(.C) ULONG,
    Set: ?fn ([*c]IRpcOptions, [*c]IUnknown, RPCOPT_PROPERTIES, ULONG_PTR) callconv(.C) HRESULT,
    Query: ?fn ([*c]IRpcOptions, [*c]IUnknown, RPCOPT_PROPERTIES, [*c]ULONG_PTR) callconv(.C) HRESULT,
};
pub const struct_IRpcOptions = extern struct {
    lpVtbl: [*c]struct_IRpcOptionsVtbl,
};
pub const IGlobalOptions = struct_IGlobalOptions;
pub const COMGLB_EXCEPTION_HANDLING = enum_tagGLOBALOPT_PROPERTIES.COMGLB_EXCEPTION_HANDLING;
pub const COMGLB_APPID = enum_tagGLOBALOPT_PROPERTIES.COMGLB_APPID;
pub const COMGLB_RPC_THREADPOOL_SETTING = enum_tagGLOBALOPT_PROPERTIES.COMGLB_RPC_THREADPOOL_SETTING;
pub const COMGLB_RO_SETTINGS = enum_tagGLOBALOPT_PROPERTIES.COMGLB_RO_SETTINGS;
pub const COMGLB_UNMARSHALING_POLICY = enum_tagGLOBALOPT_PROPERTIES.COMGLB_UNMARSHALING_POLICY;
pub const COMGLB_PROPERTIES_RESERVED1 = enum_tagGLOBALOPT_PROPERTIES.COMGLB_PROPERTIES_RESERVED1;
pub const COMGLB_PROPERTIES_RESERVED2 = enum_tagGLOBALOPT_PROPERTIES.COMGLB_PROPERTIES_RESERVED2;
pub const COMGLB_PROPERTIES_RESERVED3 = enum_tagGLOBALOPT_PROPERTIES.COMGLB_PROPERTIES_RESERVED3;
pub const enum_tagGLOBALOPT_PROPERTIES = extern enum {
    COMGLB_EXCEPTION_HANDLING = 1,
    COMGLB_APPID = 2,
    COMGLB_RPC_THREADPOOL_SETTING = 3,
    COMGLB_RO_SETTINGS = 4,
    COMGLB_UNMARSHALING_POLICY = 5,
    COMGLB_PROPERTIES_RESERVED1 = 6,
    COMGLB_PROPERTIES_RESERVED2 = 7,
    COMGLB_PROPERTIES_RESERVED3 = 8,
};
pub const GLOBALOPT_PROPERTIES = extern enum {
    COMGLB_EXCEPTION_HANDLING = 1,
    COMGLB_APPID = 2,
    COMGLB_RPC_THREADPOOL_SETTING = 3,
    COMGLB_RO_SETTINGS = 4,
    COMGLB_UNMARSHALING_POLICY = 5,
    COMGLB_PROPERTIES_RESERVED1 = 6,
    COMGLB_PROPERTIES_RESERVED2 = 7,
    COMGLB_PROPERTIES_RESERVED3 = 8,
};
pub const struct_IGlobalOptionsVtbl = extern struct {
    QueryInterface: ?fn ([*c]IGlobalOptions, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IGlobalOptions) callconv(.C) ULONG,
    Release: ?fn ([*c]IGlobalOptions) callconv(.C) ULONG,
    Set: ?fn ([*c]IGlobalOptions, GLOBALOPT_PROPERTIES, ULONG_PTR) callconv(.C) HRESULT,
    Query: ?fn ([*c]IGlobalOptions, GLOBALOPT_PROPERTIES, [*c]ULONG_PTR) callconv(.C) HRESULT,
};
pub const struct_IGlobalOptions = extern struct {
    lpVtbl: [*c]struct_IGlobalOptionsVtbl,
};
pub const ISurrogate = struct_ISurrogate;
pub const struct_ISurrogateVtbl = extern struct {
    QueryInterface: ?fn ([*c]ISurrogate, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ISurrogate) callconv(.C) ULONG,
    Release: ?fn ([*c]ISurrogate) callconv(.C) ULONG,
    LoadDllServer: ?fn ([*c]ISurrogate, [*c]const IID) callconv(.C) HRESULT,
    FreeSurrogate: ?fn ([*c]ISurrogate) callconv(.C) HRESULT,
};
pub const struct_ISurrogate = extern struct {
    lpVtbl: [*c]struct_ISurrogateVtbl,
};
pub const IGlobalInterfaceTable = struct_IGlobalInterfaceTable;
pub const struct_IGlobalInterfaceTableVtbl = extern struct {
    QueryInterface: ?fn ([*c]IGlobalInterfaceTable, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IGlobalInterfaceTable) callconv(.C) ULONG,
    Release: ?fn ([*c]IGlobalInterfaceTable) callconv(.C) ULONG,
    RegisterInterfaceInGlobal: ?fn ([*c]IGlobalInterfaceTable, [*c]IUnknown, [*c]const IID, [*c]DWORD) callconv(.C) HRESULT,
    RevokeInterfaceFromGlobal: ?fn ([*c]IGlobalInterfaceTable, DWORD) callconv(.C) HRESULT,
    GetInterfaceFromGlobal: ?fn ([*c]IGlobalInterfaceTable, DWORD, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
};
pub const struct_IGlobalInterfaceTable = extern struct {
    lpVtbl: [*c]struct_IGlobalInterfaceTableVtbl,
};
pub const ISynchronizeHandle = struct_ISynchronizeHandle;
pub const struct_ISynchronizeHandleVtbl = extern struct {
    QueryInterface: ?fn ([*c]ISynchronizeHandle, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ISynchronizeHandle) callconv(.C) ULONG,
    Release: ?fn ([*c]ISynchronizeHandle) callconv(.C) ULONG,
    GetHandle: ?fn ([*c]ISynchronizeHandle, [*c]HANDLE) callconv(.C) HRESULT,
};
pub const struct_ISynchronizeHandle = extern struct {
    lpVtbl: [*c]struct_ISynchronizeHandleVtbl,
};
pub const ISynchronizeEvent = struct_ISynchronizeEvent;
pub const struct_ISynchronizeEventVtbl = extern struct {
    QueryInterface: ?fn ([*c]ISynchronizeEvent, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ISynchronizeEvent) callconv(.C) ULONG,
    Release: ?fn ([*c]ISynchronizeEvent) callconv(.C) ULONG,
    GetHandle: ?fn ([*c]ISynchronizeEvent, [*c]HANDLE) callconv(.C) HRESULT,
    SetEventHandle: ?fn ([*c]ISynchronizeEvent, [*c]HANDLE) callconv(.C) HRESULT,
};
pub const struct_ISynchronizeEvent = extern struct {
    lpVtbl: [*c]struct_ISynchronizeEventVtbl,
};
pub const ISynchronizeContainer = struct_ISynchronizeContainer;
pub const struct_ISynchronizeContainerVtbl = extern struct {
    QueryInterface: ?fn ([*c]ISynchronizeContainer, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ISynchronizeContainer) callconv(.C) ULONG,
    Release: ?fn ([*c]ISynchronizeContainer) callconv(.C) ULONG,
    AddSynchronize: ?fn ([*c]ISynchronizeContainer, [*c]ISynchronize) callconv(.C) HRESULT,
    WaitMultiple: ?fn ([*c]ISynchronizeContainer, DWORD, DWORD, [*c]([*c]ISynchronize)) callconv(.C) HRESULT,
};
pub const struct_ISynchronizeContainer = extern struct {
    lpVtbl: [*c]struct_ISynchronizeContainerVtbl,
};
pub const ISynchronizeMutex = struct_ISynchronizeMutex;
pub const struct_ISynchronizeMutexVtbl = extern struct {
    QueryInterface: ?fn ([*c]ISynchronizeMutex, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ISynchronizeMutex) callconv(.C) ULONG,
    Release: ?fn ([*c]ISynchronizeMutex) callconv(.C) ULONG,
    Wait: ?fn ([*c]ISynchronizeMutex, DWORD, DWORD) callconv(.C) HRESULT,
    Signal: ?fn ([*c]ISynchronizeMutex) callconv(.C) HRESULT,
    Reset: ?fn ([*c]ISynchronizeMutex) callconv(.C) HRESULT,
    ReleaseMutex: ?fn ([*c]ISynchronizeMutex) callconv(.C) HRESULT,
};
pub const struct_ISynchronizeMutex = extern struct {
    lpVtbl: [*c]struct_ISynchronizeMutexVtbl,
};
pub const ICancelMethodCalls = struct_ICancelMethodCalls;
pub const struct_ICancelMethodCallsVtbl = extern struct {
    QueryInterface: ?fn ([*c]ICancelMethodCalls, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ICancelMethodCalls) callconv(.C) ULONG,
    Release: ?fn ([*c]ICancelMethodCalls) callconv(.C) ULONG,
    Cancel: ?fn ([*c]ICancelMethodCalls, ULONG) callconv(.C) HRESULT,
    TestCancel: ?fn ([*c]ICancelMethodCalls) callconv(.C) HRESULT,
};
pub const struct_ICancelMethodCalls = extern struct {
    lpVtbl: [*c]struct_ICancelMethodCallsVtbl,
};
pub const ICallFactory = struct_ICallFactory;
pub const struct_ICallFactoryVtbl = extern struct {
    QueryInterface: ?fn ([*c]ICallFactory, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ICallFactory) callconv(.C) ULONG,
    Release: ?fn ([*c]ICallFactory) callconv(.C) ULONG,
    CreateCall: ?fn ([*c]ICallFactory, [*c]const IID, [*c]IUnknown, [*c]const IID, [*c]([*c]IUnknown)) callconv(.C) HRESULT,
};
pub const struct_ICallFactory = extern struct {
    lpVtbl: [*c]struct_ICallFactoryVtbl,
};
pub const IRpcHelper = struct_IRpcHelper;
pub const struct_IRpcHelperVtbl = extern struct {
    QueryInterface: ?fn ([*c]IRpcHelper, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IRpcHelper) callconv(.C) ULONG,
    Release: ?fn ([*c]IRpcHelper) callconv(.C) ULONG,
    GetDCOMProtocolVersion: ?fn ([*c]IRpcHelper, [*c]DWORD) callconv(.C) HRESULT,
    GetIIDFromOBJREF: ?fn ([*c]IRpcHelper, ?*c_void, [*c]([*c]IID)) callconv(.C) HRESULT,
};
pub const struct_IRpcHelper = extern struct {
    lpVtbl: [*c]struct_IRpcHelperVtbl,
};
pub const IReleaseMarshalBuffers = struct_IReleaseMarshalBuffers;
pub const struct_IReleaseMarshalBuffersVtbl = extern struct {
    QueryInterface: ?fn ([*c]IReleaseMarshalBuffers, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IReleaseMarshalBuffers) callconv(.C) ULONG,
    Release: ?fn ([*c]IReleaseMarshalBuffers) callconv(.C) ULONG,
    ReleaseMarshalBuffer: ?fn ([*c]IReleaseMarshalBuffers, [*c]RPCOLEMESSAGE, DWORD, [*c]IUnknown) callconv(.C) HRESULT,
};
pub const struct_IReleaseMarshalBuffers = extern struct {
    lpVtbl: [*c]struct_IReleaseMarshalBuffersVtbl,
};
pub const IWaitMultiple = struct_IWaitMultiple;
pub const struct_IWaitMultipleVtbl = extern struct {
    QueryInterface: ?fn ([*c]IWaitMultiple, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IWaitMultiple) callconv(.C) ULONG,
    Release: ?fn ([*c]IWaitMultiple) callconv(.C) ULONG,
    WaitMultiple: ?fn ([*c]IWaitMultiple, DWORD, [*c]([*c]ISynchronize)) callconv(.C) HRESULT,
    AddSynchronize: ?fn ([*c]IWaitMultiple, [*c]ISynchronize) callconv(.C) HRESULT,
};
pub const struct_IWaitMultiple = extern struct {
    lpVtbl: [*c]struct_IWaitMultipleVtbl,
};
pub const IAddrTrackingControl = struct_IAddrTrackingControl;
pub const struct_IAddrTrackingControlVtbl = extern struct {
    QueryInterface: ?fn ([*c]IAddrTrackingControl, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IAddrTrackingControl) callconv(.C) ULONG,
    Release: ?fn ([*c]IAddrTrackingControl) callconv(.C) ULONG,
    EnableCOMDynamicAddrTracking: ?fn ([*c]IAddrTrackingControl) callconv(.C) HRESULT,
    DisableCOMDynamicAddrTracking: ?fn ([*c]IAddrTrackingControl) callconv(.C) HRESULT,
};
pub const struct_IAddrTrackingControl = extern struct {
    lpVtbl: [*c]struct_IAddrTrackingControlVtbl,
};
pub const IAddrExclusionControl = struct_IAddrExclusionControl;
pub const struct_IAddrExclusionControlVtbl = extern struct {
    QueryInterface: ?fn ([*c]IAddrExclusionControl, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IAddrExclusionControl) callconv(.C) ULONG,
    Release: ?fn ([*c]IAddrExclusionControl) callconv(.C) ULONG,
    GetCurrentAddrExclusionList: ?fn ([*c]IAddrExclusionControl, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    UpdateAddrExclusionList: ?fn ([*c]IAddrExclusionControl, [*c]IUnknown) callconv(.C) HRESULT,
};
pub const struct_IAddrExclusionControl = extern struct {
    lpVtbl: [*c]struct_IAddrExclusionControlVtbl,
};
pub const IPipeByte = struct_IPipeByte;
pub const struct_IPipeByteVtbl = extern struct {
    QueryInterface: ?fn ([*c]IPipeByte, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IPipeByte) callconv(.C) ULONG,
    Release: ?fn ([*c]IPipeByte) callconv(.C) ULONG,
    Pull: ?fn ([*c]IPipeByte, [*c]BYTE, ULONG, [*c]ULONG) callconv(.C) HRESULT,
    Push: ?fn ([*c]IPipeByte, [*c]BYTE, ULONG) callconv(.C) HRESULT,
};
pub const struct_IPipeByte = extern struct {
    lpVtbl: [*c]struct_IPipeByteVtbl,
};
pub const AsyncIPipeByte = struct_AsyncIPipeByte;
pub const struct_AsyncIPipeByteVtbl = extern struct {
    QueryInterface: ?fn ([*c]AsyncIPipeByte, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]AsyncIPipeByte) callconv(.C) ULONG,
    Release: ?fn ([*c]AsyncIPipeByte) callconv(.C) ULONG,
    Begin_Pull: ?fn ([*c]AsyncIPipeByte, ULONG) callconv(.C) HRESULT,
    Finish_Pull: ?fn ([*c]AsyncIPipeByte, [*c]BYTE, [*c]ULONG) callconv(.C) HRESULT,
    Begin_Push: ?fn ([*c]AsyncIPipeByte, [*c]BYTE, ULONG) callconv(.C) HRESULT,
    Finish_Push: ?fn ([*c]AsyncIPipeByte) callconv(.C) HRESULT,
};
pub const struct_AsyncIPipeByte = extern struct {
    lpVtbl: [*c]struct_AsyncIPipeByteVtbl,
};
pub const IPipeLong = struct_IPipeLong;
pub const struct_IPipeLongVtbl = extern struct {
    QueryInterface: ?fn ([*c]IPipeLong, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IPipeLong) callconv(.C) ULONG,
    Release: ?fn ([*c]IPipeLong) callconv(.C) ULONG,
    Pull: ?fn ([*c]IPipeLong, [*c]LONG, ULONG, [*c]ULONG) callconv(.C) HRESULT,
    Push: ?fn ([*c]IPipeLong, [*c]LONG, ULONG) callconv(.C) HRESULT,
};
pub const struct_IPipeLong = extern struct {
    lpVtbl: [*c]struct_IPipeLongVtbl,
};
pub const AsyncIPipeLong = struct_AsyncIPipeLong;
pub const struct_AsyncIPipeLongVtbl = extern struct {
    QueryInterface: ?fn ([*c]AsyncIPipeLong, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]AsyncIPipeLong) callconv(.C) ULONG,
    Release: ?fn ([*c]AsyncIPipeLong) callconv(.C) ULONG,
    Begin_Pull: ?fn ([*c]AsyncIPipeLong, ULONG) callconv(.C) HRESULT,
    Finish_Pull: ?fn ([*c]AsyncIPipeLong, [*c]LONG, [*c]ULONG) callconv(.C) HRESULT,
    Begin_Push: ?fn ([*c]AsyncIPipeLong, [*c]LONG, ULONG) callconv(.C) HRESULT,
    Finish_Push: ?fn ([*c]AsyncIPipeLong) callconv(.C) HRESULT,
};
pub const struct_AsyncIPipeLong = extern struct {
    lpVtbl: [*c]struct_AsyncIPipeLongVtbl,
};
pub const IPipeDouble = struct_IPipeDouble;
pub const struct_IPipeDoubleVtbl = extern struct {
    QueryInterface: ?fn ([*c]IPipeDouble, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IPipeDouble) callconv(.C) ULONG,
    Release: ?fn ([*c]IPipeDouble) callconv(.C) ULONG,
    Pull: ?fn ([*c]IPipeDouble, [*c]DOUBLE, ULONG, [*c]ULONG) callconv(.C) HRESULT,
    Push: ?fn ([*c]IPipeDouble, [*c]DOUBLE, ULONG) callconv(.C) HRESULT,
};
pub const struct_IPipeDouble = extern struct {
    lpVtbl: [*c]struct_IPipeDoubleVtbl,
};
pub const AsyncIPipeDouble = struct_AsyncIPipeDouble;
pub const struct_AsyncIPipeDoubleVtbl = extern struct {
    QueryInterface: ?fn ([*c]AsyncIPipeDouble, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]AsyncIPipeDouble) callconv(.C) ULONG,
    Release: ?fn ([*c]AsyncIPipeDouble) callconv(.C) ULONG,
    Begin_Pull: ?fn ([*c]AsyncIPipeDouble, ULONG) callconv(.C) HRESULT,
    Finish_Pull: ?fn ([*c]AsyncIPipeDouble, [*c]DOUBLE, [*c]ULONG) callconv(.C) HRESULT,
    Begin_Push: ?fn ([*c]AsyncIPipeDouble, [*c]DOUBLE, ULONG) callconv(.C) HRESULT,
    Finish_Push: ?fn ([*c]AsyncIPipeDouble) callconv(.C) HRESULT,
};
pub const struct_AsyncIPipeDouble = extern struct {
    lpVtbl: [*c]struct_AsyncIPipeDoubleVtbl,
};
pub const struct_IEnumContextProps = @OpaqueType();
pub const IEnumContextProps = struct_IEnumContextProps;
pub const struct_IContext = @OpaqueType();
pub const IContext = struct_IContext;
pub const struct_IObjContext = @OpaqueType();
pub const IObjContext = struct_IObjContext;
pub const IComThreadingInfo = struct_IComThreadingInfo;
pub const APTTYPE_CURRENT = enum__APTTYPE.APTTYPE_CURRENT;
pub const APTTYPE_STA = enum__APTTYPE.APTTYPE_STA;
pub const APTTYPE_MTA = enum__APTTYPE.APTTYPE_MTA;
pub const APTTYPE_NA = enum__APTTYPE.APTTYPE_NA;
pub const APTTYPE_MAINSTA = enum__APTTYPE.APTTYPE_MAINSTA;
pub const enum__APTTYPE = extern enum {
    APTTYPE_CURRENT = -1,
    APTTYPE_STA = 0,
    APTTYPE_MTA = 1,
    APTTYPE_NA = 2,
    APTTYPE_MAINSTA = 3,
};
pub const APTTYPE = extern enum {
    APTTYPE_CURRENT = -1,
    APTTYPE_STA = 0,
    APTTYPE_MTA = 1,
    APTTYPE_NA = 2,
    APTTYPE_MAINSTA = 3,
};
pub const THDTYPE_BLOCKMESSAGES = enum__THDTYPE.THDTYPE_BLOCKMESSAGES;
pub const THDTYPE_PROCESSMESSAGES = enum__THDTYPE.THDTYPE_PROCESSMESSAGES;
pub const enum__THDTYPE = extern enum {
    THDTYPE_BLOCKMESSAGES = 0,
    THDTYPE_PROCESSMESSAGES = 1,
};
pub const THDTYPE = extern enum {
    THDTYPE_BLOCKMESSAGES = 0,
    THDTYPE_PROCESSMESSAGES = 1,
};
pub const struct_IComThreadingInfoVtbl = extern struct {
    QueryInterface: ?fn ([*c]IComThreadingInfo, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IComThreadingInfo) callconv(.C) ULONG,
    Release: ?fn ([*c]IComThreadingInfo) callconv(.C) ULONG,
    GetCurrentApartmentType: ?fn ([*c]IComThreadingInfo, [*c]APTTYPE) callconv(.C) HRESULT,
    GetCurrentThreadType: ?fn ([*c]IComThreadingInfo, [*c]THDTYPE) callconv(.C) HRESULT,
    GetCurrentLogicalThreadId: ?fn ([*c]IComThreadingInfo, [*c]GUID) callconv(.C) HRESULT,
    SetCurrentLogicalThreadId: ?fn ([*c]IComThreadingInfo, [*c]const GUID) callconv(.C) HRESULT,
};
pub const struct_IComThreadingInfo = extern struct {
    lpVtbl: [*c]struct_IComThreadingInfoVtbl,
};
pub const IProcessInitControl = struct_IProcessInitControl;
pub const struct_IProcessInitControlVtbl = extern struct {
    QueryInterface: ?fn ([*c]IProcessInitControl, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IProcessInitControl) callconv(.C) ULONG,
    Release: ?fn ([*c]IProcessInitControl) callconv(.C) ULONG,
    ResetInitializerTimeout: ?fn ([*c]IProcessInitControl, DWORD) callconv(.C) HRESULT,
};
pub const struct_IProcessInitControl = extern struct {
    lpVtbl: [*c]struct_IProcessInitControlVtbl,
};
pub const IFastRundown = struct_IFastRundown;
pub const struct_IFastRundownVtbl = extern struct {
    QueryInterface: ?fn ([*c]IFastRundown, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IFastRundown) callconv(.C) ULONG,
    Release: ?fn ([*c]IFastRundown) callconv(.C) ULONG,
};
pub const struct_IFastRundown = extern struct {
    lpVtbl: [*c]struct_IFastRundownVtbl,
};
pub const IMarshalingStream = struct_IMarshalingStream;
pub const CO_MARSHALING_SOURCE_IS_APP_CONTAINER = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_SOURCE_IS_APP_CONTAINER;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_1 = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_1;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_2 = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_2;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_3 = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_3;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_4 = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_4;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_5 = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_5;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_6 = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_6;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_7 = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_7;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_8 = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_8;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_9 = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_9;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_10 = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_10;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_11 = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_11;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_12 = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_12;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_13 = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_13;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_14 = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_14;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_15 = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_15;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_16 = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_16;
pub const CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_17 = enum_CO_MARSHALING_CONTEXT_ATTRIBUTES.CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_17;
pub const enum_CO_MARSHALING_CONTEXT_ATTRIBUTES = extern enum {
    CO_MARSHALING_SOURCE_IS_APP_CONTAINER = 0,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_1 = -2147483648,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_2 = -2147483647,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_3 = -2147483646,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_4 = -2147483645,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_5 = -2147483644,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_6 = -2147483643,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_7 = -2147483642,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_8 = -2147483641,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_9 = -2147483640,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_10 = -2147483639,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_11 = -2147483638,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_12 = -2147483637,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_13 = -2147483636,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_14 = -2147483635,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_15 = -2147483634,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_16 = -2147483633,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_17 = -2147483632,
};
pub const CO_MARSHALING_CONTEXT_ATTRIBUTES = extern enum {
    CO_MARSHALING_SOURCE_IS_APP_CONTAINER = 0,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_1 = -2147483648,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_2 = -2147483647,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_3 = -2147483646,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_4 = -2147483645,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_5 = -2147483644,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_6 = -2147483643,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_7 = -2147483642,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_8 = -2147483641,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_9 = -2147483640,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_10 = -2147483639,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_11 = -2147483638,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_12 = -2147483637,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_13 = -2147483636,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_14 = -2147483635,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_15 = -2147483634,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_16 = -2147483633,
    CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_17 = -2147483632,
};
pub const struct_IMarshalingStreamVtbl = extern struct {
    QueryInterface: ?fn ([*c]IMarshalingStream, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IMarshalingStream) callconv(.C) ULONG,
    Release: ?fn ([*c]IMarshalingStream) callconv(.C) ULONG,
    Read: ?fn ([*c]IMarshalingStream, ?*c_void, ULONG, [*c]ULONG) callconv(.C) HRESULT,
    Write: ?fn ([*c]IMarshalingStream, ?*const c_void, ULONG, [*c]ULONG) callconv(.C) HRESULT,
    Seek: ?fn ([*c]IMarshalingStream, LARGE_INTEGER, DWORD, [*c]ULARGE_INTEGER) callconv(.C) HRESULT,
    SetSize: ?fn ([*c]IMarshalingStream, ULARGE_INTEGER) callconv(.C) HRESULT,
    CopyTo: ?fn ([*c]IMarshalingStream, [*c]IStream, ULARGE_INTEGER, [*c]ULARGE_INTEGER, [*c]ULARGE_INTEGER) callconv(.C) HRESULT,
    Commit: ?fn ([*c]IMarshalingStream, DWORD) callconv(.C) HRESULT,
    Revert: ?fn ([*c]IMarshalingStream) callconv(.C) HRESULT,
    LockRegion: ?fn ([*c]IMarshalingStream, ULARGE_INTEGER, ULARGE_INTEGER, DWORD) callconv(.C) HRESULT,
    UnlockRegion: ?fn ([*c]IMarshalingStream, ULARGE_INTEGER, ULARGE_INTEGER, DWORD) callconv(.C) HRESULT,
    Stat: ?fn ([*c]IMarshalingStream, [*c]STATSTG, DWORD) callconv(.C) HRESULT,
    Clone: ?fn ([*c]IMarshalingStream, [*c]([*c]IStream)) callconv(.C) HRESULT,
    GetMarshalingContextAttribute: ?fn ([*c]IMarshalingStream, CO_MARSHALING_CONTEXT_ATTRIBUTES, [*c]ULONG_PTR) callconv(.C) HRESULT,
};
pub const struct_IMarshalingStream = extern struct {
    lpVtbl: [*c]struct_IMarshalingStreamVtbl,
};
pub const IAgileReference = struct_IAgileReference;
pub const struct_IAgileReferenceVtbl = extern struct {
    QueryInterface: ?fn ([*c]IAgileReference, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IAgileReference) callconv(.C) ULONG,
    Release: ?fn ([*c]IAgileReference) callconv(.C) ULONG,
    Resolve: ?fn ([*c]IAgileReference, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
};
pub const struct_IAgileReference = extern struct {
    lpVtbl: [*c]struct_IAgileReferenceVtbl,
};
pub const struct__COSERVERINFO = extern struct {
    dwReserved1: DWORD,
    pwszName: LPWSTR,
    pAuthInfo: [*c]COAUTHINFO,
    dwReserved2: DWORD,
};
pub const COSERVERINFO = struct__COSERVERINFO;
pub extern var __MIDL_itf_objidlbase_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPMARSHAL = [*c]IMarshal;
pub extern const IID_IMarshal: IID;
pub const IMarshalVtbl = struct_IMarshalVtbl;
pub extern const IID_INoMarshal: IID;
pub const INoMarshalVtbl = struct_INoMarshalVtbl;
pub extern const IID_IAgileObject: IID;
pub const IAgileObjectVtbl = struct_IAgileObjectVtbl;
pub extern var __MIDL_itf_objidlbase_0000_0003_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0003_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const ACTIVATIONTYPE_UNCATEGORIZED = enum_tagACTIVATIONTYPE.ACTIVATIONTYPE_UNCATEGORIZED;
pub const ACTIVATIONTYPE_FROM_MONIKER = enum_tagACTIVATIONTYPE.ACTIVATIONTYPE_FROM_MONIKER;
pub const ACTIVATIONTYPE_FROM_DATA = enum_tagACTIVATIONTYPE.ACTIVATIONTYPE_FROM_DATA;
pub const ACTIVATIONTYPE_FROM_STORAGE = enum_tagACTIVATIONTYPE.ACTIVATIONTYPE_FROM_STORAGE;
pub const ACTIVATIONTYPE_FROM_STREAM = enum_tagACTIVATIONTYPE.ACTIVATIONTYPE_FROM_STREAM;
pub const ACTIVATIONTYPE_FROM_FILE = enum_tagACTIVATIONTYPE.ACTIVATIONTYPE_FROM_FILE;
pub const enum_tagACTIVATIONTYPE = extern enum {
    ACTIVATIONTYPE_UNCATEGORIZED = 0,
    ACTIVATIONTYPE_FROM_MONIKER = 1,
    ACTIVATIONTYPE_FROM_DATA = 2,
    ACTIVATIONTYPE_FROM_STORAGE = 4,
    ACTIVATIONTYPE_FROM_STREAM = 8,
    ACTIVATIONTYPE_FROM_FILE = 16,
};
pub const ACTIVATIONTYPE = enum_tagACTIVATIONTYPE;
pub extern const IID_IActivationFilter: IID;
pub const IActivationFilterVtbl = struct_IActivationFilterVtbl;
pub const LPMARSHAL2 = [*c]IMarshal2;
pub extern const IID_IMarshal2: IID;
pub const IMarshal2Vtbl = struct_IMarshal2Vtbl;
pub const LPMALLOC = [*c]IMalloc;
pub extern const IID_IMalloc: IID;
pub const IMallocVtbl = struct_IMallocVtbl;
pub const LPSTDMARSHALINFO = [*c]IStdMarshalInfo;
pub extern const IID_IStdMarshalInfo: IID;
pub const IStdMarshalInfoVtbl = struct_IStdMarshalInfoVtbl;
pub const LPEXTERNALCONNECTION = [*c]IExternalConnection;
pub const EXTCONN_STRONG = enum_tagEXTCONN.EXTCONN_STRONG;
pub const EXTCONN_WEAK = enum_tagEXTCONN.EXTCONN_WEAK;
pub const EXTCONN_CALLABLE = enum_tagEXTCONN.EXTCONN_CALLABLE;
pub const enum_tagEXTCONN = extern enum {
    EXTCONN_STRONG = 1,
    EXTCONN_WEAK = 2,
    EXTCONN_CALLABLE = 4,
};
pub const EXTCONN = enum_tagEXTCONN;
pub extern const IID_IExternalConnection: IID;
pub const IExternalConnectionVtbl = struct_IExternalConnectionVtbl;
pub const LPMULTIQI = [*c]IMultiQI;
pub extern var __MIDL_itf_objidlbase_0000_0008_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0008_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IMultiQI: IID;
pub const IMultiQIVtbl = struct_IMultiQIVtbl;
pub extern const IID_AsyncIMultiQI: IID;
pub const AsyncIMultiQIVtbl = struct_AsyncIMultiQIVtbl;
pub extern var __MIDL_itf_objidlbase_0000_0009_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0009_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IInternalUnknown: IID;
pub const IInternalUnknownVtbl = struct_IInternalUnknownVtbl;
pub extern var __MIDL_itf_objidlbase_0000_0010_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0010_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPENUMUNKNOWN = [*c]IEnumUnknown;
pub extern const IID_IEnumUnknown: IID;
pub const IEnumUnknownVtbl = struct_IEnumUnknownVtbl;
pub extern fn IEnumUnknown_RemoteNext_Proxy(This: [*c]IEnumUnknown, celt: ULONG, rgelt: [*c]([*c]IUnknown), pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumUnknown_RemoteNext_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub const LPENUMSTRING = [*c]IEnumString;
pub extern const IID_IEnumString: IID;
pub const IEnumStringVtbl = struct_IEnumStringVtbl;
pub extern fn IEnumString_RemoteNext_Proxy(This: [*c]IEnumString, celt: ULONG, rgelt: [*c]LPOLESTR, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumString_RemoteNext_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern const IID_ISequentialStream: IID;
pub const ISequentialStreamVtbl = struct_ISequentialStreamVtbl;
pub extern fn ISequentialStream_RemoteRead_Proxy(This: [*c]ISequentialStream, pv: [*c]byte, cb: ULONG, pcbRead: [*c]ULONG) HRESULT;
pub extern fn ISequentialStream_RemoteRead_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ISequentialStream_RemoteWrite_Proxy(This: [*c]ISequentialStream, pv: [*c]const byte, cb: ULONG, pcbWritten: [*c]ULONG) HRESULT;
pub extern fn ISequentialStream_RemoteWrite_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub const LPSTREAM = [*c]IStream;
pub const STGTY_STORAGE = enum_tagSTGTY.STGTY_STORAGE;
pub const STGTY_STREAM = enum_tagSTGTY.STGTY_STREAM;
pub const STGTY_LOCKBYTES = enum_tagSTGTY.STGTY_LOCKBYTES;
pub const STGTY_PROPERTY = enum_tagSTGTY.STGTY_PROPERTY;
pub const enum_tagSTGTY = extern enum {
    STGTY_STORAGE = 1,
    STGTY_STREAM = 2,
    STGTY_LOCKBYTES = 3,
    STGTY_PROPERTY = 4,
};
pub const STGTY = enum_tagSTGTY;
pub const STREAM_SEEK_SET = enum_tagSTREAM_SEEK.STREAM_SEEK_SET;
pub const STREAM_SEEK_CUR = enum_tagSTREAM_SEEK.STREAM_SEEK_CUR;
pub const STREAM_SEEK_END = enum_tagSTREAM_SEEK.STREAM_SEEK_END;
pub const enum_tagSTREAM_SEEK = extern enum {
    STREAM_SEEK_SET = 0,
    STREAM_SEEK_CUR = 1,
    STREAM_SEEK_END = 2,
};
pub const STREAM_SEEK = enum_tagSTREAM_SEEK;
pub const LOCK_WRITE = enum_tagLOCKTYPE.LOCK_WRITE;
pub const LOCK_EXCLUSIVE = enum_tagLOCKTYPE.LOCK_EXCLUSIVE;
pub const LOCK_ONLYONCE = enum_tagLOCKTYPE.LOCK_ONLYONCE;
pub const enum_tagLOCKTYPE = extern enum {
    LOCK_WRITE = 1,
    LOCK_EXCLUSIVE = 2,
    LOCK_ONLYONCE = 4,
};
pub const LOCKTYPE = enum_tagLOCKTYPE;
pub extern const IID_IStream: IID;
pub const IStreamVtbl = struct_IStreamVtbl;
pub extern fn IStream_RemoteSeek_Proxy(This: [*c]IStream, dlibMove: LARGE_INTEGER, dwOrigin: DWORD, plibNewPosition: [*c]ULARGE_INTEGER) HRESULT;
pub extern fn IStream_RemoteSeek_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IStream_RemoteCopyTo_Proxy(This: [*c]IStream, pstm: [*c]IStream, cb: ULARGE_INTEGER, pcbRead: [*c]ULARGE_INTEGER, pcbWritten: [*c]ULARGE_INTEGER) HRESULT;
pub extern fn IStream_RemoteCopyTo_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub const PRPCOLEMESSAGE = [*c]RPCOLEMESSAGE;
pub extern const IID_IRpcChannelBuffer: IID;
pub const IRpcChannelBufferVtbl = struct_IRpcChannelBufferVtbl;
pub extern var __MIDL_itf_objidlbase_0000_0015_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0015_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IRpcChannelBuffer2: IID;
pub const IRpcChannelBuffer2Vtbl = struct_IRpcChannelBuffer2Vtbl;
pub extern const IID_IAsyncRpcChannelBuffer: IID;
pub const IAsyncRpcChannelBufferVtbl = struct_IAsyncRpcChannelBufferVtbl;
pub extern const IID_IRpcChannelBuffer3: IID;
pub const IRpcChannelBuffer3Vtbl = struct_IRpcChannelBuffer3Vtbl;
pub extern const IID_IRpcSyntaxNegotiate: IID;
pub const IRpcSyntaxNegotiateVtbl = struct_IRpcSyntaxNegotiateVtbl;
pub extern const IID_IRpcProxyBuffer: IID;
pub const IRpcProxyBufferVtbl = struct_IRpcProxyBufferVtbl;
pub extern var __MIDL_itf_objidlbase_0000_0020_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0020_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IRpcStubBuffer: IID;
pub const IRpcStubBufferVtbl = struct_IRpcStubBufferVtbl;
pub extern const IID_IPSFactoryBuffer: IID;
pub const IPSFactoryBufferVtbl = struct_IPSFactoryBufferVtbl;
pub const struct_SChannelHookCallInfo = extern struct {
    iid: IID,
    cbSize: DWORD,
    uCausality: GUID,
    dwServerPid: DWORD,
    iMethod: DWORD,
    pObject: ?*c_void,
};
pub const SChannelHookCallInfo = struct_SChannelHookCallInfo;
pub extern var __MIDL_itf_objidlbase_0000_0022_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0022_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IChannelHook: IID;
pub const IChannelHookVtbl = struct_IChannelHookVtbl;
pub extern var __MIDL_itf_objidlbase_0000_0023_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0023_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const struct_tagSOLE_AUTHENTICATION_SERVICE = extern struct {
    dwAuthnSvc: DWORD,
    dwAuthzSvc: DWORD,
    pPrincipalName: [*c]OLECHAR,
    hr: HRESULT,
};
pub const SOLE_AUTHENTICATION_SERVICE = struct_tagSOLE_AUTHENTICATION_SERVICE;
pub const PSOLE_AUTHENTICATION_SERVICE = [*c]SOLE_AUTHENTICATION_SERVICE;
pub const EOAC_NONE = enum_tagEOLE_AUTHENTICATION_CAPABILITIES.EOAC_NONE;
pub const EOAC_MUTUAL_AUTH = enum_tagEOLE_AUTHENTICATION_CAPABILITIES.EOAC_MUTUAL_AUTH;
pub const EOAC_STATIC_CLOAKING = enum_tagEOLE_AUTHENTICATION_CAPABILITIES.EOAC_STATIC_CLOAKING;
pub const EOAC_DYNAMIC_CLOAKING = enum_tagEOLE_AUTHENTICATION_CAPABILITIES.EOAC_DYNAMIC_CLOAKING;
pub const EOAC_ANY_AUTHORITY = enum_tagEOLE_AUTHENTICATION_CAPABILITIES.EOAC_ANY_AUTHORITY;
pub const EOAC_MAKE_FULLSIC = enum_tagEOLE_AUTHENTICATION_CAPABILITIES.EOAC_MAKE_FULLSIC;
pub const EOAC_DEFAULT = enum_tagEOLE_AUTHENTICATION_CAPABILITIES.EOAC_DEFAULT;
pub const EOAC_SECURE_REFS = enum_tagEOLE_AUTHENTICATION_CAPABILITIES.EOAC_SECURE_REFS;
pub const EOAC_ACCESS_CONTROL = enum_tagEOLE_AUTHENTICATION_CAPABILITIES.EOAC_ACCESS_CONTROL;
pub const EOAC_APPID = enum_tagEOLE_AUTHENTICATION_CAPABILITIES.EOAC_APPID;
pub const EOAC_DYNAMIC = enum_tagEOLE_AUTHENTICATION_CAPABILITIES.EOAC_DYNAMIC;
pub const EOAC_REQUIRE_FULLSIC = enum_tagEOLE_AUTHENTICATION_CAPABILITIES.EOAC_REQUIRE_FULLSIC;
pub const EOAC_AUTO_IMPERSONATE = enum_tagEOLE_AUTHENTICATION_CAPABILITIES.EOAC_AUTO_IMPERSONATE;
pub const EOAC_DISABLE_AAA = enum_tagEOLE_AUTHENTICATION_CAPABILITIES.EOAC_DISABLE_AAA;
pub const EOAC_NO_CUSTOM_MARSHAL = enum_tagEOLE_AUTHENTICATION_CAPABILITIES.EOAC_NO_CUSTOM_MARSHAL;
pub const EOAC_RESERVED1 = enum_tagEOLE_AUTHENTICATION_CAPABILITIES.EOAC_RESERVED1;
pub const enum_tagEOLE_AUTHENTICATION_CAPABILITIES = extern enum {
    EOAC_NONE = 0,
    EOAC_MUTUAL_AUTH = 1,
    EOAC_STATIC_CLOAKING = 32,
    EOAC_DYNAMIC_CLOAKING = 64,
    EOAC_ANY_AUTHORITY = 128,
    EOAC_MAKE_FULLSIC = 256,
    EOAC_DEFAULT = 2048,
    EOAC_SECURE_REFS = 2,
    EOAC_ACCESS_CONTROL = 4,
    EOAC_APPID = 8,
    EOAC_DYNAMIC = 16,
    EOAC_REQUIRE_FULLSIC = 512,
    EOAC_AUTO_IMPERSONATE = 1024,
    EOAC_DISABLE_AAA = 4096,
    EOAC_NO_CUSTOM_MARSHAL = 8192,
    EOAC_RESERVED1 = 16384,
};
pub const EOLE_AUTHENTICATION_CAPABILITIES = enum_tagEOLE_AUTHENTICATION_CAPABILITIES;
pub const struct_tagSOLE_AUTHENTICATION_INFO = extern struct {
    dwAuthnSvc: DWORD,
    dwAuthzSvc: DWORD,
    pAuthInfo: ?*c_void,
};
pub const SOLE_AUTHENTICATION_INFO = struct_tagSOLE_AUTHENTICATION_INFO;
pub const PSOLE_AUTHENTICATION_INFO = [*c]struct_tagSOLE_AUTHENTICATION_INFO;
pub const struct_tagSOLE_AUTHENTICATION_LIST = extern struct {
    cAuthInfo: DWORD,
    aAuthInfo: [*c]SOLE_AUTHENTICATION_INFO,
};
pub const SOLE_AUTHENTICATION_LIST = struct_tagSOLE_AUTHENTICATION_LIST;
pub const PSOLE_AUTHENTICATION_LIST = [*c]struct_tagSOLE_AUTHENTICATION_LIST;
pub extern const IID_IClientSecurity: IID;
pub const IClientSecurityVtbl = struct_IClientSecurityVtbl;
pub extern var __MIDL_itf_objidlbase_0000_0024_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0024_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IServerSecurity: IID;
pub const IServerSecurityVtbl = struct_IServerSecurityVtbl;
pub const SERVER_LOCALITY_PROCESS_LOCAL = enum_tagRPCOPT_SERVER_LOCALITY_VALUES.SERVER_LOCALITY_PROCESS_LOCAL;
pub const SERVER_LOCALITY_MACHINE_LOCAL = enum_tagRPCOPT_SERVER_LOCALITY_VALUES.SERVER_LOCALITY_MACHINE_LOCAL;
pub const SERVER_LOCALITY_REMOTE = enum_tagRPCOPT_SERVER_LOCALITY_VALUES.SERVER_LOCALITY_REMOTE;
pub const enum_tagRPCOPT_SERVER_LOCALITY_VALUES = extern enum {
    SERVER_LOCALITY_PROCESS_LOCAL = 0,
    SERVER_LOCALITY_MACHINE_LOCAL = 1,
    SERVER_LOCALITY_REMOTE = 2,
};
pub const RPCOPT_SERVER_LOCALITY_VALUES = enum_tagRPCOPT_SERVER_LOCALITY_VALUES;
pub extern var __MIDL_itf_objidlbase_0000_0025_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0025_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IRpcOptions: IID;
pub const IRpcOptionsVtbl = struct_IRpcOptionsVtbl;
pub const COMGLB_EXCEPTION_HANDLE = enum_tagGLOBALOPT_EH_VALUES.COMGLB_EXCEPTION_HANDLE;
pub const COMGLB_EXCEPTION_DONOT_HANDLE_FATAL = enum_tagGLOBALOPT_EH_VALUES.COMGLB_EXCEPTION_DONOT_HANDLE_FATAL;
pub const COMGLB_EXCEPTION_DONOT_HANDLE = enum_tagGLOBALOPT_EH_VALUES.COMGLB_EXCEPTION_DONOT_HANDLE;
pub const COMGLB_EXCEPTION_DONOT_HANDLE_ANY = enum_tagGLOBALOPT_EH_VALUES.COMGLB_EXCEPTION_DONOT_HANDLE_ANY;
pub const enum_tagGLOBALOPT_EH_VALUES = extern enum {
    COMGLB_EXCEPTION_HANDLE = 0,
    COMGLB_EXCEPTION_DONOT_HANDLE_FATAL = 1,
    COMGLB_EXCEPTION_DONOT_HANDLE = 1,
    COMGLB_EXCEPTION_DONOT_HANDLE_ANY = 2,
};
pub const GLOBALOPT_EH_VALUES = enum_tagGLOBALOPT_EH_VALUES;
pub const COMGLB_RPC_THREADPOOL_SETTING_DEFAULT_POOL = enum_tagGLOBALOPT_RPCTP_VALUES.COMGLB_RPC_THREADPOOL_SETTING_DEFAULT_POOL;
pub const COMGLB_RPC_THREADPOOL_SETTING_PRIVATE_POOL = enum_tagGLOBALOPT_RPCTP_VALUES.COMGLB_RPC_THREADPOOL_SETTING_PRIVATE_POOL;
pub const enum_tagGLOBALOPT_RPCTP_VALUES = extern enum {
    COMGLB_RPC_THREADPOOL_SETTING_DEFAULT_POOL = 0,
    COMGLB_RPC_THREADPOOL_SETTING_PRIVATE_POOL = 1,
};
pub const GLOBALOPT_RPCTP_VALUES = enum_tagGLOBALOPT_RPCTP_VALUES;
pub const COMGLB_STA_MODALLOOP_REMOVE_TOUCH_MESSAGES = enum_tagGLOBALOPT_RO_FLAGS.COMGLB_STA_MODALLOOP_REMOVE_TOUCH_MESSAGES;
pub const COMGLB_STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES = enum_tagGLOBALOPT_RO_FLAGS.COMGLB_STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES;
pub const COMGLB_STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES = enum_tagGLOBALOPT_RO_FLAGS.COMGLB_STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES;
pub const COMGLB_FAST_RUNDOWN = enum_tagGLOBALOPT_RO_FLAGS.COMGLB_FAST_RUNDOWN;
pub const COMGLB_RESERVED1 = enum_tagGLOBALOPT_RO_FLAGS.COMGLB_RESERVED1;
pub const COMGLB_RESERVED2 = enum_tagGLOBALOPT_RO_FLAGS.COMGLB_RESERVED2;
pub const COMGLB_RESERVED3 = enum_tagGLOBALOPT_RO_FLAGS.COMGLB_RESERVED3;
pub const COMGLB_STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES = enum_tagGLOBALOPT_RO_FLAGS.COMGLB_STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES;
pub const COMGLB_RESERVED4 = enum_tagGLOBALOPT_RO_FLAGS.COMGLB_RESERVED4;
pub const COMGLB_RESERVED5 = enum_tagGLOBALOPT_RO_FLAGS.COMGLB_RESERVED5;
pub const COMGLB_RESERVED6 = enum_tagGLOBALOPT_RO_FLAGS.COMGLB_RESERVED6;
pub const enum_tagGLOBALOPT_RO_FLAGS = extern enum {
    COMGLB_STA_MODALLOOP_REMOVE_TOUCH_MESSAGES = 1,
    COMGLB_STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES = 2,
    COMGLB_STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES = 4,
    COMGLB_FAST_RUNDOWN = 8,
    COMGLB_RESERVED1 = 16,
    COMGLB_RESERVED2 = 32,
    COMGLB_RESERVED3 = 64,
    COMGLB_STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES = 128,
    COMGLB_RESERVED4 = 256,
    COMGLB_RESERVED5 = 512,
    COMGLB_RESERVED6 = 1024,
};
pub const GLOBALOPT_RO_FLAGS = enum_tagGLOBALOPT_RO_FLAGS;
pub const COMGLB_UNMARSHALING_POLICY_NORMAL = enum_tagGLOBALOPT_UNMARSHALING_POLICY_VALUES.COMGLB_UNMARSHALING_POLICY_NORMAL;
pub const COMGLB_UNMARSHALING_POLICY_STRONG = enum_tagGLOBALOPT_UNMARSHALING_POLICY_VALUES.COMGLB_UNMARSHALING_POLICY_STRONG;
pub const COMGLB_UNMARSHALING_POLICY_HYBRID = enum_tagGLOBALOPT_UNMARSHALING_POLICY_VALUES.COMGLB_UNMARSHALING_POLICY_HYBRID;
pub const enum_tagGLOBALOPT_UNMARSHALING_POLICY_VALUES = extern enum {
    COMGLB_UNMARSHALING_POLICY_NORMAL = 0,
    COMGLB_UNMARSHALING_POLICY_STRONG = 1,
    COMGLB_UNMARSHALING_POLICY_HYBRID = 2,
};
pub const GLOBALOPT_UNMARSHALING_POLICY_VALUES = enum_tagGLOBALOPT_UNMARSHALING_POLICY_VALUES;
pub extern var __MIDL_itf_objidlbase_0000_0026_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0026_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IGlobalOptions: IID;
pub const IGlobalOptionsVtbl = struct_IGlobalOptionsVtbl;
pub extern var __MIDL_itf_objidlbase_0000_0027_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0027_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPSURROGATE = [*c]ISurrogate;
pub extern const IID_ISurrogate: IID;
pub const ISurrogateVtbl = struct_ISurrogateVtbl;
pub const LPGLOBALINTERFACETABLE = [*c]IGlobalInterfaceTable;
pub extern const IID_IGlobalInterfaceTable: IID;
pub const IGlobalInterfaceTableVtbl = struct_IGlobalInterfaceTableVtbl;
pub extern var __MIDL_itf_objidlbase_0000_0029_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0029_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_ISynchronize: IID;
pub const ISynchronizeVtbl = struct_ISynchronizeVtbl;
pub extern const IID_ISynchronizeHandle: IID;
pub const ISynchronizeHandleVtbl = struct_ISynchronizeHandleVtbl;
pub extern const IID_ISynchronizeEvent: IID;
pub const ISynchronizeEventVtbl = struct_ISynchronizeEventVtbl;
pub extern const IID_ISynchronizeContainer: IID;
pub const ISynchronizeContainerVtbl = struct_ISynchronizeContainerVtbl;
pub extern const IID_ISynchronizeMutex: IID;
pub const ISynchronizeMutexVtbl = struct_ISynchronizeMutexVtbl;
pub const LPCANCELMETHODCALLS = [*c]ICancelMethodCalls;
pub extern const IID_ICancelMethodCalls: IID;
pub const ICancelMethodCallsVtbl = struct_ICancelMethodCallsVtbl;
pub const DCOM_NONE = enum_tagDCOM_CALL_STATE.DCOM_NONE;
pub const DCOM_CALL_COMPLETE = enum_tagDCOM_CALL_STATE.DCOM_CALL_COMPLETE;
pub const DCOM_CALL_CANCELED = enum_tagDCOM_CALL_STATE.DCOM_CALL_CANCELED;
pub const enum_tagDCOM_CALL_STATE = extern enum {
    DCOM_NONE = 0,
    DCOM_CALL_COMPLETE = 1,
    DCOM_CALL_CANCELED = 2,
};
pub const DCOM_CALL_STATE = enum_tagDCOM_CALL_STATE;
pub extern const IID_IAsyncManager: IID;
pub const IAsyncManagerVtbl = struct_IAsyncManagerVtbl;
pub extern const IID_ICallFactory: IID;
pub const ICallFactoryVtbl = struct_ICallFactoryVtbl;
pub extern const IID_IRpcHelper: IID;
pub const IRpcHelperVtbl = struct_IRpcHelperVtbl;
pub extern const IID_IReleaseMarshalBuffers: IID;
pub const IReleaseMarshalBuffersVtbl = struct_IReleaseMarshalBuffersVtbl;
pub extern const IID_IWaitMultiple: IID;
pub const IWaitMultipleVtbl = struct_IWaitMultipleVtbl;
pub const LPADDRTRACKINGCONTROL = [*c]IAddrTrackingControl;
pub extern const IID_IAddrTrackingControl: IID;
pub const IAddrTrackingControlVtbl = struct_IAddrTrackingControlVtbl;
pub const LPADDREXCLUSIONCONTROL = [*c]IAddrExclusionControl;
pub extern const IID_IAddrExclusionControl: IID;
pub const IAddrExclusionControlVtbl = struct_IAddrExclusionControlVtbl;
pub extern const IID_IPipeByte: IID;
pub const IPipeByteVtbl = struct_IPipeByteVtbl;
pub extern const IID_AsyncIPipeByte: IID;
pub const AsyncIPipeByteVtbl = struct_AsyncIPipeByteVtbl;
pub extern const IID_IPipeLong: IID;
pub const IPipeLongVtbl = struct_IPipeLongVtbl;
pub extern const IID_AsyncIPipeLong: IID;
pub const AsyncIPipeLongVtbl = struct_AsyncIPipeLongVtbl;
pub extern const IID_IPipeDouble: IID;
pub const IPipeDoubleVtbl = struct_IPipeDoubleVtbl;
pub extern const IID_AsyncIPipeDouble: IID;
pub const AsyncIPipeDoubleVtbl = struct_AsyncIPipeDoubleVtbl;
pub const APTTYPEQUALIFIER_NONE = enum__APTTYPEQUALIFIER.APTTYPEQUALIFIER_NONE;
pub const APTTYPEQUALIFIER_IMPLICIT_MTA = enum__APTTYPEQUALIFIER.APTTYPEQUALIFIER_IMPLICIT_MTA;
pub const APTTYPEQUALIFIER_NA_ON_MTA = enum__APTTYPEQUALIFIER.APTTYPEQUALIFIER_NA_ON_MTA;
pub const APTTYPEQUALIFIER_NA_ON_STA = enum__APTTYPEQUALIFIER.APTTYPEQUALIFIER_NA_ON_STA;
pub const APTTYPEQUALIFIER_NA_ON_IMPLICIT_MTA = enum__APTTYPEQUALIFIER.APTTYPEQUALIFIER_NA_ON_IMPLICIT_MTA;
pub const APTTYPEQUALIFIER_NA_ON_MAINSTA = enum__APTTYPEQUALIFIER.APTTYPEQUALIFIER_NA_ON_MAINSTA;
pub const APTTYPEQUALIFIER_APPLICATION_STA = enum__APTTYPEQUALIFIER.APTTYPEQUALIFIER_APPLICATION_STA;
pub const APTTYPEQUALIFIER_RESERVED_1 = enum__APTTYPEQUALIFIER.APTTYPEQUALIFIER_RESERVED_1;
pub const enum__APTTYPEQUALIFIER = extern enum {
    APTTYPEQUALIFIER_NONE = 0,
    APTTYPEQUALIFIER_IMPLICIT_MTA = 1,
    APTTYPEQUALIFIER_NA_ON_MTA = 2,
    APTTYPEQUALIFIER_NA_ON_STA = 3,
    APTTYPEQUALIFIER_NA_ON_IMPLICIT_MTA = 4,
    APTTYPEQUALIFIER_NA_ON_MAINSTA = 5,
    APTTYPEQUALIFIER_APPLICATION_STA = 6,
    APTTYPEQUALIFIER_RESERVED_1 = 7,
};
pub const APTTYPEQUALIFIER = enum__APTTYPEQUALIFIER;
pub const APARTMENTID = DWORD;
pub extern var __MIDL_itf_objidlbase_0000_0048_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0048_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IComThreadingInfo: IID;
pub const IComThreadingInfoVtbl = struct_IComThreadingInfoVtbl;
pub extern const IID_IProcessInitControl: IID;
pub const IProcessInitControlVtbl = struct_IProcessInitControlVtbl;
pub extern const IID_IFastRundown: IID;
pub const IFastRundownVtbl = struct_IFastRundownVtbl;
pub extern var __MIDL_itf_objidlbase_0000_0051_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0051_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IMarshalingStream: IID;
pub const IMarshalingStreamVtbl = struct_IMarshalingStreamVtbl;
pub extern var __MIDL_itf_objidlbase_0000_0052_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0052_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IAgileReference: IID;
pub const IAgileReferenceVtbl = struct_IAgileReferenceVtbl;
pub extern const IID_ICallbackWithNoReentrancyToApplicationSTA: GUID;
pub extern var __MIDL_itf_objidlbase_0000_0053_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidlbase_0000_0053_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern fn IEnumUnknown_Next_Proxy(This: [*c]IEnumUnknown, celt: ULONG, rgelt: [*c]([*c]IUnknown), pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumUnknown_Next_Stub(This: [*c]IEnumUnknown, celt: ULONG, rgelt: [*c]([*c]IUnknown), pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumString_Next_Proxy(This: [*c]IEnumString, celt: ULONG, rgelt: [*c]LPOLESTR, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumString_Next_Stub(This: [*c]IEnumString, celt: ULONG, rgelt: [*c]LPOLESTR, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn ISequentialStream_Read_Proxy(This: [*c]ISequentialStream, pv: ?*c_void, cb: ULONG, pcbRead: [*c]ULONG) HRESULT;
pub extern fn ISequentialStream_Read_Stub(This: [*c]ISequentialStream, pv: [*c]byte, cb: ULONG, pcbRead: [*c]ULONG) HRESULT;
pub extern fn ISequentialStream_Write_Proxy(This: [*c]ISequentialStream, pv: ?*const c_void, cb: ULONG, pcbWritten: [*c]ULONG) HRESULT;
pub extern fn ISequentialStream_Write_Stub(This: [*c]ISequentialStream, pv: [*c]const byte, cb: ULONG, pcbWritten: [*c]ULONG) HRESULT;
pub extern fn IStream_Seek_Proxy(This: [*c]IStream, dlibMove: LARGE_INTEGER, dwOrigin: DWORD, plibNewPosition: [*c]ULARGE_INTEGER) HRESULT;
pub extern fn IStream_Seek_Stub(This: [*c]IStream, dlibMove: LARGE_INTEGER, dwOrigin: DWORD, plibNewPosition: [*c]ULARGE_INTEGER) HRESULT;
pub extern fn IStream_CopyTo_Proxy(This: [*c]IStream, pstm: [*c]IStream, cb: ULARGE_INTEGER, pcbRead: [*c]ULARGE_INTEGER, pcbWritten: [*c]ULARGE_INTEGER) HRESULT;
pub extern fn IStream_CopyTo_Stub(This: [*c]IStream, pstm: [*c]IStream, cb: ULARGE_INTEGER, pcbRead: [*c]ULARGE_INTEGER, pcbWritten: [*c]ULARGE_INTEGER) HRESULT;
pub extern const GUID_NULL: IID;
pub extern const CATID_MARSHALER: IID;
pub extern const IID_IRpcChannel: IID;
pub extern const IID_IRpcStub: IID;
pub extern const IID_IStubManager: IID;
pub extern const IID_IRpcProxy: IID;
pub extern const IID_IProxyManager: IID;
pub extern const IID_IPSFactory: IID;
pub extern const IID_IInternalMoniker: IID;
pub extern const IID_IDfReserved1: IID;
pub extern const IID_IDfReserved2: IID;
pub extern const IID_IDfReserved3: IID;
pub extern const CLSID_StdMarshal: CLSID;
pub extern const CLSID_AggStdMarshal: CLSID;
pub extern const CLSID_StdAsyncActManager: CLSID;
pub extern const IID_IStub: IID;
pub extern const IID_IProxy: IID;
pub extern const IID_IEnumGeneric: IID;
pub extern const IID_IEnumHolder: IID;
pub extern const IID_IEnumCallback: IID;
pub extern const IID_IOleManager: IID;
pub extern const IID_IOlePresObj: IID;
pub extern const IID_IDebug: IID;
pub extern const IID_IDebugStream: IID;
pub extern const CLSID_PSGenObject: CLSID;
pub extern const CLSID_PSClientSite: CLSID;
pub extern const CLSID_PSClassObject: CLSID;
pub extern const CLSID_PSInPlaceActive: CLSID;
pub extern const CLSID_PSInPlaceFrame: CLSID;
pub extern const CLSID_PSDragDrop: CLSID;
pub extern const CLSID_PSBindCtx: CLSID;
pub extern const CLSID_PSEnumerators: CLSID;
pub extern const CLSID_StaticMetafile: CLSID;
pub extern const CLSID_StaticDib: CLSID;
pub extern const CID_CDfsVolume: CLSID;
pub extern const CLSID_DCOMAccessControl: CLSID;
pub extern const CLSID_GlobalOptions: CLSID;
pub extern const CLSID_StdGlobalInterfaceTable: CLSID;
pub extern const CLSID_ComBinding: CLSID;
pub extern const CLSID_StdEvent: CLSID;
pub extern const CLSID_ManualResetEvent: CLSID;
pub extern const CLSID_SynchronizeContainer: CLSID;
pub extern const CLSID_AddrControl: CLSID;
pub extern const CLSID_ContextSwitcher: CLSID;
pub extern const CLSID_CCDFormKrnl: CLSID;
pub extern const CLSID_CCDPropertyPage: CLSID;
pub extern const CLSID_CCDFormDialog: CLSID;
pub extern const CLSID_CCDCommandButton: CLSID;
pub extern const CLSID_CCDComboBox: CLSID;
pub extern const CLSID_CCDTextBox: CLSID;
pub extern const CLSID_CCDCheckBox: CLSID;
pub extern const CLSID_CCDLabel: CLSID;
pub extern const CLSID_CCDOptionButton: CLSID;
pub extern const CLSID_CCDListBox: CLSID;
pub extern const CLSID_CCDScrollBar: CLSID;
pub extern const CLSID_CCDGroupBox: CLSID;
pub extern const CLSID_CCDGeneralPropertyPage: CLSID;
pub extern const CLSID_CCDGenericPropertyPage: CLSID;
pub extern const CLSID_CCDFontPropertyPage: CLSID;
pub extern const CLSID_CCDColorPropertyPage: CLSID;
pub extern const CLSID_CCDLabelPropertyPage: CLSID;
pub extern const CLSID_CCDCheckBoxPropertyPage: CLSID;
pub extern const CLSID_CCDTextBoxPropertyPage: CLSID;
pub extern const CLSID_CCDOptionButtonPropertyPage: CLSID;
pub extern const CLSID_CCDListBoxPropertyPage: CLSID;
pub extern const CLSID_CCDCommandButtonPropertyPage: CLSID;
pub extern const CLSID_CCDComboBoxPropertyPage: CLSID;
pub extern const CLSID_CCDScrollBarPropertyPage: CLSID;
pub extern const CLSID_CCDGroupBoxPropertyPage: CLSID;
pub extern const CLSID_CCDXObjectPropertyPage: CLSID;
pub extern const CLSID_CStdPropertyFrame: CLSID;
pub extern const CLSID_CFormPropertyPage: CLSID;
pub extern const CLSID_CGridPropertyPage: CLSID;
pub extern const CLSID_CWSJArticlePage: CLSID;
pub extern const CLSID_CSystemPage: CLSID;
pub extern const CLSID_IdentityUnmarshal: CLSID;
pub extern const CLSID_InProcFreeMarshaler: CLSID;
pub extern const CLSID_Picture_Metafile: CLSID;
pub extern const CLSID_Picture_EnhMetafile: CLSID;
pub extern const CLSID_Picture_Dib: CLSID;
pub extern const GUID_TRISTATE: GUID;
pub extern "ole32" fn CoGetMalloc(dwMemContext: DWORD, ppMalloc: [*c]LPMALLOC) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CreateStreamOnHGlobal(hGlobal: HGLOBAL, fDeleteOnRelease: BOOL, ppstm: [*c]LPSTREAM) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn GetHGlobalFromStream(pstm: LPSTREAM, phglobal: [*c]HGLOBAL) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoUninitialize() callconv(.Stdcall) void;
pub extern "ole32" fn CoGetCurrentProcess() callconv(.Stdcall) DWORD;
pub extern "ole32" fn CoInitializeEx(pvReserved: LPVOID, dwCoInit: DWORD) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoGetCallerTID(lpdwTID: LPDWORD) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoGetCurrentLogicalThreadId(pguid: [*c]GUID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoGetContextToken(pToken: [*c]ULONG_PTR) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoGetDefaultContext(aptType: APTTYPE, riid: [*c]const IID, ppv: [*c](?*c_void)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoGetApartmentType(pAptType: [*c]APTTYPE, pAptQualifier: [*c]APTTYPEQUALIFIER) callconv(.Stdcall) HRESULT;
pub const struct_tagServerInformation = extern struct {
    dwServerPid: DWORD,
    dwServerTid: DWORD,
    ui64ServerAddress: UINT64,
};
pub const ServerInformation = struct_tagServerInformation;
pub const PServerInformation = [*c]struct_tagServerInformation;
pub extern "ole32" fn CoDecodeProxy(dwClientPid: DWORD, ui64ProxyAddress: UINT64, pServerInformation: PServerInformation) callconv(.Stdcall) HRESULT;
pub const struct_CO_MTA_USAGE_COOKIE__ = extern struct {
    unused: c_int,
};
pub const CO_MTA_USAGE_COOKIE = [*c]struct_CO_MTA_USAGE_COOKIE__;
pub extern "ole32" fn CoIncrementMTAUsage(pCookie: [*c]CO_MTA_USAGE_COOKIE) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoDecrementMTAUsage(Cookie: CO_MTA_USAGE_COOKIE) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoAllowUnmarshalerCLSID(clsid: [*c]const IID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoGetObjectContext(riid: [*c]const IID, ppv: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoGetClassObject(rclsid: [*c]const IID, dwClsContext: DWORD, pvReserved: LPVOID, riid: [*c]const IID, ppv: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoRegisterClassObject(rclsid: [*c]const IID, pUnk: LPUNKNOWN, dwClsContext: DWORD, flags: DWORD, lpdwRegister: LPDWORD) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoRevokeClassObject(dwRegister: DWORD) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoResumeClassObjects() callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoSuspendClassObjects() callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoAddRefServerProcess() callconv(.Stdcall) ULONG;
pub extern "ole32" fn CoReleaseServerProcess() callconv(.Stdcall) ULONG;
pub extern "ole32" fn CoGetPSClsid(riid: [*c]const IID, pClsid: [*c]CLSID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoRegisterPSClsid(riid: [*c]const IID, rclsid: [*c]const IID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoRegisterSurrogate(pSurrogate: LPSURROGATE) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoGetMarshalSizeMax(pulSize: [*c]ULONG, riid: [*c]const IID, pUnk: LPUNKNOWN, dwDestContext: DWORD, pvDestContext: LPVOID, mshlflags: DWORD) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoMarshalInterface(pStm: LPSTREAM, riid: [*c]const IID, pUnk: LPUNKNOWN, dwDestContext: DWORD, pvDestContext: LPVOID, mshlflags: DWORD) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoUnmarshalInterface(pStm: LPSTREAM, riid: [*c]const IID, ppv: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoMarshalHresult(pstm: LPSTREAM, hresult: HRESULT) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoUnmarshalHresult(pstm: LPSTREAM, phresult: [*c]HRESULT) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoReleaseMarshalData(pStm: LPSTREAM) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoDisconnectObject(pUnk: LPUNKNOWN, dwReserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoLockObjectExternal(pUnk: LPUNKNOWN, fLock: BOOL, fLastUnlockReleases: BOOL) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoGetStandardMarshal(riid: [*c]const IID, pUnk: LPUNKNOWN, dwDestContext: DWORD, pvDestContext: LPVOID, mshlflags: DWORD, ppMarshal: [*c]LPMARSHAL) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoGetStdMarshalEx(pUnkOuter: LPUNKNOWN, smexflags: DWORD, ppUnkInner: [*c]LPUNKNOWN) callconv(.Stdcall) HRESULT;
pub const SMEXF_SERVER = enum_tagSTDMSHLFLAGS.SMEXF_SERVER;
pub const SMEXF_HANDLER = enum_tagSTDMSHLFLAGS.SMEXF_HANDLER;
pub const enum_tagSTDMSHLFLAGS = extern enum {
    SMEXF_SERVER = 1,
    SMEXF_HANDLER = 2,
};
pub const STDMSHLFLAGS = enum_tagSTDMSHLFLAGS;
pub extern "ole32" fn CoIsHandlerConnected(pUnk: LPUNKNOWN) callconv(.Stdcall) BOOL;
pub extern "ole32" fn CoMarshalInterThreadInterfaceInStream(riid: [*c]const IID, pUnk: LPUNKNOWN, ppStm: [*c]LPSTREAM) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoGetInterfaceAndReleaseStream(pStm: LPSTREAM, iid: [*c]const IID, ppv: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoCreateFreeThreadedMarshaler(punkOuter: LPUNKNOWN, ppunkMarshal: [*c]LPUNKNOWN) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoFreeUnusedLibraries() callconv(.Stdcall) void;
pub extern "ole32" fn CoFreeUnusedLibrariesEx(dwUnloadDelay: DWORD, dwReserved: DWORD) callconv(.Stdcall) void;
pub extern "ole32" fn CoDisconnectContext(dwTimeout: DWORD) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoInitializeSecurity(pSecDesc: PSECURITY_DESCRIPTOR, cAuthSvc: LONG, asAuthSvc: [*c]SOLE_AUTHENTICATION_SERVICE, pReserved1: ?*c_void, dwAuthnLevel: DWORD, dwImpLevel: DWORD, pAuthList: ?*c_void, dwCapabilities: DWORD, pReserved3: ?*c_void) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoGetCallContext(riid: [*c]const IID, ppInterface: [*c](?*c_void)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoQueryProxyBlanket(pProxy: [*c]IUnknown, pwAuthnSvc: [*c]DWORD, pAuthzSvc: [*c]DWORD, pServerPrincName: [*c]LPOLESTR, pAuthnLevel: [*c]DWORD, pImpLevel: [*c]DWORD, pAuthInfo: [*c]RPC_AUTH_IDENTITY_HANDLE, pCapabilites: [*c]DWORD) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoSetProxyBlanket(pProxy: [*c]IUnknown, dwAuthnSvc: DWORD, dwAuthzSvc: DWORD, pServerPrincName: [*c]OLECHAR, dwAuthnLevel: DWORD, dwImpLevel: DWORD, pAuthInfo: RPC_AUTH_IDENTITY_HANDLE, dwCapabilities: DWORD) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoCopyProxy(pProxy: [*c]IUnknown, ppCopy: [*c]([*c]IUnknown)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoQueryClientBlanket(pAuthnSvc: [*c]DWORD, pAuthzSvc: [*c]DWORD, pServerPrincName: [*c]LPOLESTR, pAuthnLevel: [*c]DWORD, pImpLevel: [*c]DWORD, pPrivs: [*c]RPC_AUTHZ_HANDLE, pCapabilities: [*c]DWORD) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoImpersonateClient() callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoRevertToSelf() callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoQueryAuthenticationServices(pcAuthSvc: [*c]DWORD, asAuthSvc: [*c]([*c]SOLE_AUTHENTICATION_SERVICE)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoSwitchCallContext(pNewObject: [*c]IUnknown, ppOldObject: [*c]([*c]IUnknown)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoCreateInstance(rclsid: [*c]const IID, pUnkOuter: LPUNKNOWN, dwClsContext: DWORD, riid: [*c]const IID, ppv: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoCreateInstanceEx(Clsid: [*c]const IID, punkOuter: [*c]IUnknown, dwClsCtx: DWORD, pServerInfo: [*c]COSERVERINFO, dwCount: DWORD, pResults: [*c]MULTI_QI) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoRegisterActivationFilter(pActivationFilter: [*c]IActivationFilter) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoCreateInstanceFromApp(Clsid: [*c]const IID, punkOuter: [*c]IUnknown, dwClsCtx: DWORD, reserved: PVOID, dwCount: DWORD, pResults: [*c]MULTI_QI) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoGetCancelObject(dwThreadId: DWORD, iid: [*c]const IID, ppUnk: [*c](?*c_void)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoSetCancelObject(pUnk: [*c]IUnknown) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoCancelCall(dwThreadId: DWORD, ulTimeout: ULONG) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoTestCancel() callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoEnableCallCancellation(pReserved: LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoDisableCallCancellation(pReserved: LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn StringFromCLSID(rclsid: [*c]const IID, lplpsz: [*c]LPOLESTR) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CLSIDFromString(lpsz: LPCOLESTR, pclsid: LPCLSID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn StringFromIID(rclsid: [*c]const IID, lplpsz: [*c]LPOLESTR) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn IIDFromString(lpsz: LPCOLESTR, lpiid: LPIID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn ProgIDFromCLSID(clsid: [*c]const IID, lplpszProgID: [*c]LPOLESTR) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CLSIDFromProgID(lpszProgID: LPCOLESTR, lpclsid: LPCLSID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn StringFromGUID2(rguid: [*c]const GUID, lpsz: LPOLESTR, cchMax: c_int) callconv(.Stdcall) c_int;
pub extern "ole32" fn CoCreateGuid(pguid: [*c]GUID) callconv(.Stdcall) HRESULT;
pub const PROPVAR_PAD1 = WORD;
pub const PROPVAR_PAD2 = WORD;
pub const PROPVAR_PAD3 = WORD;
pub const DISPID = LONG;
pub const MEMBERID = DISPID;
pub const TKIND_ENUM = enum_tagTYPEKIND.TKIND_ENUM;
pub const TKIND_RECORD = enum_tagTYPEKIND.TKIND_RECORD;
pub const TKIND_MODULE = enum_tagTYPEKIND.TKIND_MODULE;
pub const TKIND_INTERFACE = enum_tagTYPEKIND.TKIND_INTERFACE;
pub const TKIND_DISPATCH = enum_tagTYPEKIND.TKIND_DISPATCH;
pub const TKIND_COCLASS = enum_tagTYPEKIND.TKIND_COCLASS;
pub const TKIND_ALIAS = enum_tagTYPEKIND.TKIND_ALIAS;
pub const TKIND_UNION = enum_tagTYPEKIND.TKIND_UNION;
pub const TKIND_MAX = enum_tagTYPEKIND.TKIND_MAX;
pub const enum_tagTYPEKIND = extern enum {
    TKIND_ENUM = 0,
    TKIND_RECORD = 1,
    TKIND_MODULE = 2,
    TKIND_INTERFACE = 3,
    TKIND_DISPATCH = 4,
    TKIND_COCLASS = 5,
    TKIND_ALIAS = 6,
    TKIND_UNION = 7,
    TKIND_MAX = 8,
};
pub const TYPEKIND = extern enum {
    TKIND_ENUM = 0,
    TKIND_RECORD = 1,
    TKIND_MODULE = 2,
    TKIND_INTERFACE = 3,
    TKIND_DISPATCH = 4,
    TKIND_COCLASS = 5,
    TKIND_ALIAS = 6,
    TKIND_UNION = 7,
    TKIND_MAX = 8,
};
pub const struct_tagSAFEARRAYBOUND = extern struct {
    cElements: ULONG,
    lLbound: LONG,
};
pub const SAFEARRAYBOUND = struct_tagSAFEARRAYBOUND;
pub const struct_tagARRAYDESC = extern struct {
    tdescElem: TYPEDESC,
    cDims: USHORT,
    rgbounds: [1]SAFEARRAYBOUND,
};
pub const HREFTYPE = DWORD;
pub const struct_tagTYPEDESC = extern struct {
    @"": extern union {
        lptdesc: [*c]struct_tagTYPEDESC,
        lpadesc: [*c]struct_tagARRAYDESC,
        hreftype: HREFTYPE,
    },
    vt: VARTYPE,
};
pub const TYPEDESC = struct_tagTYPEDESC;
pub const struct_tagIDLDESC = extern struct {
    dwReserved: ULONG_PTR,
    wIDLFlags: USHORT,
};
pub const IDLDESC = struct_tagIDLDESC;
pub const struct_tagTYPEATTR = extern struct {
    guid: GUID,
    lcid: LCID,
    dwReserved: DWORD,
    memidConstructor: MEMBERID,
    memidDestructor: MEMBERID,
    lpstrSchema: LPOLESTR,
    cbSizeInstance: ULONG,
    typekind: TYPEKIND,
    cFuncs: WORD,
    cVars: WORD,
    cImplTypes: WORD,
    cbSizeVft: WORD,
    cbAlignment: WORD,
    wTypeFlags: WORD,
    wMajorVerNum: WORD,
    wMinorVerNum: WORD,
    tdescAlias: TYPEDESC,
    idldescType: IDLDESC,
};
pub const TYPEATTR = struct_tagTYPEATTR;
pub const DESCKIND_NONE = enum_tagDESCKIND.DESCKIND_NONE;
pub const DESCKIND_FUNCDESC = enum_tagDESCKIND.DESCKIND_FUNCDESC;
pub const DESCKIND_VARDESC = enum_tagDESCKIND.DESCKIND_VARDESC;
pub const DESCKIND_TYPECOMP = enum_tagDESCKIND.DESCKIND_TYPECOMP;
pub const DESCKIND_IMPLICITAPPOBJ = enum_tagDESCKIND.DESCKIND_IMPLICITAPPOBJ;
pub const DESCKIND_MAX = enum_tagDESCKIND.DESCKIND_MAX;
pub const enum_tagDESCKIND = extern enum {
    DESCKIND_NONE = 0,
    DESCKIND_FUNCDESC = 1,
    DESCKIND_VARDESC = 2,
    DESCKIND_TYPECOMP = 3,
    DESCKIND_IMPLICITAPPOBJ = 4,
    DESCKIND_MAX = 5,
};
pub const DESCKIND = extern enum {
    DESCKIND_NONE = 0,
    DESCKIND_FUNCDESC = 1,
    DESCKIND_VARDESC = 2,
    DESCKIND_TYPECOMP = 3,
    DESCKIND_IMPLICITAPPOBJ = 4,
    DESCKIND_MAX = 5,
};
pub const struct_tagSAFEARRAY = extern struct {
    cDims: USHORT,
    fFeatures: USHORT,
    cbElements: ULONG,
    cLocks: ULONG,
    pvData: PVOID,
    rgsabound: [1]SAFEARRAYBOUND,
};
pub const SAFEARRAY = struct_tagSAFEARRAY;
pub const struct_IRecordInfoVtbl = extern struct {
    QueryInterface: ?fn ([*c]IRecordInfo, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IRecordInfo) callconv(.C) ULONG,
    Release: ?fn ([*c]IRecordInfo) callconv(.C) ULONG,
    RecordInit: ?fn ([*c]IRecordInfo, PVOID) callconv(.C) HRESULT,
    RecordClear: ?fn ([*c]IRecordInfo, PVOID) callconv(.C) HRESULT,
    RecordCopy: ?fn ([*c]IRecordInfo, PVOID, PVOID) callconv(.C) HRESULT,
    GetGuid: ?fn ([*c]IRecordInfo, [*c]GUID) callconv(.C) HRESULT,
    GetName: ?fn ([*c]IRecordInfo, [*c]BSTR) callconv(.C) HRESULT,
    GetSize: ?fn ([*c]IRecordInfo, [*c]ULONG) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IRecordInfo, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetField: ?fn ([*c]IRecordInfo, PVOID, LPCOLESTR, [*c]VARIANT) callconv(.C) HRESULT,
    GetFieldNoCopy: ?fn ([*c]IRecordInfo, PVOID, LPCOLESTR, [*c]VARIANT, [*c]PVOID) callconv(.C) HRESULT,
    PutField: ?fn ([*c]IRecordInfo, ULONG, PVOID, LPCOLESTR, [*c]VARIANT) callconv(.C) HRESULT,
    PutFieldNoCopy: ?fn ([*c]IRecordInfo, ULONG, PVOID, LPCOLESTR, [*c]VARIANT) callconv(.C) HRESULT,
    GetFieldNames: ?fn ([*c]IRecordInfo, [*c]ULONG, [*c]BSTR) callconv(.C) HRESULT,
    IsMatchingType: ?fn ([*c]IRecordInfo, [*c]IRecordInfo) callconv(.C) BOOL,
    RecordCreate: ?fn ([*c]IRecordInfo) callconv(.C) PVOID,
    RecordCreateCopy: ?fn ([*c]IRecordInfo, PVOID, [*c]PVOID) callconv(.C) HRESULT,
    RecordDestroy: ?fn ([*c]IRecordInfo, PVOID) callconv(.C) HRESULT,
};
pub const struct_IRecordInfo = extern struct {
    lpVtbl: [*c]struct_IRecordInfoVtbl,
};
pub const IRecordInfo = struct_IRecordInfo;
pub const struct_tagVARIANT = extern struct {
    @"": extern union {
        @"": extern struct {
            vt: VARTYPE,
            wReserved1: WORD,
            wReserved2: WORD,
            wReserved3: WORD,
            @"": extern union {
                llVal: LONGLONG,
                lVal: LONG,
                bVal: BYTE,
                iVal: SHORT,
                fltVal: FLOAT,
                dblVal: DOUBLE,
                boolVal: VARIANT_BOOL,
                __OBSOLETE__VARIANT_BOOL: VARIANT_BOOL,
                scode: SCODE,
                cyVal: CY,
                date: DATE,
                bstrVal: BSTR,
                punkVal: [*c]IUnknown,
                pdispVal: [*c]IDispatch,
                parray: [*c]SAFEARRAY,
                pbVal: [*c]BYTE,
                piVal: [*c]SHORT,
                plVal: [*c]LONG,
                pllVal: [*c]LONGLONG,
                pfltVal: [*c]FLOAT,
                pdblVal: [*c]DOUBLE,
                pboolVal: [*c]VARIANT_BOOL,
                __OBSOLETE__VARIANT_PBOOL: [*c]VARIANT_BOOL,
                pscode: [*c]SCODE,
                pcyVal: [*c]CY,
                pdate: [*c]DATE,
                pbstrVal: [*c]BSTR,
                ppunkVal: [*c]([*c]IUnknown),
                ppdispVal: [*c]([*c]IDispatch),
                pparray: [*c]([*c]SAFEARRAY),
                pvarVal: [*c]VARIANT,
                byref: PVOID,
                cVal: CHAR,
                uiVal: USHORT,
                ulVal: ULONG,
                ullVal: ULONGLONG,
                intVal: INT,
                uintVal: UINT,
                pdecVal: [*c]DECIMAL,
                pcVal: [*c]CHAR,
                puiVal: [*c]USHORT,
                pulVal: [*c]ULONG,
                pullVal: [*c]ULONGLONG,
                pintVal: [*c]INT,
                puintVal: [*c]UINT,
                @"": extern struct {
                    pvRecord: PVOID,
                    pRecInfo: [*c]IRecordInfo,
                },
            },
        },
        decVal: DECIMAL,
    },
};
pub const VARIANT = struct_tagVARIANT;
pub const VARIANTARG = VARIANT;
pub const struct_tagPARAMDESCEX = extern struct {
    cBytes: ULONG,
    varDefaultValue: VARIANTARG,
};
pub const LPPARAMDESCEX = [*c]struct_tagPARAMDESCEX;
pub const struct_tagPARAMDESC = extern struct {
    pparamdescex: LPPARAMDESCEX,
    wParamFlags: USHORT,
};
pub const PARAMDESC = struct_tagPARAMDESC;
pub const struct_tagELEMDESC = extern struct {
    tdesc: TYPEDESC,
    @"": extern union {
        idldesc: IDLDESC,
        paramdesc: PARAMDESC,
    },
};
pub const ELEMDESC = struct_tagELEMDESC;
pub const FUNC_VIRTUAL = enum_tagFUNCKIND.FUNC_VIRTUAL;
pub const FUNC_PUREVIRTUAL = enum_tagFUNCKIND.FUNC_PUREVIRTUAL;
pub const FUNC_NONVIRTUAL = enum_tagFUNCKIND.FUNC_NONVIRTUAL;
pub const FUNC_STATIC = enum_tagFUNCKIND.FUNC_STATIC;
pub const FUNC_DISPATCH = enum_tagFUNCKIND.FUNC_DISPATCH;
pub const enum_tagFUNCKIND = extern enum {
    FUNC_VIRTUAL = 0,
    FUNC_PUREVIRTUAL = 1,
    FUNC_NONVIRTUAL = 2,
    FUNC_STATIC = 3,
    FUNC_DISPATCH = 4,
};
pub const FUNCKIND = extern enum {
    FUNC_VIRTUAL = 0,
    FUNC_PUREVIRTUAL = 1,
    FUNC_NONVIRTUAL = 2,
    FUNC_STATIC = 3,
    FUNC_DISPATCH = 4,
};
pub const INVOKE_FUNC = enum_tagINVOKEKIND.INVOKE_FUNC;
pub const INVOKE_PROPERTYGET = enum_tagINVOKEKIND.INVOKE_PROPERTYGET;
pub const INVOKE_PROPERTYPUT = enum_tagINVOKEKIND.INVOKE_PROPERTYPUT;
pub const INVOKE_PROPERTYPUTREF = enum_tagINVOKEKIND.INVOKE_PROPERTYPUTREF;
pub const enum_tagINVOKEKIND = extern enum {
    INVOKE_FUNC = 1,
    INVOKE_PROPERTYGET = 2,
    INVOKE_PROPERTYPUT = 4,
    INVOKE_PROPERTYPUTREF = 8,
};
pub const INVOKEKIND = extern enum {
    INVOKE_FUNC = 1,
    INVOKE_PROPERTYGET = 2,
    INVOKE_PROPERTYPUT = 4,
    INVOKE_PROPERTYPUTREF = 8,
};
pub const CC_FASTCALL = enum_tagCALLCONV.CC_FASTCALL;
pub const CC_CDECL = enum_tagCALLCONV.CC_CDECL;
pub const CC_MSCPASCAL = enum_tagCALLCONV.CC_MSCPASCAL;
pub const CC_PASCAL = enum_tagCALLCONV.CC_PASCAL;
pub const CC_MACPASCAL = enum_tagCALLCONV.CC_MACPASCAL;
pub const CC_STDCALL = enum_tagCALLCONV.CC_STDCALL;
pub const CC_FPFASTCALL = enum_tagCALLCONV.CC_FPFASTCALL;
pub const CC_SYSCALL = enum_tagCALLCONV.CC_SYSCALL;
pub const CC_MPWCDECL = enum_tagCALLCONV.CC_MPWCDECL;
pub const CC_MPWPASCAL = enum_tagCALLCONV.CC_MPWPASCAL;
pub const CC_MAX = enum_tagCALLCONV.CC_MAX;
pub const enum_tagCALLCONV = extern enum {
    CC_FASTCALL = 0,
    CC_CDECL = 1,
    CC_MSCPASCAL = 2,
    CC_PASCAL = 2,
    CC_MACPASCAL = 3,
    CC_STDCALL = 4,
    CC_FPFASTCALL = 5,
    CC_SYSCALL = 6,
    CC_MPWCDECL = 7,
    CC_MPWPASCAL = 8,
    CC_MAX = 9,
};
pub const CALLCONV = extern enum {
    CC_FASTCALL = 0,
    CC_CDECL = 1,
    CC_MSCPASCAL = 2,
    CC_PASCAL = 2,
    CC_MACPASCAL = 3,
    CC_STDCALL = 4,
    CC_FPFASTCALL = 5,
    CC_SYSCALL = 6,
    CC_MPWCDECL = 7,
    CC_MPWPASCAL = 8,
    CC_MAX = 9,
};
pub const struct_tagFUNCDESC = extern struct {
    memid: MEMBERID,
    lprgscode: [*c]SCODE,
    lprgelemdescParam: [*c]ELEMDESC,
    funckind: FUNCKIND,
    invkind: INVOKEKIND,
    @"callconv": CALLCONV,
    cParams: SHORT,
    cParamsOpt: SHORT,
    oVft: SHORT,
    cScodes: SHORT,
    elemdescFunc: ELEMDESC,
    wFuncFlags: WORD,
};
pub const FUNCDESC = struct_tagFUNCDESC;
pub const VAR_PERINSTANCE = enum_tagVARKIND.VAR_PERINSTANCE;
pub const VAR_STATIC = enum_tagVARKIND.VAR_STATIC;
pub const VAR_CONST = enum_tagVARKIND.VAR_CONST;
pub const VAR_DISPATCH = enum_tagVARKIND.VAR_DISPATCH;
pub const enum_tagVARKIND = extern enum {
    VAR_PERINSTANCE = 0,
    VAR_STATIC = 1,
    VAR_CONST = 2,
    VAR_DISPATCH = 3,
};
pub const VARKIND = extern enum {
    VAR_PERINSTANCE = 0,
    VAR_STATIC = 1,
    VAR_CONST = 2,
    VAR_DISPATCH = 3,
};
pub const struct_tagVARDESC = extern struct {
    memid: MEMBERID,
    lpstrSchema: LPOLESTR,
    @"": extern union {
        oInst: ULONG,
        lpvarValue: [*c]VARIANT,
    },
    elemdescVar: ELEMDESC,
    wVarFlags: WORD,
    varkind: VARKIND,
};
pub const VARDESC = struct_tagVARDESC;
pub const union_tagBINDPTR = extern union {
    lpfuncdesc: [*c]FUNCDESC,
    lpvardesc: [*c]VARDESC,
    lptcomp: [*c]ITypeComp,
};
pub const BINDPTR = union_tagBINDPTR;
pub const struct_ITypeCompVtbl = extern struct {
    QueryInterface: ?fn ([*c]ITypeComp, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ITypeComp) callconv(.C) ULONG,
    Release: ?fn ([*c]ITypeComp) callconv(.C) ULONG,
    Bind: ?fn ([*c]ITypeComp, LPOLESTR, ULONG, WORD, [*c]([*c]ITypeInfo), [*c]DESCKIND, [*c]BINDPTR) callconv(.C) HRESULT,
    BindType: ?fn ([*c]ITypeComp, LPOLESTR, ULONG, [*c]([*c]ITypeInfo), [*c]([*c]ITypeComp)) callconv(.C) HRESULT,
};
pub const struct_ITypeComp = extern struct {
    lpVtbl: [*c]struct_ITypeCompVtbl,
};
pub const ITypeComp = struct_ITypeComp;
pub const struct_tagDISPPARAMS = extern struct {
    rgvarg: [*c]VARIANTARG,
    rgdispidNamedArgs: [*c]DISPID,
    cArgs: UINT,
    cNamedArgs: UINT,
};
pub const DISPPARAMS = struct_tagDISPPARAMS;
pub const struct_tagEXCEPINFO = extern struct {
    wCode: WORD,
    wReserved: WORD,
    bstrSource: BSTR,
    bstrDescription: BSTR,
    bstrHelpFile: BSTR,
    dwHelpContext: DWORD,
    pvReserved: PVOID,
    pfnDeferredFillIn: ?fn ([*c]struct_tagEXCEPINFO) callconv(.C) HRESULT,
    scode: SCODE,
};
pub const EXCEPINFO = struct_tagEXCEPINFO;
pub const SYS_WIN16 = enum_tagSYSKIND.SYS_WIN16;
pub const SYS_WIN32 = enum_tagSYSKIND.SYS_WIN32;
pub const SYS_MAC = enum_tagSYSKIND.SYS_MAC;
pub const SYS_WIN64 = enum_tagSYSKIND.SYS_WIN64;
pub const enum_tagSYSKIND = extern enum {
    SYS_WIN16 = 0,
    SYS_WIN32 = 1,
    SYS_MAC = 2,
    SYS_WIN64 = 3,
};
pub const SYSKIND = extern enum {
    SYS_WIN16 = 0,
    SYS_WIN32 = 1,
    SYS_MAC = 2,
    SYS_WIN64 = 3,
};
pub const struct_tagTLIBATTR = extern struct {
    guid: GUID,
    lcid: LCID,
    syskind: SYSKIND,
    wMajorVerNum: WORD,
    wMinorVerNum: WORD,
    wLibFlags: WORD,
};
pub const TLIBATTR = struct_tagTLIBATTR;
pub const struct_ITypeLibVtbl = extern struct {
    QueryInterface: ?fn ([*c]ITypeLib, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ITypeLib) callconv(.C) ULONG,
    Release: ?fn ([*c]ITypeLib) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]ITypeLib) callconv(.C) UINT,
    GetTypeInfo: ?fn ([*c]ITypeLib, UINT, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetTypeInfoType: ?fn ([*c]ITypeLib, UINT, [*c]TYPEKIND) callconv(.C) HRESULT,
    GetTypeInfoOfGuid: ?fn ([*c]ITypeLib, [*c]const GUID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetLibAttr: ?fn ([*c]ITypeLib, [*c]([*c]TLIBATTR)) callconv(.C) HRESULT,
    GetTypeComp: ?fn ([*c]ITypeLib, [*c]([*c]ITypeComp)) callconv(.C) HRESULT,
    GetDocumentation: ?fn ([*c]ITypeLib, INT, [*c]BSTR, [*c]BSTR, [*c]DWORD, [*c]BSTR) callconv(.C) HRESULT,
    IsName: ?fn ([*c]ITypeLib, LPOLESTR, ULONG, [*c]BOOL) callconv(.C) HRESULT,
    FindName: ?fn ([*c]ITypeLib, LPOLESTR, ULONG, [*c]([*c]ITypeInfo), [*c]MEMBERID, [*c]USHORT) callconv(.C) HRESULT,
    ReleaseTLibAttr: ?fn ([*c]ITypeLib, [*c]TLIBATTR) callconv(.C) void,
};
pub const struct_ITypeLib = extern struct {
    lpVtbl: [*c]struct_ITypeLibVtbl,
};
pub const ITypeLib = struct_ITypeLib;
pub const struct_ITypeInfoVtbl = extern struct {
    QueryInterface: ?fn ([*c]ITypeInfo, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ITypeInfo) callconv(.C) ULONG,
    Release: ?fn ([*c]ITypeInfo) callconv(.C) ULONG,
    GetTypeAttr: ?fn ([*c]ITypeInfo, [*c]([*c]TYPEATTR)) callconv(.C) HRESULT,
    GetTypeComp: ?fn ([*c]ITypeInfo, [*c]([*c]ITypeComp)) callconv(.C) HRESULT,
    GetFuncDesc: ?fn ([*c]ITypeInfo, UINT, [*c]([*c]FUNCDESC)) callconv(.C) HRESULT,
    GetVarDesc: ?fn ([*c]ITypeInfo, UINT, [*c]([*c]VARDESC)) callconv(.C) HRESULT,
    GetNames: ?fn ([*c]ITypeInfo, MEMBERID, [*c]BSTR, UINT, [*c]UINT) callconv(.C) HRESULT,
    GetRefTypeOfImplType: ?fn ([*c]ITypeInfo, UINT, [*c]HREFTYPE) callconv(.C) HRESULT,
    GetImplTypeFlags: ?fn ([*c]ITypeInfo, UINT, [*c]INT) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]ITypeInfo, [*c]LPOLESTR, UINT, [*c]MEMBERID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]ITypeInfo, PVOID, MEMBERID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    GetDocumentation: ?fn ([*c]ITypeInfo, MEMBERID, [*c]BSTR, [*c]BSTR, [*c]DWORD, [*c]BSTR) callconv(.C) HRESULT,
    GetDllEntry: ?fn ([*c]ITypeInfo, MEMBERID, INVOKEKIND, [*c]BSTR, [*c]BSTR, [*c]WORD) callconv(.C) HRESULT,
    GetRefTypeInfo: ?fn ([*c]ITypeInfo, HREFTYPE, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    AddressOfMember: ?fn ([*c]ITypeInfo, MEMBERID, INVOKEKIND, [*c]PVOID) callconv(.C) HRESULT,
    CreateInstance: ?fn ([*c]ITypeInfo, [*c]IUnknown, [*c]const IID, [*c]PVOID) callconv(.C) HRESULT,
    GetMops: ?fn ([*c]ITypeInfo, MEMBERID, [*c]BSTR) callconv(.C) HRESULT,
    GetContainingTypeLib: ?fn ([*c]ITypeInfo, [*c]([*c]ITypeLib), [*c]UINT) callconv(.C) HRESULT,
    ReleaseTypeAttr: ?fn ([*c]ITypeInfo, [*c]TYPEATTR) callconv(.C) void,
    ReleaseFuncDesc: ?fn ([*c]ITypeInfo, [*c]FUNCDESC) callconv(.C) void,
    ReleaseVarDesc: ?fn ([*c]ITypeInfo, [*c]VARDESC) callconv(.C) void,
};
pub const struct_ITypeInfo = extern struct {
    lpVtbl: [*c]struct_ITypeInfoVtbl,
};
pub const ITypeInfo = struct_ITypeInfo;
pub const struct_IDispatchVtbl = extern struct {
    QueryInterface: ?fn ([*c]IDispatch, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IDispatch) callconv(.C) ULONG,
    Release: ?fn ([*c]IDispatch) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IDispatch, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IDispatch, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IDispatch, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IDispatch, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
};
pub const struct_IDispatch = extern struct {
    lpVtbl: [*c]struct_IDispatchVtbl,
};
pub const IDispatch = struct_IDispatch;
pub const SNB = [*c]LPOLESTR;
pub const struct_IEnumSTATSTGVtbl = extern struct {
    QueryInterface: ?fn ([*c]IEnumSTATSTG, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IEnumSTATSTG) callconv(.C) ULONG,
    Release: ?fn ([*c]IEnumSTATSTG) callconv(.C) ULONG,
    Next: ?fn ([*c]IEnumSTATSTG, ULONG, [*c]STATSTG, [*c]ULONG) callconv(.C) HRESULT,
    Skip: ?fn ([*c]IEnumSTATSTG, ULONG) callconv(.C) HRESULT,
    Reset: ?fn ([*c]IEnumSTATSTG) callconv(.C) HRESULT,
    Clone: ?fn ([*c]IEnumSTATSTG, [*c]([*c]IEnumSTATSTG)) callconv(.C) HRESULT,
};
pub const struct_IEnumSTATSTG = extern struct {
    lpVtbl: [*c]struct_IEnumSTATSTGVtbl,
};
pub const IEnumSTATSTG = struct_IEnumSTATSTG;
pub const struct_IStorageVtbl = extern struct {
    QueryInterface: ?fn ([*c]IStorage, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IStorage) callconv(.C) ULONG,
    Release: ?fn ([*c]IStorage) callconv(.C) ULONG,
    CreateStream: ?fn ([*c]IStorage, [*c]const OLECHAR, DWORD, DWORD, DWORD, [*c]([*c]IStream)) callconv(.C) HRESULT,
    OpenStream: ?fn ([*c]IStorage, [*c]const OLECHAR, ?*c_void, DWORD, DWORD, [*c]([*c]IStream)) callconv(.C) HRESULT,
    CreateStorage: ?fn ([*c]IStorage, [*c]const OLECHAR, DWORD, DWORD, DWORD, [*c]([*c]IStorage)) callconv(.C) HRESULT,
    OpenStorage: ?fn ([*c]IStorage, [*c]const OLECHAR, [*c]IStorage, DWORD, SNB, DWORD, [*c]([*c]IStorage)) callconv(.C) HRESULT,
    CopyTo: ?fn ([*c]IStorage, DWORD, [*c]const IID, SNB, [*c]IStorage) callconv(.C) HRESULT,
    MoveElementTo: ?fn ([*c]IStorage, [*c]const OLECHAR, [*c]IStorage, [*c]const OLECHAR, DWORD) callconv(.C) HRESULT,
    Commit: ?fn ([*c]IStorage, DWORD) callconv(.C) HRESULT,
    Revert: ?fn ([*c]IStorage) callconv(.C) HRESULT,
    EnumElements: ?fn ([*c]IStorage, DWORD, ?*c_void, DWORD, [*c]([*c]IEnumSTATSTG)) callconv(.C) HRESULT,
    DestroyElement: ?fn ([*c]IStorage, [*c]const OLECHAR) callconv(.C) HRESULT,
    RenameElement: ?fn ([*c]IStorage, [*c]const OLECHAR, [*c]const OLECHAR) callconv(.C) HRESULT,
    SetElementTimes: ?fn ([*c]IStorage, [*c]const OLECHAR, [*c]const FILETIME, [*c]const FILETIME, [*c]const FILETIME) callconv(.C) HRESULT,
    SetClass: ?fn ([*c]IStorage, [*c]const IID) callconv(.C) HRESULT,
    SetStateBits: ?fn ([*c]IStorage, DWORD, DWORD) callconv(.C) HRESULT,
    Stat: ?fn ([*c]IStorage, [*c]STATSTG, DWORD) callconv(.C) HRESULT,
};
pub const struct_IStorage = extern struct {
    lpVtbl: [*c]struct_IStorageVtbl,
};
pub const IStorage = struct_IStorage;
pub const struct_tagVersionedStream = extern struct {
    guidVersion: GUID,
    pStream: [*c]IStream,
};
pub const LPVERSIONEDSTREAM = [*c]struct_tagVersionedStream;
pub const LPSAFEARRAY = [*c]SAFEARRAY;
pub const struct_tagCAC = extern struct {
    cElems: ULONG,
    pElems: [*c]CHAR,
};
pub const CAC = struct_tagCAC;
pub const struct_tagCAUB = extern struct {
    cElems: ULONG,
    pElems: [*c]UCHAR,
};
pub const CAUB = struct_tagCAUB;
pub const struct_tagCAI = extern struct {
    cElems: ULONG,
    pElems: [*c]SHORT,
};
pub const CAI = struct_tagCAI;
pub const struct_tagCAUI = extern struct {
    cElems: ULONG,
    pElems: [*c]USHORT,
};
pub const CAUI = struct_tagCAUI;
pub const struct_tagCAL = extern struct {
    cElems: ULONG,
    pElems: [*c]LONG,
};
pub const CAL = struct_tagCAL;
pub const struct_tagCAUL = extern struct {
    cElems: ULONG,
    pElems: [*c]ULONG,
};
pub const CAUL = struct_tagCAUL;
pub const struct_tagCAH = extern struct {
    cElems: ULONG,
    pElems: [*c]LARGE_INTEGER,
};
pub const CAH = struct_tagCAH;
pub const struct_tagCAUH = extern struct {
    cElems: ULONG,
    pElems: [*c]ULARGE_INTEGER,
};
pub const CAUH = struct_tagCAUH;
pub const struct_tagCAFLT = extern struct {
    cElems: ULONG,
    pElems: [*c]FLOAT,
};
pub const CAFLT = struct_tagCAFLT;
pub const struct_tagCADBL = extern struct {
    cElems: ULONG,
    pElems: [*c]DOUBLE,
};
pub const CADBL = struct_tagCADBL;
pub const struct_tagCABOOL = extern struct {
    cElems: ULONG,
    pElems: [*c]VARIANT_BOOL,
};
pub const CABOOL = struct_tagCABOOL;
pub const struct_tagCASCODE = extern struct {
    cElems: ULONG,
    pElems: [*c]SCODE,
};
pub const CASCODE = struct_tagCASCODE;
pub const struct_tagCACY = extern struct {
    cElems: ULONG,
    pElems: [*c]CY,
};
pub const CACY = struct_tagCACY;
pub const struct_tagCADATE = extern struct {
    cElems: ULONG,
    pElems: [*c]DATE,
};
pub const CADATE = struct_tagCADATE;
pub const struct_tagCAFILETIME = extern struct {
    cElems: ULONG,
    pElems: [*c]FILETIME,
};
pub const CAFILETIME = struct_tagCAFILETIME;
pub const struct_tagCACLSID = extern struct {
    cElems: ULONG,
    pElems: [*c]CLSID,
};
pub const CACLSID = struct_tagCACLSID;
pub const struct_tagCACLIPDATA = extern struct {
    cElems: ULONG,
    pElems: [*c]CLIPDATA,
};
pub const CACLIPDATA = struct_tagCACLIPDATA;
pub const struct_tagCABSTR = extern struct {
    cElems: ULONG,
    pElems: [*c]BSTR,
};
pub const CABSTR = struct_tagCABSTR;
pub const struct_tagCABSTRBLOB = extern struct {
    cElems: ULONG,
    pElems: [*c]BSTRBLOB,
};
pub const CABSTRBLOB = struct_tagCABSTRBLOB;
pub const struct_tagCALPSTR = extern struct {
    cElems: ULONG,
    pElems: [*c]LPSTR,
};
pub const CALPSTR = struct_tagCALPSTR;
pub const struct_tagCALPWSTR = extern struct {
    cElems: ULONG,
    pElems: [*c]LPWSTR,
};
pub const CALPWSTR = struct_tagCALPWSTR;
pub const PROPVARIANT = struct_tagPROPVARIANT;
pub const struct_tagCAPROPVARIANT = extern struct {
    cElems: ULONG,
    pElems: [*c]PROPVARIANT,
};
pub const CAPROPVARIANT = struct_tagCAPROPVARIANT;
pub const struct_tagPROPVARIANT = extern struct {
    @"": extern union {
        @"": extern struct {
            vt: VARTYPE,
            wReserved1: PROPVAR_PAD1,
            wReserved2: PROPVAR_PAD2,
            wReserved3: PROPVAR_PAD3,
            @"": extern union {
                cVal: CHAR,
                bVal: UCHAR,
                iVal: SHORT,
                uiVal: USHORT,
                lVal: LONG,
                ulVal: ULONG,
                intVal: INT,
                uintVal: UINT,
                hVal: LARGE_INTEGER,
                uhVal: ULARGE_INTEGER,
                fltVal: FLOAT,
                dblVal: DOUBLE,
                boolVal: VARIANT_BOOL,
                __OBSOLETE__VARIANT_BOOL: VARIANT_BOOL,
                scode: SCODE,
                cyVal: CY,
                date: DATE,
                filetime: FILETIME,
                puuid: [*c]CLSID,
                pclipdata: [*c]CLIPDATA,
                bstrVal: BSTR,
                bstrblobVal: BSTRBLOB,
                blob: BLOB,
                pszVal: LPSTR,
                pwszVal: LPWSTR,
                punkVal: [*c]IUnknown,
                pdispVal: [*c]IDispatch,
                pStream: [*c]IStream,
                pStorage: [*c]IStorage,
                pVersionedStream: LPVERSIONEDSTREAM,
                parray: LPSAFEARRAY,
                cac: CAC,
                caub: CAUB,
                cai: CAI,
                caui: CAUI,
                cal: CAL,
                caul: CAUL,
                cah: CAH,
                cauh: CAUH,
                caflt: CAFLT,
                cadbl: CADBL,
                cabool: CABOOL,
                cascode: CASCODE,
                cacy: CACY,
                cadate: CADATE,
                cafiletime: CAFILETIME,
                cauuid: CACLSID,
                caclipdata: CACLIPDATA,
                cabstr: CABSTR,
                cabstrblob: CABSTRBLOB,
                calpstr: CALPSTR,
                calpwstr: CALPWSTR,
                capropvar: CAPROPVARIANT,
                pcVal: [*c]CHAR,
                pbVal: [*c]UCHAR,
                piVal: [*c]SHORT,
                puiVal: [*c]USHORT,
                plVal: [*c]LONG,
                pulVal: [*c]ULONG,
                pintVal: [*c]INT,
                puintVal: [*c]UINT,
                pfltVal: [*c]FLOAT,
                pdblVal: [*c]DOUBLE,
                pboolVal: [*c]VARIANT_BOOL,
                pdecVal: [*c]DECIMAL,
                pscode: [*c]SCODE,
                pcyVal: [*c]CY,
                pdate: [*c]DATE,
                pbstrVal: [*c]BSTR,
                ppunkVal: [*c]([*c]IUnknown),
                ppdispVal: [*c]([*c]IDispatch),
                pparray: [*c]LPSAFEARRAY,
                pvarVal: [*c]PROPVARIANT,
            },
        },
        decVal: DECIMAL,
    },
};
pub extern "ole32" fn PropVariantCopy(pvarDest: [*c]PROPVARIANT, pvarSrc: [*c]const PROPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn PropVariantClear(pvar: [*c]PROPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn FreePropVariantArray(cVariants: ULONG, rgvars: [*c]PROPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoWaitForMultipleHandles(dwFlags: DWORD, dwTimeout: DWORD, cHandles: ULONG, pHandles: LPHANDLE, lpdwindex: LPDWORD) callconv(.Stdcall) HRESULT;
pub const COWAIT_DEFAULT = enum_tagCOWAIT_FLAGS.COWAIT_DEFAULT;
pub const COWAIT_WAITALL = enum_tagCOWAIT_FLAGS.COWAIT_WAITALL;
pub const COWAIT_ALERTABLE = enum_tagCOWAIT_FLAGS.COWAIT_ALERTABLE;
pub const COWAIT_INPUTAVAILABLE = enum_tagCOWAIT_FLAGS.COWAIT_INPUTAVAILABLE;
pub const COWAIT_DISPATCH_CALLS = enum_tagCOWAIT_FLAGS.COWAIT_DISPATCH_CALLS;
pub const COWAIT_DISPATCH_WINDOW_MESSAGES = enum_tagCOWAIT_FLAGS.COWAIT_DISPATCH_WINDOW_MESSAGES;
pub const enum_tagCOWAIT_FLAGS = extern enum {
    COWAIT_DEFAULT = 0,
    COWAIT_WAITALL = 1,
    COWAIT_ALERTABLE = 2,
    COWAIT_INPUTAVAILABLE = 4,
    COWAIT_DISPATCH_CALLS = 8,
    COWAIT_DISPATCH_WINDOW_MESSAGES = 16,
};
pub const COWAIT_FLAGS = enum_tagCOWAIT_FLAGS;
pub const CWMO_DEFAULT = enum_CWMO_FLAGS.CWMO_DEFAULT;
pub const CWMO_DISPATCH_CALLS = enum_CWMO_FLAGS.CWMO_DISPATCH_CALLS;
pub const CWMO_DISPATCH_WINDOW_MESSAGES = enum_CWMO_FLAGS.CWMO_DISPATCH_WINDOW_MESSAGES;
pub const enum_CWMO_FLAGS = extern enum {
    CWMO_DEFAULT = 0,
    CWMO_DISPATCH_CALLS = 1,
    CWMO_DISPATCH_WINDOW_MESSAGES = 2,
};
pub const CWMO_FLAGS = enum_CWMO_FLAGS;
pub extern "ole32" fn CoWaitForMultipleObjects(dwFlags: DWORD, dwTimeout: DWORD, cHandles: ULONG, pHandles: [*c]const HANDLE, lpdwindex: LPDWORD) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoGetTreatAsClass(clsidOld: [*c]const IID, pClsidNew: LPCLSID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoInvalidateRemoteMachineBindings(pszMachineName: LPOLESTR) callconv(.Stdcall) HRESULT;
pub const AGILEREFERENCE_DEFAULT = enum_AgileReferenceOptions.AGILEREFERENCE_DEFAULT;
pub const AGILEREFERENCE_DELAYEDMARSHAL = enum_AgileReferenceOptions.AGILEREFERENCE_DELAYEDMARSHAL;
pub const enum_AgileReferenceOptions = extern enum {
    AGILEREFERENCE_DEFAULT = 0,
    AGILEREFERENCE_DELAYEDMARSHAL = 1,
};
pub extern "ole32" fn RoGetAgileReference(options: enum_AgileReferenceOptions, riid: [*c]const IID, pUnk: [*c]IUnknown, ppAgileReference: [*c]([*c]IAgileReference)) callconv(.Stdcall) HRESULT;
pub const LPFNGETCLASSOBJECT = ?fn ([*c]const IID, [*c]const IID, [*c]LPVOID) callconv(.C) HRESULT;
pub const LPFNCANUNLOADNOW = ?fn () callconv(.C) HRESULT;
pub extern "ole32" fn DllGetClassObject(rclsid: [*c]const IID, riid: [*c]const IID, ppv: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn DllCanUnloadNow() callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoTaskMemAlloc(cb: SIZE_T) callconv(.Stdcall) LPVOID;
pub extern "ole32" fn CoTaskMemRealloc(pv: LPVOID, cb: SIZE_T) callconv(.Stdcall) LPVOID;
pub extern "ole32" fn CoTaskMemFree(pv: LPVOID) callconv(.Stdcall) void;
pub extern "ole32" fn CoFileTimeNow(lpFileTime: [*c]FILETIME) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CLSIDFromProgIDEx(lpszProgID: LPCOLESTR, lpclsid: LPCLSID) callconv(.Stdcall) HRESULT;
pub const IMallocSpy = struct_IMallocSpy;
pub const struct_IMallocSpyVtbl = extern struct {
    QueryInterface: ?fn ([*c]IMallocSpy, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IMallocSpy) callconv(.C) ULONG,
    Release: ?fn ([*c]IMallocSpy) callconv(.C) ULONG,
    PreAlloc: ?fn ([*c]IMallocSpy, SIZE_T) callconv(.C) SIZE_T,
    PostAlloc: ?fn ([*c]IMallocSpy, ?*c_void) callconv(.C) ?*c_void,
    PreFree: ?fn ([*c]IMallocSpy, ?*c_void, BOOL) callconv(.C) ?*c_void,
    PostFree: ?fn ([*c]IMallocSpy, BOOL) callconv(.C) void,
    PreRealloc: ?fn ([*c]IMallocSpy, ?*c_void, SIZE_T, [*c](?*c_void), BOOL) callconv(.C) SIZE_T,
    PostRealloc: ?fn ([*c]IMallocSpy, ?*c_void, BOOL) callconv(.C) ?*c_void,
    PreGetSize: ?fn ([*c]IMallocSpy, ?*c_void, BOOL) callconv(.C) ?*c_void,
    PostGetSize: ?fn ([*c]IMallocSpy, SIZE_T, BOOL) callconv(.C) SIZE_T,
    PreDidAlloc: ?fn ([*c]IMallocSpy, ?*c_void, BOOL) callconv(.C) ?*c_void,
    PostDidAlloc: ?fn ([*c]IMallocSpy, ?*c_void, BOOL, c_int) callconv(.C) c_int,
    PreHeapMinimize: ?fn ([*c]IMallocSpy) callconv(.C) void,
    PostHeapMinimize: ?fn ([*c]IMallocSpy) callconv(.C) void,
};
pub const struct_IMallocSpy = extern struct {
    lpVtbl: [*c]struct_IMallocSpyVtbl,
};
pub const IBindCtx = struct_IBindCtx;
pub const struct_tagBIND_OPTS = extern struct {
    cbStruct: DWORD,
    grfFlags: DWORD,
    grfMode: DWORD,
    dwTickCountDeadline: DWORD,
};
pub const BIND_OPTS = struct_tagBIND_OPTS;
pub const struct_IEnumMonikerVtbl = extern struct {
    QueryInterface: ?fn ([*c]IEnumMoniker, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IEnumMoniker) callconv(.C) ULONG,
    Release: ?fn ([*c]IEnumMoniker) callconv(.C) ULONG,
    Next: ?fn ([*c]IEnumMoniker, ULONG, [*c]([*c]IMoniker), [*c]ULONG) callconv(.C) HRESULT,
    Skip: ?fn ([*c]IEnumMoniker, ULONG) callconv(.C) HRESULT,
    Reset: ?fn ([*c]IEnumMoniker) callconv(.C) HRESULT,
    Clone: ?fn ([*c]IEnumMoniker, [*c]([*c]IEnumMoniker)) callconv(.C) HRESULT,
};
pub const struct_IEnumMoniker = extern struct {
    lpVtbl: [*c]struct_IEnumMonikerVtbl,
};
pub const IEnumMoniker = struct_IEnumMoniker;
pub const struct_IMonikerVtbl = extern struct {
    QueryInterface: ?fn ([*c]IMoniker, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IMoniker) callconv(.C) ULONG,
    Release: ?fn ([*c]IMoniker) callconv(.C) ULONG,
    GetClassID: ?fn ([*c]IMoniker, [*c]CLSID) callconv(.C) HRESULT,
    IsDirty: ?fn ([*c]IMoniker) callconv(.C) HRESULT,
    Load: ?fn ([*c]IMoniker, [*c]IStream) callconv(.C) HRESULT,
    Save: ?fn ([*c]IMoniker, [*c]IStream, BOOL) callconv(.C) HRESULT,
    GetSizeMax: ?fn ([*c]IMoniker, [*c]ULARGE_INTEGER) callconv(.C) HRESULT,
    BindToObject: ?fn ([*c]IMoniker, [*c]IBindCtx, [*c]IMoniker, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    BindToStorage: ?fn ([*c]IMoniker, [*c]IBindCtx, [*c]IMoniker, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    Reduce: ?fn ([*c]IMoniker, [*c]IBindCtx, DWORD, [*c]([*c]IMoniker), [*c]([*c]IMoniker)) callconv(.C) HRESULT,
    ComposeWith: ?fn ([*c]IMoniker, [*c]IMoniker, BOOL, [*c]([*c]IMoniker)) callconv(.C) HRESULT,
    Enum: ?fn ([*c]IMoniker, BOOL, [*c]([*c]IEnumMoniker)) callconv(.C) HRESULT,
    IsEqual: ?fn ([*c]IMoniker, [*c]IMoniker) callconv(.C) HRESULT,
    Hash: ?fn ([*c]IMoniker, [*c]DWORD) callconv(.C) HRESULT,
    IsRunning: ?fn ([*c]IMoniker, [*c]IBindCtx, [*c]IMoniker, [*c]IMoniker) callconv(.C) HRESULT,
    GetTimeOfLastChange: ?fn ([*c]IMoniker, [*c]IBindCtx, [*c]IMoniker, [*c]FILETIME) callconv(.C) HRESULT,
    Inverse: ?fn ([*c]IMoniker, [*c]([*c]IMoniker)) callconv(.C) HRESULT,
    CommonPrefixWith: ?fn ([*c]IMoniker, [*c]IMoniker, [*c]([*c]IMoniker)) callconv(.C) HRESULT,
    RelativePathTo: ?fn ([*c]IMoniker, [*c]IMoniker, [*c]([*c]IMoniker)) callconv(.C) HRESULT,
    GetDisplayName: ?fn ([*c]IMoniker, [*c]IBindCtx, [*c]IMoniker, [*c]LPOLESTR) callconv(.C) HRESULT,
    ParseDisplayName: ?fn ([*c]IMoniker, [*c]IBindCtx, [*c]IMoniker, LPOLESTR, [*c]ULONG, [*c]([*c]IMoniker)) callconv(.C) HRESULT,
    IsSystemMoniker: ?fn ([*c]IMoniker, [*c]DWORD) callconv(.C) HRESULT,
};
pub const struct_IMoniker = extern struct {
    lpVtbl: [*c]struct_IMonikerVtbl,
};
pub const IMoniker = struct_IMoniker;
pub const struct_IRunningObjectTableVtbl = extern struct {
    QueryInterface: ?fn ([*c]IRunningObjectTable, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IRunningObjectTable) callconv(.C) ULONG,
    Release: ?fn ([*c]IRunningObjectTable) callconv(.C) ULONG,
    Register: ?fn ([*c]IRunningObjectTable, DWORD, [*c]IUnknown, [*c]IMoniker, [*c]DWORD) callconv(.C) HRESULT,
    Revoke: ?fn ([*c]IRunningObjectTable, DWORD) callconv(.C) HRESULT,
    IsRunning: ?fn ([*c]IRunningObjectTable, [*c]IMoniker) callconv(.C) HRESULT,
    GetObjectA: ?fn ([*c]IRunningObjectTable, [*c]IMoniker, [*c]([*c]IUnknown)) callconv(.C) HRESULT,
    NoteChangeTime: ?fn ([*c]IRunningObjectTable, DWORD, [*c]FILETIME) callconv(.C) HRESULT,
    GetTimeOfLastChange: ?fn ([*c]IRunningObjectTable, [*c]IMoniker, [*c]FILETIME) callconv(.C) HRESULT,
    EnumRunning: ?fn ([*c]IRunningObjectTable, [*c]([*c]IEnumMoniker)) callconv(.C) HRESULT,
};
pub const struct_IRunningObjectTable = extern struct {
    lpVtbl: [*c]struct_IRunningObjectTableVtbl,
};
pub const IRunningObjectTable = struct_IRunningObjectTable;
pub const struct_IBindCtxVtbl = extern struct {
    QueryInterface: ?fn ([*c]IBindCtx, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IBindCtx) callconv(.C) ULONG,
    Release: ?fn ([*c]IBindCtx) callconv(.C) ULONG,
    RegisterObjectBound: ?fn ([*c]IBindCtx, [*c]IUnknown) callconv(.C) HRESULT,
    RevokeObjectBound: ?fn ([*c]IBindCtx, [*c]IUnknown) callconv(.C) HRESULT,
    ReleaseBoundObjects: ?fn ([*c]IBindCtx) callconv(.C) HRESULT,
    SetBindOptions: ?fn ([*c]IBindCtx, [*c]BIND_OPTS) callconv(.C) HRESULT,
    GetBindOptions: ?fn ([*c]IBindCtx, [*c]BIND_OPTS) callconv(.C) HRESULT,
    GetRunningObjectTable: ?fn ([*c]IBindCtx, [*c]([*c]IRunningObjectTable)) callconv(.C) HRESULT,
    RegisterObjectParam: ?fn ([*c]IBindCtx, LPOLESTR, [*c]IUnknown) callconv(.C) HRESULT,
    GetObjectParam: ?fn ([*c]IBindCtx, LPOLESTR, [*c]([*c]IUnknown)) callconv(.C) HRESULT,
    EnumObjectParam: ?fn ([*c]IBindCtx, [*c]([*c]IEnumString)) callconv(.C) HRESULT,
    RevokeObjectParam: ?fn ([*c]IBindCtx, LPOLESTR) callconv(.C) HRESULT,
};
pub const struct_IBindCtx = extern struct {
    lpVtbl: [*c]struct_IBindCtxVtbl,
};
pub const IRunnableObject = struct_IRunnableObject;
pub const LPBINDCTX = [*c]IBindCtx;
pub const struct_IRunnableObjectVtbl = extern struct {
    QueryInterface: ?fn ([*c]IRunnableObject, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IRunnableObject) callconv(.C) ULONG,
    Release: ?fn ([*c]IRunnableObject) callconv(.C) ULONG,
    GetRunningClass: ?fn ([*c]IRunnableObject, LPCLSID) callconv(.C) HRESULT,
    Run: ?fn ([*c]IRunnableObject, LPBINDCTX) callconv(.C) HRESULT,
    IsRunning: ?fn ([*c]IRunnableObject) callconv(.C) BOOL,
    LockRunning: ?fn ([*c]IRunnableObject, BOOL, BOOL) callconv(.C) HRESULT,
    SetContainedObject: ?fn ([*c]IRunnableObject, BOOL) callconv(.C) HRESULT,
};
pub const struct_IRunnableObject = extern struct {
    lpVtbl: [*c]struct_IRunnableObjectVtbl,
};
pub const IPersist = struct_IPersist;
pub const struct_IPersistVtbl = extern struct {
    QueryInterface: ?fn ([*c]IPersist, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IPersist) callconv(.C) ULONG,
    Release: ?fn ([*c]IPersist) callconv(.C) ULONG,
    GetClassID: ?fn ([*c]IPersist, [*c]CLSID) callconv(.C) HRESULT,
};
pub const struct_IPersist = extern struct {
    lpVtbl: [*c]struct_IPersistVtbl,
};
pub const IPersistStream = struct_IPersistStream;
pub const struct_IPersistStreamVtbl = extern struct {
    QueryInterface: ?fn ([*c]IPersistStream, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IPersistStream) callconv(.C) ULONG,
    Release: ?fn ([*c]IPersistStream) callconv(.C) ULONG,
    GetClassID: ?fn ([*c]IPersistStream, [*c]CLSID) callconv(.C) HRESULT,
    IsDirty: ?fn ([*c]IPersistStream) callconv(.C) HRESULT,
    Load: ?fn ([*c]IPersistStream, [*c]IStream) callconv(.C) HRESULT,
    Save: ?fn ([*c]IPersistStream, [*c]IStream, BOOL) callconv(.C) HRESULT,
    GetSizeMax: ?fn ([*c]IPersistStream, [*c]ULARGE_INTEGER) callconv(.C) HRESULT,
};
pub const struct_IPersistStream = extern struct {
    lpVtbl: [*c]struct_IPersistStreamVtbl,
};
pub const IROTData = struct_IROTData;
pub const struct_IROTDataVtbl = extern struct {
    QueryInterface: ?fn ([*c]IROTData, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IROTData) callconv(.C) ULONG,
    Release: ?fn ([*c]IROTData) callconv(.C) ULONG,
    GetComparisonData: ?fn ([*c]IROTData, [*c]byte, ULONG, [*c]ULONG) callconv(.C) HRESULT,
};
pub const struct_IROTData = extern struct {
    lpVtbl: [*c]struct_IROTDataVtbl,
};
pub const IPersistFile = struct_IPersistFile;
pub const struct_IPersistFileVtbl = extern struct {
    QueryInterface: ?fn ([*c]IPersistFile, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IPersistFile) callconv(.C) ULONG,
    Release: ?fn ([*c]IPersistFile) callconv(.C) ULONG,
    GetClassID: ?fn ([*c]IPersistFile, [*c]CLSID) callconv(.C) HRESULT,
    IsDirty: ?fn ([*c]IPersistFile) callconv(.C) HRESULT,
    Load: ?fn ([*c]IPersistFile, LPCOLESTR, DWORD) callconv(.C) HRESULT,
    Save: ?fn ([*c]IPersistFile, LPCOLESTR, BOOL) callconv(.C) HRESULT,
    SaveCompleted: ?fn ([*c]IPersistFile, LPCOLESTR) callconv(.C) HRESULT,
    GetCurFile: ?fn ([*c]IPersistFile, [*c]LPOLESTR) callconv(.C) HRESULT,
};
pub const struct_IPersistFile = extern struct {
    lpVtbl: [*c]struct_IPersistFileVtbl,
};
pub const IPersistStorage = struct_IPersistStorage;
pub const struct_IPersistStorageVtbl = extern struct {
    QueryInterface: ?fn ([*c]IPersistStorage, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IPersistStorage) callconv(.C) ULONG,
    Release: ?fn ([*c]IPersistStorage) callconv(.C) ULONG,
    GetClassID: ?fn ([*c]IPersistStorage, [*c]CLSID) callconv(.C) HRESULT,
    IsDirty: ?fn ([*c]IPersistStorage) callconv(.C) HRESULT,
    InitNew: ?fn ([*c]IPersistStorage, [*c]IStorage) callconv(.C) HRESULT,
    Load: ?fn ([*c]IPersistStorage, [*c]IStorage) callconv(.C) HRESULT,
    Save: ?fn ([*c]IPersistStorage, [*c]IStorage, BOOL) callconv(.C) HRESULT,
    SaveCompleted: ?fn ([*c]IPersistStorage, [*c]IStorage) callconv(.C) HRESULT,
    HandsOffStorage: ?fn ([*c]IPersistStorage) callconv(.C) HRESULT,
};
pub const struct_IPersistStorage = extern struct {
    lpVtbl: [*c]struct_IPersistStorageVtbl,
};
pub const ILockBytes = struct_ILockBytes;
pub const struct_ILockBytesVtbl = extern struct {
    QueryInterface: ?fn ([*c]ILockBytes, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ILockBytes) callconv(.C) ULONG,
    Release: ?fn ([*c]ILockBytes) callconv(.C) ULONG,
    ReadAt: ?fn ([*c]ILockBytes, ULARGE_INTEGER, ?*c_void, ULONG, [*c]ULONG) callconv(.C) HRESULT,
    WriteAt: ?fn ([*c]ILockBytes, ULARGE_INTEGER, ?*const c_void, ULONG, [*c]ULONG) callconv(.C) HRESULT,
    Flush: ?fn ([*c]ILockBytes) callconv(.C) HRESULT,
    SetSize: ?fn ([*c]ILockBytes, ULARGE_INTEGER) callconv(.C) HRESULT,
    LockRegion: ?fn ([*c]ILockBytes, ULARGE_INTEGER, ULARGE_INTEGER, DWORD) callconv(.C) HRESULT,
    UnlockRegion: ?fn ([*c]ILockBytes, ULARGE_INTEGER, ULARGE_INTEGER, DWORD) callconv(.C) HRESULT,
    Stat: ?fn ([*c]ILockBytes, [*c]STATSTG, DWORD) callconv(.C) HRESULT,
};
pub const struct_ILockBytes = extern struct {
    lpVtbl: [*c]struct_ILockBytesVtbl,
};
pub const IEnumFORMATETC = struct_IEnumFORMATETC;
pub const struct_tagDVTARGETDEVICE = extern struct {
    tdSize: DWORD,
    tdDriverNameOffset: WORD,
    tdDeviceNameOffset: WORD,
    tdPortNameOffset: WORD,
    tdExtDevmodeOffset: WORD,
    tdData: [1]BYTE,
};
pub const DVTARGETDEVICE = struct_tagDVTARGETDEVICE;
pub const struct_tagFORMATETC = extern struct {
    cfFormat: CLIPFORMAT,
    ptd: [*c]DVTARGETDEVICE,
    dwAspect: DWORD,
    lindex: LONG,
    tymed: DWORD,
};
pub const FORMATETC = struct_tagFORMATETC;
pub const struct_IEnumFORMATETCVtbl = extern struct {
    QueryInterface: ?fn ([*c]IEnumFORMATETC, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IEnumFORMATETC) callconv(.C) ULONG,
    Release: ?fn ([*c]IEnumFORMATETC) callconv(.C) ULONG,
    Next: ?fn ([*c]IEnumFORMATETC, ULONG, [*c]FORMATETC, [*c]ULONG) callconv(.C) HRESULT,
    Skip: ?fn ([*c]IEnumFORMATETC, ULONG) callconv(.C) HRESULT,
    Reset: ?fn ([*c]IEnumFORMATETC) callconv(.C) HRESULT,
    Clone: ?fn ([*c]IEnumFORMATETC, [*c]([*c]IEnumFORMATETC)) callconv(.C) HRESULT,
};
pub const struct_IEnumFORMATETC = extern struct {
    lpVtbl: [*c]struct_IEnumFORMATETCVtbl,
};
pub const IEnumSTATDATA = struct_IEnumSTATDATA;
pub const struct_tagSTGMEDIUM = extern struct {
    tymed: DWORD,
    @"": extern union {
        hBitmap: HBITMAP,
        hMetaFilePict: HMETAFILEPICT,
        hEnhMetaFile: HENHMETAFILE,
        hGlobal: HGLOBAL,
        lpszFileName: LPOLESTR,
        pstm: [*c]IStream,
        pstg: [*c]IStorage,
    },
    pUnkForRelease: [*c]IUnknown,
};
pub const uSTGMEDIUM = struct_tagSTGMEDIUM;
pub const STGMEDIUM = uSTGMEDIUM;
pub const struct_IAdviseSinkVtbl = extern struct {
    QueryInterface: ?fn ([*c]IAdviseSink, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IAdviseSink) callconv(.C) ULONG,
    Release: ?fn ([*c]IAdviseSink) callconv(.C) ULONG,
    OnDataChange: ?fn ([*c]IAdviseSink, [*c]FORMATETC, [*c]STGMEDIUM) callconv(.C) void,
    OnViewChange: ?fn ([*c]IAdviseSink, DWORD, LONG) callconv(.C) void,
    OnRename: ?fn ([*c]IAdviseSink, [*c]IMoniker) callconv(.C) void,
    OnSave: ?fn ([*c]IAdviseSink) callconv(.C) void,
    OnClose: ?fn ([*c]IAdviseSink) callconv(.C) void,
};
pub const struct_IAdviseSink = extern struct {
    lpVtbl: [*c]struct_IAdviseSinkVtbl,
};
pub const IAdviseSink = struct_IAdviseSink;
pub const struct_tagSTATDATA = extern struct {
    formatetc: FORMATETC,
    advf: DWORD,
    pAdvSink: [*c]IAdviseSink,
    dwConnection: DWORD,
};
pub const STATDATA = struct_tagSTATDATA;
pub const struct_IEnumSTATDATAVtbl = extern struct {
    QueryInterface: ?fn ([*c]IEnumSTATDATA, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IEnumSTATDATA) callconv(.C) ULONG,
    Release: ?fn ([*c]IEnumSTATDATA) callconv(.C) ULONG,
    Next: ?fn ([*c]IEnumSTATDATA, ULONG, [*c]STATDATA, [*c]ULONG) callconv(.C) HRESULT,
    Skip: ?fn ([*c]IEnumSTATDATA, ULONG) callconv(.C) HRESULT,
    Reset: ?fn ([*c]IEnumSTATDATA) callconv(.C) HRESULT,
    Clone: ?fn ([*c]IEnumSTATDATA, [*c]([*c]IEnumSTATDATA)) callconv(.C) HRESULT,
};
pub const struct_IEnumSTATDATA = extern struct {
    lpVtbl: [*c]struct_IEnumSTATDATAVtbl,
};
pub const IRootStorage = struct_IRootStorage;
pub const struct_IRootStorageVtbl = extern struct {
    QueryInterface: ?fn ([*c]IRootStorage, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IRootStorage) callconv(.C) ULONG,
    Release: ?fn ([*c]IRootStorage) callconv(.C) ULONG,
    SwitchToFile: ?fn ([*c]IRootStorage, LPOLESTR) callconv(.C) HRESULT,
};
pub const struct_IRootStorage = extern struct {
    lpVtbl: [*c]struct_IRootStorageVtbl,
};
pub const AsyncIAdviseSink = struct_AsyncIAdviseSink;
pub const struct_AsyncIAdviseSinkVtbl = extern struct {
    QueryInterface: ?fn ([*c]AsyncIAdviseSink, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]AsyncIAdviseSink) callconv(.C) ULONG,
    Release: ?fn ([*c]AsyncIAdviseSink) callconv(.C) ULONG,
    Begin_OnDataChange: ?fn ([*c]AsyncIAdviseSink, [*c]FORMATETC, [*c]STGMEDIUM) callconv(.C) void,
    Finish_OnDataChange: ?fn ([*c]AsyncIAdviseSink) callconv(.C) void,
    Begin_OnViewChange: ?fn ([*c]AsyncIAdviseSink, DWORD, LONG) callconv(.C) void,
    Finish_OnViewChange: ?fn ([*c]AsyncIAdviseSink) callconv(.C) void,
    Begin_OnRename: ?fn ([*c]AsyncIAdviseSink, [*c]IMoniker) callconv(.C) void,
    Finish_OnRename: ?fn ([*c]AsyncIAdviseSink) callconv(.C) void,
    Begin_OnSave: ?fn ([*c]AsyncIAdviseSink) callconv(.C) void,
    Finish_OnSave: ?fn ([*c]AsyncIAdviseSink) callconv(.C) void,
    Begin_OnClose: ?fn ([*c]AsyncIAdviseSink) callconv(.C) void,
    Finish_OnClose: ?fn ([*c]AsyncIAdviseSink) callconv(.C) void,
};
pub const struct_AsyncIAdviseSink = extern struct {
    lpVtbl: [*c]struct_AsyncIAdviseSinkVtbl,
};
pub const IAdviseSink2 = struct_IAdviseSink2;
pub const struct_IAdviseSink2Vtbl = extern struct {
    QueryInterface: ?fn ([*c]IAdviseSink2, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IAdviseSink2) callconv(.C) ULONG,
    Release: ?fn ([*c]IAdviseSink2) callconv(.C) ULONG,
    OnDataChange: ?fn ([*c]IAdviseSink2, [*c]FORMATETC, [*c]STGMEDIUM) callconv(.C) void,
    OnViewChange: ?fn ([*c]IAdviseSink2, DWORD, LONG) callconv(.C) void,
    OnRename: ?fn ([*c]IAdviseSink2, [*c]IMoniker) callconv(.C) void,
    OnSave: ?fn ([*c]IAdviseSink2) callconv(.C) void,
    OnClose: ?fn ([*c]IAdviseSink2) callconv(.C) void,
    OnLinkSrcChange: ?fn ([*c]IAdviseSink2, [*c]IMoniker) callconv(.C) void,
};
pub const struct_IAdviseSink2 = extern struct {
    lpVtbl: [*c]struct_IAdviseSink2Vtbl,
};
pub const AsyncIAdviseSink2 = struct_AsyncIAdviseSink2;
pub const struct_AsyncIAdviseSink2Vtbl = extern struct {
    QueryInterface: ?fn ([*c]AsyncIAdviseSink2, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]AsyncIAdviseSink2) callconv(.C) ULONG,
    Release: ?fn ([*c]AsyncIAdviseSink2) callconv(.C) ULONG,
    Begin_OnDataChange: ?fn ([*c]AsyncIAdviseSink2, [*c]FORMATETC, [*c]STGMEDIUM) callconv(.C) void,
    Finish_OnDataChange: ?fn ([*c]AsyncIAdviseSink2) callconv(.C) void,
    Begin_OnViewChange: ?fn ([*c]AsyncIAdviseSink2, DWORD, LONG) callconv(.C) void,
    Finish_OnViewChange: ?fn ([*c]AsyncIAdviseSink2) callconv(.C) void,
    Begin_OnRename: ?fn ([*c]AsyncIAdviseSink2, [*c]IMoniker) callconv(.C) void,
    Finish_OnRename: ?fn ([*c]AsyncIAdviseSink2) callconv(.C) void,
    Begin_OnSave: ?fn ([*c]AsyncIAdviseSink2) callconv(.C) void,
    Finish_OnSave: ?fn ([*c]AsyncIAdviseSink2) callconv(.C) void,
    Begin_OnClose: ?fn ([*c]AsyncIAdviseSink2) callconv(.C) void,
    Finish_OnClose: ?fn ([*c]AsyncIAdviseSink2) callconv(.C) void,
    Begin_OnLinkSrcChange: ?fn ([*c]AsyncIAdviseSink2, [*c]IMoniker) callconv(.C) void,
    Finish_OnLinkSrcChange: ?fn ([*c]AsyncIAdviseSink2) callconv(.C) void,
};
pub const struct_AsyncIAdviseSink2 = extern struct {
    lpVtbl: [*c]struct_AsyncIAdviseSink2Vtbl,
};
pub const IDataObject = struct_IDataObject;
pub const struct_IDataObjectVtbl = extern struct {
    QueryInterface: ?fn ([*c]IDataObject, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IDataObject) callconv(.C) ULONG,
    Release: ?fn ([*c]IDataObject) callconv(.C) ULONG,
    GetData: ?fn ([*c]IDataObject, [*c]FORMATETC, [*c]STGMEDIUM) callconv(.C) HRESULT,
    GetDataHere: ?fn ([*c]IDataObject, [*c]FORMATETC, [*c]STGMEDIUM) callconv(.C) HRESULT,
    QueryGetData: ?fn ([*c]IDataObject, [*c]FORMATETC) callconv(.C) HRESULT,
    GetCanonicalFormatEtc: ?fn ([*c]IDataObject, [*c]FORMATETC, [*c]FORMATETC) callconv(.C) HRESULT,
    SetData: ?fn ([*c]IDataObject, [*c]FORMATETC, [*c]STGMEDIUM, BOOL) callconv(.C) HRESULT,
    EnumFormatEtc: ?fn ([*c]IDataObject, DWORD, [*c]([*c]IEnumFORMATETC)) callconv(.C) HRESULT,
    DAdvise: ?fn ([*c]IDataObject, [*c]FORMATETC, DWORD, [*c]IAdviseSink, [*c]DWORD) callconv(.C) HRESULT,
    DUnadvise: ?fn ([*c]IDataObject, DWORD) callconv(.C) HRESULT,
    EnumDAdvise: ?fn ([*c]IDataObject, [*c]([*c]IEnumSTATDATA)) callconv(.C) HRESULT,
};
pub const struct_IDataObject = extern struct {
    lpVtbl: [*c]struct_IDataObjectVtbl,
};
pub const IDataAdviseHolder = struct_IDataAdviseHolder;
pub const struct_IDataAdviseHolderVtbl = extern struct {
    QueryInterface: ?fn ([*c]IDataAdviseHolder, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IDataAdviseHolder) callconv(.C) ULONG,
    Release: ?fn ([*c]IDataAdviseHolder) callconv(.C) ULONG,
    Advise: ?fn ([*c]IDataAdviseHolder, [*c]IDataObject, [*c]FORMATETC, DWORD, [*c]IAdviseSink, [*c]DWORD) callconv(.C) HRESULT,
    Unadvise: ?fn ([*c]IDataAdviseHolder, DWORD) callconv(.C) HRESULT,
    EnumAdvise: ?fn ([*c]IDataAdviseHolder, [*c]([*c]IEnumSTATDATA)) callconv(.C) HRESULT,
    SendOnDataChange: ?fn ([*c]IDataAdviseHolder, [*c]IDataObject, DWORD, DWORD) callconv(.C) HRESULT,
};
pub const struct_IDataAdviseHolder = extern struct {
    lpVtbl: [*c]struct_IDataAdviseHolderVtbl,
};
pub const IMessageFilter = struct_IMessageFilter;
pub const struct_tagINTERFACEINFO = extern struct {
    pUnk: [*c]IUnknown,
    iid: IID,
    wMethod: WORD,
};
pub const LPINTERFACEINFO = [*c]struct_tagINTERFACEINFO;
pub const struct_IMessageFilterVtbl = extern struct {
    QueryInterface: ?fn ([*c]IMessageFilter, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IMessageFilter) callconv(.C) ULONG,
    Release: ?fn ([*c]IMessageFilter) callconv(.C) ULONG,
    HandleInComingCall: ?fn ([*c]IMessageFilter, DWORD, HTASK, DWORD, LPINTERFACEINFO) callconv(.C) DWORD,
    RetryRejectedCall: ?fn ([*c]IMessageFilter, HTASK, DWORD, DWORD) callconv(.C) DWORD,
    MessagePending: ?fn ([*c]IMessageFilter, HTASK, DWORD, DWORD) callconv(.C) DWORD,
};
pub const struct_IMessageFilter = extern struct {
    lpVtbl: [*c]struct_IMessageFilterVtbl,
};
pub const IClassActivator = struct_IClassActivator;
pub const struct_IClassActivatorVtbl = extern struct {
    QueryInterface: ?fn ([*c]IClassActivator, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IClassActivator) callconv(.C) ULONG,
    Release: ?fn ([*c]IClassActivator) callconv(.C) ULONG,
    GetClassObject: ?fn ([*c]IClassActivator, [*c]const IID, DWORD, LCID, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
};
pub const struct_IClassActivator = extern struct {
    lpVtbl: [*c]struct_IClassActivatorVtbl,
};
pub const IFillLockBytes = struct_IFillLockBytes;
pub const struct_IFillLockBytesVtbl = extern struct {
    QueryInterface: ?fn ([*c]IFillLockBytes, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IFillLockBytes) callconv(.C) ULONG,
    Release: ?fn ([*c]IFillLockBytes) callconv(.C) ULONG,
    FillAppend: ?fn ([*c]IFillLockBytes, ?*const c_void, ULONG, [*c]ULONG) callconv(.C) HRESULT,
    FillAt: ?fn ([*c]IFillLockBytes, ULARGE_INTEGER, ?*const c_void, ULONG, [*c]ULONG) callconv(.C) HRESULT,
    SetFillSize: ?fn ([*c]IFillLockBytes, ULARGE_INTEGER) callconv(.C) HRESULT,
    Terminate: ?fn ([*c]IFillLockBytes, BOOL) callconv(.C) HRESULT,
};
pub const struct_IFillLockBytes = extern struct {
    lpVtbl: [*c]struct_IFillLockBytesVtbl,
};
pub const IProgressNotify = struct_IProgressNotify;
pub const struct_IProgressNotifyVtbl = extern struct {
    QueryInterface: ?fn ([*c]IProgressNotify, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IProgressNotify) callconv(.C) ULONG,
    Release: ?fn ([*c]IProgressNotify) callconv(.C) ULONG,
    OnProgress: ?fn ([*c]IProgressNotify, DWORD, DWORD, BOOL, BOOL) callconv(.C) HRESULT,
};
pub const struct_IProgressNotify = extern struct {
    lpVtbl: [*c]struct_IProgressNotifyVtbl,
};
pub const ILayoutStorage = struct_ILayoutStorage;
pub const struct_tagStorageLayout = extern struct {
    LayoutType: DWORD,
    pwcsElementName: [*c]OLECHAR,
    cOffset: LARGE_INTEGER,
    cBytes: LARGE_INTEGER,
};
pub const StorageLayout = struct_tagStorageLayout;
pub const struct_ILayoutStorageVtbl = extern struct {
    QueryInterface: ?fn ([*c]ILayoutStorage, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ILayoutStorage) callconv(.C) ULONG,
    Release: ?fn ([*c]ILayoutStorage) callconv(.C) ULONG,
    LayoutScript: ?fn ([*c]ILayoutStorage, [*c]StorageLayout, DWORD, DWORD) callconv(.C) HRESULT,
    BeginMonitor: ?fn ([*c]ILayoutStorage) callconv(.C) HRESULT,
    EndMonitor: ?fn ([*c]ILayoutStorage) callconv(.C) HRESULT,
    ReLayoutDocfile: ?fn ([*c]ILayoutStorage, [*c]OLECHAR) callconv(.C) HRESULT,
    ReLayoutDocfileOnILockBytes: ?fn ([*c]ILayoutStorage, [*c]ILockBytes) callconv(.C) HRESULT,
};
pub const struct_ILayoutStorage = extern struct {
    lpVtbl: [*c]struct_ILayoutStorageVtbl,
};
pub const IBlockingLock = struct_IBlockingLock;
pub const struct_IBlockingLockVtbl = extern struct {
    QueryInterface: ?fn ([*c]IBlockingLock, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IBlockingLock) callconv(.C) ULONG,
    Release: ?fn ([*c]IBlockingLock) callconv(.C) ULONG,
    Lock: ?fn ([*c]IBlockingLock, DWORD) callconv(.C) HRESULT,
    Unlock: ?fn ([*c]IBlockingLock) callconv(.C) HRESULT,
};
pub const struct_IBlockingLock = extern struct {
    lpVtbl: [*c]struct_IBlockingLockVtbl,
};
pub const ITimeAndNoticeControl = struct_ITimeAndNoticeControl;
pub const struct_ITimeAndNoticeControlVtbl = extern struct {
    QueryInterface: ?fn ([*c]ITimeAndNoticeControl, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ITimeAndNoticeControl) callconv(.C) ULONG,
    Release: ?fn ([*c]ITimeAndNoticeControl) callconv(.C) ULONG,
    SuppressChanges: ?fn ([*c]ITimeAndNoticeControl, DWORD, DWORD) callconv(.C) HRESULT,
};
pub const struct_ITimeAndNoticeControl = extern struct {
    lpVtbl: [*c]struct_ITimeAndNoticeControlVtbl,
};
pub const IOplockStorage = struct_IOplockStorage;
pub const struct_IOplockStorageVtbl = extern struct {
    QueryInterface: ?fn ([*c]IOplockStorage, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IOplockStorage) callconv(.C) ULONG,
    Release: ?fn ([*c]IOplockStorage) callconv(.C) ULONG,
    CreateStorageEx: ?fn ([*c]IOplockStorage, LPCWSTR, DWORD, DWORD, DWORD, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    OpenStorageEx: ?fn ([*c]IOplockStorage, LPCWSTR, DWORD, DWORD, DWORD, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
};
pub const struct_IOplockStorage = extern struct {
    lpVtbl: [*c]struct_IOplockStorageVtbl,
};
pub const IDirectWriterLock = struct_IDirectWriterLock;
pub const struct_IDirectWriterLockVtbl = extern struct {
    QueryInterface: ?fn ([*c]IDirectWriterLock, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IDirectWriterLock) callconv(.C) ULONG,
    Release: ?fn ([*c]IDirectWriterLock) callconv(.C) ULONG,
    WaitForWriteAccess: ?fn ([*c]IDirectWriterLock, DWORD) callconv(.C) HRESULT,
    ReleaseWriteAccess: ?fn ([*c]IDirectWriterLock) callconv(.C) HRESULT,
    HaveWriteAccess: ?fn ([*c]IDirectWriterLock) callconv(.C) HRESULT,
};
pub const struct_IDirectWriterLock = extern struct {
    lpVtbl: [*c]struct_IDirectWriterLockVtbl,
};
pub const IUrlMon = struct_IUrlMon;
pub const struct_IUrlMonVtbl = extern struct {
    QueryInterface: ?fn ([*c]IUrlMon, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IUrlMon) callconv(.C) ULONG,
    Release: ?fn ([*c]IUrlMon) callconv(.C) ULONG,
    AsyncGetClassBits: ?fn ([*c]IUrlMon, [*c]const IID, LPCWSTR, LPCWSTR, DWORD, DWORD, LPCWSTR, [*c]IBindCtx, DWORD, [*c]const IID, DWORD) callconv(.C) HRESULT,
};
pub const struct_IUrlMon = extern struct {
    lpVtbl: [*c]struct_IUrlMonVtbl,
};
pub const IForegroundTransfer = struct_IForegroundTransfer;
pub const struct_IForegroundTransferVtbl = extern struct {
    QueryInterface: ?fn ([*c]IForegroundTransfer, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IForegroundTransfer) callconv(.C) ULONG,
    Release: ?fn ([*c]IForegroundTransfer) callconv(.C) ULONG,
    AllowForegroundTransfer: ?fn ([*c]IForegroundTransfer, ?*c_void) callconv(.C) HRESULT,
};
pub const struct_IForegroundTransfer = extern struct {
    lpVtbl: [*c]struct_IForegroundTransferVtbl,
};
pub const IThumbnailExtractor = struct_IThumbnailExtractor;
pub const struct_IThumbnailExtractorVtbl = extern struct {
    QueryInterface: ?fn ([*c]IThumbnailExtractor, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IThumbnailExtractor) callconv(.C) ULONG,
    Release: ?fn ([*c]IThumbnailExtractor) callconv(.C) ULONG,
    ExtractThumbnail: ?fn ([*c]IThumbnailExtractor, [*c]IStorage, ULONG, ULONG, [*c]ULONG, [*c]ULONG, [*c]HBITMAP) callconv(.C) HRESULT,
    OnFileUpdated: ?fn ([*c]IThumbnailExtractor, [*c]IStorage) callconv(.C) HRESULT,
};
pub const struct_IThumbnailExtractor = extern struct {
    lpVtbl: [*c]struct_IThumbnailExtractorVtbl,
};
pub const IDummyHICONIncluder = struct_IDummyHICONIncluder;
pub const struct_IDummyHICONIncluderVtbl = extern struct {
    QueryInterface: ?fn ([*c]IDummyHICONIncluder, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IDummyHICONIncluder) callconv(.C) ULONG,
    Release: ?fn ([*c]IDummyHICONIncluder) callconv(.C) ULONG,
    Dummy: ?fn ([*c]IDummyHICONIncluder, HICON, HDC) callconv(.C) HRESULT,
};
pub const struct_IDummyHICONIncluder = extern struct {
    lpVtbl: [*c]struct_IDummyHICONIncluderVtbl,
};
pub const IProcessLock = struct_IProcessLock;
pub const struct_IProcessLockVtbl = extern struct {
    QueryInterface: ?fn ([*c]IProcessLock, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IProcessLock) callconv(.C) ULONG,
    Release: ?fn ([*c]IProcessLock) callconv(.C) ULONG,
    AddRefOnProcess: ?fn ([*c]IProcessLock) callconv(.C) ULONG,
    ReleaseRefOnProcess: ?fn ([*c]IProcessLock) callconv(.C) ULONG,
};
pub const struct_IProcessLock = extern struct {
    lpVtbl: [*c]struct_IProcessLockVtbl,
};
pub const ISurrogateService = struct_ISurrogateService;
pub const ServerApplication = enum_tagApplicationType.ServerApplication;
pub const LibraryApplication = enum_tagApplicationType.LibraryApplication;
pub const enum_tagApplicationType = extern enum {
    ServerApplication = 0,
    LibraryApplication = 1,
};
pub const ApplicationType = extern enum {
    ServerApplication = 0,
    LibraryApplication = 1,
};
pub const IdleShutdown = enum_tagShutdownType.IdleShutdown;
pub const ForcedShutdown = enum_tagShutdownType.ForcedShutdown;
pub const enum_tagShutdownType = extern enum {
    IdleShutdown = 0,
    ForcedShutdown = 1,
};
pub const ShutdownType = extern enum {
    IdleShutdown = 0,
    ForcedShutdown = 1,
};
pub const struct_ISurrogateServiceVtbl = extern struct {
    QueryInterface: ?fn ([*c]ISurrogateService, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ISurrogateService) callconv(.C) ULONG,
    Release: ?fn ([*c]ISurrogateService) callconv(.C) ULONG,
    Init: ?fn ([*c]ISurrogateService, [*c]const GUID, [*c]IProcessLock, [*c]BOOL) callconv(.C) HRESULT,
    ApplicationLaunch: ?fn ([*c]ISurrogateService, [*c]const GUID, ApplicationType) callconv(.C) HRESULT,
    ApplicationFree: ?fn ([*c]ISurrogateService, [*c]const GUID) callconv(.C) HRESULT,
    CatalogRefresh: ?fn ([*c]ISurrogateService, ULONG) callconv(.C) HRESULT,
    ProcessShutdown: ?fn ([*c]ISurrogateService, ShutdownType) callconv(.C) HRESULT,
};
pub const struct_ISurrogateService = extern struct {
    lpVtbl: [*c]struct_ISurrogateServiceVtbl,
};
pub const IInitializeSpy = struct_IInitializeSpy;
pub const struct_IInitializeSpyVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInitializeSpy, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInitializeSpy) callconv(.C) ULONG,
    Release: ?fn ([*c]IInitializeSpy) callconv(.C) ULONG,
    PreInitialize: ?fn ([*c]IInitializeSpy, DWORD, DWORD) callconv(.C) HRESULT,
    PostInitialize: ?fn ([*c]IInitializeSpy, HRESULT, DWORD, DWORD) callconv(.C) HRESULT,
    PreUninitialize: ?fn ([*c]IInitializeSpy, DWORD) callconv(.C) HRESULT,
    PostUninitialize: ?fn ([*c]IInitializeSpy, DWORD) callconv(.C) HRESULT,
};
pub const struct_IInitializeSpy = extern struct {
    lpVtbl: [*c]struct_IInitializeSpyVtbl,
};
pub const IApartmentShutdown = struct_IApartmentShutdown;
pub const struct_IApartmentShutdownVtbl = extern struct {
    QueryInterface: ?fn ([*c]IApartmentShutdown, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IApartmentShutdown) callconv(.C) ULONG,
    Release: ?fn ([*c]IApartmentShutdown) callconv(.C) ULONG,
    OnUninitialize: ?fn ([*c]IApartmentShutdown, UINT64) callconv(.C) void,
};
pub const struct_IApartmentShutdown = extern struct {
    lpVtbl: [*c]struct_IApartmentShutdownVtbl,
};
pub extern var __MIDL_itf_unknwn_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_unknwn_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_unknwn_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_unknwn_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_unknwn_0000_0002_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_unknwn_0000_0002_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_unknwn_0000_0003_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_unknwn_0000_0003_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0053_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0053_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPMALLOCSPY = [*c]IMallocSpy;
pub extern const IID_IMallocSpy: IID;
pub const IMallocSpyVtbl = struct_IMallocSpyVtbl;
pub extern var __MIDL_itf_objidl_0000_0054_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0054_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPBC = [*c]IBindCtx;
pub const LPBIND_OPTS = [*c]struct_tagBIND_OPTS;
pub const struct_tagBIND_OPTS2 = extern struct {
    cbStruct: DWORD,
    grfFlags: DWORD,
    grfMode: DWORD,
    dwTickCountDeadline: DWORD,
    dwTrackFlags: DWORD,
    dwClassContext: DWORD,
    locale: LCID,
    pServerInfo: [*c]COSERVERINFO,
};
pub const BIND_OPTS2 = struct_tagBIND_OPTS2;
pub const LPBIND_OPTS2 = [*c]struct_tagBIND_OPTS2;
pub const struct_tagBIND_OPTS3 = extern struct {
    cbStruct: DWORD,
    grfFlags: DWORD,
    grfMode: DWORD,
    dwTickCountDeadline: DWORD,
    dwTrackFlags: DWORD,
    dwClassContext: DWORD,
    locale: LCID,
    pServerInfo: [*c]COSERVERINFO,
    hwnd: HWND,
};
pub const BIND_OPTS3 = struct_tagBIND_OPTS3;
pub const LPBIND_OPTS3 = [*c]struct_tagBIND_OPTS3;
pub const BIND_MAYBOTHERUSER = enum_tagBIND_FLAGS.BIND_MAYBOTHERUSER;
pub const BIND_JUSTTESTEXISTENCE = enum_tagBIND_FLAGS.BIND_JUSTTESTEXISTENCE;
pub const enum_tagBIND_FLAGS = extern enum {
    BIND_MAYBOTHERUSER = 1,
    BIND_JUSTTESTEXISTENCE = 2,
};
pub const BIND_FLAGS = enum_tagBIND_FLAGS;
pub extern const IID_IBindCtx: IID;
pub const IBindCtxVtbl = struct_IBindCtxVtbl;
pub extern fn IBindCtx_RemoteSetBindOptions_Proxy(This: [*c]IBindCtx, pbindopts: [*c]BIND_OPTS2) HRESULT;
pub extern fn IBindCtx_RemoteSetBindOptions_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IBindCtx_RemoteGetBindOptions_Proxy(This: [*c]IBindCtx, pbindopts: [*c]BIND_OPTS2) HRESULT;
pub extern fn IBindCtx_RemoteGetBindOptions_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub const LPENUMMONIKER = [*c]IEnumMoniker;
pub extern const IID_IEnumMoniker: IID;
pub const IEnumMonikerVtbl = struct_IEnumMonikerVtbl;
pub extern fn IEnumMoniker_RemoteNext_Proxy(This: [*c]IEnumMoniker, celt: ULONG, rgelt: [*c]([*c]IMoniker), pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumMoniker_RemoteNext_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_objidl_0000_0056_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0056_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPRUNNABLEOBJECT = [*c]IRunnableObject;
pub extern const IID_IRunnableObject: IID;
pub const IRunnableObjectVtbl = struct_IRunnableObjectVtbl;
pub extern fn IRunnableObject_RemoteIsRunning_Proxy(This: [*c]IRunnableObject) HRESULT;
pub extern fn IRunnableObject_RemoteIsRunning_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub const LPRUNNINGOBJECTTABLE = [*c]IRunningObjectTable;
pub extern const IID_IRunningObjectTable: IID;
pub const IRunningObjectTableVtbl = struct_IRunningObjectTableVtbl;
pub extern var __MIDL_itf_objidl_0000_0058_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0058_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPPERSIST = [*c]IPersist;
pub extern const IID_IPersist: IID;
pub const IPersistVtbl = struct_IPersistVtbl;
pub const LPPERSISTSTREAM = [*c]IPersistStream;
pub extern const IID_IPersistStream: IID;
pub const IPersistStreamVtbl = struct_IPersistStreamVtbl;
pub const LPMONIKER = [*c]IMoniker;
pub const MKSYS_NONE = enum_tagMKSYS.MKSYS_NONE;
pub const MKSYS_GENERICCOMPOSITE = enum_tagMKSYS.MKSYS_GENERICCOMPOSITE;
pub const MKSYS_FILEMONIKER = enum_tagMKSYS.MKSYS_FILEMONIKER;
pub const MKSYS_ANTIMONIKER = enum_tagMKSYS.MKSYS_ANTIMONIKER;
pub const MKSYS_ITEMMONIKER = enum_tagMKSYS.MKSYS_ITEMMONIKER;
pub const MKSYS_POINTERMONIKER = enum_tagMKSYS.MKSYS_POINTERMONIKER;
pub const MKSYS_CLASSMONIKER = enum_tagMKSYS.MKSYS_CLASSMONIKER;
pub const MKSYS_OBJREFMONIKER = enum_tagMKSYS.MKSYS_OBJREFMONIKER;
pub const MKSYS_SESSIONMONIKER = enum_tagMKSYS.MKSYS_SESSIONMONIKER;
pub const MKSYS_LUAMONIKER = enum_tagMKSYS.MKSYS_LUAMONIKER;
pub const enum_tagMKSYS = extern enum {
    MKSYS_NONE = 0,
    MKSYS_GENERICCOMPOSITE = 1,
    MKSYS_FILEMONIKER = 2,
    MKSYS_ANTIMONIKER = 3,
    MKSYS_ITEMMONIKER = 4,
    MKSYS_POINTERMONIKER = 5,
    MKSYS_CLASSMONIKER = 7,
    MKSYS_OBJREFMONIKER = 8,
    MKSYS_SESSIONMONIKER = 9,
    MKSYS_LUAMONIKER = 10,
};
pub const MKSYS = enum_tagMKSYS;
pub const MKRREDUCE_ONE = enum_tagMKREDUCE.MKRREDUCE_ONE;
pub const MKRREDUCE_TOUSER = enum_tagMKREDUCE.MKRREDUCE_TOUSER;
pub const MKRREDUCE_THROUGHUSER = enum_tagMKREDUCE.MKRREDUCE_THROUGHUSER;
pub const MKRREDUCE_ALL = enum_tagMKREDUCE.MKRREDUCE_ALL;
pub const enum_tagMKREDUCE = extern enum {
    MKRREDUCE_ONE = 196608,
    MKRREDUCE_TOUSER = 131072,
    MKRREDUCE_THROUGHUSER = 65536,
    MKRREDUCE_ALL = 0,
};
pub const MKRREDUCE = enum_tagMKREDUCE;
pub extern const IID_IMoniker: IID;
pub const IMonikerVtbl = struct_IMonikerVtbl;
pub extern fn IMoniker_RemoteBindToObject_Proxy(This: [*c]IMoniker, pbc: [*c]IBindCtx, pmkToLeft: [*c]IMoniker, riidResult: [*c]const IID, ppvResult: [*c]([*c]IUnknown)) HRESULT;
pub extern fn IMoniker_RemoteBindToObject_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IMoniker_RemoteBindToStorage_Proxy(This: [*c]IMoniker, pbc: [*c]IBindCtx, pmkToLeft: [*c]IMoniker, riid: [*c]const IID, ppvObj: [*c]([*c]IUnknown)) HRESULT;
pub extern fn IMoniker_RemoteBindToStorage_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_objidl_0000_0061_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0061_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IROTData: IID;
pub const IROTDataVtbl = struct_IROTDataVtbl;
pub extern var __MIDL_itf_objidl_0000_0062_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0062_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPENUMSTATSTG = [*c]IEnumSTATSTG;
pub extern const IID_IEnumSTATSTG: IID;
pub const IEnumSTATSTGVtbl = struct_IEnumSTATSTGVtbl;
pub extern fn IEnumSTATSTG_RemoteNext_Proxy(This: [*c]IEnumSTATSTG, celt: ULONG, rgelt: [*c]STATSTG, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumSTATSTG_RemoteNext_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub const LPSTORAGE = [*c]IStorage;
pub const struct_tagRemSNB = extern struct {
    ulCntStr: ULONG,
    ulCntChar: ULONG,
    rgString: [1]OLECHAR,
};
pub const RemSNB = struct_tagRemSNB;
pub const wireSNB = [*c]RemSNB;
pub extern const IID_IStorage: IID;
pub const IStorageVtbl = struct_IStorageVtbl;
pub extern fn IStorage_RemoteOpenStream_Proxy(This: [*c]IStorage, pwcsName: [*c]const OLECHAR, cbReserved1: ULONG, reserved1: [*c]byte, grfMode: DWORD, reserved2: DWORD, ppstm: [*c]([*c]IStream)) HRESULT;
pub extern fn IStorage_RemoteOpenStream_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IStorage_RemoteCopyTo_Proxy(This: [*c]IStorage, ciidExclude: DWORD, rgiidExclude: [*c]const IID, snbExclude: SNB, pstgDest: [*c]IStorage) HRESULT;
pub extern fn IStorage_RemoteCopyTo_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IStorage_RemoteEnumElements_Proxy(This: [*c]IStorage, reserved1: DWORD, cbReserved2: ULONG, reserved2: [*c]byte, reserved3: DWORD, ppenum: [*c]([*c]IEnumSTATSTG)) HRESULT;
pub extern fn IStorage_RemoteEnumElements_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_objidl_0000_0064_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0064_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPPERSISTFILE = [*c]IPersistFile;
pub extern const IID_IPersistFile: IID;
pub const IPersistFileVtbl = struct_IPersistFileVtbl;
pub const LPPERSISTSTORAGE = [*c]IPersistStorage;
pub extern const IID_IPersistStorage: IID;
pub const IPersistStorageVtbl = struct_IPersistStorageVtbl;
pub extern var __MIDL_itf_objidl_0000_0066_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0066_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPLOCKBYTES = [*c]ILockBytes;
pub extern const IID_ILockBytes: IID;
pub const ILockBytesVtbl = struct_ILockBytesVtbl;
pub extern fn ILockBytes_RemoteReadAt_Proxy(This: [*c]ILockBytes, ulOffset: ULARGE_INTEGER, pv: [*c]byte, cb: ULONG, pcbRead: [*c]ULONG) HRESULT;
pub extern fn ILockBytes_RemoteReadAt_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ILockBytes_RemoteWriteAt_Proxy(This: [*c]ILockBytes, ulOffset: ULARGE_INTEGER, pv: [*c]const byte, cb: ULONG, pcbWritten: [*c]ULONG) HRESULT;
pub extern fn ILockBytes_RemoteWriteAt_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub const LPENUMFORMATETC = [*c]IEnumFORMATETC;
pub const LPCLIPFORMAT = [*c]CLIPFORMAT;
pub const LPFORMATETC = [*c]struct_tagFORMATETC;
pub extern const IID_IEnumFORMATETC: IID;
pub const IEnumFORMATETCVtbl = struct_IEnumFORMATETCVtbl;
pub extern fn IEnumFORMATETC_RemoteNext_Proxy(This: [*c]IEnumFORMATETC, celt: ULONG, rgelt: [*c]FORMATETC, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumFORMATETC_RemoteNext_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub const LPENUMSTATDATA = [*c]IEnumSTATDATA;
pub const ADVF_NODATA = enum_tagADVF.ADVF_NODATA;
pub const ADVF_PRIMEFIRST = enum_tagADVF.ADVF_PRIMEFIRST;
pub const ADVF_ONLYONCE = enum_tagADVF.ADVF_ONLYONCE;
pub const ADVF_DATAONSTOP = enum_tagADVF.ADVF_DATAONSTOP;
pub const ADVFCACHE_NOHANDLER = enum_tagADVF.ADVFCACHE_NOHANDLER;
pub const ADVFCACHE_FORCEBUILTIN = enum_tagADVF.ADVFCACHE_FORCEBUILTIN;
pub const ADVFCACHE_ONSAVE = enum_tagADVF.ADVFCACHE_ONSAVE;
pub const enum_tagADVF = extern enum {
    ADVF_NODATA = 1,
    ADVF_PRIMEFIRST = 2,
    ADVF_ONLYONCE = 4,
    ADVF_DATAONSTOP = 64,
    ADVFCACHE_NOHANDLER = 8,
    ADVFCACHE_FORCEBUILTIN = 16,
    ADVFCACHE_ONSAVE = 32,
};
pub const ADVF = enum_tagADVF;
pub const LPSTATDATA = [*c]STATDATA;
pub extern const IID_IEnumSTATDATA: IID;
pub const IEnumSTATDATAVtbl = struct_IEnumSTATDATAVtbl;
pub extern fn IEnumSTATDATA_RemoteNext_Proxy(This: [*c]IEnumSTATDATA, celt: ULONG, rgelt: [*c]STATDATA, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumSTATDATA_RemoteNext_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub const LPROOTSTORAGE = [*c]IRootStorage;
pub extern const IID_IRootStorage: IID;
pub const IRootStorageVtbl = struct_IRootStorageVtbl;
pub const LPADVISESINK = [*c]IAdviseSink;
pub const TYMED_HGLOBAL = enum_tagTYMED.TYMED_HGLOBAL;
pub const TYMED_FILE = enum_tagTYMED.TYMED_FILE;
pub const TYMED_ISTREAM = enum_tagTYMED.TYMED_ISTREAM;
pub const TYMED_ISTORAGE = enum_tagTYMED.TYMED_ISTORAGE;
pub const TYMED_GDI = enum_tagTYMED.TYMED_GDI;
pub const TYMED_MFPICT = enum_tagTYMED.TYMED_MFPICT;
pub const TYMED_ENHMF = enum_tagTYMED.TYMED_ENHMF;
pub const TYMED_NULL = enum_tagTYMED.TYMED_NULL;
pub const enum_tagTYMED = extern enum {
    TYMED_HGLOBAL = 1,
    TYMED_FILE = 2,
    TYMED_ISTREAM = 4,
    TYMED_ISTORAGE = 8,
    TYMED_GDI = 16,
    TYMED_MFPICT = 32,
    TYMED_ENHMF = 64,
    TYMED_NULL = 0,
};
pub const TYMED = enum_tagTYMED;
pub const struct_tagRemSTGMEDIUM = extern struct {
    tymed: DWORD,
    dwHandleType: DWORD,
    pData: ULONG,
    pUnkForRelease: ULONG,
    cbData: ULONG,
    data: [1]byte,
};
pub const RemSTGMEDIUM = struct_tagRemSTGMEDIUM;
pub const union___MIDL_IAdviseSink_0002 = extern union {
    hBitmap: wireHBITMAP,
    hPalette: wireHPALETTE,
    hGeneric: wireHGLOBAL,
};
pub const struct__GDI_OBJECT = extern struct {
    ObjectType: DWORD,
    u: union___MIDL_IAdviseSink_0002,
};
pub const GDI_OBJECT = struct__GDI_OBJECT;
pub const union___MIDL_IAdviseSink_0003 = extern union {
    hMetaFilePict: wireHMETAFILEPICT,
    hHEnhMetaFile: wireHENHMETAFILE,
    hGdiHandle: [*c]GDI_OBJECT,
    hGlobal: wireHGLOBAL,
    lpszFileName: LPOLESTR,
    pstm: [*c]BYTE_BLOB,
    pstg: [*c]BYTE_BLOB,
};
pub const struct__STGMEDIUM_UNION = extern struct {
    tymed: DWORD,
    u: union___MIDL_IAdviseSink_0003,
};
pub const struct__userSTGMEDIUM = extern struct {
    @"": struct__STGMEDIUM_UNION,
    pUnkForRelease: [*c]IUnknown,
};
pub const userSTGMEDIUM = struct__userSTGMEDIUM;
pub const wireSTGMEDIUM = [*c]userSTGMEDIUM;
pub const wireASYNC_STGMEDIUM = [*c]userSTGMEDIUM;
pub const ASYNC_STGMEDIUM = STGMEDIUM;
pub const LPSTGMEDIUM = [*c]STGMEDIUM;
pub const struct__userFLAG_STGMEDIUM = extern struct {
    ContextFlags: LONG,
    fPassOwnership: LONG,
    Stgmed: userSTGMEDIUM,
};
pub const userFLAG_STGMEDIUM = struct__userFLAG_STGMEDIUM;
pub const wireFLAG_STGMEDIUM = [*c]userFLAG_STGMEDIUM;
pub const struct__FLAG_STGMEDIUM = extern struct {
    ContextFlags: LONG,
    fPassOwnership: LONG,
    Stgmed: STGMEDIUM,
};
pub const FLAG_STGMEDIUM = struct__FLAG_STGMEDIUM;
pub extern const IID_IAdviseSink: IID;
pub const IAdviseSinkVtbl = struct_IAdviseSinkVtbl;
pub extern fn IAdviseSink_RemoteOnDataChange_Proxy(This: [*c]IAdviseSink, pFormatetc: [*c]FORMATETC, pStgmed: [*c]ASYNC_STGMEDIUM) HRESULT;
pub extern fn IAdviseSink_RemoteOnDataChange_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IAdviseSink_RemoteOnViewChange_Proxy(This: [*c]IAdviseSink, dwAspect: DWORD, lindex: LONG) HRESULT;
pub extern fn IAdviseSink_RemoteOnViewChange_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IAdviseSink_RemoteOnRename_Proxy(This: [*c]IAdviseSink, pmk: [*c]IMoniker) HRESULT;
pub extern fn IAdviseSink_RemoteOnRename_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IAdviseSink_RemoteOnSave_Proxy(This: [*c]IAdviseSink) HRESULT;
pub extern fn IAdviseSink_RemoteOnSave_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IAdviseSink_RemoteOnClose_Proxy(This: [*c]IAdviseSink) HRESULT;
pub extern fn IAdviseSink_RemoteOnClose_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern const IID_AsyncIAdviseSink: IID;
pub const AsyncIAdviseSinkVtbl = struct_AsyncIAdviseSinkVtbl;
pub extern fn AsyncIAdviseSink_Begin_RemoteOnDataChange_Proxy(This: [*c]AsyncIAdviseSink, pFormatetc: [*c]FORMATETC, pStgmed: [*c]ASYNC_STGMEDIUM) HRESULT;
pub extern fn AsyncIAdviseSink_Begin_RemoteOnDataChange_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn AsyncIAdviseSink_Finish_RemoteOnDataChange_Proxy(This: [*c]AsyncIAdviseSink) HRESULT;
pub extern fn AsyncIAdviseSink_Finish_RemoteOnDataChange_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn AsyncIAdviseSink_Begin_RemoteOnViewChange_Proxy(This: [*c]AsyncIAdviseSink, dwAspect: DWORD, lindex: LONG) HRESULT;
pub extern fn AsyncIAdviseSink_Begin_RemoteOnViewChange_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn AsyncIAdviseSink_Finish_RemoteOnViewChange_Proxy(This: [*c]AsyncIAdviseSink) HRESULT;
pub extern fn AsyncIAdviseSink_Finish_RemoteOnViewChange_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn AsyncIAdviseSink_Begin_RemoteOnRename_Proxy(This: [*c]AsyncIAdviseSink, pmk: [*c]IMoniker) HRESULT;
pub extern fn AsyncIAdviseSink_Begin_RemoteOnRename_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn AsyncIAdviseSink_Finish_RemoteOnRename_Proxy(This: [*c]AsyncIAdviseSink) HRESULT;
pub extern fn AsyncIAdviseSink_Finish_RemoteOnRename_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn AsyncIAdviseSink_Begin_RemoteOnSave_Proxy(This: [*c]AsyncIAdviseSink) HRESULT;
pub extern fn AsyncIAdviseSink_Begin_RemoteOnSave_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn AsyncIAdviseSink_Finish_RemoteOnSave_Proxy(This: [*c]AsyncIAdviseSink) HRESULT;
pub extern fn AsyncIAdviseSink_Finish_RemoteOnSave_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn AsyncIAdviseSink_Begin_RemoteOnClose_Proxy(This: [*c]AsyncIAdviseSink) HRESULT;
pub extern fn AsyncIAdviseSink_Begin_RemoteOnClose_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn AsyncIAdviseSink_Finish_RemoteOnClose_Proxy(This: [*c]AsyncIAdviseSink) HRESULT;
pub extern fn AsyncIAdviseSink_Finish_RemoteOnClose_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_objidl_0000_0071_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0071_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPADVISESINK2 = [*c]IAdviseSink2;
pub extern const IID_IAdviseSink2: IID;
pub const IAdviseSink2Vtbl = struct_IAdviseSink2Vtbl;
pub extern fn IAdviseSink2_RemoteOnLinkSrcChange_Proxy(This: [*c]IAdviseSink2, pmk: [*c]IMoniker) HRESULT;
pub extern fn IAdviseSink2_RemoteOnLinkSrcChange_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern const IID_AsyncIAdviseSink2: IID;
pub const AsyncIAdviseSink2Vtbl = struct_AsyncIAdviseSink2Vtbl;
pub extern fn AsyncIAdviseSink2_Begin_RemoteOnLinkSrcChange_Proxy(This: [*c]AsyncIAdviseSink2, pmk: [*c]IMoniker) HRESULT;
pub extern fn AsyncIAdviseSink2_Begin_RemoteOnLinkSrcChange_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn AsyncIAdviseSink2_Finish_RemoteOnLinkSrcChange_Proxy(This: [*c]AsyncIAdviseSink2) HRESULT;
pub extern fn AsyncIAdviseSink2_Finish_RemoteOnLinkSrcChange_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_objidl_0000_0072_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0072_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPDATAOBJECT = [*c]IDataObject;
pub const DATADIR_GET = enum_tagDATADIR.DATADIR_GET;
pub const DATADIR_SET = enum_tagDATADIR.DATADIR_SET;
pub const enum_tagDATADIR = extern enum {
    DATADIR_GET = 1,
    DATADIR_SET = 2,
};
pub const DATADIR = enum_tagDATADIR;
pub extern const IID_IDataObject: IID;
pub const IDataObjectVtbl = struct_IDataObjectVtbl;
pub extern fn IDataObject_RemoteGetData_Proxy(This: [*c]IDataObject, pformatetcIn: [*c]FORMATETC, pRemoteMedium: [*c]STGMEDIUM) HRESULT;
pub extern fn IDataObject_RemoteGetData_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IDataObject_RemoteGetDataHere_Proxy(This: [*c]IDataObject, pformatetc: [*c]FORMATETC, pRemoteMedium: [*c]STGMEDIUM) HRESULT;
pub extern fn IDataObject_RemoteGetDataHere_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IDataObject_RemoteSetData_Proxy(This: [*c]IDataObject, pformatetc: [*c]FORMATETC, pmedium: [*c]FLAG_STGMEDIUM, fRelease: BOOL) HRESULT;
pub extern fn IDataObject_RemoteSetData_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_objidl_0000_0073_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0073_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPDATAADVISEHOLDER = [*c]IDataAdviseHolder;
pub extern const IID_IDataAdviseHolder: IID;
pub const IDataAdviseHolderVtbl = struct_IDataAdviseHolderVtbl;
pub const LPMESSAGEFILTER = [*c]IMessageFilter;
pub const CALLTYPE_TOPLEVEL = enum_tagCALLTYPE.CALLTYPE_TOPLEVEL;
pub const CALLTYPE_NESTED = enum_tagCALLTYPE.CALLTYPE_NESTED;
pub const CALLTYPE_ASYNC = enum_tagCALLTYPE.CALLTYPE_ASYNC;
pub const CALLTYPE_TOPLEVEL_CALLPENDING = enum_tagCALLTYPE.CALLTYPE_TOPLEVEL_CALLPENDING;
pub const CALLTYPE_ASYNC_CALLPENDING = enum_tagCALLTYPE.CALLTYPE_ASYNC_CALLPENDING;
pub const enum_tagCALLTYPE = extern enum {
    CALLTYPE_TOPLEVEL = 1,
    CALLTYPE_NESTED = 2,
    CALLTYPE_ASYNC = 3,
    CALLTYPE_TOPLEVEL_CALLPENDING = 4,
    CALLTYPE_ASYNC_CALLPENDING = 5,
};
pub const CALLTYPE = enum_tagCALLTYPE;
pub const SERVERCALL_ISHANDLED = enum_tagSERVERCALL.SERVERCALL_ISHANDLED;
pub const SERVERCALL_REJECTED = enum_tagSERVERCALL.SERVERCALL_REJECTED;
pub const SERVERCALL_RETRYLATER = enum_tagSERVERCALL.SERVERCALL_RETRYLATER;
pub const enum_tagSERVERCALL = extern enum {
    SERVERCALL_ISHANDLED = 0,
    SERVERCALL_REJECTED = 1,
    SERVERCALL_RETRYLATER = 2,
};
pub const SERVERCALL = enum_tagSERVERCALL;
pub const PENDINGTYPE_TOPLEVEL = enum_tagPENDINGTYPE.PENDINGTYPE_TOPLEVEL;
pub const PENDINGTYPE_NESTED = enum_tagPENDINGTYPE.PENDINGTYPE_NESTED;
pub const enum_tagPENDINGTYPE = extern enum {
    PENDINGTYPE_TOPLEVEL = 1,
    PENDINGTYPE_NESTED = 2,
};
pub const PENDINGTYPE = enum_tagPENDINGTYPE;
pub const PENDINGMSG_CANCELCALL = enum_tagPENDINGMSG.PENDINGMSG_CANCELCALL;
pub const PENDINGMSG_WAITNOPROCESS = enum_tagPENDINGMSG.PENDINGMSG_WAITNOPROCESS;
pub const PENDINGMSG_WAITDEFPROCESS = enum_tagPENDINGMSG.PENDINGMSG_WAITDEFPROCESS;
pub const enum_tagPENDINGMSG = extern enum {
    PENDINGMSG_CANCELCALL = 0,
    PENDINGMSG_WAITNOPROCESS = 1,
    PENDINGMSG_WAITDEFPROCESS = 2,
};
pub const PENDINGMSG = enum_tagPENDINGMSG;
pub const INTERFACEINFO = struct_tagINTERFACEINFO;
pub extern const IID_IMessageFilter: IID;
pub const IMessageFilterVtbl = struct_IMessageFilterVtbl;
pub extern const FMTID_SummaryInformation: FMTID;
pub extern const FMTID_DocSummaryInformation: FMTID;
pub extern const FMTID_UserDefinedProperties: FMTID;
pub extern const FMTID_DiscardableInformation: FMTID;
pub extern const FMTID_ImageSummaryInformation: FMTID;
pub extern const FMTID_AudioSummaryInformation: FMTID;
pub extern const FMTID_VideoSummaryInformation: FMTID;
pub extern const FMTID_MediaFileSummaryInformation: FMTID;
pub extern var __MIDL_itf_objidl_0000_0075_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0075_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IClassActivator: IID;
pub const IClassActivatorVtbl = struct_IClassActivatorVtbl;
pub extern var __MIDL_itf_objidl_0000_0076_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0076_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IFillLockBytes: IID;
pub const IFillLockBytesVtbl = struct_IFillLockBytesVtbl;
pub extern fn IFillLockBytes_RemoteFillAppend_Proxy(This: [*c]IFillLockBytes, pv: [*c]const byte, cb: ULONG, pcbWritten: [*c]ULONG) HRESULT;
pub extern fn IFillLockBytes_RemoteFillAppend_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IFillLockBytes_RemoteFillAt_Proxy(This: [*c]IFillLockBytes, ulOffset: ULARGE_INTEGER, pv: [*c]const byte, cb: ULONG, pcbWritten: [*c]ULONG) HRESULT;
pub extern fn IFillLockBytes_RemoteFillAt_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_objidl_0000_0077_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0077_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IProgressNotify: IID;
pub const IProgressNotifyVtbl = struct_IProgressNotifyVtbl;
pub extern var __MIDL_itf_objidl_0000_0078_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0078_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_ILayoutStorage: IID;
pub const ILayoutStorageVtbl = struct_ILayoutStorageVtbl;
pub extern var __MIDL_itf_objidl_0000_0079_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0079_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IBlockingLock: IID;
pub const IBlockingLockVtbl = struct_IBlockingLockVtbl;
pub extern const IID_ITimeAndNoticeControl: IID;
pub const ITimeAndNoticeControlVtbl = struct_ITimeAndNoticeControlVtbl;
pub extern const IID_IOplockStorage: IID;
pub const IOplockStorageVtbl = struct_IOplockStorageVtbl;
pub extern var __MIDL_itf_objidl_0000_0082_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0082_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IDirectWriterLock: IID;
pub const IDirectWriterLockVtbl = struct_IDirectWriterLockVtbl;
pub extern var __MIDL_itf_objidl_0000_0083_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0083_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IUrlMon: IID;
pub const IUrlMonVtbl = struct_IUrlMonVtbl;
pub extern const IID_IForegroundTransfer: IID;
pub const IForegroundTransferVtbl = struct_IForegroundTransferVtbl;
pub extern const IID_IThumbnailExtractor: IID;
pub const IThumbnailExtractorVtbl = struct_IThumbnailExtractorVtbl;
pub extern const IID_IDummyHICONIncluder: IID;
pub const IDummyHICONIncluderVtbl = struct_IDummyHICONIncluderVtbl;
pub extern var __MIDL_itf_objidl_0000_0087_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0087_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IProcessLock: IID;
pub const IProcessLockVtbl = struct_IProcessLockVtbl;
pub extern const IID_ISurrogateService: IID;
pub const ISurrogateServiceVtbl = struct_ISurrogateServiceVtbl;
pub extern var __MIDL_itf_objidl_0000_0089_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0089_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPINITIALIZESPY = [*c]IInitializeSpy;
pub extern const IID_IInitializeSpy: IID;
pub const IInitializeSpyVtbl = struct_IInitializeSpyVtbl;
pub extern var __MIDL_itf_objidl_0000_0090_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0090_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IApartmentShutdown: IID;
pub const IApartmentShutdownVtbl = struct_IApartmentShutdownVtbl;
pub extern var __MIDL_itf_objidl_0000_0091_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_objidl_0000_0091_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern fn ASYNC_STGMEDIUM_UserSize(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]ASYNC_STGMEDIUM) c_ulong;
pub extern fn ASYNC_STGMEDIUM_UserMarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]ASYNC_STGMEDIUM) [*c]u8;
pub extern fn ASYNC_STGMEDIUM_UserUnmarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]ASYNC_STGMEDIUM) [*c]u8;
pub extern fn ASYNC_STGMEDIUM_UserFree(arg0: [*c]c_ulong, arg1: [*c]ASYNC_STGMEDIUM) void;
pub extern fn CLIPFORMAT_UserSize(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]CLIPFORMAT) c_ulong;
pub extern fn CLIPFORMAT_UserMarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]CLIPFORMAT) [*c]u8;
pub extern fn CLIPFORMAT_UserUnmarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]CLIPFORMAT) [*c]u8;
pub extern fn CLIPFORMAT_UserFree(arg0: [*c]c_ulong, arg1: [*c]CLIPFORMAT) void;
pub extern fn FLAG_STGMEDIUM_UserSize(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]FLAG_STGMEDIUM) c_ulong;
pub extern fn FLAG_STGMEDIUM_UserMarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]FLAG_STGMEDIUM) [*c]u8;
pub extern fn FLAG_STGMEDIUM_UserUnmarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]FLAG_STGMEDIUM) [*c]u8;
pub extern fn FLAG_STGMEDIUM_UserFree(arg0: [*c]c_ulong, arg1: [*c]FLAG_STGMEDIUM) void;
pub extern fn HBITMAP_UserSize(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]HBITMAP) c_ulong;
pub extern fn HBITMAP_UserMarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HBITMAP) [*c]u8;
pub extern fn HBITMAP_UserUnmarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HBITMAP) [*c]u8;
pub extern fn HBITMAP_UserFree(arg0: [*c]c_ulong, arg1: [*c]HBITMAP) void;
pub extern fn HDC_UserSize(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]HDC) c_ulong;
pub extern fn HDC_UserMarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HDC) [*c]u8;
pub extern fn HDC_UserUnmarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HDC) [*c]u8;
pub extern fn HDC_UserFree(arg0: [*c]c_ulong, arg1: [*c]HDC) void;
pub extern fn HICON_UserSize(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]HICON) c_ulong;
pub extern fn HICON_UserMarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HICON) [*c]u8;
pub extern fn HICON_UserUnmarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HICON) [*c]u8;
pub extern fn HICON_UserFree(arg0: [*c]c_ulong, arg1: [*c]HICON) void;
pub extern fn SNB_UserSize(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]SNB) c_ulong;
pub extern fn SNB_UserMarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]SNB) [*c]u8;
pub extern fn SNB_UserUnmarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]SNB) [*c]u8;
pub extern fn SNB_UserFree(arg0: [*c]c_ulong, arg1: [*c]SNB) void;
pub extern fn STGMEDIUM_UserSize(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]STGMEDIUM) c_ulong;
pub extern fn STGMEDIUM_UserMarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]STGMEDIUM) [*c]u8;
pub extern fn STGMEDIUM_UserUnmarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]STGMEDIUM) [*c]u8;
pub extern fn STGMEDIUM_UserFree(arg0: [*c]c_ulong, arg1: [*c]STGMEDIUM) void;
pub extern fn ASYNC_STGMEDIUM_UserSize64(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]ASYNC_STGMEDIUM) c_ulong;
pub extern fn ASYNC_STGMEDIUM_UserMarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]ASYNC_STGMEDIUM) [*c]u8;
pub extern fn ASYNC_STGMEDIUM_UserUnmarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]ASYNC_STGMEDIUM) [*c]u8;
pub extern fn ASYNC_STGMEDIUM_UserFree64(arg0: [*c]c_ulong, arg1: [*c]ASYNC_STGMEDIUM) void;
pub extern fn CLIPFORMAT_UserSize64(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]CLIPFORMAT) c_ulong;
pub extern fn CLIPFORMAT_UserMarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]CLIPFORMAT) [*c]u8;
pub extern fn CLIPFORMAT_UserUnmarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]CLIPFORMAT) [*c]u8;
pub extern fn CLIPFORMAT_UserFree64(arg0: [*c]c_ulong, arg1: [*c]CLIPFORMAT) void;
pub extern fn FLAG_STGMEDIUM_UserSize64(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]FLAG_STGMEDIUM) c_ulong;
pub extern fn FLAG_STGMEDIUM_UserMarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]FLAG_STGMEDIUM) [*c]u8;
pub extern fn FLAG_STGMEDIUM_UserUnmarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]FLAG_STGMEDIUM) [*c]u8;
pub extern fn FLAG_STGMEDIUM_UserFree64(arg0: [*c]c_ulong, arg1: [*c]FLAG_STGMEDIUM) void;
pub extern fn HBITMAP_UserSize64(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]HBITMAP) c_ulong;
pub extern fn HBITMAP_UserMarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HBITMAP) [*c]u8;
pub extern fn HBITMAP_UserUnmarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HBITMAP) [*c]u8;
pub extern fn HBITMAP_UserFree64(arg0: [*c]c_ulong, arg1: [*c]HBITMAP) void;
pub extern fn HDC_UserSize64(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]HDC) c_ulong;
pub extern fn HDC_UserMarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HDC) [*c]u8;
pub extern fn HDC_UserUnmarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HDC) [*c]u8;
pub extern fn HDC_UserFree64(arg0: [*c]c_ulong, arg1: [*c]HDC) void;
pub extern fn HICON_UserSize64(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]HICON) c_ulong;
pub extern fn HICON_UserMarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HICON) [*c]u8;
pub extern fn HICON_UserUnmarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HICON) [*c]u8;
pub extern fn HICON_UserFree64(arg0: [*c]c_ulong, arg1: [*c]HICON) void;
pub extern fn SNB_UserSize64(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]SNB) c_ulong;
pub extern fn SNB_UserMarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]SNB) [*c]u8;
pub extern fn SNB_UserUnmarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]SNB) [*c]u8;
pub extern fn SNB_UserFree64(arg0: [*c]c_ulong, arg1: [*c]SNB) void;
pub extern fn STGMEDIUM_UserSize64(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]STGMEDIUM) c_ulong;
pub extern fn STGMEDIUM_UserMarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]STGMEDIUM) [*c]u8;
pub extern fn STGMEDIUM_UserUnmarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]STGMEDIUM) [*c]u8;
pub extern fn STGMEDIUM_UserFree64(arg0: [*c]c_ulong, arg1: [*c]STGMEDIUM) void;
pub extern fn IBindCtx_SetBindOptions_Proxy(This: [*c]IBindCtx, pbindopts: [*c]BIND_OPTS) HRESULT;
pub extern fn IBindCtx_SetBindOptions_Stub(This: [*c]IBindCtx, pbindopts: [*c]BIND_OPTS2) HRESULT;
pub extern fn IBindCtx_GetBindOptions_Proxy(This: [*c]IBindCtx, pbindopts: [*c]BIND_OPTS) HRESULT;
pub extern fn IBindCtx_GetBindOptions_Stub(This: [*c]IBindCtx, pbindopts: [*c]BIND_OPTS2) HRESULT;
pub extern fn IEnumMoniker_Next_Proxy(This: [*c]IEnumMoniker, celt: ULONG, rgelt: [*c]([*c]IMoniker), pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumMoniker_Next_Stub(This: [*c]IEnumMoniker, celt: ULONG, rgelt: [*c]([*c]IMoniker), pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IRunnableObject_IsRunning_Proxy(This: [*c]IRunnableObject) BOOL;
pub extern fn IRunnableObject_IsRunning_Stub(This: [*c]IRunnableObject) HRESULT;
pub extern fn IMoniker_BindToObject_Proxy(This: [*c]IMoniker, pbc: [*c]IBindCtx, pmkToLeft: [*c]IMoniker, riidResult: [*c]const IID, ppvResult: [*c](?*c_void)) HRESULT;
pub extern fn IMoniker_BindToObject_Stub(This: [*c]IMoniker, pbc: [*c]IBindCtx, pmkToLeft: [*c]IMoniker, riidResult: [*c]const IID, ppvResult: [*c]([*c]IUnknown)) HRESULT;
pub extern fn IMoniker_BindToStorage_Proxy(This: [*c]IMoniker, pbc: [*c]IBindCtx, pmkToLeft: [*c]IMoniker, riid: [*c]const IID, ppvObj: [*c](?*c_void)) HRESULT;
pub extern fn IMoniker_BindToStorage_Stub(This: [*c]IMoniker, pbc: [*c]IBindCtx, pmkToLeft: [*c]IMoniker, riid: [*c]const IID, ppvObj: [*c]([*c]IUnknown)) HRESULT;
pub extern fn IEnumSTATSTG_Next_Proxy(This: [*c]IEnumSTATSTG, celt: ULONG, rgelt: [*c]STATSTG, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumSTATSTG_Next_Stub(This: [*c]IEnumSTATSTG, celt: ULONG, rgelt: [*c]STATSTG, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IStorage_OpenStream_Proxy(This: [*c]IStorage, pwcsName: [*c]const OLECHAR, reserved1: ?*c_void, grfMode: DWORD, reserved2: DWORD, ppstm: [*c]([*c]IStream)) HRESULT;
pub extern fn IStorage_OpenStream_Stub(This: [*c]IStorage, pwcsName: [*c]const OLECHAR, cbReserved1: ULONG, reserved1: [*c]byte, grfMode: DWORD, reserved2: DWORD, ppstm: [*c]([*c]IStream)) HRESULT;
pub extern fn IStorage_CopyTo_Proxy(This: [*c]IStorage, ciidExclude: DWORD, rgiidExclude: [*c]const IID, snbExclude: SNB, pstgDest: [*c]IStorage) HRESULT;
pub extern fn IStorage_CopyTo_Stub(This: [*c]IStorage, ciidExclude: DWORD, rgiidExclude: [*c]const IID, snbExclude: SNB, pstgDest: [*c]IStorage) HRESULT;
pub extern fn IStorage_EnumElements_Proxy(This: [*c]IStorage, reserved1: DWORD, reserved2: ?*c_void, reserved3: DWORD, ppenum: [*c]([*c]IEnumSTATSTG)) HRESULT;
pub extern fn IStorage_EnumElements_Stub(This: [*c]IStorage, reserved1: DWORD, cbReserved2: ULONG, reserved2: [*c]byte, reserved3: DWORD, ppenum: [*c]([*c]IEnumSTATSTG)) HRESULT;
pub extern fn ILockBytes_ReadAt_Proxy(This: [*c]ILockBytes, ulOffset: ULARGE_INTEGER, pv: ?*c_void, cb: ULONG, pcbRead: [*c]ULONG) HRESULT;
pub extern fn ILockBytes_ReadAt_Stub(This: [*c]ILockBytes, ulOffset: ULARGE_INTEGER, pv: [*c]byte, cb: ULONG, pcbRead: [*c]ULONG) HRESULT;
pub extern fn ILockBytes_WriteAt_Proxy(This: [*c]ILockBytes, ulOffset: ULARGE_INTEGER, pv: ?*const c_void, cb: ULONG, pcbWritten: [*c]ULONG) HRESULT;
pub extern fn ILockBytes_WriteAt_Stub(This: [*c]ILockBytes, ulOffset: ULARGE_INTEGER, pv: [*c]const byte, cb: ULONG, pcbWritten: [*c]ULONG) HRESULT;
pub extern fn IEnumFORMATETC_Next_Proxy(This: [*c]IEnumFORMATETC, celt: ULONG, rgelt: [*c]FORMATETC, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumFORMATETC_Next_Stub(This: [*c]IEnumFORMATETC, celt: ULONG, rgelt: [*c]FORMATETC, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumSTATDATA_Next_Proxy(This: [*c]IEnumSTATDATA, celt: ULONG, rgelt: [*c]STATDATA, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumSTATDATA_Next_Stub(This: [*c]IEnumSTATDATA, celt: ULONG, rgelt: [*c]STATDATA, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IAdviseSink_OnDataChange_Proxy(This: [*c]IAdviseSink, pFormatetc: [*c]FORMATETC, pStgmed: [*c]STGMEDIUM) void;
pub extern fn IAdviseSink_OnDataChange_Stub(This: [*c]IAdviseSink, pFormatetc: [*c]FORMATETC, pStgmed: [*c]ASYNC_STGMEDIUM) HRESULT;
pub extern fn IAdviseSink_OnViewChange_Proxy(This: [*c]IAdviseSink, dwAspect: DWORD, lindex: LONG) void;
pub extern fn IAdviseSink_OnViewChange_Stub(This: [*c]IAdviseSink, dwAspect: DWORD, lindex: LONG) HRESULT;
pub extern fn IAdviseSink_OnRename_Proxy(This: [*c]IAdviseSink, pmk: [*c]IMoniker) void;
pub extern fn IAdviseSink_OnRename_Stub(This: [*c]IAdviseSink, pmk: [*c]IMoniker) HRESULT;
pub extern fn IAdviseSink_OnSave_Proxy(This: [*c]IAdviseSink) void;
pub extern fn IAdviseSink_OnSave_Stub(This: [*c]IAdviseSink) HRESULT;
pub extern fn IAdviseSink_OnClose_Proxy(This: [*c]IAdviseSink) void;
pub extern fn IAdviseSink_OnClose_Stub(This: [*c]IAdviseSink) HRESULT;
pub extern fn AsyncIAdviseSink_Begin_OnDataChange_Proxy(This: [*c]AsyncIAdviseSink, pFormatetc: [*c]FORMATETC, pStgmed: [*c]STGMEDIUM) void;
pub extern fn AsyncIAdviseSink_Begin_OnDataChange_Stub(This: [*c]AsyncIAdviseSink, pFormatetc: [*c]FORMATETC, pStgmed: [*c]ASYNC_STGMEDIUM) HRESULT;
pub extern fn AsyncIAdviseSink_Finish_OnDataChange_Proxy(This: [*c]AsyncIAdviseSink) void;
pub extern fn AsyncIAdviseSink_Finish_OnDataChange_Stub(This: [*c]AsyncIAdviseSink) HRESULT;
pub extern fn AsyncIAdviseSink_Begin_OnViewChange_Proxy(This: [*c]AsyncIAdviseSink, dwAspect: DWORD, lindex: LONG) void;
pub extern fn AsyncIAdviseSink_Begin_OnViewChange_Stub(This: [*c]AsyncIAdviseSink, dwAspect: DWORD, lindex: LONG) HRESULT;
pub extern fn AsyncIAdviseSink_Finish_OnViewChange_Proxy(This: [*c]AsyncIAdviseSink) void;
pub extern fn AsyncIAdviseSink_Finish_OnViewChange_Stub(This: [*c]AsyncIAdviseSink) HRESULT;
pub extern fn AsyncIAdviseSink_Begin_OnRename_Proxy(This: [*c]AsyncIAdviseSink, pmk: [*c]IMoniker) void;
pub extern fn AsyncIAdviseSink_Begin_OnRename_Stub(This: [*c]AsyncIAdviseSink, pmk: [*c]IMoniker) HRESULT;
pub extern fn AsyncIAdviseSink_Finish_OnRename_Proxy(This: [*c]AsyncIAdviseSink) void;
pub extern fn AsyncIAdviseSink_Finish_OnRename_Stub(This: [*c]AsyncIAdviseSink) HRESULT;
pub extern fn AsyncIAdviseSink_Begin_OnSave_Proxy(This: [*c]AsyncIAdviseSink) void;
pub extern fn AsyncIAdviseSink_Begin_OnSave_Stub(This: [*c]AsyncIAdviseSink) HRESULT;
pub extern fn AsyncIAdviseSink_Finish_OnSave_Proxy(This: [*c]AsyncIAdviseSink) void;
pub extern fn AsyncIAdviseSink_Finish_OnSave_Stub(This: [*c]AsyncIAdviseSink) HRESULT;
pub extern fn AsyncIAdviseSink_Begin_OnClose_Proxy(This: [*c]AsyncIAdviseSink) void;
pub extern fn AsyncIAdviseSink_Begin_OnClose_Stub(This: [*c]AsyncIAdviseSink) HRESULT;
pub extern fn AsyncIAdviseSink_Finish_OnClose_Proxy(This: [*c]AsyncIAdviseSink) void;
pub extern fn AsyncIAdviseSink_Finish_OnClose_Stub(This: [*c]AsyncIAdviseSink) HRESULT;
pub extern fn IAdviseSink2_OnLinkSrcChange_Proxy(This: [*c]IAdviseSink2, pmk: [*c]IMoniker) void;
pub extern fn IAdviseSink2_OnLinkSrcChange_Stub(This: [*c]IAdviseSink2, pmk: [*c]IMoniker) HRESULT;
pub extern fn AsyncIAdviseSink2_Begin_OnLinkSrcChange_Proxy(This: [*c]AsyncIAdviseSink2, pmk: [*c]IMoniker) void;
pub extern fn AsyncIAdviseSink2_Begin_OnLinkSrcChange_Stub(This: [*c]AsyncIAdviseSink2, pmk: [*c]IMoniker) HRESULT;
pub extern fn AsyncIAdviseSink2_Finish_OnLinkSrcChange_Proxy(This: [*c]AsyncIAdviseSink2) void;
pub extern fn AsyncIAdviseSink2_Finish_OnLinkSrcChange_Stub(This: [*c]AsyncIAdviseSink2) HRESULT;
pub extern fn IDataObject_GetData_Proxy(This: [*c]IDataObject, pformatetcIn: [*c]FORMATETC, pmedium: [*c]STGMEDIUM) HRESULT;
pub extern fn IDataObject_GetData_Stub(This: [*c]IDataObject, pformatetcIn: [*c]FORMATETC, pRemoteMedium: [*c]STGMEDIUM) HRESULT;
pub extern fn IDataObject_GetDataHere_Proxy(This: [*c]IDataObject, pformatetc: [*c]FORMATETC, pmedium: [*c]STGMEDIUM) HRESULT;
pub extern fn IDataObject_GetDataHere_Stub(This: [*c]IDataObject, pformatetc: [*c]FORMATETC, pRemoteMedium: [*c]STGMEDIUM) HRESULT;
pub extern fn IDataObject_SetData_Proxy(This: [*c]IDataObject, pformatetc: [*c]FORMATETC, pmedium: [*c]STGMEDIUM, fRelease: BOOL) HRESULT;
pub extern fn IDataObject_SetData_Stub(This: [*c]IDataObject, pformatetc: [*c]FORMATETC, pmedium: [*c]FLAG_STGMEDIUM, fRelease: BOOL) HRESULT;
pub extern fn IFillLockBytes_FillAppend_Proxy(This: [*c]IFillLockBytes, pv: ?*const c_void, cb: ULONG, pcbWritten: [*c]ULONG) HRESULT;
pub extern fn IFillLockBytes_FillAppend_Stub(This: [*c]IFillLockBytes, pv: [*c]const byte, cb: ULONG, pcbWritten: [*c]ULONG) HRESULT;
pub extern fn IFillLockBytes_FillAt_Proxy(This: [*c]IFillLockBytes, ulOffset: ULARGE_INTEGER, pv: ?*const c_void, cb: ULONG, pcbWritten: [*c]ULONG) HRESULT;
pub extern fn IFillLockBytes_FillAt_Stub(This: [*c]IFillLockBytes, ulOffset: ULARGE_INTEGER, pv: [*c]const byte, cb: ULONG, pcbWritten: [*c]ULONG) HRESULT;
pub const IPropertyStorage = struct_IPropertyStorage;
pub const struct_tagPROPSPEC = extern struct {
    ulKind: ULONG,
    @"": extern union {
        propid: PROPID,
        lpwstr: LPOLESTR,
    },
};
pub const PROPSPEC = struct_tagPROPSPEC;
pub const struct_tagSTATPROPSTG = extern struct {
    lpwstrName: LPOLESTR,
    propid: PROPID,
    vt: VARTYPE,
};
pub const STATPROPSTG = struct_tagSTATPROPSTG;
pub const struct_IEnumSTATPROPSTGVtbl = extern struct {
    QueryInterface: ?fn ([*c]IEnumSTATPROPSTG, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IEnumSTATPROPSTG) callconv(.C) ULONG,
    Release: ?fn ([*c]IEnumSTATPROPSTG) callconv(.C) ULONG,
    Next: ?fn ([*c]IEnumSTATPROPSTG, ULONG, [*c]STATPROPSTG, [*c]ULONG) callconv(.C) HRESULT,
    Skip: ?fn ([*c]IEnumSTATPROPSTG, ULONG) callconv(.C) HRESULT,
    Reset: ?fn ([*c]IEnumSTATPROPSTG) callconv(.C) HRESULT,
    Clone: ?fn ([*c]IEnumSTATPROPSTG, [*c]([*c]IEnumSTATPROPSTG)) callconv(.C) HRESULT,
};
pub const struct_IEnumSTATPROPSTG = extern struct {
    lpVtbl: [*c]struct_IEnumSTATPROPSTGVtbl,
};
pub const IEnumSTATPROPSTG = struct_IEnumSTATPROPSTG;
pub const struct_tagSTATPROPSETSTG = extern struct {
    fmtid: FMTID,
    clsid: CLSID,
    grfFlags: DWORD,
    mtime: FILETIME,
    ctime: FILETIME,
    atime: FILETIME,
    dwOSVersion: DWORD,
};
pub const STATPROPSETSTG = struct_tagSTATPROPSETSTG;
pub const struct_IPropertyStorageVtbl = extern struct {
    QueryInterface: ?fn ([*c]IPropertyStorage, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IPropertyStorage) callconv(.C) ULONG,
    Release: ?fn ([*c]IPropertyStorage) callconv(.C) ULONG,
    ReadMultiple: ?fn ([*c]IPropertyStorage, ULONG, [*c]const PROPSPEC, [*c]PROPVARIANT) callconv(.C) HRESULT,
    WriteMultiple: ?fn ([*c]IPropertyStorage, ULONG, [*c]const PROPSPEC, [*c]const PROPVARIANT, PROPID) callconv(.C) HRESULT,
    DeleteMultiple: ?fn ([*c]IPropertyStorage, ULONG, [*c]const PROPSPEC) callconv(.C) HRESULT,
    ReadPropertyNames: ?fn ([*c]IPropertyStorage, ULONG, [*c]const PROPID, [*c]LPOLESTR) callconv(.C) HRESULT,
    WritePropertyNames: ?fn ([*c]IPropertyStorage, ULONG, [*c]const PROPID, [*c]const LPOLESTR) callconv(.C) HRESULT,
    DeletePropertyNames: ?fn ([*c]IPropertyStorage, ULONG, [*c]const PROPID) callconv(.C) HRESULT,
    Commit: ?fn ([*c]IPropertyStorage, DWORD) callconv(.C) HRESULT,
    Revert: ?fn ([*c]IPropertyStorage) callconv(.C) HRESULT,
    Enum: ?fn ([*c]IPropertyStorage, [*c]([*c]IEnumSTATPROPSTG)) callconv(.C) HRESULT,
    SetTimes: ?fn ([*c]IPropertyStorage, [*c]const FILETIME, [*c]const FILETIME, [*c]const FILETIME) callconv(.C) HRESULT,
    SetClass: ?fn ([*c]IPropertyStorage, [*c]const IID) callconv(.C) HRESULT,
    Stat: ?fn ([*c]IPropertyStorage, [*c]STATPROPSETSTG) callconv(.C) HRESULT,
};
pub const struct_IPropertyStorage = extern struct {
    lpVtbl: [*c]struct_IPropertyStorageVtbl,
};
pub const IPropertySetStorage = struct_IPropertySetStorage;
pub const struct_IEnumSTATPROPSETSTGVtbl = extern struct {
    QueryInterface: ?fn ([*c]IEnumSTATPROPSETSTG, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IEnumSTATPROPSETSTG) callconv(.C) ULONG,
    Release: ?fn ([*c]IEnumSTATPROPSETSTG) callconv(.C) ULONG,
    Next: ?fn ([*c]IEnumSTATPROPSETSTG, ULONG, [*c]STATPROPSETSTG, [*c]ULONG) callconv(.C) HRESULT,
    Skip: ?fn ([*c]IEnumSTATPROPSETSTG, ULONG) callconv(.C) HRESULT,
    Reset: ?fn ([*c]IEnumSTATPROPSETSTG) callconv(.C) HRESULT,
    Clone: ?fn ([*c]IEnumSTATPROPSETSTG, [*c]([*c]IEnumSTATPROPSETSTG)) callconv(.C) HRESULT,
};
pub const struct_IEnumSTATPROPSETSTG = extern struct {
    lpVtbl: [*c]struct_IEnumSTATPROPSETSTGVtbl,
};
pub const IEnumSTATPROPSETSTG = struct_IEnumSTATPROPSETSTG;
pub const struct_IPropertySetStorageVtbl = extern struct {
    QueryInterface: ?fn ([*c]IPropertySetStorage, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IPropertySetStorage) callconv(.C) ULONG,
    Release: ?fn ([*c]IPropertySetStorage) callconv(.C) ULONG,
    Create: ?fn ([*c]IPropertySetStorage, [*c]const IID, [*c]const CLSID, DWORD, DWORD, [*c]([*c]IPropertyStorage)) callconv(.C) HRESULT,
    Open: ?fn ([*c]IPropertySetStorage, [*c]const IID, DWORD, [*c]([*c]IPropertyStorage)) callconv(.C) HRESULT,
    Delete: ?fn ([*c]IPropertySetStorage, [*c]const IID) callconv(.C) HRESULT,
    Enum: ?fn ([*c]IPropertySetStorage, [*c]([*c]IEnumSTATPROPSETSTG)) callconv(.C) HRESULT,
};
pub const struct_IPropertySetStorage = extern struct {
    lpVtbl: [*c]struct_IPropertySetStorageVtbl,
};
pub const ICreateTypeInfo = struct_ICreateTypeInfo;
pub const struct_ICreateTypeInfoVtbl = extern struct {
    QueryInterface: ?fn ([*c]ICreateTypeInfo, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ICreateTypeInfo) callconv(.C) ULONG,
    Release: ?fn ([*c]ICreateTypeInfo) callconv(.C) ULONG,
    SetGuid: ?fn ([*c]ICreateTypeInfo, [*c]const GUID) callconv(.C) HRESULT,
    SetTypeFlags: ?fn ([*c]ICreateTypeInfo, UINT) callconv(.C) HRESULT,
    SetDocString: ?fn ([*c]ICreateTypeInfo, LPOLESTR) callconv(.C) HRESULT,
    SetHelpContext: ?fn ([*c]ICreateTypeInfo, DWORD) callconv(.C) HRESULT,
    SetVersion: ?fn ([*c]ICreateTypeInfo, WORD, WORD) callconv(.C) HRESULT,
    AddRefTypeInfo: ?fn ([*c]ICreateTypeInfo, [*c]ITypeInfo, [*c]HREFTYPE) callconv(.C) HRESULT,
    AddFuncDesc: ?fn ([*c]ICreateTypeInfo, UINT, [*c]FUNCDESC) callconv(.C) HRESULT,
    AddImplType: ?fn ([*c]ICreateTypeInfo, UINT, HREFTYPE) callconv(.C) HRESULT,
    SetImplTypeFlags: ?fn ([*c]ICreateTypeInfo, UINT, INT) callconv(.C) HRESULT,
    SetAlignment: ?fn ([*c]ICreateTypeInfo, WORD) callconv(.C) HRESULT,
    SetSchema: ?fn ([*c]ICreateTypeInfo, LPOLESTR) callconv(.C) HRESULT,
    AddVarDesc: ?fn ([*c]ICreateTypeInfo, UINT, [*c]VARDESC) callconv(.C) HRESULT,
    SetFuncAndParamNames: ?fn ([*c]ICreateTypeInfo, UINT, [*c]LPOLESTR, UINT) callconv(.C) HRESULT,
    SetVarName: ?fn ([*c]ICreateTypeInfo, UINT, LPOLESTR) callconv(.C) HRESULT,
    SetTypeDescAlias: ?fn ([*c]ICreateTypeInfo, [*c]TYPEDESC) callconv(.C) HRESULT,
    DefineFuncAsDllEntry: ?fn ([*c]ICreateTypeInfo, UINT, LPOLESTR, LPOLESTR) callconv(.C) HRESULT,
    SetFuncDocString: ?fn ([*c]ICreateTypeInfo, UINT, LPOLESTR) callconv(.C) HRESULT,
    SetVarDocString: ?fn ([*c]ICreateTypeInfo, UINT, LPOLESTR) callconv(.C) HRESULT,
    SetFuncHelpContext: ?fn ([*c]ICreateTypeInfo, UINT, DWORD) callconv(.C) HRESULT,
    SetVarHelpContext: ?fn ([*c]ICreateTypeInfo, UINT, DWORD) callconv(.C) HRESULT,
    SetMops: ?fn ([*c]ICreateTypeInfo, UINT, BSTR) callconv(.C) HRESULT,
    SetTypeIdldesc: ?fn ([*c]ICreateTypeInfo, [*c]IDLDESC) callconv(.C) HRESULT,
    LayOut: ?fn ([*c]ICreateTypeInfo) callconv(.C) HRESULT,
};
pub const struct_ICreateTypeInfo = extern struct {
    lpVtbl: [*c]struct_ICreateTypeInfoVtbl,
};
pub const ICreateTypeInfo2 = struct_ICreateTypeInfo2;
pub const struct_ICreateTypeInfo2Vtbl = extern struct {
    QueryInterface: ?fn ([*c]ICreateTypeInfo2, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ICreateTypeInfo2) callconv(.C) ULONG,
    Release: ?fn ([*c]ICreateTypeInfo2) callconv(.C) ULONG,
    SetGuid: ?fn ([*c]ICreateTypeInfo2, [*c]const GUID) callconv(.C) HRESULT,
    SetTypeFlags: ?fn ([*c]ICreateTypeInfo2, UINT) callconv(.C) HRESULT,
    SetDocString: ?fn ([*c]ICreateTypeInfo2, LPOLESTR) callconv(.C) HRESULT,
    SetHelpContext: ?fn ([*c]ICreateTypeInfo2, DWORD) callconv(.C) HRESULT,
    SetVersion: ?fn ([*c]ICreateTypeInfo2, WORD, WORD) callconv(.C) HRESULT,
    AddRefTypeInfo: ?fn ([*c]ICreateTypeInfo2, [*c]ITypeInfo, [*c]HREFTYPE) callconv(.C) HRESULT,
    AddFuncDesc: ?fn ([*c]ICreateTypeInfo2, UINT, [*c]FUNCDESC) callconv(.C) HRESULT,
    AddImplType: ?fn ([*c]ICreateTypeInfo2, UINT, HREFTYPE) callconv(.C) HRESULT,
    SetImplTypeFlags: ?fn ([*c]ICreateTypeInfo2, UINT, INT) callconv(.C) HRESULT,
    SetAlignment: ?fn ([*c]ICreateTypeInfo2, WORD) callconv(.C) HRESULT,
    SetSchema: ?fn ([*c]ICreateTypeInfo2, LPOLESTR) callconv(.C) HRESULT,
    AddVarDesc: ?fn ([*c]ICreateTypeInfo2, UINT, [*c]VARDESC) callconv(.C) HRESULT,
    SetFuncAndParamNames: ?fn ([*c]ICreateTypeInfo2, UINT, [*c]LPOLESTR, UINT) callconv(.C) HRESULT,
    SetVarName: ?fn ([*c]ICreateTypeInfo2, UINT, LPOLESTR) callconv(.C) HRESULT,
    SetTypeDescAlias: ?fn ([*c]ICreateTypeInfo2, [*c]TYPEDESC) callconv(.C) HRESULT,
    DefineFuncAsDllEntry: ?fn ([*c]ICreateTypeInfo2, UINT, LPOLESTR, LPOLESTR) callconv(.C) HRESULT,
    SetFuncDocString: ?fn ([*c]ICreateTypeInfo2, UINT, LPOLESTR) callconv(.C) HRESULT,
    SetVarDocString: ?fn ([*c]ICreateTypeInfo2, UINT, LPOLESTR) callconv(.C) HRESULT,
    SetFuncHelpContext: ?fn ([*c]ICreateTypeInfo2, UINT, DWORD) callconv(.C) HRESULT,
    SetVarHelpContext: ?fn ([*c]ICreateTypeInfo2, UINT, DWORD) callconv(.C) HRESULT,
    SetMops: ?fn ([*c]ICreateTypeInfo2, UINT, BSTR) callconv(.C) HRESULT,
    SetTypeIdldesc: ?fn ([*c]ICreateTypeInfo2, [*c]IDLDESC) callconv(.C) HRESULT,
    LayOut: ?fn ([*c]ICreateTypeInfo2) callconv(.C) HRESULT,
    DeleteFuncDesc: ?fn ([*c]ICreateTypeInfo2, UINT) callconv(.C) HRESULT,
    DeleteFuncDescByMemId: ?fn ([*c]ICreateTypeInfo2, MEMBERID, INVOKEKIND) callconv(.C) HRESULT,
    DeleteVarDesc: ?fn ([*c]ICreateTypeInfo2, UINT) callconv(.C) HRESULT,
    DeleteVarDescByMemId: ?fn ([*c]ICreateTypeInfo2, MEMBERID) callconv(.C) HRESULT,
    DeleteImplType: ?fn ([*c]ICreateTypeInfo2, UINT) callconv(.C) HRESULT,
    SetCustData: ?fn ([*c]ICreateTypeInfo2, [*c]const GUID, [*c]VARIANT) callconv(.C) HRESULT,
    SetFuncCustData: ?fn ([*c]ICreateTypeInfo2, UINT, [*c]const GUID, [*c]VARIANT) callconv(.C) HRESULT,
    SetParamCustData: ?fn ([*c]ICreateTypeInfo2, UINT, UINT, [*c]const GUID, [*c]VARIANT) callconv(.C) HRESULT,
    SetVarCustData: ?fn ([*c]ICreateTypeInfo2, UINT, [*c]const GUID, [*c]VARIANT) callconv(.C) HRESULT,
    SetImplTypeCustData: ?fn ([*c]ICreateTypeInfo2, UINT, [*c]const GUID, [*c]VARIANT) callconv(.C) HRESULT,
    SetHelpStringContext: ?fn ([*c]ICreateTypeInfo2, ULONG) callconv(.C) HRESULT,
    SetFuncHelpStringContext: ?fn ([*c]ICreateTypeInfo2, UINT, ULONG) callconv(.C) HRESULT,
    SetVarHelpStringContext: ?fn ([*c]ICreateTypeInfo2, UINT, ULONG) callconv(.C) HRESULT,
    Invalidate: ?fn ([*c]ICreateTypeInfo2) callconv(.C) HRESULT,
    SetName: ?fn ([*c]ICreateTypeInfo2, LPOLESTR) callconv(.C) HRESULT,
};
pub const struct_ICreateTypeInfo2 = extern struct {
    lpVtbl: [*c]struct_ICreateTypeInfo2Vtbl,
};
pub const ICreateTypeLib = struct_ICreateTypeLib;
pub const struct_ICreateTypeLibVtbl = extern struct {
    QueryInterface: ?fn ([*c]ICreateTypeLib, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ICreateTypeLib) callconv(.C) ULONG,
    Release: ?fn ([*c]ICreateTypeLib) callconv(.C) ULONG,
    CreateTypeInfo: ?fn ([*c]ICreateTypeLib, LPOLESTR, TYPEKIND, [*c]([*c]ICreateTypeInfo)) callconv(.C) HRESULT,
    SetName: ?fn ([*c]ICreateTypeLib, LPOLESTR) callconv(.C) HRESULT,
    SetVersion: ?fn ([*c]ICreateTypeLib, WORD, WORD) callconv(.C) HRESULT,
    SetGuid: ?fn ([*c]ICreateTypeLib, [*c]const GUID) callconv(.C) HRESULT,
    SetDocString: ?fn ([*c]ICreateTypeLib, LPOLESTR) callconv(.C) HRESULT,
    SetHelpFileName: ?fn ([*c]ICreateTypeLib, LPOLESTR) callconv(.C) HRESULT,
    SetHelpContext: ?fn ([*c]ICreateTypeLib, DWORD) callconv(.C) HRESULT,
    SetLcid: ?fn ([*c]ICreateTypeLib, LCID) callconv(.C) HRESULT,
    SetLibFlags: ?fn ([*c]ICreateTypeLib, UINT) callconv(.C) HRESULT,
    SaveAllChanges: ?fn ([*c]ICreateTypeLib) callconv(.C) HRESULT,
};
pub const struct_ICreateTypeLib = extern struct {
    lpVtbl: [*c]struct_ICreateTypeLibVtbl,
};
pub const ICreateTypeLib2 = struct_ICreateTypeLib2;
pub const struct_ICreateTypeLib2Vtbl = extern struct {
    QueryInterface: ?fn ([*c]ICreateTypeLib2, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ICreateTypeLib2) callconv(.C) ULONG,
    Release: ?fn ([*c]ICreateTypeLib2) callconv(.C) ULONG,
    CreateTypeInfo: ?fn ([*c]ICreateTypeLib2, LPOLESTR, TYPEKIND, [*c]([*c]ICreateTypeInfo)) callconv(.C) HRESULT,
    SetName: ?fn ([*c]ICreateTypeLib2, LPOLESTR) callconv(.C) HRESULT,
    SetVersion: ?fn ([*c]ICreateTypeLib2, WORD, WORD) callconv(.C) HRESULT,
    SetGuid: ?fn ([*c]ICreateTypeLib2, [*c]const GUID) callconv(.C) HRESULT,
    SetDocString: ?fn ([*c]ICreateTypeLib2, LPOLESTR) callconv(.C) HRESULT,
    SetHelpFileName: ?fn ([*c]ICreateTypeLib2, LPOLESTR) callconv(.C) HRESULT,
    SetHelpContext: ?fn ([*c]ICreateTypeLib2, DWORD) callconv(.C) HRESULT,
    SetLcid: ?fn ([*c]ICreateTypeLib2, LCID) callconv(.C) HRESULT,
    SetLibFlags: ?fn ([*c]ICreateTypeLib2, UINT) callconv(.C) HRESULT,
    SaveAllChanges: ?fn ([*c]ICreateTypeLib2) callconv(.C) HRESULT,
    DeleteTypeInfo: ?fn ([*c]ICreateTypeLib2, LPOLESTR) callconv(.C) HRESULT,
    SetCustData: ?fn ([*c]ICreateTypeLib2, [*c]const GUID, [*c]VARIANT) callconv(.C) HRESULT,
    SetHelpStringContext: ?fn ([*c]ICreateTypeLib2, ULONG) callconv(.C) HRESULT,
    SetHelpStringDll: ?fn ([*c]ICreateTypeLib2, LPOLESTR) callconv(.C) HRESULT,
};
pub const struct_ICreateTypeLib2 = extern struct {
    lpVtbl: [*c]struct_ICreateTypeLib2Vtbl,
};
pub const IEnumVARIANT = struct_IEnumVARIANT;
pub const struct_IEnumVARIANTVtbl = extern struct {
    QueryInterface: ?fn ([*c]IEnumVARIANT, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IEnumVARIANT) callconv(.C) ULONG,
    Release: ?fn ([*c]IEnumVARIANT) callconv(.C) ULONG,
    Next: ?fn ([*c]IEnumVARIANT, ULONG, [*c]VARIANT, [*c]ULONG) callconv(.C) HRESULT,
    Skip: ?fn ([*c]IEnumVARIANT, ULONG) callconv(.C) HRESULT,
    Reset: ?fn ([*c]IEnumVARIANT) callconv(.C) HRESULT,
    Clone: ?fn ([*c]IEnumVARIANT, [*c]([*c]IEnumVARIANT)) callconv(.C) HRESULT,
};
pub const struct_IEnumVARIANT = extern struct {
    lpVtbl: [*c]struct_IEnumVARIANTVtbl,
};
pub const ITypeInfo2 = struct_ITypeInfo2;
pub const struct_tagCUSTDATAITEM = extern struct {
    guid: GUID,
    varValue: VARIANTARG,
};
pub const LPCUSTDATAITEM = [*c]struct_tagCUSTDATAITEM;
pub const struct_tagCUSTDATA = extern struct {
    cCustData: DWORD,
    prgCustData: LPCUSTDATAITEM,
};
pub const CUSTDATA = struct_tagCUSTDATA;
pub const struct_ITypeInfo2Vtbl = extern struct {
    QueryInterface: ?fn ([*c]ITypeInfo2, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ITypeInfo2) callconv(.C) ULONG,
    Release: ?fn ([*c]ITypeInfo2) callconv(.C) ULONG,
    GetTypeAttr: ?fn ([*c]ITypeInfo2, [*c]([*c]TYPEATTR)) callconv(.C) HRESULT,
    GetTypeComp: ?fn ([*c]ITypeInfo2, [*c]([*c]ITypeComp)) callconv(.C) HRESULT,
    GetFuncDesc: ?fn ([*c]ITypeInfo2, UINT, [*c]([*c]FUNCDESC)) callconv(.C) HRESULT,
    GetVarDesc: ?fn ([*c]ITypeInfo2, UINT, [*c]([*c]VARDESC)) callconv(.C) HRESULT,
    GetNames: ?fn ([*c]ITypeInfo2, MEMBERID, [*c]BSTR, UINT, [*c]UINT) callconv(.C) HRESULT,
    GetRefTypeOfImplType: ?fn ([*c]ITypeInfo2, UINT, [*c]HREFTYPE) callconv(.C) HRESULT,
    GetImplTypeFlags: ?fn ([*c]ITypeInfo2, UINT, [*c]INT) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]ITypeInfo2, [*c]LPOLESTR, UINT, [*c]MEMBERID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]ITypeInfo2, PVOID, MEMBERID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    GetDocumentation: ?fn ([*c]ITypeInfo2, MEMBERID, [*c]BSTR, [*c]BSTR, [*c]DWORD, [*c]BSTR) callconv(.C) HRESULT,
    GetDllEntry: ?fn ([*c]ITypeInfo2, MEMBERID, INVOKEKIND, [*c]BSTR, [*c]BSTR, [*c]WORD) callconv(.C) HRESULT,
    GetRefTypeInfo: ?fn ([*c]ITypeInfo2, HREFTYPE, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    AddressOfMember: ?fn ([*c]ITypeInfo2, MEMBERID, INVOKEKIND, [*c]PVOID) callconv(.C) HRESULT,
    CreateInstance: ?fn ([*c]ITypeInfo2, [*c]IUnknown, [*c]const IID, [*c]PVOID) callconv(.C) HRESULT,
    GetMops: ?fn ([*c]ITypeInfo2, MEMBERID, [*c]BSTR) callconv(.C) HRESULT,
    GetContainingTypeLib: ?fn ([*c]ITypeInfo2, [*c]([*c]ITypeLib), [*c]UINT) callconv(.C) HRESULT,
    ReleaseTypeAttr: ?fn ([*c]ITypeInfo2, [*c]TYPEATTR) callconv(.C) void,
    ReleaseFuncDesc: ?fn ([*c]ITypeInfo2, [*c]FUNCDESC) callconv(.C) void,
    ReleaseVarDesc: ?fn ([*c]ITypeInfo2, [*c]VARDESC) callconv(.C) void,
    GetTypeKind: ?fn ([*c]ITypeInfo2, [*c]TYPEKIND) callconv(.C) HRESULT,
    GetTypeFlags: ?fn ([*c]ITypeInfo2, [*c]ULONG) callconv(.C) HRESULT,
    GetFuncIndexOfMemId: ?fn ([*c]ITypeInfo2, MEMBERID, INVOKEKIND, [*c]UINT) callconv(.C) HRESULT,
    GetVarIndexOfMemId: ?fn ([*c]ITypeInfo2, MEMBERID, [*c]UINT) callconv(.C) HRESULT,
    GetCustData: ?fn ([*c]ITypeInfo2, [*c]const GUID, [*c]VARIANT) callconv(.C) HRESULT,
    GetFuncCustData: ?fn ([*c]ITypeInfo2, UINT, [*c]const GUID, [*c]VARIANT) callconv(.C) HRESULT,
    GetParamCustData: ?fn ([*c]ITypeInfo2, UINT, UINT, [*c]const GUID, [*c]VARIANT) callconv(.C) HRESULT,
    GetVarCustData: ?fn ([*c]ITypeInfo2, UINT, [*c]const GUID, [*c]VARIANT) callconv(.C) HRESULT,
    GetImplTypeCustData: ?fn ([*c]ITypeInfo2, UINT, [*c]const GUID, [*c]VARIANT) callconv(.C) HRESULT,
    GetDocumentation2: ?fn ([*c]ITypeInfo2, MEMBERID, LCID, [*c]BSTR, [*c]DWORD, [*c]BSTR) callconv(.C) HRESULT,
    GetAllCustData: ?fn ([*c]ITypeInfo2, [*c]CUSTDATA) callconv(.C) HRESULT,
    GetAllFuncCustData: ?fn ([*c]ITypeInfo2, UINT, [*c]CUSTDATA) callconv(.C) HRESULT,
    GetAllParamCustData: ?fn ([*c]ITypeInfo2, UINT, UINT, [*c]CUSTDATA) callconv(.C) HRESULT,
    GetAllVarCustData: ?fn ([*c]ITypeInfo2, UINT, [*c]CUSTDATA) callconv(.C) HRESULT,
    GetAllImplTypeCustData: ?fn ([*c]ITypeInfo2, UINT, [*c]CUSTDATA) callconv(.C) HRESULT,
};
pub const struct_ITypeInfo2 = extern struct {
    lpVtbl: [*c]struct_ITypeInfo2Vtbl,
};
pub const ITypeLib2 = struct_ITypeLib2;
pub const struct_ITypeLib2Vtbl = extern struct {
    QueryInterface: ?fn ([*c]ITypeLib2, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ITypeLib2) callconv(.C) ULONG,
    Release: ?fn ([*c]ITypeLib2) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]ITypeLib2) callconv(.C) UINT,
    GetTypeInfo: ?fn ([*c]ITypeLib2, UINT, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetTypeInfoType: ?fn ([*c]ITypeLib2, UINT, [*c]TYPEKIND) callconv(.C) HRESULT,
    GetTypeInfoOfGuid: ?fn ([*c]ITypeLib2, [*c]const GUID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetLibAttr: ?fn ([*c]ITypeLib2, [*c]([*c]TLIBATTR)) callconv(.C) HRESULT,
    GetTypeComp: ?fn ([*c]ITypeLib2, [*c]([*c]ITypeComp)) callconv(.C) HRESULT,
    GetDocumentation: ?fn ([*c]ITypeLib2, INT, [*c]BSTR, [*c]BSTR, [*c]DWORD, [*c]BSTR) callconv(.C) HRESULT,
    IsName: ?fn ([*c]ITypeLib2, LPOLESTR, ULONG, [*c]BOOL) callconv(.C) HRESULT,
    FindName: ?fn ([*c]ITypeLib2, LPOLESTR, ULONG, [*c]([*c]ITypeInfo), [*c]MEMBERID, [*c]USHORT) callconv(.C) HRESULT,
    ReleaseTLibAttr: ?fn ([*c]ITypeLib2, [*c]TLIBATTR) callconv(.C) void,
    GetCustData: ?fn ([*c]ITypeLib2, [*c]const GUID, [*c]VARIANT) callconv(.C) HRESULT,
    GetLibStatistics: ?fn ([*c]ITypeLib2, [*c]ULONG, [*c]ULONG) callconv(.C) HRESULT,
    GetDocumentation2: ?fn ([*c]ITypeLib2, INT, LCID, [*c]BSTR, [*c]DWORD, [*c]BSTR) callconv(.C) HRESULT,
    GetAllCustData: ?fn ([*c]ITypeLib2, [*c]CUSTDATA) callconv(.C) HRESULT,
};
pub const struct_ITypeLib2 = extern struct {
    lpVtbl: [*c]struct_ITypeLib2Vtbl,
};
pub const ITypeChangeEvents = struct_ITypeChangeEvents;
pub const CHANGEKIND_ADDMEMBER = enum_tagCHANGEKIND.CHANGEKIND_ADDMEMBER;
pub const CHANGEKIND_DELETEMEMBER = enum_tagCHANGEKIND.CHANGEKIND_DELETEMEMBER;
pub const CHANGEKIND_SETNAMES = enum_tagCHANGEKIND.CHANGEKIND_SETNAMES;
pub const CHANGEKIND_SETDOCUMENTATION = enum_tagCHANGEKIND.CHANGEKIND_SETDOCUMENTATION;
pub const CHANGEKIND_GENERAL = enum_tagCHANGEKIND.CHANGEKIND_GENERAL;
pub const CHANGEKIND_INVALIDATE = enum_tagCHANGEKIND.CHANGEKIND_INVALIDATE;
pub const CHANGEKIND_CHANGEFAILED = enum_tagCHANGEKIND.CHANGEKIND_CHANGEFAILED;
pub const CHANGEKIND_MAX = enum_tagCHANGEKIND.CHANGEKIND_MAX;
pub const enum_tagCHANGEKIND = extern enum {
    CHANGEKIND_ADDMEMBER = 0,
    CHANGEKIND_DELETEMEMBER = 1,
    CHANGEKIND_SETNAMES = 2,
    CHANGEKIND_SETDOCUMENTATION = 3,
    CHANGEKIND_GENERAL = 4,
    CHANGEKIND_INVALIDATE = 5,
    CHANGEKIND_CHANGEFAILED = 6,
    CHANGEKIND_MAX = 7,
};
pub const CHANGEKIND = extern enum {
    CHANGEKIND_ADDMEMBER = 0,
    CHANGEKIND_DELETEMEMBER = 1,
    CHANGEKIND_SETNAMES = 2,
    CHANGEKIND_SETDOCUMENTATION = 3,
    CHANGEKIND_GENERAL = 4,
    CHANGEKIND_INVALIDATE = 5,
    CHANGEKIND_CHANGEFAILED = 6,
    CHANGEKIND_MAX = 7,
};
pub const struct_ITypeChangeEventsVtbl = extern struct {
    QueryInterface: ?fn ([*c]ITypeChangeEvents, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ITypeChangeEvents) callconv(.C) ULONG,
    Release: ?fn ([*c]ITypeChangeEvents) callconv(.C) ULONG,
    RequestTypeChange: ?fn ([*c]ITypeChangeEvents, CHANGEKIND, [*c]ITypeInfo, LPOLESTR, [*c]INT) callconv(.C) HRESULT,
    AfterTypeChange: ?fn ([*c]ITypeChangeEvents, CHANGEKIND, [*c]ITypeInfo, LPOLESTR) callconv(.C) HRESULT,
};
pub const struct_ITypeChangeEvents = extern struct {
    lpVtbl: [*c]struct_ITypeChangeEventsVtbl,
};
pub const IErrorInfo = struct_IErrorInfo;
pub const struct_IErrorInfoVtbl = extern struct {
    QueryInterface: ?fn ([*c]IErrorInfo, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IErrorInfo) callconv(.C) ULONG,
    Release: ?fn ([*c]IErrorInfo) callconv(.C) ULONG,
    GetGUID: ?fn ([*c]IErrorInfo, [*c]GUID) callconv(.C) HRESULT,
    GetSource: ?fn ([*c]IErrorInfo, [*c]BSTR) callconv(.C) HRESULT,
    GetDescription: ?fn ([*c]IErrorInfo, [*c]BSTR) callconv(.C) HRESULT,
    GetHelpFile: ?fn ([*c]IErrorInfo, [*c]BSTR) callconv(.C) HRESULT,
    GetHelpContext: ?fn ([*c]IErrorInfo, [*c]DWORD) callconv(.C) HRESULT,
};
pub const struct_IErrorInfo = extern struct {
    lpVtbl: [*c]struct_IErrorInfoVtbl,
};
pub const ICreateErrorInfo = struct_ICreateErrorInfo;
pub const struct_ICreateErrorInfoVtbl = extern struct {
    QueryInterface: ?fn ([*c]ICreateErrorInfo, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ICreateErrorInfo) callconv(.C) ULONG,
    Release: ?fn ([*c]ICreateErrorInfo) callconv(.C) ULONG,
    SetGUID: ?fn ([*c]ICreateErrorInfo, [*c]const GUID) callconv(.C) HRESULT,
    SetSource: ?fn ([*c]ICreateErrorInfo, LPOLESTR) callconv(.C) HRESULT,
    SetDescription: ?fn ([*c]ICreateErrorInfo, LPOLESTR) callconv(.C) HRESULT,
    SetHelpFile: ?fn ([*c]ICreateErrorInfo, LPOLESTR) callconv(.C) HRESULT,
    SetHelpContext: ?fn ([*c]ICreateErrorInfo, DWORD) callconv(.C) HRESULT,
};
pub const struct_ICreateErrorInfo = extern struct {
    lpVtbl: [*c]struct_ICreateErrorInfoVtbl,
};
pub const ISupportErrorInfo = struct_ISupportErrorInfo;
pub const struct_ISupportErrorInfoVtbl = extern struct {
    QueryInterface: ?fn ([*c]ISupportErrorInfo, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ISupportErrorInfo) callconv(.C) ULONG,
    Release: ?fn ([*c]ISupportErrorInfo) callconv(.C) ULONG,
    InterfaceSupportsErrorInfo: ?fn ([*c]ISupportErrorInfo, [*c]const IID) callconv(.C) HRESULT,
};
pub const struct_ISupportErrorInfo = extern struct {
    lpVtbl: [*c]struct_ISupportErrorInfoVtbl,
};
pub const ITypeFactory = struct_ITypeFactory;
pub const struct_ITypeFactoryVtbl = extern struct {
    QueryInterface: ?fn ([*c]ITypeFactory, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ITypeFactory) callconv(.C) ULONG,
    Release: ?fn ([*c]ITypeFactory) callconv(.C) ULONG,
    CreateFromTypeInfo: ?fn ([*c]ITypeFactory, [*c]ITypeInfo, [*c]const IID, [*c]([*c]IUnknown)) callconv(.C) HRESULT,
};
pub const struct_ITypeFactory = extern struct {
    lpVtbl: [*c]struct_ITypeFactoryVtbl,
};
pub const ITypeMarshal = struct_ITypeMarshal;
pub const struct_ITypeMarshalVtbl = extern struct {
    QueryInterface: ?fn ([*c]ITypeMarshal, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ITypeMarshal) callconv(.C) ULONG,
    Release: ?fn ([*c]ITypeMarshal) callconv(.C) ULONG,
    Size: ?fn ([*c]ITypeMarshal, PVOID, DWORD, PVOID, [*c]ULONG) callconv(.C) HRESULT,
    Marshal: ?fn ([*c]ITypeMarshal, PVOID, DWORD, PVOID, ULONG, [*c]BYTE, [*c]ULONG) callconv(.C) HRESULT,
    Unmarshal: ?fn ([*c]ITypeMarshal, PVOID, DWORD, ULONG, [*c]BYTE, [*c]ULONG) callconv(.C) HRESULT,
    Free: ?fn ([*c]ITypeMarshal, PVOID) callconv(.C) HRESULT,
};
pub const struct_ITypeMarshal = extern struct {
    lpVtbl: [*c]struct_ITypeMarshalVtbl,
};
pub const IErrorLog = struct_IErrorLog;
pub const struct_IErrorLogVtbl = extern struct {
    QueryInterface: ?fn ([*c]IErrorLog, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IErrorLog) callconv(.C) ULONG,
    Release: ?fn ([*c]IErrorLog) callconv(.C) ULONG,
    AddError: ?fn ([*c]IErrorLog, LPCOLESTR, [*c]EXCEPINFO) callconv(.C) HRESULT,
};
pub const struct_IErrorLog = extern struct {
    lpVtbl: [*c]struct_IErrorLogVtbl,
};
pub const IPropertyBag = struct_IPropertyBag;
pub const struct_IPropertyBagVtbl = extern struct {
    QueryInterface: ?fn ([*c]IPropertyBag, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IPropertyBag) callconv(.C) ULONG,
    Release: ?fn ([*c]IPropertyBag) callconv(.C) ULONG,
    Read: ?fn ([*c]IPropertyBag, LPCOLESTR, [*c]VARIANT, [*c]IErrorLog) callconv(.C) HRESULT,
    Write: ?fn ([*c]IPropertyBag, LPCOLESTR, [*c]VARIANT) callconv(.C) HRESULT,
};
pub const struct_IPropertyBag = extern struct {
    lpVtbl: [*c]struct_IPropertyBagVtbl,
};
pub const ITypeLibRegistrationReader = struct_ITypeLibRegistrationReader;
pub const struct_ITypeLibRegistrationReaderVtbl = extern struct {
    QueryInterface: ?fn ([*c]ITypeLibRegistrationReader, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ITypeLibRegistrationReader) callconv(.C) ULONG,
    Release: ?fn ([*c]ITypeLibRegistrationReader) callconv(.C) ULONG,
    EnumTypeLibRegistrations: ?fn ([*c]ITypeLibRegistrationReader, [*c]([*c]IEnumUnknown)) callconv(.C) HRESULT,
};
pub const struct_ITypeLibRegistrationReader = extern struct {
    lpVtbl: [*c]struct_ITypeLibRegistrationReaderVtbl,
};
pub const ITypeLibRegistration = struct_ITypeLibRegistration;
pub const struct_ITypeLibRegistrationVtbl = extern struct {
    QueryInterface: ?fn ([*c]ITypeLibRegistration, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ITypeLibRegistration) callconv(.C) ULONG,
    Release: ?fn ([*c]ITypeLibRegistration) callconv(.C) ULONG,
    GetGuid: ?fn ([*c]ITypeLibRegistration, [*c]GUID) callconv(.C) HRESULT,
    GetVersion: ?fn ([*c]ITypeLibRegistration, [*c]BSTR) callconv(.C) HRESULT,
    GetLcid: ?fn ([*c]ITypeLibRegistration, [*c]LCID) callconv(.C) HRESULT,
    GetWin32Path: ?fn ([*c]ITypeLibRegistration, [*c]BSTR) callconv(.C) HRESULT,
    GetWin64Path: ?fn ([*c]ITypeLibRegistration, [*c]BSTR) callconv(.C) HRESULT,
    GetDisplayName: ?fn ([*c]ITypeLibRegistration, [*c]BSTR) callconv(.C) HRESULT,
    GetFlags: ?fn ([*c]ITypeLibRegistration, [*c]DWORD) callconv(.C) HRESULT,
    GetHelpDir: ?fn ([*c]ITypeLibRegistration, [*c]BSTR) callconv(.C) HRESULT,
};
pub const struct_ITypeLibRegistration = extern struct {
    lpVtbl: [*c]struct_ITypeLibRegistrationVtbl,
};
pub extern var __MIDL_itf_oaidl_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_oaidl_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const CURRENCY = CY;
pub const LPSAFEARRAYBOUND = [*c]struct_tagSAFEARRAYBOUND;
pub const struct__wireSAFEARR_BSTR = extern struct {
    Size: ULONG,
    aBstr: [*c]wireBSTR,
};
pub const SAFEARR_BSTR = struct__wireSAFEARR_BSTR;
pub const struct__wireSAFEARR_UNKNOWN = extern struct {
    Size: ULONG,
    apUnknown: [*c]([*c]IUnknown),
};
pub const SAFEARR_UNKNOWN = struct__wireSAFEARR_UNKNOWN;
pub const struct__wireSAFEARR_DISPATCH = extern struct {
    Size: ULONG,
    apDispatch: [*c]([*c]IDispatch),
};
pub const SAFEARR_DISPATCH = struct__wireSAFEARR_DISPATCH;
pub const wireVARIANT = [*c]struct__wireVARIANT;
pub const struct__wireSAFEARR_VARIANT = extern struct {
    Size: ULONG,
    aVariant: [*c]wireVARIANT,
};
pub const SAFEARR_VARIANT = struct__wireSAFEARR_VARIANT;
pub const struct__wireBRECORD = extern struct {
    fFlags: ULONG,
    clSize: ULONG,
    pRecInfo: [*c]IRecordInfo,
    pRecord: [*c]byte,
};
pub const wireBRECORD = [*c]struct__wireBRECORD;
pub const struct__wireSAFEARR_BRECORD = extern struct {
    Size: ULONG,
    aRecord: [*c]wireBRECORD,
};
pub const SAFEARR_BRECORD = struct__wireSAFEARR_BRECORD;
pub const struct__wireSAFEARR_HAVEIID = extern struct {
    Size: ULONG,
    apUnknown: [*c]([*c]IUnknown),
    iid: IID,
};
pub const SAFEARR_HAVEIID = struct__wireSAFEARR_HAVEIID;
pub const union___MIDL_IOleAutomationTypes_0001 = extern union {
    BstrStr: SAFEARR_BSTR,
    UnknownStr: SAFEARR_UNKNOWN,
    DispatchStr: SAFEARR_DISPATCH,
    VariantStr: SAFEARR_VARIANT,
    RecordStr: SAFEARR_BRECORD,
    HaveIidStr: SAFEARR_HAVEIID,
    ByteStr: BYTE_SIZEDARR,
    WordStr: WORD_SIZEDARR,
    LongStr: DWORD_SIZEDARR,
    HyperStr: HYPER_SIZEDARR,
};
pub const struct__wireSAFEARRAY_UNION = extern struct {
    sfType: ULONG,
    u: union___MIDL_IOleAutomationTypes_0001,
};
pub const SAFEARRAYUNION = struct__wireSAFEARRAY_UNION;
pub const struct__wireSAFEARRAY = extern struct {
    cDims: USHORT,
    fFeatures: USHORT,
    cbElements: ULONG,
    cLocks: ULONG,
    uArrayStructs: SAFEARRAYUNION,
    rgsabound: [1]SAFEARRAYBOUND,
};
pub const wireSAFEARRAY = [*c]struct__wireSAFEARRAY;
pub const wirePSAFEARRAY = [*c]wireSAFEARRAY;
pub const struct__wireVARIANT = extern struct {
    clSize: DWORD,
    rpcReserved: DWORD,
    vt: USHORT,
    wReserved1: USHORT,
    wReserved2: USHORT,
    wReserved3: USHORT,
    @"": extern union {
        llVal: LONGLONG,
        lVal: LONG,
        bVal: BYTE,
        iVal: SHORT,
        fltVal: FLOAT,
        dblVal: DOUBLE,
        boolVal: VARIANT_BOOL,
        scode: SCODE,
        cyVal: CY,
        date: DATE,
        bstrVal: wireBSTR,
        punkVal: [*c]IUnknown,
        pdispVal: [*c]IDispatch,
        parray: wirePSAFEARRAY,
        brecVal: wireBRECORD,
        pbVal: [*c]BYTE,
        piVal: [*c]SHORT,
        plVal: [*c]LONG,
        pllVal: [*c]LONGLONG,
        pfltVal: [*c]FLOAT,
        pdblVal: [*c]DOUBLE,
        pboolVal: [*c]VARIANT_BOOL,
        pscode: [*c]SCODE,
        pcyVal: [*c]CY,
        pdate: [*c]DATE,
        pbstrVal: [*c]wireBSTR,
        ppunkVal: [*c]([*c]IUnknown),
        ppdispVal: [*c]([*c]IDispatch),
        pparray: [*c]wirePSAFEARRAY,
        pvarVal: [*c]wireVARIANT,
        cVal: CHAR,
        uiVal: USHORT,
        ulVal: ULONG,
        ullVal: ULONGLONG,
        intVal: INT,
        uintVal: UINT,
        decVal: DECIMAL,
        pdecVal: [*c]DECIMAL,
        pcVal: [*c]CHAR,
        puiVal: [*c]USHORT,
        pulVal: [*c]ULONG,
        pullVal: [*c]ULONGLONG,
        pintVal: [*c]INT,
        puintVal: [*c]UINT,
    },
};
pub const SF_ERROR = enum_tagSF_TYPE.SF_ERROR;
pub const SF_I1 = enum_tagSF_TYPE.SF_I1;
pub const SF_I2 = enum_tagSF_TYPE.SF_I2;
pub const SF_I4 = enum_tagSF_TYPE.SF_I4;
pub const SF_I8 = enum_tagSF_TYPE.SF_I8;
pub const SF_BSTR = enum_tagSF_TYPE.SF_BSTR;
pub const SF_UNKNOWN = enum_tagSF_TYPE.SF_UNKNOWN;
pub const SF_DISPATCH = enum_tagSF_TYPE.SF_DISPATCH;
pub const SF_VARIANT = enum_tagSF_TYPE.SF_VARIANT;
pub const SF_RECORD = enum_tagSF_TYPE.SF_RECORD;
pub const SF_HAVEIID = enum_tagSF_TYPE.SF_HAVEIID;
pub const enum_tagSF_TYPE = extern enum {
    SF_ERROR = 10,
    SF_I1 = 16,
    SF_I2 = 2,
    SF_I4 = 3,
    SF_I8 = 20,
    SF_BSTR = 8,
    SF_UNKNOWN = 13,
    SF_DISPATCH = 9,
    SF_VARIANT = 12,
    SF_RECORD = 36,
    SF_HAVEIID = 32781,
};
pub const SF_TYPE = enum_tagSF_TYPE;
pub const LPVARIANT = [*c]VARIANT;
pub const LPVARIANTARG = [*c]VARIANT;
pub const ARRAYDESC = struct_tagARRAYDESC;
pub const PARAMDESCEX = struct_tagPARAMDESCEX;
pub const LPPARAMDESC = [*c]struct_tagPARAMDESC;
pub const LPIDLDESC = [*c]struct_tagIDLDESC;
pub const LPELEMDESC = [*c]struct_tagELEMDESC;
pub const LPTYPEATTR = [*c]struct_tagTYPEATTR;
pub const LPEXCEPINFO = [*c]struct_tagEXCEPINFO;
pub const LPFUNCDESC = [*c]struct_tagFUNCDESC;
pub const LPVARDESC = [*c]struct_tagVARDESC;
pub const TYPEFLAG_FAPPOBJECT = enum_tagTYPEFLAGS.TYPEFLAG_FAPPOBJECT;
pub const TYPEFLAG_FCANCREATE = enum_tagTYPEFLAGS.TYPEFLAG_FCANCREATE;
pub const TYPEFLAG_FLICENSED = enum_tagTYPEFLAGS.TYPEFLAG_FLICENSED;
pub const TYPEFLAG_FPREDECLID = enum_tagTYPEFLAGS.TYPEFLAG_FPREDECLID;
pub const TYPEFLAG_FHIDDEN = enum_tagTYPEFLAGS.TYPEFLAG_FHIDDEN;
pub const TYPEFLAG_FCONTROL = enum_tagTYPEFLAGS.TYPEFLAG_FCONTROL;
pub const TYPEFLAG_FDUAL = enum_tagTYPEFLAGS.TYPEFLAG_FDUAL;
pub const TYPEFLAG_FNONEXTENSIBLE = enum_tagTYPEFLAGS.TYPEFLAG_FNONEXTENSIBLE;
pub const TYPEFLAG_FOLEAUTOMATION = enum_tagTYPEFLAGS.TYPEFLAG_FOLEAUTOMATION;
pub const TYPEFLAG_FRESTRICTED = enum_tagTYPEFLAGS.TYPEFLAG_FRESTRICTED;
pub const TYPEFLAG_FAGGREGATABLE = enum_tagTYPEFLAGS.TYPEFLAG_FAGGREGATABLE;
pub const TYPEFLAG_FREPLACEABLE = enum_tagTYPEFLAGS.TYPEFLAG_FREPLACEABLE;
pub const TYPEFLAG_FDISPATCHABLE = enum_tagTYPEFLAGS.TYPEFLAG_FDISPATCHABLE;
pub const TYPEFLAG_FREVERSEBIND = enum_tagTYPEFLAGS.TYPEFLAG_FREVERSEBIND;
pub const TYPEFLAG_FPROXY = enum_tagTYPEFLAGS.TYPEFLAG_FPROXY;
pub const enum_tagTYPEFLAGS = extern enum {
    TYPEFLAG_FAPPOBJECT = 1,
    TYPEFLAG_FCANCREATE = 2,
    TYPEFLAG_FLICENSED = 4,
    TYPEFLAG_FPREDECLID = 8,
    TYPEFLAG_FHIDDEN = 16,
    TYPEFLAG_FCONTROL = 32,
    TYPEFLAG_FDUAL = 64,
    TYPEFLAG_FNONEXTENSIBLE = 128,
    TYPEFLAG_FOLEAUTOMATION = 256,
    TYPEFLAG_FRESTRICTED = 512,
    TYPEFLAG_FAGGREGATABLE = 1024,
    TYPEFLAG_FREPLACEABLE = 2048,
    TYPEFLAG_FDISPATCHABLE = 4096,
    TYPEFLAG_FREVERSEBIND = 8192,
    TYPEFLAG_FPROXY = 16384,
};
pub const TYPEFLAGS = enum_tagTYPEFLAGS;
pub const FUNCFLAG_FRESTRICTED = enum_tagFUNCFLAGS.FUNCFLAG_FRESTRICTED;
pub const FUNCFLAG_FSOURCE = enum_tagFUNCFLAGS.FUNCFLAG_FSOURCE;
pub const FUNCFLAG_FBINDABLE = enum_tagFUNCFLAGS.FUNCFLAG_FBINDABLE;
pub const FUNCFLAG_FREQUESTEDIT = enum_tagFUNCFLAGS.FUNCFLAG_FREQUESTEDIT;
pub const FUNCFLAG_FDISPLAYBIND = enum_tagFUNCFLAGS.FUNCFLAG_FDISPLAYBIND;
pub const FUNCFLAG_FDEFAULTBIND = enum_tagFUNCFLAGS.FUNCFLAG_FDEFAULTBIND;
pub const FUNCFLAG_FHIDDEN = enum_tagFUNCFLAGS.FUNCFLAG_FHIDDEN;
pub const FUNCFLAG_FUSESGETLASTERROR = enum_tagFUNCFLAGS.FUNCFLAG_FUSESGETLASTERROR;
pub const FUNCFLAG_FDEFAULTCOLLELEM = enum_tagFUNCFLAGS.FUNCFLAG_FDEFAULTCOLLELEM;
pub const FUNCFLAG_FUIDEFAULT = enum_tagFUNCFLAGS.FUNCFLAG_FUIDEFAULT;
pub const FUNCFLAG_FNONBROWSABLE = enum_tagFUNCFLAGS.FUNCFLAG_FNONBROWSABLE;
pub const FUNCFLAG_FREPLACEABLE = enum_tagFUNCFLAGS.FUNCFLAG_FREPLACEABLE;
pub const FUNCFLAG_FIMMEDIATEBIND = enum_tagFUNCFLAGS.FUNCFLAG_FIMMEDIATEBIND;
pub const enum_tagFUNCFLAGS = extern enum {
    FUNCFLAG_FRESTRICTED = 1,
    FUNCFLAG_FSOURCE = 2,
    FUNCFLAG_FBINDABLE = 4,
    FUNCFLAG_FREQUESTEDIT = 8,
    FUNCFLAG_FDISPLAYBIND = 16,
    FUNCFLAG_FDEFAULTBIND = 32,
    FUNCFLAG_FHIDDEN = 64,
    FUNCFLAG_FUSESGETLASTERROR = 128,
    FUNCFLAG_FDEFAULTCOLLELEM = 256,
    FUNCFLAG_FUIDEFAULT = 512,
    FUNCFLAG_FNONBROWSABLE = 1024,
    FUNCFLAG_FREPLACEABLE = 2048,
    FUNCFLAG_FIMMEDIATEBIND = 4096,
};
pub const FUNCFLAGS = enum_tagFUNCFLAGS;
pub const VARFLAG_FREADONLY = enum_tagVARFLAGS.VARFLAG_FREADONLY;
pub const VARFLAG_FSOURCE = enum_tagVARFLAGS.VARFLAG_FSOURCE;
pub const VARFLAG_FBINDABLE = enum_tagVARFLAGS.VARFLAG_FBINDABLE;
pub const VARFLAG_FREQUESTEDIT = enum_tagVARFLAGS.VARFLAG_FREQUESTEDIT;
pub const VARFLAG_FDISPLAYBIND = enum_tagVARFLAGS.VARFLAG_FDISPLAYBIND;
pub const VARFLAG_FDEFAULTBIND = enum_tagVARFLAGS.VARFLAG_FDEFAULTBIND;
pub const VARFLAG_FHIDDEN = enum_tagVARFLAGS.VARFLAG_FHIDDEN;
pub const VARFLAG_FRESTRICTED = enum_tagVARFLAGS.VARFLAG_FRESTRICTED;
pub const VARFLAG_FDEFAULTCOLLELEM = enum_tagVARFLAGS.VARFLAG_FDEFAULTCOLLELEM;
pub const VARFLAG_FUIDEFAULT = enum_tagVARFLAGS.VARFLAG_FUIDEFAULT;
pub const VARFLAG_FNONBROWSABLE = enum_tagVARFLAGS.VARFLAG_FNONBROWSABLE;
pub const VARFLAG_FREPLACEABLE = enum_tagVARFLAGS.VARFLAG_FREPLACEABLE;
pub const VARFLAG_FIMMEDIATEBIND = enum_tagVARFLAGS.VARFLAG_FIMMEDIATEBIND;
pub const enum_tagVARFLAGS = extern enum {
    VARFLAG_FREADONLY = 1,
    VARFLAG_FSOURCE = 2,
    VARFLAG_FBINDABLE = 4,
    VARFLAG_FREQUESTEDIT = 8,
    VARFLAG_FDISPLAYBIND = 16,
    VARFLAG_FDEFAULTBIND = 32,
    VARFLAG_FHIDDEN = 64,
    VARFLAG_FRESTRICTED = 128,
    VARFLAG_FDEFAULTCOLLELEM = 256,
    VARFLAG_FUIDEFAULT = 512,
    VARFLAG_FNONBROWSABLE = 1024,
    VARFLAG_FREPLACEABLE = 2048,
    VARFLAG_FIMMEDIATEBIND = 4096,
};
pub const VARFLAGS = enum_tagVARFLAGS;
pub const struct_tagCLEANLOCALSTORAGE = extern struct {
    pInterface: [*c]IUnknown,
    pStorage: PVOID,
    flags: DWORD,
};
pub const CLEANLOCALSTORAGE = struct_tagCLEANLOCALSTORAGE;
pub const CUSTDATAITEM = struct_tagCUSTDATAITEM;
pub const LPCUSTDATA = [*c]struct_tagCUSTDATA;
pub extern var IOleAutomationTypes_v1_0_c_ifspec: RPC_IF_HANDLE;
pub extern var IOleAutomationTypes_v1_0_s_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_oaidl_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_oaidl_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPCREATETYPEINFO = [*c]ICreateTypeInfo;
pub extern const IID_ICreateTypeInfo: IID;
pub const ICreateTypeInfoVtbl = struct_ICreateTypeInfoVtbl;
pub const LPCREATETYPEINFO2 = [*c]ICreateTypeInfo2;
pub extern const IID_ICreateTypeInfo2: IID;
pub const ICreateTypeInfo2Vtbl = struct_ICreateTypeInfo2Vtbl;
pub const LPCREATETYPELIB = [*c]ICreateTypeLib;
pub extern const IID_ICreateTypeLib: IID;
pub const ICreateTypeLibVtbl = struct_ICreateTypeLibVtbl;
pub const LPCREATETYPELIB2 = [*c]ICreateTypeLib2;
pub extern const IID_ICreateTypeLib2: IID;
pub const ICreateTypeLib2Vtbl = struct_ICreateTypeLib2Vtbl;
pub extern var __MIDL_itf_oaidl_0000_0005_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_oaidl_0000_0005_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPDISPATCH = [*c]IDispatch;
pub extern const IID_IDispatch: IID;
pub const IDispatchVtbl = struct_IDispatchVtbl;
pub extern fn IDispatch_RemoteInvoke_Proxy(This: [*c]IDispatch, dispIdMember: DISPID, riid: [*c]const IID, lcid: LCID, dwFlags: DWORD, pDispParams: [*c]DISPPARAMS, pVarResult: [*c]VARIANT, pExcepInfo: [*c]EXCEPINFO, pArgErr: [*c]UINT, cVarRef: UINT, rgVarRefIdx: [*c]UINT, rgVarRef: [*c]VARIANTARG) HRESULT;
pub extern fn IDispatch_RemoteInvoke_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub const LPENUMVARIANT = [*c]IEnumVARIANT;
pub extern const IID_IEnumVARIANT: IID;
pub const IEnumVARIANTVtbl = struct_IEnumVARIANTVtbl;
pub extern fn IEnumVARIANT_RemoteNext_Proxy(This: [*c]IEnumVARIANT, celt: ULONG, rgVar: [*c]VARIANT, pCeltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumVARIANT_RemoteNext_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub const LPTYPECOMP = [*c]ITypeComp;
pub const LPBINDPTR = [*c]union_tagBINDPTR;
pub extern const IID_ITypeComp: IID;
pub const ITypeCompVtbl = struct_ITypeCompVtbl;
pub extern fn ITypeComp_RemoteBind_Proxy(This: [*c]ITypeComp, szName: LPOLESTR, lHashVal: ULONG, wFlags: WORD, ppTInfo: [*c]([*c]ITypeInfo), pDescKind: [*c]DESCKIND, ppFuncDesc: [*c]LPFUNCDESC, ppVarDesc: [*c]LPVARDESC, ppTypeComp: [*c]([*c]ITypeComp), pDummy: [*c]CLEANLOCALSTORAGE) HRESULT;
pub extern fn ITypeComp_RemoteBind_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeComp_RemoteBindType_Proxy(This: [*c]ITypeComp, szName: LPOLESTR, lHashVal: ULONG, ppTInfo: [*c]([*c]ITypeInfo)) HRESULT;
pub extern fn ITypeComp_RemoteBindType_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_oaidl_0000_0008_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_oaidl_0000_0008_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPTYPEINFO = [*c]ITypeInfo;
pub extern const IID_ITypeInfo: IID;
pub const ITypeInfoVtbl = struct_ITypeInfoVtbl;
pub extern fn ITypeInfo_RemoteGetTypeAttr_Proxy(This: [*c]ITypeInfo, ppTypeAttr: [*c]LPTYPEATTR, pDummy: [*c]CLEANLOCALSTORAGE) HRESULT;
pub extern fn ITypeInfo_RemoteGetTypeAttr_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeInfo_RemoteGetFuncDesc_Proxy(This: [*c]ITypeInfo, index: UINT, ppFuncDesc: [*c]LPFUNCDESC, pDummy: [*c]CLEANLOCALSTORAGE) HRESULT;
pub extern fn ITypeInfo_RemoteGetFuncDesc_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeInfo_RemoteGetVarDesc_Proxy(This: [*c]ITypeInfo, index: UINT, ppVarDesc: [*c]LPVARDESC, pDummy: [*c]CLEANLOCALSTORAGE) HRESULT;
pub extern fn ITypeInfo_RemoteGetVarDesc_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeInfo_RemoteGetNames_Proxy(This: [*c]ITypeInfo, memid: MEMBERID, rgBstrNames: [*c]BSTR, cMaxNames: UINT, pcNames: [*c]UINT) HRESULT;
pub extern fn ITypeInfo_RemoteGetNames_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeInfo_LocalGetIDsOfNames_Proxy(This: [*c]ITypeInfo) HRESULT;
pub extern fn ITypeInfo_LocalGetIDsOfNames_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeInfo_LocalInvoke_Proxy(This: [*c]ITypeInfo) HRESULT;
pub extern fn ITypeInfo_LocalInvoke_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeInfo_RemoteGetDocumentation_Proxy(This: [*c]ITypeInfo, memid: MEMBERID, refPtrFlags: DWORD, pBstrName: [*c]BSTR, pBstrDocString: [*c]BSTR, pdwHelpContext: [*c]DWORD, pBstrHelpFile: [*c]BSTR) HRESULT;
pub extern fn ITypeInfo_RemoteGetDocumentation_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeInfo_RemoteGetDllEntry_Proxy(This: [*c]ITypeInfo, memid: MEMBERID, invKind: INVOKEKIND, refPtrFlags: DWORD, pBstrDllName: [*c]BSTR, pBstrName: [*c]BSTR, pwOrdinal: [*c]WORD) HRESULT;
pub extern fn ITypeInfo_RemoteGetDllEntry_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeInfo_LocalAddressOfMember_Proxy(This: [*c]ITypeInfo) HRESULT;
pub extern fn ITypeInfo_LocalAddressOfMember_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeInfo_RemoteCreateInstance_Proxy(This: [*c]ITypeInfo, riid: [*c]const IID, ppvObj: [*c]([*c]IUnknown)) HRESULT;
pub extern fn ITypeInfo_RemoteCreateInstance_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeInfo_RemoteGetContainingTypeLib_Proxy(This: [*c]ITypeInfo, ppTLib: [*c]([*c]ITypeLib), pIndex: [*c]UINT) HRESULT;
pub extern fn ITypeInfo_RemoteGetContainingTypeLib_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeInfo_LocalReleaseTypeAttr_Proxy(This: [*c]ITypeInfo) HRESULT;
pub extern fn ITypeInfo_LocalReleaseTypeAttr_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeInfo_LocalReleaseFuncDesc_Proxy(This: [*c]ITypeInfo) HRESULT;
pub extern fn ITypeInfo_LocalReleaseFuncDesc_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeInfo_LocalReleaseVarDesc_Proxy(This: [*c]ITypeInfo) HRESULT;
pub extern fn ITypeInfo_LocalReleaseVarDesc_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub const LPTYPEINFO2 = [*c]ITypeInfo2;
pub extern const IID_ITypeInfo2: IID;
pub const ITypeInfo2Vtbl = struct_ITypeInfo2Vtbl;
pub extern fn ITypeInfo2_RemoteGetDocumentation2_Proxy(This: [*c]ITypeInfo2, memid: MEMBERID, lcid: LCID, refPtrFlags: DWORD, pbstrHelpString: [*c]BSTR, pdwHelpStringContext: [*c]DWORD, pbstrHelpStringDll: [*c]BSTR) HRESULT;
pub extern fn ITypeInfo2_RemoteGetDocumentation2_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_oaidl_0000_0010_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_oaidl_0000_0010_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LIBFLAG_FRESTRICTED = enum_tagLIBFLAGS.LIBFLAG_FRESTRICTED;
pub const LIBFLAG_FCONTROL = enum_tagLIBFLAGS.LIBFLAG_FCONTROL;
pub const LIBFLAG_FHIDDEN = enum_tagLIBFLAGS.LIBFLAG_FHIDDEN;
pub const LIBFLAG_FHASDISKIMAGE = enum_tagLIBFLAGS.LIBFLAG_FHASDISKIMAGE;
pub const enum_tagLIBFLAGS = extern enum {
    LIBFLAG_FRESTRICTED = 1,
    LIBFLAG_FCONTROL = 2,
    LIBFLAG_FHIDDEN = 4,
    LIBFLAG_FHASDISKIMAGE = 8,
};
pub const LIBFLAGS = enum_tagLIBFLAGS;
pub const LPTYPELIB = [*c]ITypeLib;
pub const LPTLIBATTR = [*c]struct_tagTLIBATTR;
pub extern const IID_ITypeLib: IID;
pub const ITypeLibVtbl = struct_ITypeLibVtbl;
pub extern fn ITypeLib_RemoteGetTypeInfoCount_Proxy(This: [*c]ITypeLib, pcTInfo: [*c]UINT) HRESULT;
pub extern fn ITypeLib_RemoteGetTypeInfoCount_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeLib_RemoteGetLibAttr_Proxy(This: [*c]ITypeLib, ppTLibAttr: [*c]LPTLIBATTR, pDummy: [*c]CLEANLOCALSTORAGE) HRESULT;
pub extern fn ITypeLib_RemoteGetLibAttr_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeLib_RemoteGetDocumentation_Proxy(This: [*c]ITypeLib, index: INT, refPtrFlags: DWORD, pBstrName: [*c]BSTR, pBstrDocString: [*c]BSTR, pdwHelpContext: [*c]DWORD, pBstrHelpFile: [*c]BSTR) HRESULT;
pub extern fn ITypeLib_RemoteGetDocumentation_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeLib_RemoteIsName_Proxy(This: [*c]ITypeLib, szNameBuf: LPOLESTR, lHashVal: ULONG, pfName: [*c]BOOL, pBstrLibName: [*c]BSTR) HRESULT;
pub extern fn ITypeLib_RemoteIsName_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeLib_RemoteFindName_Proxy(This: [*c]ITypeLib, szNameBuf: LPOLESTR, lHashVal: ULONG, ppTInfo: [*c]([*c]ITypeInfo), rgMemId: [*c]MEMBERID, pcFound: [*c]USHORT, pBstrLibName: [*c]BSTR) HRESULT;
pub extern fn ITypeLib_RemoteFindName_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeLib_LocalReleaseTLibAttr_Proxy(This: [*c]ITypeLib) HRESULT;
pub extern fn ITypeLib_LocalReleaseTLibAttr_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_oaidl_0000_0011_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_oaidl_0000_0011_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPTYPELIB2 = [*c]ITypeLib2;
pub extern const IID_ITypeLib2: IID;
pub const ITypeLib2Vtbl = struct_ITypeLib2Vtbl;
pub extern fn ITypeLib2_RemoteGetLibStatistics_Proxy(This: [*c]ITypeLib2, pcUniqueNames: [*c]ULONG, pcchUniqueNames: [*c]ULONG) HRESULT;
pub extern fn ITypeLib2_RemoteGetLibStatistics_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn ITypeLib2_RemoteGetDocumentation2_Proxy(This: [*c]ITypeLib2, index: INT, lcid: LCID, refPtrFlags: DWORD, pbstrHelpString: [*c]BSTR, pdwHelpStringContext: [*c]DWORD, pbstrHelpStringDll: [*c]BSTR) HRESULT;
pub extern fn ITypeLib2_RemoteGetDocumentation2_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub const LPTYPECHANGEEVENTS = [*c]ITypeChangeEvents;
pub extern const IID_ITypeChangeEvents: IID;
pub const ITypeChangeEventsVtbl = struct_ITypeChangeEventsVtbl;
pub const LPERRORINFO = [*c]IErrorInfo;
pub extern const IID_IErrorInfo: IID;
pub const IErrorInfoVtbl = struct_IErrorInfoVtbl;
pub const LPCREATEERRORINFO = [*c]ICreateErrorInfo;
pub extern const IID_ICreateErrorInfo: IID;
pub const ICreateErrorInfoVtbl = struct_ICreateErrorInfoVtbl;
pub const LPSUPPORTERRORINFO = [*c]ISupportErrorInfo;
pub extern const IID_ISupportErrorInfo: IID;
pub const ISupportErrorInfoVtbl = struct_ISupportErrorInfoVtbl;
pub extern const IID_ITypeFactory: IID;
pub const ITypeFactoryVtbl = struct_ITypeFactoryVtbl;
pub extern const IID_ITypeMarshal: IID;
pub const ITypeMarshalVtbl = struct_ITypeMarshalVtbl;
pub const LPRECORDINFO = [*c]IRecordInfo;
pub extern const IID_IRecordInfo: IID;
pub const IRecordInfoVtbl = struct_IRecordInfoVtbl;
pub const LPERRORLOG = [*c]IErrorLog;
pub extern const IID_IErrorLog: IID;
pub const IErrorLogVtbl = struct_IErrorLogVtbl;
pub const LPPROPERTYBAG = [*c]IPropertyBag;
pub extern const IID_IPropertyBag: IID;
pub const IPropertyBagVtbl = struct_IPropertyBagVtbl;
pub extern fn IPropertyBag_RemoteRead_Proxy(This: [*c]IPropertyBag, pszPropName: LPCOLESTR, pVar: [*c]VARIANT, pErrorLog: [*c]IErrorLog, varType: DWORD, pUnkObj: [*c]IUnknown) HRESULT;
pub extern fn IPropertyBag_RemoteRead_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern const IID_ITypeLibRegistrationReader: IID;
pub const ITypeLibRegistrationReaderVtbl = struct_ITypeLibRegistrationReaderVtbl;
pub extern const IID_ITypeLibRegistration: IID;
pub const ITypeLibRegistrationVtbl = struct_ITypeLibRegistrationVtbl;
pub extern const CLSID_TypeLibRegistrationReader: CLSID;
pub extern var __MIDL_itf_oaidl_0000_0023_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_oaidl_0000_0023_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern fn BSTR_UserSize(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]BSTR) c_ulong;
pub extern fn BSTR_UserMarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]BSTR) [*c]u8;
pub extern fn BSTR_UserUnmarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]BSTR) [*c]u8;
pub extern fn BSTR_UserFree(arg0: [*c]c_ulong, arg1: [*c]BSTR) void;
pub extern fn CLEANLOCALSTORAGE_UserSize(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]CLEANLOCALSTORAGE) c_ulong;
pub extern fn CLEANLOCALSTORAGE_UserMarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]CLEANLOCALSTORAGE) [*c]u8;
pub extern fn CLEANLOCALSTORAGE_UserUnmarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]CLEANLOCALSTORAGE) [*c]u8;
pub extern fn CLEANLOCALSTORAGE_UserFree(arg0: [*c]c_ulong, arg1: [*c]CLEANLOCALSTORAGE) void;
pub extern fn VARIANT_UserSize(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]VARIANT) c_ulong;
pub extern fn VARIANT_UserMarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]VARIANT) [*c]u8;
pub extern fn VARIANT_UserUnmarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]VARIANT) [*c]u8;
pub extern fn VARIANT_UserFree(arg0: [*c]c_ulong, arg1: [*c]VARIANT) void;
pub extern fn BSTR_UserSize64(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]BSTR) c_ulong;
pub extern fn BSTR_UserMarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]BSTR) [*c]u8;
pub extern fn BSTR_UserUnmarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]BSTR) [*c]u8;
pub extern fn BSTR_UserFree64(arg0: [*c]c_ulong, arg1: [*c]BSTR) void;
pub extern fn CLEANLOCALSTORAGE_UserSize64(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]CLEANLOCALSTORAGE) c_ulong;
pub extern fn CLEANLOCALSTORAGE_UserMarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]CLEANLOCALSTORAGE) [*c]u8;
pub extern fn CLEANLOCALSTORAGE_UserUnmarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]CLEANLOCALSTORAGE) [*c]u8;
pub extern fn CLEANLOCALSTORAGE_UserFree64(arg0: [*c]c_ulong, arg1: [*c]CLEANLOCALSTORAGE) void;
pub extern fn VARIANT_UserSize64(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]VARIANT) c_ulong;
pub extern fn VARIANT_UserMarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]VARIANT) [*c]u8;
pub extern fn VARIANT_UserUnmarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]VARIANT) [*c]u8;
pub extern fn VARIANT_UserFree64(arg0: [*c]c_ulong, arg1: [*c]VARIANT) void;
pub extern fn IDispatch_Invoke_Proxy(This: [*c]IDispatch, dispIdMember: DISPID, riid: [*c]const IID, lcid: LCID, wFlags: WORD, pDispParams: [*c]DISPPARAMS, pVarResult: [*c]VARIANT, pExcepInfo: [*c]EXCEPINFO, puArgErr: [*c]UINT) HRESULT;
pub extern fn IDispatch_Invoke_Stub(This: [*c]IDispatch, dispIdMember: DISPID, riid: [*c]const IID, lcid: LCID, dwFlags: DWORD, pDispParams: [*c]DISPPARAMS, pVarResult: [*c]VARIANT, pExcepInfo: [*c]EXCEPINFO, pArgErr: [*c]UINT, cVarRef: UINT, rgVarRefIdx: [*c]UINT, rgVarRef: [*c]VARIANTARG) HRESULT;
pub extern fn IEnumVARIANT_Next_Proxy(This: [*c]IEnumVARIANT, celt: ULONG, rgVar: [*c]VARIANT, pCeltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumVARIANT_Next_Stub(This: [*c]IEnumVARIANT, celt: ULONG, rgVar: [*c]VARIANT, pCeltFetched: [*c]ULONG) HRESULT;
pub extern fn ITypeComp_Bind_Proxy(This: [*c]ITypeComp, szName: LPOLESTR, lHashVal: ULONG, wFlags: WORD, ppTInfo: [*c]([*c]ITypeInfo), pDescKind: [*c]DESCKIND, pBindPtr: [*c]BINDPTR) HRESULT;
pub extern fn ITypeComp_Bind_Stub(This: [*c]ITypeComp, szName: LPOLESTR, lHashVal: ULONG, wFlags: WORD, ppTInfo: [*c]([*c]ITypeInfo), pDescKind: [*c]DESCKIND, ppFuncDesc: [*c]LPFUNCDESC, ppVarDesc: [*c]LPVARDESC, ppTypeComp: [*c]([*c]ITypeComp), pDummy: [*c]CLEANLOCALSTORAGE) HRESULT;
pub extern fn ITypeComp_BindType_Proxy(This: [*c]ITypeComp, szName: LPOLESTR, lHashVal: ULONG, ppTInfo: [*c]([*c]ITypeInfo), ppTComp: [*c]([*c]ITypeComp)) HRESULT;
pub extern fn ITypeComp_BindType_Stub(This: [*c]ITypeComp, szName: LPOLESTR, lHashVal: ULONG, ppTInfo: [*c]([*c]ITypeInfo)) HRESULT;
pub extern fn ITypeInfo_GetTypeAttr_Proxy(This: [*c]ITypeInfo, ppTypeAttr: [*c]([*c]TYPEATTR)) HRESULT;
pub extern fn ITypeInfo_GetTypeAttr_Stub(This: [*c]ITypeInfo, ppTypeAttr: [*c]LPTYPEATTR, pDummy: [*c]CLEANLOCALSTORAGE) HRESULT;
pub extern fn ITypeInfo_GetFuncDesc_Proxy(This: [*c]ITypeInfo, index: UINT, ppFuncDesc: [*c]([*c]FUNCDESC)) HRESULT;
pub extern fn ITypeInfo_GetFuncDesc_Stub(This: [*c]ITypeInfo, index: UINT, ppFuncDesc: [*c]LPFUNCDESC, pDummy: [*c]CLEANLOCALSTORAGE) HRESULT;
pub extern fn ITypeInfo_GetVarDesc_Proxy(This: [*c]ITypeInfo, index: UINT, ppVarDesc: [*c]([*c]VARDESC)) HRESULT;
pub extern fn ITypeInfo_GetVarDesc_Stub(This: [*c]ITypeInfo, index: UINT, ppVarDesc: [*c]LPVARDESC, pDummy: [*c]CLEANLOCALSTORAGE) HRESULT;
pub extern fn ITypeInfo_GetNames_Proxy(This: [*c]ITypeInfo, memid: MEMBERID, rgBstrNames: [*c]BSTR, cMaxNames: UINT, pcNames: [*c]UINT) HRESULT;
pub extern fn ITypeInfo_GetNames_Stub(This: [*c]ITypeInfo, memid: MEMBERID, rgBstrNames: [*c]BSTR, cMaxNames: UINT, pcNames: [*c]UINT) HRESULT;
pub extern fn ITypeInfo_GetIDsOfNames_Proxy(This: [*c]ITypeInfo, rgszNames: [*c]LPOLESTR, cNames: UINT, pMemId: [*c]MEMBERID) HRESULT;
pub extern fn ITypeInfo_GetIDsOfNames_Stub(This: [*c]ITypeInfo) HRESULT;
pub extern fn ITypeInfo_Invoke_Proxy(This: [*c]ITypeInfo, pvInstance: PVOID, memid: MEMBERID, wFlags: WORD, pDispParams: [*c]DISPPARAMS, pVarResult: [*c]VARIANT, pExcepInfo: [*c]EXCEPINFO, puArgErr: [*c]UINT) HRESULT;
pub extern fn ITypeInfo_Invoke_Stub(This: [*c]ITypeInfo) HRESULT;
pub extern fn ITypeInfo_GetDocumentation_Proxy(This: [*c]ITypeInfo, memid: MEMBERID, pBstrName: [*c]BSTR, pBstrDocString: [*c]BSTR, pdwHelpContext: [*c]DWORD, pBstrHelpFile: [*c]BSTR) HRESULT;
pub extern fn ITypeInfo_GetDocumentation_Stub(This: [*c]ITypeInfo, memid: MEMBERID, refPtrFlags: DWORD, pBstrName: [*c]BSTR, pBstrDocString: [*c]BSTR, pdwHelpContext: [*c]DWORD, pBstrHelpFile: [*c]BSTR) HRESULT;
pub extern fn ITypeInfo_GetDllEntry_Proxy(This: [*c]ITypeInfo, memid: MEMBERID, invKind: INVOKEKIND, pBstrDllName: [*c]BSTR, pBstrName: [*c]BSTR, pwOrdinal: [*c]WORD) HRESULT;
pub extern fn ITypeInfo_GetDllEntry_Stub(This: [*c]ITypeInfo, memid: MEMBERID, invKind: INVOKEKIND, refPtrFlags: DWORD, pBstrDllName: [*c]BSTR, pBstrName: [*c]BSTR, pwOrdinal: [*c]WORD) HRESULT;
pub extern fn ITypeInfo_AddressOfMember_Proxy(This: [*c]ITypeInfo, memid: MEMBERID, invKind: INVOKEKIND, ppv: [*c]PVOID) HRESULT;
pub extern fn ITypeInfo_AddressOfMember_Stub(This: [*c]ITypeInfo) HRESULT;
pub extern fn ITypeInfo_CreateInstance_Proxy(This: [*c]ITypeInfo, pUnkOuter: [*c]IUnknown, riid: [*c]const IID, ppvObj: [*c]PVOID) HRESULT;
pub extern fn ITypeInfo_CreateInstance_Stub(This: [*c]ITypeInfo, riid: [*c]const IID, ppvObj: [*c]([*c]IUnknown)) HRESULT;
pub extern fn ITypeInfo_GetContainingTypeLib_Proxy(This: [*c]ITypeInfo, ppTLib: [*c]([*c]ITypeLib), pIndex: [*c]UINT) HRESULT;
pub extern fn ITypeInfo_GetContainingTypeLib_Stub(This: [*c]ITypeInfo, ppTLib: [*c]([*c]ITypeLib), pIndex: [*c]UINT) HRESULT;
pub extern fn ITypeInfo_ReleaseTypeAttr_Proxy(This: [*c]ITypeInfo, pTypeAttr: [*c]TYPEATTR) void;
pub extern fn ITypeInfo_ReleaseTypeAttr_Stub(This: [*c]ITypeInfo) HRESULT;
pub extern fn ITypeInfo_ReleaseFuncDesc_Proxy(This: [*c]ITypeInfo, pFuncDesc: [*c]FUNCDESC) void;
pub extern fn ITypeInfo_ReleaseFuncDesc_Stub(This: [*c]ITypeInfo) HRESULT;
pub extern fn ITypeInfo_ReleaseVarDesc_Proxy(This: [*c]ITypeInfo, pVarDesc: [*c]VARDESC) void;
pub extern fn ITypeInfo_ReleaseVarDesc_Stub(This: [*c]ITypeInfo) HRESULT;
pub extern fn ITypeInfo2_GetDocumentation2_Proxy(This: [*c]ITypeInfo2, memid: MEMBERID, lcid: LCID, pbstrHelpString: [*c]BSTR, pdwHelpStringContext: [*c]DWORD, pbstrHelpStringDll: [*c]BSTR) HRESULT;
pub extern fn ITypeInfo2_GetDocumentation2_Stub(This: [*c]ITypeInfo2, memid: MEMBERID, lcid: LCID, refPtrFlags: DWORD, pbstrHelpString: [*c]BSTR, pdwHelpStringContext: [*c]DWORD, pbstrHelpStringDll: [*c]BSTR) HRESULT;
pub extern fn ITypeLib_GetTypeInfoCount_Proxy(This: [*c]ITypeLib) UINT;
pub extern fn ITypeLib_GetTypeInfoCount_Stub(This: [*c]ITypeLib, pcTInfo: [*c]UINT) HRESULT;
pub extern fn ITypeLib_GetLibAttr_Proxy(This: [*c]ITypeLib, ppTLibAttr: [*c]([*c]TLIBATTR)) HRESULT;
pub extern fn ITypeLib_GetLibAttr_Stub(This: [*c]ITypeLib, ppTLibAttr: [*c]LPTLIBATTR, pDummy: [*c]CLEANLOCALSTORAGE) HRESULT;
pub extern fn ITypeLib_GetDocumentation_Proxy(This: [*c]ITypeLib, index: INT, pBstrName: [*c]BSTR, pBstrDocString: [*c]BSTR, pdwHelpContext: [*c]DWORD, pBstrHelpFile: [*c]BSTR) HRESULT;
pub extern fn ITypeLib_GetDocumentation_Stub(This: [*c]ITypeLib, index: INT, refPtrFlags: DWORD, pBstrName: [*c]BSTR, pBstrDocString: [*c]BSTR, pdwHelpContext: [*c]DWORD, pBstrHelpFile: [*c]BSTR) HRESULT;
pub extern fn ITypeLib_IsName_Proxy(This: [*c]ITypeLib, szNameBuf: LPOLESTR, lHashVal: ULONG, pfName: [*c]BOOL) HRESULT;
pub extern fn ITypeLib_IsName_Stub(This: [*c]ITypeLib, szNameBuf: LPOLESTR, lHashVal: ULONG, pfName: [*c]BOOL, pBstrLibName: [*c]BSTR) HRESULT;
pub extern fn ITypeLib_FindName_Proxy(This: [*c]ITypeLib, szNameBuf: LPOLESTR, lHashVal: ULONG, ppTInfo: [*c]([*c]ITypeInfo), rgMemId: [*c]MEMBERID, pcFound: [*c]USHORT) HRESULT;
pub extern fn ITypeLib_FindName_Stub(This: [*c]ITypeLib, szNameBuf: LPOLESTR, lHashVal: ULONG, ppTInfo: [*c]([*c]ITypeInfo), rgMemId: [*c]MEMBERID, pcFound: [*c]USHORT, pBstrLibName: [*c]BSTR) HRESULT;
pub extern fn ITypeLib_ReleaseTLibAttr_Proxy(This: [*c]ITypeLib, pTLibAttr: [*c]TLIBATTR) void;
pub extern fn ITypeLib_ReleaseTLibAttr_Stub(This: [*c]ITypeLib) HRESULT;
pub extern fn ITypeLib2_GetLibStatistics_Proxy(This: [*c]ITypeLib2, pcUniqueNames: [*c]ULONG, pcchUniqueNames: [*c]ULONG) HRESULT;
pub extern fn ITypeLib2_GetLibStatistics_Stub(This: [*c]ITypeLib2, pcUniqueNames: [*c]ULONG, pcchUniqueNames: [*c]ULONG) HRESULT;
pub extern fn ITypeLib2_GetDocumentation2_Proxy(This: [*c]ITypeLib2, index: INT, lcid: LCID, pbstrHelpString: [*c]BSTR, pdwHelpStringContext: [*c]DWORD, pbstrHelpStringDll: [*c]BSTR) HRESULT;
pub extern fn ITypeLib2_GetDocumentation2_Stub(This: [*c]ITypeLib2, index: INT, lcid: LCID, refPtrFlags: DWORD, pbstrHelpString: [*c]BSTR, pdwHelpStringContext: [*c]DWORD, pbstrHelpStringDll: [*c]BSTR) HRESULT;
pub extern fn IPropertyBag_Read_Proxy(This: [*c]IPropertyBag, pszPropName: LPCOLESTR, pVar: [*c]VARIANT, pErrorLog: [*c]IErrorLog) HRESULT;
pub extern fn IPropertyBag_Read_Stub(This: [*c]IPropertyBag, pszPropName: LPCOLESTR, pVar: [*c]VARIANT, pErrorLog: [*c]IErrorLog, varType: DWORD, pUnkObj: [*c]IUnknown) HRESULT;
pub const VERSIONEDSTREAM = struct_tagVersionedStream;
pub const LPPROPVARIANT = [*c]struct_tagPROPVARIANT;
pub extern var __MIDL_itf_propidlbase_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_propidlbase_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IPropertyStorage: IID;
pub const IPropertyStorageVtbl = struct_IPropertyStorageVtbl;
pub const LPPROPERTYSETSTORAGE = [*c]IPropertySetStorage;
pub extern const IID_IPropertySetStorage: IID;
pub const IPropertySetStorageVtbl = struct_IPropertySetStorageVtbl;
pub const LPENUMSTATPROPSTG = [*c]IEnumSTATPROPSTG;
pub extern const IID_IEnumSTATPROPSTG: IID;
pub const IEnumSTATPROPSTGVtbl = struct_IEnumSTATPROPSTGVtbl;
pub extern fn IEnumSTATPROPSTG_RemoteNext_Proxy(This: [*c]IEnumSTATPROPSTG, celt: ULONG, rgelt: [*c]STATPROPSTG, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumSTATPROPSTG_RemoteNext_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub const LPENUMSTATPROPSETSTG = [*c]IEnumSTATPROPSETSTG;
pub extern const IID_IEnumSTATPROPSETSTG: IID;
pub const IEnumSTATPROPSETSTGVtbl = struct_IEnumSTATPROPSETSTGVtbl;
pub extern fn IEnumSTATPROPSETSTG_RemoteNext_Proxy(This: [*c]IEnumSTATPROPSETSTG, celt: ULONG, rgelt: [*c]STATPROPSETSTG, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumSTATPROPSETSTG_RemoteNext_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub const LPPROPERTYSTORAGE = [*c]IPropertyStorage;
pub extern var __MIDL_itf_propidlbase_0000_0004_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_propidlbase_0000_0004_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern fn LPSAFEARRAY_UserSize(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]LPSAFEARRAY) c_ulong;
pub extern fn LPSAFEARRAY_UserMarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]LPSAFEARRAY) [*c]u8;
pub extern fn LPSAFEARRAY_UserUnmarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]LPSAFEARRAY) [*c]u8;
pub extern fn LPSAFEARRAY_UserFree(arg0: [*c]c_ulong, arg1: [*c]LPSAFEARRAY) void;
pub extern fn LPSAFEARRAY_UserSize64(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]LPSAFEARRAY) c_ulong;
pub extern fn LPSAFEARRAY_UserMarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]LPSAFEARRAY) [*c]u8;
pub extern fn LPSAFEARRAY_UserUnmarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]LPSAFEARRAY) [*c]u8;
pub extern fn LPSAFEARRAY_UserFree64(arg0: [*c]c_ulong, arg1: [*c]LPSAFEARRAY) void;
pub extern fn IEnumSTATPROPSTG_Next_Proxy(This: [*c]IEnumSTATPROPSTG, celt: ULONG, rgelt: [*c]STATPROPSTG, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumSTATPROPSTG_Next_Stub(This: [*c]IEnumSTATPROPSTG, celt: ULONG, rgelt: [*c]STATPROPSTG, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumSTATPROPSETSTG_Next_Proxy(This: [*c]IEnumSTATPROPSETSTG, celt: ULONG, rgelt: [*c]STATPROPSETSTG, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumSTATPROPSETSTG_Next_Stub(This: [*c]IEnumSTATPROPSETSTG, celt: ULONG, rgelt: [*c]STATPROPSETSTG, pceltFetched: [*c]ULONG) HRESULT;
pub const STGFMT = DWORD;
pub extern "ole32" fn StgCreateDocfile(pwcsName: [*c]const WCHAR, grfMode: DWORD, reserved: DWORD, ppstgOpen: [*c]([*c]IStorage)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn StgCreateDocfileOnILockBytes(plkbyt: [*c]ILockBytes, grfMode: DWORD, reserved: DWORD, ppstgOpen: [*c]([*c]IStorage)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn StgOpenStorage(pwcsName: [*c]const WCHAR, pstgPriority: [*c]IStorage, grfMode: DWORD, snbExclude: SNB, reserved: DWORD, ppstgOpen: [*c]([*c]IStorage)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn StgOpenStorageOnILockBytes(plkbyt: [*c]ILockBytes, pstgPriority: [*c]IStorage, grfMode: DWORD, snbExclude: SNB, reserved: DWORD, ppstgOpen: [*c]([*c]IStorage)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn StgIsStorageFile(pwcsName: [*c]const WCHAR) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn StgIsStorageILockBytes(plkbyt: [*c]ILockBytes) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn StgSetTimes(lpszName: [*c]const WCHAR, pctime: [*c]const FILETIME, patime: [*c]const FILETIME, pmtime: [*c]const FILETIME) callconv(.Stdcall) HRESULT;
pub const struct_tagSTGOPTIONS = extern struct {
    usVersion: USHORT,
    reserved: USHORT,
    ulSectorSize: ULONG,
    pwcsTemplateFile: [*c]const WCHAR,
};
pub const STGOPTIONS = struct_tagSTGOPTIONS;
pub extern "ole32" fn StgCreateStorageEx(pwcsName: [*c]const WCHAR, grfMode: DWORD, stgfmt: DWORD, grfAttrs: DWORD, pStgOptions: [*c]STGOPTIONS, pSecurityDescriptor: PSECURITY_DESCRIPTOR, riid: [*c]const IID, ppObjectOpen: [*c](?*c_void)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn StgOpenStorageEx(pwcsName: [*c]const WCHAR, grfMode: DWORD, stgfmt: DWORD, grfAttrs: DWORD, pStgOptions: [*c]STGOPTIONS, pSecurityDescriptor: PSECURITY_DESCRIPTOR, riid: [*c]const IID, ppObjectOpen: [*c](?*c_void)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn StgCreatePropStg(pUnk: [*c]IUnknown, fmtid: [*c]const IID, pclsid: [*c]const CLSID, grfFlags: DWORD, dwReserved: DWORD, ppPropStg: [*c]([*c]IPropertyStorage)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn StgOpenPropStg(pUnk: [*c]IUnknown, fmtid: [*c]const IID, grfFlags: DWORD, dwReserved: DWORD, ppPropStg: [*c]([*c]IPropertyStorage)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn StgCreatePropSetStg(pStorage: [*c]IStorage, dwReserved: DWORD, ppPropSetStg: [*c]([*c]IPropertySetStorage)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn FmtIdToPropStgName(pfmtid: [*c]const FMTID, oszName: LPOLESTR) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn PropStgNameToFmtId(oszName: LPOLESTR, pfmtid: [*c]FMTID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn ReadClassStg(pStg: LPSTORAGE, pclsid: [*c]CLSID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn WriteClassStg(pStg: LPSTORAGE, rclsid: [*c]const IID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn ReadClassStm(pStm: LPSTREAM, pclsid: [*c]CLSID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn WriteClassStm(pStm: LPSTREAM, rclsid: [*c]const IID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn GetHGlobalFromILockBytes(plkbyt: LPLOCKBYTES, phglobal: [*c]HGLOBAL) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CreateILockBytesOnHGlobal(hGlobal: HGLOBAL, fDeleteOnRelease: BOOL, pplkbyt: [*c]LPLOCKBYTES) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn GetConvertStg(pStg: LPSTORAGE) callconv(.Stdcall) HRESULT;
pub const COINIT_APARTMENTTHREADED = enum_tagCOINIT.COINIT_APARTMENTTHREADED;
pub const COINIT_MULTITHREADED = enum_tagCOINIT.COINIT_MULTITHREADED;
pub const COINIT_DISABLE_OLE1DDE = enum_tagCOINIT.COINIT_DISABLE_OLE1DDE;
pub const COINIT_SPEED_OVER_MEMORY = enum_tagCOINIT.COINIT_SPEED_OVER_MEMORY;
pub const enum_tagCOINIT = extern enum {
    COINIT_APARTMENTTHREADED = 2,
    COINIT_MULTITHREADED = 0,
    COINIT_DISABLE_OLE1DDE = 4,
    COINIT_SPEED_OVER_MEMORY = 8,
};
pub const COINIT = enum_tagCOINIT;
pub extern "ole32" fn CoBuildVersion() callconv(.Stdcall) DWORD;
pub extern "ole32" fn CoInitialize(pvReserved: LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoRegisterMallocSpy(pMallocSpy: LPMALLOCSPY) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoRevokeMallocSpy() callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoCreateStandardMalloc(memctx: DWORD, ppMalloc: [*c]([*c]IMalloc)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoRegisterInitializeSpy(pSpy: [*c]IInitializeSpy, puliCookie: [*c]ULARGE_INTEGER) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoRevokeInitializeSpy(uliCookie: ULARGE_INTEGER) callconv(.Stdcall) HRESULT;
pub const SD_LAUNCHPERMISSIONS = enum_tagCOMSD.SD_LAUNCHPERMISSIONS;
pub const SD_ACCESSPERMISSIONS = enum_tagCOMSD.SD_ACCESSPERMISSIONS;
pub const SD_LAUNCHRESTRICTIONS = enum_tagCOMSD.SD_LAUNCHRESTRICTIONS;
pub const SD_ACCESSRESTRICTIONS = enum_tagCOMSD.SD_ACCESSRESTRICTIONS;
pub const enum_tagCOMSD = extern enum {
    SD_LAUNCHPERMISSIONS = 0,
    SD_ACCESSPERMISSIONS = 1,
    SD_LAUNCHRESTRICTIONS = 2,
    SD_ACCESSRESTRICTIONS = 3,
};
pub const COMSD = enum_tagCOMSD;
pub extern "ole32" fn CoGetSystemSecurityPermissions(comSDType: COMSD, ppSD: [*c]PSECURITY_DESCRIPTOR) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoLoadLibrary(lpszLibName: LPOLESTR, bAutoFree: BOOL) callconv(.Stdcall) HINSTANCE;
pub extern "ole32" fn CoFreeLibrary(hInst: HINSTANCE) callconv(.Stdcall) void;
pub extern "ole32" fn CoFreeAllLibraries() callconv(.Stdcall) void;
pub extern "ole32" fn CoGetInstanceFromFile(pServerInfo: [*c]COSERVERINFO, pClsid: [*c]CLSID, punkOuter: [*c]IUnknown, dwClsCtx: DWORD, grfMode: DWORD, pwszName: [*c]OLECHAR, dwCount: DWORD, pResults: [*c]MULTI_QI) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoGetInstanceFromIStorage(pServerInfo: [*c]COSERVERINFO, pClsid: [*c]CLSID, punkOuter: [*c]IUnknown, dwClsCtx: DWORD, pstg: [*c]struct_IStorage, dwCount: DWORD, pResults: [*c]MULTI_QI) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoAllowSetForegroundWindow(pUnk: [*c]IUnknown, lpvReserved: LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn DcomChannelSetHResult(pvReserved: LPVOID, pulReserved: [*c]ULONG, appsHR: HRESULT) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoIsOle1Class(rclsid: [*c]const IID) callconv(.Stdcall) BOOL;
pub extern "ole32" fn CoFileTimeToDosDateTime(lpFileTime: [*c]FILETIME, lpDosDate: LPWORD, lpDosTime: LPWORD) callconv(.Stdcall) BOOL;
pub extern "ole32" fn CoDosDateTimeToFileTime(nDosDate: WORD, nDosTime: WORD, lpFileTime: [*c]FILETIME) callconv(.Stdcall) BOOL;
pub extern "ole32" fn CoRegisterMessageFilter(lpMessageFilter: LPMESSAGEFILTER, lplpMessageFilter: [*c]LPMESSAGEFILTER) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoRegisterChannelHook(ExtensionUuid: [*c]const GUID, pChannelHook: [*c]IChannelHook) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoTreatAsClass(clsidOld: [*c]const IID, clsidNew: [*c]const IID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CreateDataAdviseHolder(ppDAHolder: [*c]LPDATAADVISEHOLDER) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CreateDataCache(pUnkOuter: LPUNKNOWN, rclsid: [*c]const IID, iid: [*c]const IID, ppv: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn StgOpenAsyncDocfileOnIFillLockBytes(pflb: [*c]IFillLockBytes, grfMode: DWORD, asyncFlags: DWORD, ppstgOpen: [*c]([*c]IStorage)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn StgGetIFillLockBytesOnILockBytes(pilb: [*c]ILockBytes, ppflb: [*c]([*c]IFillLockBytes)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn StgGetIFillLockBytesOnFile(pwcsName: [*c]const OLECHAR, ppflb: [*c]([*c]IFillLockBytes)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn StgOpenLayoutDocfile(pwcsDfName: [*c]const OLECHAR, grfMode: DWORD, reserved: DWORD, ppstgOpen: [*c]([*c]IStorage)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoInstall(pbc: [*c]IBindCtx, dwFlags: DWORD, pClassSpec: [*c]uCLSSPEC, pQuery: [*c]QUERYCONTEXT, pszCodeBase: LPWSTR) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn BindMoniker(pmk: LPMONIKER, grfOpt: DWORD, iidResult: [*c]const IID, ppvResult: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CoGetObject(pszName: LPCWSTR, pBindOptions: [*c]BIND_OPTS, riid: [*c]const IID, ppv: [*c](?*c_void)) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn MkParseDisplayName(pbc: LPBC, szUserName: LPCOLESTR, pchEaten: [*c]ULONG, ppmk: [*c]LPMONIKER) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn MonikerRelativePathTo(pmkSrc: LPMONIKER, pmkDest: LPMONIKER, ppmkRelPath: [*c]LPMONIKER, dwReserved: BOOL) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn MonikerCommonPrefixWith(pmkThis: LPMONIKER, pmkOther: LPMONIKER, ppmkCommon: [*c]LPMONIKER) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CreateBindCtx(reserved: DWORD, ppbc: [*c]LPBC) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CreateGenericComposite(pmkFirst: LPMONIKER, pmkRest: LPMONIKER, ppmkComposite: [*c]LPMONIKER) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn GetClassFile(szFilename: LPCOLESTR, pclsid: [*c]CLSID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CreateClassMoniker(rclsid: [*c]const IID, ppmk: [*c]LPMONIKER) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CreateFileMoniker(lpszPathName: LPCOLESTR, ppmk: [*c]LPMONIKER) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CreateItemMoniker(lpszDelim: LPCOLESTR, lpszItem: LPCOLESTR, ppmk: [*c]LPMONIKER) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CreateAntiMoniker(ppmk: [*c]LPMONIKER) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CreatePointerMoniker(punk: LPUNKNOWN, ppmk: [*c]LPMONIKER) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn CreateObjrefMoniker(punk: LPUNKNOWN, ppmk: [*c]LPMONIKER) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn GetRunningObjectTable(reserved: DWORD, pprot: [*c]LPRUNNINGOBJECTTABLE) callconv(.Stdcall) HRESULT;
pub const IPersistMoniker = struct_IPersistMoniker;
pub const struct_IPersistMonikerVtbl = extern struct {
    QueryInterface: ?fn ([*c]IPersistMoniker, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IPersistMoniker) callconv(.C) ULONG,
    Release: ?fn ([*c]IPersistMoniker) callconv(.C) ULONG,
    GetClassID: ?fn ([*c]IPersistMoniker, [*c]CLSID) callconv(.C) HRESULT,
    IsDirty: ?fn ([*c]IPersistMoniker) callconv(.C) HRESULT,
    Load: ?fn ([*c]IPersistMoniker, BOOL, [*c]IMoniker, LPBC, DWORD) callconv(.C) HRESULT,
    Save: ?fn ([*c]IPersistMoniker, [*c]IMoniker, LPBC, BOOL) callconv(.C) HRESULT,
    SaveCompleted: ?fn ([*c]IPersistMoniker, [*c]IMoniker, LPBC) callconv(.C) HRESULT,
    GetCurMoniker: ?fn ([*c]IPersistMoniker, [*c]([*c]IMoniker)) callconv(.C) HRESULT,
};
pub const struct_IPersistMoniker = extern struct {
    lpVtbl: [*c]struct_IPersistMonikerVtbl,
};
pub const IMonikerProp = struct_IMonikerProp;
pub const MIMETYPEPROP = enum___MIDL_IMonikerProp_0001.MIMETYPEPROP;
pub const USE_SRC_URL = enum___MIDL_IMonikerProp_0001.USE_SRC_URL;
pub const CLASSIDPROP = enum___MIDL_IMonikerProp_0001.CLASSIDPROP;
pub const TRUSTEDDOWNLOADPROP = enum___MIDL_IMonikerProp_0001.TRUSTEDDOWNLOADPROP;
pub const POPUPLEVELPROP = enum___MIDL_IMonikerProp_0001.POPUPLEVELPROP;
pub const enum___MIDL_IMonikerProp_0001 = extern enum {
    MIMETYPEPROP = 0,
    USE_SRC_URL = 1,
    CLASSIDPROP = 2,
    TRUSTEDDOWNLOADPROP = 3,
    POPUPLEVELPROP = 4,
};
pub const MONIKERPROPERTY = extern enum {
    MIMETYPEPROP = 0,
    USE_SRC_URL = 1,
    CLASSIDPROP = 2,
    TRUSTEDDOWNLOADPROP = 3,
    POPUPLEVELPROP = 4,
};
pub const struct_IMonikerPropVtbl = extern struct {
    QueryInterface: ?fn ([*c]IMonikerProp, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IMonikerProp) callconv(.C) ULONG,
    Release: ?fn ([*c]IMonikerProp) callconv(.C) ULONG,
    PutProperty: ?fn ([*c]IMonikerProp, MONIKERPROPERTY, LPCWSTR) callconv(.C) HRESULT,
};
pub const struct_IMonikerProp = extern struct {
    lpVtbl: [*c]struct_IMonikerPropVtbl,
};
pub const IBindProtocol = struct_IBindProtocol;
pub const struct_IBindingVtbl = extern struct {
    QueryInterface: ?fn ([*c]IBinding, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IBinding) callconv(.C) ULONG,
    Release: ?fn ([*c]IBinding) callconv(.C) ULONG,
    Abort: ?fn ([*c]IBinding) callconv(.C) HRESULT,
    Suspend: ?fn ([*c]IBinding) callconv(.C) HRESULT,
    Resume: ?fn ([*c]IBinding) callconv(.C) HRESULT,
    SetPriority: ?fn ([*c]IBinding, LONG) callconv(.C) HRESULT,
    GetPriority: ?fn ([*c]IBinding, [*c]LONG) callconv(.C) HRESULT,
    GetBindResult: ?fn ([*c]IBinding, [*c]CLSID, [*c]DWORD, [*c]LPOLESTR, [*c]DWORD) callconv(.C) HRESULT,
};
pub const struct_IBinding = extern struct {
    lpVtbl: [*c]struct_IBindingVtbl,
};
pub const IBinding = struct_IBinding;
pub const struct_IBindProtocolVtbl = extern struct {
    QueryInterface: ?fn ([*c]IBindProtocol, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IBindProtocol) callconv(.C) ULONG,
    Release: ?fn ([*c]IBindProtocol) callconv(.C) ULONG,
    CreateBinding: ?fn ([*c]IBindProtocol, LPCWSTR, [*c]IBindCtx, [*c]([*c]IBinding)) callconv(.C) HRESULT,
};
pub const struct_IBindProtocol = extern struct {
    lpVtbl: [*c]struct_IBindProtocolVtbl,
};
pub const IBindStatusCallback = struct_IBindStatusCallback;
pub const struct__tagBINDINFO = extern struct {
    cbSize: ULONG,
    szExtraInfo: LPWSTR,
    stgmedData: STGMEDIUM,
    grfBindInfoF: DWORD,
    dwBindVerb: DWORD,
    szCustomVerb: LPWSTR,
    cbstgmedData: DWORD,
    dwOptions: DWORD,
    dwOptionsFlags: DWORD,
    dwCodePage: DWORD,
    securityAttributes: SECURITY_ATTRIBUTES,
    iid: IID,
    pUnk: [*c]IUnknown,
    dwReserved: DWORD,
};
pub const BINDINFO = struct__tagBINDINFO;
pub const struct_IBindStatusCallbackVtbl = extern struct {
    QueryInterface: ?fn ([*c]IBindStatusCallback, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IBindStatusCallback) callconv(.C) ULONG,
    Release: ?fn ([*c]IBindStatusCallback) callconv(.C) ULONG,
    OnStartBinding: ?fn ([*c]IBindStatusCallback, DWORD, [*c]IBinding) callconv(.C) HRESULT,
    GetPriority: ?fn ([*c]IBindStatusCallback, [*c]LONG) callconv(.C) HRESULT,
    OnLowResource: ?fn ([*c]IBindStatusCallback, DWORD) callconv(.C) HRESULT,
    OnProgress: ?fn ([*c]IBindStatusCallback, ULONG, ULONG, ULONG, LPCWSTR) callconv(.C) HRESULT,
    OnStopBinding: ?fn ([*c]IBindStatusCallback, HRESULT, LPCWSTR) callconv(.C) HRESULT,
    GetBindInfo: ?fn ([*c]IBindStatusCallback, [*c]DWORD, [*c]BINDINFO) callconv(.C) HRESULT,
    OnDataAvailable: ?fn ([*c]IBindStatusCallback, DWORD, DWORD, [*c]FORMATETC, [*c]STGMEDIUM) callconv(.C) HRESULT,
    OnObjectAvailable: ?fn ([*c]IBindStatusCallback, [*c]const IID, [*c]IUnknown) callconv(.C) HRESULT,
};
pub const struct_IBindStatusCallback = extern struct {
    lpVtbl: [*c]struct_IBindStatusCallbackVtbl,
};
pub const IBindStatusCallbackEx = struct_IBindStatusCallbackEx;
pub const struct_IBindStatusCallbackExVtbl = extern struct {
    QueryInterface: ?fn ([*c]IBindStatusCallbackEx, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IBindStatusCallbackEx) callconv(.C) ULONG,
    Release: ?fn ([*c]IBindStatusCallbackEx) callconv(.C) ULONG,
    OnStartBinding: ?fn ([*c]IBindStatusCallbackEx, DWORD, [*c]IBinding) callconv(.C) HRESULT,
    GetPriority: ?fn ([*c]IBindStatusCallbackEx, [*c]LONG) callconv(.C) HRESULT,
    OnLowResource: ?fn ([*c]IBindStatusCallbackEx, DWORD) callconv(.C) HRESULT,
    OnProgress: ?fn ([*c]IBindStatusCallbackEx, ULONG, ULONG, ULONG, LPCWSTR) callconv(.C) HRESULT,
    OnStopBinding: ?fn ([*c]IBindStatusCallbackEx, HRESULT, LPCWSTR) callconv(.C) HRESULT,
    GetBindInfo: ?fn ([*c]IBindStatusCallbackEx, [*c]DWORD, [*c]BINDINFO) callconv(.C) HRESULT,
    OnDataAvailable: ?fn ([*c]IBindStatusCallbackEx, DWORD, DWORD, [*c]FORMATETC, [*c]STGMEDIUM) callconv(.C) HRESULT,
    OnObjectAvailable: ?fn ([*c]IBindStatusCallbackEx, [*c]const IID, [*c]IUnknown) callconv(.C) HRESULT,
    GetBindInfoEx: ?fn ([*c]IBindStatusCallbackEx, [*c]DWORD, [*c]BINDINFO, [*c]DWORD, [*c]DWORD) callconv(.C) HRESULT,
};
pub const struct_IBindStatusCallbackEx = extern struct {
    lpVtbl: [*c]struct_IBindStatusCallbackExVtbl,
};
pub const IAuthenticate = struct_IAuthenticate;
pub const struct_IAuthenticateVtbl = extern struct {
    QueryInterface: ?fn ([*c]IAuthenticate, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IAuthenticate) callconv(.C) ULONG,
    Release: ?fn ([*c]IAuthenticate) callconv(.C) ULONG,
    Authenticate: ?fn ([*c]IAuthenticate, [*c]HWND, [*c]LPWSTR, [*c]LPWSTR) callconv(.C) HRESULT,
};
pub const struct_IAuthenticate = extern struct {
    lpVtbl: [*c]struct_IAuthenticateVtbl,
};
pub const IAuthenticateEx = struct_IAuthenticateEx;
pub const struct__tagAUTHENTICATEINFO = extern struct {
    dwFlags: DWORD,
    dwReserved: DWORD,
};
pub const AUTHENTICATEINFO = struct__tagAUTHENTICATEINFO;
pub const struct_IAuthenticateExVtbl = extern struct {
    QueryInterface: ?fn ([*c]IAuthenticateEx, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IAuthenticateEx) callconv(.C) ULONG,
    Release: ?fn ([*c]IAuthenticateEx) callconv(.C) ULONG,
    Authenticate: ?fn ([*c]IAuthenticateEx, [*c]HWND, [*c]LPWSTR, [*c]LPWSTR) callconv(.C) HRESULT,
    AuthenticateEx: ?fn ([*c]IAuthenticateEx, [*c]HWND, [*c]LPWSTR, [*c]LPWSTR, [*c]AUTHENTICATEINFO) callconv(.C) HRESULT,
};
pub const struct_IAuthenticateEx = extern struct {
    lpVtbl: [*c]struct_IAuthenticateExVtbl,
};
pub const IHttpNegotiate = struct_IHttpNegotiate;
pub const struct_IHttpNegotiateVtbl = extern struct {
    QueryInterface: ?fn ([*c]IHttpNegotiate, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IHttpNegotiate) callconv(.C) ULONG,
    Release: ?fn ([*c]IHttpNegotiate) callconv(.C) ULONG,
    BeginningTransaction: ?fn ([*c]IHttpNegotiate, LPCWSTR, LPCWSTR, DWORD, [*c]LPWSTR) callconv(.C) HRESULT,
    OnResponse: ?fn ([*c]IHttpNegotiate, DWORD, LPCWSTR, LPCWSTR, [*c]LPWSTR) callconv(.C) HRESULT,
};
pub const struct_IHttpNegotiate = extern struct {
    lpVtbl: [*c]struct_IHttpNegotiateVtbl,
};
pub const IHttpNegotiate2 = struct_IHttpNegotiate2;
pub const struct_IHttpNegotiate2Vtbl = extern struct {
    QueryInterface: ?fn ([*c]IHttpNegotiate2, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IHttpNegotiate2) callconv(.C) ULONG,
    Release: ?fn ([*c]IHttpNegotiate2) callconv(.C) ULONG,
    BeginningTransaction: ?fn ([*c]IHttpNegotiate2, LPCWSTR, LPCWSTR, DWORD, [*c]LPWSTR) callconv(.C) HRESULT,
    OnResponse: ?fn ([*c]IHttpNegotiate2, DWORD, LPCWSTR, LPCWSTR, [*c]LPWSTR) callconv(.C) HRESULT,
    GetRootSecurityId: ?fn ([*c]IHttpNegotiate2, [*c]BYTE, [*c]DWORD, DWORD_PTR) callconv(.C) HRESULT,
};
pub const struct_IHttpNegotiate2 = extern struct {
    lpVtbl: [*c]struct_IHttpNegotiate2Vtbl,
};
pub const IHttpNegotiate3 = struct_IHttpNegotiate3;
pub const struct_IHttpNegotiate3Vtbl = extern struct {
    QueryInterface: ?fn ([*c]IHttpNegotiate3, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IHttpNegotiate3) callconv(.C) ULONG,
    Release: ?fn ([*c]IHttpNegotiate3) callconv(.C) ULONG,
    BeginningTransaction: ?fn ([*c]IHttpNegotiate3, LPCWSTR, LPCWSTR, DWORD, [*c]LPWSTR) callconv(.C) HRESULT,
    OnResponse: ?fn ([*c]IHttpNegotiate3, DWORD, LPCWSTR, LPCWSTR, [*c]LPWSTR) callconv(.C) HRESULT,
    GetRootSecurityId: ?fn ([*c]IHttpNegotiate3, [*c]BYTE, [*c]DWORD, DWORD_PTR) callconv(.C) HRESULT,
    GetSerializedClientCertContext: ?fn ([*c]IHttpNegotiate3, [*c]([*c]BYTE), [*c]DWORD) callconv(.C) HRESULT,
};
pub const struct_IHttpNegotiate3 = extern struct {
    lpVtbl: [*c]struct_IHttpNegotiate3Vtbl,
};
pub const IWinInetFileStream = struct_IWinInetFileStream;
pub const struct_IWinInetFileStreamVtbl = extern struct {
    QueryInterface: ?fn ([*c]IWinInetFileStream, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IWinInetFileStream) callconv(.C) ULONG,
    Release: ?fn ([*c]IWinInetFileStream) callconv(.C) ULONG,
    SetHandleForUnlock: ?fn ([*c]IWinInetFileStream, DWORD_PTR, DWORD_PTR) callconv(.C) HRESULT,
    SetDeleteFile: ?fn ([*c]IWinInetFileStream, DWORD_PTR) callconv(.C) HRESULT,
};
pub const struct_IWinInetFileStream = extern struct {
    lpVtbl: [*c]struct_IWinInetFileStreamVtbl,
};
pub const IWindowForBindingUI = struct_IWindowForBindingUI;
pub const struct_IWindowForBindingUIVtbl = extern struct {
    QueryInterface: ?fn ([*c]IWindowForBindingUI, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IWindowForBindingUI) callconv(.C) ULONG,
    Release: ?fn ([*c]IWindowForBindingUI) callconv(.C) ULONG,
    GetWindow: ?fn ([*c]IWindowForBindingUI, [*c]const GUID, [*c]HWND) callconv(.C) HRESULT,
};
pub const struct_IWindowForBindingUI = extern struct {
    lpVtbl: [*c]struct_IWindowForBindingUIVtbl,
};
pub const ICodeInstall = struct_ICodeInstall;
pub const struct_ICodeInstallVtbl = extern struct {
    QueryInterface: ?fn ([*c]ICodeInstall, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ICodeInstall) callconv(.C) ULONG,
    Release: ?fn ([*c]ICodeInstall) callconv(.C) ULONG,
    GetWindow: ?fn ([*c]ICodeInstall, [*c]const GUID, [*c]HWND) callconv(.C) HRESULT,
    OnCodeInstallProblem: ?fn ([*c]ICodeInstall, ULONG, LPCWSTR, LPCWSTR, DWORD) callconv(.C) HRESULT,
};
pub const struct_ICodeInstall = extern struct {
    lpVtbl: [*c]struct_ICodeInstallVtbl,
};
pub const IUri = struct_IUri;
pub const Uri_PROPERTY_ABSOLUTE_URI = enum___MIDL_IUri_0001.Uri_PROPERTY_ABSOLUTE_URI;
pub const Uri_PROPERTY_STRING_START = enum___MIDL_IUri_0001.Uri_PROPERTY_STRING_START;
pub const Uri_PROPERTY_AUTHORITY = enum___MIDL_IUri_0001.Uri_PROPERTY_AUTHORITY;
pub const Uri_PROPERTY_DISPLAY_URI = enum___MIDL_IUri_0001.Uri_PROPERTY_DISPLAY_URI;
pub const Uri_PROPERTY_DOMAIN = enum___MIDL_IUri_0001.Uri_PROPERTY_DOMAIN;
pub const Uri_PROPERTY_EXTENSION = enum___MIDL_IUri_0001.Uri_PROPERTY_EXTENSION;
pub const Uri_PROPERTY_FRAGMENT = enum___MIDL_IUri_0001.Uri_PROPERTY_FRAGMENT;
pub const Uri_PROPERTY_HOST = enum___MIDL_IUri_0001.Uri_PROPERTY_HOST;
pub const Uri_PROPERTY_PASSWORD = enum___MIDL_IUri_0001.Uri_PROPERTY_PASSWORD;
pub const Uri_PROPERTY_PATH = enum___MIDL_IUri_0001.Uri_PROPERTY_PATH;
pub const Uri_PROPERTY_PATH_AND_QUERY = enum___MIDL_IUri_0001.Uri_PROPERTY_PATH_AND_QUERY;
pub const Uri_PROPERTY_QUERY = enum___MIDL_IUri_0001.Uri_PROPERTY_QUERY;
pub const Uri_PROPERTY_RAW_URI = enum___MIDL_IUri_0001.Uri_PROPERTY_RAW_URI;
pub const Uri_PROPERTY_SCHEME_NAME = enum___MIDL_IUri_0001.Uri_PROPERTY_SCHEME_NAME;
pub const Uri_PROPERTY_USER_INFO = enum___MIDL_IUri_0001.Uri_PROPERTY_USER_INFO;
pub const Uri_PROPERTY_USER_NAME = enum___MIDL_IUri_0001.Uri_PROPERTY_USER_NAME;
pub const Uri_PROPERTY_STRING_LAST = enum___MIDL_IUri_0001.Uri_PROPERTY_STRING_LAST;
pub const Uri_PROPERTY_HOST_TYPE = enum___MIDL_IUri_0001.Uri_PROPERTY_HOST_TYPE;
pub const Uri_PROPERTY_DWORD_START = enum___MIDL_IUri_0001.Uri_PROPERTY_DWORD_START;
pub const Uri_PROPERTY_PORT = enum___MIDL_IUri_0001.Uri_PROPERTY_PORT;
pub const Uri_PROPERTY_SCHEME = enum___MIDL_IUri_0001.Uri_PROPERTY_SCHEME;
pub const Uri_PROPERTY_ZONE = enum___MIDL_IUri_0001.Uri_PROPERTY_ZONE;
pub const Uri_PROPERTY_DWORD_LAST = enum___MIDL_IUri_0001.Uri_PROPERTY_DWORD_LAST;
pub const enum___MIDL_IUri_0001 = extern enum {
    Uri_PROPERTY_ABSOLUTE_URI = 0,
    Uri_PROPERTY_STRING_START = 0,
    Uri_PROPERTY_AUTHORITY = 1,
    Uri_PROPERTY_DISPLAY_URI = 2,
    Uri_PROPERTY_DOMAIN = 3,
    Uri_PROPERTY_EXTENSION = 4,
    Uri_PROPERTY_FRAGMENT = 5,
    Uri_PROPERTY_HOST = 6,
    Uri_PROPERTY_PASSWORD = 7,
    Uri_PROPERTY_PATH = 8,
    Uri_PROPERTY_PATH_AND_QUERY = 9,
    Uri_PROPERTY_QUERY = 10,
    Uri_PROPERTY_RAW_URI = 11,
    Uri_PROPERTY_SCHEME_NAME = 12,
    Uri_PROPERTY_USER_INFO = 13,
    Uri_PROPERTY_USER_NAME = 14,
    Uri_PROPERTY_STRING_LAST = 14,
    Uri_PROPERTY_HOST_TYPE = 15,
    Uri_PROPERTY_DWORD_START = 15,
    Uri_PROPERTY_PORT = 16,
    Uri_PROPERTY_SCHEME = 17,
    Uri_PROPERTY_ZONE = 18,
    Uri_PROPERTY_DWORD_LAST = 18,
};
pub const Uri_PROPERTY = extern enum {
    Uri_PROPERTY_ABSOLUTE_URI = 0,
    Uri_PROPERTY_STRING_START = 0,
    Uri_PROPERTY_AUTHORITY = 1,
    Uri_PROPERTY_DISPLAY_URI = 2,
    Uri_PROPERTY_DOMAIN = 3,
    Uri_PROPERTY_EXTENSION = 4,
    Uri_PROPERTY_FRAGMENT = 5,
    Uri_PROPERTY_HOST = 6,
    Uri_PROPERTY_PASSWORD = 7,
    Uri_PROPERTY_PATH = 8,
    Uri_PROPERTY_PATH_AND_QUERY = 9,
    Uri_PROPERTY_QUERY = 10,
    Uri_PROPERTY_RAW_URI = 11,
    Uri_PROPERTY_SCHEME_NAME = 12,
    Uri_PROPERTY_USER_INFO = 13,
    Uri_PROPERTY_USER_NAME = 14,
    Uri_PROPERTY_STRING_LAST = 14,
    Uri_PROPERTY_HOST_TYPE = 15,
    Uri_PROPERTY_DWORD_START = 15,
    Uri_PROPERTY_PORT = 16,
    Uri_PROPERTY_SCHEME = 17,
    Uri_PROPERTY_ZONE = 18,
    Uri_PROPERTY_DWORD_LAST = 18,
};
pub const struct_IUriVtbl = extern struct {
    QueryInterface: ?fn ([*c]IUri, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IUri) callconv(.C) ULONG,
    Release: ?fn ([*c]IUri) callconv(.C) ULONG,
    GetPropertyBSTR: ?fn ([*c]IUri, Uri_PROPERTY, [*c]BSTR, DWORD) callconv(.C) HRESULT,
    GetPropertyLength: ?fn ([*c]IUri, Uri_PROPERTY, [*c]DWORD, DWORD) callconv(.C) HRESULT,
    GetPropertyDWORD: ?fn ([*c]IUri, Uri_PROPERTY, [*c]DWORD, DWORD) callconv(.C) HRESULT,
    HasProperty: ?fn ([*c]IUri, Uri_PROPERTY, [*c]BOOL) callconv(.C) HRESULT,
    GetAbsoluteUri: ?fn ([*c]IUri, [*c]BSTR) callconv(.C) HRESULT,
    GetAuthority: ?fn ([*c]IUri, [*c]BSTR) callconv(.C) HRESULT,
    GetDisplayUri: ?fn ([*c]IUri, [*c]BSTR) callconv(.C) HRESULT,
    GetDomain: ?fn ([*c]IUri, [*c]BSTR) callconv(.C) HRESULT,
    GetExtension: ?fn ([*c]IUri, [*c]BSTR) callconv(.C) HRESULT,
    GetFragment: ?fn ([*c]IUri, [*c]BSTR) callconv(.C) HRESULT,
    GetHost: ?fn ([*c]IUri, [*c]BSTR) callconv(.C) HRESULT,
    GetPassword: ?fn ([*c]IUri, [*c]BSTR) callconv(.C) HRESULT,
    GetPath: ?fn ([*c]IUri, [*c]BSTR) callconv(.C) HRESULT,
    GetPathAndQuery: ?fn ([*c]IUri, [*c]BSTR) callconv(.C) HRESULT,
    GetQuery: ?fn ([*c]IUri, [*c]BSTR) callconv(.C) HRESULT,
    GetRawUri: ?fn ([*c]IUri, [*c]BSTR) callconv(.C) HRESULT,
    GetSchemeName: ?fn ([*c]IUri, [*c]BSTR) callconv(.C) HRESULT,
    GetUserInfo: ?fn ([*c]IUri, [*c]BSTR) callconv(.C) HRESULT,
    GetUserNameA: ?fn ([*c]IUri, [*c]BSTR) callconv(.C) HRESULT,
    GetHostType: ?fn ([*c]IUri, [*c]DWORD) callconv(.C) HRESULT,
    GetPort: ?fn ([*c]IUri, [*c]DWORD) callconv(.C) HRESULT,
    GetScheme: ?fn ([*c]IUri, [*c]DWORD) callconv(.C) HRESULT,
    GetZone: ?fn ([*c]IUri, [*c]DWORD) callconv(.C) HRESULT,
    GetProperties: ?fn ([*c]IUri, LPDWORD) callconv(.C) HRESULT,
    IsEqual: ?fn ([*c]IUri, [*c]IUri, [*c]BOOL) callconv(.C) HRESULT,
};
pub const struct_IUri = extern struct {
    lpVtbl: [*c]struct_IUriVtbl,
};
pub const IUriContainer = struct_IUriContainer;
pub const struct_IUriContainerVtbl = extern struct {
    QueryInterface: ?fn ([*c]IUriContainer, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IUriContainer) callconv(.C) ULONG,
    Release: ?fn ([*c]IUriContainer) callconv(.C) ULONG,
    GetIUri: ?fn ([*c]IUriContainer, [*c]([*c]IUri)) callconv(.C) HRESULT,
};
pub const struct_IUriContainer = extern struct {
    lpVtbl: [*c]struct_IUriContainerVtbl,
};
pub const IUriBuilder = struct_IUriBuilder;
pub const struct_IUriBuilderVtbl = extern struct {
    QueryInterface: ?fn ([*c]IUriBuilder, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IUriBuilder) callconv(.C) ULONG,
    Release: ?fn ([*c]IUriBuilder) callconv(.C) ULONG,
    CreateUriSimple: ?fn ([*c]IUriBuilder, DWORD, DWORD_PTR, [*c]([*c]IUri)) callconv(.C) HRESULT,
    CreateUri: ?fn ([*c]IUriBuilder, DWORD, DWORD, DWORD_PTR, [*c]([*c]IUri)) callconv(.C) HRESULT,
    CreateUriWithFlags: ?fn ([*c]IUriBuilder, DWORD, DWORD, DWORD, DWORD_PTR, [*c]([*c]IUri)) callconv(.C) HRESULT,
    GetIUri: ?fn ([*c]IUriBuilder, [*c]([*c]IUri)) callconv(.C) HRESULT,
    SetIUri: ?fn ([*c]IUriBuilder, [*c]IUri) callconv(.C) HRESULT,
    GetFragment: ?fn ([*c]IUriBuilder, [*c]DWORD, [*c]LPCWSTR) callconv(.C) HRESULT,
    GetHost: ?fn ([*c]IUriBuilder, [*c]DWORD, [*c]LPCWSTR) callconv(.C) HRESULT,
    GetPassword: ?fn ([*c]IUriBuilder, [*c]DWORD, [*c]LPCWSTR) callconv(.C) HRESULT,
    GetPath: ?fn ([*c]IUriBuilder, [*c]DWORD, [*c]LPCWSTR) callconv(.C) HRESULT,
    GetPort: ?fn ([*c]IUriBuilder, [*c]BOOL, [*c]DWORD) callconv(.C) HRESULT,
    GetQuery: ?fn ([*c]IUriBuilder, [*c]DWORD, [*c]LPCWSTR) callconv(.C) HRESULT,
    GetSchemeName: ?fn ([*c]IUriBuilder, [*c]DWORD, [*c]LPCWSTR) callconv(.C) HRESULT,
    GetUserNameA: ?fn ([*c]IUriBuilder, [*c]DWORD, [*c]LPCWSTR) callconv(.C) HRESULT,
    SetFragment: ?fn ([*c]IUriBuilder, LPCWSTR) callconv(.C) HRESULT,
    SetHost: ?fn ([*c]IUriBuilder, LPCWSTR) callconv(.C) HRESULT,
    SetPassword: ?fn ([*c]IUriBuilder, LPCWSTR) callconv(.C) HRESULT,
    SetPath: ?fn ([*c]IUriBuilder, LPCWSTR) callconv(.C) HRESULT,
    SetPortA: ?fn ([*c]IUriBuilder, BOOL, DWORD) callconv(.C) HRESULT,
    SetQuery: ?fn ([*c]IUriBuilder, LPCWSTR) callconv(.C) HRESULT,
    SetSchemeName: ?fn ([*c]IUriBuilder, LPCWSTR) callconv(.C) HRESULT,
    SetUserName: ?fn ([*c]IUriBuilder, LPCWSTR) callconv(.C) HRESULT,
    RemoveProperties: ?fn ([*c]IUriBuilder, DWORD) callconv(.C) HRESULT,
    HasBeenModified: ?fn ([*c]IUriBuilder, [*c]BOOL) callconv(.C) HRESULT,
};
pub const struct_IUriBuilder = extern struct {
    lpVtbl: [*c]struct_IUriBuilderVtbl,
};
pub const IUriBuilderFactory = struct_IUriBuilderFactory;
pub const struct_IUriBuilderFactoryVtbl = extern struct {
    QueryInterface: ?fn ([*c]IUriBuilderFactory, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IUriBuilderFactory) callconv(.C) ULONG,
    Release: ?fn ([*c]IUriBuilderFactory) callconv(.C) ULONG,
    CreateIUriBuilder: ?fn ([*c]IUriBuilderFactory, DWORD, DWORD_PTR, [*c]([*c]IUriBuilder)) callconv(.C) HRESULT,
    CreateInitializedIUriBuilder: ?fn ([*c]IUriBuilderFactory, DWORD, DWORD_PTR, [*c]([*c]IUriBuilder)) callconv(.C) HRESULT,
};
pub const struct_IUriBuilderFactory = extern struct {
    lpVtbl: [*c]struct_IUriBuilderFactoryVtbl,
};
pub const IWinInetInfo = struct_IWinInetInfo;
pub const struct_IWinInetInfoVtbl = extern struct {
    QueryInterface: ?fn ([*c]IWinInetInfo, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IWinInetInfo) callconv(.C) ULONG,
    Release: ?fn ([*c]IWinInetInfo) callconv(.C) ULONG,
    QueryOption: ?fn ([*c]IWinInetInfo, DWORD, LPVOID, [*c]DWORD) callconv(.C) HRESULT,
};
pub const struct_IWinInetInfo = extern struct {
    lpVtbl: [*c]struct_IWinInetInfoVtbl,
};
pub const IHttpSecurity = struct_IHttpSecurity;
pub const struct_IHttpSecurityVtbl = extern struct {
    QueryInterface: ?fn ([*c]IHttpSecurity, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IHttpSecurity) callconv(.C) ULONG,
    Release: ?fn ([*c]IHttpSecurity) callconv(.C) ULONG,
    GetWindow: ?fn ([*c]IHttpSecurity, [*c]const GUID, [*c]HWND) callconv(.C) HRESULT,
    OnSecurityProblem: ?fn ([*c]IHttpSecurity, DWORD) callconv(.C) HRESULT,
};
pub const struct_IHttpSecurity = extern struct {
    lpVtbl: [*c]struct_IHttpSecurityVtbl,
};
pub const IWinInetHttpInfo = struct_IWinInetHttpInfo;
pub const struct_IWinInetHttpInfoVtbl = extern struct {
    QueryInterface: ?fn ([*c]IWinInetHttpInfo, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IWinInetHttpInfo) callconv(.C) ULONG,
    Release: ?fn ([*c]IWinInetHttpInfo) callconv(.C) ULONG,
    QueryOption: ?fn ([*c]IWinInetHttpInfo, DWORD, LPVOID, [*c]DWORD) callconv(.C) HRESULT,
    QueryInfo: ?fn ([*c]IWinInetHttpInfo, DWORD, LPVOID, [*c]DWORD, [*c]DWORD, [*c]DWORD) callconv(.C) HRESULT,
};
pub const struct_IWinInetHttpInfo = extern struct {
    lpVtbl: [*c]struct_IWinInetHttpInfoVtbl,
};
pub const IWinInetHttpTimeouts = struct_IWinInetHttpTimeouts;
pub const struct_IWinInetHttpTimeoutsVtbl = extern struct {
    QueryInterface: ?fn ([*c]IWinInetHttpTimeouts, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IWinInetHttpTimeouts) callconv(.C) ULONG,
    Release: ?fn ([*c]IWinInetHttpTimeouts) callconv(.C) ULONG,
    GetRequestTimeouts: ?fn ([*c]IWinInetHttpTimeouts, [*c]DWORD, [*c]DWORD, [*c]DWORD) callconv(.C) HRESULT,
};
pub const struct_IWinInetHttpTimeouts = extern struct {
    lpVtbl: [*c]struct_IWinInetHttpTimeoutsVtbl,
};
pub const IWinInetCacheHints = struct_IWinInetCacheHints;
pub const struct_IWinInetCacheHintsVtbl = extern struct {
    QueryInterface: ?fn ([*c]IWinInetCacheHints, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IWinInetCacheHints) callconv(.C) ULONG,
    Release: ?fn ([*c]IWinInetCacheHints) callconv(.C) ULONG,
    SetCacheExtension: ?fn ([*c]IWinInetCacheHints, LPCWSTR, LPVOID, [*c]DWORD, [*c]DWORD, [*c]DWORD) callconv(.C) HRESULT,
};
pub const struct_IWinInetCacheHints = extern struct {
    lpVtbl: [*c]struct_IWinInetCacheHintsVtbl,
};
pub const IWinInetCacheHints2 = struct_IWinInetCacheHints2;
pub const struct_IWinInetCacheHints2Vtbl = extern struct {
    QueryInterface: ?fn ([*c]IWinInetCacheHints2, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IWinInetCacheHints2) callconv(.C) ULONG,
    Release: ?fn ([*c]IWinInetCacheHints2) callconv(.C) ULONG,
    SetCacheExtension: ?fn ([*c]IWinInetCacheHints2, LPCWSTR, LPVOID, [*c]DWORD, [*c]DWORD, [*c]DWORD) callconv(.C) HRESULT,
    SetCacheExtension2: ?fn ([*c]IWinInetCacheHints2, LPCWSTR, [*c]WCHAR, [*c]DWORD, [*c]DWORD, [*c]DWORD) callconv(.C) HRESULT,
};
pub const struct_IWinInetCacheHints2 = extern struct {
    lpVtbl: [*c]struct_IWinInetCacheHints2Vtbl,
};
pub const IBindHost = struct_IBindHost;
pub const struct_IBindHostVtbl = extern struct {
    QueryInterface: ?fn ([*c]IBindHost, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IBindHost) callconv(.C) ULONG,
    Release: ?fn ([*c]IBindHost) callconv(.C) ULONG,
    CreateMoniker: ?fn ([*c]IBindHost, LPOLESTR, [*c]IBindCtx, [*c]([*c]IMoniker), DWORD) callconv(.C) HRESULT,
    MonikerBindToStorage: ?fn ([*c]IBindHost, [*c]IMoniker, [*c]IBindCtx, [*c]IBindStatusCallback, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    MonikerBindToObject: ?fn ([*c]IBindHost, [*c]IMoniker, [*c]IBindCtx, [*c]IBindStatusCallback, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
};
pub const struct_IBindHost = extern struct {
    lpVtbl: [*c]struct_IBindHostVtbl,
};
pub const IInternet = struct_IInternet;
pub const struct_IInternetVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternet, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternet) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternet) callconv(.C) ULONG,
};
pub const struct_IInternet = extern struct {
    lpVtbl: [*c]struct_IInternetVtbl,
};
pub const IInternetBindInfo = struct_IInternetBindInfo;
pub const struct_IInternetBindInfoVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetBindInfo, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetBindInfo) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetBindInfo) callconv(.C) ULONG,
    GetBindInfo: ?fn ([*c]IInternetBindInfo, [*c]DWORD, [*c]BINDINFO) callconv(.C) HRESULT,
    GetBindString: ?fn ([*c]IInternetBindInfo, ULONG, [*c]LPOLESTR, ULONG, [*c]ULONG) callconv(.C) HRESULT,
};
pub const struct_IInternetBindInfo = extern struct {
    lpVtbl: [*c]struct_IInternetBindInfoVtbl,
};
pub const IInternetBindInfoEx = struct_IInternetBindInfoEx;
pub const struct_IInternetBindInfoExVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetBindInfoEx, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetBindInfoEx) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetBindInfoEx) callconv(.C) ULONG,
    GetBindInfo: ?fn ([*c]IInternetBindInfoEx, [*c]DWORD, [*c]BINDINFO) callconv(.C) HRESULT,
    GetBindString: ?fn ([*c]IInternetBindInfoEx, ULONG, [*c]LPOLESTR, ULONG, [*c]ULONG) callconv(.C) HRESULT,
    GetBindInfoEx: ?fn ([*c]IInternetBindInfoEx, [*c]DWORD, [*c]BINDINFO, [*c]DWORD, [*c]DWORD) callconv(.C) HRESULT,
};
pub const struct_IInternetBindInfoEx = extern struct {
    lpVtbl: [*c]struct_IInternetBindInfoExVtbl,
};
pub const IInternetProtocolRoot = struct_IInternetProtocolRoot;
pub const struct__tagPROTOCOLDATA = extern struct {
    grfFlags: DWORD,
    dwState: DWORD,
    pData: LPVOID,
    cbData: ULONG,
};
pub const PROTOCOLDATA = struct__tagPROTOCOLDATA;
pub const struct_IInternetProtocolSinkVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetProtocolSink, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetProtocolSink) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetProtocolSink) callconv(.C) ULONG,
    Switch: ?fn ([*c]IInternetProtocolSink, [*c]PROTOCOLDATA) callconv(.C) HRESULT,
    ReportProgress: ?fn ([*c]IInternetProtocolSink, ULONG, LPCWSTR) callconv(.C) HRESULT,
    ReportData: ?fn ([*c]IInternetProtocolSink, DWORD, ULONG, ULONG) callconv(.C) HRESULT,
    ReportResult: ?fn ([*c]IInternetProtocolSink, HRESULT, DWORD, LPCWSTR) callconv(.C) HRESULT,
};
pub const struct_IInternetProtocolSink = extern struct {
    lpVtbl: [*c]struct_IInternetProtocolSinkVtbl,
};
pub const IInternetProtocolSink = struct_IInternetProtocolSink;
pub const struct_IInternetProtocolRootVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetProtocolRoot, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetProtocolRoot) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetProtocolRoot) callconv(.C) ULONG,
    Start: ?fn ([*c]IInternetProtocolRoot, LPCWSTR, [*c]IInternetProtocolSink, [*c]IInternetBindInfo, DWORD, HANDLE_PTR) callconv(.C) HRESULT,
    Continue: ?fn ([*c]IInternetProtocolRoot, [*c]PROTOCOLDATA) callconv(.C) HRESULT,
    Abort: ?fn ([*c]IInternetProtocolRoot, HRESULT, DWORD) callconv(.C) HRESULT,
    Terminate: ?fn ([*c]IInternetProtocolRoot, DWORD) callconv(.C) HRESULT,
    Suspend: ?fn ([*c]IInternetProtocolRoot) callconv(.C) HRESULT,
    Resume: ?fn ([*c]IInternetProtocolRoot) callconv(.C) HRESULT,
};
pub const struct_IInternetProtocolRoot = extern struct {
    lpVtbl: [*c]struct_IInternetProtocolRootVtbl,
};
pub const IInternetProtocol = struct_IInternetProtocol;
pub const struct_IInternetProtocolVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetProtocol, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetProtocol) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetProtocol) callconv(.C) ULONG,
    Start: ?fn ([*c]IInternetProtocol, LPCWSTR, [*c]IInternetProtocolSink, [*c]IInternetBindInfo, DWORD, HANDLE_PTR) callconv(.C) HRESULT,
    Continue: ?fn ([*c]IInternetProtocol, [*c]PROTOCOLDATA) callconv(.C) HRESULT,
    Abort: ?fn ([*c]IInternetProtocol, HRESULT, DWORD) callconv(.C) HRESULT,
    Terminate: ?fn ([*c]IInternetProtocol, DWORD) callconv(.C) HRESULT,
    Suspend: ?fn ([*c]IInternetProtocol) callconv(.C) HRESULT,
    Resume: ?fn ([*c]IInternetProtocol) callconv(.C) HRESULT,
    Read: ?fn ([*c]IInternetProtocol, ?*c_void, ULONG, [*c]ULONG) callconv(.C) HRESULT,
    Seek: ?fn ([*c]IInternetProtocol, LARGE_INTEGER, DWORD, [*c]ULARGE_INTEGER) callconv(.C) HRESULT,
    LockRequest: ?fn ([*c]IInternetProtocol, DWORD) callconv(.C) HRESULT,
    UnlockRequest: ?fn ([*c]IInternetProtocol) callconv(.C) HRESULT,
};
pub const struct_IInternetProtocol = extern struct {
    lpVtbl: [*c]struct_IInternetProtocolVtbl,
};
pub const IInternetProtocolEx = struct_IInternetProtocolEx;
pub const struct_IInternetProtocolExVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetProtocolEx, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetProtocolEx) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetProtocolEx) callconv(.C) ULONG,
    Start: ?fn ([*c]IInternetProtocolEx, LPCWSTR, [*c]IInternetProtocolSink, [*c]IInternetBindInfo, DWORD, HANDLE_PTR) callconv(.C) HRESULT,
    Continue: ?fn ([*c]IInternetProtocolEx, [*c]PROTOCOLDATA) callconv(.C) HRESULT,
    Abort: ?fn ([*c]IInternetProtocolEx, HRESULT, DWORD) callconv(.C) HRESULT,
    Terminate: ?fn ([*c]IInternetProtocolEx, DWORD) callconv(.C) HRESULT,
    Suspend: ?fn ([*c]IInternetProtocolEx) callconv(.C) HRESULT,
    Resume: ?fn ([*c]IInternetProtocolEx) callconv(.C) HRESULT,
    Read: ?fn ([*c]IInternetProtocolEx, ?*c_void, ULONG, [*c]ULONG) callconv(.C) HRESULT,
    Seek: ?fn ([*c]IInternetProtocolEx, LARGE_INTEGER, DWORD, [*c]ULARGE_INTEGER) callconv(.C) HRESULT,
    LockRequest: ?fn ([*c]IInternetProtocolEx, DWORD) callconv(.C) HRESULT,
    UnlockRequest: ?fn ([*c]IInternetProtocolEx) callconv(.C) HRESULT,
    StartEx: ?fn ([*c]IInternetProtocolEx, [*c]IUri, [*c]IInternetProtocolSink, [*c]IInternetBindInfo, DWORD, HANDLE_PTR) callconv(.C) HRESULT,
};
pub const struct_IInternetProtocolEx = extern struct {
    lpVtbl: [*c]struct_IInternetProtocolExVtbl,
};
pub const IInternetProtocolSinkStackable = struct_IInternetProtocolSinkStackable;
pub const struct_IInternetProtocolSinkStackableVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetProtocolSinkStackable, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetProtocolSinkStackable) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetProtocolSinkStackable) callconv(.C) ULONG,
    SwitchSink: ?fn ([*c]IInternetProtocolSinkStackable, [*c]IInternetProtocolSink) callconv(.C) HRESULT,
    CommitSwitch: ?fn ([*c]IInternetProtocolSinkStackable) callconv(.C) HRESULT,
    RollbackSwitch: ?fn ([*c]IInternetProtocolSinkStackable) callconv(.C) HRESULT,
};
pub const struct_IInternetProtocolSinkStackable = extern struct {
    lpVtbl: [*c]struct_IInternetProtocolSinkStackableVtbl,
};
pub const IInternetSession = struct_IInternetSession;
pub const struct_IInternetSessionVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetSession, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetSession) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetSession) callconv(.C) ULONG,
    RegisterNameSpace: ?fn ([*c]IInternetSession, [*c]IClassFactory, [*c]const IID, LPCWSTR, ULONG, [*c]const LPCWSTR, DWORD) callconv(.C) HRESULT,
    UnregisterNameSpace: ?fn ([*c]IInternetSession, [*c]IClassFactory, LPCWSTR) callconv(.C) HRESULT,
    RegisterMimeFilter: ?fn ([*c]IInternetSession, [*c]IClassFactory, [*c]const IID, LPCWSTR) callconv(.C) HRESULT,
    UnregisterMimeFilter: ?fn ([*c]IInternetSession, [*c]IClassFactory, LPCWSTR) callconv(.C) HRESULT,
    CreateBinding: ?fn ([*c]IInternetSession, LPBC, LPCWSTR, [*c]IUnknown, [*c]([*c]IUnknown), [*c]([*c]IInternetProtocol), DWORD) callconv(.C) HRESULT,
    SetSessionOption: ?fn ([*c]IInternetSession, DWORD, LPVOID, DWORD, DWORD) callconv(.C) HRESULT,
    GetSessionOption: ?fn ([*c]IInternetSession, DWORD, LPVOID, [*c]DWORD, DWORD) callconv(.C) HRESULT,
};
pub const struct_IInternetSession = extern struct {
    lpVtbl: [*c]struct_IInternetSessionVtbl,
};
pub const IInternetThreadSwitch = struct_IInternetThreadSwitch;
pub const struct_IInternetThreadSwitchVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetThreadSwitch, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetThreadSwitch) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetThreadSwitch) callconv(.C) ULONG,
    Prepare: ?fn ([*c]IInternetThreadSwitch) callconv(.C) HRESULT,
    Continue: ?fn ([*c]IInternetThreadSwitch) callconv(.C) HRESULT,
};
pub const struct_IInternetThreadSwitch = extern struct {
    lpVtbl: [*c]struct_IInternetThreadSwitchVtbl,
};
pub const IInternetPriority = struct_IInternetPriority;
pub const struct_IInternetPriorityVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetPriority, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetPriority) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetPriority) callconv(.C) ULONG,
    SetPriority: ?fn ([*c]IInternetPriority, LONG) callconv(.C) HRESULT,
    GetPriority: ?fn ([*c]IInternetPriority, [*c]LONG) callconv(.C) HRESULT,
};
pub const struct_IInternetPriority = extern struct {
    lpVtbl: [*c]struct_IInternetPriorityVtbl,
};
pub const IInternetProtocolInfo = struct_IInternetProtocolInfo;
pub const PARSE_CANONICALIZE = enum__tagPARSEACTION.PARSE_CANONICALIZE;
pub const PARSE_FRIENDLY = enum__tagPARSEACTION.PARSE_FRIENDLY;
pub const PARSE_SECURITY_URL = enum__tagPARSEACTION.PARSE_SECURITY_URL;
pub const PARSE_ROOTDOCUMENT = enum__tagPARSEACTION.PARSE_ROOTDOCUMENT;
pub const PARSE_DOCUMENT = enum__tagPARSEACTION.PARSE_DOCUMENT;
pub const PARSE_ANCHOR = enum__tagPARSEACTION.PARSE_ANCHOR;
pub const PARSE_ENCODE_IS_UNESCAPE = enum__tagPARSEACTION.PARSE_ENCODE_IS_UNESCAPE;
pub const PARSE_DECODE_IS_ESCAPE = enum__tagPARSEACTION.PARSE_DECODE_IS_ESCAPE;
pub const PARSE_PATH_FROM_URL = enum__tagPARSEACTION.PARSE_PATH_FROM_URL;
pub const PARSE_URL_FROM_PATH = enum__tagPARSEACTION.PARSE_URL_FROM_PATH;
pub const PARSE_MIME = enum__tagPARSEACTION.PARSE_MIME;
pub const PARSE_SERVER = enum__tagPARSEACTION.PARSE_SERVER;
pub const PARSE_SCHEMA = enum__tagPARSEACTION.PARSE_SCHEMA;
pub const PARSE_SITE = enum__tagPARSEACTION.PARSE_SITE;
pub const PARSE_DOMAIN = enum__tagPARSEACTION.PARSE_DOMAIN;
pub const PARSE_LOCATION = enum__tagPARSEACTION.PARSE_LOCATION;
pub const PARSE_SECURITY_DOMAIN = enum__tagPARSEACTION.PARSE_SECURITY_DOMAIN;
pub const PARSE_ESCAPE = enum__tagPARSEACTION.PARSE_ESCAPE;
pub const PARSE_UNESCAPE = enum__tagPARSEACTION.PARSE_UNESCAPE;
pub const enum__tagPARSEACTION = extern enum {
    PARSE_CANONICALIZE = 1,
    PARSE_FRIENDLY = 2,
    PARSE_SECURITY_URL = 3,
    PARSE_ROOTDOCUMENT = 4,
    PARSE_DOCUMENT = 5,
    PARSE_ANCHOR = 6,
    PARSE_ENCODE_IS_UNESCAPE = 7,
    PARSE_DECODE_IS_ESCAPE = 8,
    PARSE_PATH_FROM_URL = 9,
    PARSE_URL_FROM_PATH = 10,
    PARSE_MIME = 11,
    PARSE_SERVER = 12,
    PARSE_SCHEMA = 13,
    PARSE_SITE = 14,
    PARSE_DOMAIN = 15,
    PARSE_LOCATION = 16,
    PARSE_SECURITY_DOMAIN = 17,
    PARSE_ESCAPE = 18,
    PARSE_UNESCAPE = 19,
};
pub const PARSEACTION = extern enum {
    PARSE_CANONICALIZE = 1,
    PARSE_FRIENDLY = 2,
    PARSE_SECURITY_URL = 3,
    PARSE_ROOTDOCUMENT = 4,
    PARSE_DOCUMENT = 5,
    PARSE_ANCHOR = 6,
    PARSE_ENCODE_IS_UNESCAPE = 7,
    PARSE_DECODE_IS_ESCAPE = 8,
    PARSE_PATH_FROM_URL = 9,
    PARSE_URL_FROM_PATH = 10,
    PARSE_MIME = 11,
    PARSE_SERVER = 12,
    PARSE_SCHEMA = 13,
    PARSE_SITE = 14,
    PARSE_DOMAIN = 15,
    PARSE_LOCATION = 16,
    PARSE_SECURITY_DOMAIN = 17,
    PARSE_ESCAPE = 18,
    PARSE_UNESCAPE = 19,
};
pub const QUERY_EXPIRATION_DATE = enum__tagQUERYOPTION.QUERY_EXPIRATION_DATE;
pub const QUERY_TIME_OF_LAST_CHANGE = enum__tagQUERYOPTION.QUERY_TIME_OF_LAST_CHANGE;
pub const QUERY_CONTENT_ENCODING = enum__tagQUERYOPTION.QUERY_CONTENT_ENCODING;
pub const QUERY_CONTENT_TYPE = enum__tagQUERYOPTION.QUERY_CONTENT_TYPE;
pub const QUERY_REFRESH = enum__tagQUERYOPTION.QUERY_REFRESH;
pub const QUERY_RECOMBINE = enum__tagQUERYOPTION.QUERY_RECOMBINE;
pub const QUERY_CAN_NAVIGATE = enum__tagQUERYOPTION.QUERY_CAN_NAVIGATE;
pub const QUERY_USES_NETWORK = enum__tagQUERYOPTION.QUERY_USES_NETWORK;
pub const QUERY_IS_CACHED = enum__tagQUERYOPTION.QUERY_IS_CACHED;
pub const QUERY_IS_INSTALLEDENTRY = enum__tagQUERYOPTION.QUERY_IS_INSTALLEDENTRY;
pub const QUERY_IS_CACHED_OR_MAPPED = enum__tagQUERYOPTION.QUERY_IS_CACHED_OR_MAPPED;
pub const QUERY_USES_CACHE = enum__tagQUERYOPTION.QUERY_USES_CACHE;
pub const QUERY_IS_SECURE = enum__tagQUERYOPTION.QUERY_IS_SECURE;
pub const QUERY_IS_SAFE = enum__tagQUERYOPTION.QUERY_IS_SAFE;
pub const QUERY_USES_HISTORYFOLDER = enum__tagQUERYOPTION.QUERY_USES_HISTORYFOLDER;
pub const QUERY_IS_CACHED_AND_USABLE_OFFLINE = enum__tagQUERYOPTION.QUERY_IS_CACHED_AND_USABLE_OFFLINE;
pub const enum__tagQUERYOPTION = extern enum {
    QUERY_EXPIRATION_DATE = 1,
    QUERY_TIME_OF_LAST_CHANGE = 2,
    QUERY_CONTENT_ENCODING = 3,
    QUERY_CONTENT_TYPE = 4,
    QUERY_REFRESH = 5,
    QUERY_RECOMBINE = 6,
    QUERY_CAN_NAVIGATE = 7,
    QUERY_USES_NETWORK = 8,
    QUERY_IS_CACHED = 9,
    QUERY_IS_INSTALLEDENTRY = 10,
    QUERY_IS_CACHED_OR_MAPPED = 11,
    QUERY_USES_CACHE = 12,
    QUERY_IS_SECURE = 13,
    QUERY_IS_SAFE = 14,
    QUERY_USES_HISTORYFOLDER = 15,
    QUERY_IS_CACHED_AND_USABLE_OFFLINE = 16,
};
pub const QUERYOPTION = extern enum {
    QUERY_EXPIRATION_DATE = 1,
    QUERY_TIME_OF_LAST_CHANGE = 2,
    QUERY_CONTENT_ENCODING = 3,
    QUERY_CONTENT_TYPE = 4,
    QUERY_REFRESH = 5,
    QUERY_RECOMBINE = 6,
    QUERY_CAN_NAVIGATE = 7,
    QUERY_USES_NETWORK = 8,
    QUERY_IS_CACHED = 9,
    QUERY_IS_INSTALLEDENTRY = 10,
    QUERY_IS_CACHED_OR_MAPPED = 11,
    QUERY_USES_CACHE = 12,
    QUERY_IS_SECURE = 13,
    QUERY_IS_SAFE = 14,
    QUERY_USES_HISTORYFOLDER = 15,
    QUERY_IS_CACHED_AND_USABLE_OFFLINE = 16,
};
pub const struct_IInternetProtocolInfoVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetProtocolInfo, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetProtocolInfo) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetProtocolInfo) callconv(.C) ULONG,
    ParseUrl: ?fn ([*c]IInternetProtocolInfo, LPCWSTR, PARSEACTION, DWORD, LPWSTR, DWORD, [*c]DWORD, DWORD) callconv(.C) HRESULT,
    CombineUrl: ?fn ([*c]IInternetProtocolInfo, LPCWSTR, LPCWSTR, DWORD, LPWSTR, DWORD, [*c]DWORD, DWORD) callconv(.C) HRESULT,
    CompareUrl: ?fn ([*c]IInternetProtocolInfo, LPCWSTR, LPCWSTR, DWORD) callconv(.C) HRESULT,
    QueryInfo: ?fn ([*c]IInternetProtocolInfo, LPCWSTR, QUERYOPTION, DWORD, LPVOID, DWORD, [*c]DWORD, DWORD) callconv(.C) HRESULT,
};
pub const struct_IInternetProtocolInfo = extern struct {
    lpVtbl: [*c]struct_IInternetProtocolInfoVtbl,
};
pub const IInternetSecurityMgrSite = struct_IInternetSecurityMgrSite;
pub const struct_IInternetSecurityMgrSiteVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetSecurityMgrSite, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetSecurityMgrSite) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetSecurityMgrSite) callconv(.C) ULONG,
    GetWindow: ?fn ([*c]IInternetSecurityMgrSite, [*c]HWND) callconv(.C) HRESULT,
    EnableModeless: ?fn ([*c]IInternetSecurityMgrSite, BOOL) callconv(.C) HRESULT,
};
pub const struct_IInternetSecurityMgrSite = extern struct {
    lpVtbl: [*c]struct_IInternetSecurityMgrSiteVtbl,
};
pub const IInternetSecurityManager = struct_IInternetSecurityManager;
pub const struct_IInternetSecurityManagerVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetSecurityManager, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetSecurityManager) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetSecurityManager) callconv(.C) ULONG,
    SetSecuritySite: ?fn ([*c]IInternetSecurityManager, [*c]IInternetSecurityMgrSite) callconv(.C) HRESULT,
    GetSecuritySite: ?fn ([*c]IInternetSecurityManager, [*c]([*c]IInternetSecurityMgrSite)) callconv(.C) HRESULT,
    MapUrlToZone: ?fn ([*c]IInternetSecurityManager, LPCWSTR, [*c]DWORD, DWORD) callconv(.C) HRESULT,
    GetSecurityId: ?fn ([*c]IInternetSecurityManager, LPCWSTR, [*c]BYTE, [*c]DWORD, DWORD_PTR) callconv(.C) HRESULT,
    ProcessUrlAction: ?fn ([*c]IInternetSecurityManager, LPCWSTR, DWORD, [*c]BYTE, DWORD, [*c]BYTE, DWORD, DWORD, DWORD) callconv(.C) HRESULT,
    QueryCustomPolicy: ?fn ([*c]IInternetSecurityManager, LPCWSTR, [*c]const GUID, [*c]([*c]BYTE), [*c]DWORD, [*c]BYTE, DWORD, DWORD) callconv(.C) HRESULT,
    SetZoneMapping: ?fn ([*c]IInternetSecurityManager, DWORD, LPCWSTR, DWORD) callconv(.C) HRESULT,
    GetZoneMappings: ?fn ([*c]IInternetSecurityManager, DWORD, [*c]([*c]IEnumString), DWORD) callconv(.C) HRESULT,
};
pub const struct_IInternetSecurityManager = extern struct {
    lpVtbl: [*c]struct_IInternetSecurityManagerVtbl,
};
pub const IInternetSecurityManagerEx = struct_IInternetSecurityManagerEx;
pub const struct_IInternetSecurityManagerExVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetSecurityManagerEx, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetSecurityManagerEx) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetSecurityManagerEx) callconv(.C) ULONG,
    SetSecuritySite: ?fn ([*c]IInternetSecurityManagerEx, [*c]IInternetSecurityMgrSite) callconv(.C) HRESULT,
    GetSecuritySite: ?fn ([*c]IInternetSecurityManagerEx, [*c]([*c]IInternetSecurityMgrSite)) callconv(.C) HRESULT,
    MapUrlToZone: ?fn ([*c]IInternetSecurityManagerEx, LPCWSTR, [*c]DWORD, DWORD) callconv(.C) HRESULT,
    GetSecurityId: ?fn ([*c]IInternetSecurityManagerEx, LPCWSTR, [*c]BYTE, [*c]DWORD, DWORD_PTR) callconv(.C) HRESULT,
    ProcessUrlAction: ?fn ([*c]IInternetSecurityManagerEx, LPCWSTR, DWORD, [*c]BYTE, DWORD, [*c]BYTE, DWORD, DWORD, DWORD) callconv(.C) HRESULT,
    QueryCustomPolicy: ?fn ([*c]IInternetSecurityManagerEx, LPCWSTR, [*c]const GUID, [*c]([*c]BYTE), [*c]DWORD, [*c]BYTE, DWORD, DWORD) callconv(.C) HRESULT,
    SetZoneMapping: ?fn ([*c]IInternetSecurityManagerEx, DWORD, LPCWSTR, DWORD) callconv(.C) HRESULT,
    GetZoneMappings: ?fn ([*c]IInternetSecurityManagerEx, DWORD, [*c]([*c]IEnumString), DWORD) callconv(.C) HRESULT,
    ProcessUrlActionEx: ?fn ([*c]IInternetSecurityManagerEx, LPCWSTR, DWORD, [*c]BYTE, DWORD, [*c]BYTE, DWORD, DWORD, DWORD, [*c]DWORD) callconv(.C) HRESULT,
};
pub const struct_IInternetSecurityManagerEx = extern struct {
    lpVtbl: [*c]struct_IInternetSecurityManagerExVtbl,
};
pub const IInternetSecurityManagerEx2 = struct_IInternetSecurityManagerEx2;
pub const struct_IInternetSecurityManagerEx2Vtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetSecurityManagerEx2, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetSecurityManagerEx2) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetSecurityManagerEx2) callconv(.C) ULONG,
    SetSecuritySite: ?fn ([*c]IInternetSecurityManagerEx2, [*c]IInternetSecurityMgrSite) callconv(.C) HRESULT,
    GetSecuritySite: ?fn ([*c]IInternetSecurityManagerEx2, [*c]([*c]IInternetSecurityMgrSite)) callconv(.C) HRESULT,
    MapUrlToZone: ?fn ([*c]IInternetSecurityManagerEx2, LPCWSTR, [*c]DWORD, DWORD) callconv(.C) HRESULT,
    GetSecurityId: ?fn ([*c]IInternetSecurityManagerEx2, LPCWSTR, [*c]BYTE, [*c]DWORD, DWORD_PTR) callconv(.C) HRESULT,
    ProcessUrlAction: ?fn ([*c]IInternetSecurityManagerEx2, LPCWSTR, DWORD, [*c]BYTE, DWORD, [*c]BYTE, DWORD, DWORD, DWORD) callconv(.C) HRESULT,
    QueryCustomPolicy: ?fn ([*c]IInternetSecurityManagerEx2, LPCWSTR, [*c]const GUID, [*c]([*c]BYTE), [*c]DWORD, [*c]BYTE, DWORD, DWORD) callconv(.C) HRESULT,
    SetZoneMapping: ?fn ([*c]IInternetSecurityManagerEx2, DWORD, LPCWSTR, DWORD) callconv(.C) HRESULT,
    GetZoneMappings: ?fn ([*c]IInternetSecurityManagerEx2, DWORD, [*c]([*c]IEnumString), DWORD) callconv(.C) HRESULT,
    ProcessUrlActionEx: ?fn ([*c]IInternetSecurityManagerEx2, LPCWSTR, DWORD, [*c]BYTE, DWORD, [*c]BYTE, DWORD, DWORD, DWORD, [*c]DWORD) callconv(.C) HRESULT,
    MapUrlToZoneEx2: ?fn ([*c]IInternetSecurityManagerEx2, [*c]IUri, [*c]DWORD, DWORD, [*c]LPWSTR, [*c]DWORD) callconv(.C) HRESULT,
    ProcessUrlActionEx2: ?fn ([*c]IInternetSecurityManagerEx2, [*c]IUri, DWORD, [*c]BYTE, DWORD, [*c]BYTE, DWORD, DWORD, DWORD_PTR, [*c]DWORD) callconv(.C) HRESULT,
    GetSecurityIdEx2: ?fn ([*c]IInternetSecurityManagerEx2, [*c]IUri, [*c]BYTE, [*c]DWORD, DWORD_PTR) callconv(.C) HRESULT,
    QueryCustomPolicyEx2: ?fn ([*c]IInternetSecurityManagerEx2, [*c]IUri, [*c]const GUID, [*c]([*c]BYTE), [*c]DWORD, [*c]BYTE, DWORD, DWORD_PTR) callconv(.C) HRESULT,
};
pub const struct_IInternetSecurityManagerEx2 = extern struct {
    lpVtbl: [*c]struct_IInternetSecurityManagerEx2Vtbl,
};
pub const IZoneIdentifier = struct_IZoneIdentifier;
pub const struct_IZoneIdentifierVtbl = extern struct {
    QueryInterface: ?fn ([*c]IZoneIdentifier, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IZoneIdentifier) callconv(.C) ULONG,
    Release: ?fn ([*c]IZoneIdentifier) callconv(.C) ULONG,
    GetId: ?fn ([*c]IZoneIdentifier, [*c]DWORD) callconv(.C) HRESULT,
    SetId: ?fn ([*c]IZoneIdentifier, DWORD) callconv(.C) HRESULT,
    Remove: ?fn ([*c]IZoneIdentifier) callconv(.C) HRESULT,
};
pub const struct_IZoneIdentifier = extern struct {
    lpVtbl: [*c]struct_IZoneIdentifierVtbl,
};
pub const IZoneIdentifier2 = struct_IZoneIdentifier2;
pub const struct_IZoneIdentifier2Vtbl = extern struct {
    QueryInterface: ?fn ([*c]IZoneIdentifier2, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IZoneIdentifier2) callconv(.C) ULONG,
    Release: ?fn ([*c]IZoneIdentifier2) callconv(.C) ULONG,
    GetId: ?fn ([*c]IZoneIdentifier2, [*c]DWORD) callconv(.C) HRESULT,
    SetId: ?fn ([*c]IZoneIdentifier2, DWORD) callconv(.C) HRESULT,
    Remove: ?fn ([*c]IZoneIdentifier2) callconv(.C) HRESULT,
    GetLastWriterPackageFamilyName: ?fn ([*c]IZoneIdentifier2, [*c]LPWSTR) callconv(.C) HRESULT,
    SetLastWriterPackageFamilyName: ?fn ([*c]IZoneIdentifier2, LPCWSTR) callconv(.C) HRESULT,
    RemoveLastWriterPackageFamilyName: ?fn ([*c]IZoneIdentifier2) callconv(.C) HRESULT,
    GetAppZoneId: ?fn ([*c]IZoneIdentifier2, [*c]DWORD) callconv(.C) HRESULT,
    SetAppZoneId: ?fn ([*c]IZoneIdentifier2, DWORD) callconv(.C) HRESULT,
    RemoveAppZoneId: ?fn ([*c]IZoneIdentifier2) callconv(.C) HRESULT,
};
pub const struct_IZoneIdentifier2 = extern struct {
    lpVtbl: [*c]struct_IZoneIdentifier2Vtbl,
};
pub const IInternetHostSecurityManager = struct_IInternetHostSecurityManager;
pub const struct_IInternetHostSecurityManagerVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetHostSecurityManager, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetHostSecurityManager) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetHostSecurityManager) callconv(.C) ULONG,
    GetSecurityId: ?fn ([*c]IInternetHostSecurityManager, [*c]BYTE, [*c]DWORD, DWORD_PTR) callconv(.C) HRESULT,
    ProcessUrlAction: ?fn ([*c]IInternetHostSecurityManager, DWORD, [*c]BYTE, DWORD, [*c]BYTE, DWORD, DWORD, DWORD) callconv(.C) HRESULT,
    QueryCustomPolicy: ?fn ([*c]IInternetHostSecurityManager, [*c]const GUID, [*c]([*c]BYTE), [*c]DWORD, [*c]BYTE, DWORD, DWORD) callconv(.C) HRESULT,
};
pub const struct_IInternetHostSecurityManager = extern struct {
    lpVtbl: [*c]struct_IInternetHostSecurityManagerVtbl,
};
pub const IInternetZoneManager = struct_IInternetZoneManager;
pub const struct__ZONEATTRIBUTES = extern struct {
    cbSize: ULONG,
    szDisplayName: [260]WCHAR,
    szDescription: [200]WCHAR,
    szIconPath: [260]WCHAR,
    dwTemplateMinLevel: DWORD,
    dwTemplateRecommended: DWORD,
    dwTemplateCurrentLevel: DWORD,
    dwFlags: DWORD,
};
pub const ZONEATTRIBUTES = struct__ZONEATTRIBUTES;
pub const URLZONEREG_DEFAULT = enum__URLZONEREG.URLZONEREG_DEFAULT;
pub const URLZONEREG_HKLM = enum__URLZONEREG.URLZONEREG_HKLM;
pub const URLZONEREG_HKCU = enum__URLZONEREG.URLZONEREG_HKCU;
pub const enum__URLZONEREG = extern enum {
    URLZONEREG_DEFAULT = 0,
    URLZONEREG_HKLM = 1,
    URLZONEREG_HKCU = 2,
};
pub const URLZONEREG = extern enum {
    URLZONEREG_DEFAULT = 0,
    URLZONEREG_HKLM = 1,
    URLZONEREG_HKCU = 2,
};
pub const struct_IInternetZoneManagerVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetZoneManager, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetZoneManager) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetZoneManager) callconv(.C) ULONG,
    GetZoneAttributes: ?fn ([*c]IInternetZoneManager, DWORD, [*c]ZONEATTRIBUTES) callconv(.C) HRESULT,
    SetZoneAttributes: ?fn ([*c]IInternetZoneManager, DWORD, [*c]ZONEATTRIBUTES) callconv(.C) HRESULT,
    GetZoneCustomPolicy: ?fn ([*c]IInternetZoneManager, DWORD, [*c]const GUID, [*c]([*c]BYTE), [*c]DWORD, URLZONEREG) callconv(.C) HRESULT,
    SetZoneCustomPolicy: ?fn ([*c]IInternetZoneManager, DWORD, [*c]const GUID, [*c]BYTE, DWORD, URLZONEREG) callconv(.C) HRESULT,
    GetZoneActionPolicy: ?fn ([*c]IInternetZoneManager, DWORD, DWORD, [*c]BYTE, DWORD, URLZONEREG) callconv(.C) HRESULT,
    SetZoneActionPolicy: ?fn ([*c]IInternetZoneManager, DWORD, DWORD, [*c]BYTE, DWORD, URLZONEREG) callconv(.C) HRESULT,
    PromptAction: ?fn ([*c]IInternetZoneManager, DWORD, HWND, LPCWSTR, LPCWSTR, DWORD) callconv(.C) HRESULT,
    LogAction: ?fn ([*c]IInternetZoneManager, DWORD, LPCWSTR, LPCWSTR, DWORD) callconv(.C) HRESULT,
    CreateZoneEnumerator: ?fn ([*c]IInternetZoneManager, [*c]DWORD, [*c]DWORD, DWORD) callconv(.C) HRESULT,
    GetZoneAt: ?fn ([*c]IInternetZoneManager, DWORD, DWORD, [*c]DWORD) callconv(.C) HRESULT,
    DestroyZoneEnumerator: ?fn ([*c]IInternetZoneManager, DWORD) callconv(.C) HRESULT,
    CopyTemplatePoliciesToZone: ?fn ([*c]IInternetZoneManager, DWORD, DWORD, DWORD) callconv(.C) HRESULT,
};
pub const struct_IInternetZoneManager = extern struct {
    lpVtbl: [*c]struct_IInternetZoneManagerVtbl,
};
pub const IInternetZoneManagerEx = struct_IInternetZoneManagerEx;
pub const struct_IInternetZoneManagerExVtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetZoneManagerEx, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetZoneManagerEx) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetZoneManagerEx) callconv(.C) ULONG,
    GetZoneAttributes: ?fn ([*c]IInternetZoneManagerEx, DWORD, [*c]ZONEATTRIBUTES) callconv(.C) HRESULT,
    SetZoneAttributes: ?fn ([*c]IInternetZoneManagerEx, DWORD, [*c]ZONEATTRIBUTES) callconv(.C) HRESULT,
    GetZoneCustomPolicy: ?fn ([*c]IInternetZoneManagerEx, DWORD, [*c]const GUID, [*c]([*c]BYTE), [*c]DWORD, URLZONEREG) callconv(.C) HRESULT,
    SetZoneCustomPolicy: ?fn ([*c]IInternetZoneManagerEx, DWORD, [*c]const GUID, [*c]BYTE, DWORD, URLZONEREG) callconv(.C) HRESULT,
    GetZoneActionPolicy: ?fn ([*c]IInternetZoneManagerEx, DWORD, DWORD, [*c]BYTE, DWORD, URLZONEREG) callconv(.C) HRESULT,
    SetZoneActionPolicy: ?fn ([*c]IInternetZoneManagerEx, DWORD, DWORD, [*c]BYTE, DWORD, URLZONEREG) callconv(.C) HRESULT,
    PromptAction: ?fn ([*c]IInternetZoneManagerEx, DWORD, HWND, LPCWSTR, LPCWSTR, DWORD) callconv(.C) HRESULT,
    LogAction: ?fn ([*c]IInternetZoneManagerEx, DWORD, LPCWSTR, LPCWSTR, DWORD) callconv(.C) HRESULT,
    CreateZoneEnumerator: ?fn ([*c]IInternetZoneManagerEx, [*c]DWORD, [*c]DWORD, DWORD) callconv(.C) HRESULT,
    GetZoneAt: ?fn ([*c]IInternetZoneManagerEx, DWORD, DWORD, [*c]DWORD) callconv(.C) HRESULT,
    DestroyZoneEnumerator: ?fn ([*c]IInternetZoneManagerEx, DWORD) callconv(.C) HRESULT,
    CopyTemplatePoliciesToZone: ?fn ([*c]IInternetZoneManagerEx, DWORD, DWORD, DWORD) callconv(.C) HRESULT,
    GetZoneActionPolicyEx: ?fn ([*c]IInternetZoneManagerEx, DWORD, DWORD, [*c]BYTE, DWORD, URLZONEREG, DWORD) callconv(.C) HRESULT,
    SetZoneActionPolicyEx: ?fn ([*c]IInternetZoneManagerEx, DWORD, DWORD, [*c]BYTE, DWORD, URLZONEREG, DWORD) callconv(.C) HRESULT,
};
pub const struct_IInternetZoneManagerEx = extern struct {
    lpVtbl: [*c]struct_IInternetZoneManagerExVtbl,
};
pub const IInternetZoneManagerEx2 = struct_IInternetZoneManagerEx2;
pub const struct_IInternetZoneManagerEx2Vtbl = extern struct {
    QueryInterface: ?fn ([*c]IInternetZoneManagerEx2, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IInternetZoneManagerEx2) callconv(.C) ULONG,
    Release: ?fn ([*c]IInternetZoneManagerEx2) callconv(.C) ULONG,
    GetZoneAttributes: ?fn ([*c]IInternetZoneManagerEx2, DWORD, [*c]ZONEATTRIBUTES) callconv(.C) HRESULT,
    SetZoneAttributes: ?fn ([*c]IInternetZoneManagerEx2, DWORD, [*c]ZONEATTRIBUTES) callconv(.C) HRESULT,
    GetZoneCustomPolicy: ?fn ([*c]IInternetZoneManagerEx2, DWORD, [*c]const GUID, [*c]([*c]BYTE), [*c]DWORD, URLZONEREG) callconv(.C) HRESULT,
    SetZoneCustomPolicy: ?fn ([*c]IInternetZoneManagerEx2, DWORD, [*c]const GUID, [*c]BYTE, DWORD, URLZONEREG) callconv(.C) HRESULT,
    GetZoneActionPolicy: ?fn ([*c]IInternetZoneManagerEx2, DWORD, DWORD, [*c]BYTE, DWORD, URLZONEREG) callconv(.C) HRESULT,
    SetZoneActionPolicy: ?fn ([*c]IInternetZoneManagerEx2, DWORD, DWORD, [*c]BYTE, DWORD, URLZONEREG) callconv(.C) HRESULT,
    PromptAction: ?fn ([*c]IInternetZoneManagerEx2, DWORD, HWND, LPCWSTR, LPCWSTR, DWORD) callconv(.C) HRESULT,
    LogAction: ?fn ([*c]IInternetZoneManagerEx2, DWORD, LPCWSTR, LPCWSTR, DWORD) callconv(.C) HRESULT,
    CreateZoneEnumerator: ?fn ([*c]IInternetZoneManagerEx2, [*c]DWORD, [*c]DWORD, DWORD) callconv(.C) HRESULT,
    GetZoneAt: ?fn ([*c]IInternetZoneManagerEx2, DWORD, DWORD, [*c]DWORD) callconv(.C) HRESULT,
    DestroyZoneEnumerator: ?fn ([*c]IInternetZoneManagerEx2, DWORD) callconv(.C) HRESULT,
    CopyTemplatePoliciesToZone: ?fn ([*c]IInternetZoneManagerEx2, DWORD, DWORD, DWORD) callconv(.C) HRESULT,
    GetZoneActionPolicyEx: ?fn ([*c]IInternetZoneManagerEx2, DWORD, DWORD, [*c]BYTE, DWORD, URLZONEREG, DWORD) callconv(.C) HRESULT,
    SetZoneActionPolicyEx: ?fn ([*c]IInternetZoneManagerEx2, DWORD, DWORD, [*c]BYTE, DWORD, URLZONEREG, DWORD) callconv(.C) HRESULT,
    GetZoneAttributesEx: ?fn ([*c]IInternetZoneManagerEx2, DWORD, [*c]ZONEATTRIBUTES, DWORD) callconv(.C) HRESULT,
    GetZoneSecurityState: ?fn ([*c]IInternetZoneManagerEx2, DWORD, BOOL, LPDWORD, [*c]BOOL) callconv(.C) HRESULT,
    GetIESecurityState: ?fn ([*c]IInternetZoneManagerEx2, BOOL, LPDWORD, [*c]BOOL, BOOL) callconv(.C) HRESULT,
    FixUnsecureSettings: ?fn ([*c]IInternetZoneManagerEx2) callconv(.C) HRESULT,
};
pub const struct_IInternetZoneManagerEx2 = extern struct {
    lpVtbl: [*c]struct_IInternetZoneManagerEx2Vtbl,
};
pub const ISoftDistExt = struct_ISoftDistExt;
pub const struct_IXMLElementCollectionVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLElementCollection, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLElementCollection) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLElementCollection) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLElementCollection, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLElementCollection, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLElementCollection, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLElementCollection, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    put_length: ?fn ([*c]IXMLElementCollection, c_long) callconv(.C) HRESULT,
    get_length: ?fn ([*c]IXMLElementCollection, [*c]c_long) callconv(.C) HRESULT,
    get__newEnum: ?fn ([*c]IXMLElementCollection, [*c]([*c]IUnknown)) callconv(.C) HRESULT,
    item: ?fn ([*c]IXMLElementCollection, VARIANT, VARIANT, [*c]([*c]IDispatch)) callconv(.C) HRESULT,
};
pub const struct_IXMLElementCollection = extern struct {
    lpVtbl: [*c]struct_IXMLElementCollectionVtbl,
};
pub const IXMLElementCollection = struct_IXMLElementCollection;
pub const struct_IXMLElementVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLElement, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLElement) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLElement) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLElement, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLElement, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLElement, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLElement, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_tagName: ?fn ([*c]IXMLElement, [*c]BSTR) callconv(.C) HRESULT,
    put_tagName: ?fn ([*c]IXMLElement, BSTR) callconv(.C) HRESULT,
    get_parent: ?fn ([*c]IXMLElement, [*c]([*c]IXMLElement)) callconv(.C) HRESULT,
    setAttribute: ?fn ([*c]IXMLElement, BSTR, VARIANT) callconv(.C) HRESULT,
    getAttribute: ?fn ([*c]IXMLElement, BSTR, [*c]VARIANT) callconv(.C) HRESULT,
    removeAttribute: ?fn ([*c]IXMLElement, BSTR) callconv(.C) HRESULT,
    get_children: ?fn ([*c]IXMLElement, [*c]([*c]IXMLElementCollection)) callconv(.C) HRESULT,
    get_type: ?fn ([*c]IXMLElement, [*c]c_long) callconv(.C) HRESULT,
    get_text: ?fn ([*c]IXMLElement, [*c]BSTR) callconv(.C) HRESULT,
    put_text: ?fn ([*c]IXMLElement, BSTR) callconv(.C) HRESULT,
    addChild: ?fn ([*c]IXMLElement, [*c]IXMLElement, c_long, c_long) callconv(.C) HRESULT,
    removeChild: ?fn ([*c]IXMLElement, [*c]IXMLElement) callconv(.C) HRESULT,
};
pub const struct_IXMLElement = extern struct {
    lpVtbl: [*c]struct_IXMLElementVtbl,
};
pub const IXMLElement = struct_IXMLElement;
pub const struct__tagSOFTDISTINFO = extern struct {
    cbSize: ULONG,
    dwFlags: DWORD,
    dwAdState: DWORD,
    szTitle: LPWSTR,
    szAbstract: LPWSTR,
    szHREF: LPWSTR,
    dwInstalledVersionMS: DWORD,
    dwInstalledVersionLS: DWORD,
    dwUpdateVersionMS: DWORD,
    dwUpdateVersionLS: DWORD,
    dwAdvertisedVersionMS: DWORD,
    dwAdvertisedVersionLS: DWORD,
    dwReserved: DWORD,
};
pub const LPSOFTDISTINFO = [*c]struct__tagSOFTDISTINFO;
pub const struct__tagCODEBASEHOLD = extern struct {
    cbSize: ULONG,
    szDistUnit: LPWSTR,
    szCodeBase: LPWSTR,
    dwVersionMS: DWORD,
    dwVersionLS: DWORD,
    dwStyle: DWORD,
};
pub const LPCODEBASEHOLD = [*c]struct__tagCODEBASEHOLD;
pub const struct_ISoftDistExtVtbl = extern struct {
    QueryInterface: ?fn ([*c]ISoftDistExt, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ISoftDistExt) callconv(.C) ULONG,
    Release: ?fn ([*c]ISoftDistExt) callconv(.C) ULONG,
    ProcessSoftDist: ?fn ([*c]ISoftDistExt, LPCWSTR, [*c]IXMLElement, LPSOFTDISTINFO) callconv(.C) HRESULT,
    GetFirstCodeBase: ?fn ([*c]ISoftDistExt, [*c]LPWSTR, LPDWORD) callconv(.C) HRESULT,
    GetNextCodeBase: ?fn ([*c]ISoftDistExt, [*c]LPWSTR, LPDWORD) callconv(.C) HRESULT,
    AsyncInstallDistributionUnit: ?fn ([*c]ISoftDistExt, [*c]IBindCtx, LPVOID, DWORD, LPCODEBASEHOLD) callconv(.C) HRESULT,
};
pub const struct_ISoftDistExt = extern struct {
    lpVtbl: [*c]struct_ISoftDistExtVtbl,
};
pub const ICatalogFileInfo = struct_ICatalogFileInfo;
pub const struct_ICatalogFileInfoVtbl = extern struct {
    QueryInterface: ?fn ([*c]ICatalogFileInfo, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]ICatalogFileInfo) callconv(.C) ULONG,
    Release: ?fn ([*c]ICatalogFileInfo) callconv(.C) ULONG,
    GetCatalogFile: ?fn ([*c]ICatalogFileInfo, [*c]LPSTR) callconv(.C) HRESULT,
    GetJavaTrust: ?fn ([*c]ICatalogFileInfo, [*c](?*c_void)) callconv(.C) HRESULT,
};
pub const struct_ICatalogFileInfo = extern struct {
    lpVtbl: [*c]struct_ICatalogFileInfoVtbl,
};
pub const IDataFilter = struct_IDataFilter;
pub const struct_IDataFilterVtbl = extern struct {
    QueryInterface: ?fn ([*c]IDataFilter, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IDataFilter) callconv(.C) ULONG,
    Release: ?fn ([*c]IDataFilter) callconv(.C) ULONG,
    DoEncode: ?fn ([*c]IDataFilter, DWORD, LONG, [*c]BYTE, LONG, [*c]BYTE, LONG, [*c]LONG, [*c]LONG, DWORD) callconv(.C) HRESULT,
    DoDecode: ?fn ([*c]IDataFilter, DWORD, LONG, [*c]BYTE, LONG, [*c]BYTE, LONG, [*c]LONG, [*c]LONG, DWORD) callconv(.C) HRESULT,
    SetEncodingLevel: ?fn ([*c]IDataFilter, DWORD) callconv(.C) HRESULT,
};
pub const struct_IDataFilter = extern struct {
    lpVtbl: [*c]struct_IDataFilterVtbl,
};
pub const IEncodingFilterFactory = struct_IEncodingFilterFactory;
pub const struct__tagDATAINFO = extern struct {
    ulTotalSize: ULONG,
    ulavrPacketSize: ULONG,
    ulConnectSpeed: ULONG,
    ulProcessorSpeed: ULONG,
};
pub const DATAINFO = struct__tagDATAINFO;
pub const struct_IEncodingFilterFactoryVtbl = extern struct {
    QueryInterface: ?fn ([*c]IEncodingFilterFactory, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IEncodingFilterFactory) callconv(.C) ULONG,
    Release: ?fn ([*c]IEncodingFilterFactory) callconv(.C) ULONG,
    FindBestFilter: ?fn ([*c]IEncodingFilterFactory, LPCWSTR, LPCWSTR, DATAINFO, [*c]([*c]IDataFilter)) callconv(.C) HRESULT,
    GetDefaultFilter: ?fn ([*c]IEncodingFilterFactory, LPCWSTR, LPCWSTR, [*c]([*c]IDataFilter)) callconv(.C) HRESULT,
};
pub const struct_IEncodingFilterFactory = extern struct {
    lpVtbl: [*c]struct_IEncodingFilterFactoryVtbl,
};
pub const IWrappedProtocol = struct_IWrappedProtocol;
pub const struct_IWrappedProtocolVtbl = extern struct {
    QueryInterface: ?fn ([*c]IWrappedProtocol, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IWrappedProtocol) callconv(.C) ULONG,
    Release: ?fn ([*c]IWrappedProtocol) callconv(.C) ULONG,
    GetWrapperCode: ?fn ([*c]IWrappedProtocol, [*c]LONG, DWORD_PTR) callconv(.C) HRESULT,
};
pub const struct_IWrappedProtocol = extern struct {
    lpVtbl: [*c]struct_IWrappedProtocolVtbl,
};
pub const IGetBindHandle = struct_IGetBindHandle;
pub const BINDHANDLETYPES_APPCACHE = enum___MIDL_IGetBindHandle_0001.BINDHANDLETYPES_APPCACHE;
pub const BINDHANDLETYPES_DEPENDENCY = enum___MIDL_IGetBindHandle_0001.BINDHANDLETYPES_DEPENDENCY;
pub const BINDHANDLETYPES_COUNT = enum___MIDL_IGetBindHandle_0001.BINDHANDLETYPES_COUNT;
pub const enum___MIDL_IGetBindHandle_0001 = extern enum {
    BINDHANDLETYPES_APPCACHE = 0,
    BINDHANDLETYPES_DEPENDENCY = 1,
    BINDHANDLETYPES_COUNT = 2,
};
pub const BINDHANDLETYPES = extern enum {
    BINDHANDLETYPES_APPCACHE = 0,
    BINDHANDLETYPES_DEPENDENCY = 1,
    BINDHANDLETYPES_COUNT = 2,
};
pub const struct_IGetBindHandleVtbl = extern struct {
    QueryInterface: ?fn ([*c]IGetBindHandle, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IGetBindHandle) callconv(.C) ULONG,
    Release: ?fn ([*c]IGetBindHandle) callconv(.C) ULONG,
    GetBindHandle: ?fn ([*c]IGetBindHandle, BINDHANDLETYPES, [*c]HANDLE) callconv(.C) HRESULT,
};
pub const struct_IGetBindHandle = extern struct {
    lpVtbl: [*c]struct_IGetBindHandleVtbl,
};
pub const IBindCallbackRedirect = struct_IBindCallbackRedirect;
pub const struct_IBindCallbackRedirectVtbl = extern struct {
    QueryInterface: ?fn ([*c]IBindCallbackRedirect, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IBindCallbackRedirect) callconv(.C) ULONG,
    Release: ?fn ([*c]IBindCallbackRedirect) callconv(.C) ULONG,
    Redirect: ?fn ([*c]IBindCallbackRedirect, LPCWSTR, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
};
pub const struct_IBindCallbackRedirect = extern struct {
    lpVtbl: [*c]struct_IBindCallbackRedirectVtbl,
};
pub const IBindHttpSecurity = struct_IBindHttpSecurity;
pub const struct_IBindHttpSecurityVtbl = extern struct {
    QueryInterface: ?fn ([*c]IBindHttpSecurity, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IBindHttpSecurity) callconv(.C) ULONG,
    Release: ?fn ([*c]IBindHttpSecurity) callconv(.C) ULONG,
    GetIgnoreCertMask: ?fn ([*c]IBindHttpSecurity, [*c]DWORD) callconv(.C) HRESULT,
};
pub const struct_IBindHttpSecurity = extern struct {
    lpVtbl: [*c]struct_IBindHttpSecurityVtbl,
};
pub const IOleAdviseHolder = struct_IOleAdviseHolder;
pub const struct_IOleAdviseHolderVtbl = extern struct {
    QueryInterface: ?fn ([*c]IOleAdviseHolder, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IOleAdviseHolder) callconv(.C) ULONG,
    Release: ?fn ([*c]IOleAdviseHolder) callconv(.C) ULONG,
    Advise: ?fn ([*c]IOleAdviseHolder, [*c]IAdviseSink, [*c]DWORD) callconv(.C) HRESULT,
    Unadvise: ?fn ([*c]IOleAdviseHolder, DWORD) callconv(.C) HRESULT,
    EnumAdvise: ?fn ([*c]IOleAdviseHolder, [*c]([*c]IEnumSTATDATA)) callconv(.C) HRESULT,
    SendOnRename: ?fn ([*c]IOleAdviseHolder, [*c]IMoniker) callconv(.C) HRESULT,
    SendOnSave: ?fn ([*c]IOleAdviseHolder) callconv(.C) HRESULT,
    SendOnClose: ?fn ([*c]IOleAdviseHolder) callconv(.C) HRESULT,
};
pub const struct_IOleAdviseHolder = extern struct {
    lpVtbl: [*c]struct_IOleAdviseHolderVtbl,
};
pub const IOleCache = struct_IOleCache;
pub const struct_IOleCacheVtbl = extern struct {
    QueryInterface: ?fn ([*c]IOleCache, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IOleCache) callconv(.C) ULONG,
    Release: ?fn ([*c]IOleCache) callconv(.C) ULONG,
    Cache: ?fn ([*c]IOleCache, [*c]FORMATETC, DWORD, [*c]DWORD) callconv(.C) HRESULT,
    Uncache: ?fn ([*c]IOleCache, DWORD) callconv(.C) HRESULT,
    EnumCache: ?fn ([*c]IOleCache, [*c]([*c]IEnumSTATDATA)) callconv(.C) HRESULT,
    InitCache: ?fn ([*c]IOleCache, [*c]IDataObject) callconv(.C) HRESULT,
    SetData: ?fn ([*c]IOleCache, [*c]FORMATETC, [*c]STGMEDIUM, BOOL) callconv(.C) HRESULT,
};
pub const struct_IOleCache = extern struct {
    lpVtbl: [*c]struct_IOleCacheVtbl,
};
pub const IOleCache2 = struct_IOleCache2;
pub const struct_IOleCache2Vtbl = extern struct {
    QueryInterface: ?fn ([*c]IOleCache2, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IOleCache2) callconv(.C) ULONG,
    Release: ?fn ([*c]IOleCache2) callconv(.C) ULONG,
    Cache: ?fn ([*c]IOleCache2, [*c]FORMATETC, DWORD, [*c]DWORD) callconv(.C) HRESULT,
    Uncache: ?fn ([*c]IOleCache2, DWORD) callconv(.C) HRESULT,
    EnumCache: ?fn ([*c]IOleCache2, [*c]([*c]IEnumSTATDATA)) callconv(.C) HRESULT,
    InitCache: ?fn ([*c]IOleCache2, [*c]IDataObject) callconv(.C) HRESULT,
    SetData: ?fn ([*c]IOleCache2, [*c]FORMATETC, [*c]STGMEDIUM, BOOL) callconv(.C) HRESULT,
    UpdateCache: ?fn ([*c]IOleCache2, LPDATAOBJECT, DWORD, LPVOID) callconv(.C) HRESULT,
    DiscardCache: ?fn ([*c]IOleCache2, DWORD) callconv(.C) HRESULT,
};
pub const struct_IOleCache2 = extern struct {
    lpVtbl: [*c]struct_IOleCache2Vtbl,
};
pub const IOleCacheControl = struct_IOleCacheControl;
pub const struct_IOleCacheControlVtbl = extern struct {
    QueryInterface: ?fn ([*c]IOleCacheControl, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IOleCacheControl) callconv(.C) ULONG,
    Release: ?fn ([*c]IOleCacheControl) callconv(.C) ULONG,
    OnRun: ?fn ([*c]IOleCacheControl, LPDATAOBJECT) callconv(.C) HRESULT,
    OnStop: ?fn ([*c]IOleCacheControl) callconv(.C) HRESULT,
};
pub const struct_IOleCacheControl = extern struct {
    lpVtbl: [*c]struct_IOleCacheControlVtbl,
};
pub const IParseDisplayName = struct_IParseDisplayName;
pub const struct_IParseDisplayNameVtbl = extern struct {
    QueryInterface: ?fn ([*c]IParseDisplayName, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IParseDisplayName) callconv(.C) ULONG,
    Release: ?fn ([*c]IParseDisplayName) callconv(.C) ULONG,
    ParseDisplayName: ?fn ([*c]IParseDisplayName, [*c]IBindCtx, LPOLESTR, [*c]ULONG, [*c]([*c]IMoniker)) callconv(.C) HRESULT,
};
pub const struct_IParseDisplayName = extern struct {
    lpVtbl: [*c]struct_IParseDisplayNameVtbl,
};
pub const IOleContainer = struct_IOleContainer;
pub const struct_IOleContainerVtbl = extern struct {
    QueryInterface: ?fn ([*c]IOleContainer, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IOleContainer) callconv(.C) ULONG,
    Release: ?fn ([*c]IOleContainer) callconv(.C) ULONG,
    ParseDisplayName: ?fn ([*c]IOleContainer, [*c]IBindCtx, LPOLESTR, [*c]ULONG, [*c]([*c]IMoniker)) callconv(.C) HRESULT,
    EnumObjects: ?fn ([*c]IOleContainer, DWORD, [*c]([*c]IEnumUnknown)) callconv(.C) HRESULT,
    LockContainer: ?fn ([*c]IOleContainer, BOOL) callconv(.C) HRESULT,
};
pub const struct_IOleContainer = extern struct {
    lpVtbl: [*c]struct_IOleContainerVtbl,
};
pub const IOleClientSite = struct_IOleClientSite;
pub const struct_IOleClientSiteVtbl = extern struct {
    QueryInterface: ?fn ([*c]IOleClientSite, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IOleClientSite) callconv(.C) ULONG,
    Release: ?fn ([*c]IOleClientSite) callconv(.C) ULONG,
    SaveObject: ?fn ([*c]IOleClientSite) callconv(.C) HRESULT,
    GetMoniker: ?fn ([*c]IOleClientSite, DWORD, DWORD, [*c]([*c]IMoniker)) callconv(.C) HRESULT,
    GetContainer: ?fn ([*c]IOleClientSite, [*c]([*c]IOleContainer)) callconv(.C) HRESULT,
    ShowObject: ?fn ([*c]IOleClientSite) callconv(.C) HRESULT,
    OnShowWindow: ?fn ([*c]IOleClientSite, BOOL) callconv(.C) HRESULT,
    RequestNewObjectLayout: ?fn ([*c]IOleClientSite) callconv(.C) HRESULT,
};
pub const struct_IOleClientSite = extern struct {
    lpVtbl: [*c]struct_IOleClientSiteVtbl,
};
pub const IOleObject = struct_IOleObject;
pub const struct_tagOLEVERB = extern struct {
    lVerb: LONG,
    lpszVerbName: LPOLESTR,
    fuFlags: DWORD,
    grfAttribs: DWORD,
};
pub const LPOLEVERB = [*c]struct_tagOLEVERB;
pub const struct_IEnumOLEVERBVtbl = extern struct {
    QueryInterface: ?fn ([*c]IEnumOLEVERB, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IEnumOLEVERB) callconv(.C) ULONG,
    Release: ?fn ([*c]IEnumOLEVERB) callconv(.C) ULONG,
    Next: ?fn ([*c]IEnumOLEVERB, ULONG, LPOLEVERB, [*c]ULONG) callconv(.C) HRESULT,
    Skip: ?fn ([*c]IEnumOLEVERB, ULONG) callconv(.C) HRESULT,
    Reset: ?fn ([*c]IEnumOLEVERB) callconv(.C) HRESULT,
    Clone: ?fn ([*c]IEnumOLEVERB, [*c]([*c]IEnumOLEVERB)) callconv(.C) HRESULT,
};
pub const struct_IEnumOLEVERB = extern struct {
    lpVtbl: [*c]struct_IEnumOLEVERBVtbl,
};
pub const IEnumOLEVERB = struct_IEnumOLEVERB;
pub const struct_IOleObjectVtbl = extern struct {
    QueryInterface: ?fn ([*c]IOleObject, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IOleObject) callconv(.C) ULONG,
    Release: ?fn ([*c]IOleObject) callconv(.C) ULONG,
    SetClientSite: ?fn ([*c]IOleObject, [*c]IOleClientSite) callconv(.C) HRESULT,
    GetClientSite: ?fn ([*c]IOleObject, [*c]([*c]IOleClientSite)) callconv(.C) HRESULT,
    SetHostNames: ?fn ([*c]IOleObject, LPCOLESTR, LPCOLESTR) callconv(.C) HRESULT,
    Close: ?fn ([*c]IOleObject, DWORD) callconv(.C) HRESULT,
    SetMoniker: ?fn ([*c]IOleObject, DWORD, [*c]IMoniker) callconv(.C) HRESULT,
    GetMoniker: ?fn ([*c]IOleObject, DWORD, DWORD, [*c]([*c]IMoniker)) callconv(.C) HRESULT,
    InitFromData: ?fn ([*c]IOleObject, [*c]IDataObject, BOOL, DWORD) callconv(.C) HRESULT,
    GetClipboardData: ?fn ([*c]IOleObject, DWORD, [*c]([*c]IDataObject)) callconv(.C) HRESULT,
    DoVerb: ?fn ([*c]IOleObject, LONG, LPMSG, [*c]IOleClientSite, LONG, HWND, LPCRECT) callconv(.C) HRESULT,
    EnumVerbs: ?fn ([*c]IOleObject, [*c]([*c]IEnumOLEVERB)) callconv(.C) HRESULT,
    Update: ?fn ([*c]IOleObject) callconv(.C) HRESULT,
    IsUpToDate: ?fn ([*c]IOleObject) callconv(.C) HRESULT,
    GetUserClassID: ?fn ([*c]IOleObject, [*c]CLSID) callconv(.C) HRESULT,
    GetUserType: ?fn ([*c]IOleObject, DWORD, [*c]LPOLESTR) callconv(.C) HRESULT,
    SetExtent: ?fn ([*c]IOleObject, DWORD, [*c]SIZEL) callconv(.C) HRESULT,
    GetExtent: ?fn ([*c]IOleObject, DWORD, [*c]SIZEL) callconv(.C) HRESULT,
    Advise: ?fn ([*c]IOleObject, [*c]IAdviseSink, [*c]DWORD) callconv(.C) HRESULT,
    Unadvise: ?fn ([*c]IOleObject, DWORD) callconv(.C) HRESULT,
    EnumAdvise: ?fn ([*c]IOleObject, [*c]([*c]IEnumSTATDATA)) callconv(.C) HRESULT,
    GetMiscStatus: ?fn ([*c]IOleObject, DWORD, [*c]DWORD) callconv(.C) HRESULT,
    SetColorScheme: ?fn ([*c]IOleObject, [*c]LOGPALETTE) callconv(.C) HRESULT,
};
pub const struct_IOleObject = extern struct {
    lpVtbl: [*c]struct_IOleObjectVtbl,
};
pub const IOleWindow = struct_IOleWindow;
pub const struct_IOleWindowVtbl = extern struct {
    QueryInterface: ?fn ([*c]IOleWindow, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IOleWindow) callconv(.C) ULONG,
    Release: ?fn ([*c]IOleWindow) callconv(.C) ULONG,
    GetWindow: ?fn ([*c]IOleWindow, [*c]HWND) callconv(.C) HRESULT,
    ContextSensitiveHelp: ?fn ([*c]IOleWindow, BOOL) callconv(.C) HRESULT,
};
pub const struct_IOleWindow = extern struct {
    lpVtbl: [*c]struct_IOleWindowVtbl,
};
pub const IOleLink = struct_IOleLink;
pub const struct_IOleLinkVtbl = extern struct {
    QueryInterface: ?fn ([*c]IOleLink, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IOleLink) callconv(.C) ULONG,
    Release: ?fn ([*c]IOleLink) callconv(.C) ULONG,
    SetUpdateOptions: ?fn ([*c]IOleLink, DWORD) callconv(.C) HRESULT,
    GetUpdateOptions: ?fn ([*c]IOleLink, [*c]DWORD) callconv(.C) HRESULT,
    SetSourceMoniker: ?fn ([*c]IOleLink, [*c]IMoniker, [*c]const IID) callconv(.C) HRESULT,
    GetSourceMoniker: ?fn ([*c]IOleLink, [*c]([*c]IMoniker)) callconv(.C) HRESULT,
    SetSourceDisplayName: ?fn ([*c]IOleLink, LPCOLESTR) callconv(.C) HRESULT,
    GetSourceDisplayName: ?fn ([*c]IOleLink, [*c]LPOLESTR) callconv(.C) HRESULT,
    BindToSource: ?fn ([*c]IOleLink, DWORD, [*c]IBindCtx) callconv(.C) HRESULT,
    BindIfRunning: ?fn ([*c]IOleLink) callconv(.C) HRESULT,
    GetBoundSource: ?fn ([*c]IOleLink, [*c]([*c]IUnknown)) callconv(.C) HRESULT,
    UnbindSource: ?fn ([*c]IOleLink) callconv(.C) HRESULT,
    Update: ?fn ([*c]IOleLink, [*c]IBindCtx) callconv(.C) HRESULT,
};
pub const struct_IOleLink = extern struct {
    lpVtbl: [*c]struct_IOleLinkVtbl,
};
pub const IOleItemContainer = struct_IOleItemContainer;
pub const struct_IOleItemContainerVtbl = extern struct {
    QueryInterface: ?fn ([*c]IOleItemContainer, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IOleItemContainer) callconv(.C) ULONG,
    Release: ?fn ([*c]IOleItemContainer) callconv(.C) ULONG,
    ParseDisplayName: ?fn ([*c]IOleItemContainer, [*c]IBindCtx, LPOLESTR, [*c]ULONG, [*c]([*c]IMoniker)) callconv(.C) HRESULT,
    EnumObjects: ?fn ([*c]IOleItemContainer, DWORD, [*c]([*c]IEnumUnknown)) callconv(.C) HRESULT,
    LockContainer: ?fn ([*c]IOleItemContainer, BOOL) callconv(.C) HRESULT,
    GetObjectA: ?fn ([*c]IOleItemContainer, LPOLESTR, DWORD, [*c]IBindCtx, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    GetObjectStorage: ?fn ([*c]IOleItemContainer, LPOLESTR, [*c]IBindCtx, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    IsRunning: ?fn ([*c]IOleItemContainer, LPOLESTR) callconv(.C) HRESULT,
};
pub const struct_IOleItemContainer = extern struct {
    lpVtbl: [*c]struct_IOleItemContainerVtbl,
};
pub const IOleInPlaceUIWindow = struct_IOleInPlaceUIWindow;
pub const LPCBORDERWIDTHS = LPCRECT;
pub const struct_IOleInPlaceActiveObjectVtbl = extern struct {
    QueryInterface: ?fn ([*c]IOleInPlaceActiveObject, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IOleInPlaceActiveObject) callconv(.C) ULONG,
    Release: ?fn ([*c]IOleInPlaceActiveObject) callconv(.C) ULONG,
    GetWindow: ?fn ([*c]IOleInPlaceActiveObject, [*c]HWND) callconv(.C) HRESULT,
    ContextSensitiveHelp: ?fn ([*c]IOleInPlaceActiveObject, BOOL) callconv(.C) HRESULT,
    TranslateAcceleratorA: ?fn ([*c]IOleInPlaceActiveObject, LPMSG) callconv(.C) HRESULT,
    OnFrameWindowActivate: ?fn ([*c]IOleInPlaceActiveObject, BOOL) callconv(.C) HRESULT,
    OnDocWindowActivate: ?fn ([*c]IOleInPlaceActiveObject, BOOL) callconv(.C) HRESULT,
    ResizeBorder: ?fn ([*c]IOleInPlaceActiveObject, LPCRECT, [*c]IOleInPlaceUIWindow, BOOL) callconv(.C) HRESULT,
    EnableModeless: ?fn ([*c]IOleInPlaceActiveObject, BOOL) callconv(.C) HRESULT,
};
pub const struct_IOleInPlaceActiveObject = extern struct {
    lpVtbl: [*c]struct_IOleInPlaceActiveObjectVtbl,
};
pub const IOleInPlaceActiveObject = struct_IOleInPlaceActiveObject;
pub const struct_IOleInPlaceUIWindowVtbl = extern struct {
    QueryInterface: ?fn ([*c]IOleInPlaceUIWindow, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IOleInPlaceUIWindow) callconv(.C) ULONG,
    Release: ?fn ([*c]IOleInPlaceUIWindow) callconv(.C) ULONG,
    GetWindow: ?fn ([*c]IOleInPlaceUIWindow, [*c]HWND) callconv(.C) HRESULT,
    ContextSensitiveHelp: ?fn ([*c]IOleInPlaceUIWindow, BOOL) callconv(.C) HRESULT,
    GetBorder: ?fn ([*c]IOleInPlaceUIWindow, LPRECT) callconv(.C) HRESULT,
    RequestBorderSpace: ?fn ([*c]IOleInPlaceUIWindow, LPCBORDERWIDTHS) callconv(.C) HRESULT,
    SetBorderSpace: ?fn ([*c]IOleInPlaceUIWindow, LPCBORDERWIDTHS) callconv(.C) HRESULT,
    SetActiveObject: ?fn ([*c]IOleInPlaceUIWindow, [*c]IOleInPlaceActiveObject, LPCOLESTR) callconv(.C) HRESULT,
};
pub const struct_IOleInPlaceUIWindow = extern struct {
    lpVtbl: [*c]struct_IOleInPlaceUIWindowVtbl,
};
pub const IOleInPlaceFrame = struct_IOleInPlaceFrame;
pub const struct_tagOleMenuGroupWidths = extern struct {
    width: [6]LONG,
};
pub const LPOLEMENUGROUPWIDTHS = [*c]struct_tagOleMenuGroupWidths;
pub const HOLEMENU = HGLOBAL;
pub const struct_IOleInPlaceFrameVtbl = extern struct {
    QueryInterface: ?fn ([*c]IOleInPlaceFrame, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IOleInPlaceFrame) callconv(.C) ULONG,
    Release: ?fn ([*c]IOleInPlaceFrame) callconv(.C) ULONG,
    GetWindow: ?fn ([*c]IOleInPlaceFrame, [*c]HWND) callconv(.C) HRESULT,
    ContextSensitiveHelp: ?fn ([*c]IOleInPlaceFrame, BOOL) callconv(.C) HRESULT,
    GetBorder: ?fn ([*c]IOleInPlaceFrame, LPRECT) callconv(.C) HRESULT,
    RequestBorderSpace: ?fn ([*c]IOleInPlaceFrame, LPCBORDERWIDTHS) callconv(.C) HRESULT,
    SetBorderSpace: ?fn ([*c]IOleInPlaceFrame, LPCBORDERWIDTHS) callconv(.C) HRESULT,
    SetActiveObject: ?fn ([*c]IOleInPlaceFrame, [*c]IOleInPlaceActiveObject, LPCOLESTR) callconv(.C) HRESULT,
    InsertMenus: ?fn ([*c]IOleInPlaceFrame, HMENU, LPOLEMENUGROUPWIDTHS) callconv(.C) HRESULT,
    SetMenu: ?fn ([*c]IOleInPlaceFrame, HMENU, HOLEMENU, HWND) callconv(.C) HRESULT,
    RemoveMenus: ?fn ([*c]IOleInPlaceFrame, HMENU) callconv(.C) HRESULT,
    SetStatusText: ?fn ([*c]IOleInPlaceFrame, LPCOLESTR) callconv(.C) HRESULT,
    EnableModeless: ?fn ([*c]IOleInPlaceFrame, BOOL) callconv(.C) HRESULT,
    TranslateAcceleratorA: ?fn ([*c]IOleInPlaceFrame, LPMSG, WORD) callconv(.C) HRESULT,
};
pub const struct_IOleInPlaceFrame = extern struct {
    lpVtbl: [*c]struct_IOleInPlaceFrameVtbl,
};
pub const IOleInPlaceObject = struct_IOleInPlaceObject;
pub const struct_IOleInPlaceObjectVtbl = extern struct {
    QueryInterface: ?fn ([*c]IOleInPlaceObject, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IOleInPlaceObject) callconv(.C) ULONG,
    Release: ?fn ([*c]IOleInPlaceObject) callconv(.C) ULONG,
    GetWindow: ?fn ([*c]IOleInPlaceObject, [*c]HWND) callconv(.C) HRESULT,
    ContextSensitiveHelp: ?fn ([*c]IOleInPlaceObject, BOOL) callconv(.C) HRESULT,
    InPlaceDeactivate: ?fn ([*c]IOleInPlaceObject) callconv(.C) HRESULT,
    UIDeactivate: ?fn ([*c]IOleInPlaceObject) callconv(.C) HRESULT,
    SetObjectRects: ?fn ([*c]IOleInPlaceObject, LPCRECT, LPCRECT) callconv(.C) HRESULT,
    ReactivateAndUndo: ?fn ([*c]IOleInPlaceObject) callconv(.C) HRESULT,
};
pub const struct_IOleInPlaceObject = extern struct {
    lpVtbl: [*c]struct_IOleInPlaceObjectVtbl,
};
pub const IOleInPlaceSite = struct_IOleInPlaceSite;
pub const struct_tagOIFI = extern struct {
    cb: UINT,
    fMDIApp: BOOL,
    hwndFrame: HWND,
    haccel: HACCEL,
    cAccelEntries: UINT,
};
pub const LPOLEINPLACEFRAMEINFO = [*c]struct_tagOIFI;
pub const struct_IOleInPlaceSiteVtbl = extern struct {
    QueryInterface: ?fn ([*c]IOleInPlaceSite, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IOleInPlaceSite) callconv(.C) ULONG,
    Release: ?fn ([*c]IOleInPlaceSite) callconv(.C) ULONG,
    GetWindow: ?fn ([*c]IOleInPlaceSite, [*c]HWND) callconv(.C) HRESULT,
    ContextSensitiveHelp: ?fn ([*c]IOleInPlaceSite, BOOL) callconv(.C) HRESULT,
    CanInPlaceActivate: ?fn ([*c]IOleInPlaceSite) callconv(.C) HRESULT,
    OnInPlaceActivate: ?fn ([*c]IOleInPlaceSite) callconv(.C) HRESULT,
    OnUIActivate: ?fn ([*c]IOleInPlaceSite) callconv(.C) HRESULT,
    GetWindowContext: ?fn ([*c]IOleInPlaceSite, [*c]([*c]IOleInPlaceFrame), [*c]([*c]IOleInPlaceUIWindow), LPRECT, LPRECT, LPOLEINPLACEFRAMEINFO) callconv(.C) HRESULT,
    Scroll: ?fn ([*c]IOleInPlaceSite, SIZE) callconv(.C) HRESULT,
    OnUIDeactivate: ?fn ([*c]IOleInPlaceSite, BOOL) callconv(.C) HRESULT,
    OnInPlaceDeactivate: ?fn ([*c]IOleInPlaceSite) callconv(.C) HRESULT,
    DiscardUndoState: ?fn ([*c]IOleInPlaceSite) callconv(.C) HRESULT,
    DeactivateAndUndo: ?fn ([*c]IOleInPlaceSite) callconv(.C) HRESULT,
    OnPosRectChange: ?fn ([*c]IOleInPlaceSite, LPCRECT) callconv(.C) HRESULT,
};
pub const struct_IOleInPlaceSite = extern struct {
    lpVtbl: [*c]struct_IOleInPlaceSiteVtbl,
};
pub const IContinue = struct_IContinue;
pub const struct_IContinueVtbl = extern struct {
    QueryInterface: ?fn ([*c]IContinue, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IContinue) callconv(.C) ULONG,
    Release: ?fn ([*c]IContinue) callconv(.C) ULONG,
    FContinue: ?fn ([*c]IContinue) callconv(.C) HRESULT,
};
pub const struct_IContinue = extern struct {
    lpVtbl: [*c]struct_IContinueVtbl,
};
pub const IViewObject = struct_IViewObject;
pub const struct_IViewObjectVtbl = extern struct {
    QueryInterface: ?fn ([*c]IViewObject, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IViewObject) callconv(.C) ULONG,
    Release: ?fn ([*c]IViewObject) callconv(.C) ULONG,
    Draw: ?fn ([*c]IViewObject, DWORD, LONG, ?*c_void, [*c]DVTARGETDEVICE, HDC, HDC, LPCRECTL, LPCRECTL, ?fn (ULONG_PTR) callconv(.C) BOOL, ULONG_PTR) callconv(.C) HRESULT,
    GetColorSet: ?fn ([*c]IViewObject, DWORD, LONG, ?*c_void, [*c]DVTARGETDEVICE, HDC, [*c]([*c]LOGPALETTE)) callconv(.C) HRESULT,
    Freeze: ?fn ([*c]IViewObject, DWORD, LONG, ?*c_void, [*c]DWORD) callconv(.C) HRESULT,
    Unfreeze: ?fn ([*c]IViewObject, DWORD) callconv(.C) HRESULT,
    SetAdvise: ?fn ([*c]IViewObject, DWORD, DWORD, [*c]IAdviseSink) callconv(.C) HRESULT,
    GetAdvise: ?fn ([*c]IViewObject, [*c]DWORD, [*c]DWORD, [*c]([*c]IAdviseSink)) callconv(.C) HRESULT,
};
pub const struct_IViewObject = extern struct {
    lpVtbl: [*c]struct_IViewObjectVtbl,
};
pub const IViewObject2 = struct_IViewObject2;
pub const struct_IViewObject2Vtbl = extern struct {
    QueryInterface: ?fn ([*c]IViewObject2, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IViewObject2) callconv(.C) ULONG,
    Release: ?fn ([*c]IViewObject2) callconv(.C) ULONG,
    Draw: ?fn ([*c]IViewObject2, DWORD, LONG, ?*c_void, [*c]DVTARGETDEVICE, HDC, HDC, LPCRECTL, LPCRECTL, ?fn (ULONG_PTR) callconv(.C) BOOL, ULONG_PTR) callconv(.C) HRESULT,
    GetColorSet: ?fn ([*c]IViewObject2, DWORD, LONG, ?*c_void, [*c]DVTARGETDEVICE, HDC, [*c]([*c]LOGPALETTE)) callconv(.C) HRESULT,
    Freeze: ?fn ([*c]IViewObject2, DWORD, LONG, ?*c_void, [*c]DWORD) callconv(.C) HRESULT,
    Unfreeze: ?fn ([*c]IViewObject2, DWORD) callconv(.C) HRESULT,
    SetAdvise: ?fn ([*c]IViewObject2, DWORD, DWORD, [*c]IAdviseSink) callconv(.C) HRESULT,
    GetAdvise: ?fn ([*c]IViewObject2, [*c]DWORD, [*c]DWORD, [*c]([*c]IAdviseSink)) callconv(.C) HRESULT,
    GetExtent: ?fn ([*c]IViewObject2, DWORD, LONG, [*c]DVTARGETDEVICE, LPSIZEL) callconv(.C) HRESULT,
};
pub const struct_IViewObject2 = extern struct {
    lpVtbl: [*c]struct_IViewObject2Vtbl,
};
pub const IDropSource = struct_IDropSource;
pub const struct_IDropSourceVtbl = extern struct {
    QueryInterface: ?fn ([*c]IDropSource, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IDropSource) callconv(.C) ULONG,
    Release: ?fn ([*c]IDropSource) callconv(.C) ULONG,
    QueryContinueDrag: ?fn ([*c]IDropSource, BOOL, DWORD) callconv(.C) HRESULT,
    GiveFeedback: ?fn ([*c]IDropSource, DWORD) callconv(.C) HRESULT,
};
pub const struct_IDropSource = extern struct {
    lpVtbl: [*c]struct_IDropSourceVtbl,
};
pub const IDropTarget = struct_IDropTarget;
pub const struct_IDropTargetVtbl = extern struct {
    QueryInterface: ?fn ([*c]IDropTarget, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IDropTarget) callconv(.C) ULONG,
    Release: ?fn ([*c]IDropTarget) callconv(.C) ULONG,
    DragEnter: ?fn ([*c]IDropTarget, [*c]IDataObject, DWORD, POINTL, [*c]DWORD) callconv(.C) HRESULT,
    DragOver: ?fn ([*c]IDropTarget, DWORD, POINTL, [*c]DWORD) callconv(.C) HRESULT,
    DragLeave: ?fn ([*c]IDropTarget) callconv(.C) HRESULT,
    Drop: ?fn ([*c]IDropTarget, [*c]IDataObject, DWORD, POINTL, [*c]DWORD) callconv(.C) HRESULT,
};
pub const struct_IDropTarget = extern struct {
    lpVtbl: [*c]struct_IDropTargetVtbl,
};
pub const IDropSourceNotify = struct_IDropSourceNotify;
pub const struct_IDropSourceNotifyVtbl = extern struct {
    QueryInterface: ?fn ([*c]IDropSourceNotify, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IDropSourceNotify) callconv(.C) ULONG,
    Release: ?fn ([*c]IDropSourceNotify) callconv(.C) ULONG,
    DragEnterTarget: ?fn ([*c]IDropSourceNotify, HWND) callconv(.C) HRESULT,
    DragLeaveTarget: ?fn ([*c]IDropSourceNotify) callconv(.C) HRESULT,
};
pub const struct_IDropSourceNotify = extern struct {
    lpVtbl: [*c]struct_IDropSourceNotifyVtbl,
};
pub const IEnterpriseDropTarget = struct_IEnterpriseDropTarget;
pub const struct_IEnterpriseDropTargetVtbl = extern struct {
    QueryInterface: ?fn ([*c]IEnterpriseDropTarget, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IEnterpriseDropTarget) callconv(.C) ULONG,
    Release: ?fn ([*c]IEnterpriseDropTarget) callconv(.C) ULONG,
    SetDropSourceEnterpriseId: ?fn ([*c]IEnterpriseDropTarget, LPCWSTR) callconv(.C) HRESULT,
    IsEvaluatingEdpPolicy: ?fn ([*c]IEnterpriseDropTarget, [*c]BOOL) callconv(.C) HRESULT,
};
pub const struct_IEnterpriseDropTarget = extern struct {
    lpVtbl: [*c]struct_IEnterpriseDropTargetVtbl,
};
pub extern var __MIDL_itf_oleidl_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_oleidl_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPOLEADVISEHOLDER = [*c]IOleAdviseHolder;
pub extern const IID_IOleAdviseHolder: IID;
pub const IOleAdviseHolderVtbl = struct_IOleAdviseHolderVtbl;
pub extern var __MIDL_itf_oleidl_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_oleidl_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPOLECACHE = [*c]IOleCache;
pub extern const IID_IOleCache: IID;
pub const IOleCacheVtbl = struct_IOleCacheVtbl;
pub const LPOLECACHE2 = [*c]IOleCache2;
pub const DISCARDCACHE_SAVEIFDIRTY = enum_tagDISCARDCACHE.DISCARDCACHE_SAVEIFDIRTY;
pub const DISCARDCACHE_NOSAVE = enum_tagDISCARDCACHE.DISCARDCACHE_NOSAVE;
pub const enum_tagDISCARDCACHE = extern enum {
    DISCARDCACHE_SAVEIFDIRTY = 0,
    DISCARDCACHE_NOSAVE = 1,
};
pub const DISCARDCACHE = enum_tagDISCARDCACHE;
pub extern const IID_IOleCache2: IID;
pub const IOleCache2Vtbl = struct_IOleCache2Vtbl;
pub extern fn IOleCache2_RemoteUpdateCache_Proxy(This: [*c]IOleCache2, pDataObject: LPDATAOBJECT, grfUpdf: DWORD, pReserved: LONG_PTR) HRESULT;
pub extern fn IOleCache2_RemoteUpdateCache_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_oleidl_0000_0003_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_oleidl_0000_0003_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPOLECACHECONTROL = [*c]IOleCacheControl;
pub extern const IID_IOleCacheControl: IID;
pub const IOleCacheControlVtbl = struct_IOleCacheControlVtbl;
pub const LPPARSEDISPLAYNAME = [*c]IParseDisplayName;
pub extern const IID_IParseDisplayName: IID;
pub const IParseDisplayNameVtbl = struct_IParseDisplayNameVtbl;
pub const LPOLECONTAINER = [*c]IOleContainer;
pub extern const IID_IOleContainer: IID;
pub const IOleContainerVtbl = struct_IOleContainerVtbl;
pub const LPOLECLIENTSITE = [*c]IOleClientSite;
pub extern const IID_IOleClientSite: IID;
pub const IOleClientSiteVtbl = struct_IOleClientSiteVtbl;
pub const LPOLEOBJECT = [*c]IOleObject;
pub const OLEGETMONIKER_ONLYIFTHERE = enum_tagOLEGETMONIKER.OLEGETMONIKER_ONLYIFTHERE;
pub const OLEGETMONIKER_FORCEASSIGN = enum_tagOLEGETMONIKER.OLEGETMONIKER_FORCEASSIGN;
pub const OLEGETMONIKER_UNASSIGN = enum_tagOLEGETMONIKER.OLEGETMONIKER_UNASSIGN;
pub const OLEGETMONIKER_TEMPFORUSER = enum_tagOLEGETMONIKER.OLEGETMONIKER_TEMPFORUSER;
pub const enum_tagOLEGETMONIKER = extern enum {
    OLEGETMONIKER_ONLYIFTHERE = 1,
    OLEGETMONIKER_FORCEASSIGN = 2,
    OLEGETMONIKER_UNASSIGN = 3,
    OLEGETMONIKER_TEMPFORUSER = 4,
};
pub const OLEGETMONIKER = enum_tagOLEGETMONIKER;
pub const OLEWHICHMK_CONTAINER = enum_tagOLEWHICHMK.OLEWHICHMK_CONTAINER;
pub const OLEWHICHMK_OBJREL = enum_tagOLEWHICHMK.OLEWHICHMK_OBJREL;
pub const OLEWHICHMK_OBJFULL = enum_tagOLEWHICHMK.OLEWHICHMK_OBJFULL;
pub const enum_tagOLEWHICHMK = extern enum {
    OLEWHICHMK_CONTAINER = 1,
    OLEWHICHMK_OBJREL = 2,
    OLEWHICHMK_OBJFULL = 3,
};
pub const OLEWHICHMK = enum_tagOLEWHICHMK;
pub const USERCLASSTYPE_FULL = enum_tagUSERCLASSTYPE.USERCLASSTYPE_FULL;
pub const USERCLASSTYPE_SHORT = enum_tagUSERCLASSTYPE.USERCLASSTYPE_SHORT;
pub const USERCLASSTYPE_APPNAME = enum_tagUSERCLASSTYPE.USERCLASSTYPE_APPNAME;
pub const enum_tagUSERCLASSTYPE = extern enum {
    USERCLASSTYPE_FULL = 1,
    USERCLASSTYPE_SHORT = 2,
    USERCLASSTYPE_APPNAME = 3,
};
pub const USERCLASSTYPE = enum_tagUSERCLASSTYPE;
pub const OLEMISC_RECOMPOSEONRESIZE = enum_tagOLEMISC.OLEMISC_RECOMPOSEONRESIZE;
pub const OLEMISC_ONLYICONIC = enum_tagOLEMISC.OLEMISC_ONLYICONIC;
pub const OLEMISC_INSERTNOTREPLACE = enum_tagOLEMISC.OLEMISC_INSERTNOTREPLACE;
pub const OLEMISC_STATIC = enum_tagOLEMISC.OLEMISC_STATIC;
pub const OLEMISC_CANTLINKINSIDE = enum_tagOLEMISC.OLEMISC_CANTLINKINSIDE;
pub const OLEMISC_CANLINKBYOLE1 = enum_tagOLEMISC.OLEMISC_CANLINKBYOLE1;
pub const OLEMISC_ISLINKOBJECT = enum_tagOLEMISC.OLEMISC_ISLINKOBJECT;
pub const OLEMISC_INSIDEOUT = enum_tagOLEMISC.OLEMISC_INSIDEOUT;
pub const OLEMISC_ACTIVATEWHENVISIBLE = enum_tagOLEMISC.OLEMISC_ACTIVATEWHENVISIBLE;
pub const OLEMISC_RENDERINGISDEVICEINDEPENDENT = enum_tagOLEMISC.OLEMISC_RENDERINGISDEVICEINDEPENDENT;
pub const OLEMISC_INVISIBLEATRUNTIME = enum_tagOLEMISC.OLEMISC_INVISIBLEATRUNTIME;
pub const OLEMISC_ALWAYSRUN = enum_tagOLEMISC.OLEMISC_ALWAYSRUN;
pub const OLEMISC_ACTSLIKEBUTTON = enum_tagOLEMISC.OLEMISC_ACTSLIKEBUTTON;
pub const OLEMISC_ACTSLIKELABEL = enum_tagOLEMISC.OLEMISC_ACTSLIKELABEL;
pub const OLEMISC_NOUIACTIVATE = enum_tagOLEMISC.OLEMISC_NOUIACTIVATE;
pub const OLEMISC_ALIGNABLE = enum_tagOLEMISC.OLEMISC_ALIGNABLE;
pub const OLEMISC_SIMPLEFRAME = enum_tagOLEMISC.OLEMISC_SIMPLEFRAME;
pub const OLEMISC_SETCLIENTSITEFIRST = enum_tagOLEMISC.OLEMISC_SETCLIENTSITEFIRST;
pub const OLEMISC_IMEMODE = enum_tagOLEMISC.OLEMISC_IMEMODE;
pub const OLEMISC_IGNOREACTIVATEWHENVISIBLE = enum_tagOLEMISC.OLEMISC_IGNOREACTIVATEWHENVISIBLE;
pub const OLEMISC_WANTSTOMENUMERGE = enum_tagOLEMISC.OLEMISC_WANTSTOMENUMERGE;
pub const OLEMISC_SUPPORTSMULTILEVELUNDO = enum_tagOLEMISC.OLEMISC_SUPPORTSMULTILEVELUNDO;
pub const enum_tagOLEMISC = extern enum {
    OLEMISC_RECOMPOSEONRESIZE = 1,
    OLEMISC_ONLYICONIC = 2,
    OLEMISC_INSERTNOTREPLACE = 4,
    OLEMISC_STATIC = 8,
    OLEMISC_CANTLINKINSIDE = 16,
    OLEMISC_CANLINKBYOLE1 = 32,
    OLEMISC_ISLINKOBJECT = 64,
    OLEMISC_INSIDEOUT = 128,
    OLEMISC_ACTIVATEWHENVISIBLE = 256,
    OLEMISC_RENDERINGISDEVICEINDEPENDENT = 512,
    OLEMISC_INVISIBLEATRUNTIME = 1024,
    OLEMISC_ALWAYSRUN = 2048,
    OLEMISC_ACTSLIKEBUTTON = 4096,
    OLEMISC_ACTSLIKELABEL = 8192,
    OLEMISC_NOUIACTIVATE = 16384,
    OLEMISC_ALIGNABLE = 32768,
    OLEMISC_SIMPLEFRAME = 65536,
    OLEMISC_SETCLIENTSITEFIRST = 131072,
    OLEMISC_IMEMODE = 262144,
    OLEMISC_IGNOREACTIVATEWHENVISIBLE = 524288,
    OLEMISC_WANTSTOMENUMERGE = 1048576,
    OLEMISC_SUPPORTSMULTILEVELUNDO = 2097152,
};
pub const OLEMISC = enum_tagOLEMISC;
pub const OLECLOSE_SAVEIFDIRTY = enum_tagOLECLOSE.OLECLOSE_SAVEIFDIRTY;
pub const OLECLOSE_NOSAVE = enum_tagOLECLOSE.OLECLOSE_NOSAVE;
pub const OLECLOSE_PROMPTSAVE = enum_tagOLECLOSE.OLECLOSE_PROMPTSAVE;
pub const enum_tagOLECLOSE = extern enum {
    OLECLOSE_SAVEIFDIRTY = 0,
    OLECLOSE_NOSAVE = 1,
    OLECLOSE_PROMPTSAVE = 2,
};
pub const OLECLOSE = enum_tagOLECLOSE;
pub extern const IID_IOleObject: IID;
pub const IOleObjectVtbl = struct_IOleObjectVtbl;
pub const OLERENDER_NONE = enum_tagOLERENDER.OLERENDER_NONE;
pub const OLERENDER_DRAW = enum_tagOLERENDER.OLERENDER_DRAW;
pub const OLERENDER_FORMAT = enum_tagOLERENDER.OLERENDER_FORMAT;
pub const OLERENDER_ASIS = enum_tagOLERENDER.OLERENDER_ASIS;
pub const enum_tagOLERENDER = extern enum {
    OLERENDER_NONE = 0,
    OLERENDER_DRAW = 1,
    OLERENDER_FORMAT = 2,
    OLERENDER_ASIS = 3,
};
pub const OLERENDER = enum_tagOLERENDER;
pub const LPOLERENDER = [*c]OLERENDER;
pub const struct_tagOBJECTDESCRIPTOR = extern struct {
    cbSize: ULONG,
    clsid: CLSID,
    dwDrawAspect: DWORD,
    sizel: SIZEL,
    pointl: POINTL,
    dwStatus: DWORD,
    dwFullUserTypeName: DWORD,
    dwSrcOfCopy: DWORD,
};
pub const OBJECTDESCRIPTOR = struct_tagOBJECTDESCRIPTOR;
pub const POBJECTDESCRIPTOR = [*c]struct_tagOBJECTDESCRIPTOR;
pub const LPOBJECTDESCRIPTOR = [*c]struct_tagOBJECTDESCRIPTOR;
pub const LINKSRCDESCRIPTOR = struct_tagOBJECTDESCRIPTOR;
pub const PLINKSRCDESCRIPTOR = [*c]struct_tagOBJECTDESCRIPTOR;
pub const LPLINKSRCDESCRIPTOR = [*c]struct_tagOBJECTDESCRIPTOR;
pub extern var IOLETypes_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var IOLETypes_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPOLEWINDOW = [*c]IOleWindow;
pub extern const IID_IOleWindow: IID;
pub const IOleWindowVtbl = struct_IOleWindowVtbl;
pub const LPOLELINK = [*c]IOleLink;
pub const OLEUPDATE_ALWAYS = enum_tagOLEUPDATE.OLEUPDATE_ALWAYS;
pub const OLEUPDATE_ONCALL = enum_tagOLEUPDATE.OLEUPDATE_ONCALL;
pub const enum_tagOLEUPDATE = extern enum {
    OLEUPDATE_ALWAYS = 1,
    OLEUPDATE_ONCALL = 3,
};
pub const OLEUPDATE = enum_tagOLEUPDATE;
pub const LPOLEUPDATE = [*c]OLEUPDATE;
pub const POLEUPDATE = [*c]OLEUPDATE;
pub const OLELINKBIND_EVENIFCLASSDIFF = enum_tagOLELINKBIND.OLELINKBIND_EVENIFCLASSDIFF;
pub const enum_tagOLELINKBIND = extern enum {
    OLELINKBIND_EVENIFCLASSDIFF = 1,
};
pub const OLELINKBIND = enum_tagOLELINKBIND;
pub extern const IID_IOleLink: IID;
pub const IOleLinkVtbl = struct_IOleLinkVtbl;
pub const LPOLEITEMCONTAINER = [*c]IOleItemContainer;
pub const BINDSPEED_INDEFINITE = enum_tagBINDSPEED.BINDSPEED_INDEFINITE;
pub const BINDSPEED_MODERATE = enum_tagBINDSPEED.BINDSPEED_MODERATE;
pub const BINDSPEED_IMMEDIATE = enum_tagBINDSPEED.BINDSPEED_IMMEDIATE;
pub const enum_tagBINDSPEED = extern enum {
    BINDSPEED_INDEFINITE = 1,
    BINDSPEED_MODERATE = 2,
    BINDSPEED_IMMEDIATE = 3,
};
pub const BINDSPEED = enum_tagBINDSPEED;
pub const OLECONTF_EMBEDDINGS = enum_tagOLECONTF.OLECONTF_EMBEDDINGS;
pub const OLECONTF_LINKS = enum_tagOLECONTF.OLECONTF_LINKS;
pub const OLECONTF_OTHERS = enum_tagOLECONTF.OLECONTF_OTHERS;
pub const OLECONTF_ONLYUSER = enum_tagOLECONTF.OLECONTF_ONLYUSER;
pub const OLECONTF_ONLYIFRUNNING = enum_tagOLECONTF.OLECONTF_ONLYIFRUNNING;
pub const enum_tagOLECONTF = extern enum {
    OLECONTF_EMBEDDINGS = 1,
    OLECONTF_LINKS = 2,
    OLECONTF_OTHERS = 4,
    OLECONTF_ONLYUSER = 8,
    OLECONTF_ONLYIFRUNNING = 16,
};
pub const OLECONTF = enum_tagOLECONTF;
pub extern const IID_IOleItemContainer: IID;
pub const IOleItemContainerVtbl = struct_IOleItemContainerVtbl;
pub const LPOLEINPLACEUIWINDOW = [*c]IOleInPlaceUIWindow;
pub const BORDERWIDTHS = RECT;
pub const LPBORDERWIDTHS = LPRECT;
pub extern const IID_IOleInPlaceUIWindow: IID;
pub const IOleInPlaceUIWindowVtbl = struct_IOleInPlaceUIWindowVtbl;
pub const LPOLEINPLACEACTIVEOBJECT = [*c]IOleInPlaceActiveObject;
pub extern const IID_IOleInPlaceActiveObject: IID;
pub const IOleInPlaceActiveObjectVtbl = struct_IOleInPlaceActiveObjectVtbl;
pub extern fn IOleInPlaceActiveObject_RemoteTranslateAccelerator_Proxy(This: [*c]IOleInPlaceActiveObject) HRESULT;
pub extern fn IOleInPlaceActiveObject_RemoteTranslateAccelerator_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IOleInPlaceActiveObject_RemoteResizeBorder_Proxy(This: [*c]IOleInPlaceActiveObject, prcBorder: LPCRECT, riid: [*c]const IID, pUIWindow: [*c]IOleInPlaceUIWindow, fFrameWindow: BOOL) HRESULT;
pub extern fn IOleInPlaceActiveObject_RemoteResizeBorder_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub const LPOLEINPLACEFRAME = [*c]IOleInPlaceFrame;
pub const OLEINPLACEFRAMEINFO = struct_tagOIFI;
pub const OLEMENUGROUPWIDTHS = struct_tagOleMenuGroupWidths;
pub extern const IID_IOleInPlaceFrame: IID;
pub const IOleInPlaceFrameVtbl = struct_IOleInPlaceFrameVtbl;
pub const LPOLEINPLACEOBJECT = [*c]IOleInPlaceObject;
pub extern const IID_IOleInPlaceObject: IID;
pub const IOleInPlaceObjectVtbl = struct_IOleInPlaceObjectVtbl;
pub const LPOLEINPLACESITE = [*c]IOleInPlaceSite;
pub extern const IID_IOleInPlaceSite: IID;
pub const IOleInPlaceSiteVtbl = struct_IOleInPlaceSiteVtbl;
pub extern const IID_IContinue: IID;
pub const IContinueVtbl = struct_IContinueVtbl;
pub const LPVIEWOBJECT = [*c]IViewObject;
pub extern const IID_IViewObject: IID;
pub const IViewObjectVtbl = struct_IViewObjectVtbl;
pub extern fn IViewObject_RemoteDraw_Proxy(This: [*c]IViewObject, dwDrawAspect: DWORD, lindex: LONG, pvAspect: ULONG_PTR, ptd: [*c]DVTARGETDEVICE, hdcTargetDev: HDC, hdcDraw: HDC, lprcBounds: LPCRECTL, lprcWBounds: LPCRECTL, pContinue: [*c]IContinue) HRESULT;
pub extern fn IViewObject_RemoteDraw_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IViewObject_RemoteGetColorSet_Proxy(This: [*c]IViewObject, dwDrawAspect: DWORD, lindex: LONG, pvAspect: ULONG_PTR, ptd: [*c]DVTARGETDEVICE, hicTargetDev: ULONG_PTR, ppColorSet: [*c]([*c]LOGPALETTE)) HRESULT;
pub extern fn IViewObject_RemoteGetColorSet_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IViewObject_RemoteFreeze_Proxy(This: [*c]IViewObject, dwDrawAspect: DWORD, lindex: LONG, pvAspect: ULONG_PTR, pdwFreeze: [*c]DWORD) HRESULT;
pub extern fn IViewObject_RemoteFreeze_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IViewObject_RemoteGetAdvise_Proxy(This: [*c]IViewObject, pAspects: [*c]DWORD, pAdvf: [*c]DWORD, ppAdvSink: [*c]([*c]IAdviseSink)) HRESULT;
pub extern fn IViewObject_RemoteGetAdvise_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub const LPVIEWOBJECT2 = [*c]IViewObject2;
pub extern const IID_IViewObject2: IID;
pub const IViewObject2Vtbl = struct_IViewObject2Vtbl;
pub const LPDROPSOURCE = [*c]IDropSource;
pub extern const IID_IDropSource: IID;
pub const IDropSourceVtbl = struct_IDropSourceVtbl;
pub const LPDROPTARGET = [*c]IDropTarget;
pub extern const IID_IDropTarget: IID;
pub const IDropTargetVtbl = struct_IDropTargetVtbl;
pub extern const IID_IDropSourceNotify: IID;
pub const IDropSourceNotifyVtbl = struct_IDropSourceNotifyVtbl;
pub extern const IID_IEnterpriseDropTarget: IID;
pub const IEnterpriseDropTargetVtbl = struct_IEnterpriseDropTargetVtbl;
pub extern var __MIDL_itf_oleidl_0000_0024_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_oleidl_0000_0024_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPENUMOLEVERB = [*c]IEnumOLEVERB;
pub const OLEVERB = struct_tagOLEVERB;
pub const OLEVERBATTRIB_NEVERDIRTIES = enum_tagOLEVERBATTRIB.OLEVERBATTRIB_NEVERDIRTIES;
pub const OLEVERBATTRIB_ONCONTAINERMENU = enum_tagOLEVERBATTRIB.OLEVERBATTRIB_ONCONTAINERMENU;
pub const enum_tagOLEVERBATTRIB = extern enum {
    OLEVERBATTRIB_NEVERDIRTIES = 1,
    OLEVERBATTRIB_ONCONTAINERMENU = 2,
};
pub const OLEVERBATTRIB = enum_tagOLEVERBATTRIB;
pub extern const IID_IEnumOLEVERB: IID;
pub const IEnumOLEVERBVtbl = struct_IEnumOLEVERBVtbl;
pub extern fn IEnumOLEVERB_RemoteNext_Proxy(This: [*c]IEnumOLEVERB, celt: ULONG, rgelt: LPOLEVERB, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumOLEVERB_RemoteNext_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_oleidl_0000_0025_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_oleidl_0000_0025_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern fn HACCEL_UserSize(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]HACCEL) c_ulong;
pub extern fn HACCEL_UserMarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HACCEL) [*c]u8;
pub extern fn HACCEL_UserUnmarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HACCEL) [*c]u8;
pub extern fn HACCEL_UserFree(arg0: [*c]c_ulong, arg1: [*c]HACCEL) void;
pub extern fn HGLOBAL_UserSize(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]HGLOBAL) c_ulong;
pub extern fn HGLOBAL_UserMarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HGLOBAL) [*c]u8;
pub extern fn HGLOBAL_UserUnmarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HGLOBAL) [*c]u8;
pub extern fn HGLOBAL_UserFree(arg0: [*c]c_ulong, arg1: [*c]HGLOBAL) void;
pub extern fn HMENU_UserSize(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]HMENU) c_ulong;
pub extern fn HMENU_UserMarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HMENU) [*c]u8;
pub extern fn HMENU_UserUnmarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HMENU) [*c]u8;
pub extern fn HMENU_UserFree(arg0: [*c]c_ulong, arg1: [*c]HMENU) void;
pub extern fn HWND_UserSize(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]HWND) c_ulong;
pub extern fn HWND_UserMarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HWND) [*c]u8;
pub extern fn HWND_UserUnmarshal(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HWND) [*c]u8;
pub extern fn HWND_UserFree(arg0: [*c]c_ulong, arg1: [*c]HWND) void;
pub extern fn HACCEL_UserSize64(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]HACCEL) c_ulong;
pub extern fn HACCEL_UserMarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HACCEL) [*c]u8;
pub extern fn HACCEL_UserUnmarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HACCEL) [*c]u8;
pub extern fn HACCEL_UserFree64(arg0: [*c]c_ulong, arg1: [*c]HACCEL) void;
pub extern fn HGLOBAL_UserSize64(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]HGLOBAL) c_ulong;
pub extern fn HGLOBAL_UserMarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HGLOBAL) [*c]u8;
pub extern fn HGLOBAL_UserUnmarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HGLOBAL) [*c]u8;
pub extern fn HGLOBAL_UserFree64(arg0: [*c]c_ulong, arg1: [*c]HGLOBAL) void;
pub extern fn HMENU_UserSize64(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]HMENU) c_ulong;
pub extern fn HMENU_UserMarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HMENU) [*c]u8;
pub extern fn HMENU_UserUnmarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HMENU) [*c]u8;
pub extern fn HMENU_UserFree64(arg0: [*c]c_ulong, arg1: [*c]HMENU) void;
pub extern fn HWND_UserSize64(arg0: [*c]c_ulong, arg1: c_ulong, arg2: [*c]HWND) c_ulong;
pub extern fn HWND_UserMarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HWND) [*c]u8;
pub extern fn HWND_UserUnmarshal64(arg0: [*c]c_ulong, arg1: [*c]u8, arg2: [*c]HWND) [*c]u8;
pub extern fn HWND_UserFree64(arg0: [*c]c_ulong, arg1: [*c]HWND) void;
pub extern fn IOleCache2_UpdateCache_Proxy(This: [*c]IOleCache2, pDataObject: LPDATAOBJECT, grfUpdf: DWORD, pReserved: LPVOID) HRESULT;
pub extern fn IOleCache2_UpdateCache_Stub(This: [*c]IOleCache2, pDataObject: LPDATAOBJECT, grfUpdf: DWORD, pReserved: LONG_PTR) HRESULT;
pub extern fn IOleInPlaceActiveObject_TranslateAccelerator_Proxy(This: [*c]IOleInPlaceActiveObject, lpmsg: LPMSG) HRESULT;
pub extern fn IOleInPlaceActiveObject_TranslateAccelerator_Stub(This: [*c]IOleInPlaceActiveObject) HRESULT;
pub extern fn IOleInPlaceActiveObject_ResizeBorder_Proxy(This: [*c]IOleInPlaceActiveObject, prcBorder: LPCRECT, pUIWindow: [*c]IOleInPlaceUIWindow, fFrameWindow: BOOL) HRESULT;
pub extern fn IOleInPlaceActiveObject_ResizeBorder_Stub(This: [*c]IOleInPlaceActiveObject, prcBorder: LPCRECT, riid: [*c]const IID, pUIWindow: [*c]IOleInPlaceUIWindow, fFrameWindow: BOOL) HRESULT;
pub extern fn IViewObject_Draw_Proxy(This: [*c]IViewObject, dwDrawAspect: DWORD, lindex: LONG, pvAspect: ?*c_void, ptd: [*c]DVTARGETDEVICE, hdcTargetDev: HDC, hdcDraw: HDC, lprcBounds: LPCRECTL, lprcWBounds: LPCRECTL, pfnContinue: ?fn (ULONG_PTR) callconv(.C) BOOL, dwContinue: ULONG_PTR) HRESULT;
pub extern fn IViewObject_Draw_Stub(This: [*c]IViewObject, dwDrawAspect: DWORD, lindex: LONG, pvAspect: ULONG_PTR, ptd: [*c]DVTARGETDEVICE, hdcTargetDev: HDC, hdcDraw: HDC, lprcBounds: LPCRECTL, lprcWBounds: LPCRECTL, pContinue: [*c]IContinue) HRESULT;
pub extern fn IViewObject_GetColorSet_Proxy(This: [*c]IViewObject, dwDrawAspect: DWORD, lindex: LONG, pvAspect: ?*c_void, ptd: [*c]DVTARGETDEVICE, hicTargetDev: HDC, ppColorSet: [*c]([*c]LOGPALETTE)) HRESULT;
pub extern fn IViewObject_GetColorSet_Stub(This: [*c]IViewObject, dwDrawAspect: DWORD, lindex: LONG, pvAspect: ULONG_PTR, ptd: [*c]DVTARGETDEVICE, hicTargetDev: ULONG_PTR, ppColorSet: [*c]([*c]LOGPALETTE)) HRESULT;
pub extern fn IViewObject_Freeze_Proxy(This: [*c]IViewObject, dwDrawAspect: DWORD, lindex: LONG, pvAspect: ?*c_void, pdwFreeze: [*c]DWORD) HRESULT;
pub extern fn IViewObject_Freeze_Stub(This: [*c]IViewObject, dwDrawAspect: DWORD, lindex: LONG, pvAspect: ULONG_PTR, pdwFreeze: [*c]DWORD) HRESULT;
pub extern fn IViewObject_GetAdvise_Proxy(This: [*c]IViewObject, pAspects: [*c]DWORD, pAdvf: [*c]DWORD, ppAdvSink: [*c]([*c]IAdviseSink)) HRESULT;
pub extern fn IViewObject_GetAdvise_Stub(This: [*c]IViewObject, pAspects: [*c]DWORD, pAdvf: [*c]DWORD, ppAdvSink: [*c]([*c]IAdviseSink)) HRESULT;
pub extern fn IEnumOLEVERB_Next_Proxy(This: [*c]IEnumOLEVERB, celt: ULONG, rgelt: LPOLEVERB, pceltFetched: [*c]ULONG) HRESULT;
pub extern fn IEnumOLEVERB_Next_Stub(This: [*c]IEnumOLEVERB, celt: ULONG, rgelt: LPOLEVERB, pceltFetched: [*c]ULONG) HRESULT;
pub const IServiceProvider = struct_IServiceProvider;
pub const struct_IServiceProviderVtbl = extern struct {
    QueryInterface: ?fn ([*c]IServiceProvider, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IServiceProvider) callconv(.C) ULONG,
    Release: ?fn ([*c]IServiceProvider) callconv(.C) ULONG,
    QueryService: ?fn ([*c]IServiceProvider, [*c]const GUID, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
};
pub const struct_IServiceProvider = extern struct {
    lpVtbl: [*c]struct_IServiceProviderVtbl,
};
pub extern var __MIDL_itf_servprov_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_servprov_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPSERVICEPROVIDER = [*c]IServiceProvider;
pub extern const IID_IServiceProvider: IID;
pub const IServiceProviderVtbl = struct_IServiceProviderVtbl;
pub extern fn IServiceProvider_RemoteQueryService_Proxy(This: [*c]IServiceProvider, guidService: [*c]const GUID, riid: [*c]const IID, ppvObject: [*c]([*c]IUnknown)) HRESULT;
pub extern fn IServiceProvider_RemoteQueryService_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_servprov_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_servprov_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern fn IServiceProvider_QueryService_Proxy(This: [*c]IServiceProvider, guidService: [*c]const GUID, riid: [*c]const IID, ppvObject: [*c](?*c_void)) HRESULT;
pub extern fn IServiceProvider_QueryService_Stub(This: [*c]IServiceProvider, guidService: [*c]const GUID, riid: [*c]const IID, ppvObject: [*c]([*c]IUnknown)) HRESULT;
pub const IXMLDOMImplementation = struct_IXMLDOMImplementation;
pub const struct_IXMLDOMImplementationVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMImplementation, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMImplementation) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMImplementation) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMImplementation, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMImplementation, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMImplementation, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMImplementation, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    hasFeature: ?fn ([*c]IXMLDOMImplementation, BSTR, BSTR, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMImplementation = extern struct {
    lpVtbl: [*c]struct_IXMLDOMImplementationVtbl,
};
pub const IXMLDOMNode = struct_IXMLDOMNode;
pub const NODE_INVALID = enum_tagDOMNodeType.NODE_INVALID;
pub const NODE_ELEMENT = enum_tagDOMNodeType.NODE_ELEMENT;
pub const NODE_ATTRIBUTE = enum_tagDOMNodeType.NODE_ATTRIBUTE;
pub const NODE_TEXT = enum_tagDOMNodeType.NODE_TEXT;
pub const NODE_CDATA_SECTION = enum_tagDOMNodeType.NODE_CDATA_SECTION;
pub const NODE_ENTITY_REFERENCE = enum_tagDOMNodeType.NODE_ENTITY_REFERENCE;
pub const NODE_ENTITY = enum_tagDOMNodeType.NODE_ENTITY;
pub const NODE_PROCESSING_INSTRUCTION = enum_tagDOMNodeType.NODE_PROCESSING_INSTRUCTION;
pub const NODE_COMMENT = enum_tagDOMNodeType.NODE_COMMENT;
pub const NODE_DOCUMENT = enum_tagDOMNodeType.NODE_DOCUMENT;
pub const NODE_DOCUMENT_TYPE = enum_tagDOMNodeType.NODE_DOCUMENT_TYPE;
pub const NODE_DOCUMENT_FRAGMENT = enum_tagDOMNodeType.NODE_DOCUMENT_FRAGMENT;
pub const NODE_NOTATION = enum_tagDOMNodeType.NODE_NOTATION;
pub const enum_tagDOMNodeType = extern enum {
    NODE_INVALID = 0,
    NODE_ELEMENT = 1,
    NODE_ATTRIBUTE = 2,
    NODE_TEXT = 3,
    NODE_CDATA_SECTION = 4,
    NODE_ENTITY_REFERENCE = 5,
    NODE_ENTITY = 6,
    NODE_PROCESSING_INSTRUCTION = 7,
    NODE_COMMENT = 8,
    NODE_DOCUMENT = 9,
    NODE_DOCUMENT_TYPE = 10,
    NODE_DOCUMENT_FRAGMENT = 11,
    NODE_NOTATION = 12,
};
pub const DOMNodeType = extern enum {
    NODE_INVALID = 0,
    NODE_ELEMENT = 1,
    NODE_ATTRIBUTE = 2,
    NODE_TEXT = 3,
    NODE_CDATA_SECTION = 4,
    NODE_ENTITY_REFERENCE = 5,
    NODE_ENTITY = 6,
    NODE_PROCESSING_INSTRUCTION = 7,
    NODE_COMMENT = 8,
    NODE_DOCUMENT = 9,
    NODE_DOCUMENT_TYPE = 10,
    NODE_DOCUMENT_FRAGMENT = 11,
    NODE_NOTATION = 12,
};
pub const struct_IXMLDOMNodeListVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMNodeList, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMNodeList) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMNodeList) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMNodeList, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMNodeList, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMNodeList, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMNodeList, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_item: ?fn ([*c]IXMLDOMNodeList, c_long, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_length: ?fn ([*c]IXMLDOMNodeList, [*c]c_long) callconv(.C) HRESULT,
    nextNode: ?fn ([*c]IXMLDOMNodeList, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    reset: ?fn ([*c]IXMLDOMNodeList) callconv(.C) HRESULT,
    get__newEnum: ?fn ([*c]IXMLDOMNodeList, [*c]([*c]IUnknown)) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMNodeList = extern struct {
    lpVtbl: [*c]struct_IXMLDOMNodeListVtbl,
};
pub const IXMLDOMNodeList = struct_IXMLDOMNodeList;
pub const struct_IXMLDOMNamedNodeMapVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMNamedNodeMap, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMNamedNodeMap) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMNamedNodeMap) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMNamedNodeMap, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMNamedNodeMap, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMNamedNodeMap, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMNamedNodeMap, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    getNamedItem: ?fn ([*c]IXMLDOMNamedNodeMap, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    setNamedItem: ?fn ([*c]IXMLDOMNamedNodeMap, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    removeNamedItem: ?fn ([*c]IXMLDOMNamedNodeMap, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_item: ?fn ([*c]IXMLDOMNamedNodeMap, c_long, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_length: ?fn ([*c]IXMLDOMNamedNodeMap, [*c]c_long) callconv(.C) HRESULT,
    getQualifiedItem: ?fn ([*c]IXMLDOMNamedNodeMap, BSTR, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    removeQualifiedItem: ?fn ([*c]IXMLDOMNamedNodeMap, BSTR, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    nextNode: ?fn ([*c]IXMLDOMNamedNodeMap, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    reset: ?fn ([*c]IXMLDOMNamedNodeMap) callconv(.C) HRESULT,
    get__newEnum: ?fn ([*c]IXMLDOMNamedNodeMap, [*c]([*c]IUnknown)) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMNamedNodeMap = extern struct {
    lpVtbl: [*c]struct_IXMLDOMNamedNodeMapVtbl,
};
pub const IXMLDOMNamedNodeMap = struct_IXMLDOMNamedNodeMap;
pub const struct_IXMLDOMDocumentTypeVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMDocumentType, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMDocumentType) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMDocumentType) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMDocumentType, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMDocumentType, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMDocumentType, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMDocumentType, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_nodeName: ?fn ([*c]IXMLDOMDocumentType, [*c]BSTR) callconv(.C) HRESULT,
    get_nodeValue: ?fn ([*c]IXMLDOMDocumentType, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeValue: ?fn ([*c]IXMLDOMDocumentType, VARIANT) callconv(.C) HRESULT,
    get_nodeType: ?fn ([*c]IXMLDOMDocumentType, [*c]DOMNodeType) callconv(.C) HRESULT,
    get_parentNode: ?fn ([*c]IXMLDOMDocumentType, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_childNodes: ?fn ([*c]IXMLDOMDocumentType, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    get_firstChild: ?fn ([*c]IXMLDOMDocumentType, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_lastChild: ?fn ([*c]IXMLDOMDocumentType, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_previousSibling: ?fn ([*c]IXMLDOMDocumentType, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nextSibling: ?fn ([*c]IXMLDOMDocumentType, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_attributes: ?fn ([*c]IXMLDOMDocumentType, [*c]([*c]IXMLDOMNamedNodeMap)) callconv(.C) HRESULT,
    insertBefore: ?fn ([*c]IXMLDOMDocumentType, [*c]IXMLDOMNode, VARIANT, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    replaceChild: ?fn ([*c]IXMLDOMDocumentType, [*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    removeChild: ?fn ([*c]IXMLDOMDocumentType, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    appendChild: ?fn ([*c]IXMLDOMDocumentType, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    hasChildNodes: ?fn ([*c]IXMLDOMDocumentType, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_ownerDocument: ?fn ([*c]IXMLDOMDocumentType, [*c]([*c]IXMLDOMDocument)) callconv(.C) HRESULT,
    cloneNode: ?fn ([*c]IXMLDOMDocumentType, VARIANT_BOOL, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypeString: ?fn ([*c]IXMLDOMDocumentType, [*c]BSTR) callconv(.C) HRESULT,
    get_text: ?fn ([*c]IXMLDOMDocumentType, [*c]BSTR) callconv(.C) HRESULT,
    put_text: ?fn ([*c]IXMLDOMDocumentType, BSTR) callconv(.C) HRESULT,
    get_specified: ?fn ([*c]IXMLDOMDocumentType, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_definition: ?fn ([*c]IXMLDOMDocumentType, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypedValue: ?fn ([*c]IXMLDOMDocumentType, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeTypedValue: ?fn ([*c]IXMLDOMDocumentType, VARIANT) callconv(.C) HRESULT,
    get_dataType: ?fn ([*c]IXMLDOMDocumentType, [*c]VARIANT) callconv(.C) HRESULT,
    put_dataType: ?fn ([*c]IXMLDOMDocumentType, BSTR) callconv(.C) HRESULT,
    get_xml: ?fn ([*c]IXMLDOMDocumentType, [*c]BSTR) callconv(.C) HRESULT,
    transformNode: ?fn ([*c]IXMLDOMDocumentType, [*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    selectNodes: ?fn ([*c]IXMLDOMDocumentType, BSTR, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    selectSingleNode: ?fn ([*c]IXMLDOMDocumentType, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_parsed: ?fn ([*c]IXMLDOMDocumentType, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_namespaceURI: ?fn ([*c]IXMLDOMDocumentType, [*c]BSTR) callconv(.C) HRESULT,
    get_prefix: ?fn ([*c]IXMLDOMDocumentType, [*c]BSTR) callconv(.C) HRESULT,
    get_baseName: ?fn ([*c]IXMLDOMDocumentType, [*c]BSTR) callconv(.C) HRESULT,
    transformNodeToObject: ?fn ([*c]IXMLDOMDocumentType, [*c]IXMLDOMNode, VARIANT) callconv(.C) HRESULT,
    get_name: ?fn ([*c]IXMLDOMDocumentType, [*c]BSTR) callconv(.C) HRESULT,
    get_entities: ?fn ([*c]IXMLDOMDocumentType, [*c]([*c]IXMLDOMNamedNodeMap)) callconv(.C) HRESULT,
    get_notations: ?fn ([*c]IXMLDOMDocumentType, [*c]([*c]IXMLDOMNamedNodeMap)) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMDocumentType = extern struct {
    lpVtbl: [*c]struct_IXMLDOMDocumentTypeVtbl,
};
pub const IXMLDOMDocumentType = struct_IXMLDOMDocumentType;
pub const struct_IXMLDOMAttributeVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMAttribute, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMAttribute) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMAttribute) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMAttribute, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMAttribute, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMAttribute, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMAttribute, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_nodeName: ?fn ([*c]IXMLDOMAttribute, [*c]BSTR) callconv(.C) HRESULT,
    get_nodeValue: ?fn ([*c]IXMLDOMAttribute, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeValue: ?fn ([*c]IXMLDOMAttribute, VARIANT) callconv(.C) HRESULT,
    get_nodeType: ?fn ([*c]IXMLDOMAttribute, [*c]DOMNodeType) callconv(.C) HRESULT,
    get_parentNode: ?fn ([*c]IXMLDOMAttribute, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_childNodes: ?fn ([*c]IXMLDOMAttribute, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    get_firstChild: ?fn ([*c]IXMLDOMAttribute, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_lastChild: ?fn ([*c]IXMLDOMAttribute, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_previousSibling: ?fn ([*c]IXMLDOMAttribute, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nextSibling: ?fn ([*c]IXMLDOMAttribute, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_attributes: ?fn ([*c]IXMLDOMAttribute, [*c]([*c]IXMLDOMNamedNodeMap)) callconv(.C) HRESULT,
    insertBefore: ?fn ([*c]IXMLDOMAttribute, [*c]IXMLDOMNode, VARIANT, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    replaceChild: ?fn ([*c]IXMLDOMAttribute, [*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    removeChild: ?fn ([*c]IXMLDOMAttribute, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    appendChild: ?fn ([*c]IXMLDOMAttribute, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    hasChildNodes: ?fn ([*c]IXMLDOMAttribute, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_ownerDocument: ?fn ([*c]IXMLDOMAttribute, [*c]([*c]IXMLDOMDocument)) callconv(.C) HRESULT,
    cloneNode: ?fn ([*c]IXMLDOMAttribute, VARIANT_BOOL, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypeString: ?fn ([*c]IXMLDOMAttribute, [*c]BSTR) callconv(.C) HRESULT,
    get_text: ?fn ([*c]IXMLDOMAttribute, [*c]BSTR) callconv(.C) HRESULT,
    put_text: ?fn ([*c]IXMLDOMAttribute, BSTR) callconv(.C) HRESULT,
    get_specified: ?fn ([*c]IXMLDOMAttribute, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_definition: ?fn ([*c]IXMLDOMAttribute, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypedValue: ?fn ([*c]IXMLDOMAttribute, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeTypedValue: ?fn ([*c]IXMLDOMAttribute, VARIANT) callconv(.C) HRESULT,
    get_dataType: ?fn ([*c]IXMLDOMAttribute, [*c]VARIANT) callconv(.C) HRESULT,
    put_dataType: ?fn ([*c]IXMLDOMAttribute, BSTR) callconv(.C) HRESULT,
    get_xml: ?fn ([*c]IXMLDOMAttribute, [*c]BSTR) callconv(.C) HRESULT,
    transformNode: ?fn ([*c]IXMLDOMAttribute, [*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    selectNodes: ?fn ([*c]IXMLDOMAttribute, BSTR, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    selectSingleNode: ?fn ([*c]IXMLDOMAttribute, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_parsed: ?fn ([*c]IXMLDOMAttribute, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_namespaceURI: ?fn ([*c]IXMLDOMAttribute, [*c]BSTR) callconv(.C) HRESULT,
    get_prefix: ?fn ([*c]IXMLDOMAttribute, [*c]BSTR) callconv(.C) HRESULT,
    get_baseName: ?fn ([*c]IXMLDOMAttribute, [*c]BSTR) callconv(.C) HRESULT,
    transformNodeToObject: ?fn ([*c]IXMLDOMAttribute, [*c]IXMLDOMNode, VARIANT) callconv(.C) HRESULT,
    get_name: ?fn ([*c]IXMLDOMAttribute, [*c]BSTR) callconv(.C) HRESULT,
    get_value: ?fn ([*c]IXMLDOMAttribute, [*c]VARIANT) callconv(.C) HRESULT,
    put_value: ?fn ([*c]IXMLDOMAttribute, VARIANT) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMAttribute = extern struct {
    lpVtbl: [*c]struct_IXMLDOMAttributeVtbl,
};
pub const IXMLDOMAttribute = struct_IXMLDOMAttribute;
pub const struct_IXMLDOMElementVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMElement, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMElement) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMElement) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMElement, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMElement, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMElement, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMElement, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_nodeName: ?fn ([*c]IXMLDOMElement, [*c]BSTR) callconv(.C) HRESULT,
    get_nodeValue: ?fn ([*c]IXMLDOMElement, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeValue: ?fn ([*c]IXMLDOMElement, VARIANT) callconv(.C) HRESULT,
    get_nodeType: ?fn ([*c]IXMLDOMElement, [*c]DOMNodeType) callconv(.C) HRESULT,
    get_parentNode: ?fn ([*c]IXMLDOMElement, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_childNodes: ?fn ([*c]IXMLDOMElement, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    get_firstChild: ?fn ([*c]IXMLDOMElement, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_lastChild: ?fn ([*c]IXMLDOMElement, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_previousSibling: ?fn ([*c]IXMLDOMElement, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nextSibling: ?fn ([*c]IXMLDOMElement, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_attributes: ?fn ([*c]IXMLDOMElement, [*c]([*c]IXMLDOMNamedNodeMap)) callconv(.C) HRESULT,
    insertBefore: ?fn ([*c]IXMLDOMElement, [*c]IXMLDOMNode, VARIANT, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    replaceChild: ?fn ([*c]IXMLDOMElement, [*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    removeChild: ?fn ([*c]IXMLDOMElement, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    appendChild: ?fn ([*c]IXMLDOMElement, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    hasChildNodes: ?fn ([*c]IXMLDOMElement, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_ownerDocument: ?fn ([*c]IXMLDOMElement, [*c]([*c]IXMLDOMDocument)) callconv(.C) HRESULT,
    cloneNode: ?fn ([*c]IXMLDOMElement, VARIANT_BOOL, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypeString: ?fn ([*c]IXMLDOMElement, [*c]BSTR) callconv(.C) HRESULT,
    get_text: ?fn ([*c]IXMLDOMElement, [*c]BSTR) callconv(.C) HRESULT,
    put_text: ?fn ([*c]IXMLDOMElement, BSTR) callconv(.C) HRESULT,
    get_specified: ?fn ([*c]IXMLDOMElement, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_definition: ?fn ([*c]IXMLDOMElement, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypedValue: ?fn ([*c]IXMLDOMElement, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeTypedValue: ?fn ([*c]IXMLDOMElement, VARIANT) callconv(.C) HRESULT,
    get_dataType: ?fn ([*c]IXMLDOMElement, [*c]VARIANT) callconv(.C) HRESULT,
    put_dataType: ?fn ([*c]IXMLDOMElement, BSTR) callconv(.C) HRESULT,
    get_xml: ?fn ([*c]IXMLDOMElement, [*c]BSTR) callconv(.C) HRESULT,
    transformNode: ?fn ([*c]IXMLDOMElement, [*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    selectNodes: ?fn ([*c]IXMLDOMElement, BSTR, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    selectSingleNode: ?fn ([*c]IXMLDOMElement, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_parsed: ?fn ([*c]IXMLDOMElement, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_namespaceURI: ?fn ([*c]IXMLDOMElement, [*c]BSTR) callconv(.C) HRESULT,
    get_prefix: ?fn ([*c]IXMLDOMElement, [*c]BSTR) callconv(.C) HRESULT,
    get_baseName: ?fn ([*c]IXMLDOMElement, [*c]BSTR) callconv(.C) HRESULT,
    transformNodeToObject: ?fn ([*c]IXMLDOMElement, [*c]IXMLDOMNode, VARIANT) callconv(.C) HRESULT,
    get_tagName: ?fn ([*c]IXMLDOMElement, [*c]BSTR) callconv(.C) HRESULT,
    getAttribute: ?fn ([*c]IXMLDOMElement, BSTR, [*c]VARIANT) callconv(.C) HRESULT,
    setAttribute: ?fn ([*c]IXMLDOMElement, BSTR, VARIANT) callconv(.C) HRESULT,
    removeAttribute: ?fn ([*c]IXMLDOMElement, BSTR) callconv(.C) HRESULT,
    getAttributeNode: ?fn ([*c]IXMLDOMElement, BSTR, [*c]([*c]IXMLDOMAttribute)) callconv(.C) HRESULT,
    setAttributeNode: ?fn ([*c]IXMLDOMElement, [*c]IXMLDOMAttribute, [*c]([*c]IXMLDOMAttribute)) callconv(.C) HRESULT,
    removeAttributeNode: ?fn ([*c]IXMLDOMElement, [*c]IXMLDOMAttribute, [*c]([*c]IXMLDOMAttribute)) callconv(.C) HRESULT,
    getElementsByTagName: ?fn ([*c]IXMLDOMElement, BSTR, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    normalize: ?fn ([*c]IXMLDOMElement) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMElement = extern struct {
    lpVtbl: [*c]struct_IXMLDOMElementVtbl,
};
pub const IXMLDOMElement = struct_IXMLDOMElement;
pub const struct_IXMLDOMDocumentFragmentVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMDocumentFragment, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMDocumentFragment) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMDocumentFragment) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMDocumentFragment, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMDocumentFragment, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMDocumentFragment, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMDocumentFragment, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_nodeName: ?fn ([*c]IXMLDOMDocumentFragment, [*c]BSTR) callconv(.C) HRESULT,
    get_nodeValue: ?fn ([*c]IXMLDOMDocumentFragment, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeValue: ?fn ([*c]IXMLDOMDocumentFragment, VARIANT) callconv(.C) HRESULT,
    get_nodeType: ?fn ([*c]IXMLDOMDocumentFragment, [*c]DOMNodeType) callconv(.C) HRESULT,
    get_parentNode: ?fn ([*c]IXMLDOMDocumentFragment, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_childNodes: ?fn ([*c]IXMLDOMDocumentFragment, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    get_firstChild: ?fn ([*c]IXMLDOMDocumentFragment, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_lastChild: ?fn ([*c]IXMLDOMDocumentFragment, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_previousSibling: ?fn ([*c]IXMLDOMDocumentFragment, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nextSibling: ?fn ([*c]IXMLDOMDocumentFragment, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_attributes: ?fn ([*c]IXMLDOMDocumentFragment, [*c]([*c]IXMLDOMNamedNodeMap)) callconv(.C) HRESULT,
    insertBefore: ?fn ([*c]IXMLDOMDocumentFragment, [*c]IXMLDOMNode, VARIANT, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    replaceChild: ?fn ([*c]IXMLDOMDocumentFragment, [*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    removeChild: ?fn ([*c]IXMLDOMDocumentFragment, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    appendChild: ?fn ([*c]IXMLDOMDocumentFragment, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    hasChildNodes: ?fn ([*c]IXMLDOMDocumentFragment, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_ownerDocument: ?fn ([*c]IXMLDOMDocumentFragment, [*c]([*c]IXMLDOMDocument)) callconv(.C) HRESULT,
    cloneNode: ?fn ([*c]IXMLDOMDocumentFragment, VARIANT_BOOL, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypeString: ?fn ([*c]IXMLDOMDocumentFragment, [*c]BSTR) callconv(.C) HRESULT,
    get_text: ?fn ([*c]IXMLDOMDocumentFragment, [*c]BSTR) callconv(.C) HRESULT,
    put_text: ?fn ([*c]IXMLDOMDocumentFragment, BSTR) callconv(.C) HRESULT,
    get_specified: ?fn ([*c]IXMLDOMDocumentFragment, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_definition: ?fn ([*c]IXMLDOMDocumentFragment, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypedValue: ?fn ([*c]IXMLDOMDocumentFragment, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeTypedValue: ?fn ([*c]IXMLDOMDocumentFragment, VARIANT) callconv(.C) HRESULT,
    get_dataType: ?fn ([*c]IXMLDOMDocumentFragment, [*c]VARIANT) callconv(.C) HRESULT,
    put_dataType: ?fn ([*c]IXMLDOMDocumentFragment, BSTR) callconv(.C) HRESULT,
    get_xml: ?fn ([*c]IXMLDOMDocumentFragment, [*c]BSTR) callconv(.C) HRESULT,
    transformNode: ?fn ([*c]IXMLDOMDocumentFragment, [*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    selectNodes: ?fn ([*c]IXMLDOMDocumentFragment, BSTR, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    selectSingleNode: ?fn ([*c]IXMLDOMDocumentFragment, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_parsed: ?fn ([*c]IXMLDOMDocumentFragment, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_namespaceURI: ?fn ([*c]IXMLDOMDocumentFragment, [*c]BSTR) callconv(.C) HRESULT,
    get_prefix: ?fn ([*c]IXMLDOMDocumentFragment, [*c]BSTR) callconv(.C) HRESULT,
    get_baseName: ?fn ([*c]IXMLDOMDocumentFragment, [*c]BSTR) callconv(.C) HRESULT,
    transformNodeToObject: ?fn ([*c]IXMLDOMDocumentFragment, [*c]IXMLDOMNode, VARIANT) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMDocumentFragment = extern struct {
    lpVtbl: [*c]struct_IXMLDOMDocumentFragmentVtbl,
};
pub const IXMLDOMDocumentFragment = struct_IXMLDOMDocumentFragment;
pub const struct_IXMLDOMTextVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMText, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMText) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMText) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMText, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMText, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMText, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMText, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_nodeName: ?fn ([*c]IXMLDOMText, [*c]BSTR) callconv(.C) HRESULT,
    get_nodeValue: ?fn ([*c]IXMLDOMText, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeValue: ?fn ([*c]IXMLDOMText, VARIANT) callconv(.C) HRESULT,
    get_nodeType: ?fn ([*c]IXMLDOMText, [*c]DOMNodeType) callconv(.C) HRESULT,
    get_parentNode: ?fn ([*c]IXMLDOMText, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_childNodes: ?fn ([*c]IXMLDOMText, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    get_firstChild: ?fn ([*c]IXMLDOMText, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_lastChild: ?fn ([*c]IXMLDOMText, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_previousSibling: ?fn ([*c]IXMLDOMText, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nextSibling: ?fn ([*c]IXMLDOMText, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_attributes: ?fn ([*c]IXMLDOMText, [*c]([*c]IXMLDOMNamedNodeMap)) callconv(.C) HRESULT,
    insertBefore: ?fn ([*c]IXMLDOMText, [*c]IXMLDOMNode, VARIANT, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    replaceChild: ?fn ([*c]IXMLDOMText, [*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    removeChild: ?fn ([*c]IXMLDOMText, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    appendChild: ?fn ([*c]IXMLDOMText, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    hasChildNodes: ?fn ([*c]IXMLDOMText, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_ownerDocument: ?fn ([*c]IXMLDOMText, [*c]([*c]IXMLDOMDocument)) callconv(.C) HRESULT,
    cloneNode: ?fn ([*c]IXMLDOMText, VARIANT_BOOL, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypeString: ?fn ([*c]IXMLDOMText, [*c]BSTR) callconv(.C) HRESULT,
    get_text: ?fn ([*c]IXMLDOMText, [*c]BSTR) callconv(.C) HRESULT,
    put_text: ?fn ([*c]IXMLDOMText, BSTR) callconv(.C) HRESULT,
    get_specified: ?fn ([*c]IXMLDOMText, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_definition: ?fn ([*c]IXMLDOMText, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypedValue: ?fn ([*c]IXMLDOMText, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeTypedValue: ?fn ([*c]IXMLDOMText, VARIANT) callconv(.C) HRESULT,
    get_dataType: ?fn ([*c]IXMLDOMText, [*c]VARIANT) callconv(.C) HRESULT,
    put_dataType: ?fn ([*c]IXMLDOMText, BSTR) callconv(.C) HRESULT,
    get_xml: ?fn ([*c]IXMLDOMText, [*c]BSTR) callconv(.C) HRESULT,
    transformNode: ?fn ([*c]IXMLDOMText, [*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    selectNodes: ?fn ([*c]IXMLDOMText, BSTR, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    selectSingleNode: ?fn ([*c]IXMLDOMText, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_parsed: ?fn ([*c]IXMLDOMText, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_namespaceURI: ?fn ([*c]IXMLDOMText, [*c]BSTR) callconv(.C) HRESULT,
    get_prefix: ?fn ([*c]IXMLDOMText, [*c]BSTR) callconv(.C) HRESULT,
    get_baseName: ?fn ([*c]IXMLDOMText, [*c]BSTR) callconv(.C) HRESULT,
    transformNodeToObject: ?fn ([*c]IXMLDOMText, [*c]IXMLDOMNode, VARIANT) callconv(.C) HRESULT,
    get_data: ?fn ([*c]IXMLDOMText, [*c]BSTR) callconv(.C) HRESULT,
    put_data: ?fn ([*c]IXMLDOMText, BSTR) callconv(.C) HRESULT,
    get_length: ?fn ([*c]IXMLDOMText, [*c]c_long) callconv(.C) HRESULT,
    substringData: ?fn ([*c]IXMLDOMText, c_long, c_long, [*c]BSTR) callconv(.C) HRESULT,
    appendData: ?fn ([*c]IXMLDOMText, BSTR) callconv(.C) HRESULT,
    insertData: ?fn ([*c]IXMLDOMText, c_long, BSTR) callconv(.C) HRESULT,
    deleteData: ?fn ([*c]IXMLDOMText, c_long, c_long) callconv(.C) HRESULT,
    replaceData: ?fn ([*c]IXMLDOMText, c_long, c_long, BSTR) callconv(.C) HRESULT,
    splitText: ?fn ([*c]IXMLDOMText, c_long, [*c]([*c]IXMLDOMText)) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMText = extern struct {
    lpVtbl: [*c]struct_IXMLDOMTextVtbl,
};
pub const IXMLDOMText = struct_IXMLDOMText;
pub const struct_IXMLDOMCommentVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMComment, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMComment) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMComment) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMComment, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMComment, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMComment, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMComment, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_nodeName: ?fn ([*c]IXMLDOMComment, [*c]BSTR) callconv(.C) HRESULT,
    get_nodeValue: ?fn ([*c]IXMLDOMComment, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeValue: ?fn ([*c]IXMLDOMComment, VARIANT) callconv(.C) HRESULT,
    get_nodeType: ?fn ([*c]IXMLDOMComment, [*c]DOMNodeType) callconv(.C) HRESULT,
    get_parentNode: ?fn ([*c]IXMLDOMComment, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_childNodes: ?fn ([*c]IXMLDOMComment, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    get_firstChild: ?fn ([*c]IXMLDOMComment, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_lastChild: ?fn ([*c]IXMLDOMComment, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_previousSibling: ?fn ([*c]IXMLDOMComment, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nextSibling: ?fn ([*c]IXMLDOMComment, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_attributes: ?fn ([*c]IXMLDOMComment, [*c]([*c]IXMLDOMNamedNodeMap)) callconv(.C) HRESULT,
    insertBefore: ?fn ([*c]IXMLDOMComment, [*c]IXMLDOMNode, VARIANT, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    replaceChild: ?fn ([*c]IXMLDOMComment, [*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    removeChild: ?fn ([*c]IXMLDOMComment, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    appendChild: ?fn ([*c]IXMLDOMComment, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    hasChildNodes: ?fn ([*c]IXMLDOMComment, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_ownerDocument: ?fn ([*c]IXMLDOMComment, [*c]([*c]IXMLDOMDocument)) callconv(.C) HRESULT,
    cloneNode: ?fn ([*c]IXMLDOMComment, VARIANT_BOOL, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypeString: ?fn ([*c]IXMLDOMComment, [*c]BSTR) callconv(.C) HRESULT,
    get_text: ?fn ([*c]IXMLDOMComment, [*c]BSTR) callconv(.C) HRESULT,
    put_text: ?fn ([*c]IXMLDOMComment, BSTR) callconv(.C) HRESULT,
    get_specified: ?fn ([*c]IXMLDOMComment, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_definition: ?fn ([*c]IXMLDOMComment, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypedValue: ?fn ([*c]IXMLDOMComment, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeTypedValue: ?fn ([*c]IXMLDOMComment, VARIANT) callconv(.C) HRESULT,
    get_dataType: ?fn ([*c]IXMLDOMComment, [*c]VARIANT) callconv(.C) HRESULT,
    put_dataType: ?fn ([*c]IXMLDOMComment, BSTR) callconv(.C) HRESULT,
    get_xml: ?fn ([*c]IXMLDOMComment, [*c]BSTR) callconv(.C) HRESULT,
    transformNode: ?fn ([*c]IXMLDOMComment, [*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    selectNodes: ?fn ([*c]IXMLDOMComment, BSTR, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    selectSingleNode: ?fn ([*c]IXMLDOMComment, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_parsed: ?fn ([*c]IXMLDOMComment, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_namespaceURI: ?fn ([*c]IXMLDOMComment, [*c]BSTR) callconv(.C) HRESULT,
    get_prefix: ?fn ([*c]IXMLDOMComment, [*c]BSTR) callconv(.C) HRESULT,
    get_baseName: ?fn ([*c]IXMLDOMComment, [*c]BSTR) callconv(.C) HRESULT,
    transformNodeToObject: ?fn ([*c]IXMLDOMComment, [*c]IXMLDOMNode, VARIANT) callconv(.C) HRESULT,
    get_data: ?fn ([*c]IXMLDOMComment, [*c]BSTR) callconv(.C) HRESULT,
    put_data: ?fn ([*c]IXMLDOMComment, BSTR) callconv(.C) HRESULT,
    get_length: ?fn ([*c]IXMLDOMComment, [*c]c_long) callconv(.C) HRESULT,
    substringData: ?fn ([*c]IXMLDOMComment, c_long, c_long, [*c]BSTR) callconv(.C) HRESULT,
    appendData: ?fn ([*c]IXMLDOMComment, BSTR) callconv(.C) HRESULT,
    insertData: ?fn ([*c]IXMLDOMComment, c_long, BSTR) callconv(.C) HRESULT,
    deleteData: ?fn ([*c]IXMLDOMComment, c_long, c_long) callconv(.C) HRESULT,
    replaceData: ?fn ([*c]IXMLDOMComment, c_long, c_long, BSTR) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMComment = extern struct {
    lpVtbl: [*c]struct_IXMLDOMCommentVtbl,
};
pub const IXMLDOMComment = struct_IXMLDOMComment;
pub const struct_IXMLDOMCDATASectionVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMCDATASection, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMCDATASection) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMCDATASection) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMCDATASection, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMCDATASection, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMCDATASection, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMCDATASection, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_nodeName: ?fn ([*c]IXMLDOMCDATASection, [*c]BSTR) callconv(.C) HRESULT,
    get_nodeValue: ?fn ([*c]IXMLDOMCDATASection, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeValue: ?fn ([*c]IXMLDOMCDATASection, VARIANT) callconv(.C) HRESULT,
    get_nodeType: ?fn ([*c]IXMLDOMCDATASection, [*c]DOMNodeType) callconv(.C) HRESULT,
    get_parentNode: ?fn ([*c]IXMLDOMCDATASection, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_childNodes: ?fn ([*c]IXMLDOMCDATASection, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    get_firstChild: ?fn ([*c]IXMLDOMCDATASection, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_lastChild: ?fn ([*c]IXMLDOMCDATASection, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_previousSibling: ?fn ([*c]IXMLDOMCDATASection, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nextSibling: ?fn ([*c]IXMLDOMCDATASection, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_attributes: ?fn ([*c]IXMLDOMCDATASection, [*c]([*c]IXMLDOMNamedNodeMap)) callconv(.C) HRESULT,
    insertBefore: ?fn ([*c]IXMLDOMCDATASection, [*c]IXMLDOMNode, VARIANT, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    replaceChild: ?fn ([*c]IXMLDOMCDATASection, [*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    removeChild: ?fn ([*c]IXMLDOMCDATASection, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    appendChild: ?fn ([*c]IXMLDOMCDATASection, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    hasChildNodes: ?fn ([*c]IXMLDOMCDATASection, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_ownerDocument: ?fn ([*c]IXMLDOMCDATASection, [*c]([*c]IXMLDOMDocument)) callconv(.C) HRESULT,
    cloneNode: ?fn ([*c]IXMLDOMCDATASection, VARIANT_BOOL, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypeString: ?fn ([*c]IXMLDOMCDATASection, [*c]BSTR) callconv(.C) HRESULT,
    get_text: ?fn ([*c]IXMLDOMCDATASection, [*c]BSTR) callconv(.C) HRESULT,
    put_text: ?fn ([*c]IXMLDOMCDATASection, BSTR) callconv(.C) HRESULT,
    get_specified: ?fn ([*c]IXMLDOMCDATASection, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_definition: ?fn ([*c]IXMLDOMCDATASection, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypedValue: ?fn ([*c]IXMLDOMCDATASection, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeTypedValue: ?fn ([*c]IXMLDOMCDATASection, VARIANT) callconv(.C) HRESULT,
    get_dataType: ?fn ([*c]IXMLDOMCDATASection, [*c]VARIANT) callconv(.C) HRESULT,
    put_dataType: ?fn ([*c]IXMLDOMCDATASection, BSTR) callconv(.C) HRESULT,
    get_xml: ?fn ([*c]IXMLDOMCDATASection, [*c]BSTR) callconv(.C) HRESULT,
    transformNode: ?fn ([*c]IXMLDOMCDATASection, [*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    selectNodes: ?fn ([*c]IXMLDOMCDATASection, BSTR, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    selectSingleNode: ?fn ([*c]IXMLDOMCDATASection, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_parsed: ?fn ([*c]IXMLDOMCDATASection, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_namespaceURI: ?fn ([*c]IXMLDOMCDATASection, [*c]BSTR) callconv(.C) HRESULT,
    get_prefix: ?fn ([*c]IXMLDOMCDATASection, [*c]BSTR) callconv(.C) HRESULT,
    get_baseName: ?fn ([*c]IXMLDOMCDATASection, [*c]BSTR) callconv(.C) HRESULT,
    transformNodeToObject: ?fn ([*c]IXMLDOMCDATASection, [*c]IXMLDOMNode, VARIANT) callconv(.C) HRESULT,
    get_data: ?fn ([*c]IXMLDOMCDATASection, [*c]BSTR) callconv(.C) HRESULT,
    put_data: ?fn ([*c]IXMLDOMCDATASection, BSTR) callconv(.C) HRESULT,
    get_length: ?fn ([*c]IXMLDOMCDATASection, [*c]c_long) callconv(.C) HRESULT,
    substringData: ?fn ([*c]IXMLDOMCDATASection, c_long, c_long, [*c]BSTR) callconv(.C) HRESULT,
    appendData: ?fn ([*c]IXMLDOMCDATASection, BSTR) callconv(.C) HRESULT,
    insertData: ?fn ([*c]IXMLDOMCDATASection, c_long, BSTR) callconv(.C) HRESULT,
    deleteData: ?fn ([*c]IXMLDOMCDATASection, c_long, c_long) callconv(.C) HRESULT,
    replaceData: ?fn ([*c]IXMLDOMCDATASection, c_long, c_long, BSTR) callconv(.C) HRESULT,
    splitText: ?fn ([*c]IXMLDOMCDATASection, c_long, [*c]([*c]IXMLDOMText)) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMCDATASection = extern struct {
    lpVtbl: [*c]struct_IXMLDOMCDATASectionVtbl,
};
pub const IXMLDOMCDATASection = struct_IXMLDOMCDATASection;
pub const struct_IXMLDOMProcessingInstructionVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMProcessingInstruction) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMProcessingInstruction) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMProcessingInstruction, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMProcessingInstruction, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_nodeName: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]BSTR) callconv(.C) HRESULT,
    get_nodeValue: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeValue: ?fn ([*c]IXMLDOMProcessingInstruction, VARIANT) callconv(.C) HRESULT,
    get_nodeType: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]DOMNodeType) callconv(.C) HRESULT,
    get_parentNode: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_childNodes: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    get_firstChild: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_lastChild: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_previousSibling: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nextSibling: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_attributes: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]([*c]IXMLDOMNamedNodeMap)) callconv(.C) HRESULT,
    insertBefore: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]IXMLDOMNode, VARIANT, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    replaceChild: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    removeChild: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    appendChild: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    hasChildNodes: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_ownerDocument: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]([*c]IXMLDOMDocument)) callconv(.C) HRESULT,
    cloneNode: ?fn ([*c]IXMLDOMProcessingInstruction, VARIANT_BOOL, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypeString: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]BSTR) callconv(.C) HRESULT,
    get_text: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]BSTR) callconv(.C) HRESULT,
    put_text: ?fn ([*c]IXMLDOMProcessingInstruction, BSTR) callconv(.C) HRESULT,
    get_specified: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_definition: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypedValue: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeTypedValue: ?fn ([*c]IXMLDOMProcessingInstruction, VARIANT) callconv(.C) HRESULT,
    get_dataType: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]VARIANT) callconv(.C) HRESULT,
    put_dataType: ?fn ([*c]IXMLDOMProcessingInstruction, BSTR) callconv(.C) HRESULT,
    get_xml: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]BSTR) callconv(.C) HRESULT,
    transformNode: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    selectNodes: ?fn ([*c]IXMLDOMProcessingInstruction, BSTR, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    selectSingleNode: ?fn ([*c]IXMLDOMProcessingInstruction, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_parsed: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_namespaceURI: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]BSTR) callconv(.C) HRESULT,
    get_prefix: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]BSTR) callconv(.C) HRESULT,
    get_baseName: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]BSTR) callconv(.C) HRESULT,
    transformNodeToObject: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]IXMLDOMNode, VARIANT) callconv(.C) HRESULT,
    get_target: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]BSTR) callconv(.C) HRESULT,
    get_data: ?fn ([*c]IXMLDOMProcessingInstruction, [*c]BSTR) callconv(.C) HRESULT,
    put_data: ?fn ([*c]IXMLDOMProcessingInstruction, BSTR) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMProcessingInstruction = extern struct {
    lpVtbl: [*c]struct_IXMLDOMProcessingInstructionVtbl,
};
pub const IXMLDOMProcessingInstruction = struct_IXMLDOMProcessingInstruction;
pub const struct_IXMLDOMEntityReferenceVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMEntityReference, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMEntityReference) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMEntityReference) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMEntityReference, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMEntityReference, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMEntityReference, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMEntityReference, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_nodeName: ?fn ([*c]IXMLDOMEntityReference, [*c]BSTR) callconv(.C) HRESULT,
    get_nodeValue: ?fn ([*c]IXMLDOMEntityReference, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeValue: ?fn ([*c]IXMLDOMEntityReference, VARIANT) callconv(.C) HRESULT,
    get_nodeType: ?fn ([*c]IXMLDOMEntityReference, [*c]DOMNodeType) callconv(.C) HRESULT,
    get_parentNode: ?fn ([*c]IXMLDOMEntityReference, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_childNodes: ?fn ([*c]IXMLDOMEntityReference, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    get_firstChild: ?fn ([*c]IXMLDOMEntityReference, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_lastChild: ?fn ([*c]IXMLDOMEntityReference, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_previousSibling: ?fn ([*c]IXMLDOMEntityReference, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nextSibling: ?fn ([*c]IXMLDOMEntityReference, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_attributes: ?fn ([*c]IXMLDOMEntityReference, [*c]([*c]IXMLDOMNamedNodeMap)) callconv(.C) HRESULT,
    insertBefore: ?fn ([*c]IXMLDOMEntityReference, [*c]IXMLDOMNode, VARIANT, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    replaceChild: ?fn ([*c]IXMLDOMEntityReference, [*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    removeChild: ?fn ([*c]IXMLDOMEntityReference, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    appendChild: ?fn ([*c]IXMLDOMEntityReference, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    hasChildNodes: ?fn ([*c]IXMLDOMEntityReference, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_ownerDocument: ?fn ([*c]IXMLDOMEntityReference, [*c]([*c]IXMLDOMDocument)) callconv(.C) HRESULT,
    cloneNode: ?fn ([*c]IXMLDOMEntityReference, VARIANT_BOOL, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypeString: ?fn ([*c]IXMLDOMEntityReference, [*c]BSTR) callconv(.C) HRESULT,
    get_text: ?fn ([*c]IXMLDOMEntityReference, [*c]BSTR) callconv(.C) HRESULT,
    put_text: ?fn ([*c]IXMLDOMEntityReference, BSTR) callconv(.C) HRESULT,
    get_specified: ?fn ([*c]IXMLDOMEntityReference, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_definition: ?fn ([*c]IXMLDOMEntityReference, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypedValue: ?fn ([*c]IXMLDOMEntityReference, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeTypedValue: ?fn ([*c]IXMLDOMEntityReference, VARIANT) callconv(.C) HRESULT,
    get_dataType: ?fn ([*c]IXMLDOMEntityReference, [*c]VARIANT) callconv(.C) HRESULT,
    put_dataType: ?fn ([*c]IXMLDOMEntityReference, BSTR) callconv(.C) HRESULT,
    get_xml: ?fn ([*c]IXMLDOMEntityReference, [*c]BSTR) callconv(.C) HRESULT,
    transformNode: ?fn ([*c]IXMLDOMEntityReference, [*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    selectNodes: ?fn ([*c]IXMLDOMEntityReference, BSTR, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    selectSingleNode: ?fn ([*c]IXMLDOMEntityReference, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_parsed: ?fn ([*c]IXMLDOMEntityReference, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_namespaceURI: ?fn ([*c]IXMLDOMEntityReference, [*c]BSTR) callconv(.C) HRESULT,
    get_prefix: ?fn ([*c]IXMLDOMEntityReference, [*c]BSTR) callconv(.C) HRESULT,
    get_baseName: ?fn ([*c]IXMLDOMEntityReference, [*c]BSTR) callconv(.C) HRESULT,
    transformNodeToObject: ?fn ([*c]IXMLDOMEntityReference, [*c]IXMLDOMNode, VARIANT) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMEntityReference = extern struct {
    lpVtbl: [*c]struct_IXMLDOMEntityReferenceVtbl,
};
pub const IXMLDOMEntityReference = struct_IXMLDOMEntityReference;
pub const struct_IXMLDOMParseErrorVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMParseError, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMParseError) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMParseError) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMParseError, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMParseError, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMParseError, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMParseError, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_errorCode: ?fn ([*c]IXMLDOMParseError, [*c]c_long) callconv(.C) HRESULT,
    get_url: ?fn ([*c]IXMLDOMParseError, [*c]BSTR) callconv(.C) HRESULT,
    get_reason: ?fn ([*c]IXMLDOMParseError, [*c]BSTR) callconv(.C) HRESULT,
    get_srcText: ?fn ([*c]IXMLDOMParseError, [*c]BSTR) callconv(.C) HRESULT,
    get_line: ?fn ([*c]IXMLDOMParseError, [*c]c_long) callconv(.C) HRESULT,
    get_linepos: ?fn ([*c]IXMLDOMParseError, [*c]c_long) callconv(.C) HRESULT,
    get_filepos: ?fn ([*c]IXMLDOMParseError, [*c]c_long) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMParseError = extern struct {
    lpVtbl: [*c]struct_IXMLDOMParseErrorVtbl,
};
pub const IXMLDOMParseError = struct_IXMLDOMParseError;
pub const struct_IXMLDOMDocumentVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMDocument, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMDocument) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMDocument) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMDocument, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMDocument, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMDocument, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMDocument, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_nodeName: ?fn ([*c]IXMLDOMDocument, [*c]BSTR) callconv(.C) HRESULT,
    get_nodeValue: ?fn ([*c]IXMLDOMDocument, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeValue: ?fn ([*c]IXMLDOMDocument, VARIANT) callconv(.C) HRESULT,
    get_nodeType: ?fn ([*c]IXMLDOMDocument, [*c]DOMNodeType) callconv(.C) HRESULT,
    get_parentNode: ?fn ([*c]IXMLDOMDocument, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_childNodes: ?fn ([*c]IXMLDOMDocument, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    get_firstChild: ?fn ([*c]IXMLDOMDocument, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_lastChild: ?fn ([*c]IXMLDOMDocument, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_previousSibling: ?fn ([*c]IXMLDOMDocument, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nextSibling: ?fn ([*c]IXMLDOMDocument, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_attributes: ?fn ([*c]IXMLDOMDocument, [*c]([*c]IXMLDOMNamedNodeMap)) callconv(.C) HRESULT,
    insertBefore: ?fn ([*c]IXMLDOMDocument, [*c]IXMLDOMNode, VARIANT, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    replaceChild: ?fn ([*c]IXMLDOMDocument, [*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    removeChild: ?fn ([*c]IXMLDOMDocument, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    appendChild: ?fn ([*c]IXMLDOMDocument, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    hasChildNodes: ?fn ([*c]IXMLDOMDocument, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_ownerDocument: ?fn ([*c]IXMLDOMDocument, [*c]([*c]IXMLDOMDocument)) callconv(.C) HRESULT,
    cloneNode: ?fn ([*c]IXMLDOMDocument, VARIANT_BOOL, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypeString: ?fn ([*c]IXMLDOMDocument, [*c]BSTR) callconv(.C) HRESULT,
    get_text: ?fn ([*c]IXMLDOMDocument, [*c]BSTR) callconv(.C) HRESULT,
    put_text: ?fn ([*c]IXMLDOMDocument, BSTR) callconv(.C) HRESULT,
    get_specified: ?fn ([*c]IXMLDOMDocument, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_definition: ?fn ([*c]IXMLDOMDocument, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypedValue: ?fn ([*c]IXMLDOMDocument, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeTypedValue: ?fn ([*c]IXMLDOMDocument, VARIANT) callconv(.C) HRESULT,
    get_dataType: ?fn ([*c]IXMLDOMDocument, [*c]VARIANT) callconv(.C) HRESULT,
    put_dataType: ?fn ([*c]IXMLDOMDocument, BSTR) callconv(.C) HRESULT,
    get_xml: ?fn ([*c]IXMLDOMDocument, [*c]BSTR) callconv(.C) HRESULT,
    transformNode: ?fn ([*c]IXMLDOMDocument, [*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    selectNodes: ?fn ([*c]IXMLDOMDocument, BSTR, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    selectSingleNode: ?fn ([*c]IXMLDOMDocument, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_parsed: ?fn ([*c]IXMLDOMDocument, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_namespaceURI: ?fn ([*c]IXMLDOMDocument, [*c]BSTR) callconv(.C) HRESULT,
    get_prefix: ?fn ([*c]IXMLDOMDocument, [*c]BSTR) callconv(.C) HRESULT,
    get_baseName: ?fn ([*c]IXMLDOMDocument, [*c]BSTR) callconv(.C) HRESULT,
    transformNodeToObject: ?fn ([*c]IXMLDOMDocument, [*c]IXMLDOMNode, VARIANT) callconv(.C) HRESULT,
    get_doctype: ?fn ([*c]IXMLDOMDocument, [*c]([*c]IXMLDOMDocumentType)) callconv(.C) HRESULT,
    get_implementation: ?fn ([*c]IXMLDOMDocument, [*c]([*c]IXMLDOMImplementation)) callconv(.C) HRESULT,
    get_documentElement: ?fn ([*c]IXMLDOMDocument, [*c]([*c]IXMLDOMElement)) callconv(.C) HRESULT,
    putref_documentElement: ?fn ([*c]IXMLDOMDocument, [*c]IXMLDOMElement) callconv(.C) HRESULT,
    createElement: ?fn ([*c]IXMLDOMDocument, BSTR, [*c]([*c]IXMLDOMElement)) callconv(.C) HRESULT,
    createDocumentFragment: ?fn ([*c]IXMLDOMDocument, [*c]([*c]IXMLDOMDocumentFragment)) callconv(.C) HRESULT,
    createTextNode: ?fn ([*c]IXMLDOMDocument, BSTR, [*c]([*c]IXMLDOMText)) callconv(.C) HRESULT,
    createComment: ?fn ([*c]IXMLDOMDocument, BSTR, [*c]([*c]IXMLDOMComment)) callconv(.C) HRESULT,
    createCDATASection: ?fn ([*c]IXMLDOMDocument, BSTR, [*c]([*c]IXMLDOMCDATASection)) callconv(.C) HRESULT,
    createProcessingInstruction: ?fn ([*c]IXMLDOMDocument, BSTR, BSTR, [*c]([*c]IXMLDOMProcessingInstruction)) callconv(.C) HRESULT,
    createAttribute: ?fn ([*c]IXMLDOMDocument, BSTR, [*c]([*c]IXMLDOMAttribute)) callconv(.C) HRESULT,
    createEntityReference: ?fn ([*c]IXMLDOMDocument, BSTR, [*c]([*c]IXMLDOMEntityReference)) callconv(.C) HRESULT,
    getElementsByTagName: ?fn ([*c]IXMLDOMDocument, BSTR, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    createNode: ?fn ([*c]IXMLDOMDocument, VARIANT, BSTR, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    nodeFromID: ?fn ([*c]IXMLDOMDocument, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    load: ?fn ([*c]IXMLDOMDocument, VARIANT, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_readyState: ?fn ([*c]IXMLDOMDocument, [*c]c_long) callconv(.C) HRESULT,
    get_parseError: ?fn ([*c]IXMLDOMDocument, [*c]([*c]IXMLDOMParseError)) callconv(.C) HRESULT,
    get_url: ?fn ([*c]IXMLDOMDocument, [*c]BSTR) callconv(.C) HRESULT,
    get_async: ?fn ([*c]IXMLDOMDocument, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    put_async: ?fn ([*c]IXMLDOMDocument, VARIANT_BOOL) callconv(.C) HRESULT,
    abort: ?fn ([*c]IXMLDOMDocument) callconv(.C) HRESULT,
    loadXML: ?fn ([*c]IXMLDOMDocument, BSTR, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    save: ?fn ([*c]IXMLDOMDocument, VARIANT) callconv(.C) HRESULT,
    get_validateOnParse: ?fn ([*c]IXMLDOMDocument, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    put_validateOnParse: ?fn ([*c]IXMLDOMDocument, VARIANT_BOOL) callconv(.C) HRESULT,
    get_resolveExternals: ?fn ([*c]IXMLDOMDocument, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    put_resolveExternals: ?fn ([*c]IXMLDOMDocument, VARIANT_BOOL) callconv(.C) HRESULT,
    get_preserveWhiteSpace: ?fn ([*c]IXMLDOMDocument, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    put_preserveWhiteSpace: ?fn ([*c]IXMLDOMDocument, VARIANT_BOOL) callconv(.C) HRESULT,
    put_onreadystatechange: ?fn ([*c]IXMLDOMDocument, VARIANT) callconv(.C) HRESULT,
    put_ondataavailable: ?fn ([*c]IXMLDOMDocument, VARIANT) callconv(.C) HRESULT,
    put_ontransformnode: ?fn ([*c]IXMLDOMDocument, VARIANT) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMDocument = extern struct {
    lpVtbl: [*c]struct_IXMLDOMDocumentVtbl,
};
pub const IXMLDOMDocument = struct_IXMLDOMDocument;
pub const struct_IXMLDOMNodeVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMNode, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMNode) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMNode) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMNode, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMNode, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMNode, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMNode, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_nodeName: ?fn ([*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    get_nodeValue: ?fn ([*c]IXMLDOMNode, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeValue: ?fn ([*c]IXMLDOMNode, VARIANT) callconv(.C) HRESULT,
    get_nodeType: ?fn ([*c]IXMLDOMNode, [*c]DOMNodeType) callconv(.C) HRESULT,
    get_parentNode: ?fn ([*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_childNodes: ?fn ([*c]IXMLDOMNode, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    get_firstChild: ?fn ([*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_lastChild: ?fn ([*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_previousSibling: ?fn ([*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nextSibling: ?fn ([*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_attributes: ?fn ([*c]IXMLDOMNode, [*c]([*c]IXMLDOMNamedNodeMap)) callconv(.C) HRESULT,
    insertBefore: ?fn ([*c]IXMLDOMNode, [*c]IXMLDOMNode, VARIANT, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    replaceChild: ?fn ([*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    removeChild: ?fn ([*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    appendChild: ?fn ([*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    hasChildNodes: ?fn ([*c]IXMLDOMNode, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_ownerDocument: ?fn ([*c]IXMLDOMNode, [*c]([*c]IXMLDOMDocument)) callconv(.C) HRESULT,
    cloneNode: ?fn ([*c]IXMLDOMNode, VARIANT_BOOL, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypeString: ?fn ([*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    get_text: ?fn ([*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    put_text: ?fn ([*c]IXMLDOMNode, BSTR) callconv(.C) HRESULT,
    get_specified: ?fn ([*c]IXMLDOMNode, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_definition: ?fn ([*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypedValue: ?fn ([*c]IXMLDOMNode, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeTypedValue: ?fn ([*c]IXMLDOMNode, VARIANT) callconv(.C) HRESULT,
    get_dataType: ?fn ([*c]IXMLDOMNode, [*c]VARIANT) callconv(.C) HRESULT,
    put_dataType: ?fn ([*c]IXMLDOMNode, BSTR) callconv(.C) HRESULT,
    get_xml: ?fn ([*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    transformNode: ?fn ([*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    selectNodes: ?fn ([*c]IXMLDOMNode, BSTR, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    selectSingleNode: ?fn ([*c]IXMLDOMNode, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_parsed: ?fn ([*c]IXMLDOMNode, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_namespaceURI: ?fn ([*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    get_prefix: ?fn ([*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    get_baseName: ?fn ([*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    transformNodeToObject: ?fn ([*c]IXMLDOMNode, [*c]IXMLDOMNode, VARIANT) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMNode = extern struct {
    lpVtbl: [*c]struct_IXMLDOMNodeVtbl,
};
pub const IXMLDOMCharacterData = struct_IXMLDOMCharacterData;
pub const struct_IXMLDOMCharacterDataVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMCharacterData, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMCharacterData) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMCharacterData) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMCharacterData, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMCharacterData, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMCharacterData, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMCharacterData, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_nodeName: ?fn ([*c]IXMLDOMCharacterData, [*c]BSTR) callconv(.C) HRESULT,
    get_nodeValue: ?fn ([*c]IXMLDOMCharacterData, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeValue: ?fn ([*c]IXMLDOMCharacterData, VARIANT) callconv(.C) HRESULT,
    get_nodeType: ?fn ([*c]IXMLDOMCharacterData, [*c]DOMNodeType) callconv(.C) HRESULT,
    get_parentNode: ?fn ([*c]IXMLDOMCharacterData, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_childNodes: ?fn ([*c]IXMLDOMCharacterData, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    get_firstChild: ?fn ([*c]IXMLDOMCharacterData, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_lastChild: ?fn ([*c]IXMLDOMCharacterData, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_previousSibling: ?fn ([*c]IXMLDOMCharacterData, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nextSibling: ?fn ([*c]IXMLDOMCharacterData, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_attributes: ?fn ([*c]IXMLDOMCharacterData, [*c]([*c]IXMLDOMNamedNodeMap)) callconv(.C) HRESULT,
    insertBefore: ?fn ([*c]IXMLDOMCharacterData, [*c]IXMLDOMNode, VARIANT, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    replaceChild: ?fn ([*c]IXMLDOMCharacterData, [*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    removeChild: ?fn ([*c]IXMLDOMCharacterData, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    appendChild: ?fn ([*c]IXMLDOMCharacterData, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    hasChildNodes: ?fn ([*c]IXMLDOMCharacterData, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_ownerDocument: ?fn ([*c]IXMLDOMCharacterData, [*c]([*c]IXMLDOMDocument)) callconv(.C) HRESULT,
    cloneNode: ?fn ([*c]IXMLDOMCharacterData, VARIANT_BOOL, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypeString: ?fn ([*c]IXMLDOMCharacterData, [*c]BSTR) callconv(.C) HRESULT,
    get_text: ?fn ([*c]IXMLDOMCharacterData, [*c]BSTR) callconv(.C) HRESULT,
    put_text: ?fn ([*c]IXMLDOMCharacterData, BSTR) callconv(.C) HRESULT,
    get_specified: ?fn ([*c]IXMLDOMCharacterData, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_definition: ?fn ([*c]IXMLDOMCharacterData, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypedValue: ?fn ([*c]IXMLDOMCharacterData, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeTypedValue: ?fn ([*c]IXMLDOMCharacterData, VARIANT) callconv(.C) HRESULT,
    get_dataType: ?fn ([*c]IXMLDOMCharacterData, [*c]VARIANT) callconv(.C) HRESULT,
    put_dataType: ?fn ([*c]IXMLDOMCharacterData, BSTR) callconv(.C) HRESULT,
    get_xml: ?fn ([*c]IXMLDOMCharacterData, [*c]BSTR) callconv(.C) HRESULT,
    transformNode: ?fn ([*c]IXMLDOMCharacterData, [*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    selectNodes: ?fn ([*c]IXMLDOMCharacterData, BSTR, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    selectSingleNode: ?fn ([*c]IXMLDOMCharacterData, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_parsed: ?fn ([*c]IXMLDOMCharacterData, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_namespaceURI: ?fn ([*c]IXMLDOMCharacterData, [*c]BSTR) callconv(.C) HRESULT,
    get_prefix: ?fn ([*c]IXMLDOMCharacterData, [*c]BSTR) callconv(.C) HRESULT,
    get_baseName: ?fn ([*c]IXMLDOMCharacterData, [*c]BSTR) callconv(.C) HRESULT,
    transformNodeToObject: ?fn ([*c]IXMLDOMCharacterData, [*c]IXMLDOMNode, VARIANT) callconv(.C) HRESULT,
    get_data: ?fn ([*c]IXMLDOMCharacterData, [*c]BSTR) callconv(.C) HRESULT,
    put_data: ?fn ([*c]IXMLDOMCharacterData, BSTR) callconv(.C) HRESULT,
    get_length: ?fn ([*c]IXMLDOMCharacterData, [*c]c_long) callconv(.C) HRESULT,
    substringData: ?fn ([*c]IXMLDOMCharacterData, c_long, c_long, [*c]BSTR) callconv(.C) HRESULT,
    appendData: ?fn ([*c]IXMLDOMCharacterData, BSTR) callconv(.C) HRESULT,
    insertData: ?fn ([*c]IXMLDOMCharacterData, c_long, BSTR) callconv(.C) HRESULT,
    deleteData: ?fn ([*c]IXMLDOMCharacterData, c_long, c_long) callconv(.C) HRESULT,
    replaceData: ?fn ([*c]IXMLDOMCharacterData, c_long, c_long, BSTR) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMCharacterData = extern struct {
    lpVtbl: [*c]struct_IXMLDOMCharacterDataVtbl,
};
pub const IXMLDOMNotation = struct_IXMLDOMNotation;
pub const struct_IXMLDOMNotationVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMNotation, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMNotation) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMNotation) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMNotation, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMNotation, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMNotation, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMNotation, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_nodeName: ?fn ([*c]IXMLDOMNotation, [*c]BSTR) callconv(.C) HRESULT,
    get_nodeValue: ?fn ([*c]IXMLDOMNotation, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeValue: ?fn ([*c]IXMLDOMNotation, VARIANT) callconv(.C) HRESULT,
    get_nodeType: ?fn ([*c]IXMLDOMNotation, [*c]DOMNodeType) callconv(.C) HRESULT,
    get_parentNode: ?fn ([*c]IXMLDOMNotation, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_childNodes: ?fn ([*c]IXMLDOMNotation, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    get_firstChild: ?fn ([*c]IXMLDOMNotation, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_lastChild: ?fn ([*c]IXMLDOMNotation, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_previousSibling: ?fn ([*c]IXMLDOMNotation, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nextSibling: ?fn ([*c]IXMLDOMNotation, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_attributes: ?fn ([*c]IXMLDOMNotation, [*c]([*c]IXMLDOMNamedNodeMap)) callconv(.C) HRESULT,
    insertBefore: ?fn ([*c]IXMLDOMNotation, [*c]IXMLDOMNode, VARIANT, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    replaceChild: ?fn ([*c]IXMLDOMNotation, [*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    removeChild: ?fn ([*c]IXMLDOMNotation, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    appendChild: ?fn ([*c]IXMLDOMNotation, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    hasChildNodes: ?fn ([*c]IXMLDOMNotation, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_ownerDocument: ?fn ([*c]IXMLDOMNotation, [*c]([*c]IXMLDOMDocument)) callconv(.C) HRESULT,
    cloneNode: ?fn ([*c]IXMLDOMNotation, VARIANT_BOOL, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypeString: ?fn ([*c]IXMLDOMNotation, [*c]BSTR) callconv(.C) HRESULT,
    get_text: ?fn ([*c]IXMLDOMNotation, [*c]BSTR) callconv(.C) HRESULT,
    put_text: ?fn ([*c]IXMLDOMNotation, BSTR) callconv(.C) HRESULT,
    get_specified: ?fn ([*c]IXMLDOMNotation, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_definition: ?fn ([*c]IXMLDOMNotation, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypedValue: ?fn ([*c]IXMLDOMNotation, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeTypedValue: ?fn ([*c]IXMLDOMNotation, VARIANT) callconv(.C) HRESULT,
    get_dataType: ?fn ([*c]IXMLDOMNotation, [*c]VARIANT) callconv(.C) HRESULT,
    put_dataType: ?fn ([*c]IXMLDOMNotation, BSTR) callconv(.C) HRESULT,
    get_xml: ?fn ([*c]IXMLDOMNotation, [*c]BSTR) callconv(.C) HRESULT,
    transformNode: ?fn ([*c]IXMLDOMNotation, [*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    selectNodes: ?fn ([*c]IXMLDOMNotation, BSTR, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    selectSingleNode: ?fn ([*c]IXMLDOMNotation, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_parsed: ?fn ([*c]IXMLDOMNotation, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_namespaceURI: ?fn ([*c]IXMLDOMNotation, [*c]BSTR) callconv(.C) HRESULT,
    get_prefix: ?fn ([*c]IXMLDOMNotation, [*c]BSTR) callconv(.C) HRESULT,
    get_baseName: ?fn ([*c]IXMLDOMNotation, [*c]BSTR) callconv(.C) HRESULT,
    transformNodeToObject: ?fn ([*c]IXMLDOMNotation, [*c]IXMLDOMNode, VARIANT) callconv(.C) HRESULT,
    get_publicId: ?fn ([*c]IXMLDOMNotation, [*c]VARIANT) callconv(.C) HRESULT,
    get_systemId: ?fn ([*c]IXMLDOMNotation, [*c]VARIANT) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMNotation = extern struct {
    lpVtbl: [*c]struct_IXMLDOMNotationVtbl,
};
pub const IXMLDOMEntity = struct_IXMLDOMEntity;
pub const struct_IXMLDOMEntityVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDOMEntity, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDOMEntity) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDOMEntity) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDOMEntity, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDOMEntity, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDOMEntity, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDOMEntity, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_nodeName: ?fn ([*c]IXMLDOMEntity, [*c]BSTR) callconv(.C) HRESULT,
    get_nodeValue: ?fn ([*c]IXMLDOMEntity, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeValue: ?fn ([*c]IXMLDOMEntity, VARIANT) callconv(.C) HRESULT,
    get_nodeType: ?fn ([*c]IXMLDOMEntity, [*c]DOMNodeType) callconv(.C) HRESULT,
    get_parentNode: ?fn ([*c]IXMLDOMEntity, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_childNodes: ?fn ([*c]IXMLDOMEntity, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    get_firstChild: ?fn ([*c]IXMLDOMEntity, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_lastChild: ?fn ([*c]IXMLDOMEntity, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_previousSibling: ?fn ([*c]IXMLDOMEntity, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nextSibling: ?fn ([*c]IXMLDOMEntity, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_attributes: ?fn ([*c]IXMLDOMEntity, [*c]([*c]IXMLDOMNamedNodeMap)) callconv(.C) HRESULT,
    insertBefore: ?fn ([*c]IXMLDOMEntity, [*c]IXMLDOMNode, VARIANT, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    replaceChild: ?fn ([*c]IXMLDOMEntity, [*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    removeChild: ?fn ([*c]IXMLDOMEntity, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    appendChild: ?fn ([*c]IXMLDOMEntity, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    hasChildNodes: ?fn ([*c]IXMLDOMEntity, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_ownerDocument: ?fn ([*c]IXMLDOMEntity, [*c]([*c]IXMLDOMDocument)) callconv(.C) HRESULT,
    cloneNode: ?fn ([*c]IXMLDOMEntity, VARIANT_BOOL, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypeString: ?fn ([*c]IXMLDOMEntity, [*c]BSTR) callconv(.C) HRESULT,
    get_text: ?fn ([*c]IXMLDOMEntity, [*c]BSTR) callconv(.C) HRESULT,
    put_text: ?fn ([*c]IXMLDOMEntity, BSTR) callconv(.C) HRESULT,
    get_specified: ?fn ([*c]IXMLDOMEntity, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_definition: ?fn ([*c]IXMLDOMEntity, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypedValue: ?fn ([*c]IXMLDOMEntity, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeTypedValue: ?fn ([*c]IXMLDOMEntity, VARIANT) callconv(.C) HRESULT,
    get_dataType: ?fn ([*c]IXMLDOMEntity, [*c]VARIANT) callconv(.C) HRESULT,
    put_dataType: ?fn ([*c]IXMLDOMEntity, BSTR) callconv(.C) HRESULT,
    get_xml: ?fn ([*c]IXMLDOMEntity, [*c]BSTR) callconv(.C) HRESULT,
    transformNode: ?fn ([*c]IXMLDOMEntity, [*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    selectNodes: ?fn ([*c]IXMLDOMEntity, BSTR, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    selectSingleNode: ?fn ([*c]IXMLDOMEntity, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_parsed: ?fn ([*c]IXMLDOMEntity, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_namespaceURI: ?fn ([*c]IXMLDOMEntity, [*c]BSTR) callconv(.C) HRESULT,
    get_prefix: ?fn ([*c]IXMLDOMEntity, [*c]BSTR) callconv(.C) HRESULT,
    get_baseName: ?fn ([*c]IXMLDOMEntity, [*c]BSTR) callconv(.C) HRESULT,
    transformNodeToObject: ?fn ([*c]IXMLDOMEntity, [*c]IXMLDOMNode, VARIANT) callconv(.C) HRESULT,
    get_publicId: ?fn ([*c]IXMLDOMEntity, [*c]VARIANT) callconv(.C) HRESULT,
    get_systemId: ?fn ([*c]IXMLDOMEntity, [*c]VARIANT) callconv(.C) HRESULT,
    get_notationName: ?fn ([*c]IXMLDOMEntity, [*c]BSTR) callconv(.C) HRESULT,
};
pub const struct_IXMLDOMEntity = extern struct {
    lpVtbl: [*c]struct_IXMLDOMEntityVtbl,
};
pub const IXTLRuntime = struct_IXTLRuntime;
pub const struct_IXTLRuntimeVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXTLRuntime, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXTLRuntime) callconv(.C) ULONG,
    Release: ?fn ([*c]IXTLRuntime) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXTLRuntime, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXTLRuntime, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXTLRuntime, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXTLRuntime, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_nodeName: ?fn ([*c]IXTLRuntime, [*c]BSTR) callconv(.C) HRESULT,
    get_nodeValue: ?fn ([*c]IXTLRuntime, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeValue: ?fn ([*c]IXTLRuntime, VARIANT) callconv(.C) HRESULT,
    get_nodeType: ?fn ([*c]IXTLRuntime, [*c]DOMNodeType) callconv(.C) HRESULT,
    get_parentNode: ?fn ([*c]IXTLRuntime, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_childNodes: ?fn ([*c]IXTLRuntime, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    get_firstChild: ?fn ([*c]IXTLRuntime, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_lastChild: ?fn ([*c]IXTLRuntime, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_previousSibling: ?fn ([*c]IXTLRuntime, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nextSibling: ?fn ([*c]IXTLRuntime, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_attributes: ?fn ([*c]IXTLRuntime, [*c]([*c]IXMLDOMNamedNodeMap)) callconv(.C) HRESULT,
    insertBefore: ?fn ([*c]IXTLRuntime, [*c]IXMLDOMNode, VARIANT, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    replaceChild: ?fn ([*c]IXTLRuntime, [*c]IXMLDOMNode, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    removeChild: ?fn ([*c]IXTLRuntime, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    appendChild: ?fn ([*c]IXTLRuntime, [*c]IXMLDOMNode, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    hasChildNodes: ?fn ([*c]IXTLRuntime, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_ownerDocument: ?fn ([*c]IXTLRuntime, [*c]([*c]IXMLDOMDocument)) callconv(.C) HRESULT,
    cloneNode: ?fn ([*c]IXTLRuntime, VARIANT_BOOL, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypeString: ?fn ([*c]IXTLRuntime, [*c]BSTR) callconv(.C) HRESULT,
    get_text: ?fn ([*c]IXTLRuntime, [*c]BSTR) callconv(.C) HRESULT,
    put_text: ?fn ([*c]IXTLRuntime, BSTR) callconv(.C) HRESULT,
    get_specified: ?fn ([*c]IXTLRuntime, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_definition: ?fn ([*c]IXTLRuntime, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_nodeTypedValue: ?fn ([*c]IXTLRuntime, [*c]VARIANT) callconv(.C) HRESULT,
    put_nodeTypedValue: ?fn ([*c]IXTLRuntime, VARIANT) callconv(.C) HRESULT,
    get_dataType: ?fn ([*c]IXTLRuntime, [*c]VARIANT) callconv(.C) HRESULT,
    put_dataType: ?fn ([*c]IXTLRuntime, BSTR) callconv(.C) HRESULT,
    get_xml: ?fn ([*c]IXTLRuntime, [*c]BSTR) callconv(.C) HRESULT,
    transformNode: ?fn ([*c]IXTLRuntime, [*c]IXMLDOMNode, [*c]BSTR) callconv(.C) HRESULT,
    selectNodes: ?fn ([*c]IXTLRuntime, BSTR, [*c]([*c]IXMLDOMNodeList)) callconv(.C) HRESULT,
    selectSingleNode: ?fn ([*c]IXTLRuntime, BSTR, [*c]([*c]IXMLDOMNode)) callconv(.C) HRESULT,
    get_parsed: ?fn ([*c]IXTLRuntime, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    get_namespaceURI: ?fn ([*c]IXTLRuntime, [*c]BSTR) callconv(.C) HRESULT,
    get_prefix: ?fn ([*c]IXTLRuntime, [*c]BSTR) callconv(.C) HRESULT,
    get_baseName: ?fn ([*c]IXTLRuntime, [*c]BSTR) callconv(.C) HRESULT,
    transformNodeToObject: ?fn ([*c]IXTLRuntime, [*c]IXMLDOMNode, VARIANT) callconv(.C) HRESULT,
    uniqueID: ?fn ([*c]IXTLRuntime, [*c]IXMLDOMNode, [*c]c_long) callconv(.C) HRESULT,
    depth: ?fn ([*c]IXTLRuntime, [*c]IXMLDOMNode, [*c]c_long) callconv(.C) HRESULT,
    childNumber: ?fn ([*c]IXTLRuntime, [*c]IXMLDOMNode, [*c]c_long) callconv(.C) HRESULT,
    ancestorChildNumber: ?fn ([*c]IXTLRuntime, BSTR, [*c]IXMLDOMNode, [*c]c_long) callconv(.C) HRESULT,
    absoluteChildNumber: ?fn ([*c]IXTLRuntime, [*c]IXMLDOMNode, [*c]c_long) callconv(.C) HRESULT,
    formatIndex: ?fn ([*c]IXTLRuntime, c_long, BSTR, [*c]BSTR) callconv(.C) HRESULT,
    formatNumber: ?fn ([*c]IXTLRuntime, f64, BSTR, [*c]BSTR) callconv(.C) HRESULT,
    formatDate: ?fn ([*c]IXTLRuntime, VARIANT, BSTR, VARIANT, [*c]BSTR) callconv(.C) HRESULT,
    formatTime: ?fn ([*c]IXTLRuntime, VARIANT, BSTR, VARIANT, [*c]BSTR) callconv(.C) HRESULT,
};
pub const struct_IXTLRuntime = extern struct {
    lpVtbl: [*c]struct_IXTLRuntimeVtbl,
};
pub const XMLDOMDocumentEvents = struct_XMLDOMDocumentEvents;
pub const struct_XMLDOMDocumentEventsVtbl = extern struct {
    QueryInterface: ?fn ([*c]XMLDOMDocumentEvents, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]XMLDOMDocumentEvents) callconv(.C) ULONG,
    Release: ?fn ([*c]XMLDOMDocumentEvents) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]XMLDOMDocumentEvents, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]XMLDOMDocumentEvents, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]XMLDOMDocumentEvents, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]XMLDOMDocumentEvents, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
};
pub const struct_XMLDOMDocumentEvents = extern struct {
    lpVtbl: [*c]struct_XMLDOMDocumentEventsVtbl,
};
pub const struct_DOMDocument = @OpaqueType();
pub const DOMDocument = struct_DOMDocument;
pub const struct_DOMFreeThreadedDocument = @OpaqueType();
pub const DOMFreeThreadedDocument = struct_DOMFreeThreadedDocument;
pub const IXMLHttpRequest = struct_IXMLHttpRequest;
pub const struct_IXMLHttpRequestVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLHttpRequest, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLHttpRequest) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLHttpRequest) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLHttpRequest, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLHttpRequest, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLHttpRequest, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLHttpRequest, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    open: ?fn ([*c]IXMLHttpRequest, BSTR, BSTR, VARIANT, VARIANT, VARIANT) callconv(.C) HRESULT,
    setRequestHeader: ?fn ([*c]IXMLHttpRequest, BSTR, BSTR) callconv(.C) HRESULT,
    getResponseHeader: ?fn ([*c]IXMLHttpRequest, BSTR, [*c]BSTR) callconv(.C) HRESULT,
    getAllResponseHeaders: ?fn ([*c]IXMLHttpRequest, [*c]BSTR) callconv(.C) HRESULT,
    send: ?fn ([*c]IXMLHttpRequest, VARIANT) callconv(.C) HRESULT,
    abort: ?fn ([*c]IXMLHttpRequest) callconv(.C) HRESULT,
    get_status: ?fn ([*c]IXMLHttpRequest, [*c]c_long) callconv(.C) HRESULT,
    get_statusText: ?fn ([*c]IXMLHttpRequest, [*c]BSTR) callconv(.C) HRESULT,
    get_responseXML: ?fn ([*c]IXMLHttpRequest, [*c]([*c]IDispatch)) callconv(.C) HRESULT,
    get_responseText: ?fn ([*c]IXMLHttpRequest, [*c]BSTR) callconv(.C) HRESULT,
    get_responseBody: ?fn ([*c]IXMLHttpRequest, [*c]VARIANT) callconv(.C) HRESULT,
    get_responseStream: ?fn ([*c]IXMLHttpRequest, [*c]VARIANT) callconv(.C) HRESULT,
    get_readyState: ?fn ([*c]IXMLHttpRequest, [*c]c_long) callconv(.C) HRESULT,
    put_onreadystatechange: ?fn ([*c]IXMLHttpRequest, [*c]IDispatch) callconv(.C) HRESULT,
};
pub const struct_IXMLHttpRequest = extern struct {
    lpVtbl: [*c]struct_IXMLHttpRequestVtbl,
};
pub const struct_XMLHTTPRequest = @OpaqueType();
pub const XMLHTTPRequest = struct_XMLHTTPRequest;
pub const IXMLDSOControl = struct_IXMLDSOControl;
pub const struct_IXMLDSOControlVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDSOControl, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDSOControl) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDSOControl) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDSOControl, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDSOControl, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDSOControl, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDSOControl, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_XMLDocument: ?fn ([*c]IXMLDSOControl, [*c]([*c]IXMLDOMDocument)) callconv(.C) HRESULT,
    put_XMLDocument: ?fn ([*c]IXMLDSOControl, [*c]IXMLDOMDocument) callconv(.C) HRESULT,
    get_JavaDSOCompatible: ?fn ([*c]IXMLDSOControl, [*c]BOOL) callconv(.C) HRESULT,
    put_JavaDSOCompatible: ?fn ([*c]IXMLDSOControl, BOOL) callconv(.C) HRESULT,
    get_readyState: ?fn ([*c]IXMLDSOControl, [*c]c_long) callconv(.C) HRESULT,
};
pub const struct_IXMLDSOControl = extern struct {
    lpVtbl: [*c]struct_IXMLDSOControlVtbl,
};
pub const struct_XMLDSOControl = @OpaqueType();
pub const XMLDSOControl = struct_XMLDSOControl;
pub const IXMLDocument = struct_IXMLDocument;
pub const struct_IXMLDocumentVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDocument, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDocument) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDocument) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDocument, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDocument, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDocument, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDocument, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_root: ?fn ([*c]IXMLDocument, [*c]([*c]IXMLElement)) callconv(.C) HRESULT,
    get_fileSize: ?fn ([*c]IXMLDocument, [*c]BSTR) callconv(.C) HRESULT,
    get_fileModifiedDate: ?fn ([*c]IXMLDocument, [*c]BSTR) callconv(.C) HRESULT,
    get_fileUpdatedDate: ?fn ([*c]IXMLDocument, [*c]BSTR) callconv(.C) HRESULT,
    get_URL: ?fn ([*c]IXMLDocument, [*c]BSTR) callconv(.C) HRESULT,
    put_URL: ?fn ([*c]IXMLDocument, BSTR) callconv(.C) HRESULT,
    get_mimeType: ?fn ([*c]IXMLDocument, [*c]BSTR) callconv(.C) HRESULT,
    get_readyState: ?fn ([*c]IXMLDocument, [*c]c_long) callconv(.C) HRESULT,
    get_charset: ?fn ([*c]IXMLDocument, [*c]BSTR) callconv(.C) HRESULT,
    put_charset: ?fn ([*c]IXMLDocument, BSTR) callconv(.C) HRESULT,
    get_version: ?fn ([*c]IXMLDocument, [*c]BSTR) callconv(.C) HRESULT,
    get_doctype: ?fn ([*c]IXMLDocument, [*c]BSTR) callconv(.C) HRESULT,
    get_dtdURL: ?fn ([*c]IXMLDocument, [*c]BSTR) callconv(.C) HRESULT,
    createElement: ?fn ([*c]IXMLDocument, VARIANT, VARIANT, [*c]([*c]IXMLElement)) callconv(.C) HRESULT,
};
pub const struct_IXMLDocument = extern struct {
    lpVtbl: [*c]struct_IXMLDocumentVtbl,
};
pub const IXMLDocument2 = struct_IXMLDocument2;
pub const struct_IXMLElement2Vtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLElement2, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLElement2) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLElement2) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLElement2, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLElement2, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLElement2, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLElement2, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_tagName: ?fn ([*c]IXMLElement2, [*c]BSTR) callconv(.C) HRESULT,
    put_tagName: ?fn ([*c]IXMLElement2, BSTR) callconv(.C) HRESULT,
    get_parent: ?fn ([*c]IXMLElement2, [*c]([*c]IXMLElement2)) callconv(.C) HRESULT,
    setAttribute: ?fn ([*c]IXMLElement2, BSTR, VARIANT) callconv(.C) HRESULT,
    getAttribute: ?fn ([*c]IXMLElement2, BSTR, [*c]VARIANT) callconv(.C) HRESULT,
    removeAttribute: ?fn ([*c]IXMLElement2, BSTR) callconv(.C) HRESULT,
    get_children: ?fn ([*c]IXMLElement2, [*c]([*c]IXMLElementCollection)) callconv(.C) HRESULT,
    get_type: ?fn ([*c]IXMLElement2, [*c]c_long) callconv(.C) HRESULT,
    get_text: ?fn ([*c]IXMLElement2, [*c]BSTR) callconv(.C) HRESULT,
    put_text: ?fn ([*c]IXMLElement2, BSTR) callconv(.C) HRESULT,
    addChild: ?fn ([*c]IXMLElement2, [*c]IXMLElement2, c_long, c_long) callconv(.C) HRESULT,
    removeChild: ?fn ([*c]IXMLElement2, [*c]IXMLElement2) callconv(.C) HRESULT,
    get_attributes: ?fn ([*c]IXMLElement2, [*c]([*c]IXMLElementCollection)) callconv(.C) HRESULT,
};
pub const struct_IXMLElement2 = extern struct {
    lpVtbl: [*c]struct_IXMLElement2Vtbl,
};
pub const IXMLElement2 = struct_IXMLElement2;
pub const struct_IXMLDocument2Vtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLDocument2, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLDocument2) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLDocument2) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLDocument2, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLDocument2, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLDocument2, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLDocument2, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_root: ?fn ([*c]IXMLDocument2, [*c]([*c]IXMLElement2)) callconv(.C) HRESULT,
    get_fileSize: ?fn ([*c]IXMLDocument2, [*c]BSTR) callconv(.C) HRESULT,
    get_fileModifiedDate: ?fn ([*c]IXMLDocument2, [*c]BSTR) callconv(.C) HRESULT,
    get_fileUpdatedDate: ?fn ([*c]IXMLDocument2, [*c]BSTR) callconv(.C) HRESULT,
    get_URL: ?fn ([*c]IXMLDocument2, [*c]BSTR) callconv(.C) HRESULT,
    put_URL: ?fn ([*c]IXMLDocument2, BSTR) callconv(.C) HRESULT,
    get_mimeType: ?fn ([*c]IXMLDocument2, [*c]BSTR) callconv(.C) HRESULT,
    get_readyState: ?fn ([*c]IXMLDocument2, [*c]c_long) callconv(.C) HRESULT,
    get_charset: ?fn ([*c]IXMLDocument2, [*c]BSTR) callconv(.C) HRESULT,
    put_charset: ?fn ([*c]IXMLDocument2, BSTR) callconv(.C) HRESULT,
    get_version: ?fn ([*c]IXMLDocument2, [*c]BSTR) callconv(.C) HRESULT,
    get_doctype: ?fn ([*c]IXMLDocument2, [*c]BSTR) callconv(.C) HRESULT,
    get_dtdURL: ?fn ([*c]IXMLDocument2, [*c]BSTR) callconv(.C) HRESULT,
    createElement: ?fn ([*c]IXMLDocument2, VARIANT, VARIANT, [*c]([*c]IXMLElement2)) callconv(.C) HRESULT,
    get_async: ?fn ([*c]IXMLDocument2, [*c]VARIANT_BOOL) callconv(.C) HRESULT,
    put_async: ?fn ([*c]IXMLDocument2, VARIANT_BOOL) callconv(.C) HRESULT,
};
pub const struct_IXMLDocument2 = extern struct {
    lpVtbl: [*c]struct_IXMLDocument2Vtbl,
};
pub const IXMLAttribute = struct_IXMLAttribute;
pub const struct_IXMLAttributeVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLAttribute, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLAttribute) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLAttribute) callconv(.C) ULONG,
    GetTypeInfoCount: ?fn ([*c]IXMLAttribute, [*c]UINT) callconv(.C) HRESULT,
    GetTypeInfo: ?fn ([*c]IXMLAttribute, UINT, LCID, [*c]([*c]ITypeInfo)) callconv(.C) HRESULT,
    GetIDsOfNames: ?fn ([*c]IXMLAttribute, [*c]const IID, [*c]LPOLESTR, UINT, LCID, [*c]DISPID) callconv(.C) HRESULT,
    Invoke: ?fn ([*c]IXMLAttribute, DISPID, [*c]const IID, LCID, WORD, [*c]DISPPARAMS, [*c]VARIANT, [*c]EXCEPINFO, [*c]UINT) callconv(.C) HRESULT,
    get_name: ?fn ([*c]IXMLAttribute, [*c]BSTR) callconv(.C) HRESULT,
    get_value: ?fn ([*c]IXMLAttribute, [*c]BSTR) callconv(.C) HRESULT,
};
pub const struct_IXMLAttribute = extern struct {
    lpVtbl: [*c]struct_IXMLAttributeVtbl,
};
pub const IXMLError = struct_IXMLError;
pub const struct__xml_error = extern struct {
    _nLine: c_uint,
    _pchBuf: BSTR,
    _cchBuf: c_uint,
    _ich: c_uint,
    _pszFound: BSTR,
    _pszExpected: BSTR,
    _reserved1: DWORD,
    _reserved2: DWORD,
};
pub const XML_ERROR = struct__xml_error;
pub const struct_IXMLErrorVtbl = extern struct {
    QueryInterface: ?fn ([*c]IXMLError, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IXMLError) callconv(.C) ULONG,
    Release: ?fn ([*c]IXMLError) callconv(.C) ULONG,
    GetErrorInfo: ?fn ([*c]IXMLError, [*c]XML_ERROR) callconv(.C) HRESULT,
};
pub const struct_IXMLError = extern struct {
    lpVtbl: [*c]struct_IXMLErrorVtbl,
};
pub const struct_XMLDocument = @OpaqueType();
pub const XMLDocument = struct_XMLDocument;
pub extern var __MIDL_itf_msxml_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_msxml_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const XMLELEMTYPE_ELEMENT = enum_tagXMLEMEM_TYPE.XMLELEMTYPE_ELEMENT;
pub const XMLELEMTYPE_TEXT = enum_tagXMLEMEM_TYPE.XMLELEMTYPE_TEXT;
pub const XMLELEMTYPE_COMMENT = enum_tagXMLEMEM_TYPE.XMLELEMTYPE_COMMENT;
pub const XMLELEMTYPE_DOCUMENT = enum_tagXMLEMEM_TYPE.XMLELEMTYPE_DOCUMENT;
pub const XMLELEMTYPE_DTD = enum_tagXMLEMEM_TYPE.XMLELEMTYPE_DTD;
pub const XMLELEMTYPE_PI = enum_tagXMLEMEM_TYPE.XMLELEMTYPE_PI;
pub const XMLELEMTYPE_OTHER = enum_tagXMLEMEM_TYPE.XMLELEMTYPE_OTHER;
pub const enum_tagXMLEMEM_TYPE = extern enum {
    XMLELEMTYPE_ELEMENT = 0,
    XMLELEMTYPE_TEXT = 1,
    XMLELEMTYPE_COMMENT = 2,
    XMLELEMTYPE_DOCUMENT = 3,
    XMLELEMTYPE_DTD = 4,
    XMLELEMTYPE_PI = 5,
    XMLELEMTYPE_OTHER = 6,
};
pub const XMLELEM_TYPE = enum_tagXMLEMEM_TYPE;
pub extern const LIBID_MSXML: IID;
pub extern const IID_IXMLDOMImplementation: IID;
pub const IXMLDOMImplementationVtbl = struct_IXMLDOMImplementationVtbl;
pub extern const IID_IXMLDOMNode: IID;
pub const IXMLDOMNodeVtbl = struct_IXMLDOMNodeVtbl;
pub extern const IID_IXMLDOMDocumentFragment: IID;
pub const IXMLDOMDocumentFragmentVtbl = struct_IXMLDOMDocumentFragmentVtbl;
pub extern const IID_IXMLDOMDocument: IID;
pub const IXMLDOMDocumentVtbl = struct_IXMLDOMDocumentVtbl;
pub extern const IID_IXMLDOMNodeList: IID;
pub const IXMLDOMNodeListVtbl = struct_IXMLDOMNodeListVtbl;
pub extern const IID_IXMLDOMNamedNodeMap: IID;
pub const IXMLDOMNamedNodeMapVtbl = struct_IXMLDOMNamedNodeMapVtbl;
pub extern const IID_IXMLDOMCharacterData: IID;
pub const IXMLDOMCharacterDataVtbl = struct_IXMLDOMCharacterDataVtbl;
pub extern const IID_IXMLDOMAttribute: IID;
pub const IXMLDOMAttributeVtbl = struct_IXMLDOMAttributeVtbl;
pub extern const IID_IXMLDOMElement: IID;
pub const IXMLDOMElementVtbl = struct_IXMLDOMElementVtbl;
pub extern const IID_IXMLDOMText: IID;
pub const IXMLDOMTextVtbl = struct_IXMLDOMTextVtbl;
pub extern const IID_IXMLDOMComment: IID;
pub const IXMLDOMCommentVtbl = struct_IXMLDOMCommentVtbl;
pub extern const IID_IXMLDOMProcessingInstruction: IID;
pub const IXMLDOMProcessingInstructionVtbl = struct_IXMLDOMProcessingInstructionVtbl;
pub extern const IID_IXMLDOMCDATASection: IID;
pub const IXMLDOMCDATASectionVtbl = struct_IXMLDOMCDATASectionVtbl;
pub extern const IID_IXMLDOMDocumentType: IID;
pub const IXMLDOMDocumentTypeVtbl = struct_IXMLDOMDocumentTypeVtbl;
pub extern const IID_IXMLDOMNotation: IID;
pub const IXMLDOMNotationVtbl = struct_IXMLDOMNotationVtbl;
pub extern const IID_IXMLDOMEntity: IID;
pub const IXMLDOMEntityVtbl = struct_IXMLDOMEntityVtbl;
pub extern const IID_IXMLDOMEntityReference: IID;
pub const IXMLDOMEntityReferenceVtbl = struct_IXMLDOMEntityReferenceVtbl;
pub extern const IID_IXMLDOMParseError: IID;
pub const IXMLDOMParseErrorVtbl = struct_IXMLDOMParseErrorVtbl;
pub extern const IID_IXTLRuntime: IID;
pub const IXTLRuntimeVtbl = struct_IXTLRuntimeVtbl;
pub extern const DIID_XMLDOMDocumentEvents: IID;
pub const XMLDOMDocumentEventsVtbl = struct_XMLDOMDocumentEventsVtbl;
pub extern const CLSID_DOMDocument: CLSID;
pub extern const CLSID_DOMFreeThreadedDocument: CLSID;
pub extern const IID_IXMLHttpRequest: IID;
pub const IXMLHttpRequestVtbl = struct_IXMLHttpRequestVtbl;
pub extern const CLSID_XMLHTTPRequest: CLSID;
pub extern const IID_IXMLDSOControl: IID;
pub const IXMLDSOControlVtbl = struct_IXMLDSOControlVtbl;
pub extern const CLSID_XMLDSOControl: CLSID;
pub extern const IID_IXMLElementCollection: IID;
pub const IXMLElementCollectionVtbl = struct_IXMLElementCollectionVtbl;
pub extern const IID_IXMLDocument: IID;
pub const IXMLDocumentVtbl = struct_IXMLDocumentVtbl;
pub extern const IID_IXMLDocument2: IID;
pub const IXMLDocument2Vtbl = struct_IXMLDocument2Vtbl;
pub extern const IID_IXMLElement: IID;
pub const IXMLElementVtbl = struct_IXMLElementVtbl;
pub extern const IID_IXMLElement2: IID;
pub const IXMLElement2Vtbl = struct_IXMLElement2Vtbl;
pub extern const IID_IXMLAttribute: IID;
pub const IXMLAttributeVtbl = struct_IXMLAttributeVtbl;
pub extern const IID_IXMLError: IID;
pub const IXMLErrorVtbl = struct_IXMLErrorVtbl;
pub extern const CLSID_XMLDocument: CLSID;
pub extern var __MIDL_itf_msxml_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_msxml_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const CLSID_SBS_StdURLMoniker: IID;
pub extern const CLSID_SBS_HttpProtocol: IID;
pub extern const CLSID_SBS_FtpProtocol: IID;
pub extern const CLSID_SBS_GopherProtocol: IID;
pub extern const CLSID_SBS_HttpSProtocol: IID;
pub extern const CLSID_SBS_FileProtocol: IID;
pub extern const CLSID_SBS_MkProtocol: IID;
pub extern const CLSID_SBS_UrlMkBindCtx: IID;
pub extern const CLSID_SBS_SoftDistExt: IID;
pub extern const CLSID_SBS_CdlProtocol: IID;
pub extern const CLSID_SBS_ClassInstallFilter: IID;
pub extern const CLSID_SBS_InternetSecurityManager: IID;
pub extern const CLSID_SBS_InternetZoneManager: IID;
pub extern const IID_IAsyncMoniker: IID;
pub extern const CLSID_StdURLMoniker: IID;
pub extern const CLSID_HttpProtocol: IID;
pub extern const CLSID_FtpProtocol: IID;
pub extern const CLSID_GopherProtocol: IID;
pub extern const CLSID_HttpSProtocol: IID;
pub extern const CLSID_FileProtocol: IID;
pub extern const CLSID_ResProtocol: IID;
pub extern const CLSID_AboutProtocol: IID;
pub extern const CLSID_JSProtocol: IID;
pub extern const CLSID_MailtoProtocol: IID;
pub extern const CLSID_IE4_PROTOCOLS: IID;
pub extern const CLSID_MkProtocol: IID;
pub extern const CLSID_StdURLProtocol: IID;
pub extern const CLSID_TBAuthProtocol: IID;
pub extern const CLSID_UrlMkBindCtx: IID;
pub extern const CLSID_CdlProtocol: IID;
pub extern const CLSID_ClassInstallFilter: IID;
pub extern const IID_IAsyncBindCtx: IID;
pub extern "urlmon" fn CreateURLMoniker(pMkCtx: LPMONIKER, szURL: LPCWSTR, ppmk: [*c]LPMONIKER) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CreateURLMonikerEx(pMkCtx: LPMONIKER, szURL: LPCWSTR, ppmk: [*c]LPMONIKER, dwFlags: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn GetClassURL(szURL: LPCWSTR, pClsID: [*c]CLSID) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CreateAsyncBindCtx(reserved: DWORD, pBSCb: [*c]IBindStatusCallback, pEFetc: [*c]IEnumFORMATETC, ppBC: [*c]([*c]IBindCtx)) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CreateURLMonikerEx2(pMkCtx: LPMONIKER, pUri: [*c]IUri, ppmk: [*c]LPMONIKER, dwFlags: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CreateAsyncBindCtxEx(pbc: [*c]IBindCtx, dwOptions: DWORD, pBSCb: [*c]IBindStatusCallback, pEnum: [*c]IEnumFORMATETC, ppBC: [*c]([*c]IBindCtx), reserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn MkParseDisplayNameEx(pbc: [*c]IBindCtx, szDisplayName: LPCWSTR, pchEaten: [*c]ULONG, ppmk: [*c]LPMONIKER) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn RegisterBindStatusCallback(pBC: LPBC, pBSCb: [*c]IBindStatusCallback, ppBSCBPrev: [*c]([*c]IBindStatusCallback), dwReserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn RevokeBindStatusCallback(pBC: LPBC, pBSCb: [*c]IBindStatusCallback) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn GetClassFileOrMime(pBC: LPBC, szFilename: LPCWSTR, pBuffer: LPVOID, cbSize: DWORD, szMime: LPCWSTR, dwReserved: DWORD, pclsid: [*c]CLSID) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn IsValidURL(pBC: LPBC, szURL: LPCWSTR, dwReserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CoGetClassObjectFromURL(rCLASSID: [*c]const IID, szCODE: LPCWSTR, dwFileVersionMS: DWORD, dwFileVersionLS: DWORD, szTYPE: LPCWSTR, pBindCtx: LPBINDCTX, dwClsContext: DWORD, pvReserved: LPVOID, riid: [*c]const IID, ppv: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn IEInstallScope(pdwScope: LPDWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn FaultInIEFeature(hWnd: HWND, pClassSpec: [*c]uCLSSPEC, pQuery: [*c]QUERYCONTEXT, dwFlags: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn GetComponentIDFromCLSSPEC(pClassspec: [*c]uCLSSPEC, ppszComponentID: [*c]LPSTR) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn IsAsyncMoniker(pmk: [*c]IMoniker) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CreateURLBinding(lpszUrl: LPCWSTR, pbc: [*c]IBindCtx, ppBdg: [*c]([*c]IBinding)) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn RegisterMediaTypes(ctypes: UINT, rgszTypes: [*c]const LPCSTR, rgcfTypes: [*c]CLIPFORMAT) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn FindMediaType(rgszTypes: LPCSTR, rgcfTypes: [*c]CLIPFORMAT) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CreateFormatEnumerator(cfmtetc: UINT, rgfmtetc: [*c]FORMATETC, ppenumfmtetc: [*c]([*c]IEnumFORMATETC)) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn RegisterFormatEnumerator(pBC: LPBC, pEFetc: [*c]IEnumFORMATETC, reserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn RevokeFormatEnumerator(pBC: LPBC, pEFetc: [*c]IEnumFORMATETC) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn RegisterMediaTypeClass(pBC: LPBC, ctypes: UINT, rgszTypes: [*c]const LPCSTR, rgclsID: [*c]CLSID, reserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn FindMediaTypeClass(pBC: LPBC, szType: LPCSTR, pclsID: [*c]CLSID, reserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn UrlMkSetSessionOption(dwOption: DWORD, pBuffer: LPVOID, dwBufferLength: DWORD, dwReserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn UrlMkGetSessionOption(dwOption: DWORD, pBuffer: LPVOID, dwBufferLength: DWORD, pdwBufferLengthOut: [*c]DWORD, dwReserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn FindMimeFromData(pBC: LPBC, pwzUrl: LPCWSTR, pBuffer: LPVOID, cbSize: DWORD, pwzMimeProposed: LPCWSTR, dwMimeFlags: DWORD, ppwzMimeOut: [*c]LPWSTR, dwReserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn ObtainUserAgentString(dwOption: DWORD, pszUAOut: LPSTR, cbSize: [*c]DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CompareSecurityIds(pbSecurityId1: [*c]BYTE, dwLen1: DWORD, pbSecurityId2: [*c]BYTE, dwLen2: DWORD, dwReserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CompatFlagsFromClsid(pclsid: [*c]CLSID, pdwCompatFlags: LPDWORD, pdwMiscStatusFlags: LPDWORD) callconv(.Stdcall) HRESULT;
pub const IE_EPM_OBJECT_EVENT = enum_IEObjectType.IE_EPM_OBJECT_EVENT;
pub const IE_EPM_OBJECT_MUTEX = enum_IEObjectType.IE_EPM_OBJECT_MUTEX;
pub const IE_EPM_OBJECT_SEMAPHORE = enum_IEObjectType.IE_EPM_OBJECT_SEMAPHORE;
pub const IE_EPM_OBJECT_SHARED_MEMORY = enum_IEObjectType.IE_EPM_OBJECT_SHARED_MEMORY;
pub const IE_EPM_OBJECT_WAITABLE_TIMER = enum_IEObjectType.IE_EPM_OBJECT_WAITABLE_TIMER;
pub const IE_EPM_OBJECT_FILE = enum_IEObjectType.IE_EPM_OBJECT_FILE;
pub const IE_EPM_OBJECT_NAMED_PIPE = enum_IEObjectType.IE_EPM_OBJECT_NAMED_PIPE;
pub const IE_EPM_OBJECT_REGISTRY = enum_IEObjectType.IE_EPM_OBJECT_REGISTRY;
pub const enum_IEObjectType = extern enum {
    IE_EPM_OBJECT_EVENT,
    IE_EPM_OBJECT_MUTEX,
    IE_EPM_OBJECT_SEMAPHORE,
    IE_EPM_OBJECT_SHARED_MEMORY,
    IE_EPM_OBJECT_WAITABLE_TIMER,
    IE_EPM_OBJECT_FILE,
    IE_EPM_OBJECT_NAMED_PIPE,
    IE_EPM_OBJECT_REGISTRY,
};
pub const IEObjectType = enum_IEObjectType;
pub extern "urlmon" fn SetAccessForIEAppContainer(hObject: HANDLE, ieObjectType: IEObjectType, dwAccessMask: DWORD) callconv(.Stdcall) HRESULT;
pub extern var __MIDL_itf_urlmon_0000_0000_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0000_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPPERSISTMONIKER = [*c]IPersistMoniker;
pub extern const IID_IPersistMoniker: IID;
pub const IPersistMonikerVtbl = struct_IPersistMonikerVtbl;
pub extern var __MIDL_itf_urlmon_0000_0001_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0001_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPMONIKERPROP = [*c]IMonikerProp;
pub extern const IID_IMonikerProp: IID;
pub const IMonikerPropVtbl = struct_IMonikerPropVtbl;
pub extern var __MIDL_itf_urlmon_0000_0002_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0002_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPBINDPROTOCOL = [*c]IBindProtocol;
pub extern const IID_IBindProtocol: IID;
pub const IBindProtocolVtbl = struct_IBindProtocolVtbl;
pub extern var __MIDL_itf_urlmon_0000_0003_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0003_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPBINDING = [*c]IBinding;
pub extern const IID_IBinding: IID;
pub const IBindingVtbl = struct_IBindingVtbl;
pub extern fn IBinding_RemoteGetBindResult_Proxy(This: [*c]IBinding, pclsidProtocol: [*c]CLSID, pdwResult: [*c]DWORD, pszResult: [*c]LPOLESTR, dwReserved: DWORD) HRESULT;
pub extern fn IBinding_RemoteGetBindResult_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_urlmon_0000_0004_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0004_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPBINDSTATUSCALLBACK = [*c]IBindStatusCallback;
pub const BINDVERB_GET = enum___MIDL_IBindStatusCallback_0001.BINDVERB_GET;
pub const BINDVERB_POST = enum___MIDL_IBindStatusCallback_0001.BINDVERB_POST;
pub const BINDVERB_PUT = enum___MIDL_IBindStatusCallback_0001.BINDVERB_PUT;
pub const BINDVERB_CUSTOM = enum___MIDL_IBindStatusCallback_0001.BINDVERB_CUSTOM;
pub const BINDVERB_RESERVED1 = enum___MIDL_IBindStatusCallback_0001.BINDVERB_RESERVED1;
pub const enum___MIDL_IBindStatusCallback_0001 = extern enum {
    BINDVERB_GET = 0,
    BINDVERB_POST = 1,
    BINDVERB_PUT = 2,
    BINDVERB_CUSTOM = 3,
    BINDVERB_RESERVED1 = 4,
};
pub const BINDVERB = enum___MIDL_IBindStatusCallback_0001;
pub const BINDINFOF_URLENCODESTGMEDDATA = enum___MIDL_IBindStatusCallback_0002.BINDINFOF_URLENCODESTGMEDDATA;
pub const BINDINFOF_URLENCODEDEXTRAINFO = enum___MIDL_IBindStatusCallback_0002.BINDINFOF_URLENCODEDEXTRAINFO;
pub const enum___MIDL_IBindStatusCallback_0002 = extern enum {
    BINDINFOF_URLENCODESTGMEDDATA = 1,
    BINDINFOF_URLENCODEDEXTRAINFO = 2,
};
pub const BINDINFOF = enum___MIDL_IBindStatusCallback_0002;
pub const BINDF_ASYNCHRONOUS = enum___MIDL_IBindStatusCallback_0003.BINDF_ASYNCHRONOUS;
pub const BINDF_ASYNCSTORAGE = enum___MIDL_IBindStatusCallback_0003.BINDF_ASYNCSTORAGE;
pub const BINDF_NOPROGRESSIVERENDERING = enum___MIDL_IBindStatusCallback_0003.BINDF_NOPROGRESSIVERENDERING;
pub const BINDF_OFFLINEOPERATION = enum___MIDL_IBindStatusCallback_0003.BINDF_OFFLINEOPERATION;
pub const BINDF_GETNEWESTVERSION = enum___MIDL_IBindStatusCallback_0003.BINDF_GETNEWESTVERSION;
pub const BINDF_NOWRITECACHE = enum___MIDL_IBindStatusCallback_0003.BINDF_NOWRITECACHE;
pub const BINDF_NEEDFILE = enum___MIDL_IBindStatusCallback_0003.BINDF_NEEDFILE;
pub const BINDF_PULLDATA = enum___MIDL_IBindStatusCallback_0003.BINDF_PULLDATA;
pub const BINDF_IGNORESECURITYPROBLEM = enum___MIDL_IBindStatusCallback_0003.BINDF_IGNORESECURITYPROBLEM;
pub const BINDF_RESYNCHRONIZE = enum___MIDL_IBindStatusCallback_0003.BINDF_RESYNCHRONIZE;
pub const BINDF_HYPERLINK = enum___MIDL_IBindStatusCallback_0003.BINDF_HYPERLINK;
pub const BINDF_NO_UI = enum___MIDL_IBindStatusCallback_0003.BINDF_NO_UI;
pub const BINDF_SILENTOPERATION = enum___MIDL_IBindStatusCallback_0003.BINDF_SILENTOPERATION;
pub const BINDF_PRAGMA_NO_CACHE = enum___MIDL_IBindStatusCallback_0003.BINDF_PRAGMA_NO_CACHE;
pub const BINDF_GETCLASSOBJECT = enum___MIDL_IBindStatusCallback_0003.BINDF_GETCLASSOBJECT;
pub const BINDF_RESERVED_1 = enum___MIDL_IBindStatusCallback_0003.BINDF_RESERVED_1;
pub const BINDF_FREE_THREADED = enum___MIDL_IBindStatusCallback_0003.BINDF_FREE_THREADED;
pub const BINDF_DIRECT_READ = enum___MIDL_IBindStatusCallback_0003.BINDF_DIRECT_READ;
pub const BINDF_FORMS_SUBMIT = enum___MIDL_IBindStatusCallback_0003.BINDF_FORMS_SUBMIT;
pub const BINDF_GETFROMCACHE_IF_NET_FAIL = enum___MIDL_IBindStatusCallback_0003.BINDF_GETFROMCACHE_IF_NET_FAIL;
pub const BINDF_FROMURLMON = enum___MIDL_IBindStatusCallback_0003.BINDF_FROMURLMON;
pub const BINDF_FWD_BACK = enum___MIDL_IBindStatusCallback_0003.BINDF_FWD_BACK;
pub const BINDF_PREFERDEFAULTHANDLER = enum___MIDL_IBindStatusCallback_0003.BINDF_PREFERDEFAULTHANDLER;
pub const BINDF_ENFORCERESTRICTED = enum___MIDL_IBindStatusCallback_0003.BINDF_ENFORCERESTRICTED;
pub const BINDF_RESERVED_2 = enum___MIDL_IBindStatusCallback_0003.BINDF_RESERVED_2;
pub const BINDF_RESERVED_3 = enum___MIDL_IBindStatusCallback_0003.BINDF_RESERVED_3;
pub const BINDF_RESERVED_4 = enum___MIDL_IBindStatusCallback_0003.BINDF_RESERVED_4;
pub const BINDF_RESERVED_5 = enum___MIDL_IBindStatusCallback_0003.BINDF_RESERVED_5;
pub const BINDF_RESERVED_6 = enum___MIDL_IBindStatusCallback_0003.BINDF_RESERVED_6;
pub const BINDF_RESERVED_7 = enum___MIDL_IBindStatusCallback_0003.BINDF_RESERVED_7;
pub const BINDF_RESERVED_8 = enum___MIDL_IBindStatusCallback_0003.BINDF_RESERVED_8;
pub const enum___MIDL_IBindStatusCallback_0003 = extern enum {
    BINDF_ASYNCHRONOUS = 1,
    BINDF_ASYNCSTORAGE = 2,
    BINDF_NOPROGRESSIVERENDERING = 4,
    BINDF_OFFLINEOPERATION = 8,
    BINDF_GETNEWESTVERSION = 16,
    BINDF_NOWRITECACHE = 32,
    BINDF_NEEDFILE = 64,
    BINDF_PULLDATA = 128,
    BINDF_IGNORESECURITYPROBLEM = 256,
    BINDF_RESYNCHRONIZE = 512,
    BINDF_HYPERLINK = 1024,
    BINDF_NO_UI = 2048,
    BINDF_SILENTOPERATION = 4096,
    BINDF_PRAGMA_NO_CACHE = 8192,
    BINDF_GETCLASSOBJECT = 16384,
    BINDF_RESERVED_1 = 32768,
    BINDF_FREE_THREADED = 65536,
    BINDF_DIRECT_READ = 131072,
    BINDF_FORMS_SUBMIT = 262144,
    BINDF_GETFROMCACHE_IF_NET_FAIL = 524288,
    BINDF_FROMURLMON = 1048576,
    BINDF_FWD_BACK = 2097152,
    BINDF_PREFERDEFAULTHANDLER = 4194304,
    BINDF_ENFORCERESTRICTED = 8388608,
    BINDF_RESERVED_2 = -2147483648,
    BINDF_RESERVED_3 = 16777216,
    BINDF_RESERVED_4 = 33554432,
    BINDF_RESERVED_5 = 67108864,
    BINDF_RESERVED_6 = 134217728,
    BINDF_RESERVED_7 = 1073741824,
    BINDF_RESERVED_8 = 536870912,
};
pub const BINDF = enum___MIDL_IBindStatusCallback_0003;
pub const URL_ENCODING_NONE = enum___MIDL_IBindStatusCallback_0004.URL_ENCODING_NONE;
pub const URL_ENCODING_ENABLE_UTF8 = enum___MIDL_IBindStatusCallback_0004.URL_ENCODING_ENABLE_UTF8;
pub const URL_ENCODING_DISABLE_UTF8 = enum___MIDL_IBindStatusCallback_0004.URL_ENCODING_DISABLE_UTF8;
pub const enum___MIDL_IBindStatusCallback_0004 = extern enum {
    URL_ENCODING_NONE = 0,
    URL_ENCODING_ENABLE_UTF8 = 268435456,
    URL_ENCODING_DISABLE_UTF8 = 536870912,
};
pub const URL_ENCODING = enum___MIDL_IBindStatusCallback_0004;
pub const struct__REMSECURITY_ATTRIBUTES = extern struct {
    nLength: DWORD,
    lpSecurityDescriptor: DWORD,
    bInheritHandle: BOOL,
};
pub const REMSECURITY_ATTRIBUTES = struct__REMSECURITY_ATTRIBUTES;
pub const PREMSECURITY_ATTRIBUTES = [*c]struct__REMSECURITY_ATTRIBUTES;
pub const LPREMSECURITY_ATTRIBUTES = [*c]struct__REMSECURITY_ATTRIBUTES;
pub const struct__tagRemBINDINFO = extern struct {
    cbSize: ULONG,
    szExtraInfo: LPWSTR,
    grfBindInfoF: DWORD,
    dwBindVerb: DWORD,
    szCustomVerb: LPWSTR,
    cbstgmedData: DWORD,
    dwOptions: DWORD,
    dwOptionsFlags: DWORD,
    dwCodePage: DWORD,
    securityAttributes: REMSECURITY_ATTRIBUTES,
    iid: IID,
    pUnk: [*c]IUnknown,
    dwReserved: DWORD,
};
pub const RemBINDINFO = struct__tagRemBINDINFO;
pub const struct_tagRemFORMATETC = extern struct {
    cfFormat: DWORD,
    ptd: DWORD,
    dwAspect: DWORD,
    lindex: LONG,
    tymed: DWORD,
};
pub const RemFORMATETC = struct_tagRemFORMATETC;
pub const LPREMFORMATETC = [*c]struct_tagRemFORMATETC;
pub const BINDINFO_OPTIONS_WININETFLAG = enum___MIDL_IBindStatusCallback_0005.BINDINFO_OPTIONS_WININETFLAG;
pub const BINDINFO_OPTIONS_ENABLE_UTF8 = enum___MIDL_IBindStatusCallback_0005.BINDINFO_OPTIONS_ENABLE_UTF8;
pub const BINDINFO_OPTIONS_DISABLE_UTF8 = enum___MIDL_IBindStatusCallback_0005.BINDINFO_OPTIONS_DISABLE_UTF8;
pub const BINDINFO_OPTIONS_USE_IE_ENCODING = enum___MIDL_IBindStatusCallback_0005.BINDINFO_OPTIONS_USE_IE_ENCODING;
pub const BINDINFO_OPTIONS_BINDTOOBJECT = enum___MIDL_IBindStatusCallback_0005.BINDINFO_OPTIONS_BINDTOOBJECT;
pub const BINDINFO_OPTIONS_SECURITYOPTOUT = enum___MIDL_IBindStatusCallback_0005.BINDINFO_OPTIONS_SECURITYOPTOUT;
pub const BINDINFO_OPTIONS_IGNOREMIMETEXTPLAIN = enum___MIDL_IBindStatusCallback_0005.BINDINFO_OPTIONS_IGNOREMIMETEXTPLAIN;
pub const BINDINFO_OPTIONS_USEBINDSTRINGCREDS = enum___MIDL_IBindStatusCallback_0005.BINDINFO_OPTIONS_USEBINDSTRINGCREDS;
pub const BINDINFO_OPTIONS_IGNOREHTTPHTTPSREDIRECTS = enum___MIDL_IBindStatusCallback_0005.BINDINFO_OPTIONS_IGNOREHTTPHTTPSREDIRECTS;
pub const BINDINFO_OPTIONS_IGNORE_SSLERRORS_ONCE = enum___MIDL_IBindStatusCallback_0005.BINDINFO_OPTIONS_IGNORE_SSLERRORS_ONCE;
pub const BINDINFO_WPC_DOWNLOADBLOCKED = enum___MIDL_IBindStatusCallback_0005.BINDINFO_WPC_DOWNLOADBLOCKED;
pub const BINDINFO_WPC_LOGGING_ENABLED = enum___MIDL_IBindStatusCallback_0005.BINDINFO_WPC_LOGGING_ENABLED;
pub const BINDINFO_OPTIONS_ALLOWCONNECTDATA = enum___MIDL_IBindStatusCallback_0005.BINDINFO_OPTIONS_ALLOWCONNECTDATA;
pub const BINDINFO_OPTIONS_DISABLEAUTOREDIRECTS = enum___MIDL_IBindStatusCallback_0005.BINDINFO_OPTIONS_DISABLEAUTOREDIRECTS;
pub const BINDINFO_OPTIONS_SHDOCVW_NAVIGATE = enum___MIDL_IBindStatusCallback_0005.BINDINFO_OPTIONS_SHDOCVW_NAVIGATE;
pub const enum___MIDL_IBindStatusCallback_0005 = extern enum {
    BINDINFO_OPTIONS_WININETFLAG = 65536,
    BINDINFO_OPTIONS_ENABLE_UTF8 = 131072,
    BINDINFO_OPTIONS_DISABLE_UTF8 = 262144,
    BINDINFO_OPTIONS_USE_IE_ENCODING = 524288,
    BINDINFO_OPTIONS_BINDTOOBJECT = 1048576,
    BINDINFO_OPTIONS_SECURITYOPTOUT = 2097152,
    BINDINFO_OPTIONS_IGNOREMIMETEXTPLAIN = 4194304,
    BINDINFO_OPTIONS_USEBINDSTRINGCREDS = 8388608,
    BINDINFO_OPTIONS_IGNOREHTTPHTTPSREDIRECTS = 16777216,
    BINDINFO_OPTIONS_IGNORE_SSLERRORS_ONCE = 33554432,
    BINDINFO_WPC_DOWNLOADBLOCKED = 134217728,
    BINDINFO_WPC_LOGGING_ENABLED = 268435456,
    BINDINFO_OPTIONS_ALLOWCONNECTDATA = 536870912,
    BINDINFO_OPTIONS_DISABLEAUTOREDIRECTS = 1073741824,
    BINDINFO_OPTIONS_SHDOCVW_NAVIGATE = -2147483648,
};
pub const BINDINFO_OPTIONS = enum___MIDL_IBindStatusCallback_0005;
pub const BSCF_FIRSTDATANOTIFICATION = enum___MIDL_IBindStatusCallback_0006.BSCF_FIRSTDATANOTIFICATION;
pub const BSCF_INTERMEDIATEDATANOTIFICATION = enum___MIDL_IBindStatusCallback_0006.BSCF_INTERMEDIATEDATANOTIFICATION;
pub const BSCF_LASTDATANOTIFICATION = enum___MIDL_IBindStatusCallback_0006.BSCF_LASTDATANOTIFICATION;
pub const BSCF_DATAFULLYAVAILABLE = enum___MIDL_IBindStatusCallback_0006.BSCF_DATAFULLYAVAILABLE;
pub const BSCF_AVAILABLEDATASIZEUNKNOWN = enum___MIDL_IBindStatusCallback_0006.BSCF_AVAILABLEDATASIZEUNKNOWN;
pub const BSCF_SKIPDRAINDATAFORFILEURLS = enum___MIDL_IBindStatusCallback_0006.BSCF_SKIPDRAINDATAFORFILEURLS;
pub const BSCF_64BITLENGTHDOWNLOAD = enum___MIDL_IBindStatusCallback_0006.BSCF_64BITLENGTHDOWNLOAD;
pub const enum___MIDL_IBindStatusCallback_0006 = extern enum {
    BSCF_FIRSTDATANOTIFICATION = 1,
    BSCF_INTERMEDIATEDATANOTIFICATION = 2,
    BSCF_LASTDATANOTIFICATION = 4,
    BSCF_DATAFULLYAVAILABLE = 8,
    BSCF_AVAILABLEDATASIZEUNKNOWN = 16,
    BSCF_SKIPDRAINDATAFORFILEURLS = 32,
    BSCF_64BITLENGTHDOWNLOAD = 64,
};
pub const BSCF = enum___MIDL_IBindStatusCallback_0006;
pub const BINDSTATUS_FINDINGRESOURCE = enum_tagBINDSTATUS.BINDSTATUS_FINDINGRESOURCE;
pub const BINDSTATUS_CONNECTING = enum_tagBINDSTATUS.BINDSTATUS_CONNECTING;
pub const BINDSTATUS_REDIRECTING = enum_tagBINDSTATUS.BINDSTATUS_REDIRECTING;
pub const BINDSTATUS_BEGINDOWNLOADDATA = enum_tagBINDSTATUS.BINDSTATUS_BEGINDOWNLOADDATA;
pub const BINDSTATUS_DOWNLOADINGDATA = enum_tagBINDSTATUS.BINDSTATUS_DOWNLOADINGDATA;
pub const BINDSTATUS_ENDDOWNLOADDATA = enum_tagBINDSTATUS.BINDSTATUS_ENDDOWNLOADDATA;
pub const BINDSTATUS_BEGINDOWNLOADCOMPONENTS = enum_tagBINDSTATUS.BINDSTATUS_BEGINDOWNLOADCOMPONENTS;
pub const BINDSTATUS_INSTALLINGCOMPONENTS = enum_tagBINDSTATUS.BINDSTATUS_INSTALLINGCOMPONENTS;
pub const BINDSTATUS_ENDDOWNLOADCOMPONENTS = enum_tagBINDSTATUS.BINDSTATUS_ENDDOWNLOADCOMPONENTS;
pub const BINDSTATUS_USINGCACHEDCOPY = enum_tagBINDSTATUS.BINDSTATUS_USINGCACHEDCOPY;
pub const BINDSTATUS_SENDINGREQUEST = enum_tagBINDSTATUS.BINDSTATUS_SENDINGREQUEST;
pub const BINDSTATUS_CLASSIDAVAILABLE = enum_tagBINDSTATUS.BINDSTATUS_CLASSIDAVAILABLE;
pub const BINDSTATUS_MIMETYPEAVAILABLE = enum_tagBINDSTATUS.BINDSTATUS_MIMETYPEAVAILABLE;
pub const BINDSTATUS_CACHEFILENAMEAVAILABLE = enum_tagBINDSTATUS.BINDSTATUS_CACHEFILENAMEAVAILABLE;
pub const BINDSTATUS_BEGINSYNCOPERATION = enum_tagBINDSTATUS.BINDSTATUS_BEGINSYNCOPERATION;
pub const BINDSTATUS_ENDSYNCOPERATION = enum_tagBINDSTATUS.BINDSTATUS_ENDSYNCOPERATION;
pub const BINDSTATUS_BEGINUPLOADDATA = enum_tagBINDSTATUS.BINDSTATUS_BEGINUPLOADDATA;
pub const BINDSTATUS_UPLOADINGDATA = enum_tagBINDSTATUS.BINDSTATUS_UPLOADINGDATA;
pub const BINDSTATUS_ENDUPLOADDATA = enum_tagBINDSTATUS.BINDSTATUS_ENDUPLOADDATA;
pub const BINDSTATUS_PROTOCOLCLASSID = enum_tagBINDSTATUS.BINDSTATUS_PROTOCOLCLASSID;
pub const BINDSTATUS_ENCODING = enum_tagBINDSTATUS.BINDSTATUS_ENCODING;
pub const BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE = enum_tagBINDSTATUS.BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE;
pub const BINDSTATUS_CLASSINSTALLLOCATION = enum_tagBINDSTATUS.BINDSTATUS_CLASSINSTALLLOCATION;
pub const BINDSTATUS_DECODING = enum_tagBINDSTATUS.BINDSTATUS_DECODING;
pub const BINDSTATUS_LOADINGMIMEHANDLER = enum_tagBINDSTATUS.BINDSTATUS_LOADINGMIMEHANDLER;
pub const BINDSTATUS_CONTENTDISPOSITIONATTACH = enum_tagBINDSTATUS.BINDSTATUS_CONTENTDISPOSITIONATTACH;
pub const BINDSTATUS_FILTERREPORTMIMETYPE = enum_tagBINDSTATUS.BINDSTATUS_FILTERREPORTMIMETYPE;
pub const BINDSTATUS_CLSIDCANINSTANTIATE = enum_tagBINDSTATUS.BINDSTATUS_CLSIDCANINSTANTIATE;
pub const BINDSTATUS_IUNKNOWNAVAILABLE = enum_tagBINDSTATUS.BINDSTATUS_IUNKNOWNAVAILABLE;
pub const BINDSTATUS_DIRECTBIND = enum_tagBINDSTATUS.BINDSTATUS_DIRECTBIND;
pub const BINDSTATUS_RAWMIMETYPE = enum_tagBINDSTATUS.BINDSTATUS_RAWMIMETYPE;
pub const BINDSTATUS_PROXYDETECTING = enum_tagBINDSTATUS.BINDSTATUS_PROXYDETECTING;
pub const BINDSTATUS_ACCEPTRANGES = enum_tagBINDSTATUS.BINDSTATUS_ACCEPTRANGES;
pub const BINDSTATUS_COOKIE_SENT = enum_tagBINDSTATUS.BINDSTATUS_COOKIE_SENT;
pub const BINDSTATUS_COMPACT_POLICY_RECEIVED = enum_tagBINDSTATUS.BINDSTATUS_COMPACT_POLICY_RECEIVED;
pub const BINDSTATUS_COOKIE_SUPPRESSED = enum_tagBINDSTATUS.BINDSTATUS_COOKIE_SUPPRESSED;
pub const BINDSTATUS_COOKIE_STATE_UNKNOWN = enum_tagBINDSTATUS.BINDSTATUS_COOKIE_STATE_UNKNOWN;
pub const BINDSTATUS_COOKIE_STATE_ACCEPT = enum_tagBINDSTATUS.BINDSTATUS_COOKIE_STATE_ACCEPT;
pub const BINDSTATUS_COOKIE_STATE_REJECT = enum_tagBINDSTATUS.BINDSTATUS_COOKIE_STATE_REJECT;
pub const BINDSTATUS_COOKIE_STATE_PROMPT = enum_tagBINDSTATUS.BINDSTATUS_COOKIE_STATE_PROMPT;
pub const BINDSTATUS_COOKIE_STATE_LEASH = enum_tagBINDSTATUS.BINDSTATUS_COOKIE_STATE_LEASH;
pub const BINDSTATUS_COOKIE_STATE_DOWNGRADE = enum_tagBINDSTATUS.BINDSTATUS_COOKIE_STATE_DOWNGRADE;
pub const BINDSTATUS_POLICY_HREF = enum_tagBINDSTATUS.BINDSTATUS_POLICY_HREF;
pub const BINDSTATUS_P3P_HEADER = enum_tagBINDSTATUS.BINDSTATUS_P3P_HEADER;
pub const BINDSTATUS_SESSION_COOKIE_RECEIVED = enum_tagBINDSTATUS.BINDSTATUS_SESSION_COOKIE_RECEIVED;
pub const BINDSTATUS_PERSISTENT_COOKIE_RECEIVED = enum_tagBINDSTATUS.BINDSTATUS_PERSISTENT_COOKIE_RECEIVED;
pub const BINDSTATUS_SESSION_COOKIES_ALLOWED = enum_tagBINDSTATUS.BINDSTATUS_SESSION_COOKIES_ALLOWED;
pub const BINDSTATUS_CACHECONTROL = enum_tagBINDSTATUS.BINDSTATUS_CACHECONTROL;
pub const BINDSTATUS_CONTENTDISPOSITIONFILENAME = enum_tagBINDSTATUS.BINDSTATUS_CONTENTDISPOSITIONFILENAME;
pub const BINDSTATUS_MIMETEXTPLAINMISMATCH = enum_tagBINDSTATUS.BINDSTATUS_MIMETEXTPLAINMISMATCH;
pub const BINDSTATUS_PUBLISHERAVAILABLE = enum_tagBINDSTATUS.BINDSTATUS_PUBLISHERAVAILABLE;
pub const BINDSTATUS_DISPLAYNAMEAVAILABLE = enum_tagBINDSTATUS.BINDSTATUS_DISPLAYNAMEAVAILABLE;
pub const BINDSTATUS_SSLUX_NAVBLOCKED = enum_tagBINDSTATUS.BINDSTATUS_SSLUX_NAVBLOCKED;
pub const BINDSTATUS_SERVER_MIMETYPEAVAILABLE = enum_tagBINDSTATUS.BINDSTATUS_SERVER_MIMETYPEAVAILABLE;
pub const BINDSTATUS_SNIFFED_CLASSIDAVAILABLE = enum_tagBINDSTATUS.BINDSTATUS_SNIFFED_CLASSIDAVAILABLE;
pub const BINDSTATUS_64BIT_PROGRESS = enum_tagBINDSTATUS.BINDSTATUS_64BIT_PROGRESS;
pub const BINDSTATUS_LAST = enum_tagBINDSTATUS.BINDSTATUS_LAST;
pub const BINDSTATUS_RESERVED_0 = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_0;
pub const BINDSTATUS_RESERVED_1 = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_1;
pub const BINDSTATUS_RESERVED_2 = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_2;
pub const BINDSTATUS_RESERVED_3 = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_3;
pub const BINDSTATUS_RESERVED_4 = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_4;
pub const BINDSTATUS_RESERVED_5 = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_5;
pub const BINDSTATUS_RESERVED_6 = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_6;
pub const BINDSTATUS_RESERVED_7 = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_7;
pub const BINDSTATUS_RESERVED_8 = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_8;
pub const BINDSTATUS_RESERVED_9 = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_9;
pub const BINDSTATUS_RESERVED_A = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_A;
pub const BINDSTATUS_RESERVED_B = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_B;
pub const BINDSTATUS_RESERVED_C = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_C;
pub const BINDSTATUS_RESERVED_D = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_D;
pub const BINDSTATUS_RESERVED_E = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_E;
pub const BINDSTATUS_RESERVED_F = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_F;
pub const BINDSTATUS_RESERVED_10 = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_10;
pub const BINDSTATUS_RESERVED_11 = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_11;
pub const BINDSTATUS_RESERVED_12 = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_12;
pub const BINDSTATUS_RESERVED_13 = enum_tagBINDSTATUS.BINDSTATUS_RESERVED_13;
pub const BINDSTATUS_LAST_PRIVATE = enum_tagBINDSTATUS.BINDSTATUS_LAST_PRIVATE;
pub const enum_tagBINDSTATUS = extern enum {
    BINDSTATUS_FINDINGRESOURCE = 1,
    BINDSTATUS_CONNECTING = 2,
    BINDSTATUS_REDIRECTING = 3,
    BINDSTATUS_BEGINDOWNLOADDATA = 4,
    BINDSTATUS_DOWNLOADINGDATA = 5,
    BINDSTATUS_ENDDOWNLOADDATA = 6,
    BINDSTATUS_BEGINDOWNLOADCOMPONENTS = 7,
    BINDSTATUS_INSTALLINGCOMPONENTS = 8,
    BINDSTATUS_ENDDOWNLOADCOMPONENTS = 9,
    BINDSTATUS_USINGCACHEDCOPY = 10,
    BINDSTATUS_SENDINGREQUEST = 11,
    BINDSTATUS_CLASSIDAVAILABLE = 12,
    BINDSTATUS_MIMETYPEAVAILABLE = 13,
    BINDSTATUS_CACHEFILENAMEAVAILABLE = 14,
    BINDSTATUS_BEGINSYNCOPERATION = 15,
    BINDSTATUS_ENDSYNCOPERATION = 16,
    BINDSTATUS_BEGINUPLOADDATA = 17,
    BINDSTATUS_UPLOADINGDATA = 18,
    BINDSTATUS_ENDUPLOADDATA = 19,
    BINDSTATUS_PROTOCOLCLASSID = 20,
    BINDSTATUS_ENCODING = 21,
    BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE = 22,
    BINDSTATUS_CLASSINSTALLLOCATION = 23,
    BINDSTATUS_DECODING = 24,
    BINDSTATUS_LOADINGMIMEHANDLER = 25,
    BINDSTATUS_CONTENTDISPOSITIONATTACH = 26,
    BINDSTATUS_FILTERREPORTMIMETYPE = 27,
    BINDSTATUS_CLSIDCANINSTANTIATE = 28,
    BINDSTATUS_IUNKNOWNAVAILABLE = 29,
    BINDSTATUS_DIRECTBIND = 30,
    BINDSTATUS_RAWMIMETYPE = 31,
    BINDSTATUS_PROXYDETECTING = 32,
    BINDSTATUS_ACCEPTRANGES = 33,
    BINDSTATUS_COOKIE_SENT = 34,
    BINDSTATUS_COMPACT_POLICY_RECEIVED = 35,
    BINDSTATUS_COOKIE_SUPPRESSED = 36,
    BINDSTATUS_COOKIE_STATE_UNKNOWN = 37,
    BINDSTATUS_COOKIE_STATE_ACCEPT = 38,
    BINDSTATUS_COOKIE_STATE_REJECT = 39,
    BINDSTATUS_COOKIE_STATE_PROMPT = 40,
    BINDSTATUS_COOKIE_STATE_LEASH = 41,
    BINDSTATUS_COOKIE_STATE_DOWNGRADE = 42,
    BINDSTATUS_POLICY_HREF = 43,
    BINDSTATUS_P3P_HEADER = 44,
    BINDSTATUS_SESSION_COOKIE_RECEIVED = 45,
    BINDSTATUS_PERSISTENT_COOKIE_RECEIVED = 46,
    BINDSTATUS_SESSION_COOKIES_ALLOWED = 47,
    BINDSTATUS_CACHECONTROL = 48,
    BINDSTATUS_CONTENTDISPOSITIONFILENAME = 49,
    BINDSTATUS_MIMETEXTPLAINMISMATCH = 50,
    BINDSTATUS_PUBLISHERAVAILABLE = 51,
    BINDSTATUS_DISPLAYNAMEAVAILABLE = 52,
    BINDSTATUS_SSLUX_NAVBLOCKED = 53,
    BINDSTATUS_SERVER_MIMETYPEAVAILABLE = 54,
    BINDSTATUS_SNIFFED_CLASSIDAVAILABLE = 55,
    BINDSTATUS_64BIT_PROGRESS = 56,
    BINDSTATUS_LAST = 56,
    BINDSTATUS_RESERVED_0 = 57,
    BINDSTATUS_RESERVED_1 = 58,
    BINDSTATUS_RESERVED_2 = 59,
    BINDSTATUS_RESERVED_3 = 60,
    BINDSTATUS_RESERVED_4 = 61,
    BINDSTATUS_RESERVED_5 = 62,
    BINDSTATUS_RESERVED_6 = 63,
    BINDSTATUS_RESERVED_7 = 64,
    BINDSTATUS_RESERVED_8 = 65,
    BINDSTATUS_RESERVED_9 = 66,
    BINDSTATUS_RESERVED_A = 67,
    BINDSTATUS_RESERVED_B = 68,
    BINDSTATUS_RESERVED_C = 69,
    BINDSTATUS_RESERVED_D = 70,
    BINDSTATUS_RESERVED_E = 71,
    BINDSTATUS_RESERVED_F = 72,
    BINDSTATUS_RESERVED_10 = 73,
    BINDSTATUS_RESERVED_11 = 74,
    BINDSTATUS_RESERVED_12 = 75,
    BINDSTATUS_RESERVED_13 = 76,
    BINDSTATUS_LAST_PRIVATE = 76,
};
pub const BINDSTATUS = enum_tagBINDSTATUS;
pub extern const IID_IBindStatusCallback: IID;
pub const IBindStatusCallbackVtbl = struct_IBindStatusCallbackVtbl;
pub extern fn IBindStatusCallback_RemoteGetBindInfo_Proxy(This: [*c]IBindStatusCallback, grfBINDF: [*c]DWORD, pbindinfo: [*c]RemBINDINFO, pstgmed: [*c]RemSTGMEDIUM) HRESULT;
pub extern fn IBindStatusCallback_RemoteGetBindInfo_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IBindStatusCallback_RemoteOnDataAvailable_Proxy(This: [*c]IBindStatusCallback, grfBSCF: DWORD, dwSize: DWORD, pformatetc: [*c]RemFORMATETC, pstgmed: [*c]RemSTGMEDIUM) HRESULT;
pub extern fn IBindStatusCallback_RemoteOnDataAvailable_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_urlmon_0000_0005_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0005_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPBINDSTATUSCALLBACKEX = [*c]IBindStatusCallbackEx;
pub const BINDF2_DISABLEBASICOVERHTTP = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_DISABLEBASICOVERHTTP;
pub const BINDF2_DISABLEAUTOCOOKIEHANDLING = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_DISABLEAUTOCOOKIEHANDLING;
pub const BINDF2_READ_DATA_GREATER_THAN_4GB = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_READ_DATA_GREATER_THAN_4GB;
pub const BINDF2_DISABLE_HTTP_REDIRECT_XSECURITYID = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_DISABLE_HTTP_REDIRECT_XSECURITYID;
pub const BINDF2_SETDOWNLOADMODE = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_SETDOWNLOADMODE;
pub const BINDF2_DISABLE_HTTP_REDIRECT_CACHING = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_DISABLE_HTTP_REDIRECT_CACHING;
pub const BINDF2_KEEP_CALLBACK_MODULE_LOADED = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_KEEP_CALLBACK_MODULE_LOADED;
pub const BINDF2_ALLOW_PROXY_CRED_PROMPT = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_ALLOW_PROXY_CRED_PROMPT;
pub const BINDF2_RESERVED_17 = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_17;
pub const BINDF2_RESERVED_16 = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_16;
pub const BINDF2_RESERVED_15 = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_15;
pub const BINDF2_RESERVED_14 = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_14;
pub const BINDF2_RESERVED_13 = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_13;
pub const BINDF2_RESERVED_12 = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_12;
pub const BINDF2_RESERVED_11 = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_11;
pub const BINDF2_RESERVED_10 = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_10;
pub const BINDF2_RESERVED_F = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_F;
pub const BINDF2_RESERVED_E = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_E;
pub const BINDF2_RESERVED_D = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_D;
pub const BINDF2_RESERVED_C = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_C;
pub const BINDF2_RESERVED_B = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_B;
pub const BINDF2_RESERVED_A = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_A;
pub const BINDF2_RESERVED_9 = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_9;
pub const BINDF2_RESERVED_8 = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_8;
pub const BINDF2_RESERVED_7 = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_7;
pub const BINDF2_RESERVED_6 = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_6;
pub const BINDF2_RESERVED_5 = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_5;
pub const BINDF2_RESERVED_4 = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_4;
pub const BINDF2_RESERVED_3 = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_3;
pub const BINDF2_RESERVED_2 = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_2;
pub const BINDF2_RESERVED_1 = enum___MIDL_IBindStatusCallbackEx_0001.BINDF2_RESERVED_1;
pub const enum___MIDL_IBindStatusCallbackEx_0001 = extern enum {
    BINDF2_DISABLEBASICOVERHTTP = 1,
    BINDF2_DISABLEAUTOCOOKIEHANDLING = 2,
    BINDF2_READ_DATA_GREATER_THAN_4GB = 4,
    BINDF2_DISABLE_HTTP_REDIRECT_XSECURITYID = 8,
    BINDF2_SETDOWNLOADMODE = 32,
    BINDF2_DISABLE_HTTP_REDIRECT_CACHING = 64,
    BINDF2_KEEP_CALLBACK_MODULE_LOADED = 128,
    BINDF2_ALLOW_PROXY_CRED_PROMPT = 256,
    BINDF2_RESERVED_17 = 512,
    BINDF2_RESERVED_16 = 1024,
    BINDF2_RESERVED_15 = 2048,
    BINDF2_RESERVED_14 = 4096,
    BINDF2_RESERVED_13 = 8192,
    BINDF2_RESERVED_12 = 16384,
    BINDF2_RESERVED_11 = 32768,
    BINDF2_RESERVED_10 = 65536,
    BINDF2_RESERVED_F = 131072,
    BINDF2_RESERVED_E = 262144,
    BINDF2_RESERVED_D = 524288,
    BINDF2_RESERVED_C = 1048576,
    BINDF2_RESERVED_B = 2097152,
    BINDF2_RESERVED_A = 4194304,
    BINDF2_RESERVED_9 = 8388608,
    BINDF2_RESERVED_8 = 16777216,
    BINDF2_RESERVED_7 = 33554432,
    BINDF2_RESERVED_6 = 67108864,
    BINDF2_RESERVED_5 = 134217728,
    BINDF2_RESERVED_4 = 268435456,
    BINDF2_RESERVED_3 = 536870912,
    BINDF2_RESERVED_2 = 1073741824,
    BINDF2_RESERVED_1 = -2147483648,
};
pub const BINDF2 = enum___MIDL_IBindStatusCallbackEx_0001;
pub extern const IID_IBindStatusCallbackEx: IID;
pub const IBindStatusCallbackExVtbl = struct_IBindStatusCallbackExVtbl;
pub extern fn IBindStatusCallbackEx_RemoteGetBindInfoEx_Proxy(This: [*c]IBindStatusCallbackEx, grfBINDF: [*c]DWORD, pbindinfo: [*c]RemBINDINFO, pstgmed: [*c]RemSTGMEDIUM, grfBINDF2: [*c]DWORD, pdwReserved: [*c]DWORD) HRESULT;
pub extern fn IBindStatusCallbackEx_RemoteGetBindInfoEx_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_urlmon_0000_0006_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0006_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPAUTHENTICATION = [*c]IAuthenticate;
pub extern const IID_IAuthenticate: IID;
pub const IAuthenticateVtbl = struct_IAuthenticateVtbl;
pub extern var __MIDL_itf_urlmon_0000_0007_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0007_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPAUTHENTICATIONEX = [*c]IAuthenticateEx;
pub const AUTHENTICATEF_PROXY = enum___MIDL_IAuthenticateEx_0001.AUTHENTICATEF_PROXY;
pub const AUTHENTICATEF_BASIC = enum___MIDL_IAuthenticateEx_0001.AUTHENTICATEF_BASIC;
pub const AUTHENTICATEF_HTTP = enum___MIDL_IAuthenticateEx_0001.AUTHENTICATEF_HTTP;
pub const enum___MIDL_IAuthenticateEx_0001 = extern enum {
    AUTHENTICATEF_PROXY = 1,
    AUTHENTICATEF_BASIC = 2,
    AUTHENTICATEF_HTTP = 4,
};
pub const AUTHENTICATEF = enum___MIDL_IAuthenticateEx_0001;
pub extern const IID_IAuthenticateEx: IID;
pub const IAuthenticateExVtbl = struct_IAuthenticateExVtbl;
pub extern var __MIDL_itf_urlmon_0000_0008_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0008_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPHTTPNEGOTIATE = [*c]IHttpNegotiate;
pub extern const IID_IHttpNegotiate: IID;
pub const IHttpNegotiateVtbl = struct_IHttpNegotiateVtbl;
pub extern var __MIDL_itf_urlmon_0000_0009_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0009_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPHTTPNEGOTIATE2 = [*c]IHttpNegotiate2;
pub extern const IID_IHttpNegotiate2: IID;
pub const IHttpNegotiate2Vtbl = struct_IHttpNegotiate2Vtbl;
pub extern var __MIDL_itf_urlmon_0000_0010_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0010_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPHTTPNEGOTIATE3 = [*c]IHttpNegotiate3;
pub extern const IID_IHttpNegotiate3: IID;
pub const IHttpNegotiate3Vtbl = struct_IHttpNegotiate3Vtbl;
pub extern var __MIDL_itf_urlmon_0000_0011_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0011_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPWININETFILESTREAM = [*c]IWinInetFileStream;
pub extern const IID_IWinInetFileStream: IID;
pub const IWinInetFileStreamVtbl = struct_IWinInetFileStreamVtbl;
pub extern var __MIDL_itf_urlmon_0000_0012_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0012_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPWINDOWFORBINDINGUI = [*c]IWindowForBindingUI;
pub extern const IID_IWindowForBindingUI: IID;
pub const IWindowForBindingUIVtbl = struct_IWindowForBindingUIVtbl;
pub extern var __MIDL_itf_urlmon_0000_0013_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0013_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPCODEINSTALL = [*c]ICodeInstall;
pub const CIP_DISK_FULL = enum___MIDL_ICodeInstall_0001.CIP_DISK_FULL;
pub const CIP_ACCESS_DENIED = enum___MIDL_ICodeInstall_0001.CIP_ACCESS_DENIED;
pub const CIP_NEWER_VERSION_EXISTS = enum___MIDL_ICodeInstall_0001.CIP_NEWER_VERSION_EXISTS;
pub const CIP_OLDER_VERSION_EXISTS = enum___MIDL_ICodeInstall_0001.CIP_OLDER_VERSION_EXISTS;
pub const CIP_NAME_CONFLICT = enum___MIDL_ICodeInstall_0001.CIP_NAME_CONFLICT;
pub const CIP_TRUST_VERIFICATION_COMPONENT_MISSING = enum___MIDL_ICodeInstall_0001.CIP_TRUST_VERIFICATION_COMPONENT_MISSING;
pub const CIP_EXE_SELF_REGISTERATION_TIMEOUT = enum___MIDL_ICodeInstall_0001.CIP_EXE_SELF_REGISTERATION_TIMEOUT;
pub const CIP_UNSAFE_TO_ABORT = enum___MIDL_ICodeInstall_0001.CIP_UNSAFE_TO_ABORT;
pub const CIP_NEED_REBOOT = enum___MIDL_ICodeInstall_0001.CIP_NEED_REBOOT;
pub const CIP_NEED_REBOOT_UI_PERMISSION = enum___MIDL_ICodeInstall_0001.CIP_NEED_REBOOT_UI_PERMISSION;
pub const enum___MIDL_ICodeInstall_0001 = extern enum {
    CIP_DISK_FULL = 0,
    CIP_ACCESS_DENIED = 1,
    CIP_NEWER_VERSION_EXISTS = 2,
    CIP_OLDER_VERSION_EXISTS = 3,
    CIP_NAME_CONFLICT = 4,
    CIP_TRUST_VERIFICATION_COMPONENT_MISSING = 5,
    CIP_EXE_SELF_REGISTERATION_TIMEOUT = 6,
    CIP_UNSAFE_TO_ABORT = 7,
    CIP_NEED_REBOOT = 8,
    CIP_NEED_REBOOT_UI_PERMISSION = 9,
};
pub const CIP_STATUS = enum___MIDL_ICodeInstall_0001;
pub extern const IID_ICodeInstall: IID;
pub const ICodeInstallVtbl = struct_ICodeInstallVtbl;
pub extern var __MIDL_itf_urlmon_0000_0014_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0014_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const Uri_HOST_UNKNOWN = enum___MIDL_IUri_0002.Uri_HOST_UNKNOWN;
pub const Uri_HOST_DNS = enum___MIDL_IUri_0002.Uri_HOST_DNS;
pub const Uri_HOST_IPV4 = enum___MIDL_IUri_0002.Uri_HOST_IPV4;
pub const Uri_HOST_IPV6 = enum___MIDL_IUri_0002.Uri_HOST_IPV6;
pub const Uri_HOST_IDN = enum___MIDL_IUri_0002.Uri_HOST_IDN;
pub const enum___MIDL_IUri_0002 = extern enum {
    Uri_HOST_UNKNOWN = 0,
    Uri_HOST_DNS = 1,
    Uri_HOST_IPV4 = 2,
    Uri_HOST_IPV6 = 3,
    Uri_HOST_IDN = 4,
};
pub const Uri_HOST_TYPE = enum___MIDL_IUri_0002;
pub extern const IID_IUri: IID;
pub const IUriVtbl = struct_IUriVtbl;
pub extern "urlmon" fn CreateUri(pwzURI: LPCWSTR, dwFlags: DWORD, dwReserved: DWORD_PTR, ppURI: [*c]([*c]IUri)) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CreateUriWithFragment(pwzURI: LPCWSTR, pwzFragment: LPCWSTR, dwFlags: DWORD, dwReserved: DWORD_PTR, ppURI: [*c]([*c]IUri)) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CreateUriFromMultiByteString(pszANSIInputUri: LPCSTR, dwEncodingFlags: DWORD, dwCodePage: DWORD, dwCreateFlags: DWORD, dwReserved: DWORD_PTR, ppUri: [*c]([*c]IUri)) callconv(.Stdcall) HRESULT;
pub extern var __MIDL_itf_urlmon_0000_0015_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0015_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IUriContainer: IID;
pub const IUriContainerVtbl = struct_IUriContainerVtbl;
pub extern const IID_IUriBuilder: IID;
pub const IUriBuilderVtbl = struct_IUriBuilderVtbl;
pub extern const IID_IUriBuilderFactory: IID;
pub const IUriBuilderFactoryVtbl = struct_IUriBuilderFactoryVtbl;
pub extern "urlmon" fn CreateIUriBuilder(pIUri: [*c]IUri, dwFlags: DWORD, dwReserved: DWORD_PTR, ppIUriBuilder: [*c]([*c]IUriBuilder)) callconv(.Stdcall) HRESULT;
pub extern var __MIDL_itf_urlmon_0000_0018_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0018_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPWININETINFO = [*c]IWinInetInfo;
pub extern const IID_IWinInetInfo: IID;
pub const IWinInetInfoVtbl = struct_IWinInetInfoVtbl;
pub extern fn IWinInetInfo_RemoteQueryOption_Proxy(This: [*c]IWinInetInfo, dwOption: DWORD, pBuffer: [*c]BYTE, pcbBuf: [*c]DWORD) HRESULT;
pub extern fn IWinInetInfo_RemoteQueryOption_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_urlmon_0000_0019_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0019_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPHTTPSECURITY = [*c]IHttpSecurity;
pub extern const IID_IHttpSecurity: IID;
pub const IHttpSecurityVtbl = struct_IHttpSecurityVtbl;
pub extern var __MIDL_itf_urlmon_0000_0020_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0020_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPWININETHTTPINFO = [*c]IWinInetHttpInfo;
pub extern const IID_IWinInetHttpInfo: IID;
pub const IWinInetHttpInfoVtbl = struct_IWinInetHttpInfoVtbl;
pub extern fn IWinInetHttpInfo_RemoteQueryInfo_Proxy(This: [*c]IWinInetHttpInfo, dwOption: DWORD, pBuffer: [*c]BYTE, pcbBuf: [*c]DWORD, pdwFlags: [*c]DWORD, pdwReserved: [*c]DWORD) HRESULT;
pub extern fn IWinInetHttpInfo_RemoteQueryInfo_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern var __MIDL_itf_urlmon_0000_0021_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0021_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IWinInetHttpTimeouts: IID;
pub const IWinInetHttpTimeoutsVtbl = struct_IWinInetHttpTimeoutsVtbl;
pub extern var __MIDL_itf_urlmon_0000_0022_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0022_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPWININETCACHEHINTS = [*c]IWinInetCacheHints;
pub extern const IID_IWinInetCacheHints: IID;
pub const IWinInetCacheHintsVtbl = struct_IWinInetCacheHintsVtbl;
pub extern var __MIDL_itf_urlmon_0000_0023_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0023_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPWININETCACHEHINTS2 = [*c]IWinInetCacheHints2;
pub extern const IID_IWinInetCacheHints2: IID;
pub const IWinInetCacheHints2Vtbl = struct_IWinInetCacheHints2Vtbl;
pub extern const SID_BindHost: GUID;
pub extern var __MIDL_itf_urlmon_0000_0024_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0024_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPBINDHOST = [*c]IBindHost;
pub extern const IID_IBindHost: IID;
pub const IBindHostVtbl = struct_IBindHostVtbl;
pub extern fn IBindHost_RemoteMonikerBindToStorage_Proxy(This: [*c]IBindHost, pMk: [*c]IMoniker, pBC: [*c]IBindCtx, pBSC: [*c]IBindStatusCallback, riid: [*c]const IID, ppvObj: [*c]([*c]IUnknown)) HRESULT;
pub extern fn IBindHost_RemoteMonikerBindToStorage_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern fn IBindHost_RemoteMonikerBindToObject_Proxy(This: [*c]IBindHost, pMk: [*c]IMoniker, pBC: [*c]IBindCtx, pBSC: [*c]IBindStatusCallback, riid: [*c]const IID, ppvObj: [*c]([*c]IUnknown)) HRESULT;
pub extern fn IBindHost_RemoteMonikerBindToObject_Stub(This: [*c]IRpcStubBuffer, _pRpcChannelBuffer: [*c]IRpcChannelBuffer, _pRpcMessage: PRPC_MESSAGE, _pdwStubPhase: [*c]DWORD) void;
pub extern "urlmon" fn HlinkSimpleNavigateToString(szTarget: LPCWSTR, szLocation: LPCWSTR, szTargetFrameName: LPCWSTR, pUnk: [*c]IUnknown, pbc: [*c]IBindCtx, arg5: [*c]IBindStatusCallback, grfHLNF: DWORD, dwReserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn HlinkSimpleNavigateToMoniker(pmkTarget: [*c]IMoniker, szLocation: LPCWSTR, szTargetFrameName: LPCWSTR, pUnk: [*c]IUnknown, pbc: [*c]IBindCtx, arg5: [*c]IBindStatusCallback, grfHLNF: DWORD, dwReserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn URLOpenStreamA(arg0: LPUNKNOWN, arg1: LPCSTR, arg2: DWORD, arg3: LPBINDSTATUSCALLBACK) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn URLOpenStreamW(arg0: LPUNKNOWN, arg1: LPCWSTR, arg2: DWORD, arg3: LPBINDSTATUSCALLBACK) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn URLOpenPullStreamA(arg0: LPUNKNOWN, arg1: LPCSTR, arg2: DWORD, arg3: LPBINDSTATUSCALLBACK) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn URLOpenPullStreamW(arg0: LPUNKNOWN, arg1: LPCWSTR, arg2: DWORD, arg3: LPBINDSTATUSCALLBACK) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn URLDownloadToFileA(arg0: LPUNKNOWN, arg1: LPCSTR, arg2: LPCSTR, arg3: DWORD, arg4: LPBINDSTATUSCALLBACK) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn URLDownloadToFileW(arg0: LPUNKNOWN, arg1: LPCWSTR, arg2: LPCWSTR, arg3: DWORD, arg4: LPBINDSTATUSCALLBACK) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn URLDownloadToCacheFileA(arg0: LPUNKNOWN, arg1: LPCSTR, arg2: LPSTR, cchFileName: DWORD, arg4: DWORD, arg5: LPBINDSTATUSCALLBACK) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn URLDownloadToCacheFileW(arg0: LPUNKNOWN, arg1: LPCWSTR, arg2: LPWSTR, cchFileName: DWORD, arg4: DWORD, arg5: LPBINDSTATUSCALLBACK) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn URLOpenBlockingStreamA(arg0: LPUNKNOWN, arg1: LPCSTR, arg2: [*c]LPSTREAM, arg3: DWORD, arg4: LPBINDSTATUSCALLBACK) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn URLOpenBlockingStreamW(arg0: LPUNKNOWN, arg1: LPCWSTR, arg2: [*c]LPSTREAM, arg3: DWORD, arg4: LPBINDSTATUSCALLBACK) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn HlinkGoBack(pUnk: [*c]IUnknown) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn HlinkGoForward(pUnk: [*c]IUnknown) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn HlinkNavigateString(pUnk: [*c]IUnknown, szTarget: LPCWSTR) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn HlinkNavigateMoniker(pUnk: [*c]IUnknown, pmkTarget: [*c]IMoniker) callconv(.Stdcall) HRESULT;
pub extern var __MIDL_itf_urlmon_0000_0025_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0025_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPIINTERNET = [*c]IInternet;
pub extern const IID_IInternet: IID;
pub const IInternetVtbl = struct_IInternetVtbl;
pub extern var __MIDL_itf_urlmon_0000_0026_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0026_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPIINTERNETBINDINFO = [*c]IInternetBindInfo;
pub const BINDSTRING_HEADERS = enum_tagBINDSTRING.BINDSTRING_HEADERS;
pub const BINDSTRING_ACCEPT_MIMES = enum_tagBINDSTRING.BINDSTRING_ACCEPT_MIMES;
pub const BINDSTRING_EXTRA_URL = enum_tagBINDSTRING.BINDSTRING_EXTRA_URL;
pub const BINDSTRING_LANGUAGE = enum_tagBINDSTRING.BINDSTRING_LANGUAGE;
pub const BINDSTRING_USERNAME = enum_tagBINDSTRING.BINDSTRING_USERNAME;
pub const BINDSTRING_PASSWORD = enum_tagBINDSTRING.BINDSTRING_PASSWORD;
pub const BINDSTRING_UA_PIXELS = enum_tagBINDSTRING.BINDSTRING_UA_PIXELS;
pub const BINDSTRING_UA_COLOR = enum_tagBINDSTRING.BINDSTRING_UA_COLOR;
pub const BINDSTRING_OS = enum_tagBINDSTRING.BINDSTRING_OS;
pub const BINDSTRING_USER_AGENT = enum_tagBINDSTRING.BINDSTRING_USER_AGENT;
pub const BINDSTRING_ACCEPT_ENCODINGS = enum_tagBINDSTRING.BINDSTRING_ACCEPT_ENCODINGS;
pub const BINDSTRING_POST_COOKIE = enum_tagBINDSTRING.BINDSTRING_POST_COOKIE;
pub const BINDSTRING_POST_DATA_MIME = enum_tagBINDSTRING.BINDSTRING_POST_DATA_MIME;
pub const BINDSTRING_URL = enum_tagBINDSTRING.BINDSTRING_URL;
pub const BINDSTRING_IID = enum_tagBINDSTRING.BINDSTRING_IID;
pub const BINDSTRING_FLAG_BIND_TO_OBJECT = enum_tagBINDSTRING.BINDSTRING_FLAG_BIND_TO_OBJECT;
pub const BINDSTRING_PTR_BIND_CONTEXT = enum_tagBINDSTRING.BINDSTRING_PTR_BIND_CONTEXT;
pub const BINDSTRING_XDR_ORIGIN = enum_tagBINDSTRING.BINDSTRING_XDR_ORIGIN;
pub const BINDSTRING_DOWNLOADPATH = enum_tagBINDSTRING.BINDSTRING_DOWNLOADPATH;
pub const BINDSTRING_ROOTDOC_URL = enum_tagBINDSTRING.BINDSTRING_ROOTDOC_URL;
pub const BINDSTRING_INITIAL_FILENAME = enum_tagBINDSTRING.BINDSTRING_INITIAL_FILENAME;
pub const BINDSTRING_PROXY_USERNAME = enum_tagBINDSTRING.BINDSTRING_PROXY_USERNAME;
pub const BINDSTRING_PROXY_PASSWORD = enum_tagBINDSTRING.BINDSTRING_PROXY_PASSWORD;
pub const BINDSTRING_ENTERPRISE_ID = enum_tagBINDSTRING.BINDSTRING_ENTERPRISE_ID;
pub const BINDSTRING_DOC_URL = enum_tagBINDSTRING.BINDSTRING_DOC_URL;
pub const BINDSTRING_SAMESITE_COOKIE_LEVEL = enum_tagBINDSTRING.BINDSTRING_SAMESITE_COOKIE_LEVEL;
pub const enum_tagBINDSTRING = extern enum {
    BINDSTRING_HEADERS = 1,
    BINDSTRING_ACCEPT_MIMES = 2,
    BINDSTRING_EXTRA_URL = 3,
    BINDSTRING_LANGUAGE = 4,
    BINDSTRING_USERNAME = 5,
    BINDSTRING_PASSWORD = 6,
    BINDSTRING_UA_PIXELS = 7,
    BINDSTRING_UA_COLOR = 8,
    BINDSTRING_OS = 9,
    BINDSTRING_USER_AGENT = 10,
    BINDSTRING_ACCEPT_ENCODINGS = 11,
    BINDSTRING_POST_COOKIE = 12,
    BINDSTRING_POST_DATA_MIME = 13,
    BINDSTRING_URL = 14,
    BINDSTRING_IID = 15,
    BINDSTRING_FLAG_BIND_TO_OBJECT = 16,
    BINDSTRING_PTR_BIND_CONTEXT = 17,
    BINDSTRING_XDR_ORIGIN = 18,
    BINDSTRING_DOWNLOADPATH = 19,
    BINDSTRING_ROOTDOC_URL = 20,
    BINDSTRING_INITIAL_FILENAME = 21,
    BINDSTRING_PROXY_USERNAME = 22,
    BINDSTRING_PROXY_PASSWORD = 23,
    BINDSTRING_ENTERPRISE_ID = 24,
    BINDSTRING_DOC_URL = 25,
    BINDSTRING_SAMESITE_COOKIE_LEVEL = 26,
};
pub const BINDSTRING = enum_tagBINDSTRING;
pub extern const IID_IInternetBindInfo: IID;
pub const IInternetBindInfoVtbl = struct_IInternetBindInfoVtbl;
pub extern var __MIDL_itf_urlmon_0000_0027_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0027_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPIINTERNETBINDINFOEX = [*c]IInternetBindInfoEx;
pub extern const IID_IInternetBindInfoEx: IID;
pub const IInternetBindInfoExVtbl = struct_IInternetBindInfoExVtbl;
pub extern var __MIDL_itf_urlmon_0000_0028_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0028_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPIINTERNETPROTOCOLROOT = [*c]IInternetProtocolRoot;
pub const PI_PARSE_URL = enum__tagPI_FLAGS.PI_PARSE_URL;
pub const PI_FILTER_MODE = enum__tagPI_FLAGS.PI_FILTER_MODE;
pub const PI_FORCE_ASYNC = enum__tagPI_FLAGS.PI_FORCE_ASYNC;
pub const PI_USE_WORKERTHREAD = enum__tagPI_FLAGS.PI_USE_WORKERTHREAD;
pub const PI_MIMEVERIFICATION = enum__tagPI_FLAGS.PI_MIMEVERIFICATION;
pub const PI_CLSIDLOOKUP = enum__tagPI_FLAGS.PI_CLSIDLOOKUP;
pub const PI_DATAPROGRESS = enum__tagPI_FLAGS.PI_DATAPROGRESS;
pub const PI_SYNCHRONOUS = enum__tagPI_FLAGS.PI_SYNCHRONOUS;
pub const PI_APARTMENTTHREADED = enum__tagPI_FLAGS.PI_APARTMENTTHREADED;
pub const PI_CLASSINSTALL = enum__tagPI_FLAGS.PI_CLASSINSTALL;
pub const PI_PASSONBINDCTX = enum__tagPI_FLAGS.PI_PASSONBINDCTX;
pub const PI_NOMIMEHANDLER = enum__tagPI_FLAGS.PI_NOMIMEHANDLER;
pub const PI_LOADAPPDIRECT = enum__tagPI_FLAGS.PI_LOADAPPDIRECT;
pub const PD_FORCE_SWITCH = enum__tagPI_FLAGS.PD_FORCE_SWITCH;
pub const PI_PREFERDEFAULTHANDLER = enum__tagPI_FLAGS.PI_PREFERDEFAULTHANDLER;
pub const enum__tagPI_FLAGS = extern enum {
    PI_PARSE_URL = 1,
    PI_FILTER_MODE = 2,
    PI_FORCE_ASYNC = 4,
    PI_USE_WORKERTHREAD = 8,
    PI_MIMEVERIFICATION = 16,
    PI_CLSIDLOOKUP = 32,
    PI_DATAPROGRESS = 64,
    PI_SYNCHRONOUS = 128,
    PI_APARTMENTTHREADED = 256,
    PI_CLASSINSTALL = 512,
    PI_PASSONBINDCTX = 8192,
    PI_NOMIMEHANDLER = 32768,
    PI_LOADAPPDIRECT = 16384,
    PD_FORCE_SWITCH = 65536,
    PI_PREFERDEFAULTHANDLER = 131072,
};
pub const PI_FLAGS = enum__tagPI_FLAGS;
pub const struct__tagStartParam = extern struct {
    iid: IID,
    pIBindCtx: [*c]IBindCtx,
    pItf: [*c]IUnknown,
};
pub const StartParam = struct__tagStartParam;
pub extern const IID_IInternetProtocolRoot: IID;
pub const IInternetProtocolRootVtbl = struct_IInternetProtocolRootVtbl;
pub extern var __MIDL_itf_urlmon_0000_0029_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0029_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPIINTERNETPROTOCOL = [*c]IInternetProtocol;
pub extern const IID_IInternetProtocol: IID;
pub const IInternetProtocolVtbl = struct_IInternetProtocolVtbl;
pub extern var __MIDL_itf_urlmon_0000_0030_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0030_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IInternetProtocolEx: IID;
pub const IInternetProtocolExVtbl = struct_IInternetProtocolExVtbl;
pub extern var __MIDL_itf_urlmon_0000_0031_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0031_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPIINTERNETPROTOCOLSINK = [*c]IInternetProtocolSink;
pub extern const IID_IInternetProtocolSink: IID;
pub const IInternetProtocolSinkVtbl = struct_IInternetProtocolSinkVtbl;
pub extern var __MIDL_itf_urlmon_0000_0032_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0032_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPIINTERNETPROTOCOLSINKStackable = [*c]IInternetProtocolSinkStackable;
pub extern const IID_IInternetProtocolSinkStackable: IID;
pub const IInternetProtocolSinkStackableVtbl = struct_IInternetProtocolSinkStackableVtbl;
pub extern var __MIDL_itf_urlmon_0000_0033_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0033_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPIINTERNETSESSION = [*c]IInternetSession;
pub const OIBDG_APARTMENTTHREADED = enum__tagOIBDG_FLAGS.OIBDG_APARTMENTTHREADED;
pub const OIBDG_DATAONLY = enum__tagOIBDG_FLAGS.OIBDG_DATAONLY;
pub const enum__tagOIBDG_FLAGS = extern enum {
    OIBDG_APARTMENTTHREADED = 256,
    OIBDG_DATAONLY = 4096,
};
pub const OIBDG_FLAGS = enum__tagOIBDG_FLAGS;
pub extern const IID_IInternetSession: IID;
pub const IInternetSessionVtbl = struct_IInternetSessionVtbl;
pub extern var __MIDL_itf_urlmon_0000_0034_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0034_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPIINTERNETTHREADSWITCH = [*c]IInternetThreadSwitch;
pub extern const IID_IInternetThreadSwitch: IID;
pub const IInternetThreadSwitchVtbl = struct_IInternetThreadSwitchVtbl;
pub extern var __MIDL_itf_urlmon_0000_0035_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0035_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPIINTERNETPRIORITY = [*c]IInternetPriority;
pub extern const IID_IInternetPriority: IID;
pub const IInternetPriorityVtbl = struct_IInternetPriorityVtbl;
pub extern var __MIDL_itf_urlmon_0000_0036_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0036_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPIINTERNETPROTOCOLINFO = [*c]IInternetProtocolInfo;
pub const PSU_DEFAULT = enum__tagPSUACTION.PSU_DEFAULT;
pub const PSU_SECURITY_URL_ONLY = enum__tagPSUACTION.PSU_SECURITY_URL_ONLY;
pub const enum__tagPSUACTION = extern enum {
    PSU_DEFAULT = 1,
    PSU_SECURITY_URL_ONLY = 2,
};
pub const PSUACTION = enum__tagPSUACTION;
pub extern const IID_IInternetProtocolInfo: IID;
pub const IInternetProtocolInfoVtbl = struct_IInternetProtocolInfoVtbl;
pub extern "urlmon" fn CoInternetParseUrl(pwzUrl: LPCWSTR, ParseAction: PARSEACTION, dwFlags: DWORD, pszResult: LPWSTR, cchResult: DWORD, pcchResult: [*c]DWORD, dwReserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CoInternetParseIUri(pIUri: [*c]IUri, ParseAction: PARSEACTION, dwFlags: DWORD, pwzResult: LPWSTR, cchResult: DWORD, pcchResult: [*c]DWORD, dwReserved: DWORD_PTR) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CoInternetCombineUrl(pwzBaseUrl: LPCWSTR, pwzRelativeUrl: LPCWSTR, dwCombineFlags: DWORD, pszResult: LPWSTR, cchResult: DWORD, pcchResult: [*c]DWORD, dwReserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CoInternetCombineUrlEx(pBaseUri: [*c]IUri, pwzRelativeUrl: LPCWSTR, dwCombineFlags: DWORD, ppCombinedUri: [*c]([*c]IUri), dwReserved: DWORD_PTR) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CoInternetCombineIUri(pBaseUri: [*c]IUri, pRelativeUri: [*c]IUri, dwCombineFlags: DWORD, ppCombinedUri: [*c]([*c]IUri), dwReserved: DWORD_PTR) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CoInternetCompareUrl(pwzUrl1: LPCWSTR, pwzUrl2: LPCWSTR, dwFlags: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CoInternetGetProtocolFlags(pwzUrl: LPCWSTR, pdwFlags: [*c]DWORD, dwReserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CoInternetQueryInfo(pwzUrl: LPCWSTR, QueryOptions: QUERYOPTION, dwQueryFlags: DWORD, pvBuffer: LPVOID, cbBuffer: DWORD, pcbBuffer: [*c]DWORD, dwReserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CoInternetGetSession(dwSessionMode: DWORD, ppIInternetSession: [*c]([*c]IInternetSession), dwReserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CoInternetGetSecurityUrl(pwszUrl: LPCWSTR, ppwszSecUrl: [*c]LPWSTR, psuAction: PSUACTION, dwReserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn AsyncInstallDistributionUnit(szDistUnit: LPCWSTR, szTYPE: LPCWSTR, szExt: LPCWSTR, dwFileVersionMS: DWORD, dwFileVersionLS: DWORD, szURL: LPCWSTR, pbc: [*c]IBindCtx, pvReserved: LPVOID, flags: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CoInternetGetSecurityUrlEx(pUri: [*c]IUri, ppSecUri: [*c]([*c]IUri), psuAction: PSUACTION, dwReserved: DWORD_PTR) callconv(.Stdcall) HRESULT;
pub const FEATURE_OBJECT_CACHING = enum__tagINTERNETFEATURELIST.FEATURE_OBJECT_CACHING;
pub const FEATURE_ZONE_ELEVATION = enum__tagINTERNETFEATURELIST.FEATURE_ZONE_ELEVATION;
pub const FEATURE_MIME_HANDLING = enum__tagINTERNETFEATURELIST.FEATURE_MIME_HANDLING;
pub const FEATURE_MIME_SNIFFING = enum__tagINTERNETFEATURELIST.FEATURE_MIME_SNIFFING;
pub const FEATURE_WINDOW_RESTRICTIONS = enum__tagINTERNETFEATURELIST.FEATURE_WINDOW_RESTRICTIONS;
pub const FEATURE_WEBOC_POPUPMANAGEMENT = enum__tagINTERNETFEATURELIST.FEATURE_WEBOC_POPUPMANAGEMENT;
pub const FEATURE_BEHAVIORS = enum__tagINTERNETFEATURELIST.FEATURE_BEHAVIORS;
pub const FEATURE_DISABLE_MK_PROTOCOL = enum__tagINTERNETFEATURELIST.FEATURE_DISABLE_MK_PROTOCOL;
pub const FEATURE_LOCALMACHINE_LOCKDOWN = enum__tagINTERNETFEATURELIST.FEATURE_LOCALMACHINE_LOCKDOWN;
pub const FEATURE_SECURITYBAND = enum__tagINTERNETFEATURELIST.FEATURE_SECURITYBAND;
pub const FEATURE_RESTRICT_ACTIVEXINSTALL = enum__tagINTERNETFEATURELIST.FEATURE_RESTRICT_ACTIVEXINSTALL;
pub const FEATURE_VALIDATE_NAVIGATE_URL = enum__tagINTERNETFEATURELIST.FEATURE_VALIDATE_NAVIGATE_URL;
pub const FEATURE_RESTRICT_FILEDOWNLOAD = enum__tagINTERNETFEATURELIST.FEATURE_RESTRICT_FILEDOWNLOAD;
pub const FEATURE_ADDON_MANAGEMENT = enum__tagINTERNETFEATURELIST.FEATURE_ADDON_MANAGEMENT;
pub const FEATURE_PROTOCOL_LOCKDOWN = enum__tagINTERNETFEATURELIST.FEATURE_PROTOCOL_LOCKDOWN;
pub const FEATURE_HTTP_USERNAME_PASSWORD_DISABLE = enum__tagINTERNETFEATURELIST.FEATURE_HTTP_USERNAME_PASSWORD_DISABLE;
pub const FEATURE_SAFE_BINDTOOBJECT = enum__tagINTERNETFEATURELIST.FEATURE_SAFE_BINDTOOBJECT;
pub const FEATURE_UNC_SAVEDFILECHECK = enum__tagINTERNETFEATURELIST.FEATURE_UNC_SAVEDFILECHECK;
pub const FEATURE_GET_URL_DOM_FILEPATH_UNENCODED = enum__tagINTERNETFEATURELIST.FEATURE_GET_URL_DOM_FILEPATH_UNENCODED;
pub const FEATURE_TABBED_BROWSING = enum__tagINTERNETFEATURELIST.FEATURE_TABBED_BROWSING;
pub const FEATURE_SSLUX = enum__tagINTERNETFEATURELIST.FEATURE_SSLUX;
pub const FEATURE_DISABLE_NAVIGATION_SOUNDS = enum__tagINTERNETFEATURELIST.FEATURE_DISABLE_NAVIGATION_SOUNDS;
pub const FEATURE_DISABLE_LEGACY_COMPRESSION = enum__tagINTERNETFEATURELIST.FEATURE_DISABLE_LEGACY_COMPRESSION;
pub const FEATURE_FORCE_ADDR_AND_STATUS = enum__tagINTERNETFEATURELIST.FEATURE_FORCE_ADDR_AND_STATUS;
pub const FEATURE_XMLHTTP = enum__tagINTERNETFEATURELIST.FEATURE_XMLHTTP;
pub const FEATURE_DISABLE_TELNET_PROTOCOL = enum__tagINTERNETFEATURELIST.FEATURE_DISABLE_TELNET_PROTOCOL;
pub const FEATURE_FEEDS = enum__tagINTERNETFEATURELIST.FEATURE_FEEDS;
pub const FEATURE_BLOCK_INPUT_PROMPTS = enum__tagINTERNETFEATURELIST.FEATURE_BLOCK_INPUT_PROMPTS;
pub const FEATURE_ENTRY_COUNT = enum__tagINTERNETFEATURELIST.FEATURE_ENTRY_COUNT;
pub const enum__tagINTERNETFEATURELIST = extern enum {
    FEATURE_OBJECT_CACHING = 0,
    FEATURE_ZONE_ELEVATION = 1,
    FEATURE_MIME_HANDLING = 2,
    FEATURE_MIME_SNIFFING = 3,
    FEATURE_WINDOW_RESTRICTIONS = 4,
    FEATURE_WEBOC_POPUPMANAGEMENT = 5,
    FEATURE_BEHAVIORS = 6,
    FEATURE_DISABLE_MK_PROTOCOL = 7,
    FEATURE_LOCALMACHINE_LOCKDOWN = 8,
    FEATURE_SECURITYBAND = 9,
    FEATURE_RESTRICT_ACTIVEXINSTALL = 10,
    FEATURE_VALIDATE_NAVIGATE_URL = 11,
    FEATURE_RESTRICT_FILEDOWNLOAD = 12,
    FEATURE_ADDON_MANAGEMENT = 13,
    FEATURE_PROTOCOL_LOCKDOWN = 14,
    FEATURE_HTTP_USERNAME_PASSWORD_DISABLE = 15,
    FEATURE_SAFE_BINDTOOBJECT = 16,
    FEATURE_UNC_SAVEDFILECHECK = 17,
    FEATURE_GET_URL_DOM_FILEPATH_UNENCODED = 18,
    FEATURE_TABBED_BROWSING = 19,
    FEATURE_SSLUX = 20,
    FEATURE_DISABLE_NAVIGATION_SOUNDS = 21,
    FEATURE_DISABLE_LEGACY_COMPRESSION = 22,
    FEATURE_FORCE_ADDR_AND_STATUS = 23,
    FEATURE_XMLHTTP = 24,
    FEATURE_DISABLE_TELNET_PROTOCOL = 25,
    FEATURE_FEEDS = 26,
    FEATURE_BLOCK_INPUT_PROMPTS = 27,
    FEATURE_ENTRY_COUNT = 28,
};
pub const INTERNETFEATURELIST = enum__tagINTERNETFEATURELIST;
pub extern "urlmon" fn CoInternetSetFeatureEnabled(FeatureEntry: INTERNETFEATURELIST, dwFlags: DWORD, fEnable: BOOL) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CoInternetIsFeatureEnabled(FeatureEntry: INTERNETFEATURELIST, dwFlags: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CoInternetIsFeatureEnabledForUrl(FeatureEntry: INTERNETFEATURELIST, dwFlags: DWORD, szURL: LPCWSTR, pSecMgr: [*c]IInternetSecurityManager) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CoInternetIsFeatureEnabledForIUri(FeatureEntry: INTERNETFEATURELIST, dwFlags: DWORD, pIUri: [*c]IUri, pSecMgr: [*c]IInternetSecurityManagerEx2) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CoInternetIsFeatureZoneElevationEnabled(szFromURL: LPCWSTR, szToURL: LPCWSTR, pSecMgr: [*c]IInternetSecurityManager, dwFlags: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CopyStgMedium(pcstgmedSrc: [*c]const STGMEDIUM, pstgmedDest: [*c]STGMEDIUM) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CopyBindInfo(pcbiSrc: [*c]const BINDINFO, pbiDest: [*c]BINDINFO) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn ReleaseBindInfo(pbindinfo: [*c]BINDINFO) callconv(.Stdcall) void;
pub extern "urlmon" fn IEGetUserPrivateNamespaceName() callconv(.Stdcall) PWSTR;
pub extern "urlmon" fn CoInternetCreateSecurityManager(pSP: [*c]IServiceProvider, ppSM: [*c]([*c]IInternetSecurityManager), dwReserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn CoInternetCreateZoneManager(pSP: [*c]IServiceProvider, ppZM: [*c]([*c]IInternetZoneManager), dwReserved: DWORD) callconv(.Stdcall) HRESULT;
pub extern const CLSID_InternetSecurityManager: IID;
pub extern const CLSID_InternetZoneManager: IID;
pub extern const CLSID_PersistentZoneIdentifier: IID;
pub extern var __MIDL_itf_urlmon_0000_0037_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0037_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IInternetSecurityMgrSite: IID;
pub const IInternetSecurityMgrSiteVtbl = struct_IInternetSecurityMgrSiteVtbl;
pub extern var __MIDL_itf_urlmon_0000_0038_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0038_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const PUAF_DEFAULT = enum___MIDL_IInternetSecurityManager_0001.PUAF_DEFAULT;
pub const PUAF_NOUI = enum___MIDL_IInternetSecurityManager_0001.PUAF_NOUI;
pub const PUAF_ISFILE = enum___MIDL_IInternetSecurityManager_0001.PUAF_ISFILE;
pub const PUAF_WARN_IF_DENIED = enum___MIDL_IInternetSecurityManager_0001.PUAF_WARN_IF_DENIED;
pub const PUAF_FORCEUI_FOREGROUND = enum___MIDL_IInternetSecurityManager_0001.PUAF_FORCEUI_FOREGROUND;
pub const PUAF_CHECK_TIFS = enum___MIDL_IInternetSecurityManager_0001.PUAF_CHECK_TIFS;
pub const PUAF_DONTCHECKBOXINDIALOG = enum___MIDL_IInternetSecurityManager_0001.PUAF_DONTCHECKBOXINDIALOG;
pub const PUAF_TRUSTED = enum___MIDL_IInternetSecurityManager_0001.PUAF_TRUSTED;
pub const PUAF_ACCEPT_WILDCARD_SCHEME = enum___MIDL_IInternetSecurityManager_0001.PUAF_ACCEPT_WILDCARD_SCHEME;
pub const PUAF_ENFORCERESTRICTED = enum___MIDL_IInternetSecurityManager_0001.PUAF_ENFORCERESTRICTED;
pub const PUAF_NOSAVEDFILECHECK = enum___MIDL_IInternetSecurityManager_0001.PUAF_NOSAVEDFILECHECK;
pub const PUAF_REQUIRESAVEDFILECHECK = enum___MIDL_IInternetSecurityManager_0001.PUAF_REQUIRESAVEDFILECHECK;
pub const PUAF_DONT_USE_CACHE = enum___MIDL_IInternetSecurityManager_0001.PUAF_DONT_USE_CACHE;
pub const PUAF_RESERVED1 = enum___MIDL_IInternetSecurityManager_0001.PUAF_RESERVED1;
pub const PUAF_RESERVED2 = enum___MIDL_IInternetSecurityManager_0001.PUAF_RESERVED2;
pub const PUAF_LMZ_UNLOCKED = enum___MIDL_IInternetSecurityManager_0001.PUAF_LMZ_UNLOCKED;
pub const PUAF_LMZ_LOCKED = enum___MIDL_IInternetSecurityManager_0001.PUAF_LMZ_LOCKED;
pub const PUAF_DEFAULTZONEPOL = enum___MIDL_IInternetSecurityManager_0001.PUAF_DEFAULTZONEPOL;
pub const PUAF_NPL_USE_LOCKED_IF_RESTRICTED = enum___MIDL_IInternetSecurityManager_0001.PUAF_NPL_USE_LOCKED_IF_RESTRICTED;
pub const PUAF_NOUIIFLOCKED = enum___MIDL_IInternetSecurityManager_0001.PUAF_NOUIIFLOCKED;
pub const PUAF_DRAGPROTOCOLCHECK = enum___MIDL_IInternetSecurityManager_0001.PUAF_DRAGPROTOCOLCHECK;
pub const enum___MIDL_IInternetSecurityManager_0001 = extern enum {
    PUAF_DEFAULT = 0,
    PUAF_NOUI = 1,
    PUAF_ISFILE = 2,
    PUAF_WARN_IF_DENIED = 4,
    PUAF_FORCEUI_FOREGROUND = 8,
    PUAF_CHECK_TIFS = 16,
    PUAF_DONTCHECKBOXINDIALOG = 32,
    PUAF_TRUSTED = 64,
    PUAF_ACCEPT_WILDCARD_SCHEME = 128,
    PUAF_ENFORCERESTRICTED = 256,
    PUAF_NOSAVEDFILECHECK = 512,
    PUAF_REQUIRESAVEDFILECHECK = 1024,
    PUAF_DONT_USE_CACHE = 4096,
    PUAF_RESERVED1 = 8192,
    PUAF_RESERVED2 = 16384,
    PUAF_LMZ_UNLOCKED = 65536,
    PUAF_LMZ_LOCKED = 131072,
    PUAF_DEFAULTZONEPOL = 262144,
    PUAF_NPL_USE_LOCKED_IF_RESTRICTED = 524288,
    PUAF_NOUIIFLOCKED = 1048576,
    PUAF_DRAGPROTOCOLCHECK = 2097152,
};
pub const PUAF = enum___MIDL_IInternetSecurityManager_0001;
pub const PUAFOUT_DEFAULT = enum___MIDL_IInternetSecurityManager_0002.PUAFOUT_DEFAULT;
pub const PUAFOUT_ISLOCKZONEPOLICY = enum___MIDL_IInternetSecurityManager_0002.PUAFOUT_ISLOCKZONEPOLICY;
pub const enum___MIDL_IInternetSecurityManager_0002 = extern enum {
    PUAFOUT_DEFAULT = 0,
    PUAFOUT_ISLOCKZONEPOLICY = 1,
};
pub const PUAFOUT = enum___MIDL_IInternetSecurityManager_0002;
pub const SZM_CREATE = enum___MIDL_IInternetSecurityManager_0003.SZM_CREATE;
pub const SZM_DELETE = enum___MIDL_IInternetSecurityManager_0003.SZM_DELETE;
pub const enum___MIDL_IInternetSecurityManager_0003 = extern enum {
    SZM_CREATE = 0,
    SZM_DELETE = 1,
};
pub const SZM_FLAGS = enum___MIDL_IInternetSecurityManager_0003;
pub extern const IID_IInternetSecurityManager: IID;
pub const IInternetSecurityManagerVtbl = struct_IInternetSecurityManagerVtbl;
pub extern var __MIDL_itf_urlmon_0000_0039_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0039_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IInternetSecurityManagerEx: IID;
pub const IInternetSecurityManagerExVtbl = struct_IInternetSecurityManagerExVtbl;
pub extern var __MIDL_itf_urlmon_0000_0040_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0040_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IInternetSecurityManagerEx2: IID;
pub const IInternetSecurityManagerEx2Vtbl = struct_IInternetSecurityManagerEx2Vtbl;
pub extern var __MIDL_itf_urlmon_0000_0041_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0041_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IZoneIdentifier: IID;
pub const IZoneIdentifierVtbl = struct_IZoneIdentifierVtbl;
pub extern var __MIDL_itf_urlmon_0000_0042_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0042_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IZoneIdentifier2: IID;
pub const IZoneIdentifier2Vtbl = struct_IZoneIdentifier2Vtbl;
pub extern var __MIDL_itf_urlmon_0000_0043_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0043_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IInternetHostSecurityManager: IID;
pub const IInternetHostSecurityManagerVtbl = struct_IInternetHostSecurityManagerVtbl;
pub extern const GUID_CUSTOM_LOCALMACHINEZONEUNLOCKED: GUID;
pub extern var __MIDL_itf_urlmon_0000_0044_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0044_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPURLZONEMANAGER = [*c]IInternetZoneManager;
pub const URLZONE_INVALID = enum_tagURLZONE.URLZONE_INVALID;
pub const URLZONE_PREDEFINED_MIN = enum_tagURLZONE.URLZONE_PREDEFINED_MIN;
pub const URLZONE_LOCAL_MACHINE = enum_tagURLZONE.URLZONE_LOCAL_MACHINE;
pub const URLZONE_INTRANET = enum_tagURLZONE.URLZONE_INTRANET;
pub const URLZONE_TRUSTED = enum_tagURLZONE.URLZONE_TRUSTED;
pub const URLZONE_INTERNET = enum_tagURLZONE.URLZONE_INTERNET;
pub const URLZONE_UNTRUSTED = enum_tagURLZONE.URLZONE_UNTRUSTED;
pub const URLZONE_PREDEFINED_MAX = enum_tagURLZONE.URLZONE_PREDEFINED_MAX;
pub const URLZONE_USER_MIN = enum_tagURLZONE.URLZONE_USER_MIN;
pub const URLZONE_USER_MAX = enum_tagURLZONE.URLZONE_USER_MAX;
pub const enum_tagURLZONE = extern enum {
    URLZONE_INVALID = -1,
    URLZONE_PREDEFINED_MIN = 0,
    URLZONE_LOCAL_MACHINE = 0,
    URLZONE_INTRANET = 1,
    URLZONE_TRUSTED = 2,
    URLZONE_INTERNET = 3,
    URLZONE_UNTRUSTED = 4,
    URLZONE_PREDEFINED_MAX = 999,
    URLZONE_USER_MIN = 1000,
    URLZONE_USER_MAX = 10000,
};
pub const URLZONE = enum_tagURLZONE;
pub const URLTEMPLATE_CUSTOM = enum_tagURLTEMPLATE.URLTEMPLATE_CUSTOM;
pub const URLTEMPLATE_PREDEFINED_MIN = enum_tagURLTEMPLATE.URLTEMPLATE_PREDEFINED_MIN;
pub const URLTEMPLATE_LOW = enum_tagURLTEMPLATE.URLTEMPLATE_LOW;
pub const URLTEMPLATE_MEDLOW = enum_tagURLTEMPLATE.URLTEMPLATE_MEDLOW;
pub const URLTEMPLATE_MEDIUM = enum_tagURLTEMPLATE.URLTEMPLATE_MEDIUM;
pub const URLTEMPLATE_MEDHIGH = enum_tagURLTEMPLATE.URLTEMPLATE_MEDHIGH;
pub const URLTEMPLATE_HIGH = enum_tagURLTEMPLATE.URLTEMPLATE_HIGH;
pub const URLTEMPLATE_PREDEFINED_MAX = enum_tagURLTEMPLATE.URLTEMPLATE_PREDEFINED_MAX;
pub const enum_tagURLTEMPLATE = extern enum {
    URLTEMPLATE_CUSTOM = 0,
    URLTEMPLATE_PREDEFINED_MIN = 65536,
    URLTEMPLATE_LOW = 65536,
    URLTEMPLATE_MEDLOW = 66816,
    URLTEMPLATE_MEDIUM = 69632,
    URLTEMPLATE_MEDHIGH = 70912,
    URLTEMPLATE_HIGH = 73728,
    URLTEMPLATE_PREDEFINED_MAX = 131072,
};
pub const URLTEMPLATE = enum_tagURLTEMPLATE;
pub const MAX_ZONE_PATH = enum___MIDL_IInternetZoneManager_0001.MAX_ZONE_PATH;
pub const MAX_ZONE_DESCRIPTION = enum___MIDL_IInternetZoneManager_0001.MAX_ZONE_DESCRIPTION;
pub const enum___MIDL_IInternetZoneManager_0001 = extern enum {
    MAX_ZONE_PATH = 260,
    MAX_ZONE_DESCRIPTION = 200,
};
pub const ZAFLAGS_CUSTOM_EDIT = enum___MIDL_IInternetZoneManager_0002.ZAFLAGS_CUSTOM_EDIT;
pub const ZAFLAGS_ADD_SITES = enum___MIDL_IInternetZoneManager_0002.ZAFLAGS_ADD_SITES;
pub const ZAFLAGS_REQUIRE_VERIFICATION = enum___MIDL_IInternetZoneManager_0002.ZAFLAGS_REQUIRE_VERIFICATION;
pub const ZAFLAGS_INCLUDE_PROXY_OVERRIDE = enum___MIDL_IInternetZoneManager_0002.ZAFLAGS_INCLUDE_PROXY_OVERRIDE;
pub const ZAFLAGS_INCLUDE_INTRANET_SITES = enum___MIDL_IInternetZoneManager_0002.ZAFLAGS_INCLUDE_INTRANET_SITES;
pub const ZAFLAGS_NO_UI = enum___MIDL_IInternetZoneManager_0002.ZAFLAGS_NO_UI;
pub const ZAFLAGS_SUPPORTS_VERIFICATION = enum___MIDL_IInternetZoneManager_0002.ZAFLAGS_SUPPORTS_VERIFICATION;
pub const ZAFLAGS_UNC_AS_INTRANET = enum___MIDL_IInternetZoneManager_0002.ZAFLAGS_UNC_AS_INTRANET;
pub const ZAFLAGS_DETECT_INTRANET = enum___MIDL_IInternetZoneManager_0002.ZAFLAGS_DETECT_INTRANET;
pub const ZAFLAGS_USE_LOCKED_ZONES = enum___MIDL_IInternetZoneManager_0002.ZAFLAGS_USE_LOCKED_ZONES;
pub const ZAFLAGS_VERIFY_TEMPLATE_SETTINGS = enum___MIDL_IInternetZoneManager_0002.ZAFLAGS_VERIFY_TEMPLATE_SETTINGS;
pub const ZAFLAGS_NO_CACHE = enum___MIDL_IInternetZoneManager_0002.ZAFLAGS_NO_CACHE;
pub const enum___MIDL_IInternetZoneManager_0002 = extern enum {
    ZAFLAGS_CUSTOM_EDIT = 1,
    ZAFLAGS_ADD_SITES = 2,
    ZAFLAGS_REQUIRE_VERIFICATION = 4,
    ZAFLAGS_INCLUDE_PROXY_OVERRIDE = 8,
    ZAFLAGS_INCLUDE_INTRANET_SITES = 16,
    ZAFLAGS_NO_UI = 32,
    ZAFLAGS_SUPPORTS_VERIFICATION = 64,
    ZAFLAGS_UNC_AS_INTRANET = 128,
    ZAFLAGS_DETECT_INTRANET = 256,
    ZAFLAGS_USE_LOCKED_ZONES = 65536,
    ZAFLAGS_VERIFY_TEMPLATE_SETTINGS = 131072,
    ZAFLAGS_NO_CACHE = 262144,
};
pub const ZAFLAGS = enum___MIDL_IInternetZoneManager_0002;
pub const LPZONEATTRIBUTES = [*c]struct__ZONEATTRIBUTES;
pub extern const IID_IInternetZoneManager: IID;
pub const IInternetZoneManagerVtbl = struct_IInternetZoneManagerVtbl;
pub extern var __MIDL_itf_urlmon_0000_0045_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0045_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IInternetZoneManagerEx: IID;
pub const IInternetZoneManagerExVtbl = struct_IInternetZoneManagerExVtbl;
pub extern var __MIDL_itf_urlmon_0000_0046_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0046_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IInternetZoneManagerEx2: IID;
pub const IInternetZoneManagerEx2Vtbl = struct_IInternetZoneManagerEx2Vtbl;
pub extern const CLSID_SoftDistExt: IID;
pub const CODEBASEHOLD = struct__tagCODEBASEHOLD;
pub const SOFTDISTINFO = struct__tagSOFTDISTINFO;
pub extern var __MIDL_itf_urlmon_0000_0047_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0047_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_ISoftDistExt: IID;
pub const ISoftDistExtVtbl = struct_ISoftDistExtVtbl;
pub extern "urlmon" fn GetSoftwareUpdateInfo(szDistUnit: LPCWSTR, psdi: LPSOFTDISTINFO) callconv(.Stdcall) HRESULT;
pub extern "urlmon" fn SetSoftwareUpdateAdvertisementState(szDistUnit: LPCWSTR, dwAdState: DWORD, dwAdvertisedVersionMS: DWORD, dwAdvertisedVersionLS: DWORD) callconv(.Stdcall) HRESULT;
pub extern var __MIDL_itf_urlmon_0000_0048_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0048_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPCATALOGFILEINFO = [*c]ICatalogFileInfo;
pub extern const IID_ICatalogFileInfo: IID;
pub const ICatalogFileInfoVtbl = struct_ICatalogFileInfoVtbl;
pub extern var __MIDL_itf_urlmon_0000_0049_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0049_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPDATAFILTER = [*c]IDataFilter;
pub extern const IID_IDataFilter: IID;
pub const IDataFilterVtbl = struct_IDataFilterVtbl;
pub const struct__tagPROTOCOLFILTERDATA = extern struct {
    cbSize: DWORD,
    pProtocolSink: [*c]IInternetProtocolSink,
    pProtocol: [*c]IInternetProtocol,
    pUnk: [*c]IUnknown,
    dwFilterFlags: DWORD,
};
pub const PROTOCOLFILTERDATA = struct__tagPROTOCOLFILTERDATA;
pub extern var __MIDL_itf_urlmon_0000_0050_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0050_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPENCODINGFILTERFACTORY = [*c]IEncodingFilterFactory;
pub extern const IID_IEncodingFilterFactory: IID;
pub const IEncodingFilterFactoryVtbl = struct_IEncodingFilterFactoryVtbl;
pub extern "urlmon" fn IsLoggingEnabledA(pszUrl: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "urlmon" fn IsLoggingEnabledW(pwszUrl: LPCWSTR) callconv(.Stdcall) BOOL;
pub const struct__tagHIT_LOGGING_INFO = extern struct {
    dwStructSize: DWORD,
    lpszLoggedUrlName: LPSTR,
    StartTime: SYSTEMTIME,
    EndTime: SYSTEMTIME,
    lpszExtendedInfo: LPSTR,
};
pub const HIT_LOGGING_INFO = struct__tagHIT_LOGGING_INFO;
pub const LPHIT_LOGGING_INFO = [*c]struct__tagHIT_LOGGING_INFO;
pub extern "urlmon" fn WriteHitLogging(lpLogginginfo: LPHIT_LOGGING_INFO) callconv(.Stdcall) BOOL;
pub const struct_CONFIRMSAFETY = extern struct {
    clsid: CLSID,
    pUnk: [*c]IUnknown,
    dwFlags: DWORD,
};
pub extern const GUID_CUSTOM_CONFIRMOBJECTSAFETY: GUID;
pub extern var __MIDL_itf_urlmon_0000_0051_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0051_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPIWRAPPEDPROTOCOL = [*c]IWrappedProtocol;
pub extern const IID_IWrappedProtocol: IID;
pub const IWrappedProtocolVtbl = struct_IWrappedProtocolVtbl;
pub extern var __MIDL_itf_urlmon_0000_0052_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0052_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPGETBINDHANDLE = [*c]IGetBindHandle;
pub extern const IID_IGetBindHandle: IID;
pub const IGetBindHandleVtbl = struct_IGetBindHandleVtbl;
pub const struct__tagPROTOCOL_ARGUMENT = extern struct {
    szMethod: LPCWSTR,
    szTargetUrl: LPCWSTR,
};
pub const PROTOCOL_ARGUMENT = struct__tagPROTOCOL_ARGUMENT;
pub const LPPROTOCOL_ARGUMENT = [*c]struct__tagPROTOCOL_ARGUMENT;
pub extern var __MIDL_itf_urlmon_0000_0053_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0053_v0_0_s_ifspec: RPC_IF_HANDLE;
pub const LPBINDCALLBACKREDIRECT = [*c]IBindCallbackRedirect;
pub extern const IID_IBindCallbackRedirect: IID;
pub const IBindCallbackRedirectVtbl = struct_IBindCallbackRedirectVtbl;
pub extern var __MIDL_itf_urlmon_0000_0054_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0054_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern const IID_IBindHttpSecurity: IID;
pub const IBindHttpSecurityVtbl = struct_IBindHttpSecurityVtbl;
pub extern var __MIDL_itf_urlmon_0000_0055_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_urlmon_0000_0055_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern fn IBinding_GetBindResult_Proxy(This: [*c]IBinding, pclsidProtocol: [*c]CLSID, pdwResult: [*c]DWORD, pszResult: [*c]LPOLESTR, pdwReserved: [*c]DWORD) HRESULT;
pub extern fn IBinding_GetBindResult_Stub(This: [*c]IBinding, pclsidProtocol: [*c]CLSID, pdwResult: [*c]DWORD, pszResult: [*c]LPOLESTR, dwReserved: DWORD) HRESULT;
pub extern fn IBindStatusCallback_GetBindInfo_Proxy(This: [*c]IBindStatusCallback, grfBINDF: [*c]DWORD, pbindinfo: [*c]BINDINFO) HRESULT;
pub extern fn IBindStatusCallback_GetBindInfo_Stub(This: [*c]IBindStatusCallback, grfBINDF: [*c]DWORD, pbindinfo: [*c]RemBINDINFO, pstgmed: [*c]RemSTGMEDIUM) HRESULT;
pub extern fn IBindStatusCallback_OnDataAvailable_Proxy(This: [*c]IBindStatusCallback, grfBSCF: DWORD, dwSize: DWORD, pformatetc: [*c]FORMATETC, pstgmed: [*c]STGMEDIUM) HRESULT;
pub extern fn IBindStatusCallback_OnDataAvailable_Stub(This: [*c]IBindStatusCallback, grfBSCF: DWORD, dwSize: DWORD, pformatetc: [*c]RemFORMATETC, pstgmed: [*c]RemSTGMEDIUM) HRESULT;
pub extern fn IBindStatusCallbackEx_GetBindInfoEx_Proxy(This: [*c]IBindStatusCallbackEx, grfBINDF: [*c]DWORD, pbindinfo: [*c]BINDINFO, grfBINDF2: [*c]DWORD, pdwReserved: [*c]DWORD) HRESULT;
pub extern fn IBindStatusCallbackEx_GetBindInfoEx_Stub(This: [*c]IBindStatusCallbackEx, grfBINDF: [*c]DWORD, pbindinfo: [*c]RemBINDINFO, pstgmed: [*c]RemSTGMEDIUM, grfBINDF2: [*c]DWORD, pdwReserved: [*c]DWORD) HRESULT;
pub extern fn IWinInetInfo_QueryOption_Proxy(This: [*c]IWinInetInfo, dwOption: DWORD, pBuffer: LPVOID, pcbBuf: [*c]DWORD) HRESULT;
pub extern fn IWinInetInfo_QueryOption_Stub(This: [*c]IWinInetInfo, dwOption: DWORD, pBuffer: [*c]BYTE, pcbBuf: [*c]DWORD) HRESULT;
pub extern fn IWinInetHttpInfo_QueryInfo_Proxy(This: [*c]IWinInetHttpInfo, dwOption: DWORD, pBuffer: LPVOID, pcbBuf: [*c]DWORD, pdwFlags: [*c]DWORD, pdwReserved: [*c]DWORD) HRESULT;
pub extern fn IWinInetHttpInfo_QueryInfo_Stub(This: [*c]IWinInetHttpInfo, dwOption: DWORD, pBuffer: [*c]BYTE, pcbBuf: [*c]DWORD, pdwFlags: [*c]DWORD, pdwReserved: [*c]DWORD) HRESULT;
pub extern fn IBindHost_MonikerBindToStorage_Proxy(This: [*c]IBindHost, pMk: [*c]IMoniker, pBC: [*c]IBindCtx, pBSC: [*c]IBindStatusCallback, riid: [*c]const IID, ppvObj: [*c](?*c_void)) HRESULT;
pub extern fn IBindHost_MonikerBindToStorage_Stub(This: [*c]IBindHost, pMk: [*c]IMoniker, pBC: [*c]IBindCtx, pBSC: [*c]IBindStatusCallback, riid: [*c]const IID, ppvObj: [*c]([*c]IUnknown)) HRESULT;
pub extern fn IBindHost_MonikerBindToObject_Proxy(This: [*c]IBindHost, pMk: [*c]IMoniker, pBC: [*c]IBindCtx, pBSC: [*c]IBindStatusCallback, riid: [*c]const IID, ppvObj: [*c](?*c_void)) HRESULT;
pub extern fn IBindHost_MonikerBindToObject_Stub(This: [*c]IBindHost, pMk: [*c]IMoniker, pBC: [*c]IBindCtx, pBSC: [*c]IBindStatusCallback, riid: [*c]const IID, ppvObj: [*c]([*c]IUnknown)) HRESULT;
pub const PIDMSI_STATUS_NORMAL = enum_PIDMSI_STATUS_VALUE.PIDMSI_STATUS_NORMAL;
pub const PIDMSI_STATUS_NEW = enum_PIDMSI_STATUS_VALUE.PIDMSI_STATUS_NEW;
pub const PIDMSI_STATUS_PRELIM = enum_PIDMSI_STATUS_VALUE.PIDMSI_STATUS_PRELIM;
pub const PIDMSI_STATUS_DRAFT = enum_PIDMSI_STATUS_VALUE.PIDMSI_STATUS_DRAFT;
pub const PIDMSI_STATUS_INPROGRESS = enum_PIDMSI_STATUS_VALUE.PIDMSI_STATUS_INPROGRESS;
pub const PIDMSI_STATUS_EDIT = enum_PIDMSI_STATUS_VALUE.PIDMSI_STATUS_EDIT;
pub const PIDMSI_STATUS_REVIEW = enum_PIDMSI_STATUS_VALUE.PIDMSI_STATUS_REVIEW;
pub const PIDMSI_STATUS_PROOF = enum_PIDMSI_STATUS_VALUE.PIDMSI_STATUS_PROOF;
pub const PIDMSI_STATUS_FINAL = enum_PIDMSI_STATUS_VALUE.PIDMSI_STATUS_FINAL;
pub const PIDMSI_STATUS_OTHER = enum_PIDMSI_STATUS_VALUE.PIDMSI_STATUS_OTHER;
pub const enum_PIDMSI_STATUS_VALUE = extern enum {
    PIDMSI_STATUS_NORMAL = 0,
    PIDMSI_STATUS_NEW = 1,
    PIDMSI_STATUS_PRELIM = 2,
    PIDMSI_STATUS_DRAFT = 3,
    PIDMSI_STATUS_INPROGRESS = 4,
    PIDMSI_STATUS_EDIT = 5,
    PIDMSI_STATUS_REVIEW = 6,
    PIDMSI_STATUS_PROOF = 7,
    PIDMSI_STATUS_FINAL = 8,
    PIDMSI_STATUS_OTHER = 32767,
};
pub const struct_tagSERIALIZEDPROPERTYVALUE = extern struct {
    dwType: DWORD,
    rgb: [1]BYTE,
};
pub const SERIALIZEDPROPERTYVALUE = struct_tagSERIALIZEDPROPERTYVALUE;
pub extern "ole32" fn StgConvertVariantToProperty(pvar: [*c]const PROPVARIANT, CodePage: USHORT, pprop: [*c]SERIALIZEDPROPERTYVALUE, pcb: [*c]ULONG, pid: PROPID, fReserved: BOOLEAN, pcIndirect: [*c]ULONG) callconv(.Stdcall) [*c]SERIALIZEDPROPERTYVALUE;
pub extern var __MIDL_itf_propidl_0000_0004_v0_0_c_ifspec: RPC_IF_HANDLE;
pub extern var __MIDL_itf_propidl_0000_0004_v0_0_s_ifspec: RPC_IF_HANDLE;
pub extern "ole32" fn CreateStdProgressIndicator(hwndParent: HWND, pszTitle: LPCOLESTR, pIbscCaller: [*c]IBindStatusCallback, ppIbsc: [*c]([*c]IBindStatusCallback)) callconv(.Stdcall) HRESULT;
pub extern const IID_StdOle: IID;
pub extern "oleaut32" fn SysAllocString(psz: [*c]const OLECHAR) callconv(.Stdcall) BSTR;
pub extern "oleaut32" fn SysReAllocString(pbstr: [*c]BSTR, psz: [*c]const OLECHAR) callconv(.Stdcall) INT;
pub extern "oleaut32" fn SysAllocStringLen(strIn: [*c]const OLECHAR, ui: UINT) callconv(.Stdcall) BSTR;
pub extern "oleaut32" fn SysReAllocStringLen(pbstr: [*c]BSTR, psz: [*c]const OLECHAR, len: c_uint) callconv(.Stdcall) INT;
pub extern "oleaut32" fn SysAddRefString(bstrString: BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SysReleaseString(bstrString: BSTR) callconv(.Stdcall) void;
pub extern "oleaut32" fn SysFreeString(bstrString: BSTR) callconv(.Stdcall) void;
pub extern "oleaut32" fn SysStringLen(pbstr: BSTR) callconv(.Stdcall) UINT;
pub extern "oleaut32" fn SysStringByteLen(bstr: BSTR) callconv(.Stdcall) UINT;
pub extern "oleaut32" fn SysAllocStringByteLen(psz: LPCSTR, len: UINT) callconv(.Stdcall) BSTR;
pub extern "oleaut32" fn DosDateTimeToVariantTime(wDosDate: USHORT, wDosTime: USHORT, pvtime: [*c]DOUBLE) callconv(.Stdcall) INT;
pub extern "oleaut32" fn VariantTimeToDosDateTime(vtime: DOUBLE, pwDosDate: [*c]USHORT, pwDosTime: [*c]USHORT) callconv(.Stdcall) INT;
pub extern "oleaut32" fn SystemTimeToVariantTime(lpSystemTime: LPSYSTEMTIME, pvtime: [*c]DOUBLE) callconv(.Stdcall) INT;
pub extern "oleaut32" fn VariantTimeToSystemTime(vtime: DOUBLE, lpSystemTime: LPSYSTEMTIME) callconv(.Stdcall) INT;
pub extern "oleaut32" fn SafeArrayAllocDescriptor(cDims: UINT, ppsaOut: [*c]([*c]SAFEARRAY)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayAllocDescriptorEx(vt: VARTYPE, cDims: UINT, ppsaOut: [*c]([*c]SAFEARRAY)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayAllocData(psa: [*c]SAFEARRAY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayCreate(vt: VARTYPE, cDims: UINT, rgsabound: [*c]SAFEARRAYBOUND) callconv(.Stdcall) [*c]SAFEARRAY;
pub extern "oleaut32" fn SafeArrayCreateEx(vt: VARTYPE, cDims: UINT, rgsabound: [*c]SAFEARRAYBOUND, pvExtra: PVOID) callconv(.Stdcall) [*c]SAFEARRAY;
pub extern "oleaut32" fn SafeArrayCopyData(psaSource: [*c]SAFEARRAY, psaTarget: [*c]SAFEARRAY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayReleaseDescriptor(psa: [*c]SAFEARRAY) callconv(.Stdcall) void;
pub extern "oleaut32" fn SafeArrayDestroyDescriptor(psa: [*c]SAFEARRAY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayReleaseData(pData: PVOID) callconv(.Stdcall) void;
pub extern "oleaut32" fn SafeArrayDestroyData(psa: [*c]SAFEARRAY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayAddRef(psa: [*c]SAFEARRAY, ppDataToRelease: [*c]PVOID) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayDestroy(psa: [*c]SAFEARRAY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayRedim(psa: [*c]SAFEARRAY, psaboundNew: [*c]SAFEARRAYBOUND) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayGetDim(psa: [*c]SAFEARRAY) callconv(.Stdcall) UINT;
pub extern "oleaut32" fn SafeArrayGetElemsize(psa: [*c]SAFEARRAY) callconv(.Stdcall) UINT;
pub extern "oleaut32" fn SafeArrayGetUBound(psa: [*c]SAFEARRAY, nDim: UINT, plUbound: [*c]LONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayGetLBound(psa: [*c]SAFEARRAY, nDim: UINT, plLbound: [*c]LONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayLock(psa: [*c]SAFEARRAY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayUnlock(psa: [*c]SAFEARRAY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayAccessData(psa: [*c]SAFEARRAY, ppvData: [*c](?*c_void)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayUnaccessData(psa: [*c]SAFEARRAY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayGetElement(psa: [*c]SAFEARRAY, rgIndices: [*c]LONG, pv: ?*c_void) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayPutElement(psa: [*c]SAFEARRAY, rgIndices: [*c]LONG, pv: ?*c_void) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayCopy(psa: [*c]SAFEARRAY, ppsaOut: [*c]([*c]SAFEARRAY)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayPtrOfIndex(psa: [*c]SAFEARRAY, rgIndices: [*c]LONG, ppvData: [*c](?*c_void)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArraySetRecordInfo(psa: [*c]SAFEARRAY, prinfo: [*c]IRecordInfo) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayGetRecordInfo(psa: [*c]SAFEARRAY, prinfo: [*c]([*c]IRecordInfo)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArraySetIID(psa: [*c]SAFEARRAY, guid: [*c]const GUID) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayGetIID(psa: [*c]SAFEARRAY, pguid: [*c]GUID) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayGetVartype(psa: [*c]SAFEARRAY, pvt: [*c]VARTYPE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SafeArrayCreateVector(vt: VARTYPE, lLbound: LONG, cElements: ULONG) callconv(.Stdcall) [*c]SAFEARRAY;
pub extern "oleaut32" fn SafeArrayCreateVectorEx(vt: VARTYPE, lLbound: LONG, cElements: ULONG, pvExtra: PVOID) callconv(.Stdcall) [*c]SAFEARRAY;
pub extern "oleaut32" fn VariantInit(pvarg: [*c]VARIANTARG) callconv(.Stdcall) void;
pub extern "oleaut32" fn VariantClear(pvarg: [*c]VARIANTARG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VariantCopy(pvargDest: [*c]VARIANTARG, pvargSrc: [*c]const VARIANTARG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VariantCopyInd(pvarDest: [*c]VARIANT, pvargSrc: [*c]const VARIANTARG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VariantChangeType(pvargDest: [*c]VARIANTARG, pvarSrc: [*c]const VARIANTARG, wFlags: USHORT, vt: VARTYPE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VariantChangeTypeEx(pvargDest: [*c]VARIANTARG, pvarSrc: [*c]const VARIANTARG, lcid: LCID, wFlags: USHORT, vt: VARTYPE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VectorFromBstr(bstr: BSTR, ppsa: [*c]([*c]SAFEARRAY)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn BstrFromVector(psa: [*c]SAFEARRAY, pbstr: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI1FromI2(sIn: SHORT, pbOut: [*c]BYTE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI1FromI4(lIn: LONG, pbOut: [*c]BYTE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI1FromI8(i64In: LONG64, pbOut: [*c]BYTE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI1FromR4(fltIn: FLOAT, pbOut: [*c]BYTE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI1FromR8(dblIn: DOUBLE, pbOut: [*c]BYTE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI1FromCy(cyIn: CY, pbOut: [*c]BYTE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI1FromDate(dateIn: DATE, pbOut: [*c]BYTE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI1FromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, pbOut: [*c]BYTE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI1FromDisp(pdispIn: [*c]IDispatch, lcid: LCID, pbOut: [*c]BYTE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI1FromBool(boolIn: VARIANT_BOOL, pbOut: [*c]BYTE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI1FromI1(cIn: CHAR, pbOut: [*c]BYTE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI1FromUI2(uiIn: USHORT, pbOut: [*c]BYTE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI1FromUI4(ulIn: ULONG, pbOut: [*c]BYTE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI1FromUI8(ui64In: ULONG64, pbOut: [*c]BYTE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI1FromDec(pdecIn: [*c]const DECIMAL, pbOut: [*c]BYTE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI2FromUI1(bIn: BYTE, psOut: [*c]SHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI2FromI4(lIn: LONG, psOut: [*c]SHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI2FromI8(i64In: LONG64, psOut: [*c]SHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI2FromR4(fltIn: FLOAT, psOut: [*c]SHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI2FromR8(dblIn: DOUBLE, psOut: [*c]SHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI2FromCy(cyIn: CY, psOut: [*c]SHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI2FromDate(dateIn: DATE, psOut: [*c]SHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI2FromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, psOut: [*c]SHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI2FromDisp(pdispIn: [*c]IDispatch, lcid: LCID, psOut: [*c]SHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI2FromBool(boolIn: VARIANT_BOOL, psOut: [*c]SHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI2FromI1(cIn: CHAR, psOut: [*c]SHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI2FromUI2(uiIn: USHORT, psOut: [*c]SHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI2FromUI4(ulIn: ULONG, psOut: [*c]SHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI2FromUI8(ui64In: ULONG64, psOut: [*c]SHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI2FromDec(pdecIn: [*c]const DECIMAL, psOut: [*c]SHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI4FromUI1(bIn: BYTE, plOut: [*c]LONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI4FromI2(sIn: SHORT, plOut: [*c]LONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI4FromI8(i64In: LONG64, plOut: [*c]LONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI4FromR4(fltIn: FLOAT, plOut: [*c]LONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI4FromR8(dblIn: DOUBLE, plOut: [*c]LONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI4FromCy(cyIn: CY, plOut: [*c]LONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI4FromDate(dateIn: DATE, plOut: [*c]LONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI4FromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, plOut: [*c]LONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI4FromDisp(pdispIn: [*c]IDispatch, lcid: LCID, plOut: [*c]LONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI4FromBool(boolIn: VARIANT_BOOL, plOut: [*c]LONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI4FromI1(cIn: CHAR, plOut: [*c]LONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI4FromUI2(uiIn: USHORT, plOut: [*c]LONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI4FromUI4(ulIn: ULONG, plOut: [*c]LONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI4FromUI8(ui64In: ULONG64, plOut: [*c]LONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI4FromDec(pdecIn: [*c]const DECIMAL, plOut: [*c]LONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI8FromUI1(bIn: BYTE, pi64Out: [*c]LONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI8FromI2(sIn: SHORT, pi64Out: [*c]LONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI8FromR4(fltIn: FLOAT, pi64Out: [*c]LONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI8FromR8(dblIn: DOUBLE, pi64Out: [*c]LONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI8FromCy(cyIn: CY, pi64Out: [*c]LONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI8FromDate(dateIn: DATE, pi64Out: [*c]LONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI8FromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, pi64Out: [*c]LONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI8FromDisp(pdispIn: [*c]IDispatch, lcid: LCID, pi64Out: [*c]LONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI8FromBool(boolIn: VARIANT_BOOL, pi64Out: [*c]LONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI8FromI1(cIn: CHAR, pi64Out: [*c]LONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI8FromUI2(uiIn: USHORT, pi64Out: [*c]LONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI8FromUI4(ulIn: ULONG, pi64Out: [*c]LONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI8FromUI8(ui64In: ULONG64, pi64Out: [*c]LONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI8FromDec(pdecIn: [*c]const DECIMAL, pi64Out: [*c]LONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR4FromUI1(bIn: BYTE, pfltOut: [*c]FLOAT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR4FromI2(sIn: SHORT, pfltOut: [*c]FLOAT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR4FromI4(lIn: LONG, pfltOut: [*c]FLOAT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR4FromI8(i64In: LONG64, pfltOut: [*c]FLOAT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR4FromR8(dblIn: DOUBLE, pfltOut: [*c]FLOAT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR4FromCy(cyIn: CY, pfltOut: [*c]FLOAT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR4FromDate(dateIn: DATE, pfltOut: [*c]FLOAT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR4FromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, pfltOut: [*c]FLOAT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR4FromDisp(pdispIn: [*c]IDispatch, lcid: LCID, pfltOut: [*c]FLOAT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR4FromBool(boolIn: VARIANT_BOOL, pfltOut: [*c]FLOAT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR4FromI1(cIn: CHAR, pfltOut: [*c]FLOAT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR4FromUI2(uiIn: USHORT, pfltOut: [*c]FLOAT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR4FromUI4(ulIn: ULONG, pfltOut: [*c]FLOAT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR4FromUI8(ui64In: ULONG64, pfltOut: [*c]FLOAT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR4FromDec(pdecIn: [*c]const DECIMAL, pfltOut: [*c]FLOAT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR8FromUI1(bIn: BYTE, pdblOut: [*c]DOUBLE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR8FromI2(sIn: SHORT, pdblOut: [*c]DOUBLE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR8FromI4(lIn: LONG, pdblOut: [*c]DOUBLE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR8FromI8(i64In: LONG64, pdblOut: [*c]DOUBLE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR8FromR4(fltIn: FLOAT, pdblOut: [*c]DOUBLE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR8FromCy(cyIn: CY, pdblOut: [*c]DOUBLE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR8FromDate(dateIn: DATE, pdblOut: [*c]DOUBLE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR8FromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, pdblOut: [*c]DOUBLE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR8FromDisp(pdispIn: [*c]IDispatch, lcid: LCID, pdblOut: [*c]DOUBLE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR8FromBool(boolIn: VARIANT_BOOL, pdblOut: [*c]DOUBLE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR8FromI1(cIn: CHAR, pdblOut: [*c]DOUBLE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR8FromUI2(uiIn: USHORT, pdblOut: [*c]DOUBLE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR8FromUI4(ulIn: ULONG, pdblOut: [*c]DOUBLE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR8FromUI8(ui64In: ULONG64, pdblOut: [*c]DOUBLE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR8FromDec(pdecIn: [*c]const DECIMAL, pdblOut: [*c]DOUBLE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDateFromUI1(bIn: BYTE, pdateOut: [*c]DATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDateFromI2(sIn: SHORT, pdateOut: [*c]DATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDateFromI4(lIn: LONG, pdateOut: [*c]DATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDateFromI8(i64In: LONG64, pdateOut: [*c]DATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDateFromR4(fltIn: FLOAT, pdateOut: [*c]DATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDateFromR8(dblIn: DOUBLE, pdateOut: [*c]DATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDateFromCy(cyIn: CY, pdateOut: [*c]DATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDateFromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, pdateOut: [*c]DATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDateFromDisp(pdispIn: [*c]IDispatch, lcid: LCID, pdateOut: [*c]DATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDateFromBool(boolIn: VARIANT_BOOL, pdateOut: [*c]DATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDateFromI1(cIn: CHAR, pdateOut: [*c]DATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDateFromUI2(uiIn: USHORT, pdateOut: [*c]DATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDateFromUI4(ulIn: ULONG, pdateOut: [*c]DATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDateFromUI8(ui64In: ULONG64, pdateOut: [*c]DATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDateFromDec(pdecIn: [*c]const DECIMAL, pdateOut: [*c]DATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyFromUI1(bIn: BYTE, pcyOut: [*c]CY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyFromI2(sIn: SHORT, pcyOut: [*c]CY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyFromI4(lIn: LONG, pcyOut: [*c]CY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyFromI8(i64In: LONG64, pcyOut: [*c]CY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyFromR4(fltIn: FLOAT, pcyOut: [*c]CY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyFromR8(dblIn: DOUBLE, pcyOut: [*c]CY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyFromDate(dateIn: DATE, pcyOut: [*c]CY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyFromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, pcyOut: [*c]CY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyFromDisp(pdispIn: [*c]IDispatch, lcid: LCID, pcyOut: [*c]CY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyFromBool(boolIn: VARIANT_BOOL, pcyOut: [*c]CY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyFromI1(cIn: CHAR, pcyOut: [*c]CY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyFromUI2(uiIn: USHORT, pcyOut: [*c]CY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyFromUI4(ulIn: ULONG, pcyOut: [*c]CY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyFromUI8(ui64In: ULONG64, pcyOut: [*c]CY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyFromDec(pdecIn: [*c]const DECIMAL, pcyOut: [*c]CY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBstrFromUI1(bVal: BYTE, lcid: LCID, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBstrFromI2(iVal: SHORT, lcid: LCID, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBstrFromI4(lIn: LONG, lcid: LCID, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBstrFromI8(i64In: LONG64, lcid: LCID, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBstrFromR4(fltIn: FLOAT, lcid: LCID, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBstrFromR8(dblIn: DOUBLE, lcid: LCID, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBstrFromCy(cyIn: CY, lcid: LCID, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBstrFromDate(dateIn: DATE, lcid: LCID, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBstrFromDisp(pdispIn: [*c]IDispatch, lcid: LCID, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBstrFromBool(boolIn: VARIANT_BOOL, lcid: LCID, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBstrFromI1(cIn: CHAR, lcid: LCID, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBstrFromUI2(uiIn: USHORT, lcid: LCID, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBstrFromUI4(ulIn: ULONG, lcid: LCID, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBstrFromUI8(ui64In: ULONG64, lcid: LCID, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBstrFromDec(pdecIn: [*c]const DECIMAL, lcid: LCID, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBoolFromUI1(bIn: BYTE, pboolOut: [*c]VARIANT_BOOL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBoolFromI2(sIn: SHORT, pboolOut: [*c]VARIANT_BOOL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBoolFromI4(lIn: LONG, pboolOut: [*c]VARIANT_BOOL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBoolFromI8(i64In: LONG64, pboolOut: [*c]VARIANT_BOOL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBoolFromR4(fltIn: FLOAT, pboolOut: [*c]VARIANT_BOOL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBoolFromR8(dblIn: DOUBLE, pboolOut: [*c]VARIANT_BOOL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBoolFromDate(dateIn: DATE, pboolOut: [*c]VARIANT_BOOL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBoolFromCy(cyIn: CY, pboolOut: [*c]VARIANT_BOOL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBoolFromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, pboolOut: [*c]VARIANT_BOOL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBoolFromDisp(pdispIn: [*c]IDispatch, lcid: LCID, pboolOut: [*c]VARIANT_BOOL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBoolFromI1(cIn: CHAR, pboolOut: [*c]VARIANT_BOOL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBoolFromUI2(uiIn: USHORT, pboolOut: [*c]VARIANT_BOOL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBoolFromUI4(ulIn: ULONG, pboolOut: [*c]VARIANT_BOOL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBoolFromUI8(i64In: ULONG64, pboolOut: [*c]VARIANT_BOOL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBoolFromDec(pdecIn: [*c]const DECIMAL, pboolOut: [*c]VARIANT_BOOL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI1FromUI1(bIn: BYTE, pcOut: [*c]CHAR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI1FromI2(uiIn: SHORT, pcOut: [*c]CHAR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI1FromI4(lIn: LONG, pcOut: [*c]CHAR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI1FromI8(i64In: LONG64, pcOut: [*c]CHAR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI1FromR4(fltIn: FLOAT, pcOut: [*c]CHAR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI1FromR8(dblIn: DOUBLE, pcOut: [*c]CHAR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI1FromDate(dateIn: DATE, pcOut: [*c]CHAR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI1FromCy(cyIn: CY, pcOut: [*c]CHAR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI1FromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, pcOut: [*c]CHAR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI1FromDisp(pdispIn: [*c]IDispatch, lcid: LCID, pcOut: [*c]CHAR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI1FromBool(boolIn: VARIANT_BOOL, pcOut: [*c]CHAR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI1FromUI2(uiIn: USHORT, pcOut: [*c]CHAR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI1FromUI4(ulIn: ULONG, pcOut: [*c]CHAR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI1FromUI8(i64In: ULONG64, pcOut: [*c]CHAR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarI1FromDec(pdecIn: [*c]const DECIMAL, pcOut: [*c]CHAR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI2FromUI1(bIn: BYTE, puiOut: [*c]USHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI2FromI2(uiIn: SHORT, puiOut: [*c]USHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI2FromI4(lIn: LONG, puiOut: [*c]USHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI2FromI8(i64In: LONG64, puiOut: [*c]USHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI2FromR4(fltIn: FLOAT, puiOut: [*c]USHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI2FromR8(dblIn: DOUBLE, puiOut: [*c]USHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI2FromDate(dateIn: DATE, puiOut: [*c]USHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI2FromCy(cyIn: CY, puiOut: [*c]USHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI2FromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, puiOut: [*c]USHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI2FromDisp(pdispIn: [*c]IDispatch, lcid: LCID, puiOut: [*c]USHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI2FromBool(boolIn: VARIANT_BOOL, puiOut: [*c]USHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI2FromI1(cIn: CHAR, puiOut: [*c]USHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI2FromUI4(ulIn: ULONG, puiOut: [*c]USHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI2FromUI8(i64In: ULONG64, puiOut: [*c]USHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI2FromDec(pdecIn: [*c]const DECIMAL, puiOut: [*c]USHORT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI4FromUI1(bIn: BYTE, pulOut: [*c]ULONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI4FromI2(uiIn: SHORT, pulOut: [*c]ULONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI4FromI4(lIn: LONG, pulOut: [*c]ULONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI4FromI8(i64In: LONG64, plOut: [*c]ULONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI4FromR4(fltIn: FLOAT, pulOut: [*c]ULONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI4FromR8(dblIn: DOUBLE, pulOut: [*c]ULONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI4FromDate(dateIn: DATE, pulOut: [*c]ULONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI4FromCy(cyIn: CY, pulOut: [*c]ULONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI4FromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, pulOut: [*c]ULONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI4FromDisp(pdispIn: [*c]IDispatch, lcid: LCID, pulOut: [*c]ULONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI4FromBool(boolIn: VARIANT_BOOL, pulOut: [*c]ULONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI4FromI1(cIn: CHAR, pulOut: [*c]ULONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI4FromUI2(uiIn: USHORT, pulOut: [*c]ULONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI4FromUI8(ui64In: ULONG64, plOut: [*c]ULONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI4FromDec(pdecIn: [*c]const DECIMAL, pulOut: [*c]ULONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI8FromUI1(bIn: BYTE, pi64Out: [*c]ULONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI8FromI2(sIn: SHORT, pi64Out: [*c]ULONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI8FromI4(lIn: LONG, pi64Out: [*c]ULONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI8FromI8(ui64In: LONG64, pi64Out: [*c]ULONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI8FromR4(fltIn: FLOAT, pi64Out: [*c]ULONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI8FromR8(dblIn: DOUBLE, pi64Out: [*c]ULONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI8FromCy(cyIn: CY, pi64Out: [*c]ULONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI8FromDate(dateIn: DATE, pi64Out: [*c]ULONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI8FromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, pi64Out: [*c]ULONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI8FromDisp(pdispIn: [*c]IDispatch, lcid: LCID, pi64Out: [*c]ULONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI8FromBool(boolIn: VARIANT_BOOL, pi64Out: [*c]ULONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI8FromI1(cIn: CHAR, pi64Out: [*c]ULONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI8FromUI2(uiIn: USHORT, pi64Out: [*c]ULONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI8FromUI4(ulIn: ULONG, pi64Out: [*c]ULONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUI8FromDec(pdecIn: [*c]const DECIMAL, pi64Out: [*c]ULONG64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecFromUI1(bIn: BYTE, pdecOut: [*c]DECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecFromI2(uiIn: SHORT, pdecOut: [*c]DECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecFromI4(lIn: LONG, pdecOut: [*c]DECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecFromI8(i64In: LONG64, pdecOut: [*c]DECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecFromR4(fltIn: FLOAT, pdecOut: [*c]DECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecFromR8(dblIn: DOUBLE, pdecOut: [*c]DECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecFromDate(dateIn: DATE, pdecOut: [*c]DECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecFromCy(cyIn: CY, pdecOut: [*c]DECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecFromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, pdecOut: [*c]DECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecFromDisp(pdispIn: [*c]IDispatch, lcid: LCID, pdecOut: [*c]DECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecFromBool(boolIn: VARIANT_BOOL, pdecOut: [*c]DECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecFromI1(cIn: CHAR, pdecOut: [*c]DECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecFromUI2(uiIn: USHORT, pdecOut: [*c]DECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecFromUI4(ulIn: ULONG, pdecOut: [*c]DECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecFromUI8(ui64In: ULONG64, pdecOut: [*c]DECIMAL) callconv(.Stdcall) HRESULT;
pub const NUMPARSE = extern struct {
    cDig: INT,
    dwInFlags: ULONG,
    dwOutFlags: ULONG,
    cchUsed: INT,
    nBaseShift: INT,
    nPwr10: INT,
};
pub extern "oleaut32" fn VarParseNumFromStr(strIn: LPCOLESTR, lcid: LCID, dwFlags: ULONG, pnumprs: [*c]NUMPARSE, rgbDig: [*c]BYTE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarNumFromParseNum(pnumprs: [*c]NUMPARSE, rgbDig: [*c]BYTE, dwVtBits: ULONG, pvar: [*c]VARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarAdd(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarAnd(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCat(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDiv(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarEqv(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarIdiv(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarImp(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarMod(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarMul(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarOr(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarPow(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarSub(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarXor(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarAbs(pvarIn: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarFix(pvarIn: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarInt(pvarIn: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarNeg(pvarIn: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarNot(pvarIn: LPVARIANT, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarRound(pvarIn: LPVARIANT, cDecimals: c_int, pvarResult: LPVARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCmp(pvarLeft: LPVARIANT, pvarRight: LPVARIANT, lcid: LCID, dwFlags: ULONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecAdd(pdecLeft: LPDECIMAL, pdecRight: LPDECIMAL, pdecResult: LPDECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecDiv(pdecLeft: LPDECIMAL, pdecRight: LPDECIMAL, pdecResult: LPDECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecMul(pdecLeft: LPDECIMAL, pdecRight: LPDECIMAL, pdecResult: LPDECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecSub(pdecLeft: LPDECIMAL, pdecRight: LPDECIMAL, pdecResult: LPDECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecAbs(pdecIn: LPDECIMAL, pdecResult: LPDECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecFix(pdecIn: LPDECIMAL, pdecResult: LPDECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecInt(pdecIn: LPDECIMAL, pdecResult: LPDECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecNeg(pdecIn: LPDECIMAL, pdecResult: LPDECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecRound(pdecIn: LPDECIMAL, cDecimals: c_int, pdecResult: LPDECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecCmp(pdecLeft: LPDECIMAL, pdecRight: LPDECIMAL) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDecCmpR8(pdecLeft: LPDECIMAL, dblRight: f64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyAdd(cyLeft: CY, cyRight: CY, pcyResult: LPCY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyMul(cyLeft: CY, cyRight: CY, pcyResult: LPCY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyMulI4(cyLeft: CY, lRight: LONG, pcyResult: LPCY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyMulI8(cyLeft: CY, lRight: LONG64, pcyResult: LPCY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCySub(cyLeft: CY, cyRight: CY, pcyResult: LPCY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyAbs(cyIn: CY, pcyResult: LPCY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyFix(cyIn: CY, pcyResult: LPCY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyInt(cyIn: CY, pcyResult: LPCY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyNeg(cyIn: CY, pcyResult: LPCY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyRound(cyIn: CY, cDecimals: c_int, pcyResult: LPCY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyCmp(cyLeft: CY, cyRight: CY) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarCyCmpR8(cyLeft: CY, dblRight: f64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBstrCat(bstrLeft: BSTR, bstrRight: BSTR, pbstrResult: LPBSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarBstrCmp(bstrLeft: BSTR, bstrRight: BSTR, lcid: LCID, dwFlags: ULONG) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR8Pow(dblLeft: f64, dblRight: f64, pdblResult: [*c]f64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR4CmpR8(fltLeft: f32, dblRight: f64) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarR8Round(dblIn: f64, cDecimals: c_int, pdblResult: [*c]f64) callconv(.Stdcall) HRESULT;
pub const UDATE = extern struct {
    st: SYSTEMTIME,
    wDayOfYear: USHORT,
};
pub extern "oleaut32" fn VarDateFromUdate(pudateIn: [*c]UDATE, dwFlags: ULONG, pdateOut: [*c]DATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarDateFromUdateEx(pudateIn: [*c]UDATE, lcid: LCID, dwFlags: ULONG, pdateOut: [*c]DATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarUdateFromDate(dateIn: DATE, dwFlags: ULONG, pudateOut: [*c]UDATE) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn GetAltMonthNames(lcid: LCID, prgp: [*c]([*c]LPOLESTR)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarFormat(pvarIn: LPVARIANT, pstrFormat: LPOLESTR, iFirstDay: c_int, iFirstWeek: c_int, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarFormatDateTime(pvarIn: LPVARIANT, iNamedFormat: c_int, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarFormatNumber(pvarIn: LPVARIANT, iNumDig: c_int, iIncLead: c_int, iUseParens: c_int, iGroup: c_int, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarFormatPercent(pvarIn: LPVARIANT, iNumDig: c_int, iIncLead: c_int, iUseParens: c_int, iGroup: c_int, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarFormatCurrency(pvarIn: LPVARIANT, iNumDig: c_int, iIncLead: c_int, iUseParens: c_int, iGroup: c_int, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarWeekdayName(iWeekday: c_int, fAbbrev: c_int, iFirstDay: c_int, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarMonthName(iMonth: c_int, fAbbrev: c_int, dwFlags: ULONG, pbstrOut: [*c]BSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarFormatFromTokens(pvarIn: LPVARIANT, pstrFormat: LPOLESTR, pbTokCur: LPBYTE, dwFlags: ULONG, pbstrOut: [*c]BSTR, lcid: LCID) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn VarTokenizeFormatString(pstrFormat: LPOLESTR, rgbTok: LPBYTE, cbTok: c_int, iFirstDay: c_int, iFirstWeek: c_int, lcid: LCID, pcbActual: [*c]c_int) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn LHashValOfNameSysA(syskind: SYSKIND, lcid: LCID, szName: LPCSTR) callconv(.Stdcall) ULONG;
pub extern "oleaut32" fn LHashValOfNameSys(syskind: SYSKIND, lcid: LCID, szName: [*c]const OLECHAR) callconv(.Stdcall) ULONG;
pub extern "oleaut32" fn LoadTypeLib(szFile: LPCOLESTR, pptlib: [*c]([*c]ITypeLib)) callconv(.Stdcall) HRESULT;
pub const REGKIND_DEFAULT = enum_tagREGKIND.REGKIND_DEFAULT;
pub const REGKIND_REGISTER = enum_tagREGKIND.REGKIND_REGISTER;
pub const REGKIND_NONE = enum_tagREGKIND.REGKIND_NONE;
pub const enum_tagREGKIND = extern enum {
    REGKIND_DEFAULT,
    REGKIND_REGISTER,
    REGKIND_NONE,
};
pub const REGKIND = enum_tagREGKIND;
pub extern "oleaut32" fn LoadTypeLibEx(szFile: LPCOLESTR, regkind: REGKIND, pptlib: [*c]([*c]ITypeLib)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn LoadRegTypeLib(rguid: [*c]const GUID, wVerMajor: WORD, wVerMinor: WORD, lcid: LCID, pptlib: [*c]([*c]ITypeLib)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn QueryPathOfRegTypeLib(guid: [*c]const GUID, wMaj: USHORT, wMin: USHORT, lcid: LCID, lpbstrPathName: LPBSTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn RegisterTypeLib(ptlib: [*c]ITypeLib, szFullPath: LPCOLESTR, szHelpDir: LPCOLESTR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn UnRegisterTypeLib(libID: [*c]const GUID, wVerMajor: WORD, wVerMinor: WORD, lcid: LCID, syskind: SYSKIND) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn RegisterTypeLibForUser(ptlib: [*c]ITypeLib, szFullPath: [*c]OLECHAR, szHelpDir: [*c]OLECHAR) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn UnRegisterTypeLibForUser(libID: [*c]const GUID, wMajorVerNum: WORD, wMinorVerNum: WORD, lcid: LCID, syskind: SYSKIND) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn CreateTypeLib(syskind: SYSKIND, szFile: LPCOLESTR, ppctlib: [*c]([*c]ICreateTypeLib)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn CreateTypeLib2(syskind: SYSKIND, szFile: LPCOLESTR, ppctlib: [*c]([*c]ICreateTypeLib2)) callconv(.Stdcall) HRESULT;
pub const struct_tagPARAMDATA = extern struct {
    szName: [*c]OLECHAR,
    vt: VARTYPE,
};
pub const PARAMDATA = struct_tagPARAMDATA;
pub const LPPARAMDATA = [*c]struct_tagPARAMDATA;
pub const struct_tagMETHODDATA = extern struct {
    szName: [*c]OLECHAR,
    ppdata: [*c]PARAMDATA,
    dispid: DISPID,
    iMeth: UINT,
    cc: CALLCONV,
    cArgs: UINT,
    wFlags: WORD,
    vtReturn: VARTYPE,
};
pub const METHODDATA = struct_tagMETHODDATA;
pub const LPMETHODDATA = [*c]struct_tagMETHODDATA;
pub const struct_tagINTERFACEDATA = extern struct {
    pmethdata: [*c]METHODDATA,
    cMembers: UINT,
};
pub const INTERFACEDATA = struct_tagINTERFACEDATA;
pub const LPINTERFACEDATA = [*c]struct_tagINTERFACEDATA;
pub extern "oleaut32" fn DispGetParam(pdispparams: [*c]DISPPARAMS, position: UINT, vtTarg: VARTYPE, pvarResult: [*c]VARIANT, puArgErr: [*c]UINT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn DispGetIDsOfNames(ptinfo: [*c]ITypeInfo, rgszNames: [*c]LPOLESTR, cNames: UINT, rgdispid: [*c]DISPID) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn DispInvoke(_this: ?*c_void, ptinfo: [*c]ITypeInfo, dispidMember: DISPID, wFlags: WORD, pparams: [*c]DISPPARAMS, pvarResult: [*c]VARIANT, pexcepinfo: [*c]EXCEPINFO, puArgErr: [*c]UINT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn CreateDispTypeInfo(pidata: [*c]INTERFACEDATA, lcid: LCID, pptinfo: [*c]([*c]ITypeInfo)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn CreateStdDispatch(punkOuter: [*c]IUnknown, pvThis: ?*c_void, ptinfo: [*c]ITypeInfo, ppunkStdDisp: [*c]([*c]IUnknown)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn DispCallFunc(pvInstance: ?*c_void, oVft: ULONG_PTR, cc: CALLCONV, vtReturn: VARTYPE, cActuals: UINT, prgvt: [*c]VARTYPE, prgpvarg: [*c]([*c]VARIANTARG), pvargResult: [*c]VARIANT) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn RegisterActiveObject(punk: [*c]IUnknown, rclsid: [*c]const IID, dwFlags: DWORD, pdwRegister: [*c]DWORD) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn RevokeActiveObject(dwRegister: DWORD, pvReserved: ?*c_void) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn GetActiveObject(rclsid: [*c]const IID, pvReserved: ?*c_void, ppunk: [*c]([*c]IUnknown)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn SetErrorInfo(dwReserved: ULONG, perrinfo: [*c]IErrorInfo) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn GetErrorInfo(dwReserved: ULONG, pperrinfo: [*c]([*c]IErrorInfo)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn CreateErrorInfo(pperrinfo: [*c]([*c]ICreateErrorInfo)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn GetRecordInfoFromTypeInfo(pTypeInfo: [*c]ITypeInfo, ppRecInfo: [*c]([*c]IRecordInfo)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn GetRecordInfoFromGuids(rGuidTypeLib: [*c]const GUID, uVerMajor: ULONG, uVerMinor: ULONG, lcid: LCID, rGuidTypeInfo: [*c]const GUID, ppRecInfo: [*c]([*c]IRecordInfo)) callconv(.Stdcall) HRESULT;
pub extern "oleaut32" fn OaBuildVersion() callconv(.Stdcall) ULONG;
pub extern "oleaut32" fn ClearCustData(pCustData: LPCUSTDATA) callconv(.Stdcall) void;
pub extern "oleaut32" fn OaEnablePerUserTLibRegistration() callconv(.Stdcall) void;
pub extern "ole32" fn OleBuildVersion() callconv(.Stdcall) DWORD;
pub extern "ole32" fn WriteFmtUserTypeStg(pstg: LPSTORAGE, cf: CLIPFORMAT, lpszUserType: LPOLESTR) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn ReadFmtUserTypeStg(pstg: LPSTORAGE, pcf: [*c]CLIPFORMAT, lplpszUserType: [*c]LPOLESTR) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleInitialize(pvReserved: LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleUninitialize() callconv(.Stdcall) void;
pub extern "ole32" fn OleQueryLinkFromData(pSrcDataObject: LPDATAOBJECT) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleQueryCreateFromData(pSrcDataObject: LPDATAOBJECT) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleCreate(rclsid: [*c]const IID, riid: [*c]const IID, renderopt: DWORD, pFormatEtc: LPFORMATETC, pClientSite: LPOLECLIENTSITE, pStg: LPSTORAGE, ppvObj: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleCreateEx(rclsid: [*c]const IID, riid: [*c]const IID, dwFlags: DWORD, renderopt: DWORD, cFormats: ULONG, rgAdvf: [*c]DWORD, rgFormatEtc: LPFORMATETC, lpAdviseSink: [*c]IAdviseSink, rgdwConnection: [*c]DWORD, pClientSite: LPOLECLIENTSITE, pStg: LPSTORAGE, ppvObj: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleCreateFromData(pSrcDataObj: LPDATAOBJECT, riid: [*c]const IID, renderopt: DWORD, pFormatEtc: LPFORMATETC, pClientSite: LPOLECLIENTSITE, pStg: LPSTORAGE, ppvObj: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleCreateFromDataEx(pSrcDataObj: LPDATAOBJECT, riid: [*c]const IID, dwFlags: DWORD, renderopt: DWORD, cFormats: ULONG, rgAdvf: [*c]DWORD, rgFormatEtc: LPFORMATETC, lpAdviseSink: [*c]IAdviseSink, rgdwConnection: [*c]DWORD, pClientSite: LPOLECLIENTSITE, pStg: LPSTORAGE, ppvObj: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleCreateLinkFromData(pSrcDataObj: LPDATAOBJECT, riid: [*c]const IID, renderopt: DWORD, pFormatEtc: LPFORMATETC, pClientSite: LPOLECLIENTSITE, pStg: LPSTORAGE, ppvObj: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleCreateLinkFromDataEx(pSrcDataObj: LPDATAOBJECT, riid: [*c]const IID, dwFlags: DWORD, renderopt: DWORD, cFormats: ULONG, rgAdvf: [*c]DWORD, rgFormatEtc: LPFORMATETC, lpAdviseSink: [*c]IAdviseSink, rgdwConnection: [*c]DWORD, pClientSite: LPOLECLIENTSITE, pStg: LPSTORAGE, ppvObj: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleCreateStaticFromData(pSrcDataObj: LPDATAOBJECT, iid: [*c]const IID, renderopt: DWORD, pFormatEtc: LPFORMATETC, pClientSite: LPOLECLIENTSITE, pStg: LPSTORAGE, ppvObj: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleCreateLink(pmkLinkSrc: LPMONIKER, riid: [*c]const IID, renderopt: DWORD, lpFormatEtc: LPFORMATETC, pClientSite: LPOLECLIENTSITE, pStg: LPSTORAGE, ppvObj: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleCreateLinkEx(pmkLinkSrc: LPMONIKER, riid: [*c]const IID, dwFlags: DWORD, renderopt: DWORD, cFormats: ULONG, rgAdvf: [*c]DWORD, rgFormatEtc: LPFORMATETC, lpAdviseSink: [*c]IAdviseSink, rgdwConnection: [*c]DWORD, pClientSite: LPOLECLIENTSITE, pStg: LPSTORAGE, ppvObj: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleCreateLinkToFile(lpszFileName: LPCOLESTR, riid: [*c]const IID, renderopt: DWORD, lpFormatEtc: LPFORMATETC, pClientSite: LPOLECLIENTSITE, pStg: LPSTORAGE, ppvObj: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleCreateLinkToFileEx(lpszFileName: LPCOLESTR, riid: [*c]const IID, dwFlags: DWORD, renderopt: DWORD, cFormats: ULONG, rgAdvf: [*c]DWORD, rgFormatEtc: LPFORMATETC, lpAdviseSink: [*c]IAdviseSink, rgdwConnection: [*c]DWORD, pClientSite: LPOLECLIENTSITE, pStg: LPSTORAGE, ppvObj: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleCreateFromFile(rclsid: [*c]const IID, lpszFileName: LPCOLESTR, riid: [*c]const IID, renderopt: DWORD, lpFormatEtc: LPFORMATETC, pClientSite: LPOLECLIENTSITE, pStg: LPSTORAGE, ppvObj: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleCreateFromFileEx(rclsid: [*c]const IID, lpszFileName: LPCOLESTR, riid: [*c]const IID, dwFlags: DWORD, renderopt: DWORD, cFormats: ULONG, rgAdvf: [*c]DWORD, rgFormatEtc: LPFORMATETC, lpAdviseSink: [*c]IAdviseSink, rgdwConnection: [*c]DWORD, pClientSite: LPOLECLIENTSITE, pStg: LPSTORAGE, ppvObj: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleLoad(pStg: LPSTORAGE, riid: [*c]const IID, pClientSite: LPOLECLIENTSITE, ppvObj: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleSave(pPS: LPPERSISTSTORAGE, pStg: LPSTORAGE, fSameAsLoad: BOOL) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleLoadFromStream(pStm: LPSTREAM, iidInterface: [*c]const IID, ppvObj: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleSaveToStream(pPStm: LPPERSISTSTREAM, pStm: LPSTREAM) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleSetContainedObject(pUnknown: LPUNKNOWN, fContained: BOOL) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleNoteObjectVisible(pUnknown: LPUNKNOWN, fVisible: BOOL) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn RegisterDragDrop(hwnd: HWND, pDropTarget: LPDROPTARGET) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn RevokeDragDrop(hwnd: HWND) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn DoDragDrop(pDataObj: LPDATAOBJECT, pDropSource: LPDROPSOURCE, dwOKEffects: DWORD, pdwEffect: LPDWORD) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleSetClipboard(pDataObj: LPDATAOBJECT) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleGetClipboard(ppDataObj: [*c]LPDATAOBJECT) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleGetClipboardWithEnterpriseInfo(dataObject: [*c]([*c]IDataObject), dataEnterpriseId: [*c]PWSTR, sourceDescription: [*c]PWSTR, targetDescription: [*c]PWSTR, dataDescription: [*c]PWSTR) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleFlushClipboard() callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleIsCurrentClipboard(pDataObj: LPDATAOBJECT) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleCreateMenuDescriptor(hmenuCombined: HMENU, lpMenuWidths: LPOLEMENUGROUPWIDTHS) callconv(.Stdcall) HOLEMENU;
pub extern "ole32" fn OleSetMenuDescriptor(holemenu: HOLEMENU, hwndFrame: HWND, hwndActiveObject: HWND, lpFrame: LPOLEINPLACEFRAME, lpActiveObj: LPOLEINPLACEACTIVEOBJECT) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleDestroyMenuDescriptor(holemenu: HOLEMENU) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleTranslateAccelerator(lpFrame: LPOLEINPLACEFRAME, lpFrameInfo: LPOLEINPLACEFRAMEINFO, lpmsg: LPMSG) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleDuplicateData(hSrc: HANDLE, cfFormat: CLIPFORMAT, uiFlags: UINT) callconv(.Stdcall) HANDLE;
pub extern "ole32" fn OleDraw(pUnknown: LPUNKNOWN, dwAspect: DWORD, hdcDraw: HDC, lprcBounds: LPCRECT) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleRun(pUnknown: LPUNKNOWN) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleIsRunning(pObject: LPOLEOBJECT) callconv(.Stdcall) BOOL;
pub extern "ole32" fn OleLockRunning(pUnknown: LPUNKNOWN, fLock: BOOL, fLastUnlockCloses: BOOL) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn ReleaseStgMedium(arg0: LPSTGMEDIUM) callconv(.Stdcall) void;
pub extern "ole32" fn CreateOleAdviseHolder(ppOAHolder: [*c]LPOLEADVISEHOLDER) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleCreateDefaultHandler(clsid: [*c]const IID, pUnkOuter: LPUNKNOWN, riid: [*c]const IID, lplpObj: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleCreateEmbeddingHelper(clsid: [*c]const IID, pUnkOuter: LPUNKNOWN, flags: DWORD, pCF: LPCLASSFACTORY, riid: [*c]const IID, lplpObj: [*c]LPVOID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn IsAccelerator(hAccel: HACCEL, cAccelEntries: c_int, lpMsg: LPMSG, lpwCmd: [*c]WORD) callconv(.Stdcall) BOOL;
pub extern "ole32" fn OleGetIconOfFile(lpszPath: LPOLESTR, fUseFileAsLabel: BOOL) callconv(.Stdcall) HGLOBAL;
pub extern "ole32" fn OleGetIconOfClass(rclsid: [*c]const IID, lpszLabel: LPOLESTR, fUseTypeAsLabel: BOOL) callconv(.Stdcall) HGLOBAL;
pub extern "ole32" fn OleMetafilePictFromIconAndLabel(hIcon: HICON, lpszLabel: LPOLESTR, lpszSourceFile: LPOLESTR, iIconIndex: UINT) callconv(.Stdcall) HGLOBAL;
pub extern "ole32" fn OleRegGetUserType(clsid: [*c]const IID, dwFormOfType: DWORD, pszUserType: [*c]LPOLESTR) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleRegGetMiscStatus(clsid: [*c]const IID, dwAspect: DWORD, pdwStatus: [*c]DWORD) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleRegEnumFormatEtc(clsid: [*c]const IID, dwDirection: DWORD, ppenum: [*c]LPENUMFORMATETC) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleRegEnumVerbs(clsid: [*c]const IID, ppenum: [*c]LPENUMOLEVERB) callconv(.Stdcall) HRESULT;
pub const LPOLESTREAM = [*c]struct__OLESTREAM;
pub const struct__OLESTREAMVTBL = extern struct {
    Get: ?fn (LPOLESTREAM, ?*c_void, DWORD) callconv(.C) DWORD,
    Put: ?fn (LPOLESTREAM, ?*const c_void, DWORD) callconv(.C) DWORD,
};
pub const OLESTREAMVTBL = struct__OLESTREAMVTBL;
pub const LPOLESTREAMVTBL = [*c]OLESTREAMVTBL;
pub const struct__OLESTREAM = extern struct {
    lpstbl: LPOLESTREAMVTBL,
};
pub const OLESTREAM = struct__OLESTREAM;
pub extern "ole32" fn OleConvertOLESTREAMToIStorage(lpolestream: LPOLESTREAM, pstg: LPSTORAGE, ptd: [*c]const DVTARGETDEVICE) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleConvertIStorageToOLESTREAM(pstg: LPSTORAGE, lpolestream: LPOLESTREAM) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleDoAutoConvert(pStg: LPSTORAGE, pClsidNew: LPCLSID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleGetAutoConvert(clsidOld: [*c]const IID, pClsidNew: LPCLSID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleSetAutoConvert(clsidOld: [*c]const IID, clsidNew: [*c]const IID) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn SetConvertStg(pStg: LPSTORAGE, fConvert: BOOL) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleConvertIStorageToOLESTREAMEx(pstg: LPSTORAGE, cfFormat: CLIPFORMAT, lWidth: LONG, lHeight: LONG, dwSize: DWORD, pmedium: LPSTGMEDIUM, polestm: LPOLESTREAM) callconv(.Stdcall) HRESULT;
pub extern "ole32" fn OleConvertOLESTREAMToIStorageEx(polestm: LPOLESTREAM, pstg: LPSTORAGE, pcfFormat: [*c]CLIPFORMAT, plwWidth: [*c]LONG, plHeight: [*c]LONG, pdwSize: [*c]DWORD, pmedium: LPSTGMEDIUM) callconv(.Stdcall) HRESULT;
pub extern const IID_IPrintDialogCallback: GUID;
pub extern const IID_IPrintDialogServices: GUID;
pub const LPOFNHOOKPROC = ?fn (HWND, UINT, WPARAM, LPARAM) callconv(.C) UINT_PTR;
pub const struct_tagOFN_NT4A = extern struct {
    lStructSize: DWORD,
    hwndOwner: HWND,
    hInstance: HINSTANCE,
    lpstrFilter: LPCSTR,
    lpstrCustomFilter: LPSTR,
    nMaxCustFilter: DWORD,
    nFilterIndex: DWORD,
    lpstrFile: LPSTR,
    nMaxFile: DWORD,
    lpstrFileTitle: LPSTR,
    nMaxFileTitle: DWORD,
    lpstrInitialDir: LPCSTR,
    lpstrTitle: LPCSTR,
    Flags: DWORD,
    nFileOffset: WORD,
    nFileExtension: WORD,
    lpstrDefExt: LPCSTR,
    lCustData: LPARAM,
    lpfnHook: LPOFNHOOKPROC,
    lpTemplateName: LPCSTR,
};
pub const OPENFILENAME_NT4A = struct_tagOFN_NT4A;
pub const LPOPENFILENAME_NT4A = [*c]struct_tagOFN_NT4A;
pub const struct_tagOFN_NT4W = extern struct {
    lStructSize: DWORD,
    hwndOwner: HWND,
    hInstance: HINSTANCE,
    lpstrFilter: LPCWSTR,
    lpstrCustomFilter: LPWSTR,
    nMaxCustFilter: DWORD,
    nFilterIndex: DWORD,
    lpstrFile: LPWSTR,
    nMaxFile: DWORD,
    lpstrFileTitle: LPWSTR,
    nMaxFileTitle: DWORD,
    lpstrInitialDir: LPCWSTR,
    lpstrTitle: LPCWSTR,
    Flags: DWORD,
    nFileOffset: WORD,
    nFileExtension: WORD,
    lpstrDefExt: LPCWSTR,
    lCustData: LPARAM,
    lpfnHook: LPOFNHOOKPROC,
    lpTemplateName: LPCWSTR,
};
pub const OPENFILENAME_NT4W = struct_tagOFN_NT4W;
pub const LPOPENFILENAME_NT4W = [*c]struct_tagOFN_NT4W;
pub const OPENFILENAME_NT4 = OPENFILENAME_NT4A;
pub const LPOPENFILENAME_NT4 = LPOPENFILENAME_NT4A;
pub const struct_tagOFNA = extern struct {
    lStructSize: DWORD,
    hwndOwner: HWND,
    hInstance: HINSTANCE,
    lpstrFilter: LPCSTR,
    lpstrCustomFilter: LPSTR,
    nMaxCustFilter: DWORD,
    nFilterIndex: DWORD,
    lpstrFile: LPSTR,
    nMaxFile: DWORD,
    lpstrFileTitle: LPSTR,
    nMaxFileTitle: DWORD,
    lpstrInitialDir: LPCSTR,
    lpstrTitle: LPCSTR,
    Flags: DWORD,
    nFileOffset: WORD,
    nFileExtension: WORD,
    lpstrDefExt: LPCSTR,
    lCustData: LPARAM,
    lpfnHook: LPOFNHOOKPROC,
    lpTemplateName: LPCSTR,
    pvReserved: ?*c_void,
    dwReserved: DWORD,
    FlagsEx: DWORD,
};
pub const OPENFILENAMEA = struct_tagOFNA;
pub const LPOPENFILENAMEA = [*c]struct_tagOFNA;
pub const struct_tagOFNW = extern struct {
    lStructSize: DWORD,
    hwndOwner: HWND,
    hInstance: HINSTANCE,
    lpstrFilter: LPCWSTR,
    lpstrCustomFilter: LPWSTR,
    nMaxCustFilter: DWORD,
    nFilterIndex: DWORD,
    lpstrFile: LPWSTR,
    nMaxFile: DWORD,
    lpstrFileTitle: LPWSTR,
    nMaxFileTitle: DWORD,
    lpstrInitialDir: LPCWSTR,
    lpstrTitle: LPCWSTR,
    Flags: DWORD,
    nFileOffset: WORD,
    nFileExtension: WORD,
    lpstrDefExt: LPCWSTR,
    lCustData: LPARAM,
    lpfnHook: LPOFNHOOKPROC,
    lpTemplateName: LPCWSTR,
    pvReserved: ?*c_void,
    dwReserved: DWORD,
    FlagsEx: DWORD,
};
pub const OPENFILENAMEW = struct_tagOFNW;
pub const LPOPENFILENAMEW = [*c]struct_tagOFNW;
pub const OPENFILENAME = OPENFILENAMEA;
pub const LPOPENFILENAME = LPOPENFILENAMEA;
pub extern "comdlg32" fn GetOpenFileNameA(arg0: LPOPENFILENAMEA) callconv(.Stdcall) BOOL;
pub extern "comdlg32" fn GetOpenFileNameW(arg0: LPOPENFILENAMEW) callconv(.Stdcall) BOOL;
pub extern "comdlg32" fn GetSaveFileNameA(arg0: LPOPENFILENAMEA) callconv(.Stdcall) BOOL;
pub extern "comdlg32" fn GetSaveFileNameW(arg0: LPOPENFILENAMEW) callconv(.Stdcall) BOOL;
pub extern "comdlg32" fn GetFileTitleA(arg0: LPCSTR, Buf: LPSTR, cchSize: WORD) callconv(.Stdcall) c_short;
pub extern "comdlg32" fn GetFileTitleW(arg0: LPCWSTR, Buf: LPWSTR, cchSize: WORD) callconv(.Stdcall) c_short;
pub const LPCCHOOKPROC = ?fn (HWND, UINT, WPARAM, LPARAM) callconv(.C) UINT_PTR;
pub const struct__OFNOTIFYA = extern struct {
    hdr: NMHDR,
    lpOFN: LPOPENFILENAMEA,
    pszFile: LPSTR,
};
pub const OFNOTIFYA = struct__OFNOTIFYA;
pub const LPOFNOTIFYA = [*c]struct__OFNOTIFYA;
pub const struct__OFNOTIFYW = extern struct {
    hdr: NMHDR,
    lpOFN: LPOPENFILENAMEW,
    pszFile: LPWSTR,
};
pub const OFNOTIFYW = struct__OFNOTIFYW;
pub const LPOFNOTIFYW = [*c]struct__OFNOTIFYW;
pub const OFNOTIFY = OFNOTIFYA;
pub const LPOFNOTIFY = LPOFNOTIFYA;
pub const struct__OFNOTIFYEXA = extern struct {
    hdr: NMHDR,
    lpOFN: LPOPENFILENAMEA,
    psf: LPVOID,
    pidl: LPVOID,
};
pub const OFNOTIFYEXA = struct__OFNOTIFYEXA;
pub const LPOFNOTIFYEXA = [*c]struct__OFNOTIFYEXA;
pub const struct__OFNOTIFYEXW = extern struct {
    hdr: NMHDR,
    lpOFN: LPOPENFILENAMEW,
    psf: LPVOID,
    pidl: LPVOID,
};
pub const OFNOTIFYEXW = struct__OFNOTIFYEXW;
pub const LPOFNOTIFYEXW = [*c]struct__OFNOTIFYEXW;
pub const OFNOTIFYEX = OFNOTIFYEXA;
pub const LPOFNOTIFYEX = LPOFNOTIFYEXA;
pub const struct_tagCHOOSECOLORA = extern struct {
    lStructSize: DWORD,
    hwndOwner: HWND,
    hInstance: HWND,
    rgbResult: COLORREF,
    lpCustColors: [*c]COLORREF,
    Flags: DWORD,
    lCustData: LPARAM,
    lpfnHook: LPCCHOOKPROC,
    lpTemplateName: LPCSTR,
};
pub const CHOOSECOLORA = struct_tagCHOOSECOLORA;
pub const LPCHOOSECOLORA = [*c]struct_tagCHOOSECOLORA;
pub const struct_tagCHOOSECOLORW = extern struct {
    lStructSize: DWORD,
    hwndOwner: HWND,
    hInstance: HWND,
    rgbResult: COLORREF,
    lpCustColors: [*c]COLORREF,
    Flags: DWORD,
    lCustData: LPARAM,
    lpfnHook: LPCCHOOKPROC,
    lpTemplateName: LPCWSTR,
};
pub const CHOOSECOLORW = struct_tagCHOOSECOLORW;
pub const LPCHOOSECOLORW = [*c]struct_tagCHOOSECOLORW;
pub const CHOOSECOLOR = CHOOSECOLORA;
pub const LPCHOOSECOLOR = LPCHOOSECOLORA;
pub extern "comdlg32" fn ChooseColorA(arg0: LPCHOOSECOLORA) callconv(.Stdcall) BOOL;
pub extern "comdlg32" fn ChooseColorW(arg0: LPCHOOSECOLORW) callconv(.Stdcall) BOOL;
pub const LPFRHOOKPROC = ?fn (HWND, UINT, WPARAM, LPARAM) callconv(.C) UINT_PTR;
pub const struct_tagFINDREPLACEA = extern struct {
    lStructSize: DWORD,
    hwndOwner: HWND,
    hInstance: HINSTANCE,
    Flags: DWORD,
    lpstrFindWhat: LPSTR,
    lpstrReplaceWith: LPSTR,
    wFindWhatLen: WORD,
    wReplaceWithLen: WORD,
    lCustData: LPARAM,
    lpfnHook: LPFRHOOKPROC,
    lpTemplateName: LPCSTR,
};
pub const FINDREPLACEA = struct_tagFINDREPLACEA;
pub const LPFINDREPLACEA = [*c]struct_tagFINDREPLACEA;
pub const struct_tagFINDREPLACEW = extern struct {
    lStructSize: DWORD,
    hwndOwner: HWND,
    hInstance: HINSTANCE,
    Flags: DWORD,
    lpstrFindWhat: LPWSTR,
    lpstrReplaceWith: LPWSTR,
    wFindWhatLen: WORD,
    wReplaceWithLen: WORD,
    lCustData: LPARAM,
    lpfnHook: LPFRHOOKPROC,
    lpTemplateName: LPCWSTR,
};
pub const FINDREPLACEW = struct_tagFINDREPLACEW;
pub const LPFINDREPLACEW = [*c]struct_tagFINDREPLACEW;
pub const FINDREPLACE = FINDREPLACEA;
pub const LPFINDREPLACE = LPFINDREPLACEA;
pub extern "comdlg32" fn FindTextA(arg0: LPFINDREPLACEA) callconv(.Stdcall) HWND;
pub extern "comdlg32" fn FindTextW(arg0: LPFINDREPLACEW) callconv(.Stdcall) HWND;
pub extern "comdlg32" fn ReplaceTextA(arg0: LPFINDREPLACEA) callconv(.Stdcall) HWND;
pub extern "comdlg32" fn ReplaceTextW(arg0: LPFINDREPLACEW) callconv(.Stdcall) HWND;
pub const LPCFHOOKPROC = ?fn (HWND, UINT, WPARAM, LPARAM) callconv(.C) UINT_PTR;
pub const struct_tagCHOOSEFONTA = extern struct {
    lStructSize: DWORD,
    hwndOwner: HWND,
    hDC: HDC,
    lpLogFont: LPLOGFONTA,
    iPointSize: INT,
    Flags: DWORD,
    rgbColors: COLORREF,
    lCustData: LPARAM,
    lpfnHook: LPCFHOOKPROC,
    lpTemplateName: LPCSTR,
    hInstance: HINSTANCE,
    lpszStyle: LPSTR,
    nFontType: WORD,
    ___MISSING_ALIGNMENT__: WORD,
    nSizeMin: INT,
    nSizeMax: INT,
};
pub const CHOOSEFONTA = struct_tagCHOOSEFONTA;
pub const struct_tagCHOOSEFONTW = extern struct {
    lStructSize: DWORD,
    hwndOwner: HWND,
    hDC: HDC,
    lpLogFont: LPLOGFONTW,
    iPointSize: INT,
    Flags: DWORD,
    rgbColors: COLORREF,
    lCustData: LPARAM,
    lpfnHook: LPCFHOOKPROC,
    lpTemplateName: LPCWSTR,
    hInstance: HINSTANCE,
    lpszStyle: LPWSTR,
    nFontType: WORD,
    ___MISSING_ALIGNMENT__: WORD,
    nSizeMin: INT,
    nSizeMax: INT,
};
pub const CHOOSEFONTW = struct_tagCHOOSEFONTW;
pub const CHOOSEFONT = CHOOSEFONTA;
pub const LPCHOOSEFONTA = [*c]CHOOSEFONTA;
pub const LPCHOOSEFONTW = [*c]CHOOSEFONTW;
pub const LPCHOOSEFONT = LPCHOOSEFONTA;
pub const PCCHOOSEFONTA = [*c]const CHOOSEFONTA;
pub const PCCHOOSEFONTW = [*c]const CHOOSEFONTW;
pub const PCCHOOSEFONT = PCCHOOSEFONTA;
pub extern "comdlg32" fn ChooseFontA(arg0: LPCHOOSEFONTA) callconv(.Stdcall) BOOL;
pub extern "comdlg32" fn ChooseFontW(arg0: LPCHOOSEFONTW) callconv(.Stdcall) BOOL;
pub const LPPRINTHOOKPROC = ?fn (HWND, UINT, WPARAM, LPARAM) callconv(.C) UINT_PTR;
pub const LPSETUPHOOKPROC = ?fn (HWND, UINT, WPARAM, LPARAM) callconv(.C) UINT_PTR;
pub const struct_tagPDA = extern struct {
    lStructSize: DWORD,
    hwndOwner: HWND,
    hDevMode: HGLOBAL,
    hDevNames: HGLOBAL,
    hDC: HDC,
    Flags: DWORD,
    nFromPage: WORD,
    nToPage: WORD,
    nMinPage: WORD,
    nMaxPage: WORD,
    nCopies: WORD,
    hInstance: HINSTANCE,
    lCustData: LPARAM,
    lpfnPrintHook: LPPRINTHOOKPROC,
    lpfnSetupHook: LPSETUPHOOKPROC,
    lpPrintTemplateName: LPCSTR,
    lpSetupTemplateName: LPCSTR,
    hPrintTemplate: HGLOBAL,
    hSetupTemplate: HGLOBAL,
};
pub const PRINTDLGA = struct_tagPDA;
pub const LPPRINTDLGA = [*c]struct_tagPDA;
pub const struct_tagPDW = extern struct {
    lStructSize: DWORD,
    hwndOwner: HWND,
    hDevMode: HGLOBAL,
    hDevNames: HGLOBAL,
    hDC: HDC,
    Flags: DWORD,
    nFromPage: WORD,
    nToPage: WORD,
    nMinPage: WORD,
    nMaxPage: WORD,
    nCopies: WORD,
    hInstance: HINSTANCE,
    lCustData: LPARAM,
    lpfnPrintHook: LPPRINTHOOKPROC,
    lpfnSetupHook: LPSETUPHOOKPROC,
    lpPrintTemplateName: LPCWSTR,
    lpSetupTemplateName: LPCWSTR,
    hPrintTemplate: HGLOBAL,
    hSetupTemplate: HGLOBAL,
};
pub const PRINTDLGW = struct_tagPDW;
pub const LPPRINTDLGW = [*c]struct_tagPDW;
pub const PRINTDLG = PRINTDLGA;
pub const LPPRINTDLG = LPPRINTDLGA;
pub extern "comdlg32" fn PrintDlgA(pPD: LPPRINTDLGA) callconv(.Stdcall) BOOL;
pub extern "comdlg32" fn PrintDlgW(pPD: LPPRINTDLGW) callconv(.Stdcall) BOOL;
pub const IPrintDialogCallback = struct_IPrintDialogCallback;
pub const struct_IPrintDialogCallbackVtbl = extern struct {
    QueryInterface: ?fn ([*c]IPrintDialogCallback, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IPrintDialogCallback) callconv(.C) ULONG,
    Release: ?fn ([*c]IPrintDialogCallback) callconv(.C) ULONG,
    InitDone: ?fn ([*c]IPrintDialogCallback) callconv(.C) HRESULT,
    SelectionChange: ?fn ([*c]IPrintDialogCallback) callconv(.C) HRESULT,
    HandleMessage: ?fn ([*c]IPrintDialogCallback, HWND, UINT, WPARAM, LPARAM, [*c]LRESULT) callconv(.C) HRESULT,
};
pub const struct_IPrintDialogCallback = extern struct {
    lpVtbl: [*c]struct_IPrintDialogCallbackVtbl,
};
pub const IPrintDialogCallbackVtbl = struct_IPrintDialogCallbackVtbl;
pub const IPrintDialogServices = struct_IPrintDialogServices;
pub const struct_IPrintDialogServicesVtbl = extern struct {
    QueryInterface: ?fn ([*c]IPrintDialogServices, [*c]const IID, [*c](?*c_void)) callconv(.C) HRESULT,
    AddRef: ?fn ([*c]IPrintDialogServices) callconv(.C) ULONG,
    Release: ?fn ([*c]IPrintDialogServices) callconv(.C) ULONG,
    GetCurrentDevMode: ?fn ([*c]IPrintDialogServices, LPDEVMODE, [*c]UINT) callconv(.C) HRESULT,
    GetCurrentPrinterName: ?fn ([*c]IPrintDialogServices, LPWSTR, [*c]UINT) callconv(.C) HRESULT,
    GetCurrentPortName: ?fn ([*c]IPrintDialogServices, LPWSTR, [*c]UINT) callconv(.C) HRESULT,
};
pub const struct_IPrintDialogServices = extern struct {
    lpVtbl: [*c]struct_IPrintDialogServicesVtbl,
};
pub const IPrintDialogServicesVtbl = struct_IPrintDialogServicesVtbl;
pub const struct_tagPRINTPAGERANGE = extern struct {
    nFromPage: DWORD,
    nToPage: DWORD,
};
pub const PRINTPAGERANGE = struct_tagPRINTPAGERANGE;
pub const LPPRINTPAGERANGE = [*c]PRINTPAGERANGE;
pub const PCPRINTPAGERANGE = [*c]const PRINTPAGERANGE;
pub const struct_tagPDEXA = extern struct {
    lStructSize: DWORD,
    hwndOwner: HWND,
    hDevMode: HGLOBAL,
    hDevNames: HGLOBAL,
    hDC: HDC,
    Flags: DWORD,
    Flags2: DWORD,
    ExclusionFlags: DWORD,
    nPageRanges: DWORD,
    nMaxPageRanges: DWORD,
    lpPageRanges: LPPRINTPAGERANGE,
    nMinPage: DWORD,
    nMaxPage: DWORD,
    nCopies: DWORD,
    hInstance: HINSTANCE,
    lpPrintTemplateName: LPCSTR,
    lpCallback: LPUNKNOWN,
    nPropertyPages: DWORD,
    lphPropertyPages: [*c]HPROPSHEETPAGE,
    nStartPage: DWORD,
    dwResultAction: DWORD,
};
pub const PRINTDLGEXA = struct_tagPDEXA;
pub const LPPRINTDLGEXA = [*c]struct_tagPDEXA;
pub const struct_tagPDEXW = extern struct {
    lStructSize: DWORD,
    hwndOwner: HWND,
    hDevMode: HGLOBAL,
    hDevNames: HGLOBAL,
    hDC: HDC,
    Flags: DWORD,
    Flags2: DWORD,
    ExclusionFlags: DWORD,
    nPageRanges: DWORD,
    nMaxPageRanges: DWORD,
    lpPageRanges: LPPRINTPAGERANGE,
    nMinPage: DWORD,
    nMaxPage: DWORD,
    nCopies: DWORD,
    hInstance: HINSTANCE,
    lpPrintTemplateName: LPCWSTR,
    lpCallback: LPUNKNOWN,
    nPropertyPages: DWORD,
    lphPropertyPages: [*c]HPROPSHEETPAGE,
    nStartPage: DWORD,
    dwResultAction: DWORD,
};
pub const PRINTDLGEXW = struct_tagPDEXW;
pub const LPPRINTDLGEXW = [*c]struct_tagPDEXW;
pub const PRINTDLGEX = PRINTDLGEXA;
pub const LPPRINTDLGEX = LPPRINTDLGEXA;
pub extern "comdlg32" fn PrintDlgExA(pPD: LPPRINTDLGEXA) callconv(.Stdcall) HRESULT;
pub extern "comdlg32" fn PrintDlgExW(pPD: LPPRINTDLGEXW) callconv(.Stdcall) HRESULT;
pub const struct_tagDEVNAMES = extern struct {
    wDriverOffset: WORD,
    wDeviceOffset: WORD,
    wOutputOffset: WORD,
    wDefault: WORD,
};
pub const DEVNAMES = struct_tagDEVNAMES;
pub const LPDEVNAMES = [*c]DEVNAMES;
pub const PCDEVNAMES = [*c]const DEVNAMES;
pub extern "comdlg32" fn CommDlgExtendedError() callconv(.Stdcall) DWORD;
pub const LPPAGEPAINTHOOK = ?fn (HWND, UINT, WPARAM, LPARAM) callconv(.C) UINT_PTR;
pub const LPPAGESETUPHOOK = ?fn (HWND, UINT, WPARAM, LPARAM) callconv(.C) UINT_PTR;
pub const struct_tagPSDA = extern struct {
    lStructSize: DWORD,
    hwndOwner: HWND,
    hDevMode: HGLOBAL,
    hDevNames: HGLOBAL,
    Flags: DWORD,
    ptPaperSize: POINT,
    rtMinMargin: RECT,
    rtMargin: RECT,
    hInstance: HINSTANCE,
    lCustData: LPARAM,
    lpfnPageSetupHook: LPPAGESETUPHOOK,
    lpfnPagePaintHook: LPPAGEPAINTHOOK,
    lpPageSetupTemplateName: LPCSTR,
    hPageSetupTemplate: HGLOBAL,
};
pub const PAGESETUPDLGA = struct_tagPSDA;
pub const LPPAGESETUPDLGA = [*c]struct_tagPSDA;
pub const struct_tagPSDW = extern struct {
    lStructSize: DWORD,
    hwndOwner: HWND,
    hDevMode: HGLOBAL,
    hDevNames: HGLOBAL,
    Flags: DWORD,
    ptPaperSize: POINT,
    rtMinMargin: RECT,
    rtMargin: RECT,
    hInstance: HINSTANCE,
    lCustData: LPARAM,
    lpfnPageSetupHook: LPPAGESETUPHOOK,
    lpfnPagePaintHook: LPPAGEPAINTHOOK,
    lpPageSetupTemplateName: LPCWSTR,
    hPageSetupTemplate: HGLOBAL,
};
pub const PAGESETUPDLGW = struct_tagPSDW;
pub const LPPAGESETUPDLGW = [*c]struct_tagPSDW;
pub const PAGESETUPDLG = PAGESETUPDLGA;
pub const LPPAGESETUPDLG = LPPAGESETUPDLGA;
pub extern "comdlg32" fn PageSetupDlgA(arg0: LPPAGESETUPDLGA) callconv(.Stdcall) BOOL;
pub extern "comdlg32" fn PageSetupDlgW(arg0: LPPAGESETUPDLGW) callconv(.Stdcall) BOOL;
pub extern fn uaw_CharUpperW(String: LPUWSTR) LPUWSTR;
pub extern fn uaw_lstrcmpW(String1: PCUWSTR, String2: PCUWSTR) c_int;
pub extern fn uaw_lstrcmpiW(String1: PCUWSTR, String2: PCUWSTR) c_int;
pub extern fn uaw_lstrlenW(String: LPCUWSTR) c_int;
pub extern fn uaw_wcschr(String: PCUWSTR, Character: WCHAR) PUWSTR;
pub extern fn uaw_wcscpy(Destination: PUWSTR, Source: PCUWSTR) PUWSTR;
pub extern fn uaw_wcsicmp(String1: PCUWSTR, String2: PCUWSTR) c_int;
pub extern fn uaw_wcslen(String: PCUWSTR) usize;
pub extern fn uaw_wcsrchr(String: PCUWSTR, Character: WCHAR) PUWSTR;
pub fn ua_CharUpperW(String: LPUWSTR) LPUWSTR {
    if (1 != 0) {
        return @ptrCast(LPUWSTR, @alignCast(@alignOf(WCHAR), CharUpperW(@ptrCast(PWSTR, @alignCast(@alignOf(WCHAR), String)))));
    } else {
        return uaw_CharUpperW(String);
    }
}
pub fn ua_lstrcmpW(String1: LPCUWSTR, String2: LPCUWSTR) c_int {
    if ((1 != 0) and (1 != 0)) {
        return lstrcmpW(@ptrCast(LPCWSTR, @alignCast(@alignOf(WCHAR), String1)), @ptrCast(LPCWSTR, @alignCast(@alignOf(WCHAR), String2)));
    } else {
        return uaw_lstrcmpW(String1, String2);
    }
}
pub fn ua_lstrcmpiW(String1: LPCUWSTR, String2: LPCUWSTR) c_int {
    if ((1 != 0) and (1 != 0)) {
        return lstrcmpiW(@ptrCast(LPCWSTR, @alignCast(@alignOf(WCHAR), String1)), @ptrCast(LPCWSTR, @alignCast(@alignOf(WCHAR), String2)));
    } else {
        return uaw_lstrcmpiW(String1, String2);
    }
}
pub fn ua_lstrlenW(String: LPCUWSTR) c_int {
    if (1 != 0) {
        return lstrlenW(@ptrCast(PCWSTR, @alignCast(@alignOf(WCHAR), String)));
    } else {
        return uaw_lstrlenW(String);
    }
}
pub const PUWSTR_C = [*c]WCHAR;
pub fn ua_wcschr(String: PCUWSTR, Character: WCHAR) PUWSTR_C {
    if (1 != 0) {
        return @ptrCast(PUWSTR_C, @alignCast(@alignOf(WCHAR), wcschr(@ptrCast(PCWSTR, @alignCast(@alignOf(WCHAR), String)), Character)));
    } else {
        return @ptrCast(PUWSTR_C, @alignCast(@alignOf(WCHAR), uaw_wcschr(String, Character)));
    }
}
pub fn ua_wcsrchr(String: PCUWSTR, Character: WCHAR) PUWSTR_C {
    if (1 != 0) {
        return @ptrCast(PUWSTR_C, @alignCast(@alignOf(WCHAR), wcsrchr(@ptrCast(PCWSTR, @alignCast(@alignOf(WCHAR), String)), Character)));
    } else {
        return @ptrCast(PUWSTR_C, @alignCast(@alignOf(WCHAR), uaw_wcsrchr(String, Character)));
    }
}
pub fn ua_wcscpy(Destination: PUWSTR, Source: PCUWSTR) PUWSTR {
    if ((1 != 0) and (1 != 0)) {
        return @ptrCast(PUWSTR, @alignCast(@alignOf(WCHAR), wcscpy(@ptrCast(PWSTR, @alignCast(@alignOf(WCHAR), Destination)), @ptrCast(PCWSTR, @alignCast(@alignOf(WCHAR), Source)))));
    } else {
        return uaw_wcscpy(Destination, Source);
    }
}
pub fn ua_wcscpy_s(Destination: PUWSTR, DestinationSize: usize, Source: PCUWSTR) PUWSTR {
    if ((1 != 0) and (1 != 0)) {
        return if (wcscpy_s(@ptrCast(PWSTR, @alignCast(@alignOf(WCHAR), Destination)), DestinationSize, @ptrCast(PCWSTR, @alignCast(@alignOf(WCHAR), Source))) == 0) Destination else null;
    } else {
        return uaw_wcscpy(Destination, Source);
    }
}
pub fn ua_wcslen(String: PCUWSTR) usize {
    if (1 != 0) {
        return wcslen(@ptrCast(PCWSTR, @alignCast(@alignOf(WCHAR), String)));
    } else {
        return uaw_wcslen(String);
    }
}
pub fn ua_wcsicmp(String1: PCUWSTR, String2: PCUWSTR) c_int {
    if ((1 != 0) and (1 != 0)) {
        return _wcsicmp(@ptrCast(LPCWSTR, @alignCast(@alignOf(WCHAR), String1)), @ptrCast(LPCWSTR, @alignCast(@alignOf(WCHAR), String2)));
    } else {
        return uaw_wcsicmp(String1, String2);
    }
}
pub extern const NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID: GUID;
pub extern const NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID: GUID;
pub extern const DOMAIN_JOIN_GUID: GUID;
pub extern const DOMAIN_LEAVE_GUID: GUID;
pub extern const FIREWALL_PORT_OPEN_GUID: GUID;
pub extern const FIREWALL_PORT_CLOSE_GUID: GUID;
pub extern const MACHINE_POLICY_PRESENT_GUID: GUID;
pub extern const USER_POLICY_PRESENT_GUID: GUID;
pub extern const RPC_INTERFACE_EVENT_GUID: GUID;
pub extern const NAMED_PIPE_EVENT_GUID: GUID;
pub extern const CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID: GUID;
pub const SERVICE_TRIGGER_CUSTOM_STATE_ID = extern struct {
    Data: [2]DWORD,
};
pub const struct__SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM = extern struct {
    u: extern union {
        CustomStateId: SERVICE_TRIGGER_CUSTOM_STATE_ID,
        s: extern struct {
            DataOffset: DWORD,
            Data: [1]BYTE,
        },
    },
};
pub const SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM = struct__SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM;
pub const LPSERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM = [*c]struct__SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM;
pub const struct__SERVICE_DESCRIPTIONA = extern struct {
    lpDescription: LPSTR,
};
pub const SERVICE_DESCRIPTIONA = struct__SERVICE_DESCRIPTIONA;
pub const LPSERVICE_DESCRIPTIONA = [*c]struct__SERVICE_DESCRIPTIONA;
pub const struct__SERVICE_DESCRIPTIONW = extern struct {
    lpDescription: LPWSTR,
};
pub const SERVICE_DESCRIPTIONW = struct__SERVICE_DESCRIPTIONW;
pub const LPSERVICE_DESCRIPTIONW = [*c]struct__SERVICE_DESCRIPTIONW;
pub const SERVICE_DESCRIPTION = SERVICE_DESCRIPTIONA;
pub const LPSERVICE_DESCRIPTION = LPSERVICE_DESCRIPTIONA;
pub const SC_ACTION_NONE = enum__SC_ACTION_TYPE.SC_ACTION_NONE;
pub const SC_ACTION_RESTART = enum__SC_ACTION_TYPE.SC_ACTION_RESTART;
pub const SC_ACTION_REBOOT = enum__SC_ACTION_TYPE.SC_ACTION_REBOOT;
pub const SC_ACTION_RUN_COMMAND = enum__SC_ACTION_TYPE.SC_ACTION_RUN_COMMAND;
pub const SC_ACTION_OWN_RESTART = enum__SC_ACTION_TYPE.SC_ACTION_OWN_RESTART;
pub const enum__SC_ACTION_TYPE = extern enum {
    SC_ACTION_NONE = 0,
    SC_ACTION_RESTART = 1,
    SC_ACTION_REBOOT = 2,
    SC_ACTION_RUN_COMMAND = 3,
    SC_ACTION_OWN_RESTART = 4,
};
pub const SC_ACTION_TYPE = enum__SC_ACTION_TYPE;
pub const struct__SC_ACTION = extern struct {
    Type: SC_ACTION_TYPE,
    Delay: DWORD,
};
pub const SC_ACTION = struct__SC_ACTION;
pub const LPSC_ACTION = [*c]struct__SC_ACTION;
pub const struct__SERVICE_FAILURE_ACTIONSA = extern struct {
    dwResetPeriod: DWORD,
    lpRebootMsg: LPSTR,
    lpCommand: LPSTR,
    cActions: DWORD,
    lpsaActions: [*c]SC_ACTION,
};
pub const SERVICE_FAILURE_ACTIONSA = struct__SERVICE_FAILURE_ACTIONSA;
pub const LPSERVICE_FAILURE_ACTIONSA = [*c]struct__SERVICE_FAILURE_ACTIONSA;
pub const struct__SERVICE_FAILURE_ACTIONSW = extern struct {
    dwResetPeriod: DWORD,
    lpRebootMsg: LPWSTR,
    lpCommand: LPWSTR,
    cActions: DWORD,
    lpsaActions: [*c]SC_ACTION,
};
pub const SERVICE_FAILURE_ACTIONSW = struct__SERVICE_FAILURE_ACTIONSW;
pub const LPSERVICE_FAILURE_ACTIONSW = [*c]struct__SERVICE_FAILURE_ACTIONSW;
pub const SERVICE_FAILURE_ACTIONS = SERVICE_FAILURE_ACTIONSA;
pub const LPSERVICE_FAILURE_ACTIONS = LPSERVICE_FAILURE_ACTIONSA;
pub const struct__SERVICE_DELAYED_AUTO_START_INFO = extern struct {
    fDelayedAutostart: BOOL,
};
pub const SERVICE_DELAYED_AUTO_START_INFO = struct__SERVICE_DELAYED_AUTO_START_INFO;
pub const LPSERVICE_DELAYED_AUTO_START_INFO = [*c]struct__SERVICE_DELAYED_AUTO_START_INFO;
pub const struct__SERVICE_FAILURE_ACTIONS_FLAG = extern struct {
    fFailureActionsOnNonCrashFailures: BOOL,
};
pub const SERVICE_FAILURE_ACTIONS_FLAG = struct__SERVICE_FAILURE_ACTIONS_FLAG;
pub const LPSERVICE_FAILURE_ACTIONS_FLAG = [*c]struct__SERVICE_FAILURE_ACTIONS_FLAG;
pub const struct__SERVICE_SID_INFO = extern struct {
    dwServiceSidType: DWORD,
};
pub const SERVICE_SID_INFO = struct__SERVICE_SID_INFO;
pub const LPSERVICE_SID_INFO = [*c]struct__SERVICE_SID_INFO;
pub const struct__SERVICE_REQUIRED_PRIVILEGES_INFOA = extern struct {
    pmszRequiredPrivileges: LPSTR,
};
pub const SERVICE_REQUIRED_PRIVILEGES_INFOA = struct__SERVICE_REQUIRED_PRIVILEGES_INFOA;
pub const LPSERVICE_REQUIRED_PRIVILEGES_INFOA = [*c]struct__SERVICE_REQUIRED_PRIVILEGES_INFOA;
pub const struct__SERVICE_REQUIRED_PRIVILEGES_INFOW = extern struct {
    pmszRequiredPrivileges: LPWSTR,
};
pub const SERVICE_REQUIRED_PRIVILEGES_INFOW = struct__SERVICE_REQUIRED_PRIVILEGES_INFOW;
pub const LPSERVICE_REQUIRED_PRIVILEGES_INFOW = [*c]struct__SERVICE_REQUIRED_PRIVILEGES_INFOW;
pub const SERVICE_REQUIRED_PRIVILEGES_INFO = SERVICE_REQUIRED_PRIVILEGES_INFOA;
pub const LPSERVICE_REQUIRED_PRIVILEGES_INFO = LPSERVICE_REQUIRED_PRIVILEGES_INFOA;
pub const struct__SERVICE_PRESHUTDOWN_INFO = extern struct {
    dwPreshutdownTimeout: DWORD,
};
pub const SERVICE_PRESHUTDOWN_INFO = struct__SERVICE_PRESHUTDOWN_INFO;
pub const LPSERVICE_PRESHUTDOWN_INFO = [*c]struct__SERVICE_PRESHUTDOWN_INFO;
pub const struct__SERVICE_TRIGGER_SPECIFIC_DATA_ITEM = extern struct {
    dwDataType: DWORD,
    cbData: DWORD,
    pData: PBYTE,
};
pub const SERVICE_TRIGGER_SPECIFIC_DATA_ITEM = struct__SERVICE_TRIGGER_SPECIFIC_DATA_ITEM;
pub const PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM = [*c]struct__SERVICE_TRIGGER_SPECIFIC_DATA_ITEM;
pub const struct__SERVICE_TRIGGER = extern struct {
    dwTriggerType: DWORD,
    dwAction: DWORD,
    pTriggerSubtype: [*c]GUID,
    cDataItems: DWORD,
    pDataItems: PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM,
};
pub const SERVICE_TRIGGER = struct__SERVICE_TRIGGER;
pub const PSERVICE_TRIGGER = [*c]struct__SERVICE_TRIGGER;
pub const struct__SERVICE_TRIGGER_INFO = extern struct {
    cTriggers: DWORD,
    pTriggers: PSERVICE_TRIGGER,
    pReserved: PBYTE,
};
pub const SERVICE_TRIGGER_INFO = struct__SERVICE_TRIGGER_INFO;
pub const PSERVICE_TRIGGER_INFO = [*c]struct__SERVICE_TRIGGER_INFO;
pub const struct__SERVICE_PREFERRED_NODE_INFO = extern struct {
    usPreferredNode: USHORT,
    fDelete: BOOLEAN,
};
pub const SERVICE_PREFERRED_NODE_INFO = struct__SERVICE_PREFERRED_NODE_INFO;
pub const LPSERVICE_PREFERRED_NODE_INFO = [*c]struct__SERVICE_PREFERRED_NODE_INFO;
pub const struct__SERVICE_TIMECHANGE_INFO = extern struct {
    liNewTime: LARGE_INTEGER,
    liOldTime: LARGE_INTEGER,
};
pub const SERVICE_TIMECHANGE_INFO = struct__SERVICE_TIMECHANGE_INFO;
pub const PSERVICE_TIMECHANGE_INFO = [*c]struct__SERVICE_TIMECHANGE_INFO;
pub const struct__SERVICE_LAUNCH_PROTECTED_INFO = extern struct {
    dwLaunchProtected: DWORD,
};
pub const SERVICE_LAUNCH_PROTECTED_INFO = struct__SERVICE_LAUNCH_PROTECTED_INFO;
pub const PSERVICE_LAUNCH_PROTECTED_INFO = [*c]struct__SERVICE_LAUNCH_PROTECTED_INFO;
pub const struct_SC_HANDLE__ = extern struct {
    unused: c_int,
};
pub const SC_HANDLE = [*c]struct_SC_HANDLE__;
pub const LPSC_HANDLE = [*c]SC_HANDLE;
pub const struct_SERVICE_STATUS_HANDLE__ = extern struct {
    unused: c_int,
};
pub const SERVICE_STATUS_HANDLE = [*c]struct_SERVICE_STATUS_HANDLE__;
pub const SC_STATUS_PROCESS_INFO = enum__SC_STATUS_TYPE.SC_STATUS_PROCESS_INFO;
pub const enum__SC_STATUS_TYPE = extern enum {
    SC_STATUS_PROCESS_INFO = 0,
};
pub const SC_STATUS_TYPE = enum__SC_STATUS_TYPE;
pub const SC_ENUM_PROCESS_INFO = enum__SC_ENUM_TYPE.SC_ENUM_PROCESS_INFO;
pub const enum__SC_ENUM_TYPE = extern enum {
    SC_ENUM_PROCESS_INFO = 0,
};
pub const SC_ENUM_TYPE = enum__SC_ENUM_TYPE;
pub const struct__SERVICE_STATUS = extern struct {
    dwServiceType: DWORD,
    dwCurrentState: DWORD,
    dwControlsAccepted: DWORD,
    dwWin32ExitCode: DWORD,
    dwServiceSpecificExitCode: DWORD,
    dwCheckPoint: DWORD,
    dwWaitHint: DWORD,
};
pub const SERVICE_STATUS = struct__SERVICE_STATUS;
pub const LPSERVICE_STATUS = [*c]struct__SERVICE_STATUS;
pub const struct__SERVICE_STATUS_PROCESS = extern struct {
    dwServiceType: DWORD,
    dwCurrentState: DWORD,
    dwControlsAccepted: DWORD,
    dwWin32ExitCode: DWORD,
    dwServiceSpecificExitCode: DWORD,
    dwCheckPoint: DWORD,
    dwWaitHint: DWORD,
    dwProcessId: DWORD,
    dwServiceFlags: DWORD,
};
pub const SERVICE_STATUS_PROCESS = struct__SERVICE_STATUS_PROCESS;
pub const LPSERVICE_STATUS_PROCESS = [*c]struct__SERVICE_STATUS_PROCESS;
pub const struct__ENUM_SERVICE_STATUSA = extern struct {
    lpServiceName: LPSTR,
    lpDisplayName: LPSTR,
    ServiceStatus: SERVICE_STATUS,
};
pub const ENUM_SERVICE_STATUSA = struct__ENUM_SERVICE_STATUSA;
pub const LPENUM_SERVICE_STATUSA = [*c]struct__ENUM_SERVICE_STATUSA;
pub const struct__ENUM_SERVICE_STATUSW = extern struct {
    lpServiceName: LPWSTR,
    lpDisplayName: LPWSTR,
    ServiceStatus: SERVICE_STATUS,
};
pub const ENUM_SERVICE_STATUSW = struct__ENUM_SERVICE_STATUSW;
pub const LPENUM_SERVICE_STATUSW = [*c]struct__ENUM_SERVICE_STATUSW;
pub const ENUM_SERVICE_STATUS = ENUM_SERVICE_STATUSA;
pub const LPENUM_SERVICE_STATUS = LPENUM_SERVICE_STATUSA;
pub const struct__ENUM_SERVICE_STATUS_PROCESSA = extern struct {
    lpServiceName: LPSTR,
    lpDisplayName: LPSTR,
    ServiceStatusProcess: SERVICE_STATUS_PROCESS,
};
pub const ENUM_SERVICE_STATUS_PROCESSA = struct__ENUM_SERVICE_STATUS_PROCESSA;
pub const LPENUM_SERVICE_STATUS_PROCESSA = [*c]struct__ENUM_SERVICE_STATUS_PROCESSA;
pub const struct__ENUM_SERVICE_STATUS_PROCESSW = extern struct {
    lpServiceName: LPWSTR,
    lpDisplayName: LPWSTR,
    ServiceStatusProcess: SERVICE_STATUS_PROCESS,
};
pub const ENUM_SERVICE_STATUS_PROCESSW = struct__ENUM_SERVICE_STATUS_PROCESSW;
pub const LPENUM_SERVICE_STATUS_PROCESSW = [*c]struct__ENUM_SERVICE_STATUS_PROCESSW;
pub const ENUM_SERVICE_STATUS_PROCESS = ENUM_SERVICE_STATUS_PROCESSA;
pub const LPENUM_SERVICE_STATUS_PROCESS = LPENUM_SERVICE_STATUS_PROCESSA;
pub const SC_LOCK = LPVOID;
pub const struct__QUERY_SERVICE_LOCK_STATUSA = extern struct {
    fIsLocked: DWORD,
    lpLockOwner: LPSTR,
    dwLockDuration: DWORD,
};
pub const QUERY_SERVICE_LOCK_STATUSA = struct__QUERY_SERVICE_LOCK_STATUSA;
pub const LPQUERY_SERVICE_LOCK_STATUSA = [*c]struct__QUERY_SERVICE_LOCK_STATUSA;
pub const struct__QUERY_SERVICE_LOCK_STATUSW = extern struct {
    fIsLocked: DWORD,
    lpLockOwner: LPWSTR,
    dwLockDuration: DWORD,
};
pub const QUERY_SERVICE_LOCK_STATUSW = struct__QUERY_SERVICE_LOCK_STATUSW;
pub const LPQUERY_SERVICE_LOCK_STATUSW = [*c]struct__QUERY_SERVICE_LOCK_STATUSW;
pub const QUERY_SERVICE_LOCK_STATUS = QUERY_SERVICE_LOCK_STATUSA;
pub const LPQUERY_SERVICE_LOCK_STATUS = LPQUERY_SERVICE_LOCK_STATUSA;
pub const struct__QUERY_SERVICE_CONFIGA = extern struct {
    dwServiceType: DWORD,
    dwStartType: DWORD,
    dwErrorControl: DWORD,
    lpBinaryPathName: LPSTR,
    lpLoadOrderGroup: LPSTR,
    dwTagId: DWORD,
    lpDependencies: LPSTR,
    lpServiceStartName: LPSTR,
    lpDisplayName: LPSTR,
};
pub const QUERY_SERVICE_CONFIGA = struct__QUERY_SERVICE_CONFIGA;
pub const LPQUERY_SERVICE_CONFIGA = [*c]struct__QUERY_SERVICE_CONFIGA;
pub const struct__QUERY_SERVICE_CONFIGW = extern struct {
    dwServiceType: DWORD,
    dwStartType: DWORD,
    dwErrorControl: DWORD,
    lpBinaryPathName: LPWSTR,
    lpLoadOrderGroup: LPWSTR,
    dwTagId: DWORD,
    lpDependencies: LPWSTR,
    lpServiceStartName: LPWSTR,
    lpDisplayName: LPWSTR,
};
pub const QUERY_SERVICE_CONFIGW = struct__QUERY_SERVICE_CONFIGW;
pub const LPQUERY_SERVICE_CONFIGW = [*c]struct__QUERY_SERVICE_CONFIGW;
pub const QUERY_SERVICE_CONFIG = QUERY_SERVICE_CONFIGA;
pub const LPQUERY_SERVICE_CONFIG = LPQUERY_SERVICE_CONFIGA;
pub const SERVICE_MAIN_FUNCTIONW = fn (DWORD, [*c]LPWSTR) callconv(.C) void;
pub const SERVICE_MAIN_FUNCTIONA = fn (DWORD, [*c]LPTSTR) callconv(.C) void;
pub const LPSERVICE_MAIN_FUNCTIONW = ?fn (DWORD, [*c]LPWSTR) callconv(.C) void;
pub const LPSERVICE_MAIN_FUNCTIONA = ?fn (DWORD, [*c]LPSTR) callconv(.C) void;
pub const struct__SERVICE_TABLE_ENTRYA = extern struct {
    lpServiceName: LPSTR,
    lpServiceProc: LPSERVICE_MAIN_FUNCTIONA,
};
pub const SERVICE_TABLE_ENTRYA = struct__SERVICE_TABLE_ENTRYA;
pub const LPSERVICE_TABLE_ENTRYA = [*c]struct__SERVICE_TABLE_ENTRYA;
pub const struct__SERVICE_TABLE_ENTRYW = extern struct {
    lpServiceName: LPWSTR,
    lpServiceProc: LPSERVICE_MAIN_FUNCTIONW,
};
pub const SERVICE_TABLE_ENTRYW = struct__SERVICE_TABLE_ENTRYW;
pub const LPSERVICE_TABLE_ENTRYW = [*c]struct__SERVICE_TABLE_ENTRYW;
pub const SERVICE_TABLE_ENTRY = SERVICE_TABLE_ENTRYA;
pub const LPSERVICE_TABLE_ENTRY = LPSERVICE_TABLE_ENTRYA;
pub const HANDLER_FUNCTION = fn (DWORD) callconv(.C) void;
pub const HANDLER_FUNCTION_EX = fn (DWORD, DWORD, LPVOID, LPVOID) callconv(.C) DWORD;
pub const LPHANDLER_FUNCTION = ?fn (DWORD) callconv(.C) void;
pub const LPHANDLER_FUNCTION_EX = ?fn (DWORD, DWORD, LPVOID, LPVOID) callconv(.C) DWORD;
pub const PFN_SC_NOTIFY_CALLBACK = ?fn (PVOID) callconv(.C) void;
pub const struct__SERVICE_NOTIFY_1 = extern struct {
    dwVersion: DWORD,
    pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
    pContext: PVOID,
    dwNotificationStatus: DWORD,
    ServiceStatus: SERVICE_STATUS_PROCESS,
};
pub const SERVICE_NOTIFY_1 = struct__SERVICE_NOTIFY_1;
pub const PSERVICE_NOTIFY_1 = [*c]struct__SERVICE_NOTIFY_1;
pub const struct__SERVICE_NOTIFY_2A = extern struct {
    dwVersion: DWORD,
    pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
    pContext: PVOID,
    dwNotificationStatus: DWORD,
    ServiceStatus: SERVICE_STATUS_PROCESS,
    dwNotificationTriggered: DWORD,
    pszServiceNames: LPSTR,
};
pub const SERVICE_NOTIFY_2A = struct__SERVICE_NOTIFY_2A;
pub const PSERVICE_NOTIFY_2A = [*c]struct__SERVICE_NOTIFY_2A;
pub const struct__SERVICE_NOTIFY_2W = extern struct {
    dwVersion: DWORD,
    pfnNotifyCallback: PFN_SC_NOTIFY_CALLBACK,
    pContext: PVOID,
    dwNotificationStatus: DWORD,
    ServiceStatus: SERVICE_STATUS_PROCESS,
    dwNotificationTriggered: DWORD,
    pszServiceNames: LPWSTR,
};
pub const SERVICE_NOTIFY_2W = struct__SERVICE_NOTIFY_2W;
pub const PSERVICE_NOTIFY_2W = [*c]struct__SERVICE_NOTIFY_2W;
pub const SERVICE_NOTIFY_2 = SERVICE_NOTIFY_2A;
pub const PSERVICE_NOTIFY_2 = PSERVICE_NOTIFY_2A;
pub const SERVICE_NOTIFYA = SERVICE_NOTIFY_2A;
pub const PSERVICE_NOTIFYA = [*c]SERVICE_NOTIFY_2A;
pub const SERVICE_NOTIFYW = SERVICE_NOTIFY_2W;
pub const PSERVICE_NOTIFYW = [*c]SERVICE_NOTIFY_2W;
pub const SERVICE_NOTIFY = SERVICE_NOTIFYA;
pub const PSERVICE_NOTIFY = PSERVICE_NOTIFYA;
pub const struct__SERVICE_CONTROL_STATUS_REASON_PARAMSA = extern struct {
    dwReason: DWORD,
    pszComment: LPSTR,
    ServiceStatus: SERVICE_STATUS_PROCESS,
};
pub const SERVICE_CONTROL_STATUS_REASON_PARAMSA = struct__SERVICE_CONTROL_STATUS_REASON_PARAMSA;
pub const PSERVICE_CONTROL_STATUS_REASON_PARAMSA = [*c]struct__SERVICE_CONTROL_STATUS_REASON_PARAMSA;
pub const struct__SERVICE_CONTROL_STATUS_REASON_PARAMSW = extern struct {
    dwReason: DWORD,
    pszComment: LPWSTR,
    ServiceStatus: SERVICE_STATUS_PROCESS,
};
pub const SERVICE_CONTROL_STATUS_REASON_PARAMSW = struct__SERVICE_CONTROL_STATUS_REASON_PARAMSW;
pub const PSERVICE_CONTROL_STATUS_REASON_PARAMSW = [*c]struct__SERVICE_CONTROL_STATUS_REASON_PARAMSW;
pub const SERVICE_CONTROL_STATUS_REASON_PARAMS = SERVICE_CONTROL_STATUS_REASON_PARAMSA;
pub const PSERVICE_CONTROL_STATUS_REASON_PARAMS = PSERVICE_CONTROL_STATUS_REASON_PARAMSA;
pub const struct__SERVICE_START_REASON = extern struct {
    dwReason: DWORD,
};
pub const SERVICE_START_REASON = struct__SERVICE_START_REASON;
pub const PSERVICE_START_REASON = [*c]struct__SERVICE_START_REASON;
pub extern "advapi32" fn ChangeServiceConfigA(hService: SC_HANDLE, dwServiceType: DWORD, dwStartType: DWORD, dwErrorControl: DWORD, lpBinaryPathName: LPCSTR, lpLoadOrderGroup: LPCSTR, lpdwTagId: LPDWORD, lpDependencies: LPCSTR, lpServiceStartName: LPCSTR, lpPassword: LPCSTR, lpDisplayName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn ChangeServiceConfigW(hService: SC_HANDLE, dwServiceType: DWORD, dwStartType: DWORD, dwErrorControl: DWORD, lpBinaryPathName: LPCWSTR, lpLoadOrderGroup: LPCWSTR, lpdwTagId: LPDWORD, lpDependencies: LPCWSTR, lpServiceStartName: LPCWSTR, lpPassword: LPCWSTR, lpDisplayName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn ChangeServiceConfig2A(hService: SC_HANDLE, dwInfoLevel: DWORD, lpInfo: LPVOID) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn ChangeServiceConfig2W(hService: SC_HANDLE, dwInfoLevel: DWORD, lpInfo: LPVOID) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CloseServiceHandle(hSCObject: SC_HANDLE) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn ControlService(hService: SC_HANDLE, dwControl: DWORD, lpServiceStatus: LPSERVICE_STATUS) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn CreateServiceA(hSCManager: SC_HANDLE, lpServiceName: LPCSTR, lpDisplayName: LPCSTR, dwDesiredAccess: DWORD, dwServiceType: DWORD, dwStartType: DWORD, dwErrorControl: DWORD, lpBinaryPathName: LPCSTR, lpLoadOrderGroup: LPCSTR, lpdwTagId: LPDWORD, lpDependencies: LPCSTR, lpServiceStartName: LPCSTR, lpPassword: LPCSTR) callconv(.Stdcall) SC_HANDLE;
pub extern "advapi32" fn CreateServiceW(hSCManager: SC_HANDLE, lpServiceName: LPCWSTR, lpDisplayName: LPCWSTR, dwDesiredAccess: DWORD, dwServiceType: DWORD, dwStartType: DWORD, dwErrorControl: DWORD, lpBinaryPathName: LPCWSTR, lpLoadOrderGroup: LPCWSTR, lpdwTagId: LPDWORD, lpDependencies: LPCWSTR, lpServiceStartName: LPCWSTR, lpPassword: LPCWSTR) callconv(.Stdcall) SC_HANDLE;
pub extern "advapi32" fn DeleteService(hService: SC_HANDLE) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn EnumDependentServicesA(hService: SC_HANDLE, dwServiceState: DWORD, lpServices: LPENUM_SERVICE_STATUSA, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD, lpServicesReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn EnumDependentServicesW(hService: SC_HANDLE, dwServiceState: DWORD, lpServices: LPENUM_SERVICE_STATUSW, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD, lpServicesReturned: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn EnumServicesStatusA(hSCManager: SC_HANDLE, dwServiceType: DWORD, dwServiceState: DWORD, lpServices: LPENUM_SERVICE_STATUSA, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD, lpServicesReturned: LPDWORD, lpResumeHandle: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn EnumServicesStatusW(hSCManager: SC_HANDLE, dwServiceType: DWORD, dwServiceState: DWORD, lpServices: LPENUM_SERVICE_STATUSW, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD, lpServicesReturned: LPDWORD, lpResumeHandle: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn EnumServicesStatusExA(hSCManager: SC_HANDLE, InfoLevel: SC_ENUM_TYPE, dwServiceType: DWORD, dwServiceState: DWORD, lpServices: LPBYTE, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD, lpServicesReturned: LPDWORD, lpResumeHandle: LPDWORD, pszGroupName: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn EnumServicesStatusExW(hSCManager: SC_HANDLE, InfoLevel: SC_ENUM_TYPE, dwServiceType: DWORD, dwServiceState: DWORD, lpServices: LPBYTE, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD, lpServicesReturned: LPDWORD, lpResumeHandle: LPDWORD, pszGroupName: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn GetServiceKeyNameA(hSCManager: SC_HANDLE, lpDisplayName: LPCSTR, lpServiceName: LPSTR, lpcchBuffer: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn GetServiceKeyNameW(hSCManager: SC_HANDLE, lpDisplayName: LPCWSTR, lpServiceName: LPWSTR, lpcchBuffer: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn GetServiceDisplayNameA(hSCManager: SC_HANDLE, lpServiceName: LPCSTR, lpDisplayName: LPSTR, lpcchBuffer: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn GetServiceDisplayNameW(hSCManager: SC_HANDLE, lpServiceName: LPCWSTR, lpDisplayName: LPWSTR, lpcchBuffer: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn LockServiceDatabase(hSCManager: SC_HANDLE) callconv(.Stdcall) SC_LOCK;
pub extern "advapi32" fn NotifyBootConfigStatus(BootAcceptable: BOOL) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn OpenSCManagerA(lpMachineName: LPCSTR, lpDatabaseName: LPCSTR, dwDesiredAccess: DWORD) callconv(.Stdcall) SC_HANDLE;
pub extern "advapi32" fn OpenSCManagerW(lpMachineName: LPCWSTR, lpDatabaseName: LPCWSTR, dwDesiredAccess: DWORD) callconv(.Stdcall) SC_HANDLE;
pub extern "advapi32" fn OpenServiceA(hSCManager: SC_HANDLE, lpServiceName: LPCSTR, dwDesiredAccess: DWORD) callconv(.Stdcall) SC_HANDLE;
pub extern "advapi32" fn OpenServiceW(hSCManager: SC_HANDLE, lpServiceName: LPCWSTR, dwDesiredAccess: DWORD) callconv(.Stdcall) SC_HANDLE;
pub extern "advapi32" fn QueryServiceConfigA(hService: SC_HANDLE, lpServiceConfig: LPQUERY_SERVICE_CONFIGA, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn QueryServiceConfigW(hService: SC_HANDLE, lpServiceConfig: LPQUERY_SERVICE_CONFIGW, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn QueryServiceConfig2A(hService: SC_HANDLE, dwInfoLevel: DWORD, lpBuffer: LPBYTE, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn QueryServiceConfig2W(hService: SC_HANDLE, dwInfoLevel: DWORD, lpBuffer: LPBYTE, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn QueryServiceLockStatusA(hSCManager: SC_HANDLE, lpLockStatus: LPQUERY_SERVICE_LOCK_STATUSA, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn QueryServiceLockStatusW(hSCManager: SC_HANDLE, lpLockStatus: LPQUERY_SERVICE_LOCK_STATUSW, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn QueryServiceObjectSecurity(hService: SC_HANDLE, dwSecurityInformation: SECURITY_INFORMATION, lpSecurityDescriptor: PSECURITY_DESCRIPTOR, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn QueryServiceStatus(hService: SC_HANDLE, lpServiceStatus: LPSERVICE_STATUS) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn QueryServiceStatusEx(hService: SC_HANDLE, InfoLevel: SC_STATUS_TYPE, lpBuffer: LPBYTE, cbBufSize: DWORD, pcbBytesNeeded: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn RegisterServiceCtrlHandlerA(lpServiceName: LPCSTR, lpHandlerProc: LPHANDLER_FUNCTION) callconv(.Stdcall) SERVICE_STATUS_HANDLE;
pub extern "advapi32" fn RegisterServiceCtrlHandlerW(lpServiceName: LPCWSTR, lpHandlerProc: LPHANDLER_FUNCTION) callconv(.Stdcall) SERVICE_STATUS_HANDLE;
pub extern "advapi32" fn RegisterServiceCtrlHandlerExA(lpServiceName: LPCSTR, lpHandlerProc: LPHANDLER_FUNCTION_EX, lpContext: LPVOID) callconv(.Stdcall) SERVICE_STATUS_HANDLE;
pub extern "advapi32" fn RegisterServiceCtrlHandlerExW(lpServiceName: LPCWSTR, lpHandlerProc: LPHANDLER_FUNCTION_EX, lpContext: LPVOID) callconv(.Stdcall) SERVICE_STATUS_HANDLE;
pub extern "advapi32" fn SetServiceObjectSecurity(hService: SC_HANDLE, dwSecurityInformation: SECURITY_INFORMATION, lpSecurityDescriptor: PSECURITY_DESCRIPTOR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn SetServiceStatus(hServiceStatus: SERVICE_STATUS_HANDLE, lpServiceStatus: LPSERVICE_STATUS) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn StartServiceCtrlDispatcherA(lpServiceStartTable: [*c]const SERVICE_TABLE_ENTRYA) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn StartServiceCtrlDispatcherW(lpServiceStartTable: [*c]const SERVICE_TABLE_ENTRYW) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn StartServiceA(hService: SC_HANDLE, dwNumServiceArgs: DWORD, lpServiceArgVectors: [*c]LPCSTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn StartServiceW(hService: SC_HANDLE, dwNumServiceArgs: DWORD, lpServiceArgVectors: [*c]LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn UnlockServiceDatabase(ScLock: SC_LOCK) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn NotifyServiceStatusChangeA(hService: SC_HANDLE, dwNotifyMask: DWORD, pNotifyBuffer: PSERVICE_NOTIFYA) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn NotifyServiceStatusChangeW(hService: SC_HANDLE, dwNotifyMask: DWORD, pNotifyBuffer: PSERVICE_NOTIFYW) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn ControlServiceExA(hService: SC_HANDLE, dwControl: DWORD, dwInfoLevel: DWORD, pControlParams: PVOID) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn ControlServiceExW(hService: SC_HANDLE, dwControl: DWORD, dwInfoLevel: DWORD, pControlParams: PVOID) callconv(.Stdcall) BOOL;
pub extern "advapi32" fn QueryServiceDynamicInformation(hServiceStatus: SERVICE_STATUS_HANDLE, dwInfoLevel: DWORD, ppDynamicInfo: [*c]PVOID) callconv(.Stdcall) BOOL;
pub const SC_EVENT_DATABASE_CHANGE = enum__SC_EVENT_TYPE.SC_EVENT_DATABASE_CHANGE;
pub const SC_EVENT_PROPERTY_CHANGE = enum__SC_EVENT_TYPE.SC_EVENT_PROPERTY_CHANGE;
pub const SC_EVENT_STATUS_CHANGE = enum__SC_EVENT_TYPE.SC_EVENT_STATUS_CHANGE;
pub const enum__SC_EVENT_TYPE = extern enum {
    SC_EVENT_DATABASE_CHANGE,
    SC_EVENT_PROPERTY_CHANGE,
    SC_EVENT_STATUS_CHANGE,
};
pub const SC_EVENT_TYPE = enum__SC_EVENT_TYPE;
pub const PSC_EVENT_TYPE = [*c]enum__SC_EVENT_TYPE;
pub const SC_NOTIFICATION_CALLBACK = fn (DWORD, PVOID) callconv(.C) void;
pub const PSC_NOTIFICATION_CALLBACK = [*c]SC_NOTIFICATION_CALLBACK;
pub const struct__SC_NOTIFICATION_REGISTRATION = @OpaqueType();
pub const PSC_NOTIFICATION_REGISTRATION = ?*struct__SC_NOTIFICATION_REGISTRATION;
pub extern "advapi32" fn SubscribeServiceChangeNotifications(hService: SC_HANDLE, eEventType: SC_EVENT_TYPE, pCallback: PSC_NOTIFICATION_CALLBACK, pCallbackContext: PVOID, pSubscription: [*c]PSC_NOTIFICATION_REGISTRATION) callconv(.Stdcall) DWORD;
pub extern "advapi32" fn UnsubscribeServiceChangeNotifications(pSubscription: PSC_NOTIFICATION_REGISTRATION) callconv(.Stdcall) void;
pub extern "advapi32" fn WaitServiceState(hService: SC_HANDLE, dwNotify: DWORD, dwTimeout: DWORD, hCancelEvent: HANDLE) callconv(.Stdcall) DWORD;
pub const ServiceRegistryStateParameters = enum_SERVICE_REGISTRY_STATE_TYPE.ServiceRegistryStateParameters;
pub const ServiceRegistryStatePersistent = enum_SERVICE_REGISTRY_STATE_TYPE.ServiceRegistryStatePersistent;
pub const MaxServiceRegistryStateType = enum_SERVICE_REGISTRY_STATE_TYPE.MaxServiceRegistryStateType;
pub const enum_SERVICE_REGISTRY_STATE_TYPE = extern enum {
    ServiceRegistryStateParameters = 0,
    ServiceRegistryStatePersistent = 1,
    MaxServiceRegistryStateType = 2,
};
pub const SERVICE_REGISTRY_STATE_TYPE = enum_SERVICE_REGISTRY_STATE_TYPE;
pub extern "advapi32" fn GetServiceRegistryStateKey(ServiceStatusHandle: SERVICE_STATUS_HANDLE, StateType: SERVICE_REGISTRY_STATE_TYPE, AccessMask: DWORD, ServiceStateKey: [*c]HKEY) callconv(.Stdcall) DWORD;
pub const ServiceDirectoryPersistentState = enum_SERVICE_DIRECTORY_TYPE.ServiceDirectoryPersistentState;
pub const ServiceDirectoryTypeMax = enum_SERVICE_DIRECTORY_TYPE.ServiceDirectoryTypeMax;
pub const enum_SERVICE_DIRECTORY_TYPE = extern enum {
    ServiceDirectoryPersistentState = 0,
    ServiceDirectoryTypeMax = 1,
};
pub const SERVICE_DIRECTORY_TYPE = enum_SERVICE_DIRECTORY_TYPE;
pub extern "advapi32" fn GetServiceDirectory(hServiceStatus: SERVICE_STATUS_HANDLE, eDirectoryType: SERVICE_DIRECTORY_TYPE, lpPathBuffer: PWCHAR, cchPathBufferLength: DWORD, lpcchRequiredBufferLength: [*c]DWORD) callconv(.Stdcall) DWORD;
pub const struct__MODEMDEVCAPS = extern struct {
    dwActualSize: DWORD,
    dwRequiredSize: DWORD,
    dwDevSpecificOffset: DWORD,
    dwDevSpecificSize: DWORD,
    dwModemProviderVersion: DWORD,
    dwModemManufacturerOffset: DWORD,
    dwModemManufacturerSize: DWORD,
    dwModemModelOffset: DWORD,
    dwModemModelSize: DWORD,
    dwModemVersionOffset: DWORD,
    dwModemVersionSize: DWORD,
    dwDialOptions: DWORD,
    dwCallSetupFailTimer: DWORD,
    dwInactivityTimeout: DWORD,
    dwSpeakerVolume: DWORD,
    dwSpeakerMode: DWORD,
    dwModemOptions: DWORD,
    dwMaxDTERate: DWORD,
    dwMaxDCERate: DWORD,
    abVariablePortion: [1]BYTE,
};
pub const MODEMDEVCAPS = struct__MODEMDEVCAPS;
pub const PMODEMDEVCAPS = [*c]struct__MODEMDEVCAPS;
pub const LPMODEMDEVCAPS = [*c]struct__MODEMDEVCAPS;
pub const struct__MODEMSETTINGS = extern struct {
    dwActualSize: DWORD,
    dwRequiredSize: DWORD,
    dwDevSpecificOffset: DWORD,
    dwDevSpecificSize: DWORD,
    dwCallSetupFailTimer: DWORD,
    dwInactivityTimeout: DWORD,
    dwSpeakerVolume: DWORD,
    dwSpeakerMode: DWORD,
    dwPreferredModemOptions: DWORD,
    dwNegotiatedModemOptions: DWORD,
    dwNegotiatedDCERate: DWORD,
    abVariablePortion: [1]BYTE,
};
pub const MODEMSETTINGS = struct__MODEMSETTINGS;
pub const PMODEMSETTINGS = [*c]struct__MODEMSETTINGS;
pub const LPMODEMSETTINGS = [*c]struct__MODEMSETTINGS;
pub const struct_HIMC__ = extern struct {
    unused: c_int,
};
pub const HIMC = [*c]struct_HIMC__;
pub const struct_HIMCC__ = extern struct {
    unused: c_int,
};
pub const HIMCC = [*c]struct_HIMCC__;
pub const LPHKL = [*c]HKL;
pub const struct_tagCOMPOSITIONFORM = extern struct {
    dwStyle: DWORD,
    ptCurrentPos: POINT,
    rcArea: RECT,
};
pub const COMPOSITIONFORM = struct_tagCOMPOSITIONFORM;
pub const PCOMPOSITIONFORM = [*c]struct_tagCOMPOSITIONFORM;
pub const NPCOMPOSITIONFORM = [*c]struct_tagCOMPOSITIONFORM;
pub const LPCOMPOSITIONFORM = [*c]struct_tagCOMPOSITIONFORM;
pub const struct_tagCANDIDATEFORM = extern struct {
    dwIndex: DWORD,
    dwStyle: DWORD,
    ptCurrentPos: POINT,
    rcArea: RECT,
};
pub const CANDIDATEFORM = struct_tagCANDIDATEFORM;
pub const PCANDIDATEFORM = [*c]struct_tagCANDIDATEFORM;
pub const NPCANDIDATEFORM = [*c]struct_tagCANDIDATEFORM;
pub const LPCANDIDATEFORM = [*c]struct_tagCANDIDATEFORM;
pub const struct_tagCANDIDATELIST = extern struct {
    dwSize: DWORD,
    dwStyle: DWORD,
    dwCount: DWORD,
    dwSelection: DWORD,
    dwPageStart: DWORD,
    dwPageSize: DWORD,
    dwOffset: [1]DWORD,
};
pub const CANDIDATELIST = struct_tagCANDIDATELIST;
pub const PCANDIDATELIST = [*c]struct_tagCANDIDATELIST;
pub const NPCANDIDATELIST = [*c]struct_tagCANDIDATELIST;
pub const LPCANDIDATELIST = [*c]struct_tagCANDIDATELIST;
pub const struct_tagREGISTERWORDA = extern struct {
    lpReading: LPSTR,
    lpWord: LPSTR,
};
pub const REGISTERWORDA = struct_tagREGISTERWORDA;
pub const PREGISTERWORDA = [*c]struct_tagREGISTERWORDA;
pub const NPREGISTERWORDA = [*c]struct_tagREGISTERWORDA;
pub const LPREGISTERWORDA = [*c]struct_tagREGISTERWORDA;
pub const struct_tagREGISTERWORDW = extern struct {
    lpReading: LPWSTR,
    lpWord: LPWSTR,
};
pub const REGISTERWORDW = struct_tagREGISTERWORDW;
pub const PREGISTERWORDW = [*c]struct_tagREGISTERWORDW;
pub const NPREGISTERWORDW = [*c]struct_tagREGISTERWORDW;
pub const LPREGISTERWORDW = [*c]struct_tagREGISTERWORDW;
pub const REGISTERWORD = REGISTERWORDA;
pub const PREGISTERWORD = PREGISTERWORDA;
pub const NPREGISTERWORD = NPREGISTERWORDA;
pub const LPREGISTERWORD = LPREGISTERWORDA;
pub const struct_tagRECONVERTSTRING = extern struct {
    dwSize: DWORD,
    dwVersion: DWORD,
    dwStrLen: DWORD,
    dwStrOffset: DWORD,
    dwCompStrLen: DWORD,
    dwCompStrOffset: DWORD,
    dwTargetStrLen: DWORD,
    dwTargetStrOffset: DWORD,
};
pub const RECONVERTSTRING = struct_tagRECONVERTSTRING;
pub const PRECONVERTSTRING = [*c]struct_tagRECONVERTSTRING;
pub const NPRECONVERTSTRING = [*c]struct_tagRECONVERTSTRING;
pub const LPRECONVERTSTRING = [*c]struct_tagRECONVERTSTRING;
pub const struct_tagSTYLEBUFA = extern struct {
    dwStyle: DWORD,
    szDescription: [32]CHAR,
};
pub const STYLEBUFA = struct_tagSTYLEBUFA;
pub const PSTYLEBUFA = [*c]struct_tagSTYLEBUFA;
pub const NPSTYLEBUFA = [*c]struct_tagSTYLEBUFA;
pub const LPSTYLEBUFA = [*c]struct_tagSTYLEBUFA;
pub const struct_tagSTYLEBUFW = extern struct {
    dwStyle: DWORD,
    szDescription: [32]WCHAR,
};
pub const STYLEBUFW = struct_tagSTYLEBUFW;
pub const PSTYLEBUFW = [*c]struct_tagSTYLEBUFW;
pub const NPSTYLEBUFW = [*c]struct_tagSTYLEBUFW;
pub const LPSTYLEBUFW = [*c]struct_tagSTYLEBUFW;
pub const STYLEBUF = STYLEBUFA;
pub const PSTYLEBUF = PSTYLEBUFA;
pub const NPSTYLEBUF = NPSTYLEBUFA;
pub const LPSTYLEBUF = LPSTYLEBUFA;
pub const struct_tagIMEMENUITEMINFOA = extern struct {
    cbSize: UINT,
    fType: UINT,
    fState: UINT,
    wID: UINT,
    hbmpChecked: HBITMAP,
    hbmpUnchecked: HBITMAP,
    dwItemData: DWORD,
    szString: [80]CHAR,
    hbmpItem: HBITMAP,
};
pub const IMEMENUITEMINFOA = struct_tagIMEMENUITEMINFOA;
pub const PIMEMENUITEMINFOA = [*c]struct_tagIMEMENUITEMINFOA;
pub const NPIMEMENUITEMINFOA = [*c]struct_tagIMEMENUITEMINFOA;
pub const LPIMEMENUITEMINFOA = [*c]struct_tagIMEMENUITEMINFOA;
pub const struct_tagIMEMENUITEMINFOW = extern struct {
    cbSize: UINT,
    fType: UINT,
    fState: UINT,
    wID: UINT,
    hbmpChecked: HBITMAP,
    hbmpUnchecked: HBITMAP,
    dwItemData: DWORD,
    szString: [80]WCHAR,
    hbmpItem: HBITMAP,
};
pub const IMEMENUITEMINFOW = struct_tagIMEMENUITEMINFOW;
pub const PIMEMENUITEMINFOW = [*c]struct_tagIMEMENUITEMINFOW;
pub const NPIMEMENUITEMINFOW = [*c]struct_tagIMEMENUITEMINFOW;
pub const LPIMEMENUITEMINFOW = [*c]struct_tagIMEMENUITEMINFOW;
pub const IMEMENUITEMINFO = IMEMENUITEMINFOA;
pub const PIMEMENUITEMINFO = PIMEMENUITEMINFOA;
pub const NPIMEMENUITEMINFO = NPIMEMENUITEMINFOA;
pub const LPIMEMENUITEMINFO = LPIMEMENUITEMINFOA;
pub const struct_tagIMECHARPOSITION = extern struct {
    dwSize: DWORD,
    dwCharPos: DWORD,
    pt: POINT,
    cLineHeight: UINT,
    rcDocument: RECT,
};
pub const IMECHARPOSITION = struct_tagIMECHARPOSITION;
pub const PIMECHARPOSITION = [*c]struct_tagIMECHARPOSITION;
pub const NPIMECHARPOSITION = [*c]struct_tagIMECHARPOSITION;
pub const LPIMECHARPOSITION = [*c]struct_tagIMECHARPOSITION;
pub const IMCENUMPROC = ?fn (HIMC, LPARAM) callconv(.C) BOOL;
pub extern "imm32" fn ImmInstallIMEA(lpszIMEFileName: LPCSTR, lpszLayoutText: LPCSTR) callconv(.Stdcall) HKL;
pub extern "imm32" fn ImmInstallIMEW(lpszIMEFileName: LPCWSTR, lpszLayoutText: LPCWSTR) callconv(.Stdcall) HKL;
pub extern "imm32" fn ImmGetDefaultIMEWnd(arg0: HWND) callconv(.Stdcall) HWND;
pub extern "imm32" fn ImmGetDescriptionA(arg0: HKL, lpszDescription: LPSTR, uBufLen: UINT) callconv(.Stdcall) UINT;
pub extern "imm32" fn ImmGetDescriptionW(arg0: HKL, lpszDescription: LPWSTR, uBufLen: UINT) callconv(.Stdcall) UINT;
pub extern "imm32" fn ImmGetIMEFileNameA(arg0: HKL, lpszFileName: LPSTR, uBufLen: UINT) callconv(.Stdcall) UINT;
pub extern "imm32" fn ImmGetIMEFileNameW(arg0: HKL, lpszFileName: LPWSTR, uBufLen: UINT) callconv(.Stdcall) UINT;
pub extern "imm32" fn ImmGetProperty(arg0: HKL, arg1: DWORD) callconv(.Stdcall) DWORD;
pub extern "imm32" fn ImmIsIME(arg0: HKL) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmSimulateHotKey(arg0: HWND, arg1: DWORD) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmCreateContext() callconv(.Stdcall) HIMC;
pub extern "imm32" fn ImmDestroyContext(arg0: HIMC) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmGetContext(arg0: HWND) callconv(.Stdcall) HIMC;
pub extern "imm32" fn ImmReleaseContext(arg0: HWND, arg1: HIMC) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmAssociateContext(arg0: HWND, arg1: HIMC) callconv(.Stdcall) HIMC;
pub extern "imm32" fn ImmAssociateContextEx(arg0: HWND, arg1: HIMC, arg2: DWORD) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmGetCompositionStringA(arg0: HIMC, arg1: DWORD, lpBuf: LPVOID, dwBufLen: DWORD) callconv(.Stdcall) LONG;
pub extern "imm32" fn ImmGetCompositionStringW(arg0: HIMC, arg1: DWORD, lpBuf: LPVOID, dwBufLen: DWORD) callconv(.Stdcall) LONG;
pub extern "imm32" fn ImmSetCompositionStringA(arg0: HIMC, dwIndex: DWORD, lpComp: LPVOID, dwCompLen: DWORD, lpRead: LPVOID, dwReadLen: DWORD) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmSetCompositionStringW(arg0: HIMC, dwIndex: DWORD, lpComp: LPVOID, dwCompLen: DWORD, lpRead: LPVOID, dwReadLen: DWORD) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmGetCandidateListCountA(arg0: HIMC, lpdwListCount: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "imm32" fn ImmGetCandidateListCountW(arg0: HIMC, lpdwListCount: LPDWORD) callconv(.Stdcall) DWORD;
pub extern "imm32" fn ImmGetCandidateListA(arg0: HIMC, deIndex: DWORD, lpCandList: LPCANDIDATELIST, dwBufLen: DWORD) callconv(.Stdcall) DWORD;
pub extern "imm32" fn ImmGetCandidateListW(arg0: HIMC, deIndex: DWORD, lpCandList: LPCANDIDATELIST, dwBufLen: DWORD) callconv(.Stdcall) DWORD;
pub extern "imm32" fn ImmGetGuideLineA(arg0: HIMC, dwIndex: DWORD, lpBuf: LPSTR, dwBufLen: DWORD) callconv(.Stdcall) DWORD;
pub extern "imm32" fn ImmGetGuideLineW(arg0: HIMC, dwIndex: DWORD, lpBuf: LPWSTR, dwBufLen: DWORD) callconv(.Stdcall) DWORD;
pub extern "imm32" fn ImmGetConversionStatus(arg0: HIMC, lpfdwConversion: LPDWORD, lpfdwSentence: LPDWORD) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmSetConversionStatus(arg0: HIMC, arg1: DWORD, arg2: DWORD) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmGetOpenStatus(arg0: HIMC) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmSetOpenStatus(arg0: HIMC, arg1: BOOL) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmGetCompositionFontA(arg0: HIMC, lplf: LPLOGFONTA) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmGetCompositionFontW(arg0: HIMC, lplf: LPLOGFONTW) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmSetCompositionFontA(arg0: HIMC, lplf: LPLOGFONTA) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmSetCompositionFontW(arg0: HIMC, lplf: LPLOGFONTW) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmConfigureIMEA(arg0: HKL, arg1: HWND, arg2: DWORD, arg3: LPVOID) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmConfigureIMEW(arg0: HKL, arg1: HWND, arg2: DWORD, arg3: LPVOID) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmEscapeA(arg0: HKL, arg1: HIMC, arg2: UINT, arg3: LPVOID) callconv(.Stdcall) LRESULT;
pub extern "imm32" fn ImmEscapeW(arg0: HKL, arg1: HIMC, arg2: UINT, arg3: LPVOID) callconv(.Stdcall) LRESULT;
pub extern "imm32" fn ImmGetConversionListA(arg0: HKL, arg1: HIMC, lpSrc: LPCSTR, lpDst: LPCANDIDATELIST, dwBufLen: DWORD, uFlag: UINT) callconv(.Stdcall) DWORD;
pub extern "imm32" fn ImmGetConversionListW(arg0: HKL, arg1: HIMC, lpSrc: LPCWSTR, lpDst: LPCANDIDATELIST, dwBufLen: DWORD, uFlag: UINT) callconv(.Stdcall) DWORD;
pub extern "imm32" fn ImmNotifyIME(arg0: HIMC, dwAction: DWORD, dwIndex: DWORD, dwValue: DWORD) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmGetStatusWindowPos(arg0: HIMC, lpptPos: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmSetStatusWindowPos(arg0: HIMC, lpptPos: LPPOINT) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmGetCompositionWindow(arg0: HIMC, lpCompForm: LPCOMPOSITIONFORM) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmSetCompositionWindow(arg0: HIMC, lpCompForm: LPCOMPOSITIONFORM) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmGetCandidateWindow(arg0: HIMC, arg1: DWORD, lpCandidate: LPCANDIDATEFORM) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmSetCandidateWindow(arg0: HIMC, lpCandidate: LPCANDIDATEFORM) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmIsUIMessageA(arg0: HWND, arg1: UINT, arg2: WPARAM, arg3: LPARAM) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmIsUIMessageW(arg0: HWND, arg1: UINT, arg2: WPARAM, arg3: LPARAM) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmGetVirtualKey(arg0: HWND) callconv(.Stdcall) UINT;
pub const REGISTERWORDENUMPROCA = ?fn (LPCSTR, DWORD, LPCSTR, LPVOID) callconv(.C) c_int;
pub const REGISTERWORDENUMPROCW = ?fn (LPCWSTR, DWORD, LPCWSTR, LPVOID) callconv(.C) c_int;
pub extern "imm32" fn ImmRegisterWordA(arg0: HKL, lpszReading: LPCSTR, arg2: DWORD, lpszRegister: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmRegisterWordW(arg0: HKL, lpszReading: LPCWSTR, arg2: DWORD, lpszRegister: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmUnregisterWordA(arg0: HKL, lpszReading: LPCSTR, arg2: DWORD, lpszUnregister: LPCSTR) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmUnregisterWordW(arg0: HKL, lpszReading: LPCWSTR, arg2: DWORD, lpszUnregister: LPCWSTR) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmGetRegisterWordStyleA(arg0: HKL, nItem: UINT, lpStyleBuf: LPSTYLEBUFA) callconv(.Stdcall) UINT;
pub extern "imm32" fn ImmGetRegisterWordStyleW(arg0: HKL, nItem: UINT, lpStyleBuf: LPSTYLEBUFW) callconv(.Stdcall) UINT;
pub extern "imm32" fn ImmEnumRegisterWordA(arg0: HKL, arg1: REGISTERWORDENUMPROCA, lpszReading: LPCSTR, arg3: DWORD, lpszRegister: LPCSTR, arg5: LPVOID) callconv(.Stdcall) UINT;
pub extern "imm32" fn ImmEnumRegisterWordW(arg0: HKL, arg1: REGISTERWORDENUMPROCW, lpszReading: LPCWSTR, arg3: DWORD, lpszRegister: LPCWSTR, arg5: LPVOID) callconv(.Stdcall) UINT;
pub extern "imm32" fn ImmDisableIME(arg0: DWORD) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmEnumInputContext(idThread: DWORD, lpfn: IMCENUMPROC, lParam: LPARAM) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmGetImeMenuItemsA(arg0: HIMC, arg1: DWORD, arg2: DWORD, lpImeParentMenu: LPIMEMENUITEMINFOA, lpImeMenu: LPIMEMENUITEMINFOA, dwSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "imm32" fn ImmGetImeMenuItemsW(arg0: HIMC, arg1: DWORD, arg2: DWORD, lpImeParentMenu: LPIMEMENUITEMINFOW, lpImeMenu: LPIMEMENUITEMINFOW, dwSize: DWORD) callconv(.Stdcall) DWORD;
pub extern "imm32" fn ImmDisableTextFrameService(idThread: DWORD) callconv(.Stdcall) BOOL;
pub extern "imm32" fn ImmDisableLegacyIME() callconv(.Stdcall) BOOL;
pub const SEE_MASK_FLAG_LOG_USAGE = 67108864;
pub const EMR_BITBLT = 76;
pub const EMR_STRETCHBLT = 77;
pub const TCP_NODELAY = 1;
pub const PSPROTOCOL_TBCP = 2;
pub const ERROR_SECURITY_STREAM_IS_INCONSISTENT = @as(c_long, 306);
pub const X509_ENHANCED_KEY_USAGE = if (@typeId(@typeOf(36)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 36) else if (@typeId(@typeOf(36)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 36) else LPCSTR(36);
pub const SCARD_CLASS_ICC_STATE = 9;
pub const SUBLANG_BELARUSIAN_BELARUS = 1;
pub const CERT_CONTEXT_REVOCATION_TYPE = 1;
pub const SUBLANG_GERMAN_SWISS = 2;
pub const STARTF_RUNFULLSCREEN = 32;
pub const _WIN32_IE_IE302 = 770;
pub const WINAPI_FAMILY_SYSTEM = 4;
pub const ERROR_UNEXPECTED_MM_MAP_ERROR = @as(c_long, 557);
pub const PROCESS_CREATION_MITIGATION_POLICY2_SPECULATIVE_STORE_BYPASS_DISABLE_RESERVED = if (@typeId(@typeOf(i64 << 24)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 24) else if (@typeId(@typeOf(i64 << 24)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 24) else @as(c_uint, 3)(i64 << 24);
pub const APPCLASS_MASK = @as(c_long, 15);
pub const URLACTION_INFODELIVERY_MIN = 7424;
pub const PEERDIST_ERROR_ALREADY_EXISTS = @as(c_long, 4058);
pub const ERROR_ENCRYPTION_POLICY_DENIES_OPERATION = @as(c_long, 6022);
pub const GCS_RESULTSTR = 2048;
pub const ERROR_PIPE_LOCAL = @as(c_long, 229);
pub const NCRYPT_DSA_ALGORITHM = BCRYPT_DSA_ALGORITHM;
pub const VK_BROWSER_HOME = 172;
pub const __WCHAR_WIDTH__ = 16;
pub const DC_BINS = 6;
pub const PD_DISABLEPRINTTOFILE = 524288;
pub const LOCALE_SMONTHNAME3 = 58;
pub const SORT_DEFAULT = 0;
pub const FS_CASE_SENSITIVE = FILE_CASE_SENSITIVE_SEARCH;
pub const DECLSPEC_UUID = x;
pub const CERT_ISSUER_PUBLIC_KEY_MD5_HASH_PROP_ID = 24;
pub const SUBLANG_JAPANESE_JAPAN = 1;
pub const TREE_CONNECT_ATTRIBUTE_INTEGRITY = 32768;
pub const CERT_ROOT_PROGRAM_FLAG_ORG = 128;
pub const ERROR_FLOPPY_BAD_REGISTERS = @as(c_long, 1125);
pub const GPT_ATTRIBUTE_PLATFORM_REQUIRED = 1;
pub const CTRY_BELARUS = 375;
pub const szOID_LOGOTYPE_EXT = "1.3.6.1.5.5.7.1.12";
pub const WB_LEFT = 0;
pub const FR_NOT_ENUM = 32;
pub const SHTDN_REASON_MAJOR_SOFTWARE = 196608;
pub const DeviceDsmAction_WriteZeroes = @as(c_uint, 25);
pub const ERROR_DS_CANT_RETRIEVE_CHILD = @as(c_long, 8422);
pub const CTL_FIND_SAME_USAGE_FLAG = 1;
pub const KLF_SUBSTITUTE_OK = 2;
pub const PRINTER_ACCESS_ADMINISTER = 4;
pub const ERROR_FT_WRITE_RECOVERY = @as(c_long, 705);
pub const DNS_ERROR_DP_NOT_ENLISTED = @as(c_long, 9903);
pub const DMPAPER_A4SMALL = 10;
pub const _WIN32_WINNT_WS08 = 1536;
pub const VarDecFromUint = VarDecFromUI4;
pub const DMDITHER_USER = 256;
pub const ERROR_DS_ATT_NOT_DEF_IN_SCHEMA = @as(c_long, 8303);
pub const IME_SMODE_PLAURALCLAUSE = 1;
pub const ERROR_SXS_XML_E_MISSINGROOT = @as(c_long, 14057);
pub const WINAPI = __stdcall;
pub const FAST_FAIL_INVALID_THREAD = 40;
pub const WSA_QOS_GENERIC_ERROR = @as(c_long, 11015);
pub const CERT_CHAIN_ENABLE_SERVER_AUTH_HYGIENE_FLAG = 2097152;
pub const MOUSEEVENTF_WHEEL = 2048;
pub const WSA_QOS_POLICY_FAILURE = @as(c_long, 11011);
pub const RPC_C_IMP_LEVEL_DEFAULT = 0;
pub const SECURITY_CREATOR_GROUP_SERVER_RID = @as(c_long, 3);
pub const CB_SETHORIZONTALEXTENT = 350;
pub const RPC_S_INVALID_VERS_OPTION = @as(c_long, 1756);
pub const MDM_V110_SPEED_9DOT6K = 4;
pub const PRINTER_CHANGE_ADD_JOB = 256;
pub const ERROR_FILE_TOO_LARGE = @as(c_long, 223);
pub const BS_MULTILINE = @as(c_long, 8192);
pub const LB_FINDSTRING = 399;
pub const WS_VSCROLL = @as(c_long, 2097152);
pub const SEC_LARGE_PAGES = 2147483648;
pub const ERROR_CTX_MODEM_RESPONSE_ERROR = @as(c_long, 7011);
pub const FACILITY_WSBAPP = 122;
pub const WINSTA_ENUMERATE = @as(c_long, 256);
pub const ERROR_MRM_INVALID_PRI_FILE = @as(c_long, 15126);
pub const NCRYPT_CLAIM_UNKNOWN = 4096;
pub const ERROR_CONTINUE = @as(c_long, 1246);
pub const CERT_TRUST_SSL_TIME_VALID = 16777216;
pub const szFORCE_KEY_PROTECTION = "ForceKeyProtection";
pub const JOB_OBJECT_CPU_RATE_CONTROL_MIN_MAX_RATE = 16;
pub const CRL_FIND_ISSUED_BY = 1;
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_BLOB = 1;
pub const JOB_NOTIFY_FIELD_PORT_NAME = 2;
pub const ACCESS_ALLOWED_COMPOUND_ACE_TYPE = 4;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_OWNER_ACE = 1;
pub const CERT_STORE_PROV_SYSTEM_REGISTRY_A = if (@typeId(@typeOf(12)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 12) else if (@typeId(@typeOf(12)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 12) else LPCSTR(12);
pub const FILE_ATTRIBUTE_PINNED = 524288;
pub const BAUD_1800 = if (@typeId(@typeOf(128)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 128) else if (@typeId(@typeOf(128)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 128) else DWORD(128);
pub const CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL = 262144;
pub const __data_entrypoint = category;
pub const QS_ALLPOSTMESSAGE = 256;
pub const JOY_BUTTON17 = @as(c_long, 65536);
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_ENABLE_TEST_ROOT_FLAG = 65536;
pub const EnumUILanguages = EnumUILanguagesA;
pub const ReadConsole = ReadConsoleA;
pub const PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_NO_LOW_LABEL_DEFER = if (@typeId(@typeOf(i64 << 56)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), i64 << 56) else if (@typeId(@typeOf(i64 << 56)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), i64 << 56) else @as(c_uint, 0)(i64 << 56);
pub const MM_MIM_LONGDATA = 964;
pub const SM_CXICONSPACING = 38;
pub const ERROR_MAGAZINE_NOT_PRESENT = @as(c_long, 1163);
pub const WM_POINTERDOWN = 582;
pub const WNNC_NET_FRONTIER = 1507328;
pub const RPC_S_ZERO_DIVIDE = @as(c_long, 1767);
pub const DNS_ERROR_POLICY_INVALID_CRITERIA = @as(c_long, 9973);
pub const CAL_SMONTHNAME8 = 28;
pub const GetAtomName = GetAtomNameA;
pub const CreateIC = CreateICA;
pub const ERROR_SERVICE_DATABASE_LOCKED = @as(c_long, 1055);
pub const ERROR_DS_NOT_AN_OBJECT = @as(c_long, 8352);
pub const JOY_RETURNRAWDATA = @as(c_long, 256);
pub const LB_ERR = -1;
pub const ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT = @as(c_long, 6728);
pub const USER_MARSHAL_FC_USHORT = 7;
pub const szOID_ECC_CURVE_X962P239V3 = "1.2.840.10045.3.1.6";
pub const CSV_QUERY_MDS_PATH_FLAG_SMB_BYPASS_CSV_ENABLED = 4;
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NOT_FOUND = 4096;
pub const GETPRINTINGOFFSET = 13;
pub const URLACTION_XPS_DOCUMENTS = 9217;
pub const SPI_GETLOGICALDPIOVERRIDE = 158;
pub const PROPSETFLAG_DEFAULT = 0;
pub const EVENTLOG_END_ALL_PAIRED_EVENTS = 4;
pub const WSAEUSERS = @as(c_long, 10068);
pub const ERROR_LOCKED = @as(c_long, 212);
pub const NCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION = BCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION;
pub const ERROR_IPSEC_DOSP_INVALID_PACKET = @as(c_long, 13927);
pub const WSA_QOS_ESHAPERATEOBJ = @as(c_long, 11030);
pub const SETWALLPAPER_DEFAULT = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(LPWSTR, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(LPWSTR, -1) else LPWSTR(-1);
pub const EMARCH_ENC_I17_SIGN_VAL_POS_X = 63;
pub const REG_OPTION_DONT_VIRTUALIZE = @as(c_long, 16);
pub const MDM_AUTO_ML_DEFAULT = 0;
pub const HTERROR = -2;
pub const cPRIV_KEY_CACHE_MAX_ITEMS_DEFAULT = 20;
pub const CERT_STORE_PROV_PKCS12 = if (@typeId(@typeOf(17)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 17) else if (@typeId(@typeOf(17)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 17) else LPCSTR(17);
pub const PSD_DISABLEMARGINS = 16;
pub const CreateFontIndirectEx = CreateFontIndirectExA;
pub const PRODUCT_DATACENTER_SERVER_CORE = 12;
pub const SCRUB_DATA_OUTPUT_FLAG_RESUME_CONTEXT_LENGTH_SPECIFIED = 262144;
pub const DragQueryFile = DragQueryFileA;
pub const NCRYPT_ECDSA_ALGORITHM = BCRYPT_ECDSA_ALGORITHM;
pub const ERROR_CLOUD_FILE_READ_ONLY_VOLUME = @as(c_long, 381);
pub const SOCK_SEQPACKET = 5;
pub const FILE_DISPOSITION_FLAG_FORCE_IMAGE_SECTION_CHECK = 4;
pub const ERROR_NOINTERFACE = @as(c_long, 632);
pub const SetPrinter = SetPrinterA;
pub const PSH_WIZARD = 32;
pub const ENHMETA_SIGNATURE = 1179469088;
pub const GetUserObjectInformation = GetUserObjectInformationA;
pub const CAL_SMONTHNAME11 = 31;
pub const JOB_OBJECT_NET_RATE_CONTROL_MAX_DSCP_TAG = 64;
pub const CONNECT_INTERACTIVE = 8;
pub const SM_CYFRAME = 33;
pub const FRS_ERR_STOPPING_SERVICE = @as(c_long, 8003);
pub const JOB_STATUS_PAUSED = 1;
pub const rct1 = 1080;
pub const SP_BAUD = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 2) else DWORD(2);
pub const WAVE_FORMAT_44M08 = 256;
pub const META_SETTEXTCHAREXTRA = 264;
pub const RPC_C_PROFILE_MATCH_BY_IF = 2;
pub const ERROR_NO_VOLUME_ID = @as(c_long, 1173);
pub const SPI_SETMOUSESONAR = 4125;
pub const BAUD_USER = if (@typeId(@typeOf(268435456)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 268435456) else if (@typeId(@typeOf(268435456)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 268435456) else DWORD(268435456);
pub const ERROR_DS_DUP_MSDS_INTID = @as(c_long, 8597);
pub const GMEM_SHARE = 8192;
pub const ECONNRESET = 108;
pub const SW_FORCEMINIMIZE = 11;
pub const WNNC_NET_DAV = 3014656;
pub const MM_MOM_OPEN = 967;
pub const REVERSE_PRINT = 1;
pub const PRSPEC_PROPID = 1;
pub const CreateDirectory = CreateDirectoryA;
pub const UNALIGNED64 = __unaligned;
pub const WN_NO_NETWORK = ERROR_NO_NETWORK;
pub const SCM_PD_PROPERTY_NAME_LENGTH_IN_CHARS = 128;
pub const HANGUP_PENDING = 4;
pub const GetComputerName = GetComputerNameA;
pub const OFFLOAD_READ_FLAG_ALL_ZERO_BEYOND_CURRENT_RANGE = 1;
pub const MDM_V110_SPEED_57DOT6K = 10;
pub const ERROR_DS_ADD_REPLICA_INHIBITED = @as(c_long, 8302);
pub const szOID_NT_PRINCIPAL_NAME = "1.3.6.1.4.1.311.20.2.3";
pub const s_host = S_un.S_un_b.s_b2;
pub const NTSYSCALLAPI = DECLSPEC_IMPORT;
pub const ERROR_UNKNOWN_PORT = @as(c_long, 1796);
pub const szPRIV_KEY_CACHE_MAX_ITEMS = "PrivKeyCacheMaxItems";
pub const ERROR_CANNOT_BREAK_OPLOCK = @as(c_long, 802);
pub const GCL_HCURSOR = -12;
pub const FACILITY_MSMQ = 14;
pub const TAPE_DRIVE_WRITE_FILEMARKS = 2181038080;
pub const IMAGE_DEBUG_TYPE_EXCEPTION = 5;
pub const DM_LOGPIXELS = @as(c_long, 131072);
pub const ERROR_CLOUD_FILE_NOT_IN_SYNC = @as(c_long, 377);
pub const __UINT_FAST16_FMTx__ = "hx";
pub const MCI_VD_STATUS_SPEED = @as(c_long, 16386);
pub const ERROR_DISK_TOO_FRAGMENTED = @as(c_long, 302);
pub const SS_WORDELLIPSIS = @as(c_long, 49152);
pub const CERT_NAME_STR_NO_QUOTING_FLAG = 268435456;
pub const STARTF_TITLEISAPPID = 4096;
pub const CHAR_BIT = 8;
pub const FADF_HAVEIID = 64;
pub const CHANGER_STORAGE_SLOT = 16384;
pub const PSH_RESIZABLE = 67108864;
pub const ERROR_DS_CANT_DELETE_DSA_OBJ = @as(c_long, 8340);
pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1 = 1;
pub const LOAD_WITH_ALTERED_SEARCH_PATH = 8;
pub const szOID_RDN_TPM_VERSION = "2.23.133.2.3";
pub const SSWF_DISPLAY = 3;
pub const TREE_CONNECT_ATTRIBUTE_PINNED = 2;
pub const URLACTION_SHELL_PREVIEW = 6159;
pub const ERROR_INVALID_CRUNTIME_PARAMETER = @as(c_long, 1288);
pub const WSAENOTSOCK = @as(c_long, 10038);
pub const ERROR_EC_CRED_NOT_FOUND = @as(c_long, 15084);
pub const RPCFLG_SENDER_WAITING_FOR_REPLY = @as(c_ulong, 8388608);
pub const ELF_CULTURE_LATIN = 0;
pub const CREDENTIAL_OID_PASSWORD_CREDENTIALS_W = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 2) else LPCSTR(2);
pub const IMAGE_SYM_CLASS_UNDEFINED_LABEL = 7;
pub const JOY_BUTTON16 = @as(c_long, 32768);
pub const LANG_FRISIAN = 98;
pub const EMR_EXCLUDECLIPRECT = 29;
pub const OemToCharBuff = OemToCharBuffA;
pub const __UINT_LEAST16_MAX__ = 65535;
pub const WSA_QOS_BAD_STYLE = @as(c_long, 11012);
pub const ANYSIZE_ARRAY = 1;
pub const PROFILE_KERNEL = 536870912;
pub const JOYCAPS_POVCTS = 64;
pub const DMCOLLATE_FALSE = 0;
pub const __SAL_H_VERSION = 180000000;
pub const PRINTER_ATTRIBUTE_ENABLE_DEVQ = 128;
pub const SECURITY_IUSER_RID = @as(c_long, 17);
pub const __UINT8_FMTu__ = "hhu";
pub const CAL_SMONTHNAME9 = 29;
pub const DNS_ERROR_ADDRESS_REQUIRED = @as(c_long, 9573);
pub const EnumResourceNamesEx = EnumResourceNamesExA;
pub const SECURITY_PARENT_PACKAGE_RID_COUNT = SECURITY_APP_PACKAGE_RID_COUNT;
pub const COMMON_LVB_REVERSE_VIDEO = 16384;
pub const ULW_COLORKEY = 1;
pub const VP_FLAGS_MAX_UNSCALED = 16;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_LEFT = 218;
pub const CreateHardLink = CreateHardLinkA;
pub const LOAD_IGNORE_CODE_AUTHZ_LEVEL = 16;
pub const CONNECT_UPDATE_RECENT = 2;
pub const NotifyServiceStatusChange = NotifyServiceStatusChangeA;
pub const STATUS_FLOAT_MULTIPLE_TRAPS = if (@typeId(@typeOf(@as(c_long, 3221226165))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221226165)) else if (@typeId(@typeOf(@as(c_long, 3221226165))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221226165)) else DWORD(@as(c_long, 3221226165));
pub const CA_NEGATIVE = 1;
pub const JOY_CAL_READ6 = @as(c_long, 8388608);
pub const NCRYPT_IMPL_REMOVABLE_FLAG = 8;
pub const PCF_XONXOFF = if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 16) else if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 16) else DWORD(16);
pub const WM_POINTERUPDATE = 581;
pub const ERROR_DEV_NOT_EXIST = @as(c_long, 55);
pub const ERROR_EVT_VERSION_TOO_OLD = @as(c_long, 15034);
pub const CERT_CHAIN_MIN_RSA_PUB_KEY_BIT_LENGTH_DEFAULT = 1023;
pub const FILE_VER_GET_LOCALISED = 1;
pub const WNetCancelConnection2 = WNetCancelConnection2A;
pub const PARTITION_SYSTEM = 239;
pub const EnumPrinterDataEx = EnumPrinterDataExA;
pub const ERROR_RESOURCE_FAILED = @as(c_long, 5038);
pub const MCI_DEVTYPE_VIDEODISC = 514;
pub const NTDDI_WINXPSP4 = 83952640;
pub const DM_PAPERSIZE = @as(c_long, 2);
pub const WM_RENDERALLFORMATS = 774;
pub const SUBLANG_ROMANIAN_ROMANIA = 1;
pub const szOID_TITLE = "2.5.4.12";
pub const ERROR_ALREADY_WAITING = @as(c_long, 1904);
pub const CAL_SMONTHNAME10 = 30;
pub const TAPE_DRIVE_HIGH_FEATURES = 2147483648;
pub const RESTART_NO_CRASH = 1;
pub const MDITILE_VERTICAL = 0;
pub const PF_MONITORX_INSTRUCTION_AVAILABLE = 35;
pub const CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_PARTIAL_CHAIN_LOGGING_FLAG = 2;
pub const SEC_64K_PAGES = 524288;
pub const ERROR_INVALID_OWNER = @as(c_long, 1307);
pub const TPM_HORPOSANIMATION = @as(c_long, 1024);
pub const _Success_impl_ = expr;
pub const PFD_DEPTH_DONTCARE = 536870912;
pub const NUMRESERVED = 106;
pub const CHANGER_MEDIUM_FLIP = 512;
pub const IMAGE_SYM_TYPE_NULL = 0;
pub const LOCALE_SMONTHNAME1 = 56;
pub const ABSOLUTE = 1;
pub const ERROR_DS_NAME_TYPE_UNKNOWN = @as(c_long, 8351);
pub const MDM_V110_SPEED_DEFAULT = 0;
pub const ERROR_PRINTER_DRIVER_IN_USE = @as(c_long, 3001);
pub const NTM_MULTIPLEMASTER = 524288;
pub const PKCS_PRIVATE_KEY_INFO = if (@typeId(@typeOf(44)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 44) else if (@typeId(@typeOf(44)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 44) else LPCSTR(44);
pub const COMPRESSION_FORMAT_LZNT1 = 2;
pub const VTBIT_UI4 = 1 << VT_UI4;
pub const TAPE_DRIVE_FIXED_BLOCK = 1024;
pub const SUBLANG_UPPER_SORBIAN_GERMANY = 1;
pub const ERROR_LOGON_NOT_GRANTED = @as(c_long, 1380);
pub const CERT_NAME_DNS_TYPE = 6;
pub const NCRYPT_CAPI_KDF_ALGORITHM = BCRYPT_CAPI_KDF_ALGORITHM;
pub const DISPLAYCONFIG_PATH_VALID_FLAGS = 13;
pub const FILE_SUPPORTS_BLOCK_REFCOUNTING = 134217728;
pub const OFN_OVERWRITEPROMPT = 2;
pub const NRC_INUSE = 22;
pub const SMART_ABORT_OFFLINE_SELFTEST = 127;
pub const ImmRegisterWord = ImmRegisterWordA;
pub const PP_IMPTYPE = 3;
pub const CRYPT_NDR_ENCODING = 2;
pub const ERROR_SXS_CORRUPTION = @as(c_long, 14083);
pub const WS_DLGFRAME = @as(c_long, 4194304);
pub const ORD_LANGDRIVER = 1;
pub const MMSYSERR_BASE = 0;
pub const MIDIPATCHSIZE = 128;
pub const MINSSIZE_T = if (@typeId(@typeOf(~MAXSSIZE_T)) == @import("builtin").TypeId.Pointer) @ptrCast(SSIZE_T, ~MAXSSIZE_T) else if (@typeId(@typeOf(~MAXSSIZE_T)) == @import("builtin").TypeId.Int) @intToPtr(SSIZE_T, ~MAXSSIZE_T) else SSIZE_T(~MAXSSIZE_T);
pub const NCRYPTBUFFER_CERT_BLOB = 47;
pub const ABM_SETPOS = 3;
pub const LANG_AZERI = 44;
pub const LANG_ODIA = 72;
pub const CS_CLASSDC = 64;
pub const FRS_ERR_INTERNAL = @as(c_long, 8005);
pub const SPI_GETSNAPTODEFBUTTON = 95;
pub const CERT_TRUST_IS_NOT_VALID_FOR_USAGE = 16;
pub const PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_ON = if (@typeId(@typeOf(i64 << 44)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << 44) else if (@typeId(@typeOf(i64 << 44)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << 44) else @as(c_uint, 1)(i64 << 44);
pub const ERROR_BAD_LOGON_SESSION_STATE = @as(c_long, 1365);
pub const CMC_FAIL_MUST_ARCHIVE_KEYS = 6;
pub const PM_QS_INPUT = QS_INPUT << 16;
pub const PRODUCT_PROFESSIONAL_N = 49;
pub const ERROR_NO_GUID_TRANSLATION = @as(c_long, 560);
pub const CRYPT_OWF_REPL_LM_HASH = 1;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION = 140;
pub const DMPAPER_PENV_9_ROTATED = 117;
pub const SUBLANG_GERMAN_LIECHTENSTEIN = 5;
pub const __FLT16_MAX_EXP__ = 15;
pub const SBS_RIGHTALIGN = @as(c_long, 4);
pub const EMR_INVERTRGN = 73;
pub const CTRY_MOROCCO = 212;
pub const ERROR_INSTALL_TRANSFORM_FAILURE = @as(c_long, 1624);
pub const ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING = @as(c_long, 8474);
pub const MIIM_STRING = 64;
pub const ERROR_NODE_CANT_HOST_RESOURCE = @as(c_long, 5071);
pub const MCI_FORMAT_MSF = 2;
pub const PSH_STRETCHWATERMARK = 262144;
pub const CMC_DATA = if (@typeId(@typeOf(59)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 59) else if (@typeId(@typeOf(59)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 59) else LPCSTR(59);
pub const SCARD_UNKNOWN = 0;
pub const SCARD_CLASS_VENDOR_DEFINED = 7;
pub const ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION = @as(c_long, 13880);
pub const CMC_STATUS_FAILED = 2;
pub const szOID_ANY_ENHANCED_KEY_USAGE = "2.5.29.37.0";
pub const RPC_C_PROFILE_ALL_ELTS = RPC_C_PROFILE_ALL_ELT;
pub const SCARD_SWALLOWED = 3;
pub const szOID_MEMBER = "2.5.4.31";
pub const DOMAIN_ALIAS_RID_RDS_REMOTE_ACCESS_SERVERS = @as(c_long, 575);
pub const JOY_BUTTON11 = @as(c_long, 1024);
pub const SECURITY_VIRTUALSERVER_ID_RID_COUNT = @as(c_long, 6);
pub const CRYPT_ENABLE_SSL_REVOCATION_RETRIEVAL = 8388608;
pub const ERROR_PARAMETER_QUOTA_EXCEEDED = @as(c_long, 1283);
pub const CMSG_SIGNER_CERT_INFO_PARAM = 7;
pub const IMFS_DEFAULT = MFS_DEFAULT;
pub const IMAGE_REL_PPC_REL24 = 6;
pub const OUT_TT_PRECIS = 4;
pub const PROV_EC_ECDSA_SIG = 14;
pub const IMAGE_FILE_MACHINE_MIPS16 = 614;
pub const ERROR_FAILED_DRIVER_ENTRY = @as(c_long, 647);
pub const WM_IME_KEYUP = 657;
pub const FILE_SUPPORTS_SPARSE_FILES = 64;
pub const DiskClassGuid = GUID_DEVINTERFACE_DISK;
pub const CERT_STORE_DELTA_CRL_FLAG = 512;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS = 51;
pub const CRYPT_WRITE = 16;
pub const ERROR_NOT_TINY_STREAM = @as(c_long, 598);
pub const ERROR_DS_HIGH_ADLDS_FFL = @as(c_long, 8641);
pub const MCI_SEQ_STATUS_DIVTYPE = @as(c_long, 16394);
pub const ERROR_DATA_NOT_ACCEPTED = @as(c_long, 592);
pub const JOY_CAL_READ5 = @as(c_long, 4194304);
pub const PRODUCT_WEB_SERVER_CORE = 29;
pub const STORAGE_RPMB_DESCRIPTOR_VERSION_1 = 1;
pub const ERROR_AUDIT_FAILED = @as(c_long, 606);
pub const MCI_SEQ_OFFSET = 1216;
pub const SPI_SETPOWEROFFTIMEOUT = 82;
pub const IMAGE_REL_ALPHA_REFLONG = 1;
pub const MCI_WAVE_SET_FORMATTAG = @as(c_long, 65536);
pub const OF_CREATE = 4096;
pub const RPC_C_OPT_BINDING_NONCAUSAL = 9;
pub const STATUS_ALREADY_REGISTERED = if (@typeId(@typeOf(@as(c_long, 3221227288))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221227288)) else if (@typeId(@typeOf(@as(c_long, 3221227288))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221227288)) else DWORD(@as(c_long, 3221227288));
pub const ERROR_DS_OBJECT_BEING_REMOVED = @as(c_long, 8339);
pub const IPPORT_LOGINSERVER = 513;
pub const ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER = @as(c_long, 8520);
pub const SetWindowLong = SetWindowLongA;
pub const VK_GAMEPAD_VIEW = 208;
pub const CHILDID_SELF = 0;
pub const ERROR_TRANSACTION_OBJECT_EXPIRED = @as(c_long, 6722);
pub const __DBL_MANT_DIG__ = 53;
pub const TIME_TICKS = 32;
pub const FACILITY_LEAP = 2184;
pub const DMDITHER_RESERVED7 = 7;
pub const IMAGE_REL_EBC_SECTION = 3;
pub const WAVE_FORMAT_2S16 = 128;
pub const FILE_APPEND_DATA = 4;
pub const CAL_SMONTHNAME13 = 33;
pub const SE_ERR_DDEBUSY = 30;
pub const szOID_OIWSEC_dsaCommSHA = "1.3.14.3.2.21";
pub const WN_BAD_NETNAME = ERROR_BAD_NET_NAME;
pub const __SIZEOF_SIZE_T__ = 8;
pub const COMMON_LVB_GRID_RVERTICAL = 4096;
pub const PRINTER_ATTRIBUTE_PUSHED_MACHINE = 262144;
pub const MCI_SET_AUDIO_ALL = @as(c_long, 0);
pub const CONTEXT_OID_CRL = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 2) else LPCSTR(2);
pub const szOID_ANY_APPLICATION_POLICY = "1.3.6.1.4.1.311.10.12.1";
pub const GMEM_MOVEABLE = 2;
pub const ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS = @as(c_long, 5918);
pub const CMSG_MAIL_LIST_VERSION = CMSG_ENVELOPED_RECIPIENT_V4;
pub const LOCALE_SMONTHNAME6 = 61;
pub const USN_REASON_DESIRED_STORAGE_CLASS_CHANGE = 16777216;
pub const CERT_RENEWAL_PROP_ID = 64;
pub const GET_VOLUME_BITMAP_FLAG_MASK_METADATA = 1;
pub const EMR_POLYLINETO = 6;
pub const ImmInstallIME = ImmInstallIMEA;
pub const WN_ALREADY_CONNECTED = ERROR_ALREADY_ASSIGNED;
pub const GID_TWOFINGERTAP = 6;
pub const SE_DACL_AUTO_INHERIT_REQ = 256;
pub const szOID_PKIX_KP_SERVER_AUTH = "1.3.6.1.5.5.7.3.1";
pub const __WINT_WIDTH__ = 16;
pub const CTRY_MACEDONIA = 389;
pub const ERROR_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS = @as(c_long, 374);
pub const CRYPT_RETRIEVE_MULTIPLE_OBJECTS = 1;
pub const NAME_FLAGS_MASK = 135;
pub const CB_SETEXTENDEDUI = 341;
pub const TRANSACTION_SET_INFORMATION = 2;
pub const WNNC_NET_RSFX = 4194304;
pub const CERT_CHAIN_ENABLE_WEAK_LOGGING_FLAG = 4;
pub const C2_NOTAPPLICABLE = 0;
pub const szOID_ECC_CURVE_SECP256K1 = "1.3.132.0.10";
pub const CERT_RDN_FLAGS_MASK = 4278190080;
pub const JOB_STATUS_DELETING = 4;
pub const _Deref_pre1_impl_ = p1;
pub const LPPROPSHEETPAGE = LPPROPSHEETPAGEA;
pub const CMSG_CONTENT_PARAM = 2;
pub const SEF_AVOID_OWNER_RESTRICTION = 4096;
pub const ERROR_OBJECT_NOT_FOUND = @as(c_long, 4312);
pub const VK_RCONTROL = 163;
pub const ERROR_WX86_WARNING = @as(c_long, 539);
pub const BN_DBLCLK = BN_DOUBLECLICKED;
pub const MKF_MODIFIERS = 64;
pub const ERROR_DS_RESERVED_MAPI_ID = @as(c_long, 8631);
pub const CFG_CALL_TARGET_VALID = 1;
pub const ENLISTMENT_SUPERIOR = 1;
pub const WINADVAPI = DECLSPEC_IMPORT;
pub const CBN_SELCHANGE = 1;
pub const MCI_PASTE = 2131;
pub const MEM_COALESCE_PLACEHOLDERS = 1;
pub const SUBLANG_ENGLISH_BELIZE = 10;
pub const GETFACENAME = 513;
pub const OBJID_SIZEGRIP = if (@typeId(@typeOf(4294967289)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG, 4294967289) else if (@typeId(@typeOf(4294967289)) == @import("builtin").TypeId.Int) @intToPtr(LONG, 4294967289) else LONG(4294967289);
pub const CERT_STORE_SHARE_CONTEXT_FLAG = 128;
pub const szOID_PKIX_ACC_DESCR = "1.3.6.1.5.5.7.48";
pub const S_PERIOD2048 = 2;
pub const SUBLANG_BANGLA_BANGLADESH = 2;
pub const CERT_DECIPHER_ONLY_KEY_USAGE = 128;
pub const WriteSizeTRaw = WriteULongPtrRaw;
pub const DeviceDsmAction_Trim = @as(c_uint, 1);
pub const METRICS_USEDEFAULT = -1;
pub const ANSI_NULL = if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(CHAR, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(CHAR, 0) else CHAR(0);
pub const VP_FLAGS_TV_MODE = 1;
pub const URLDownloadToCacheFile = URLDownloadToCacheFileA;
pub const NF_QUERY = 3;
pub const ERROR_IPSEC_IKE_NEG_STATUS_BEGIN = @as(c_long, 13800);
pub const FILE_INITIATE_REPAIR_HINT1_INDEX_ENTRY_MISMATCH = 1099511627776;
pub const WN_BAD_PROVIDER = ERROR_BAD_PROVIDER;
pub const STATE_SYSTEM_MULTISELECTABLE = 16777216;
pub const CERT_SYSTEM_STORE_RELOCATE_FLAG = 2147483648;
pub const JOY_BUTTON10 = @as(c_long, 512);
pub const SP_PARITY = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 1) else DWORD(1);
pub const SE_ERR_OOM = 8;
pub const SM_CYSCREEN = 1;
pub const DOMAIN_ALIAS_RID_USERS = @as(c_long, 545);
pub const ENOEXEC = 8;
pub const WM_PENWINLAST = 911;
pub const PPM_FIRMWARE_OSC = 65536;
pub const FILE_DEVICE_SDFXHCI = 92;
pub const szOID_PKCS_7_ENCRYPTED = "1.2.840.113549.1.7.6";
pub const KDF_KEYBITLENGTH = 18;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_TRANSPORT_PROTOCOL = @as(c_long, 9991);
pub const ERROR_NO_SUCH_PACKAGE = @as(c_long, 1364);
pub const IMAGE_REL_IA64_SECREL32 = 14;
pub const EXCEPTION_DEBUG_EVENT = 1;
pub const RPC_S_INVALID_AUTH_IDENTITY = @as(c_long, 1749);
pub const MNGO_NOINTERFACE = 0;
pub const ERROR_STATE_ENUMERATE_SETTINGS_FAILED = @as(c_long, 15814);
pub const CERT_ALT_NAME_X400_ADDRESS = 4;
pub const ERROR_DS_DRA_PREEMPTED = @as(c_long, 8461);
pub const SetFirmwareEnvironmentVariableEx = SetFirmwareEnvironmentVariableExA;
pub const NETSCAPE_SSL_SERVER_AUTH_CERT_TYPE = 64;
pub const ENDSESSION_LOGOFF = 2147483648;
pub const URLACTION_SHELL_WEBVIEW_VERB = 6149;
pub const CERT_SELECT_HARDWARE_ONLY = 64;
pub const SERVICE_DEMAND_START = 3;
pub const JOY_CAL_READ4 = @as(c_long, 524288);
pub const ERROR_BAD_PIPE = @as(c_long, 230);
pub const MIM_OPEN = MM_MIM_OPEN;
pub const FW_BLACK = FW_HEAVY;
pub const SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE = 2;
pub const PF_SNA = AF_SNA;
pub const URLPOLICY_JAVA_LOW = 196608;
pub const ERROR_LOG_MULTIPLEXED = @as(c_long, 6630);
pub const SKF_AVAILABLE = 2;
pub const ENETDOWN = 116;
pub const IMAGE_REL_AMD64_ADDR32NB = 3;
pub const ODS_NOFOCUSRECT = 512;
pub const X509_POLICY_CONSTRAINTS = if (@typeId(@typeOf(57)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 57) else if (@typeId(@typeOf(57)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 57) else LPCSTR(57);
pub const ERROR_PRINTER_DRIVER_PACKAGE_IN_USE = @as(c_long, 3015);
pub const MAX_FW_BUCKET_ID_LENGTH = 132;
pub const BCRYPT_DESX_ECB_ALG_HANDLE = if (@typeId(@typeOf(561)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 561) else if (@typeId(@typeOf(561)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 561) else BCRYPT_ALG_HANDLE(561);
pub const FACILITY_P2P = 99;
pub const LANG_GREEK = 8;
pub const FILE_DISPOSITION_FLAG_DELETE = 1;
pub const RC_SAVEBITMAP = 64;
pub const LANG_SINDHI = 89;
pub const DMDITHER_RESERVED6 = 6;
pub const CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG = 2147483648;
pub const CERT_ISSUER_PUB_KEY_BIT_LENGTH_PROP_ID = 94;
pub const MDM_V120_ML_2 = 2;
pub const SPI_GETLOWPOWERACTIVE = 83;
pub const _INTEGRAL_MAX_BITS = 64;
pub const CB_SETITEMDATA = 337;
pub const DBG_PRINTEXCEPTION_C = if (@typeId(@typeOf(@as(c_long, 1073807366))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 1073807366)) else if (@typeId(@typeOf(@as(c_long, 1073807366))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 1073807366)) else DWORD(@as(c_long, 1073807366));
pub const CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC = "CryptMsgDllExportEncryptKey";
pub const CAL_SMONTHNAME12 = 32;
pub const rct4 = 1083;
pub const CRYPT_OID_ENUM_SYSTEM_STORE_FUNC = "CertDllEnumSystemStore";
pub const NCBSSTAT = 52;
pub const XST_EXECSENT = 9;
pub const CDS_RESET = 1073741824;
pub const RPC_IF_OLE = 2;
pub const JOB_ACCESS_ADMINISTER = 16;
pub const __drv_typeCond = 1;
pub const szOID_DISALLOWED_LIST = "1.3.6.1.4.1.311.10.3.30";
pub const LOCALE_SMONTHNAME7 = 62;
pub const SHTDN_REASON_MINOR_MMC = 25;
pub const HBMMENU_CALLBACK = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(HBITMAP, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(HBITMAP, -1) else HBITMAP(-1);
pub const RPC_C_OPT_PRIVATE_SUPPRESS_WAKE = 1;
pub const MONITOR_DEFAULTTONULL = 0;
pub const ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD = @as(c_long, 8585);
pub const __drv_Mode_impl = x;
pub const GREEK_CHARSET = 161;
pub const LOCALE_INEGATIVEPERCENT = 116;
pub const CERT_ENCODING_TYPE_MASK = 65535;
pub const NUMPRS_HEX_OCT = 64;
pub const MEVT_VERSION = if (@typeId(@typeOf(132)) == @import("builtin").TypeId.Pointer) @ptrCast(BYTE, 132) else if (@typeId(@typeOf(132)) == @import("builtin").TypeId.Int) @intToPtr(BYTE, 132) else BYTE(132);
pub const PEERDIST_ERROR_OUT_OF_BOUNDS = @as(c_long, 4061);
pub const IME_ITHOTKEY_UISTYLE_TOGGLE = 514;
pub const ULW_EX_NORESIZE = 8;
pub const COLOR_BTNHILIGHT = COLOR_BTNHIGHLIGHT;
pub const GEO_NAME_USER_DEFAULT = NULL;
pub const szOID_NETSCAPE_DATA_TYPE = "2.16.840.1.113730.2";
pub const SECURITY_APPPOOL_ID_RID_COUNT = @as(c_long, 6);
pub const ALG_SID_ECDH = 5;
pub const URLACTION_ALLOW_ZONE_ELEVATION_VIA_OPT_OUT = 9989;
pub const PROCESS_CREATION_MITIGATION_POLICY_DEP_ENABLE = 1;
pub const EMR_SELECTPALETTE = 48;
pub const DMBIN_USER = 256;
pub const ERROR_CONNECTION_ACTIVE = @as(c_long, 1230);
pub const ERROR_SERVER_HAS_OPEN_HANDLES = @as(c_long, 1811);
pub const ERROR_EC_LOG_DISABLED = @as(c_long, 15081);
pub const STATUS_CONTROL_C_EXIT = if (@typeId(@typeOf(@as(c_long, 3221225786))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225786)) else if (@typeId(@typeOf(@as(c_long, 3221225786))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225786)) else DWORD(@as(c_long, 3221225786));
pub const DCB_RESET = 1;
pub const CERT_ALT_NAME_RFC822_NAME = 2;
pub const PERF_COUNTER_FRACTION = 131072;
pub const Uri_CREATE_NORMALIZE_INTL_CHARACTERS = 65536;
pub const RPC_X_SS_CHAR_TRANS_OPEN_FAIL = @as(c_long, 1773);
pub const AccessCheckByTypeAndAuditAlarm = AccessCheckByTypeAndAuditAlarmA;
pub const FRS_ERR_SYSVOL_IS_BUSY = @as(c_long, 8015);
pub const RIDEV_EXCLUDE = 16;
pub const META_SETLAYOUT = 329;
pub const SetEnvironmentStrings = SetEnvironmentStringsA;
pub const BACKUP_GHOSTED_FILE_EXTENTS = 11;
pub const __RPC_STUB = __stdcall;
pub const NCRYPT_NO_PADDING_FLAG = 1;
pub const TT_PRIM_CSPLINE = 3;
pub const SCARD_CLASS_COMMUNICATIONS = 2;
pub const WNNC_NET_EXIFS = 2949120;
pub const PSH_WIZARD_LITE = 4194304;
pub const ITALIC_FONTTYPE = 512;
pub const MAX_VOLUME_ID_SIZE = 36;
pub const CAL_HEBREW = 8;
pub const MM_LOMETRIC = 2;
pub const Uri_DISPLAY_NO_FRAGMENT = 1;
pub const SOUND_SYSTEM_MAXIMIZE = 8;
pub const RPC_C_BINDING_MIN_TIMEOUT = 0;
pub const FMFD_RETURNUPDATEDIMGMIMES = 32;
pub const sndPlaySound = sndPlaySoundA;
pub const SKF_RSHIFTLOCKED = 131072;
pub const CSV_QUERY_MDS_PATH_FLAG_STORAGE_ON_THIS_NODE_IS_CONNECTED = 1;
pub const EWX_SHUTDOWN = 1;
pub const GIDC_REMOVAL = 2;
pub const CRYPT_DONT_VERIFY_SIGNATURE = 256;
pub const CRYPT_OID_UNREGISTER_PHYSICAL_STORE_FUNC = "CertDllUnregisterPhysicalStore";
pub const ERROR_REPLY_MESSAGE_MISMATCH = @as(c_long, 595);
pub const SEF_AVOID_OWNER_CHECK = 16;
pub const HEAP_OPTIMIZE_RESOURCES_CURRENT_VERSION = 1;
pub const IMAGE_REL_BASED_DIR64 = 10;
pub const LANG_BRETON = 126;
pub const CS_BYTEALIGNWINDOW = 8192;
pub const OCSP_REQUEST = if (@typeId(@typeOf(66)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 66) else if (@typeId(@typeOf(66)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 66) else LPCSTR(66);
pub const IMAGE_FILE_MACHINE_MIPSFPU16 = 1126;
pub const SHTDN_REASON_UNKNOWN = SHTDN_REASON_MINOR_NONE;
pub const PRODUCT_STANDARD_SERVER = 7;
pub const ERROR_WMI_DP_NOT_FOUND = @as(c_long, 4204);
pub const PRINTER_CONTROL_PAUSE = 1;
pub const JOY_BUTTON13 = @as(c_long, 4096);
pub const NTDDI_WIN2K = 83886080;
pub const DSS_MONO = 128;
pub const szOID_NETSCAPE_BASE_URL = "2.16.840.1.113730.1.2";
pub const MUI_FILEINFO_VERSION = 1;
pub const PROCESSOR_STRONGARM = 2577;
pub const SECTION_EXTEND_SIZE = 16;
pub const PF_VIRT_FIRMWARE_ENABLED = 21;
pub const MIDI_UNCACHE = 4;
pub const STGM_SHARE_DENY_READ = @as(c_long, 48);
pub const __UINT_LEAST16_FMTX__ = "hX";
pub const E2BIG = 7;
pub const MCI_SET_OFF = @as(c_long, 16384);
pub const VK_RMENU = 165;
pub const PAN_STROKE_GRADUAL_VERT = 4;
pub const EMR_INTERSECTCLIPRECT = 30;
pub const szOID_NIST_sha512 = "2.16.840.1.101.3.4.2.3";
pub const GC_PAN_WITH_INERTIA = 16;
pub const WSA_E_CANCELLED = @as(c_long, 10111);
pub const IME_SMODE_CONVERSATION = 16;
pub const sz_CERT_STORE_PROV_SYSTEM_W = "System";
pub const STORAGE_FAILURE_PREDICTION_CONFIG_V1 = 1;
pub const ERROR_TRANSACTION_REQUIRED_PROMOTION = @as(c_long, 6837);
pub const szOID_PLATFORM_MANIFEST_BINARY_ID = "1.3.6.1.4.1.311.10.3.28";
pub const USER_MARSHAL_FC_WCHAR = 5;
pub const URLACTION_ACTIVEX_ALLOW_TDC = 4620;
pub const ERROR_DS_DRA_ABANDON_SYNC = @as(c_long, 8462);
pub const NOTIFYICONDATA_V3_SIZE = NOTIFYICONDATAA_V3_SIZE;
pub const FILE_DEVICE_ACPI = 50;
pub const DMPAPER_PENV_6_ROTATED = 114;
pub const DNS_ERROR_AXFR = @as(c_long, 9752);
pub const KP_IV = 1;
pub const DLGC_WANTMESSAGE = 4;
pub const _WIN32_WINNT_WIN10 = 2560;
pub const DNS_ERROR_INVALID_SCOPE_NAME = @as(c_long, 9958);
pub const LOGON32_LOGON_NETWORK_CLEARTEXT = 8;
pub const DMRES_DRAFT = -1;
pub const IE_BAUDRATE = -12;
pub const KDF_TLS_PRF_LABEL = 4;
pub const CERT_CHAIN_ENABLE_MOTW_CODE_SIGNING_HYGIENE_FLAG = 33554432;
pub const BLACK_BRUSH = 4;
pub const BF_LEFT = 1;
pub const DNS_ERROR_DP_FSMO_ERROR = @as(c_long, 9906);
pub const PO_DELETE = 19;
pub const DNS_ERROR_ROLLOVER_ALREADY_QUEUED = @as(c_long, 9120);
pub const NCRYPT_RSA_ALGORITHM_GROUP = NCRYPT_RSA_ALGORITHM;
pub const LR_LOADMAP3DCOLORS = 4096;
pub const META_SETPOLYFILLMODE = 262;
pub const szOID_KP_CTL_USAGE_SIGNING = "1.3.6.1.4.1.311.10.3.1";
pub const RpcNsMgmtBindingUnexport = RpcNsMgmtBindingUnexportA;
pub const MDIS_ALLCHILDSTYLES = 1;
pub const CRYPT_SGC_ENUM = 4;
pub const CERT_CHAIN_AUTO_HPKP_RULE_INFO = 8;
pub const __UINT_LEAST8_FMTo__ = "hho";
pub const URLACTION_WINFX_SETUP = 9728;
pub const LOCALE_SMONTHNAME4 = 59;
pub const RESOURCEUSAGE_ATTACHED = 16;
pub const POINTER_MOD_SHIFT = 4;
pub const szOID_CMC_RECIPIENT_NONCE = "1.3.6.1.5.5.7.7.7";
pub const ENUM_CURRENT_SETTINGS = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, -1) else DWORD(-1);
pub const SERVICE_ACCEPT_PRESHUTDOWN = 256;
pub const FILE_FLAG_OVERLAPPED = 1073741824;
pub const PSH_USEHBMHEADER = 1048576;
pub const JOB_NOTIFY_TYPE = 1;
pub const ERROR_DATATYPE_MISMATCH = @as(c_long, 1629);
pub const VTBIT_UI1 = 1 << VT_UI1;
pub const ERROR_AUTODATASEG_EXCEEDS_64k = @as(c_long, 199);
pub const RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO = 268435456;
pub const CreateService = CreateServiceA;
pub const LCS_CALIBRATED_RGB = @as(c_long, 0);
pub const WPF_RESTORETOMAXIMIZED = 2;
pub const LANG_KOREAN = 18;
pub const InterlockedBitTestAndSetRelease = _interlockedbittestandset;
pub const THREAD_PROFILING_FLAG_DISPATCH = 1;
pub const PROPSETFLAG_NONSIMPLE = 1;
pub const EXCEPTION_NONCONTINUABLE = 1;
pub const ESB_DISABLE_RTDN = ESB_DISABLE_RIGHT;
pub const FILE_DEVICE_CD_ROM = 2;
pub const VBS_BASIC_PAGE_SYSTEM_CALL = 5;
pub const KP_PADDING = 3;
pub const VBS_BASIC_PAGE_UNMEASURED_DATA = 2;
pub const OUTPUT_DEBUG_STRING_EVENT = 8;
pub const InterlockedIncrement = _InterlockedIncrement;
pub const SW_MAX = 11;
pub const __deref_opt_inout_ecount_nz_opt = size;
pub const RPC_S_INVALID_LEVEL = ERROR_INVALID_PARAMETER;
pub const szOID_ECC_CURVE_X962P192V2 = "1.2.840.10045.3.1.2";
pub const WINGDIAPI = DECLSPEC_IMPORT;
pub const SEE_MASK_CONNECTNETDRV = 128;
pub const sz_CERT_STORE_PROV_SYSTEM_REGISTRY = sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W;
pub const MOUSETRAILS = 39;
pub const PROCESSOR_PERF_BOOST_POLICY_DISABLED = 0;
pub const ERROR_BAD_DEV_TYPE = @as(c_long, 66);
pub const PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_RESERVED = 3 << 20;
pub const __INT64_C_SUFFIX__ = LL;
pub const CRYPT_EXPORTABLE = 1;
pub const ERROR_FLOATED_SECTION = @as(c_long, 6846);
pub const CRYPTPROTECTMEMORY_BLOCK_SIZE = 16;
pub const ERROR_REGISTRATION_FROM_REMOTE_DRIVE_NOT_SUPPORTED = @as(c_long, 15647);
pub const SUBLANG_ENGLISH_TRINIDAD = 11;
pub const AW_BLEND = 524288;
pub const CERT_TRUST_IS_CA_TRUSTED = 16384;
pub const MAXDWORD64 = if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD64, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(DWORD64, 0) else DWORD64(0))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD64, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD64, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(DWORD64, 0) else DWORD64(0)) else if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD64, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(DWORD64, 0) else DWORD64(0))) == @import("builtin").TypeId.Int) @intToPtr(DWORD64, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD64, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(DWORD64, 0) else DWORD64(0)) else DWORD64(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD64, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(DWORD64, 0) else DWORD64(0));
pub const SetJob = SetJobA;
pub const CERT_STORE_PROV_DELETE_CERT_FUNC = 3;
pub const ERROR_NOT_DAX_MAPPABLE = @as(c_long, 421);
pub const STANDARD_RIGHTS_ALL = @as(c_long, 2031616);
pub const LB_SETCOLUMNWIDTH = 405;
pub const EMARCH_ENC_I17_IMM41a_INST_WORD_X = 1;
pub const szOID_TELEX_NUMBER = "2.5.4.21";
pub const MB_MODEMASK = @as(c_long, 12288);
pub const ERROR_CLUSTER_RESOURCE_IS_REPLICATED = @as(c_long, 5983);
pub const GetProfileSection = GetProfileSectionA;
pub const PPM_IDLE_IMPLEMENTATION_CSTATES = 1;
pub const LANG_NEPALI = 97;
pub const MCI_PLAY = 2054;
pub const ERROR_TM_IDENTITY_MISMATCH = @as(c_long, 6845);
pub const IMAGE_SCN_MEM_LOCKED = 262144;
pub const MOD_RIGHT = 16384;
pub const MDM_HDLCPPP_SPEED_64K = 1;
pub const LOCALE_ENUMPROC = LOCALE_ENUMPROCA;
pub const WAVECAPS_PLAYBACKRATE = 2;
pub const PROCESSOR_MIPS_R4000 = 4000;
pub const PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_NO_REMOTE_ALWAYS_OFF = if (@typeId(@typeOf(i64 << 52)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 2), i64 << 52) else if (@typeId(@typeOf(i64 << 52)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 2), i64 << 52) else @as(c_uint, 2)(i64 << 52);
pub const FS_CYRILLIC = @as(c_long, 4);
pub const JOY_BUTTON12 = @as(c_long, 2048);
pub const POINTER_MESSAGE_FLAG_CONFIDENCE = 16384;
pub const LANG_ENGLISH = 9;
pub const PAN_WEIGHT_BOOK = 5;
pub const WM_STYLECHANGING = 124;
pub const BCRYPT_ALG_HANDLE_HMAC_FLAG = 8;
pub const QUERY_FILE_LAYOUT_INCLUDE_EXTENTS = 8;
pub const PAN_NO_FIT = 1;
pub const SCARD_STATE_MUTE = 512;
pub const _WIN32_IE_IE20 = 512;
pub const SM_SERVERR2 = 89;
pub const DPI_AWARENESS_CONTEXT_SYSTEM_AWARE = if (@typeId(@typeOf(-2)) == @import("builtin").TypeId.Pointer) @ptrCast(DPI_AWARENESS_CONTEXT, -2) else if (@typeId(@typeOf(-2)) == @import("builtin").TypeId.Int) @intToPtr(DPI_AWARENESS_CONTEXT, -2) else DPI_AWARENESS_CONTEXT(-2);
pub const TRUE = 1;
pub const RPC_C_OPT_TRUST_PEER = 14;
pub const PSPROTOCOL_ASCII = 0;
pub const GetSystemWow64Directory = GetSystemWow64DirectoryA;
pub const MCI_ANIM_REALIZE_BKGD = @as(c_long, 131072);
pub const _M_AMD64 = 100;
pub const CERT_LDAP_STORE_UNBIND_FLAG = 524288;
pub const DRV_DISABLE = 5;
pub const SM_SAMEDISPLAYFORMAT = 81;
pub const SM_CYSMSIZE = 53;
pub const __FLT16_DIG__ = 3;
pub const DOCKINFO_UNDOCKED = 1;
pub const RPCFLG_AUTO_COMPLETE = @as(c_ulong, 134217728);
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_APPLICATIONID_NOT_UNIQUE = @as(c_long, 15637);
pub const __NO_INLINE__ = 1;
pub const DATEFMT_ENUMPROCEX = DATEFMT_ENUMPROCEXA;
pub const WINSTA_CREATEDESKTOP = @as(c_long, 8);
pub const ERROR_EFS_VERSION_NOT_SUPPORT = @as(c_long, 6016);
pub const DNS_ERROR_ZONE_LOCKED = @as(c_long, 9607);
pub const MOD_NOREPEAT = 16384;
pub const SERVICE_STOP_REASON_MINOR_NONE = 23;
pub const SCS_WOW_BINARY = 2;
pub const META_PATBLT = 1565;
pub const VK_ADD = 107;
pub const szOID_PIN_RULES_DOMAIN_NAME = "1.3.6.1.4.1.311.10.3.34";
pub const MEM_EXTENDED_PARAMETER_NONPAGED_LARGE = 8;
pub const SUBLANG_BULGARIAN_BULGARIA = 1;
pub const ERROR_EVT_FILTER_INVTYPE = @as(c_long, 15018);
pub const NIS_SHAREDICON = 2;
pub const CMSG_SIGNER_INFO_V3 = 3;
pub const LOCALE_SMONDECIMALSEP = 22;
pub const GUI_POPUPMENUMODE = 16;
pub const ERROR_REGISTRY_QUOTA_LIMIT = @as(c_long, 613);
pub const DC_PAPERNAMES = 16;
pub const CERT_SYSTEM_STORE_CURRENT_SERVICE_ID = 4;
pub const X509_CERT_PAIR = if (@typeId(@typeOf(53)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 53) else if (@typeId(@typeOf(53)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 53) else LPCSTR(53);
pub const FACILITY_ACTION_QUEUE = 44;
pub const IPPORT_TTYLINK = 87;
pub const PRINTER_STATUS_PRINTING = 1024;
pub const LOW_SURROGATE_END = 57343;
pub const MoveFileWithProgress = MoveFileWithProgressA;
pub const RPC_S_INVALID_SECURITY_DESC = ERROR_INVALID_SECURITY_DESCR;
pub const ERROR_DS_DNS_LOOKUP_FAILURE = @as(c_long, 8524);
pub const TIME_NOMINUTESORSECONDS = 1;
pub const C3_HIGHSURROGATE = 2048;
pub const BS_PUSHBOX = @as(c_long, 10);
pub const ERROR_RESMON_INVALID_STATE = @as(c_long, 5084);
pub const IMEMENUITEM_STRING_SIZE = 80;
pub const NCRYPT_UI_PROTECT_KEY_FLAG = 1;
pub const SCS_32BIT_BINARY = 0;
pub const RPC_C_HTTP_AUTHN_SCHEME_NEGOTIATE = 16;
pub const WM_TABLET_LAST = 735;
pub const LOCALE_SMONTHNAME5 = 60;
pub const EVENT_SYSTEM_END = 255;
pub const JOB_OBJECT_LIMIT_WORKINGSET = 1;
pub const SUBLANG_ENGLISH_US = 1;
pub const NRC_BADDR = 7;
pub const FILE_REGION_USAGE_LARGE_PAGE_ALIGNMENT = 8;
pub const MAX_INTERFACE_CODES = 8;
pub const FILE_SUPPORTS_REMOTE_STORAGE = 256;
pub const LB_GETITEMDATA = 409;
pub const DATE_USE_ALT_CALENDAR = 4;
pub const szOID_PKCS = "1.2.840.113549.1";
pub const AF_NETBIOS = 17;
pub const SUBLANG_SAKHA_RUSSIA = 1;
pub const IS_TEXT_UNICODE_NOT_UNICODE_MASK = 3840;
pub const IMAGE_DEBUG_TYPE_REPRO = 16;
pub const GCL_WNDPROC = -24;
pub const SPI_GETMOUSECLICKLOCK = 4126;
pub const X509_INTEGER = if (@typeId(@typeOf(27)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 27) else if (@typeId(@typeOf(27)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 27) else LPCSTR(27);
pub const CERT_STORE_ALL_CONTEXT_FLAG = ~@as(c_ulong, 0);
pub const VER_LESS_EQUAL = 5;
pub const AC_LINE_OFFLINE = 0;
pub const XST_ADVDATASENT = 15;
pub const ODT_STATIC = 5;
pub const CRL_FIND_ISSUED_BY_SIGNATURE_FLAG = 2;
pub const VK_VOLUME_MUTE = 173;
pub const InterlockedAdd = _InlineInterlockedAdd;
pub const szOID_ECC_CURVE_X962P192V3 = "1.2.840.10045.3.1.3";
pub const MWT_MAX = MWT_RIGHTMULTIPLY;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_BUTTON = 209;
pub const IS_TEXT_UNICODE_SIGNATURE = 8;
pub const ERROR_JOIN_TO_SUBST = @as(c_long, 140);
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_UP = 215;
pub const APPCOMMAND_REPLY_TO_MAIL = 39;
pub const LANG_BANGLA = 69;
pub const CALLBACK_WINDOW = @as(c_long, 65536);
pub const MAX_MONITORS = 4;
pub const __INTMAX_C_SUFFIX__ = LL;
pub const ERROR_INVALID_FIELD = @as(c_long, 1616);
pub const WM_INITMENU = 278;
pub const NCRYPT_CIPHER_INTERFACE = BCRYPT_CIPHER_INTERFACE;
pub const WAVE_FORMAT_4S08 = 512;
pub const NCRYPT_HASH_INTERFACE = BCRYPT_HASH_INTERFACE;
pub const IGP_SELECT = 24;
pub const ERROR_INSTALL_FIREWALL_SERVICE_NOT_RUNNING = @as(c_long, 15626);
pub const LLMHF_INJECTED = 1;
pub const FACILITY_TIERING = 131;
pub const ERROR_LOGIN_WKSTA_RESTRICTION = @as(c_long, 1240);
pub const uuid_t = UUID;
pub const IMAGE_REL_ARM64_ADDR64 = 14;
pub const MCI_ANIM_RECT = @as(c_long, 65536);
pub const szOID_BASIC_CONSTRAINTS = "2.5.29.10";
pub const IMAGE_REL_ARM_BLX24 = 8;
pub const ERROR_CLUSTER_UPGRADE_INCOMPLETE = @as(c_long, 5977);
pub const PF_UNSPEC = AF_UNSPEC;
pub const DT_RTLREADING = 131072;
pub const CTRY_BOLIVIA = 591;
pub const PRINTER_CHANGE_SET_FORM = 131072;
pub const CORE_PARKING_POLICY_CHANGE_MAX = CORE_PARKING_POLICY_CHANGE_MULTISTEP;
pub const szOID_OIWSEC_dsaComm = "1.3.14.3.2.20";
pub const CERT_NEXT_UPDATE_LOCATION_PROP_ID = 10;
pub const BCRYPT_ECDSA_P256_ALG_HANDLE = if (@typeId(@typeOf(737)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 737) else if (@typeId(@typeOf(737)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 737) else BCRYPT_ALG_HANDLE(737);
pub const ERROR_DS_DRA_BUSY = @as(c_long, 8438);
pub const DNS_ERROR_INVALID_ZONE_TYPE = @as(c_long, 9611);
pub const MAXSTRETCHBLTMODE = 4;
pub const FAPPCOMMAND_MOUSE = 32768;
pub const STORE_ERROR_PENDING_COM_TRANSACTION = @as(c_long, 15863);
pub const META_SETTEXTCOLOR = 521;
pub const ERROR_SERVER_NOT_DISABLED = @as(c_long, 1342);
pub const ERROR_DS_OBJ_STRING_NAME_EXISTS = @as(c_long, 8305);
pub const CTRY_EGYPT = 20;
pub const ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE = @as(c_long, 15024);
pub const DOMAIN_GROUP_RID_CLONEABLE_CONTROLLERS = @as(c_long, 522);
pub const WM_IME_COMPOSITIONFULL = 644;
pub const UOI_FLAGS = 1;
pub const FIEF_FLAG_FORCE_JITUI = 1;
pub const GC_ROLLOVER = GC_PRESSANDTAP;
pub const TRANSACTION_NOTIFY_COMMIT_FINALIZE = 1073741824;
pub const NTM_PS_OPENTYPE = 131072;
pub const PAN_SERIF_SQUARE = 6;
pub const PP_CRYPT_COUNT_KEY_USE = 41;
pub const ENLISTMENT_SET_INFORMATION = 2;
pub const FILE_DEVICE_TRUST_ENV = 86;
pub const CAL_SMONTHNAME2 = 22;
pub const LMEM_LOCKCOUNT = 255;
pub const RPC_C_LISTEN_MAX_CALLS_DEFAULT = 1234;
pub const CERT_CHAIN_MAX_AIA_URL_COUNT_IN_CERT_DEFAULT = 5;
pub const __sdv_save_request = r;
pub const EDESTADDRREQ = 109;
pub const IMAGE_SUBSYSTEM_NATIVE_WINDOWS = 8;
pub const DMPAPER_JENV_KAKU3_ROTATED = 85;
pub const CERT_SELECT_BY_SUBJECT_HOST_NAME = 6;
pub const WAVECAPS_SAMPLEACCURATE = 32;
pub const SCS_QUERYRECONVERTSTRING = 131072;
pub const SHTDN_REASON_MINOR_CORDUNPLUGGED = 11;
pub const TAPE_DRIVE_SEQUENTIAL_FMKS = 2148007936;
pub const X3_IMM39_2_INST_WORD_POS_X = 16;
pub const RegSaveKey = RegSaveKeyA;
pub const R2_MERGEPEN = 15;
pub const LOCALE_SENGCOUNTRY = LOCALE_SENGLISHCOUNTRYNAME;
pub const CERT_SELECT_BY_ENHKEY_USAGE = 1;
pub const CERT_NAME_URL_TYPE = 7;
pub const WT_EXECUTELONGFUNCTION = 16;
pub const S_SERQFUL = -4;
pub const ANSI_FIXED_FONT = 11;
pub const InterlockedBitTestAndReset = _interlockedbittestandreset;
pub const SACL_SECURITY_INFORMATION = @as(c_long, 8);
pub const CHANGER_INIT_ELEM_STAT_WITH_RANGE = 2;
pub const SHQueryRecycleBin = SHQueryRecycleBinA;
pub const GetEnvironmentStringsA = GetEnvironmentStrings;
pub const IMAGE_SCN_LNK_REMOVE = 2048;
pub const SPI_SETBLOCKSENDINPUTRESETS = 4135;
pub const NTDDI_WINXPSP1 = 83951872;
pub const SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT = 4;
pub const NCRYPT_HASH_OPERATION = BCRYPT_HASH_OPERATION;
pub const WM_NCMOUSEHOVER = 672;
pub const PP_SECURE_KEYEXCHANGE_PIN = 47;
pub const CERT_QUERY_CONTENT_SERIALIZED_CRL = 7;
pub const RPC_S_STRING_TOO_LONG = @as(c_long, 1743);
pub const CRYPT_DECODE_NOCOPY_FLAG = 1;
pub const WM_MENURBUTTONUP = 290;
pub const LBS_NOTIFY = @as(c_long, 1);
pub const CERT_STORE_CRL_CONTEXT = 2;
pub const WH_MOUSE_LL = 14;
pub const TKF_HOTKEYACTIVE = 4;
pub const FR_DOWN = 1;
pub const RC_DEVBITS = 32768;
pub const CMSG_SIGNED_DATA_NO_SIGN_FLAG = 128;
pub const APPCOMMAND_LAUNCH_MEDIA_SELECT = 16;
pub const WM_RBUTTONUP = 517;
pub const SDC_PATH_PERSIST_IF_REQUIRED = 2048;
pub const ERROR_INSTALL_TEMP_UNWRITABLE = @as(c_long, 1632);
pub const WDA_MONITOR = 1;
pub const BS_AUTOCHECKBOX = @as(c_long, 3);
pub const PROCESS_CREATION_CHILD_PROCESS_RESTRICTED_UNLESS_SECURE = 4;
pub const MCI_SEQ_STATUS_NAME = @as(c_long, 16395);
pub const MCI_SEQ_SET_TEMPO = @as(c_long, 65536);
pub const DRAGDROP_S_FIRST = @as(c_long, 262400);
pub const EVENT_SYSTEM_SWITCHER_APPGRABBED = 36;
pub const HOST_NOT_FOUND = WSAHOST_NOT_FOUND;
pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY = @as(c_long, 13907);
pub const MCI_OVLY_INFO_TEXT = @as(c_long, 65536);
pub const FR_MATCHDIAC = 536870912;
pub const __amd64 = 1;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_ORPHAN_RECOVERY_NAME = 2199023255552;
pub const LOCALE_SLOCALIZEDCOUNTRYNAME = 6;
pub const ERROR_DS_FILTER_UNKNOWN = @as(c_long, 8254);
pub const NCRYPT_CHANGEPASSWORD_PROPERTY = NCRYPT_PCP_CHANGEPASSWORD_PROPERTY;
pub const WNetGetNetworkInformation = WNetGetNetworkInformationA;
pub const SOUND_SYSTEM_APPEND = 14;
pub const RPC_S_CALL_CANCELLED = @as(c_long, 1818);
pub const COMPRESSION_FORMAT_DEFAULT = 1;
pub const CDS_DISABLE_UNSAFE_MODES = 512;
pub const ERROR_PLATFORM_MANIFEST_NOT_SIGNED = @as(c_long, 4576);
pub const PRINTER_STATUS_PROCESSING = 16384;
pub const MDM_V23_OVERRIDE = 1024;
pub const ctl1 = 1184;
pub const DDL_READONLY = 1;
pub const SetEnvironmentVariable = SetEnvironmentVariableA;
pub const BAUD_128K = if (@typeId(@typeOf(65536)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 65536) else if (@typeId(@typeOf(65536)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 65536) else DWORD(65536);
pub const ACPI_PPM_HARDWARE_ALL = 254;
pub const INIT_ONCE_ASYNC = RTL_RUN_ONCE_ASYNC;
pub const IDCANCEL = 2;
pub const ERROR_INC_BACKUP = @as(c_long, 4003);
pub const ERROR_OBJECT_NAME_EXISTS = @as(c_long, 698);
pub const SM_CYFOCUSBORDER = 84;
pub const CERT_REGISTRY_STORE_ROAMING_FLAG = 262144;
pub const ERROR_DHCP_ADDRESS_CONFLICT = @as(c_long, 4100);
pub const IMAGE_REL_ALPHA_SECRELLO = 17;
pub const CERT_VERIFY_NO_TIME_CHECK_FLAG = 4;
pub const DeleteVolumeMountPoint = DeleteVolumeMountPointA;
pub const SUBLANG_SAMI_SKOLT_FINLAND = 8;
pub const TC_EA_DOUBLE = 512;
pub const C2_SEGMENTSEPARATOR = 9;
pub const AUXCAPS_LRVOLUME = 2;
pub const CERT_TRUST_NO_TIME_CHECK = 33554432;
pub const BCRYPT_DH_ALG_HANDLE = if (@typeId(@typeOf(641)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 641) else if (@typeId(@typeOf(641)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 641) else BCRYPT_ALG_HANDLE(641);
pub const ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR = @as(c_long, 5943);
pub const DMPAPER_EXECUTIVE = 7;
pub const CERT_END_ENTITY_SUBJECT_FLAG = 64;
pub const ERROR_PIPE_BUSY = @as(c_long, 231);
pub const VK_OEM_JUMP = 234;
pub const CMSG_OID_EXPORT_MAIL_LIST_FUNC = "CryptMsgDllExportMailList";
pub const FILE_INITIATE_REPAIR_HINT1_VALID_INDEX_ENTRY = 536870912;
pub const ERROR_CLUSTER_SHARED_VOLUMES_IN_USE = @as(c_long, 5947);
pub const X509_NAME_CONSTRAINTS = if (@typeId(@typeOf(55)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 55) else if (@typeId(@typeOf(55)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 55) else LPCSTR(55);
pub const TAPE_ERASE_SHORT = @as(c_long, 0);
pub const ERROR_INVALID_MESSAGE = @as(c_long, 1002);
pub const ERROR_DS_UNAVAILABLE_CRIT_EXTENSION = @as(c_long, 8236);
pub const CALL_PENDING = 2;
pub const ERROR_IMAGE_NOT_AT_BASE = @as(c_long, 700);
pub const CORE_PARKING_POLICY_CHANGE_ROCKET = 2;
pub const PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_DEFER = 0 << 16;
pub const CRYPT_OID_INFO_SIGN_KEY = 4;
pub const _MAX_ENV = 32767;
pub const GGO_UNHINTED = 256;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_DLL_UNLOAD = 4;
pub const InterlockedOr64NoFence = _InterlockedOr64;
pub const DNS_ERROR_BACKGROUND_LOADING = @as(c_long, 9568);
pub const ERROR_SECUREBOOT_PLATFORM_ID_MISMATCH = @as(c_long, 4430);
pub const URLPOLICY_MASK_PERMISSIONS = 15;
pub const ERROR_DS_CONSTRUCTED_ATT_MOD = @as(c_long, 8475);
pub const KP_CLEAR_KEY = 27;
pub const CMSG_TRUSTED_SIGNER_FLAG = 1;
pub const NCBLANSTALERT = 115;
pub const PD_NOWARNING = 128;
pub const BS_USERBUTTON = @as(c_long, 8);
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME = @as(c_long, 14080);
pub const SECURITY_PACKAGE_SCHANNEL_RID = @as(c_long, 14);
pub const KP_ALGID = 7;
pub const SUBLANG_ALBANIAN_ALBANIA = 1;
pub const RC_BANDING = 2;
pub const ALG_SID_AES_256 = 16;
pub const ERROR_JOURNAL_DELETE_IN_PROGRESS = @as(c_long, 1178);
pub const DRIVE_FIXED = 3;
pub const szOID_DRM = "1.3.6.1.4.1.311.10.5.1";
pub const CRYPTNET_URL_CACHE_PRE_FETCH_DISALLOWED_CERT_CAB = 6;
pub const CAL_SMONTHNAME3 = 23;
pub const NCRYPT_TPM_PAD_PSS_IGNORE_SALT = 32;
pub const URLACTION_JAVA_MAX = 7423;
pub const EVENT_OBJECT_STATECHANGE = 32778;
pub const SCARD_SCOPE_SYSTEM = 2;
pub const PRINTER_STATUS_SERVER_UNKNOWN = 8388608;
pub const ERROR_CLUSTER_NODE_QUARANTINED = @as(c_long, 5985);
pub const CONSOLE_WINDOWED_MODE = 2;
pub const CRL_DIST_POINT_ERR_CRL_ISSUER_BIT = @as(c_long, 2147483648);
pub const GCS_COMPREADSTR = 1;
pub const CRYPT_ACQUIRE_WINDOW_HANDLE_FLAG = 128;
pub const TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS = 8;
pub const ERROR_RECOVERY_NOT_NEEDED = @as(c_long, 6821);
pub const MEDIA_READ_ONLY = 4;
pub const ERROR_NO_TRUST_LSA_SECRET = @as(c_long, 1786);
pub const CTRY_HONG_KONG = 852;
pub const FACILITY_DEPLOYMENT_SERVICES_BINLSVC = 261;
pub const FACILITY_DEFRAG = 2304;
pub const EADDRINUSE = 100;
pub const POINTER_FLAG_NEW = 1;
pub const ES_SYSTEM_REQUIRED = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 1) else DWORD(1);
pub const GGO_NATIVE = 2;
pub const ODS_GRAYED = 2;
pub const ERROR_METAFILE_NOT_SUPPORTED = @as(c_long, 2003);
pub const MF_UNHILITE = @as(c_long, 0);
pub const IMAGE_SYM_DTYPE_NULL = 0;
pub const CreateActCtx = CreateActCtxA;
pub const ERROR_TIMEOUT = @as(c_long, 1460);
pub const IP_OPTIONS = 1;
pub const RpcNsProfileEltRemove = RpcNsProfileEltRemoveA;
pub const META_SAVEDC = 30;
pub const CMSG_SIGNER_INFO_V1 = 1;
pub const DESKTOP_JOURNALPLAYBACK = @as(c_long, 32);
pub const NTDDI_WINXPSP2 = 83952128;
pub const WINAPI_FAMILY_DESKTOP_APP = 100;
pub const META_RECTANGLE = 1051;
pub const HTBORDER = 18;
pub const ERROR_LOG_NOT_ENOUGH_CONTAINERS = @as(c_long, 6635);
pub const IMAGE_REL_AMD64_INDIR_BR_SWITCHTABLE_FIRST = 32;
pub const CS_PARENTDC = 128;
pub const CERT_STORE_PROV_SYSTEM_W = if (@typeId(@typeOf(10)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 10) else if (@typeId(@typeOf(10)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 10) else LPCSTR(10);
pub const IMAGE_SUBSYSTEM_NATIVE = 1;
pub const ERROR_LOG_INCONSISTENT_SECURITY = @as(c_long, 6646);
pub const DlgDirList = DlgDirListA;
pub const ERROR_MAX_SESSIONS_REACHED = @as(c_long, 353);
pub const ERROR_PASSWORD_EXPIRED = @as(c_long, 1330);
pub const szOID_WINDOWS_THIRD_PARTY_COMPONENT_SIGNER = "1.3.6.1.4.1.311.10.3.25";
pub const MOD_SHIFT = 4;
pub const RPC_C_HTTP_AUTHN_SCHEME_BASIC = 1;
pub const XST_INCOMPLETE = 1;
pub const ERROR_DS_SECURITY_ILLEGAL_MODIFY = @as(c_long, 8423);
pub const TAPE_DRIVE_WRITE_SHORT_FMKS = 2214592512;
pub const WEOF = if (@typeId(@typeOf(65535)) == @import("builtin").TypeId.Pointer) @ptrCast(wint_t, 65535) else if (@typeId(@typeOf(65535)) == @import("builtin").TypeId.Int) @intToPtr(wint_t, 65535) else wint_t(65535);
pub const LCID_INSTALLED = 1;
pub const STORAGE_PROTOCOL_STATUS_INVALID_REQUEST = 3;
pub const CRYPT_CREATE_SALT = 4;
pub const szOID_PKCS_9_CONTENT_TYPE = "1.2.840.113549.1.9.3";
pub const ROTFLAGS_ALLOWANYCLIENT = 2;
pub const CERT_CHAIN_FIND_BY_ISSUER_COMPLEX_CHAIN_FLAG = 2;
pub const PF_APPLETALK = AF_APPLETALK;
pub const PRINTER_DRIVER_CLASS = 8;
pub const MM_MIN = MM_TEXT;
pub const VTBIT_UI2 = 1 << VT_UI2;
pub const WINMMAPI = DECLSPEC_IMPORT;
pub const CERT_COMPARE_MASK = 65535;
pub const ERROR_MOD_NOT_FOUND = @as(c_long, 126);
pub const onexit_t = _onexit_t;
pub const URL_MK_LEGACY = 0;
pub const PROPSETFLAG_CASE_SENSITIVE = 8;
pub const PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE = 30;
pub const DM_ORIENTATION = @as(c_long, 1);
pub const InterlockedCompareExchangeAcquire16 = _InterlockedCompareExchange16;
pub const EMLINK = 31;
pub const CONDITION_VARIABLE_LOCKMODE_SHARED = RTL_CONDITION_VARIABLE_LOCKMODE_SHARED;
pub const PF_FASTFAIL_AVAILABLE = 23;
pub const IPPROTO_IP = 0;
pub const __UINT_LEAST16_FMTu__ = "hu";
pub const SPI_GETKEYBOARDDELAY = 22;
pub const ERROR_GENERIC_NOT_MAPPED = @as(c_long, 1360);
pub const szOID_ECC_CURVE_X962P192V1 = "1.2.840.10045.3.1.1";
pub const CF_NOVECTORFONTS = @as(c_long, 2048);
pub const DMPAPER_LETTERSMALL = 2;
pub const HTRIGHT = 11;
pub const IGP_UI = 16;
pub const WSASYSNOTREADY = @as(c_long, 10091);
pub const FILE_ATTRIBUTE_READONLY = 1;
pub const PPM_IDLE_IMPLEMENTATION_PEP = 2;
pub const SET_TAPE_MEDIA_INFORMATION = 0;
pub const METHOD_BUFFERED = 0;
pub const DCX_EXCLUDERGN = @as(c_long, 64);
pub const LOCALE_SMONGROUPING = 24;
pub const DFCS_BUTTONPUSH = 16;
pub const DdeInitialize = DdeInitializeA;
pub const __UINT_FAST32_FMTX__ = "X";
pub const RpcServerInqDefaultPrincName = RpcServerInqDefaultPrincNameA;
pub const ERROR_PRINT_MONITOR_IN_USE = @as(c_long, 3008);
pub const GGO_BITMAP = 1;
pub const OF_SHARE_DENY_WRITE = 32;
pub const XSTATE_IPT = 8;
pub const PAGE_NOCACHE = 512;
pub const WSAVERNOTSUPPORTED = @as(c_long, 10092);
pub const szOID_OIWSEC_desMAC = "1.3.14.3.2.10";
pub const PERF_DETAIL_NOVICE = 100;
pub const FACILITY_BLB_CLI = 121;
pub const REPLACE_ALTERNATE = 11;
pub const CTRY_AUSTRIA = 43;
pub const TIME_MS = 1;
pub const KF_MENUMODE = 4096;
pub const C3_KASHIDA = 512;
pub const TIME_ZONE_ID_STANDARD = 1;
pub const MARK_HANDLE_REALTIME = 32;
pub const PERF_SIZE_VARIABLE_LEN = 768;
pub const PERF_DISPLAY_NOSHOW = 1073741824;
pub const ERROR_SERVICE_EXISTS = @as(c_long, 1073);
pub const ERROR_ADVANCED_INSTALLER_FAILED = @as(c_long, 14099);
pub const SPI_SETICONTITLEWRAP = 26;
pub const DATE_MONTHDAY = 128;
pub const NCRYPT_ATTESTATION_FLAG = 32;
pub const ERROR_NO_SYSTEM_MENU = @as(c_long, 1437);
pub const KDF_ITERATION_COUNT = 16;
pub const DeviceDsmAction_ResetWritePointer = @as(c_uint, 23);
pub const _MAX_EXT = 256;
pub const MCI_ANIM_WINDOW_DEFAULT = @as(c_long, 0);
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT = 2;
pub const ERROR_FLOPPY_UNKNOWN_ERROR = @as(c_long, 1124);
pub const ERROR_PRI_MERGE_WRITE_FILE_FAILED = @as(c_long, 15152);
pub const WN_BAD_POINTER = ERROR_INVALID_ADDRESS;
pub const WSA_QOS_RECEIVERS = @as(c_long, 11005);
pub const BOLD_FONTTYPE = 256;
pub const QDI_SETDIBITS = 1;
pub const KP_PRECOMP_MD5 = 24;
pub const RPC_S_ENTRY_NOT_FOUND = @as(c_long, 1761);
pub const SUBLANG_SPANISH = 1;
pub const RPC_X_SS_CHAR_TRANS_SHORT_FILE = @as(c_long, 1774);
pub const DDL_DIRECTORY = 16;
pub const OFN_EXPLORER = 524288;
pub const PROCESS_AFFINITY_ENABLE_AUTO_UPDATE = @as(c_ulong, 1);
pub const VK_ESCAPE = 27;
pub const NIF_STATE = 8;
pub const DNS_ERROR_RRL_INVALID_IPV4_PREFIX = @as(c_long, 9913);
pub const CERT_SELECT_BY_THUMBPRINT = 14;
pub const CM_SERVICE_USB3_DISK_BOOT_LOAD = 16;
pub const _WIN32_IE_WS03 = 1538;
pub const JOY_RETURNBUTTONS = @as(c_long, 128);
pub const ERROR_TRANSACTION_NO_SUPERIOR = @as(c_long, 6730);
pub const FACILITY_USERMODE_VHD = 58;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY_LOW = 32768;
pub const MWMO_INPUTAVAILABLE = 4;
pub const WINAPI_FAMILY_PC_APP = 2;
pub const WTS_SESSION_TERMINATE = 11;
pub const DT_EXTERNALLEADING = 512;
pub const SUBLANG_MONGOLIAN_PRC = 2;
pub const LPPROPSHEETPAGE_V4 = LPPROPSHEETPAGEA_V4;
pub const ERROR_INVALID_EDIT_HEIGHT = @as(c_long, 1424);
pub const PPM_IDLE_IMPLEMENTATION_NONE = 0;
pub const IMAGE_REL_ARM64_ADDR32 = 1;
pub const ERROR_INVALID_ACE_CONDITION = @as(c_long, 805);
pub const NTDDI_WINXPSP3 = 83952384;
pub const SUBLANG_PASHTO_AFGHANISTAN = 1;
pub const LONG_LONG_MAX = __LONG_LONG_MAX__;
pub const CHECKSUM_TYPE_NONE = 0;
pub const CBS_OEMCONVERT = @as(c_long, 128);
pub const ERROR_CLUSTER_WRONG_OS_VERSION = @as(c_long, 5899);
pub const ERROR_DS_EXISTS_IN_POSS_SUP = @as(c_long, 8395);
pub const RPC_X_PIPE_CLOSED = @as(c_long, 1916);
pub const DMDITHER_RESERVED9 = 9;
pub const NTDDI_WIN2KSP4 = 83887104;
pub const DMCOLLATE_TRUE = 1;
pub const WaitNamedPipe = WaitNamedPipeA;
pub const CERT_STORE_SAVE_TO_MEMORY = 2;
pub const PD_RETURNDEFAULT = 1024;
pub const OBJID_MENU = if (@typeId(@typeOf(4294967293)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG, 4294967293) else if (@typeId(@typeOf(4294967293)) == @import("builtin").TypeId.Int) @intToPtr(LONG, 4294967293) else LONG(4294967293);
pub const MAXBYTE = 255;
pub const SM_CXHSCROLL = 21;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_OTHER = 29;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC = 2;
pub const PSINJECT_DOCUMENTPROCESSCOLORSATEND = 21;
pub const GetEnhMetaFileDescription = GetEnhMetaFileDescriptionA;
pub const GWLP_WNDPROC = -4;
pub const SERVICE_CONTROL_NETBINDADD = 7;
pub const SUBLANG_ENGLISH_MALAYSIA = 17;
pub const LOCALE_SMONTHNAME8 = 63;
pub const PT_MOVETO = 6;
pub const IN_CLASSA_HOST = 16777215;
pub const IMAGE_DEBUG_TYPE_CODEVIEW = 2;
pub const ERROR_INVALID_STATE = @as(c_long, 5023);
pub const ERROR_VOLUME_NOT_CLUSTER_ALIGNED = @as(c_long, 407);
pub const SM_CYCAPTION = 4;
pub const SPI_SETTOUCHPREDICTIONPARAMETERS = 157;
pub const KLF_NOTELLSHELL = 128;
pub const ERROR_VOLUME_NOT_SIS_ENABLED = @as(c_long, 4500);
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC = 62;
pub const ERROR_PROVISION_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_PROVISIONED = @as(c_long, 15642);
pub const PSINJECT_DOCSUPPLIEDRES = 6;
pub const ERROR_IPSEC_IKE_OUT_OF_MEMORY = @as(c_long, 13859);
pub const INHERIT_PARENT_AFFINITY = 65536;
pub const ALG_SID_RIPEMD = 6;
pub const CRYPT_PUBKEY_ALG_OID_GROUP_ID = 3;
pub const PHYSICALHEIGHT = 111;
pub const WAVECAPS_PITCH = 1;
pub const DOMAIN_GROUP_RID_KEY_ADMINS = @as(c_long, 526);
pub const PROC_THREAD_ATTRIBUTE_REPLACE_VALUE = 1;
pub const IMAGE_REL_PPC_PAIR = 18;
pub const SUBLANG_WELSH_UNITED_KINGDOM = 1;
pub const CREATE_SUSPENDED = 4;
pub const CERT_TRUST_INVALID_BASIC_CONSTRAINTS = 1024;
pub const CFSTR_MIME_TEXT_JSON = if (@typeId(@typeOf("text/json")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "text/json") else if (@typeId(@typeOf("text/json")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "text/json") else TEXT("text/json");
pub const WM_PRINT = 791;
pub const CERT_INFO_SIGNATURE_ALGORITHM_FLAG = 3;
pub const EnumSystemCodePages = EnumSystemCodePagesA;
pub const ERROR_NO_DATA = @as(c_long, 232);
pub const VarDateFromUint = VarDateFromUI4;
pub const DNS_ERROR_INVALID_XML = @as(c_long, 9126);
pub const FACILITY_SDIAG = 60;
pub const JOB_OBJECT_TERMINATE = 8;
pub const FILE_DEVICE_TERMSRV = 56;
pub const EPT_S_INVALID_ENTRY = @as(c_long, 1751);
pub const CERT_FIND_HAS_PRIVATE_KEY = CERT_COMPARE_HAS_PRIVATE_KEY << CERT_COMPARE_SHIFT;
pub const DWL_USER = 8;
pub const ERROR_FILE_NOT_SUPPORTED = @as(c_long, 425);
pub const CNG_RSA_PRIVATE_KEY_BLOB = if (@typeId(@typeOf(83)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 83) else if (@typeId(@typeOf(83)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 83) else LPCSTR(83);
pub const KP_CLIENT_RANDOM = 21;
pub const LOCALE_ILDATE = 34;
pub const BCRYPT_SHA384_ALG_HANDLE = if (@typeId(@typeOf(81)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 81) else if (@typeId(@typeOf(81)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 81) else BCRYPT_ALG_HANDLE(81);
pub const MAKEINTRESOURCE = MAKEINTRESOURCEA;
pub const IMAGE_REL_ALPHA_GPRELHI = 23;
pub const EMARCH_ENC_I17_IMM7B_VAL_POS_X = 0;
pub const PROTECTION_LEVEL_LSA_LIGHT = 4;
pub const WM_NCCREATE = 129;
pub const ACCESS_DENIED_OBJECT_ACE_TYPE = 6;
pub const szOID_RSA_messageDigest = "1.2.840.113549.1.9.4";
pub const META_SETVIEWPORTORG = 525;
pub const RTL_RUN_ONCE_ASYNC = @as(c_ulong, 2);
pub const EDS_RAWMODE = 2;
pub const URLACTION_ALLOW_CROSSDOMAIN_APPCACHE_MANIFEST = 9994;
pub const ETIME = 137;
pub const ERROR_WRONG_EFS = @as(c_long, 6005);
pub const ERROR_DYNAMIC_CODE_BLOCKED = @as(c_long, 1655);
pub const MAXIMUM_ALLOWED = @as(c_long, 33554432);
pub const IMAGE_SCN_CNT_CODE = 32;
pub const PRODUCT_PRO_WORKSTATION = 161;
pub const DT_VCENTER = 4;
pub const ERROR_INVALID_HANDLE_STATE = @as(c_long, 1609);
pub const FILE_INITIATE_REPAIR_HINT1_NOT_IMPLEMENTED = 32;
pub const CWP_SKIPTRANSPARENT = 4;
pub const FAST_FAIL_INVALID_FAST_FAIL_CODE = 4294967295;
pub const HTSYSMENU = 3;
pub const ERROR_INVALID_LOGON_HOURS = @as(c_long, 1328);
pub const szOID_INFOSEC_mosaicKeyManagement = "2.16.840.1.101.2.1.1.10";
pub const CAL_SMONTHNAME1 = 21;
pub const szOID_INFOSEC_SuiteAKeyManagement = "2.16.840.1.101.2.1.1.17";
pub const szOID_CERTSRV_PREVIOUS_CERT_HASH = "1.3.6.1.4.1.311.21.2";
pub const CHANGER_PREMOUNT_EJECT_REQUIRED = 524288;
pub const WM_MDIREFRESHMENU = 564;
pub const WM_MDIDESTROY = 545;
pub const IDABORT = 3;
pub const SKF_LCTLLOCKED = 262144;
pub const IMAGE_SYM_CLASS_UNION_TAG = 12;
pub const SND_FILENAME = @as(c_long, 131072);
pub const SOUND_SYSTEM_STARTUP = 1;
pub const SOUND_SYSTEM_MENUCOMMAND = 15;
pub const ERROR_NOT_SAFEBOOT_SERVICE = @as(c_long, 1084);
pub const CERT_SMART_CARD_DATA_PROP_ID = 16;
pub const ERROR_DS_DRA_NOT_SUPPORTED = @as(c_long, 8454);
pub const PORT_STATUS_PAPER_PROBLEM = 5;
pub const ERROR_STATE_CREATE_CONTAINER_FAILED = @as(c_long, 15805);
pub const DNS_ERROR_ZONE_CONFIGURATION_ERROR = @as(c_long, 9604);
pub const SUBLANG_ARABIC_OMAN = 8;
pub const URLACTION_DOWNLOAD_MIN = 4096;
pub const NCRYPT_CLAIM_VSM_KEY_ATTESTATION_STATEMENT = 4;
pub const CERT_RDN_GENERAL_STRING = 10;
pub const ERROR_INVALID_PEP_INFO_VERSION = @as(c_long, 341);
pub const CERT_PROT_ROOT_DISABLE_PEER_TRUST = 65536;
pub const LOAD_LIBRARY_AS_DATAFILE = 2;
pub const SMART_INVALID_DRIVE = 5;
pub const WS_CHILD = @as(c_long, 1073741824);
pub const MEVT_F_CALLBACK = @as(c_long, 1073741824);
pub const ERROR_JOURNAL_HOOK_SET = @as(c_long, 1430);
pub const DRAFT_QUALITY = 1;
pub const ERROR_LABEL_TOO_LONG = @as(c_long, 154);
pub const POWER_SYSTEM_MAXIMUM = 7;
pub const IMAGE_REL_IA64_PCREL60F = 23;
pub const EXTERN_C = @"extern";
pub const SUBLANG_IGBO_NIGERIA = 1;
pub const DMDITHER_RESERVED8 = 8;
pub const NTDDI_WIN2KSP3 = 83886848;
pub const MEM_DIFFERENT_IMAGE_BASE_OK = 8388608;
pub const wcswcs = wcsstr;
pub const CERT_QUERY_CONTENT_PKCS7_SIGNED = 8;
pub const ROTFLAGS_REGISTRATIONKEEPSALIVE = 1;
pub const FROM_LEFT_2ND_BUTTON_PRESSED = 4;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM = @as(c_long, 13812);
pub const PRODUCT_IOTEDGEOS = 187;
pub const SYSTEM_RESOURCE_ATTRIBUTE_ACE_TYPE = 18;
pub const EXCEPTION_DATATYPE_MISALIGNMENT = STATUS_DATATYPE_MISALIGNMENT;
pub const ERROR_MCA_MCCS_VERSION_MISMATCH = @as(c_long, 15203);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_CRL = 2;
pub const PROPSETHDR_OSVERSION_UNKNOWN = 4294967295;
pub const CRYPT_VERIFY_CERT_SIGN_SET_STRONG_PROPERTIES_FLAG = 2;
pub const NORMAL_PRINT = 0;
pub const LOCALE_SMONTHNAME9 = 64;
pub const GCP_MAXEXTENT = @as(c_long, 1048576);
pub const EVENTLOG_FULL_INFO = 0;
pub const FAST_FAIL_FATAL_APP_EXIT = 7;
pub const MAILSLOT_NO_MESSAGE = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, -1) else DWORD(-1);
pub const IMAGE_REL_THUMB_MOV32 = 17;
pub const TC_PUBLIC_DATA_TYPE_ATASMART = "ATASMARTPages";
pub const WM_MDINEXT = 548;
pub const FAST_FAIL_FLAGS_CORRUPTION = 59;
pub const DNS_ERROR_UNSUPPORTED_ALGORITHM = @as(c_long, 9105);
pub const FILESYSTEM_STATISTICS_TYPE_REFS = 4;
pub const FR_REPLACE = 16;
pub const CreateFont = CreateFontA;
pub const FS_VOL_IS_COMPRESSED = FILE_VOLUME_IS_COMPRESSED;
pub const ERROR_NO_TXF_METADATA = @as(c_long, 6816);
pub const ERROR_INVALID_HW_PROFILE = @as(c_long, 619);
pub const FAST_FAIL_MRDATA_PROTECTION_FAILURE = 34;
pub const DM_PROMPT = 4;
pub const JOB_NOTIFY_FIELD_SUBMITTED = 16;
pub const VTA_BASELINE = TA_BASELINE;
pub const RPC_X_PIPE_APP_MEMORY = ERROR_OUTOFMEMORY;
pub const SERVICE_LAUNCH_PROTECTED_WINDOWS = 1;
pub const PORT_STATUS_PAPER_OUT = 3;
pub const MCI_STATUS_MEDIA_PRESENT = @as(c_long, 5);
pub const APPCOMMAND_COPY = 36;
pub const ERROR_CLUSTER_INCOMPATIBLE_VERSIONS = @as(c_long, 5075);
pub const IMAGE_REL_ARM_BRANCH20T = 18;
pub const OInetGetSession = CoInternetGetSession;
pub const TAPE_LOGICAL_POSITION = @as(c_long, 1);
pub const EM_GETLINE = 196;
pub const FRERR_FINDREPLACECODES = 16384;
pub const CertOpenSystemStore = CertOpenSystemStoreA;
pub const WritePrivateProfileStruct = WritePrivateProfileStructA;
pub const CSTR_EQUAL = 2;
pub const DdeCreateStringHandle = DdeCreateStringHandleA;
pub const SERVICE_CONFIG_LAUNCH_PROTECTED = 12;
pub const ERROR_LONGJUMP = @as(c_long, 682);
pub const ERROR_INVALID_FIELD_IN_PARAMETER_LIST = @as(c_long, 328);
pub const BS_DIBPATTERN8X8 = 8;
pub const CERT_SELECT_BY_EXTENSION = 5;
pub const SPI_SETHUNGAPPTIMEOUT = 121;
pub const PROTECTION_LEVEL_WINDOWS = 1;
pub const KP_CMS_KEY_INFO = 37;
pub const ERROR_ACCESS_DISABLED_WEBBLADE = @as(c_long, 1277);
pub const ERROR_PRI_MERGE_MISSING_SCHEMA = @as(c_long, 15149);
pub const TC_SIGNAL = 3;
pub const STORAGE_DEVICE_FLAGS_RANDOM_DEVICEGUID_REASON_CONFLICT = 1;
pub const PRINTER_NOTIFY_FIELD_PARAMETERS = 10;
pub const SSL_HPKP_HEADER_COUNT = 2;
pub const IMAGE_REL_MIPS_GPREL = 6;
pub const ABM_SETSTATE = 10;
pub const HELP_TCARD_DATA = 16;
pub const PRINTER_ATTRIBUTE_ENTERPRISE_CLOUD = 8388608;
pub const DEVICEFAMILYDEVICEFORM_MEDICAL = 22;
pub const RPC_C_USE_INTRANET_PORT = 2;
pub const ERROR_SET_NOT_FOUND = @as(c_long, 1170);
pub const RegLoadAppKey = RegLoadAppKeyA;
pub const PROCESS_CREATION_MITIGATION_POLICY2_LOADER_INTEGRITY_CONTINUITY_MASK = if (@typeId(@typeOf(i64 << 4)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 4) else if (@typeId(@typeOf(i64 << 4)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 4) else @as(c_uint, 3)(i64 << 4);
pub const STORAGE_TIER_FLAG_WRITE_BACK_CACHE = 2097152;
pub const VRL_PREDEFINED_CLASS_BEGIN = 1 << 0;
pub const RPC_C_AUTHN_GSS_KERBEROS = 16;
pub const ALG_SID_TEK = 11;
pub const WM_IME_KEYDOWN = 656;
pub const ERROR_BUSY = @as(c_long, 170);
pub const ERROR_NO_RANGES_PROCESSED = @as(c_long, 312);
pub const PRODUCT_EMBEDDED_AUTOMOTIVE = 85;
pub const ENLISTMENT_SUPERIOR_RIGHTS = 16;
pub const EC_ENABLEALL = 0;
pub const GETCOLORTABLE = 5;
pub const ERROR_SXS_XML_E_UNEXPECTEDENDTAG = @as(c_long, 14051);
pub const JOY_BUTTON19 = @as(c_long, 262144);
pub const szOID_PKIX_PE = "1.3.6.1.5.5.7.1";
pub const IME_CMODE_SOFTKBD = 128;
pub const SOUND_SYSTEM_RESTOREUP = 10;
pub const CRL_FIND_EXISTING = 2;
pub const ERROR_MRM_INVALID_QUALIFIER_OPERATOR = @as(c_long, 15137);
pub const CMSG_TYPE_PARAM = 1;
pub const CERT_NAME_SEARCH_ALL_NAMES_FLAG = 2;
pub const VARIANT_CALENDAR_THAI = 32;
pub const IsCharUpper = IsCharUpperA;
pub const DMRES_MEDIUM = -3;
pub const SC_MANAGER_CONNECT = 1;
pub const ERROR_EVENTLOG_FILE_CHANGED = @as(c_long, 1503);
pub const CAL_SMONTHNAME6 = 26;
pub const MMIO_ALLOCBUF = 65536;
pub const MDM_CELLULAR = 8;
pub const ERROR_GPIO_INTERRUPT_ALREADY_UNMASKED = @as(c_long, 15327);
pub const LOCALE_SSHORTESTAM = 126;
pub const STATUS_STACK_OVERFLOW = if (@typeId(@typeOf(@as(c_long, 3221225725))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225725)) else if (@typeId(@typeOf(@as(c_long, 3221225725))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225725)) else DWORD(@as(c_long, 3221225725));
pub const DCTT_DOWNLOAD_OUTLINE = @as(c_long, 8);
pub const CMSG_ENVELOPED_FLAG = 1 << CMSG_ENVELOPED;
pub const MIN_UCSCHAR = 0;
pub const MAXWORD = 65535;
pub const ERROR_VERSION_PARSE_ERROR = @as(c_long, 777);
pub const ERROR_DUPLICATE_TAG = @as(c_long, 2014);
pub const ERROR_PRINT_JOB_RESTART_REQUIRED = @as(c_long, 3020);
pub const ERROR_SECUREBOOT_INVALID_POLICY = @as(c_long, 4422);
pub const SUBLANG_AMHARIC_ETHIOPIA = 1;
pub const ERROR_FAIL_FAST_EXCEPTION = @as(c_long, 1653);
pub const NTDDI_WINBLUE = 100859904;
pub const IMAGE_REL_ARM_MOV32 = 16;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_EXIST = 4;
pub const PIPE_ACCESS_INBOUND = 1;
pub const SUCCESSFUL_ACCESS_ACE_FLAG = 64;
pub const META_ESCAPE = 1574;
pub const DFCS_CAPTIONCLOSE = 0;
pub const NCRYPT_ISOLATED_KEY_FLAG_IMPORT_ONLY = 2;
pub const XSTATE_CET_U = 11;
pub const SKF_LCTLLATCHED = 67108864;
pub const ERROR_CTX_SESSION_IN_USE = @as(c_long, 7062);
pub const SendMessageTimeout = SendMessageTimeoutA;
pub const CharToOem = CharToOemA;
pub const IPPORT_SUPDUP = 95;
pub const __INT_FAST32_MAX__ = 2147483647;
pub const MCI_VD_STATUS_FORWARD = @as(c_long, 16387);
pub const FIND_ACTCTX_SECTION_KEY_RETURN_ASSEMBLY_METADATA = 4;
pub const LPD_SHARE_STENCIL = 128;
pub const STREAM_SPARSE_ATTRIBUTE = 8;
pub const NTDDI_WIN2KSP2 = 83886592;
pub const ERROR_CTX_SHADOW_DENIED = @as(c_long, 7044);
pub const PROCESS_HEAP_ENTRY_BUSY = 4;
pub const SSGF_DISPLAY = 3;
pub const DESKTOP_HOOKCONTROL = @as(c_long, 8);
pub const EnumPrinterData = EnumPrinterDataA;
pub const SUBLANG_TURKMEN_TURKMENISTAN = 1;
pub const MEVT_LONGMSG = if (@typeId(@typeOf(128)) == @import("builtin").TypeId.Pointer) @ptrCast(BYTE, 128) else if (@typeId(@typeOf(128)) == @import("builtin").TypeId.Int) @intToPtr(BYTE, 128) else BYTE(128);
pub const ALG_SID_AES = 17;
pub const MCI_GETDEVCAPS_USES_FILES = @as(c_long, 5);
pub const SPI_GETSCREENREADER = 70;
pub const MIXERCONTROL_CT_SC_SWITCH_BOOLEAN = @as(c_long, 0);
pub const IMAGE_REL_M32R_ADDR24 = 3;
pub const ERROR_MEDIA_UNAVAILABLE = @as(c_long, 4308);
pub const NTM_REGULAR = @as(c_long, 64);
pub const GCPCLASS_NUMERICSEPARATOR = 8;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_DELTA = 0.001000;
pub const DNS_ERROR_POLICY_ALREADY_EXISTS = @as(c_long, 9971);
pub const ERROR_DS_BAD_NAME_SYNTAX = @as(c_long, 8335);
pub const RotateLeft64 = _rotl64;
pub const GETPENWIDTH = 16;
pub const STATE_SYSTEM_PRESSED = 8;
pub const CF_SCRIPTSONLY = CF_ANSIONLY;
pub const CP_ACP = 0;
pub const JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 8;
pub const ERROR_LOG_PINNED_ARCHIVE_TAIL = @as(c_long, 6623);
pub const BS_SOLID = 0;
pub const META_FILLREGION = 552;
pub const szOID_INTERNATIONALIZED_EMAIL_ADDRESS = "1.3.6.1.4.1.311.20.2.4";
pub const CRYPT_INSTALL_OID_INFO_BEFORE_FLAG = 1;
pub const CERT_STORE_SAVE_AS_PKCS7 = 2;
pub const SUBLANG_KASHMIRI_INDIA = 2;
pub const CMSG_ATTR_CERT_PARAM = 32;
pub const CRYPT_FORMAT_STR_NO_HEX = 16;
pub const CERT_INFO_NOT_AFTER_FLAG = 6;
pub const URLACTION_ACTIVEX_RUN = 4608;
pub const ERROR_SXS_INVALID_DEACTIVATION = @as(c_long, 14085);
pub const ERROR_OVERRIDE_NOCHANGES = @as(c_long, 1252);
pub const R2_COPYPEN = 13;
pub const PSWIZB_FINISH = 4;
pub const CPS_CANCEL = 4;
pub const FIND_ACTCTX_SECTION_KEY_RETURN_FLAGS = 2;
pub const ERROR_PACKAGES_REPUTATION_CHECK_TIMEDOUT = @as(c_long, 15644);
pub const GetModuleHandle = GetModuleHandleA;
pub const SS_ICON = @as(c_long, 3);
pub const SPI_SETMOUSE = 4;
pub const _HEX = 128;
pub const PPCAPS_BOOKLET_EDGE = 1;
pub const CERT_FIND_HASH = CERT_FIND_SHA1_HASH;
pub const WS_EX_NOACTIVATE = @as(c_long, 134217728);
pub const PRODUCT_PROFESSIONAL_E = 69;
pub const FILE_SUPPORTS_ENCRYPTION = 131072;
pub const SUBLANG_SPANISH_MEXICAN = 2;
pub const szOID_ECC_CURVE_SECP256R1 = szOID_ECC_CURVE_P256;
pub const TXFS_RM_FLAG_RENAME_RM = 2;
pub const IGIMII_INPUTTOOLS = 64;
pub const IPPORT_CMDSERVER = 514;
pub const GetDiskSpaceInformation = GetDiskSpaceInformationA;
pub const DNS_INFO_ADDED_LOCAL_WINS = @as(c_long, 9753);
pub const HS_CROSS = 4;
pub const MAXUINT_PTR = ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT_PTR, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT_PTR, 0) else UINT_PTR(0);
pub const PROTECTION_LEVEL_ANTIMALWARE_LIGHT = 3;
pub const ACTIVATION_CONTEXT_PATH_TYPE_NONE = 1;
pub const GetPrinterDriver = GetPrinterDriverA;
pub const LANG_FARSI = 41;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE = 2;
pub const ACTCTX_FLAG_SET_PROCESS_DEFAULT = 16;
pub const mciSendString = mciSendStringA;
pub const CERT_TRUST_HAS_PREFERRED_ISSUER = 256;
pub const WN_NO_NET_OR_BAD_PATH = ERROR_NO_NET_OR_BAD_PATH;
pub const C2_OTHERNEUTRAL = 11;
pub const CMSG_ENVELOPED_RECIPIENT_V0 = 0;
pub const MEMORY_PRIORITY_LOWEST = 0;
pub const ERROR_FAIL_NOACTION_REBOOT = @as(c_long, 350);
pub const RPC_C_AUTHN_INFO_TYPE_HTTP = 1;
pub const szOID_ECC_CURVE_BRAINPOOLP512T1 = "1.3.36.3.3.2.8.1.1.14";
pub const SERVICE_STOP_REASON_FLAG_CUSTOM = 536870912;
pub const MCI_SET_AUDIO = @as(c_long, 2048);
pub const ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN = @as(c_long, 8515);
pub const IMAGE_SYM_SECTION_MAX = 65279;
pub const JOY_BUTTON18 = @as(c_long, 131072);
pub const KDF_TLS_PRF_SEED = 5;
pub const ERROR_CANNOT_LOAD_REGISTRY_FILE = @as(c_long, 589);
pub const MEMORY_PRIORITY_BELOW_NORMAL = 4;
pub const SUBLANG_GEORGIAN_GEORGIA = 1;
pub const ERROR_PNP_REBOOT_REQUIRED = @as(c_long, 638);
pub const TPM_NOANIMATION = @as(c_long, 16384);
pub const TXFS_RM_FLAG_GROW_LOG = 1024;
pub const DMPAPER_LETTER_PLUS = 59;
pub const CAL_SMONTHNAME7 = 27;
pub const WNNC_NET_CLEARCASE = 1441792;
pub const CF_NOSTYLESEL = @as(c_long, 1048576);
pub const PRODUCT_PROFESSIONAL = 48;
pub const VER_SUITE_SMALLBUSINESS_RESTRICTED = 32;
pub const PRINTER_NOTIFY_CATEGORY_ALL = 4096;
pub const DT_NOFULLWIDTHCHARBREAK = 524288;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_IN_SYNC = 2;
pub const CRYPT_UI_PROMPT = 4;
pub const ERROR_DS_INAPPROPRIATE_AUTH = @as(c_long, 8233);
pub const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DEFAULT = 5;
pub const REG_QWORD_LITTLE_ENDIAN = @as(c_ulong, 11);
pub const WM_POINTERHWHEEL = 591;
pub const RIP_EVENT = 9;
pub const COM_RIGHTS_ACTIVATE_REMOTE = 16;
pub const PRODUCT_UTILITY_VM = 149;
pub const WNFMT_ABBREVIATED = 2;
pub const LOCALE_SENGLANGUAGE = LOCALE_SENGLISHLANGUAGENAME;
pub const DCOMSCM_RESOLVE_USE_ALL_AUTHNSERVICES = 4;
pub const PSN_TRANSLATEACCELERATOR = if (@typeId(@typeOf(-12)) == @import("builtin").TypeId.Pointer) @ptrCast(PSN_FIRST, -12) else if (@typeId(@typeOf(-12)) == @import("builtin").TypeId.Int) @intToPtr(PSN_FIRST, -12) else PSN_FIRST(-12);
pub const LPPROPSHEETPAGE_V1 = LPPROPSHEETPAGEA_V1;
pub const EnumPrinters = EnumPrintersA;
pub const ERROR_CLUSTER_INVALID_NODE = @as(c_long, 5039);
pub const ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE = @as(c_long, 7014);
pub const EVENTLOG_BACKWARDS_READ = 8;
pub const S_SERBDNT = -5;
pub const IMAGE_REL_ALPHA_GPRELLO = 22;
pub const STATE_SYSTEM_LINKED = 4194304;
pub const FILE_DEVICE_KEYBOARD = 11;
pub const DEVICE_DSM_FLAG_TRIM_NOT_FS_ALLOCATED = 2147483648;
pub const SID_RECOMMENDED_SUB_AUTHORITIES = 1;
pub const CreateAcceleratorTable = CreateAcceleratorTableA;
pub const BitTestAndSet = _bittestandset;
pub const CRYPT_VOLATILE = 4096;
pub const TWF_WANTPALM = 2;
pub const FILE_ATTRIBUTE_COMPRESSED = 2048;
pub const ERROR_INVALID_EVENT_COUNT = @as(c_long, 151);
pub const DT_CALCRECT = 1024;
pub const RESOURCEMANAGER_SET_INFORMATION = 2;
pub const NTDDI_WIN2KSP1 = 83886336;
pub const ERROR_SERVICE_NOT_FOUND = @as(c_long, 1243);
pub const CMSG_CMS_RECIPIENT_COUNT_PARAM = 33;
pub const WAIT_TIMEOUT = @as(c_long, 258);
pub const CONVERT10_E_FIRST = @as(c_long, 2147746240);
pub const SECURITY_MIN_BASE_RID = @as(c_long, 80);
pub const CERT_FIND_SUBJECT_STR = CERT_FIND_SUBJECT_STR_W;
pub const MCI_FORMAT_MILLISECONDS = 0;
pub const DNS_ERROR_ZONE_NOT_SECONDARY = @as(c_long, 9613);
pub const SOFTDIST_ADSTATE_NONE = 0;
pub const IMAGE_SIZEOF_SYMBOL = 18;
pub const ERROR_SECUREBOOT_ROLLBACK_DETECTED = @as(c_long, 4420);
pub const SPI_GETNONCLIENTMETRICS = 41;
pub const DEVICE_DSM_NOTIFY_FLAG_BEGIN = 1;
pub const FILE_FLAG_OPEN_REPARSE_POINT = 2097152;
pub const ALG_SID_SSL2_MASTER = 5;
pub const PRINTER_NOTIFY_FIELD_DEFAULT_PRIORITY = 15;
pub const TMPF_FIXED_PITCH = 1;
pub const CREATE_SECURE_PROCESS = 4194304;
pub const OFN_DONTADDTORECENT = 33554432;
pub const SHTDN_REASON_MINOR_OTHERDRIVER = 14;
pub const CSV_QUERY_MDS_PATH_FLAG_CSV_DIRECT_IO_ENABLED = 2;
pub const ERROR_CLUSTER_INVALID_NETWORK = @as(c_long, 5054);
pub const NOERROR = 0;
pub const MDM_X75_DATA_BTX = 4;
pub const BCRYPT_RSA_SIGN_ALG_HANDLE = if (@typeId(@typeOf(785)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 785) else if (@typeId(@typeOf(785)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 785) else BCRYPT_ALG_HANDLE(785);
pub const TC_OP_STROKE = 2;
pub const RPC_C_MGMT_INQ_STATS = 2;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_NETWORK_PROTOCOL = @as(c_long, 9992);
pub const RPC_C_SECURITY_QOS_VERSION = @as(c_long, 1);
pub const SBM_ENABLE_ARROWS = 228;
pub const SE_SIGNING_LEVEL_UNCHECKED = 0;
pub const FILE_DEVICE_SYSENV = 82;
pub const SPI_GETFASTTASKSWITCH = 35;
pub const ILLUMINANT_DEVICE_DEFAULT = 0;
pub const LR_DEFAULTSIZE = 64;
pub const DEVICEFAMILYDEVICEFORM_TABLET = 2;
pub const PST_UNSPECIFIED = if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 0) else DWORD(0);
pub const SE_SACL_PRESENT = 16;
pub const __inner_transfer = formal;
pub const OLEIVERB_SHOW = -@as(c_long, 1);
pub const szOID_ECC_CURVE_BRAINPOOLP256T1 = "1.3.36.3.3.2.8.1.1.8";
pub const IMAGE_REL_SHM_RELLO = 22;
pub const MDM_V120_ML_NONE = 1;
pub const JOB_NOTIFY_FIELD_TIME = 19;
pub const UOI_IO = 6;
pub const szOID_X957_DSA = "1.2.840.10040.4.1";
pub const NDR_DEFAULT_ALLOCATOR = @as(c_ulong, 536870912);
pub const RC_STRETCHDIB = 8192;
pub const ERROR_CANCELLED = @as(c_long, 1223);
pub const MCI_ANIM_WINDOW_STATE = @as(c_long, 262144);
pub const ERROR_NO_SCROLLBARS = @as(c_long, 1447);
pub const SCRUB_DATA_OUTPUT_FLAG_NON_USER_DATA_RANGE = 65536;
pub const CRYPT_STRING_HEXASCII = 5;
pub const SUBLANG_SPANISH_PARAGUAY = 15;
pub const ABE_LEFT = 0;
pub const SPI_SETCARETWIDTH = 8199;
pub const RESOURCE_MANAGER_MAXIMUM_OPTION = 3;
pub const CRYPT_POLICY_OID_GROUP_ID = 8;
pub const CMSG_ENVELOPED_RECIPIENT_V3 = 3;
pub const PRODUCT_EDUCATION_N = 122;
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_SUCCESS = 0;
pub const STATUS_SEGMENT_NOTIFICATION = if (@typeId(@typeOf(@as(c_long, 1073741829))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 1073741829)) else if (@typeId(@typeOf(@as(c_long, 1073741829))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 1073741829)) else DWORD(@as(c_long, 1073741829));
pub const DATE_YEARMONTH = 8;
pub const CMC_FAIL_UNSUPORTED_EXT = 5;
pub const SHTDN_REASON_MAJOR_OPERATINGSYSTEM = 131072;
pub const WSAEFAULT = @as(c_long, 10014);
pub const CONVERT10_S_LAST = @as(c_long, 262607);
pub const __INT_LEAST32_FMTi__ = "i";
pub const IO_REPARSE_TAG_NFS = @as(c_long, 2147483668);
pub const OpenFileMapping = OpenFileMappingA;
pub const FILE_MAP_LARGE_PAGES = 536870912;
pub const IO_REPARSE_TAG_ONEDRIVE = @as(c_long, 2147483681);
pub const WM_PALETTECHANGED = 785;
pub const URLPOLICY_CHANNEL_SOFTDIST_PRECACHE = 131072;
pub const COMPRESSION_FORMAT_NONE = 0;
pub const DNS_ERROR_DEFAULT_ZONESCOPE = @as(c_long, 9953);
pub const CERT_STORE_PROV_DELETE_CTL_FUNC = 11;
pub const LOCALE_S1159 = LOCALE_SAM;
pub const NUMLOCK_ON = 32;
pub const CAL_SMONTHNAME4 = 24;
pub const EMR_POLYLINE16 = 87;
pub const WSAEALREADY = @as(c_long, 10037);
pub const IME_REGWORD_STYLE_USER_FIRST = 2147483648;
pub const PAN_FAMILY_TEXT_DISPLAY = 2;
pub const CERT_PUBKEY_HASH_RESERVED_PROP_ID = 8;
pub const TPM_WORKAREA = @as(c_long, 65536);
pub const EPT_S_CANT_CREATE = @as(c_long, 1899);
pub const JOY_POVFORWARD = 0;
pub const ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED = @as(c_long, 6723);
pub const BINDF_DONTUSECACHE = BINDF_GETNEWESTVERSION;
pub const NTM_DSIG = 2097152;
pub const PRODUCT_ENTERPRISE_S = 125;
pub const CERT_TRUST_IS_PEER_TRUSTED = 2048;
pub const __inner_data_entrypoint = category;
pub const ETO_RTLREADING = 128;
pub const ERROR_CLUSCFG_ROLLBACK_FAILED = @as(c_long, 5902);
pub const szOID_ECC_CURVE_NISTP521 = szOID_ECC_CURVE_P521;
pub const APPIDREGFLAGS_ACTIVATE_IUSERVER_INDESKTOP = 1;
pub const RPC_S_PROFILE_NOT_ADDED = @as(c_long, 1925);
pub const DC_DUPLEX = 7;
pub const CRYPT_FORMAT_OID = 4;
pub const szOID_SUBJECT_ALT_NAME2 = "2.5.29.17";
pub const FW_ISSUEID_NO_ISSUE = 0;
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_CHECK_APPLICATION_ROOT_FLAG = 131072;
pub const ERROR_CLOUD_FILE_PROVIDER_TERMINATED = @as(c_long, 404);
pub const CRYPT_USER_KEYSET = 4096;
pub const ACTCTX_FLAG_LANGID_VALID = 2;
pub const VIF_CANNOTLOADCABINET = @as(c_long, 1048576);
pub const __write_guarded_by = lock;
pub const NIF_INFO = 16;
pub const X509_LOGOTYPE_EXT = if (@typeId(@typeOf(70)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 70) else if (@typeId(@typeOf(70)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 70) else LPCSTR(70);
pub const GID_END = 2;
pub const MUI_FULL_LANGUAGE = 1;
pub const MSGF_DDEMGR = 32769;
pub const CERT_STORE_CTRL_COMMIT = 3;
pub const EMARCH_ENC_I17_IMM41b_VAL_POS_X = 32;
pub const DNS_ERROR_INVALID_POLICY_TABLE = @as(c_long, 9572);
pub const SERIAL_IOC_MCR_DTR = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 1) else DWORD(1);
pub const ERROR_DS_SERVER_DOWN = @as(c_long, 8250);
pub const C2_EUROPENUMBER = 3;
pub const GENERIC_WRITE = @as(c_long, 1073741824);
pub const IMPORT_OBJECT_HDR_SIG2 = 65535;
pub const DNS_ERROR_TRY_AGAIN_LATER = @as(c_long, 9554);
pub const WM_NCLBUTTONUP = 162;
pub const NCBDGSEND = 32;
pub const EM_SCROLL = 181;
pub const WM_INPUTLANGCHANGEREQUEST = 80;
pub const SERVICE_ACCEPT_POWEREVENT = 64;
pub const LOCALE_SNEGINFINITY = 107;
pub const RPC_C_BIND_TO_ALL_NICS = 1;
pub const R2_NOT = 6;
pub const IMAGE_REL_PPC_REFLO = 17;
pub const SERIAL_LSRMST_ESCAPE = if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(BYTE, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(BYTE, 0) else BYTE(0);
pub const LPPROPSHEETPAGE_LATEST = LPPROPSHEETPAGEA_LATEST;
pub const MOD_SWSYNTH = 7;
pub const LANG_BASHKIR = 109;
pub const DOMAIN_GROUP_RID_POLICY_ADMINS = @as(c_long, 520);
pub const POWER_REQUEST_CONTEXT_DETAILED_STRING = DIAGNOSTIC_REASON_DETAILED_STRING;
pub const CRYPT_DELETEKEYSET = 16;
pub const SPI_GETMOUSEWHEELROUTING = 8220;
pub const FOF_NORECURSION = 4096;
pub const CERT_AUTO_UPDATE_DISABLE_RANDOM_QUERY_STRING_FLAG = 4;
pub const PROPSETFLAG_ANSI = 2;
pub const STORAGE_TIER_FLAG_NO_SEEK_PENALTY = 131072;
pub const URLPOLICY_AUTHENTICATE_MUTUAL_ONLY = 196608;
pub const GetFileAttributesTransacted = GetFileAttributesTransactedA;
pub const __SIZEOF_WCHAR_T__ = 2;
pub const ABS_ALWAYSONTOP = 2;
pub const ERROR_WMI_SET_FAILURE = @as(c_long, 4214);
pub const LOCALE_ILZERO = 18;
pub const ERROR_CLUSTER_USE_SHARED_VOLUMES_API = @as(c_long, 5948);
pub const CERT_LOGOTYPE_TABLE_SIZE_IMAGE_RESOLUTION_CHOICE = 2;
pub const EFS_SUBVER_UNKNOWN = 0;
pub const PF_XMMI_INSTRUCTIONS_AVAILABLE = 6;
pub const SHUTDOWN_NORETRY = 1;
pub const LOCALE_SNATIVECTRYNAME = LOCALE_SNATIVECOUNTRYNAME;
pub const szOID_EFS_RECOVERY = "1.3.6.1.4.1.311.10.3.4.1";
pub const CF_TIFF = 6;
pub const ERROR_CLUSTER_SHARED_VOLUME_FAILOVER_NOT_ALLOWED = @as(c_long, 5961);
pub const CREATECOLORSPACE_EMBEDED = 1;
pub const DMDFO_CENTER = 2;
pub const JOB_NOTIFY_FIELD_START_TIME = 17;
pub const FW_ULTRALIGHT = FW_EXTRALIGHT;
pub const PRINTER_CONNECTION_MISMATCH = 32;
pub const VER_SUITE_TERMINAL = 16;
pub const MIXERCONTROL_CT_CLASS_METER = @as(c_long, 268435456);
pub const CertRDNValueToStr = CertRDNValueToStrA;
pub const TAPE_DRIVE_LOG_BLK_IMMED = 2147516416;
pub const VarI1FromUint = VarI1FromUI4;
pub const PRODUCT_STORAGE_STANDARD_EVALUATION_SERVER = 96;
pub const PSP_PREMATURE = 1024;
pub const CTRY_POLAND = 48;
pub const PAGE_NOACCESS = 1;
pub const SUBLANG_TAMIL_SRI_LANKA = 2;
pub const __BMI__ = 1;
pub const szOID_NAME_CONSTRAINTS = "2.5.29.30";
pub const CERT_QUERY_FORMAT_BASE64_ENCODED = 2;
pub const NCRYPT_IMPL_HARDWARE_FLAG = 1;
pub const _IRQL_always_function_max_ = irql;
pub const MCI_ANIM_STATUS_FORWARD = @as(c_long, 16386);
pub const CMSG_ENVELOPED_RECIPIENT_V2 = 2;
pub const DOMAIN_GROUP_RID_COMPUTERS = @as(c_long, 515);
pub const CERT_STORE_PROV_READ_CRL_FUNC = 5;
pub const PRINTER_CHANGE_DELETE_PRINTER = 4;
pub const DMBIN_FORMSOURCE = 15;
pub const SERVICE_INACTIVE = 2;
pub const FF_MODERN = 3 << 4;
pub const ESRCH = 3;
pub const APPCOMMAND_MEDIA_STOP = 13;
pub const DMPAPER_JENV_KAKU2_ROTATED = 84;
pub const CLR_INVALID = 4294967295;
pub const ERROR_LB_WITHOUT_TABSTOPS = @as(c_long, 1434);
pub const VBS_BASIC_PAGE_MEASURED_DATA = 1;
pub const CMC_FAIL_BAD_REQUEST = 2;
pub const ERROR_LOG_METADATA_CORRUPT = @as(c_long, 6612);
pub const MDM_MASK_X75_DATA = 7;
pub const FILE_NOTIFY_CHANGE_SIZE = 8;
pub const InterlockedPushListSList = InterlockedPushListSListEx;
pub const PDERR_DNDMMISMATCH = 4105;
pub const EXCEPTION_ILLEGAL_INSTRUCTION = STATUS_ILLEGAL_INSTRUCTION;
pub const EM_REPLACESEL = 194;
pub const JOB_STATUS_USER_INTERVENTION = 1024;
pub const KP_PREHASH = 34;
pub const REG_NOTIFY_CHANGE_ATTRIBUTES = @as(c_long, 2);
pub const szOID_RSA_SHA384RSA = "1.2.840.113549.1.1.12";
pub const META_CHORD = 2096;
pub const RESOURCETYPE_ANY = 0;
pub const RPC_C_HTTP_FLAG_USE_SSL = 1;
pub const SPI_SETCARETTIMEOUT = 8227;
pub const CAL_SMONTHNAME5 = 25;
pub const NCRYPT_CLAIM_AUTHORITY_ONLY = 1;
pub const MOM_DONE = MM_MOM_DONE;
pub const SE_PRIVILEGE_ENABLED_BY_DEFAULT = @as(c_long, 1);
pub const IOCTL_CHANGER_BASE = FILE_DEVICE_CHANGER;
pub const ERROR_DS_INAPPROPRIATE_MATCHING = @as(c_long, 8238);
pub const ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT = @as(c_long, 14101);
pub const SCRUB_DATA_INPUT_FLAG_IGNORE_REDUNDANCY = 8;
pub const DFCS_SCROLLSIZEGRIP = 8;
pub const TOUCH_HIT_TESTING_DEFAULT = 0;
pub const DRIVE_UNKNOWN = 0;
pub const CMSG_BARE_CONTENT_PARAM = 3;
pub const ACCESS_MAX_MS_V5_ACE_TYPE = 21;
pub const BCRYPT_RC4_ALG_HANDLE = if (@typeId(@typeOf(113)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 113) else if (@typeId(@typeOf(113)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 113) else BCRYPT_ALG_HANDLE(113);
pub const QDC_ALL_PATHS = 1;
pub const RPC_ENTRY = __stdcall;
pub const RPC_PROTSEQ_LRPC = 3;
pub const ES_RIGHT = @as(c_long, 2);
pub const ERROR_INVALID_DEVICE_OBJECT_PARAMETER = @as(c_long, 650);
pub const WM_DPICHANGED = 736;
pub const URLPOLICY_JAVA_PROHIBIT = 0;
pub const STATE_SYSTEM_OFFSCREEN = 65536;
pub const CTRY_SOUTH_KOREA = 82;
pub const GetTabbedTextExtent = GetTabbedTextExtentA;
pub const PPCAPS_REVERSE_PAGES_FOR_REVERSE_DUPLEX = 1;
pub const NTDDI_WS08SP2 = NTDDI_WIN6SP2;
pub const DMPAPER_A3_EXTRA = 63;
pub const DFCS_MENUARROW = 0;
pub const SET_MIRROR_MODE = 4110;
pub const NCBCALL = 16;
pub const VK_ACCEPT = 30;
pub const PROC_THREAD_ATTRIBUTE_NUMBER = 65535;
pub const N_TSHIFT = 2;
pub const LPPROPSHEETPAGE_V3 = LPPROPSHEETPAGEA_V3;
pub const EVENT_SYSTEM_IME_KEY_NOTIFICATION = 41;
pub const ALG_SID_SSL3SHAMD5 = 8;
pub const ERROR_TOO_MANY_DESCRIPTORS = @as(c_long, 331);
pub const CRYPT_OVERWRITE = 1;
pub const DMPAPER_QUARTO = 15;
pub const PROCESS_NAME_NATIVE = 1;
pub const ERROR_IPSEC_IKE_UNKNOWN_DOI = @as(c_long, 13862);
pub const WDT_INPROC_CALL = 1215587415;
pub const VP_FLAGS_FLICKER = 4;
pub const MEM_RESERVE = 8192;
pub const DNS_ERROR_UNKNOWN_SIGNING_PARAMETER_VERSION = @as(c_long, 9111);
pub const IMAGE_REL_IA64_PCREL60B = 22;
pub const KP_G = 12;
pub const PKCS12_ALLOW_OVERWRITE_KEY = 16384;
pub const ERROR_DOMAIN_LIMIT_EXCEEDED = @as(c_long, 1357);
pub const TAPE_DRIVE_REWIND_IMMEDIATE = 2147483656;
pub const ERROR_SEM_NOT_FOUND = @as(c_long, 187);
pub const SPIF_SENDCHANGE = SPIF_SENDWININICHANGE;
pub const ICM_REGISTERICMATCHER = 5;
pub const FEATURESETTING_CUSTPAPER = 3;
pub const VK_GAMEPAD_RIGHT_TRIGGER = 202;
pub const WS_EX_CLIENTEDGE = @as(c_long, 512);
pub const SCARD_LEAVE_CARD = 0;
pub const GrayString = GrayStringA;
pub const CMSG_VERIFY_SIGNER_CHAIN = 3;
pub const FAST_FAIL_INVALID_DISPATCH_CONTEXT = 39;
pub const ELF_VENDOR_SIZE = 4;
pub const SUBLANG_ENGLISH_UK = 2;
pub const RPC_C_NS_SYNTAX_DCE = 3;
pub const CONTEXT_S_FIRST = @as(c_long, 319488);
pub const CERT_FIND_NO_CTL_USAGE_FLAG = CERT_FIND_NO_ENHKEY_USAGE_FLAG;
pub const CRYPT_PSTORE = 2;
pub const CTRY_TAIWAN = 886;
pub const iscsym = __iscsym;
pub const DCBA_FACEUPLEFT = 2;
pub const ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE = @as(c_long, 5031);
pub const PROCESSOR_INTEL_PENTIUM = 586;
pub const SO_KEEPALIVE = 8;
pub const CE_TXFULL = 256;
pub const GCL_CBWNDEXTRA = -18;
pub const TAPE_DRIVE_SET_EOT_WZ_SIZE = 4194304;
pub const FILE_INITIATE_REPAIR_HINT1_OUT_OF_GENERIC_NAMES = 1073741824;
pub const VK_XBUTTON1 = 5;
pub const ATF_TIMEOUTON = 1;
pub const NORM_IGNOREKANATYPE = 65536;
pub const CHANGER_KEYPAD_ENABLE_DISABLE = 268435456;
pub const DM_DISPLAYFLAGS = @as(c_long, 2097152);
pub const DMLERR_POKEACKTIMEOUT = 16395;
pub const STATUS_SXS_INVALID_DEACTIVATION = if (@typeId(@typeOf(@as(c_long, 3222601744))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3222601744)) else if (@typeId(@typeOf(@as(c_long, 3222601744))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3222601744)) else DWORD(@as(c_long, 3222601744));
pub const URLACTION_CHANNEL_SOFTDIST_MIN = 7680;
pub const ERROR_CTX_CLOSE_PENDING = @as(c_long, 7007);
pub const SUBLANG_CZECH_CZECH_REPUBLIC = 1;
pub const MCI_SET_VIDEO = @as(c_long, 4096);
pub const TT_AVAILABLE = 1;
pub const NOTIFYICON_VERSION = 3;
pub const CRYPT_VERIFY_DATA_HASH = 64;
pub const IMAGE_REL_CEE_ADDR32 = 1;
pub const ENOPROTOOPT = 123;
pub const ERROR_TRANSACTION_NOT_FOUND = @as(c_long, 6715);
pub const UILANGUAGE_ENUMPROC = UILANGUAGE_ENUMPROCA;
pub const EMR_SETDIBITSTODEVICE = 80;
pub const szOID_PHYSICAL_DELIVERY_OFFICE_NAME = "2.5.4.19";
pub const IN_CLASSC_NET = 4294967040;
pub const WOW64_CONTEXT_EXCEPTION_REQUEST = 1073741824;
pub const PRINTER_ENUM_SHARED = 32;
pub const STORAGE_ATTRIBUTE_BLOCK_IO = 2;
pub const ERROR_IMPLEMENTATION_LIMIT = @as(c_long, 1292);
pub const FR_SHOWWRAPAROUND = 262144;
pub const ERROR_DRIVE_NOT_INSTALLED = 8;
pub const LOCALE_SABBREVMONTHNAME11 = 78;
pub const __deref_opt_inout_bcount_nz_opt = size;
pub const NRC_LOCKFAIL = 60;
pub const szOID_CERT_SIGNATURE_HASH_PROP_ID = "1.3.6.1.4.1.311.10.11.15";
pub const OutputDebugString = OutputDebugStringA;
pub const SPI_SETHOTTRACKING = 4111;
pub const EMR_POLYGON16 = 86;
pub const CRYPT_ENABLE_FILE_RETRIEVAL = 134217728;
pub const WVR_ALIGNBOTTOM = 64;
pub const CERT_CHAIN_AUTO_SERIAL_LOCAL_MACHINE = 7;
pub const PF_UNKNOWN1 = AF_UNKNOWN1;
pub const _Use_decl_annotations_ = _Use_decl_anno_impl_;
pub const STORAGE_DEVICE_NUMA_NODE_UNKNOWN = MAXDWORD;
pub const JOB_STATUS_COMPLETE = 4096;
pub const DNS_ERROR_RCODE_LAST = DNS_ERROR_RCODE_BADTIME;
pub const ERROR_CLUSTER_AFFINITY_CONFLICT = @as(c_long, 5971);
pub const __OPENCL_MEMORY_SCOPE_DEVICE = 2;
pub const DISCHARGE_POLICY_CRITICAL = 0;
pub const ERROR_JOURNAL_ENTRY_DELETED = @as(c_long, 1181);
pub const ENCRYPTION_FORMAT_DEFAULT = 1;
pub const DMPAPER_LETTER_TRANSVERSE = 54;
pub const CERT_STORE_PROV_SYSTEM_REGISTRY_W = if (@typeId(@typeOf(13)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 13) else if (@typeId(@typeOf(13)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 13) else LPCSTR(13);
pub const LINECAPS = 30;
pub const __FLT_MAX__ = 340282346999999984391321947108527833088.000000;
pub const DEVICEFAMILYINFOENUM_XBOX = 5;
pub const ERROR_SXS_XML_E_UNCLOSEDTAG = @as(c_long, 14052);
pub const ERROR_MUTUAL_AUTH_FAILED = @as(c_long, 1397);
pub const RPC_S_NO_CALL_ACTIVE = @as(c_long, 1725);
pub const REGISTERED = 4;
pub const PORT_TYPE_WRITE = 1;
pub const EMR_FILLRGN = 71;
pub const QS_MOUSEMOVE = 2;
pub const CF_DSPMETAFILEPICT = 131;
pub const PRINTER_NOTIFY_FIELD_BRANCH_OFFICE_PRINTING = 28;
pub const TC_CR_ANY = 16;
pub const CTRY_YEMEN = 967;
pub const WDT_REMOTE_CALL = 1383359575;
pub const CERT_INFO_NOT_BEFORE_FLAG = 5;
pub const ERROR_TRANSACTIONS_NOT_FROZEN = @as(c_long, 6839);
pub const OFN_ENABLETEMPLATEHANDLE = 128;
pub const VALID_INHERIT_FLAGS = 31;
pub const EXCEPTION_FLT_INEXACT_RESULT = STATUS_FLOAT_INEXACT_RESULT;
pub const PROV_RSA_AES = 24;
pub const __ADX__ = 1;
pub const MCI_CLOSE = 2052;
pub const CDN_TYPECHANGE = if (@typeId(@typeOf(-6)) == @import("builtin").TypeId.Pointer) @ptrCast(CDN_FIRST, -6) else if (@typeId(@typeOf(-6)) == @import("builtin").TypeId.Int) @intToPtr(CDN_FIRST, -6) else CDN_FIRST(-6);
pub const NTDDI_WS08SP3 = NTDDI_WIN6SP3;
pub const FACILITY_XPS = 82;
pub const szOID_PKCS_12_EXTENDED_ATTRIBUTES = "1.3.6.1.4.1.311.17.3";
pub const DMDITHER_NONE = 1;
pub const LPPROPSHEETPAGE_V2 = LPPROPSHEETPAGEA_V2;
pub const FACILITY_DEPLOYMENT_SERVICES_IMAGING = 258;
pub const XACT_S_LAST = 315408;
pub const MCI_OVLY_WINDOW_STATE = @as(c_long, 262144);
pub const MOUSE_EVENT = 2;
pub const IO_REPARSE_TAG_GLOBAL_REPARSE = @as(c_long, 2684354585);
pub const ERROR_CLUSTER_NODE_UP = @as(c_long, 5056);
pub const URLACTION_SHELL_EXECUTE_MODRISK = 6151;
pub const ERROR_DS_NOT_SUPPORTED = @as(c_long, 8256);
pub const CREATE_NEW = 1;
pub const TIME_VALID_OID_GET_CRL_FROM_CERT = if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 3) else if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 3) else LPCSTR(3);
pub const IMAGE_REL_ARM_BRANCH11 = 4;
pub const __XSAVEOPT__ = 1;
pub const InitiateSystemShutdownEx = InitiateSystemShutdownExA;
pub const CERT_FILE_HASH_USE_TYPE = 1;
pub const PIDSI_AUTHOR = @as(c_long, 4);
pub const CERT_SELECT_BY_FRIENDLYNAME = 13;
pub const PP_CLIENT_HWND = 1;
pub const VARIANT_LOCALBOOL = 16;
pub const DMICM_COLORIMETRIC = 3;
pub const CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG = 4;
pub const IPPORT_TIMESERVER = 37;
pub const RC_DIBTODEV = 512;
pub const PROCESS_VM_READ = 16;
pub const BS_PUSHBUTTON = @as(c_long, 0);
pub const MARK_HANDLE_READ_COPY = 128;
pub const MAXUINT8 = if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT8, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT8, 0) else UINT8(0))) == @import("builtin").TypeId.Pointer) @ptrCast(UINT8, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT8, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT8, 0) else UINT8(0)) else if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT8, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT8, 0) else UINT8(0))) == @import("builtin").TypeId.Int) @intToPtr(UINT8, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT8, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT8, 0) else UINT8(0)) else UINT8(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT8, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT8, 0) else UINT8(0));
pub const ERROR_LOG_FILE_FULL = @as(c_long, 1502);
pub const ERROR_RESMON_SYSTEM_RESOURCES_LACKING = @as(c_long, 5956);
pub const LR_COPYRETURNORG = 4;
pub const PFD_STEREO_DONTCARE = 2147483648;
pub const VER_SUITE_PERSONAL = 512;
pub const EXECUTE_OFFLINE_DIAGS = 212;
pub const FADF_RESERVED = 61448;
pub const ERROR_DS_DUP_SCHEMA_ID_GUID = @as(c_long, 8381);
pub const InterlockedXor64 = _InterlockedXor64;
pub const PARSE_ENCODE = PARSE_ENCODE_IS_UNESCAPE;
pub const WNNC_NET_MASFAX = 3211264;
pub const STG_LAYOUT_INTERLEAVED = @as(c_long, 1);
pub const WNNC_NET_LOCK = 3473408;
pub const NCRYPT_AUTHORITY_KEY_FLAG = 256;
pub const SWP_DRAWFRAME = SWP_FRAMECHANGED;
pub const MOUSEEVENTF_ABSOLUTE = 32768;
pub const KF_DLGMODE = 2048;
pub const szOID_LOYALTY_OTHER_LOGOTYPE = "1.3.6.1.5.5.7.20.1";
pub const NCRYPT_TPM_PSS_SALT_SIZE_UNKNOWN = 0;
pub const VP_MODE_WIN_GRAPHICS = 1;
pub const szOID_SERVER_GATED_CRYPTO = "1.3.6.1.4.1.311.10.3.3";
pub const ERROR_FILE_LEVEL_TRIM_NOT_SUPPORTED = @as(c_long, 326);
pub const X3_P_SIGN_VAL_POS_X = 0;
pub const CB_GETCOMBOBOXINFO = 356;
pub const PIPE_TYPE_MESSAGE = 4;
pub const RPC_S_UNKNOWN_AUTHN_SERVICE = @as(c_long, 1747);
pub const BCRYPT_CAPI_AES_FLAG = 16;
pub const ImmGetCandidateListCount = ImmGetCandidateListCountA;
pub const SETICMPROFILE_EMBEDED = 1;
pub const ERROR_INVALID_LIST_FORMAT = @as(c_long, 153);
pub const DMLERR_SERVER_DIED = 16398;
pub const STATUS_DLL_NOT_FOUND = if (@typeId(@typeOf(@as(c_long, 3221225781))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225781)) else if (@typeId(@typeOf(@as(c_long, 3221225781))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225781)) else DWORD(@as(c_long, 3221225781));
pub const LANG_ALSATIAN = 132;
pub const FILEOKSTRINGA = "commdlg_FileNameOK";
pub const CC_NONE = 0;
pub const EC_LEFTMARGIN = 1;
pub const ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER = @as(c_long, 6713);
pub const CERT_CHAIN_CRL_VALIDITY_EXT_PERIOD_HOURS_DEFAULT = 12;
pub const PARTITION_IFS = 7;
pub const VK_PA1 = 253;
pub const szOID_CMC_ID_POP_LINK_RANDOM = "1.3.6.1.5.5.7.7.22";
pub const TPM_VERNEGANIMATION = @as(c_long, 8192);
pub const CT_CTYPE1 = 1;
pub const SHGFI_ATTRIBUTES = 2048;
pub const CMSG_CRYPT_RELEASE_CONTEXT_FLAG = 32768;
pub const MUI_NON_LANG_NEUTRAL_FILE = 512;
pub const ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE = @as(c_long, 5941);
pub const SM_SECURE = 44;
pub const LOCALE_SABBREVMONTHNAME10 = 77;
pub const SERVICE_STOP_REASON_MINOR_MIN = 0;
pub const IMC_SETCOMPOSITIONWINDOW = 12;
pub const JOB_OBJECT_LIMIT_PROCESS_TIME = 2;
pub const PAN_XHEIGHT_DUCKING_SMALL = 5;
pub const IMAGE_REL_ARM_SECREL = 15;
pub const PRINTER_NOTIFY_FIELD_DEVMODE = 7;
pub const SCardGetCardTypeProviderName = SCardGetCardTypeProviderNameA;
pub const PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_NO_LOW_LABEL_MASK = if (@typeId(@typeOf(i64 << 56)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 56) else if (@typeId(@typeOf(i64 << 56)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 56) else @as(c_uint, 3)(i64 << 56);
pub const ERROR_ENCLAVE_NOT_TERMINATED = @as(c_long, 814);
pub const TAPE_SPACE_FILEMARKS = @as(c_long, 6);
pub const WN_SUCCESS = NO_ERROR;
pub const _WIN64 = 1;
pub const CERT_IE30_RESERVED_PROP_ID = 7;
pub const VER_SUITE_STORAGE_SERVER = 8192;
pub const RANDOM_PADDING = 2;
pub const ERROR_APP_DATA_CORRUPT = @as(c_long, 4402);
pub const CERT_STORE_PROV_SYSTEM = CERT_STORE_PROV_SYSTEM_W;
pub const CMSG_ENVELOPED_RECIPIENT_V4 = 4;
pub const SC_MANAGER_LOCK = 8;
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_WCOS_ID = 10;
pub const CRYPT_DELETE_KEYSET = CRYPT_DELETEKEYSET;
pub const POWER_ACTION_OVERRIDE_APPS = 4;
pub const BST_UNCHECKED = 0;
pub const FEATURESETTING_MIRROR = 4;
pub const ImmGetCandidateList = ImmGetCandidateListA;
pub const IDH_MISSING_CONTEXT = 28441;
pub const MDMSPKR_DIAL = 1;
pub const TRANSACTION_NOTIFY_INDOUBT = 16384;
pub const PRODUCT_ENTERPRISE_SERVER_CORE = 14;
pub const WM_PRINTCLIENT = 792;
pub const WN_CANCEL = ERROR_CANCELLED;
pub const ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED = @as(c_long, 13823);
pub const PSH_HASHELP = 512;
pub const CreateMetaFile = CreateMetaFileA;
pub const STATE_SYSTEM_EXPANDED = 512;
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME = 2;
pub const DMLERR_UNADVACKTIMEOUT = 16400;
pub const DDE_FACKREQ = 32768;
pub const PROTECTION_LEVEL_NONE = 4294967294;
pub const TRANSACTION_NOTIFY_ENLIST_PREPREPARE = 4096;
pub const ERROR_INVALID_MODULETYPE = @as(c_long, 190);
pub const LB_ADDFILE = 406;
pub const PAN_SERIF_SQUARE_COVE = 4;
pub const lstrcpyn = lstrcpynA;
pub const PCF_TOTALTIMEOUTS = if (@typeId(@typeOf(64)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 64) else if (@typeId(@typeOf(64)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 64) else DWORD(64);
pub const CTRY_QATAR = 974;
pub const WN_NET_ERROR = ERROR_UNEXP_NET_ERR;
pub const MB_RIGHT = @as(c_long, 524288);
pub const BCRYPT_PAD_PKCS1 = 2;
pub const FILE_ADD_SUBDIRECTORY = 4;
pub const ERROR_RESOURCE_NOT_IN_AVAILABLE_STORAGE = @as(c_long, 5965);
pub const WM_GETFONT = 49;
pub const ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION = 3;
pub const ExtractIcon = ExtractIconA;
pub const FW_EXTRALIGHT = 200;
pub const ERROR_CANT_TERMINATE_SELF = @as(c_long, 555);
pub const MCI_OVLY_PUT_VIDEO = @as(c_long, 1048576);
pub const __UINTMAX_FMTo__ = "llo";
pub const ERROR_DEPENDENCY_NOT_ALLOWED = @as(c_long, 5069);
pub const FACILITY_WINPE = 61;
pub const ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN = @as(c_long, 8537);
pub const S_THRESHOLD = 1;
pub const __F16C__ = 1;
pub const POWER_SETTING_VALUE_VERSION = 1;
pub const HEAP_DISABLE_COALESCE_ON_FREE = 128;
pub const IME_ESC_SET_EUDC_DICTIONARY = 4100;
pub const ERROR_EOM_OVERFLOW = @as(c_long, 1129);
pub const __inout_bcount_nz_opt = size;
pub const GetExceptionCode = _exception_code;
pub const szOID_RSA_signedData = "1.2.840.113549.1.7.2";
pub const CFSTR_MIME_X_AIFF = if (@typeId(@typeOf("audio/x-aiff")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "audio/x-aiff") else if (@typeId(@typeOf("audio/x-aiff")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "audio/x-aiff") else TEXT("audio/x-aiff");
pub const LMEM_INVALID_HANDLE = 32768;
pub const AW_CENTER = 16;
pub const DEVICEFAMILYDEVICEFORM_PRINTING = 25;
pub const CERT_QUERY_CONTENT_CERT = 1;
pub const INTERNATIONAL_USAGE = 1;
pub const CF_PRINTERFONTS = 2;
pub const IID_IOInetProtocolEx = IID_IInternetProtocolEx;
pub const CTRY_PORTUGAL = 351;
pub const FILE_SKIP_COMPLETION_PORT_ON_SUCCESS = 1;
pub const MCI_DEVTYPE_SCANNER = 518;
pub const MS_DEF_PROV = MS_DEF_PROV_A;
pub const TA_RIGHT = 2;
pub const DMPAPER_ISO_B4 = 42;
pub const ABE_TOP = 1;
pub const VER_SERVER_NT = 2147483648;
pub const SPI_GETWHEELSCROLLCHARS = 108;
pub const ERROR_SCRUB_DATA_DISABLED = @as(c_long, 332);
pub const META_STRETCHBLT = 2851;
pub const DOWNLOADFACE = 514;
pub const RPC_S_NOT_ALL_OBJS_EXPORTED = @as(c_long, 1923);
pub const CERT_SCARD_PIN_ID_PROP_ID = 90;
pub const __FLT16_DECIMAL_DIG__ = 5;
pub const LANG_SLOVAK = 27;
pub const FILE_NAMED_STREAMS = 262144;
pub const SCARD_CLASS_SECURITY = 5;
pub const ERROR_META_EXPANSION_TOO_LONG = @as(c_long, 208);
pub const PF_PAE_ENABLED = 9;
pub const LANG_KAZAK = 63;
pub const ERROR_NO_SYSTEM_RESOURCES = @as(c_long, 1450);
pub const ERROR_DS_RDN_DOESNT_MATCH_SCHEMA = @as(c_long, 8307);
pub const ALG_SID_SHA1 = 4;
pub const TAPE_PSEUDO_LOGICAL_BLOCK = @as(c_long, 3);
pub const szOID_REQUEST_CLIENT_INFO = "1.3.6.1.4.1.311.21.20";
pub const ERROR_CLUSTER_PARTIAL_WRITE = @as(c_long, 5922);
pub const RPC_IF_ALLOW_SECURE_ONLY = 8;
pub const AddPort = AddPortA;
pub const MM_HIENGLISH = 5;
pub const ERROR_BAD_LENGTH = @as(c_long, 24);
pub const IN_CLASSB_NSHIFT = 16;
pub const FE_FONTSMOOTHINGSTANDARD = 1;
pub const SO_LINGER = 128;
pub const WS_EX_WINDOWEDGE = @as(c_long, 256);
pub const SS_BLACKFRAME = @as(c_long, 7);
pub const SHGFI_ATTR_SPECIFIED = 131072;
pub const IMAGE_REL_AMD64_TOKEN = 13;
pub const SPI_GETMINIMUMHITRADIUS = 8212;
pub const PRINTER_NOTIFY_FIELD_ATTRIBUTES = 13;
pub const CF_NULL = 0;
pub const CERT_COMPARE_HAS_PRIVATE_KEY = 21;
pub const ERROR_NOT_QUORUM_CAPABLE = @as(c_long, 5021);
pub const ERROR_BAD_FORMAT = @as(c_long, 11);
pub const DOMAIN_GROUP_RID_CDC_RESERVED = @as(c_long, 524);
pub const GetPrivateProfileSection = GetPrivateProfileSectionA;
pub const SetDlgItemText = SetDlgItemTextA;
pub const BM_GETIMAGE = 246;
pub const JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS = 255;
pub const MAXUHALF_PTR = if (@typeId(@typeOf(~0)) == @import("builtin").TypeId.Pointer) @ptrCast(UHALF_PTR, ~0) else if (@typeId(@typeOf(~0)) == @import("builtin").TypeId.Int) @intToPtr(UHALF_PTR, ~0) else UHALF_PTR(~0);
pub const WM_MENUSELECT = 287;
pub const MDM_MASK_V120_ML = 3 << 6;
pub const __UINT_FAST64_FMTo__ = "llo";
pub const FACILITY_USERMODE_VIRTUALIZATION = 55;
pub const SIZE_RESTORED = 0;
pub const CT_CTYPE2 = 2;
pub const SUBLANG_LITHUANIAN = 1;
pub const LOCALE_SABBREVMONTHNAME13 = 4111;
pub const PSH_WIZARDHASFINISH = 16;
pub const ERROR_DS_DRA_SCHEMA_MISMATCH = @as(c_long, 8418);
pub const PostAppMessage = PostAppMessageA;
pub const BCRYPT_RNG_INTERFACE = 6;
pub const szOID_CROSS_CERTIFICATE_PAIR = "2.5.4.40";
pub const BINDF_DONTPUTINCACHE = BINDF_NOWRITECACHE;
pub const STATUS_NONCONTINUABLE_EXCEPTION = if (@typeId(@typeOf(@as(c_long, 3221225509))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225509)) else if (@typeId(@typeOf(@as(c_long, 3221225509))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225509)) else DWORD(@as(c_long, 3221225509));
pub const DM_PAPERWIDTH = @as(c_long, 8);
pub const CTRY_FINLAND = 358;
pub const WSA_QOS_REQUEST_CONFIRMED = @as(c_long, 11009);
pub const ERROR_CLUSTER_CANNOT_RETURN_PROPERTIES = @as(c_long, 5968);
pub const DNS_ERROR_NUMERIC_NAME = @as(c_long, 9561);
pub const ERROR_CLASS_ALREADY_EXISTS = @as(c_long, 1410);
pub const __ORDER_LITTLE_ENDIAN__ = 1234;
pub const IDI_ERROR = IDI_HAND;
pub const DNS_ERROR_RCODE_FORMAT_ERROR = @as(c_long, 9001);
pub const RPC_S_CALL_IN_PROGRESS = @as(c_long, 1791);
pub const CF_APPLY = @as(c_long, 512);
pub const RpcBindingFromStringBinding = RpcBindingFromStringBindingA;
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_COUNT_PER_CHAIN_DEFAULT = 3;
pub const CBS_UPPERCASE = @as(c_long, 8192);
pub const WINEVENT_SKIPOWNPROCESS = 2;
pub const URLPOLICY_AUTHENTICATE_CHALLENGE_RESPONSE = 65536;
pub const SORTED_CTL_EXT_HASH_BUCKET_OFFSET = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast([*c]3, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr([*c]3, 4) else ([*c]3)(4);
pub const URLACTION_ALLOW_ZONE_ELEVATION_OPT_OUT_ADDITION = 9990;
pub const ENOSPC = 28;
pub const RPC_S_INVALID_BOUND = @as(c_long, 1734);
pub const DSS_NORMAL = 0;
pub const CFSTR_MIME_RICHTEXT = if (@typeId(@typeOf("text/richtext")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "text/richtext") else if (@typeId(@typeOf("text/richtext")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "text/richtext") else TEXT("text/richtext");
pub const CF_DSPENHMETAFILE = 142;
pub const HCBT_CLICKSKIPPED = 6;
pub const PRINTER_ACCESS_USE = 8;
pub const CONTEXT_EXCEPTION_REQUEST = @as(c_long, 1073741824);
pub const ERROR_CLUSTER_JOIN_ABORTED = @as(c_long, 5074);
pub const DNS_ERROR_NSEC3_INCOMPATIBLE_WITH_RSA_SHA1 = @as(c_long, 9103);
pub const EMR_SCALEVIEWPORTEXTEX = 31;
pub const DEVICEFAMILYDEVICEFORM_VENDING = 28;
pub const SET_FEATURE_ON_THREAD_INTERNET = 64;
pub const CRYPT_MODE_ECB = 2;
pub const RTL_CRITICAL_SECTION_FLAG_RESOURCE_TYPE = 134217728;
pub const MIM_STYLE = 16;
pub const PC_STYLED = 32;
pub const RegEnumKeyEx = RegEnumKeyExA;
pub const URL_OID_CRL_FRESHEST_CRL = if (@typeId(@typeOf(7)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 7) else if (@typeId(@typeOf(7)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 7) else LPCSTR(7);
pub const ERROR_ENLISTMENT_NOT_SUPERIOR = @as(c_long, 6820);
pub const PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_NO_LOW_LABEL_ALWAYS_ON = if (@typeId(@typeOf(i64 << 56)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << 56) else if (@typeId(@typeOf(i64 << 56)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << 56) else @as(c_uint, 1)(i64 << 56);
pub const DATE_LONGDATE = 2;
pub const QDC_ONLY_ACTIVE_PATHS = 2;
pub const VARIANT_CALENDAR_HIJRI = 8;
pub const ERROR_JOB_NO_CONTAINER = @as(c_long, 1505);
pub const CRL_FIND_ISSUED_BY_AKI_FLAG = 1;
pub const CTRY_SINGAPORE = 65;
pub const CALINFO_ENUMPROCEX = CALINFO_ENUMPROCEXA;
pub const DISP_CHANGE_BADDUALVIEW = -6;
pub const GL_LEVEL_WARNING = 3;
pub const SPI_GETMENUANIMATION = 4098;
pub const SW_SCROLLCHILDREN = 1;
pub const ERROR_DISK_FULL = @as(c_long, 112);
pub const ERROR_NOT_SAFE_MODE_DRIVER = @as(c_long, 646);
pub const CHANGER_STORAGE_IEPORT = 8192;
pub const ENABLE_DISABLE_AUTOSAVE = 210;
pub const RPCFLG_HAS_CALLBACK = @as(c_ulong, 67108864);
pub const NCRYPT_KEY_PROTECTION_INTERFACE = 65540;
pub const PENVISUALIZATION_ON = 35;
pub const __UINT_FAST8_MAX__ = 255;
pub const __DBL_MIN_10_EXP__ = -307;
pub const WINUSERAPI = DECLSPEC_IMPORT;
pub const DMTT_SUBDEV = 3;
pub const CreateWindowStation = CreateWindowStationA;
pub const IMAGE_SYM_TYPE_WORD = 13;
pub const MM_JOY1ZMOVE = 930;
pub const PARITY_EVEN = if (@typeId(@typeOf(1024)) == @import("builtin").TypeId.Pointer) @ptrCast(WORD, 1024) else if (@typeId(@typeOf(1024)) == @import("builtin").TypeId.Int) @intToPtr(WORD, 1024) else WORD(1024);
pub const EnumJobs = EnumJobsA;
pub const SCHANNEL_MAC_KEY = 0;
pub const FEATURESETTING_NEGATIVE = 5;
pub const SET_FEATURE_ON_THREAD_TRUSTED = 32;
pub const TKF_HOTKEYSOUND = 16;
pub const EnumPrintProcessorDatatypes = EnumPrintProcessorDatatypesA;
pub const RPC_C_BINDING_DEFAULT_TIMEOUT = 5;
pub const FILE_DEVICE_FULLSCREEN_VIDEO = 52;
pub const __SSP_STRONG__ = 2;
pub const ERROR_MRM_GENERATION_COUNT_MISMATCH = @as(c_long, 15147);
pub const PSINJECT_BEGINSTREAM = 1;
pub const ERROR_CANT_RESOLVE_FILENAME = @as(c_long, 1921);
pub const ELEMENT_STATUS_LUN_VALID = 4096;
pub const isascii = __isascii;
pub const CRYPT_OBJECT_LOCATOR_SPN_NAME_TYPE = 1;
pub const FAST_FAIL_UNSAFE_EXTENSION_CALL = 26;
pub const META_SETTEXTJUSTIFICATION = 522;
pub const DISPLAY_DEVICE_MULTI_DRIVER = 2;
pub const R2_NOP = 11;
pub const LGRPID_KOREAN = 8;
pub const SHUTDOWN_TYPE_LEN = 32;
pub const MDM_V120_SPEED_56K = 2;
pub const PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_RESERVED = 3 << 12;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY = 512;
pub const AddAtom = AddAtomA;
pub const CERT_CHAIN_FIND_BY_ISSUER = 1;
pub const ERROR_CLUSTER_LAST_INTERNAL_NETWORK = @as(c_long, 5066);
pub const ERROR_APPEXEC_CONDITION_NOT_SATISFIED = @as(c_long, 3060);
pub const SetPort = SetPortA;
pub const PERF_DISPLAY_NO_SUFFIX = 0;
pub const FW_MEDIUM = 500;
pub const PFD_SUPPORT_DIRECTDRAW = 8192;
pub const SEF_MACL_NO_READ_UP = 512;
pub const ERROR_DATA_CHECKSUM_ERROR = @as(c_long, 323);
pub const VK_XBUTTON2 = 6;
pub const ALG_SID_ECDSA = 3;
pub const IMAGE_DEBUG_TYPE_POGO = 13;
pub const SUBLANG_SLOVENIAN_SLOVENIA = 1;
pub const HSHELL_TASKMAN = 7;
pub const PRODUCT_STANDARD_SERVER_CORE = 13;
pub const ERROR_ONLY_IF_CONNECTED = @as(c_long, 1251);
pub const InterlockedBitTestAndSet64Acquire = _interlockedbittestandset64;
pub const HSHELL_ENDTASK = 10;
pub const CT_CTYPE3 = 4;
pub const szOID_CMC_ENCRYPTED_POP = "1.3.6.1.5.5.7.7.9";
pub const InterlockedDecrementRelease = _InterlockedDecrement;
pub const ERROR_DS_ILLEGAL_SUPERIOR = @as(c_long, 8345);
pub const FAST_FAIL_LPAC_ACCESS_DENIED = 43;
pub const LOCALE_SABBREVMONTHNAME12 = 79;
pub const PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_ALWAYS_ON = if (@typeId(@typeOf(i64 << 48)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << 48) else if (@typeId(@typeOf(i64 << 48)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << 48) else @as(c_uint, 1)(i64 << 48);
pub const CAL_SCALNAME = 2;
pub const CERT_SIMPLE_NAME_STR = 1;
pub const SHTDN_REASON_MINOR_UPGRADE = 3;
pub const MCI_STRING_OFFSET = 512;
pub const STORAGE_OFFLOAD_WRITE_RANGE_TRUNCATED = 1;
pub const VK_OEM_AX = 225;
pub const VK_DIVIDE = 111;
pub const PRODUCT_SERVERRDSH = 175;
pub const DO_PRINTFILE = @as(c_long, 1414419024);
pub const ERROR_IPSEC_IKE_KERBEROS_ERROR = @as(c_long, 13827);
pub const TOKEN_ADJUST_GROUPS = 64;
pub const LF_FULLFACESIZE = 64;
pub const ERROR_IPSEC_IKE_INVALID_HASH_SIZE = @as(c_long, 13872);
pub const ERROR_CLUSTER_FAULT_DOMAIN_INVALID_HIERARCHY = @as(c_long, 5995);
pub const RC_GDI20_STATE = 32;
pub const LANG_UIGHUR = 128;
pub const STATE_SYSTEM_BUSY = 2048;
pub const USER_MARSHAL_FC_SHORT = 6;
pub const MDMSPKR_CALLSETUP = 3;
pub const FAST_FAIL_UNEXPECTED_HOST_BEHAVIOR = 58;
pub const SECURITY_CAPABILITY_ENTERPRISE_AUTHENTICATION = @as(c_long, 8);
pub const _CRT_INTERNAL_NONSTDC_NAMES = 1;
pub const FILE_PROVIDER_CURRENT_VERSION = 1;
pub const EVENT_OBJECT_DRAGLEAVE = 32805;
pub const TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX = 128;
pub const FACILITY_INPUT = 64;
pub const SC_SIZE = 61440;
pub const MM_MAX_AXES_NAMELEN = 16;
pub const XTYPF_NODATA = 4;
pub const DNS_ERROR_RECORD_ALREADY_EXISTS = @as(c_long, 9711);
pub const SECURITY_CAPABILITY_RID_COUNT = @as(c_long, 5);
pub const COMMON_LVB_TRAILING_BYTE = 512;
pub const ERROR_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED = @as(c_long, 4553);
pub const PF_MMX_INSTRUCTIONS_AVAILABLE = 3;
pub const ERROR_DS_NONEXISTENT_POSS_SUP = @as(c_long, 8390);
pub const CAL_NOUSEROVERRIDE = LOCALE_NOUSEROVERRIDE;
pub const XST_ADVSENT = 11;
pub const XST_UNADVACKRCVD = 14;
pub const PP_SIG_KEYSIZE_INC = 34;
pub const MDMSPKRFLAG_CALLSETUP = 8;
pub const ERROR_DS_CANT_MOD_SYSTEM_ONLY = @as(c_long, 8369);
pub const PSINJECT_ORIENTATION = 8;
pub const FILE_DEVICE_WPD = 64;
pub const COLOR_GRAYTEXT = 17;
pub const SWP_NOREDRAW = 8;
pub const ERROR_TRUSTED_DOMAIN_FAILURE = @as(c_long, 1788);
pub const ERROR_CLUSTER_RESNAME_NOT_FOUND = @as(c_long, 5080);
pub const CERT_TRUST_PUB_CHECK_TIMESTAMP_REV_FLAG = 512;
pub const FILL_NV_MEMORY_FLAG_NO_DRAIN = 256;
pub const CERT_ALT_NAME_ENTRY_ERR_INDEX_SHIFT = 16;
pub const TAPE_DRIVE_SETMARKS = 2148532224;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_BASE_RECORD = 8;
pub const ERROR_INVALID_COMPUTERNAME = @as(c_long, 1210);
pub const NON_PAGED_DEBUG_SIGNATURE = 18766;
pub const WH_KEYBOARD = 2;
pub const ERROR_INSTALL_ALREADY_RUNNING = @as(c_long, 1618);
pub const FILE_PROVIDER_COMPRESSION_XPRESS16K = 3;
pub const IMAGE_FILE_MACHINE_THUMB = 450;
pub const QDI_DIBTOSCREEN = 4;
pub const ERROR_MRM_NAMED_RESOURCE_NOT_FOUND = @as(c_long, 15127);
pub const LCS_GM_IMAGES = @as(c_long, 4);
pub const WNNC_NET_SECUREAGENT = 4653056;
pub const DMPAPER_JENV_CHOU3 = 73;
pub const URL_OID_CROSS_CERT_SUBJECT_INFO_ACCESS = if (@typeId(@typeOf(12)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 12) else if (@typeId(@typeOf(12)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 12) else LPCSTR(12);
pub const ERROR_HOOK_TYPE_NOT_ALLOWED = @as(c_long, 1458);
pub const FR_MATCHCASE = 4;
pub const DNS_ERROR_POLICY_SCOPE_MISSING = @as(c_long, 9986);
pub const WRITE_NV_MEMORY_FLAG_NON_TEMPORAL = 2;
pub const ALG_SID_RC4 = 1;
pub const ERROR_DS_WRONG_OM_OBJ_CLASS = @as(c_long, 8476);
pub const LB_ADDSTRING = 384;
pub const MAILSLOT_WAIT_FOREVER = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, -1) else DWORD(-1);
pub const WSA_QOS_NO_SENDERS = @as(c_long, 11007);
pub const ERROR_INSTALL_PACKAGE_VERSION = @as(c_long, 1613);
pub const PROCESS_POWER_THROTTLING_VALID_FLAGS = PROCESS_POWER_THROTTLING_EXECUTION_SPEED;
pub const TPM_LAYOUTRTL = @as(c_long, 32768);
pub const EIO = 5;
pub const PKCS12_EXPORT_ECC_CURVE_OID = 8192;
pub const WM_ENTERMENULOOP = 529;
pub const _RPC_HTTP_TRANSPORT_CREDENTIALS = _RPC_HTTP_TRANSPORT_CREDENTIALS_A;
pub const KP_SCHANNEL_ALG = 20;
pub const TAPE_DRIVE_ECC = 65536;
pub const RPCFLG_HAS_GUARANTEE = @as(c_ulong, 16);
pub const KP_PERMISSIONS = 6;
pub const ODT_LISTBOX = 2;
pub const SORT_CHINESE_UNICODE = 1;
pub const ERROR_CTX_WINSTATION_ALREADY_EXISTS = @as(c_long, 7023);
pub const BCRYPT_ECDH_PUBLIC_GENERIC_MAGIC = 1347109701;
pub const CERT_STORE_SHARE_STORE_FLAG = 64;
pub const PostThreadMessage = PostThreadMessageA;
pub const InsertMenuItem = InsertMenuItemA;
pub const MEM_IMAGE = 16777216;
pub const ICM_QUERYPROFILE = 3;
pub const VS_FF_PRERELEASE = @as(c_long, 2);
pub const SDC_TOPOLOGY_SUPPLIED = 16;
pub const CDERR_INITIALIZATION = 2;
pub const OLEOBJ_E_FIRST = @as(c_long, 2147746176);
pub const ERROR_INVALID_PRINTER_STATE = @as(c_long, 1906);
pub const szOID_WINDOWS_KITS_SIGNER = "1.3.6.1.4.1.311.10.3.20";
pub const CERT_RDN_IA5_STRING = 7;
pub const APPCOMMAND_FORWARD_MAIL = 40;
pub const IMAGE_REL_ARM64_SECREL = 8;
pub const szOID_RSA_ENCRYPT = "1.2.840.113549.3";
pub const PERF_COUNTER_HISTOGRAM = 393216;
pub const ERROR_CACHE_PAGE_LOCKED = @as(c_long, 752);
pub const WHDR_PREPARED = 2;
pub const ERROR_LOG_PINNED_RESERVATION = @as(c_long, 6648);
pub const ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD = @as(c_long, 8491);
pub const IO_REPARSE_TAG_SYMLINK = @as(c_long, 2684354572);
pub const IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION = 32768;
pub const READ_COMPRESSION_INFO_VALID = 32;
pub const SERVICE_ACCEPT_TRIGGEREVENT = 1024;
pub const RpcNsEntryExpandName = RpcNsEntryExpandNameA;
pub const VK_NAVIGATION_MENU = 137;
pub const PD_NONETWORKBUTTON = 2097152;
pub const szOID_SUBJECT_INFO_ACCESS = "1.3.6.1.5.5.7.1.11";
pub const ERROR_DEPENDENCY_ALREADY_EXISTS = @as(c_long, 5003);
pub const APPCOMMAND_VOLUME_UP = 10;
pub const PRINTER_NOTIFY_FIELD_DRIVER_NAME = 4;
pub const SUBLANG_ARABIC_IRAQ = 2;
pub const CERT_STORE_PROV_COLLECTION = if (@typeId(@typeOf(11)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 11) else if (@typeId(@typeOf(11)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 11) else LPCSTR(11);
pub const ERROR_CS_ENCRYPTION_FILE_NOT_CSE = @as(c_long, 6021);
pub const CERT_STORE_PROV_FIND_CERT_FUNC = 14;
pub const PRPC_BINDING_HANDLE_TEMPLATE_V1 = PRPC_BINDING_HANDLE_TEMPLATE_V1_A;
pub const WINSTA_READATTRIBUTES = @as(c_long, 2);
pub const UI_CAP_ROT90 = 2;
pub const IO_REPARSE_TAG_APPEXECLINK = @as(c_long, 2147483675);
pub const InterlockedExchangeAdd = _InterlockedExchangeAdd;
pub const SE_SACL_AUTO_INHERITED = 2048;
pub const ZAWPROXYAPI = DECLSPEC_IMPORT;
pub const LOCALE_SLONGDATE = 32;
pub const BCRYPT_KEY_DERIVATION_OPERATION = 64;
pub const SetComputerName = SetComputerNameA;
pub const AddFontResource = AddFontResourceA;
pub const EPROTO = 134;
pub const CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION = CMSG_ENVELOPED_DATA_V0;
pub const NEWFORMATDLGWITHLINK = 1591;
pub const WSADESCRIPTION_LEN = 256;
pub const SUBLANG_SWAHILI_KENYA = 1;
pub const ERROR_CTX_WD_NOT_FOUND = @as(c_long, 7004);
pub const SPI_GETDEFAULTINPUTLANG = 89;
pub const FACILITY_WINDOWS_STORE = 63;
pub const CB_INITSTORAGE = 353;
pub const ERROR_CTX_CDM_DISCONNECT = @as(c_long, 7067);
pub const NCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE;
pub const IMAGE_REL_BASED_IA64_IMM64 = 9;
pub const ERROR_DS_TREE_DELETE_NOT_FINISHED = @as(c_long, 8397);
pub const SECURITY_AUTHENTICATION_FRESH_KEY_AUTH_RID = @as(c_long, 3);
pub const PARITY_ODD = if (@typeId(@typeOf(512)) == @import("builtin").TypeId.Pointer) @ptrCast(WORD, 512) else if (@typeId(@typeOf(512)) == @import("builtin").TypeId.Int) @intToPtr(WORD, 512) else WORD(512);
pub const InterlockedXor64NoFence = _InterlockedXor64;
pub const ERROR_NO_MORE_USER_HANDLES = @as(c_long, 1158);
pub const DRAGDROP_E_LAST = @as(c_long, 2147746063);
pub const IMAGE_FILE_MACHINE_M32R = 36929;
pub const WOW64_CONTEXT_EXCEPTION_ACTIVE = 134217728;
pub const LANG_ORIYA = 72;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS = 52;
pub const SERVICE_CONTROL_SYSTEMLOWRESOURCES = 97;
pub const _Requires_shared_lock_held_ = lock;
pub const __FLT_MAX_EXP__ = 128;
pub const NONZEROLHND = LMEM_MOVEABLE;
pub const BIDI_ACCESS_USER = 2;
pub const BCRYPT_KEY_DATA_BLOB_MAGIC = 1296188491;
pub const JOB_STATUS_OFFLINE = 32;
pub const szOID_RSA_RSA = "1.2.840.113549.1.1.1";
pub const DMPAPER_JENV_CHOU4_ROTATED = 87;
pub const SPI_SETSOUNDSENTRY = 65;
pub const RemoveDirectoryTransacted = RemoveDirectoryTransactedA;
pub const JOB_NOTIFY_FIELD_PAGES_PRINTED = 21;
pub const SECURITY_MANDATORY_UNTRUSTED_RID = @as(c_long, 0);
pub const LANG_BELARUSIAN = 35;
pub const IMAGE_REL_BASED_MIPS_JMPADDR16 = 9;
pub const METHOD_NEITHER = 3;
pub const IMAGE_REL_IA64_TOKEN = 27;
pub const DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS = @as(c_long, 556);
pub const ERROR_DS_INIT_FAILURE_CONSOLE = @as(c_long, 8561);
pub const FLI_MASK = 4155;
pub const ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED = @as(c_long, 8426);
pub const WM_MDICREATE = 544;
pub const SYMMETRICWRAPKEYBLOB = 11;
pub const WAVECAPS_SYNC = 16;
pub const RPC_S_INTERNAL_ERROR = @as(c_long, 1766);
pub const PP_SMARTCARD_READER = 43;
pub const SetFirmwareEnvironmentVariable = SetFirmwareEnvironmentVariableA;
pub const ERROR_IPSEC_IKE_NEGOTIATION_DISABLED = @as(c_long, 13883);
pub const SM_CMOUSEBUTTONS = 43;
pub const ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY = @as(c_long, 8548);
pub const DefWindowProc = DefWindowProcA;
pub const DOMAIN_USER_RID_GUEST = @as(c_long, 501);
pub const RPC_CALL_STATUS_DISCONNECTED = 2;
pub const __CHAR_BIT__ = 8;
pub const ALG_SID_MD4 = 2;
pub const RPC_C_BINDING_MAX_TIMEOUT = 9;
pub const URLACTION_DOTNET_USERCONTROLS = 8197;
pub const ERROR_NO_SUCH_ALIAS = @as(c_long, 1376);
pub const PRODUCT_ENTERPRISE_N_EVALUATION = 84;
pub const PRINTER_STATUS_IO_ACTIVE = 256;
pub const PROV_REPLACE_OWF = 23;
pub const OBJ_METADC = 4;
pub const HTGROWBOX = 4;
pub const TXFS_RM_FLAG_ENFORCE_MINIMUM_SIZE = 4096;
pub const ALG_SID_RC5 = 13;
pub const RegCopyTree = RegCopyTreeA;
pub const RPC_CALL_STATUS_CANCELLED = 1;
pub const MIXER_GETLINEINFOF_QUERYMASK = @as(c_long, 15);
pub const szOID_PIN_RULES_EXT = "1.3.6.1.4.1.311.10.3.33";
pub const PP_UNIQUE_CONTAINER = 36;
pub const IO_REPARSE_TAG_CLOUD = @as(c_long, 2415919130);
pub const LOCALE_IDIGITS = 17;
pub const MMIO_INSTALLPROC = 65536;
pub const MIXERCONTROL_CT_CLASS_LIST = @as(c_long, 1879048192);
pub const MH_CLEANUP = 4;
pub const PROCESS_CREATION_MITIGATION_POLICY2_STRICT_CONTROL_FLOW_GUARD_DEFER = if (@typeId(@typeOf(i64 << 8)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), i64 << 8) else if (@typeId(@typeOf(i64 << 8)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), i64 << 8) else @as(c_uint, 0)(i64 << 8);
pub const FAILED_ACCESS_ACE_FLAG = 128;
pub const ERROR_IPSEC_WRONG_SA = @as(c_long, 13912);
pub const NLS_VALID_LOCALE_MASK = 1048575;
pub const LCMAP_UPPERCASE = 512;
pub const ERROR_SHARING_VIOLATION = @as(c_long, 32);
pub const WAVERR_BASE = 32;
pub const CERT_KEY_REPAIR_ATTEMPTED_PROP_ID = 103;
pub const CpuIdEx = __cpuidex;
pub const ERROR_INVALID_SERVER_STATE = @as(c_long, 1352);
pub const __inner_this_out_validated = typ_raw;
pub const SO_DEBUG = 1;
pub const FILE_INITIATE_REPAIR_HINT1_SID_VALID = 2097152;
pub const BAUD_56K = if (@typeId(@typeOf(32768)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 32768) else if (@typeId(@typeOf(32768)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 32768) else DWORD(32768);
pub const SERVICE_ACCEPT_TIMECHANGE = 512;
pub const CTRY_INDONESIA = 62;
pub const TAPE_DRIVE_LOAD_UNLOAD = 2147483649;
pub const DESKTOP_READOBJECTS = @as(c_long, 1);
pub const CRM_PROTOCOL_EXPLICIT_MARSHAL_ONLY = 1;
pub const __SSE2__ = 1;
pub const CAL_RETURN_NUMBER = LOCALE_RETURN_NUMBER;
pub const WNNC_NET_10NET = 327680;
pub const JOY_CAL_READUONLY = @as(c_long, 67108864);
pub const FACILITY_DEPLOYMENT_SERVICES_UTIL = 260;
pub const IMAGE_FILE_MACHINE_ARM = 448;
pub const LOCALE_TRANSIENT_KEYBOARD2 = 9216;
pub const PF_ARM_V81_ATOMIC_INSTRUCTIONS_AVAILABLE = 34;
pub const BCRYPT_PRIVATE_KEY_FLAG = 2;
pub const MB_ICONHAND = @as(c_long, 16);
pub const FILE_CASE_PRESERVED_NAMES = 2;
pub const RESOURCEDISPLAYTYPE_NDSCONTAINER = 11;
pub const TRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTERED = 1;
pub const SC_MONITORPOWER = 61808;
pub const MKF_CONFIRMHOTKEY = 8;
pub const PDERR_CREATEICFAILURE = 4106;
pub const RIM_TYPEKEYBOARD = 1;
pub const CERT_CHAIN_OPT_IN_WEAK_SIGNATURE = 65536;
pub const SS_ENHMETAFILE = @as(c_long, 15);
pub const CRYPT_LITTLE_ENDIAN = 1;
pub const FILE_DEVICE_NETWORK_REDIRECTOR = 40;
pub const SERVICE_NOTIFY_DELETED = 256;
pub const szOID_OIWDIR_md2 = "1.3.14.7.2.2.1";
pub const X509_DSS_PUBLICKEY = X509_MULTI_BYTE_UINT;
pub const FACILITY_WINDOWSUPDATE = 36;
pub const FoldString = FoldStringA;
pub const USER_MARSHAL_FC_CHAR = 2;
pub const ERROR_DS_CANT_REM_MISSING_ATT_VAL = @as(c_long, 8325);
pub const chx11 = 1050;
pub const LOCALE_NOUSEROVERRIDE = 2147483648;
pub const ERROR_PRIVATE_DIALOG_INDEX = @as(c_long, 1415);
pub const CRYPT_STRING_BASE64HEADER = 0;
pub const MK_SHIFT = 4;
pub const MIXERCONTROL_CT_SC_TIME_MICROSECS = @as(c_long, 0);
pub const szOID_ENCRYPTED_KEY_HASH = "1.3.6.1.4.1.311.21.21";
pub const MUI_FILETYPE_NOT_LANGUAGE_NEUTRAL = 1;
pub const MEM_REPLACE_PLACEHOLDER = 16384;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_KE = @as(c_long, 13833);
pub const CMSG_CTRL_DECRYPT = 2;
pub const PRINTER_NOTIFY_FIELD_CJOBS = 20;
pub const OCSP_RESPONSE = if (@typeId(@typeOf(67)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 67) else if (@typeId(@typeOf(67)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 67) else LPCSTR(67);
pub const SDC_FORCE_MODE_ENUMERATION = 4096;
pub const WM_SETICON = 128;
pub const NUMPRS_EXPONENT = 2048;
pub const SO_RCVBUF = 4098;
pub const HELPMSGSTRINGA = "commdlg_help";
pub const ERROR_EVT_FILTER_NOTELTSET = @as(c_long, 15015);
pub const MCI_ANIM_PLAY_FAST = @as(c_long, 262144);
pub const __corei7 = 1;
pub const FRAME_FPO = 0;
pub const RPC_S_INVALID_TIMEOUT = @as(c_long, 1709);
pub const WS_EX_RIGHTSCROLLBAR = @as(c_long, 0);
pub const DWL_MSGRESULT = 0;
pub const PRINTER_CHANGE_PRINTER_DRIVER = 1879048192;
pub const NCRYPT_KEY_STORAGE_INTERFACE = 65537;
pub const SPI_GETMOUSEVANISH = 4128;
pub const VK_NAVIGATION_VIEW = 136;
pub const CryptGetDefaultProvider = CryptGetDefaultProviderA;
pub const __file_parser_library = typ;
pub const InterlockedIncrementRelease = _InterlockedIncrement;
pub const PRINTER_NOTIFY_TYPE = 0;
pub const PS_ENDCAP_MASK = 3840;
pub const ERROR_DS_ATT_VAL_ALREADY_EXISTS = @as(c_long, 8323);
pub const CTRY_LEBANON = 961;
pub const NLS_ALPHANUMERIC = 0;
pub const NTDDI_WS08SP4 = NTDDI_WIN6SP4;
pub const DRIVE_NO_ROOT_DIR = 1;
pub const NCRYPT_MD5_ALGORITHM = BCRYPT_MD5_ALGORITHM;
pub const URLACTION_CHANNEL_SOFTDIST_MAX = 7935;
pub const EVENT_CONSOLE_UPDATE_SCROLL = 16388;
pub const IMAGE_REL_ARM64_REL21 = 5;
pub const CFSTR_MIME_WEBVTT = if (@typeId(@typeOf("text/vtt")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "text/vtt") else if (@typeId(@typeOf("text/vtt")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "text/vtt") else TEXT("text/vtt");
pub const ERROR_INVALID_DRIVE = @as(c_long, 15);
pub const FACILITY_DRVSERVICING = 136;
pub const CERT_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = 93;
pub const IMAGE_REL_AMD64_INDIR_CALL = 25;
pub const SPI_GETGRADIENTCAPTIONS = 4104;
pub const ALG_SID_MD5 = 3;
pub const SSL_OBJECT_LOCATOR_CERT_VALIDATION_CONFIG_FUNC = "SslObjectLocatorInitializeCertValidationConfig";
pub const VK_LCONTROL = 162;
pub const UNW_FLAG_UHANDLER = 2;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_FQDN = @as(c_long, 9994);
pub const MIDL_WINRT_TYPE_SERIALIZATION_INFO_CURRENT_VERSION = MidlWinrtTypeSerializationInfoVersionOne;
pub const PRODUCT_DATACENTER_SERVER_V = 37;
pub const ERROR_LOG_HARD_ERROR = @as(c_long, 718);
pub const SMTO_ABORTIFHUNG = 2;
pub const WSAEREFUSED = @as(c_long, 10112);
pub const ERROR_INVALID_WORKSTATION = @as(c_long, 1329);
pub const PRINTER_CHANGE_PRINTER = 255;
pub const URLACTION_CHANNEL_SOFTDIST_PERMISSIONS = 7685;
pub const MOUSEWHEEL_ROUTING_MOUSE_POS = 2;
pub const FF_ROMAN = 1 << 4;
pub const EVENT_SYSTEM_MOVESIZEEND = 11;
pub const GetJob = GetJobA;
pub const szOID_PRIVATEKEY_USAGE_PERIOD = "2.5.29.16";
pub const PSP_USETITLE = 8;
pub const GCPCLASS_POSTBOUNDLTR = 32;
pub const ERROR_RM_ALREADY_STARTED = @as(c_long, 6822);
pub const PSINJECT_ENDSETUP = 17;
pub const GET_FEATURE_FROM_THREAD_RESTRICTED = 128;
pub const SUBLANG_ARABIC_YEMEN = 9;
pub const FLS_MAXIMUM_AVAILABLE = 4080;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC = 8;
pub const APPMODEL_ERROR_PACKAGE_NOT_AVAILABLE = @as(c_long, 15706);
pub const BCRYPT_PROV_DISPATCH = 1;
pub const EMR_ELLIPSE = 42;
pub const FILE_CLEAR_ENCRYPTION = 2;
pub const SECURITY_LOGON_IDS_RID = @as(c_long, 5);
pub const ERROR_REQUEST_OUT_OF_SEQUENCE = @as(c_long, 776);
pub const ERROR_FS_DRIVER_REQUIRED = @as(c_long, 588);
pub const RegisterClass = RegisterClassA;
pub const MUTANT_QUERY_STATE = 1;
pub const META_OFFSETCLIPRGN = 544;
pub const MS_DEF_RSA_SCHANNEL_PROV_A = "Microsoft RSA SChannel Cryptographic Provider";
pub const SUBLANG_MACEDONIAN_MACEDONIA = 1;
pub const szOID_BIOMETRIC_EXT = "1.3.6.1.5.5.7.1.2";
pub const CERT_SELECT_BY_POLICY_OID = 3;
pub const HEBREW_CHARSET = 177;
pub const SBM_GETRANGE = 227;
pub const InterlockedExchangeAdd64 = _InterlockedExchangeAdd64;
pub const EnumSystemLocales = EnumSystemLocalesA;
pub const DCE_C_ERROR_STRING_LEN = 256;
pub const FF_SCRIPT = 4 << 4;
pub const SPI_GETPENDRAGOUTTHRESHOLD = 134;
pub const CHANGER_CLEANER_SLOT = 64;
pub const SIZEZOOMHIDE = SIZE_MAXHIDE;
pub const FR_NOUPDOWN = 1024;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_MACHINE = @as(c_long, 15650);
pub const IMAGE_ARCHIVE_END = "`\n";
pub const rpc_binding_handle_t = RPC_BINDING_HANDLE;
pub const HBMMENU_MBAR_MINIMIZE = if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Pointer) @ptrCast(HBITMAP, 3) else if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Int) @intToPtr(HBITMAP, 3) else HBITMAP(3);
pub const PARTITION_XENIX_1 = 2;
pub const SPI_SETACCESSTIMEOUT = 61;
pub const CERT_SUBJECT_NAME_MD5_HASH_PROP_ID = 29;
pub const SERVICE_START_REASON_DEMAND = 1;
pub const ABORTDOC = 2;
pub const HELP_WM_HELP = 12;
pub const SECURITY_CREATOR_OWNER_RID = @as(c_long, 0);
pub const PKCS12_ONLY_CERTIFICATES_PROVIDER_TYPE = 0;
pub const EMARCH_ENC_I17_IMM7B_SIZE_X = 7;
pub const LOCALE_TRANSIENT_KEYBOARD3 = 10240;
pub const TIME_VALID_OID_FLUSH_CRL_FROM_CERT = if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 3) else if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 3) else LPCSTR(3);
pub const PRINTER_STATUS_NO_TONER = 262144;
pub const SB_LINELEFT = 0;
pub const SCARD_READER_TYPE_TPM = 128;
pub const MSG_DONTROUTE = 4;
pub const SUBLANG_ARMENIAN_ARMENIA = 1;
pub const SECURITY_NETWORK_RID = @as(c_long, 2);
pub const DTR_CONTROL_ENABLE = 1;
pub const ODT_BUTTON = 4;
pub const ELEMENT_STATUS_PRODUCT_DATA = 64;
pub const IDHOT_SNAPWINDOW = -1;
pub const DNS_ERROR_DNSSEC_BASE = 9100;
pub const TARGET_IS_NT61_OR_LATER = 1;
pub const PKCS5_PADDING = 1;
pub const PRINTER_ATTRIBUTE_WORK_OFFLINE = 1024;
pub const PC_WINDPOLYGON = 4;
pub const WM_SETTINGCHANGE = WM_WININICHANGE;
pub const LCMAP_HALFWIDTH = 4194304;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC = 61;
pub const ERROR_DS_DUP_MAPI_ID = @as(c_long, 8380);
pub const RPC_S_UNSUPPORTED_NAME_SYNTAX = @as(c_long, 1737);
pub const PAN_STROKE_GRADUAL_DIAG = 2;
pub const CERT_CHAIN_POLICY_IGNORE_CA_REV_UNKNOWN_FLAG = 1024;
pub const ERROR_SEVERITY_WARNING = 2147483648;
pub const SC_CONTEXTHELP = 61824;
pub const ERROR_SEVERITY_SUCCESS = 0;
pub const AW_ACTIVATE = 131072;
pub const chx10 = 1049;
pub const PRINTER_CHANGE_SET_PRINTER = 2;
pub const FACILITY_WIA = 33;
pub const SEE_MASK_HOTKEY = 32;
pub const AF_IPX = 6;
pub const CHANGER_IEPORT_USER_CONTROL_OPEN = 2147483776;
pub const RPCFLG_HAS_MULTI_SYNTAXES = @as(c_ulong, 33554432);
pub const TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_VIRTUAL_CLOCK = 2;
pub const WriteLongPtrNoFence = WriteNoFence64;
pub const MSGFLT_RESET = 0;
pub const CompareString = CompareStringA;
pub const DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS = @as(c_long, 560);
pub const CERT_SERIAL_CHAIN_PROP_ID = 119;
pub const __file_parser_class = typ;
pub const NCRYPTBUFFER_PROTECTION_FLAGS = 4;
pub const NCRYPT_ECC_CURVE_NAME_LIST_PROPERTY = BCRYPT_ECC_CURVE_NAME_LIST;
pub const BCRYPT_ECDH_P256_ALG_HANDLE = if (@typeId(@typeOf(673)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 673) else if (@typeId(@typeOf(673)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 673) else BCRYPT_ALG_HANDLE(673);
pub const RAND_MAX = 32767;
pub const Uri_CREATE_DECODE_EXTRA_INFO = 64;
pub const EnumDisplaySettingsEx = EnumDisplaySettingsExA;
pub const TAPE_DRIVE_SELECT = 2;
pub const RemoveFontResourceEx = RemoveFontResourceExA;
pub const EMR_POLYPOLYLINE = 7;
pub const GESTURECONFIGMAXCOUNT = 256;
pub const OPENCARDNAMEW_EX = OPENCARDNAME_EXW;
pub const LCMAP_SORTHANDLE = 536870912;
pub const PRODUCT_CORE_CONNECTED = 111;
pub const DEVICEFAMILYDEVICEFORM_HOME_AUTOMATION = 18;
pub const CRM_PROTOCOL_DYNAMIC_MARSHAL_INFO = 2;
pub const CharNext = CharNextA;
pub const GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS = 4;
pub const PPCAPS_RIGHT_THEN_DOWN = 1;
pub const ERROR_ALREADY_WIN32 = @as(c_long, 719);
pub const FACILITY_JSCRIPT = 2306;
pub const CONTEXT_OID_OCSP_RESP = if (@typeId(@typeOf(6)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 6) else if (@typeId(@typeOf(6)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 6) else LPCSTR(6);
pub const TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS = 32;
pub const OFN_NOLONGNAMES = 262144;
pub const CONTEXT_OID_PKCS7 = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 4) else LPCSTR(4);
pub const PIDDSI_HIDDENCOUNT = 9;
pub const SE_ACCESS_CHECK_VALID_FLAGS = 8;
pub const PRPC_HTTP_TRANSPORT_CREDENTIALS_V3 = PRPC_HTTP_TRANSPORT_CREDENTIALS_V3_A;
pub const EM_GETMARGINS = 212;
pub const CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG = 2;
pub const IMAGE_REL_PPC_BRNTAKEN = 1024;
pub const ERROR_SHUTDOWN_IS_SCHEDULED = @as(c_long, 1190);
pub const X509_OBJECT_IDENTIFIER = if (@typeId(@typeOf(73)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 73) else if (@typeId(@typeOf(73)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 73) else LPCSTR(73);
pub const __RDRND__ = 1;
pub const TRANSACTION_NOTIFY_MARSHAL = 131072;
pub const DCBA_FACEUPRIGHT = 3;
pub const SEE_MASK_NOZONECHECKS = 8388608;
pub const PEERDIST_ERROR_INVALIDATED = @as(c_long, 4057);
pub const ERROR_DS_AUDIT_FAILURE = @as(c_long, 8625);
pub const DMPAPER_A5_TRANSVERSE = 61;
pub const CRYPT_DONT_CACHE_RESULT = 8;
pub const COPYFILE2_MESSAGE_COPY_OFFLOAD = @as(c_long, 1);
pub const ALG_SID_MD2 = 1;
pub const CF_NOFACESEL = @as(c_long, 524288);
pub const ERROR_IPSEC_IKE_ENCRYPT = @as(c_long, 13866);
pub const GDICOMMENT_UNICODE_STRING = 64;
pub const FRS_ERR_AUTHENTICATION = @as(c_long, 8008);
pub const STORAGE_RPMB_MINIMUM_RELIABLE_WRITE_SIZE = 512;
pub const ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY = @as(c_long, 7005);
pub const ERROR_IPSEC_IKE_LOAD_FAILED = @as(c_long, 13876);
pub const PRODUCT_ANDROMEDA = 184;
pub const WS_EX_MDICHILD = @as(c_long, 64);
pub const IMAGE_REL_BASED_HIGHADJ = 4;
pub const IMAGE_REL_IA64_PCREL60M = 25;
pub const CreateFileMappingNuma = CreateFileMappingNumaA;
pub const CFSEPCHAR = 43;
pub const DFCS_BUTTONRADIO = 4;
pub const AF_HYLINK = 15;
pub const szOID_DESTINATION_INDICATOR = "2.5.4.27";
pub const TAPE_RESET_STATISTICS = @as(c_long, 2);
pub const FILE_SHARE_WRITE = 2;
pub const LWA_ALPHA = 2;
pub const ERROR_API_UNAVAILABLE = @as(c_long, 15841);
pub const IME_ESC_PRIVATE_FIRST = 2048;
pub const UNPROTECTED_SACL_SECURITY_INFORMATION = @as(c_long, 268435456);
pub const HIBERFILE_TYPE_NONE = 0;
pub const FADF_DISPATCH = 1024;
pub const IPPORT_TFTP = 69;
pub const SPI_GETMOUSECLICKLOCKTIME = 8200;
pub const RPC_C_VERS_COMPATIBLE = 2;
pub const NUMPRS_LEADING_PLUS = 4;
pub const PROFILE_SERVER = 1073741824;
pub const WMSZ_BOTTOMRIGHT = 8;
pub const S_SERDDR = -14;
pub const SSL_F12_ERROR_TEXT_LENGTH = 256;
pub const CRYPTNET_URL_CACHE_RESPONSE_NONE = 0;
pub const CDS_GLOBAL = 8;
pub const MIXERCONTROL_CT_SUBCLASS_MASK = @as(c_long, 251658240);
pub const EMBDHLP_INPROC_SERVER = @as(c_long, 1);
pub const FOF_ALLOWUNDO = 64;
pub const EM_SETMARGINS = 211;
pub const BM_SETCHECK = 241;
pub const PROCESS_CREATION_MITIGATION_POLICY2_SPECULATIVE_STORE_BYPASS_DISABLE_MASK = if (@typeId(@typeOf(i64 << 24)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 24) else if (@typeId(@typeOf(i64 << 24)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 24) else @as(c_uint, 3)(i64 << 24);
pub const WT_EXECUTEONLYONCE = 8;
pub const RegisterClassEx = RegisterClassExA;
pub const OpenPrinter = OpenPrinterA;
pub const ACCESS_MIN_MS_ACE_TYPE = 0;
pub const LOCALE_SMONTHOUSANDSEP = 23;
pub const SPI_SETSERIALKEYS = 63;
pub const CERT_TRUST_HAS_NOT_SUPPORTED_CRITICAL_EXT = 134217728;
pub const CERT_KEY_CERT_SIGN_KEY_USAGE = 4;
pub const CERT_ISSUER_CHAIN_PUB_KEY_CNG_ALG_BIT_LENGTH_PROP_ID = 96;
pub const KP_ROUNDS = 35;
pub const SECURITY_LOCAL_ACCOUNT_RID = @as(c_long, 113);
pub const HTBOTTOMLEFT = 16;
pub const ERROR_SYSTEM_INTEGRITY_SUPPLEMENTAL_POLICY_NOT_AUTHORIZED = @as(c_long, 4555);
pub const WS_EX_LAYOUTRTL = @as(c_long, 4194304);
pub const CERT_CHAIN_POLICY_IGNORE_ROOT_REV_UNKNOWN_FLAG = 2048;
pub const COMPRESSION_FORMAT_XPRESS_HUFF = 4;
pub const STDOLE_MINORVERNUM = 0;
pub const PID_MAX_READONLY = 3221225471;
pub const PDC_ARRIVAL = 1;
pub const BSF_SENDNOTIFYMESSAGE = 256;
pub const SERVICE_CONFIG_TRIGGER_INFO = 8;
pub const DefineDosDevice = DefineDosDeviceA;
pub const PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_ON = 1 << 20;
pub const HP_TLS1PRF_LABEL = 6;
pub const CS_VREDRAW = 1;
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT = 1024;
pub const RPCFLG_MESSAGE = @as(c_ulong, 16777216);
pub const lst4 = 1123;
pub const __MIDL_CONST = @"const";
pub const CTRY_CZECH = 420;
pub const __UINT64_FMTx__ = "llx";
pub const SPI_GETACCESSTIMEOUT = 60;
pub const STATE_SYSTEM_FOCUSED = 4;
pub const CTRY_AZERBAIJAN = 994;
pub const szOID_KP_TPM_PLATFORM_CERTIFICATE = "2.23.133.8.2";
pub const CERT_STRONG_SIGN_SERIALIZED_INFO_CHOICE = 1;
pub const TRANSACTION_ENLIST = 4;
pub const RPC_S_OUT_OF_THREADS = ERROR_MAX_THRDS_REACHED;
pub const EMR_CLOSEFIGURE = 61;
pub const RPC_QUERY_NO_AUTH_REQUIRED = 64;
pub const DNS_ERROR_NON_RFC_NAME = @as(c_long, 9556);
pub const __UINTPTR_WIDTH__ = 64;
pub const MOUSE_VIRTUAL_DESKTOP = 2;
pub const CERT_TRUST_HAS_AUTO_UPDATE_WEAK_SIGNATURE = 32768;
pub const chx13 = 1052;
pub const ERROR_TRANSACTION_NOT_ROOT = @as(c_long, 6721);
pub const CRYPTPROTECT_VERIFY_PROTECTION = 64;
pub const HELPINFO_WINDOW = 1;
pub const SP_APPABORT = -2;
pub const RPC_X_INVALID_BOUND = RPC_S_INVALID_BOUND;
pub const CRYPT_PREGEN = 64;
pub const MNS_MODELESS = 1073741824;
pub const ERROR_CANTWRITE = @as(c_long, 1013);
pub const OPAQUE = 2;
pub const WM_TIMECHANGE = 30;
pub const PRINTER_STATUS_PAPER_PROBLEM = 64;
pub const __AES__ = 1;
pub const FIND_FIRST_EX_LARGE_FETCH = 2;
pub const ERROR_NETNAME_DELETED = @as(c_long, 64);
pub const EVENTLOG_START_PAIRED_EVENT = 1;
pub const STGFMT_DOCUMENT = 0;
pub const MIXER_OBJECTF_HANDLE = @as(c_long, 2147483648);
pub const QS_MOUSEBUTTON = 4;
pub const X3_IMM20_INST_WORD_X = 3;
pub const midl_user_free = MIDL_user_free;
pub const ERROR_HASH_NOT_PRESENT = @as(c_long, 15301);
pub const INPUT_KEYBOARD = 1;
pub const ERROR_DRIVER_FAILED_PRIOR_UNLOAD = @as(c_long, 654);
pub const CERT_SYSTEM_STORE_LOCATION_MASK = 16711680;
pub const COMPRESSION_FORMAT_XPRESS = 3;
pub const ERROR_DECRYPTION_FAILED = @as(c_long, 6001);
pub const ERROR_INVALID_SERVICENAME = @as(c_long, 1213);
pub const LOCALE_SNATIVEDISPLAYNAME = 115;
pub const CMSG_ENCODE_SORTED_CTL_FLAG = 1;
pub const JOB_NOTIFY_FIELD_PRINT_PROCESSOR = 6;
pub const SET_PURGE_FAILURE_MODE_DISABLED = 2;
pub const WOW64_SIZE_OF_80387_REGISTERS = 80;
pub const STREAM_CONTAINS_PROPERTIES = 4;
pub const FILE_ATTRIBUTE_STRICTLY_SEQUENTIAL = 536870912;
pub const RPC_QUERY_CALL_LOCAL_ADDRESS = 8;
pub const CFSTR_MIME_GIF = if (@typeId(@typeOf("image/gif")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "image/gif") else if (@typeId(@typeOf("image/gif")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "image/gif") else TEXT("image/gif");
pub const PRPC_HTTP_TRANSPORT_CREDENTIALS_V2 = PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_A;
pub const CF_NOSCRIPTSEL = @as(c_long, 8388608);
pub const SIMULATED_FONTTYPE = 32768;
pub const STORAGE_TIER_NAME_LENGTH = 256;
pub const CM_IN_GAMUT = 0;
pub const ERROR_WINDOW_OF_OTHER_THREAD = @as(c_long, 1408);
pub const FILE_DEVICE_SOUND = 29;
pub const CRYPT_KEYID_ALLOC_FLAG = 32768;
pub const X3_IMM20_SIGN_VAL_POS_X = 0;
pub const RPC_C_PROFILE_MATCH_BY_MBR = 3;
pub const COPY_FILE_RESTARTABLE = 2;
pub const FAST_FAIL_GUARD_ICALL_CHECK_SUPPRESSED = 31;
pub const IMAGE_FILE_RELOCS_STRIPPED = 1;
pub const PROTECTION_LEVEL_WINTCB_LIGHT = 0;
pub const LANG_SWAHILI = 65;
pub const DISCHARGE_POLICY_LOW = 1;
pub const SDC_SAVE_TO_DATABASE = 512;
pub const szOID_ARCHIVED_KEY_ATTR = "1.3.6.1.4.1.311.21.13";
pub const PBT_APMRESUMECRITICAL = 6;
pub const DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2 = if (@typeId(@typeOf(-4)) == @import("builtin").TypeId.Pointer) @ptrCast(DPI_AWARENESS_CONTEXT, -4) else if (@typeId(@typeOf(-4)) == @import("builtin").TypeId.Int) @intToPtr(DPI_AWARENESS_CONTEXT, -4) else DPI_AWARENESS_CONTEXT(-4);
pub const CMSG_HASHED_DATA_V2 = 2;
pub const PRINTER_NOTIFY_FIELD_SERVER_NAME = 0;
pub const ERROR_POSSIBLE_DEADLOCK = @as(c_long, 1131);
pub const szOID_WINDOWS_SOFTWARE_EXTENSION_SIGNER = "1.3.6.1.4.1.311.10.3.26";
pub const DBG_RIPEXCEPTION = if (@typeId(@typeOf(@as(c_long, 1073807367))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 1073807367)) else if (@typeId(@typeOf(@as(c_long, 1073807367))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 1073807367)) else DWORD(@as(c_long, 1073807367));
pub const HTTOPRIGHT = 14;
pub const CONNECT_RESERVED = 4278190080;
pub const NTM_TYPE1 = 1048576;
pub const szOID_CMC_ID_CONFIRM_CERT_ACCEPTANCE = "1.3.6.1.5.5.7.7.24";
pub const CERT_QUERY_CONTENT_SERIALIZED_CTL = 6;
pub const sz_CERT_STORE_PROV_LDAP_W = "Ldap";
pub const ERROR_INVALID_PARAMETER = @as(c_long, 87);
pub const GCPCLASS_LATINNUMERICTERMINATOR = 6;
pub const SUBLANG_ARABIC_KUWAIT = 13;
pub const CERT_QUERY_CONTENT_PFX = 12;
pub const CRYPT_STRING_HEX = 4;
pub const NCRYPT_PAD_CIPHER_FLAG = 16;
pub const TXFS_RM_FLAG_LOGGING_MODE = 1;
pub const META_SETWINDOWORG = 523;
pub const SZDDESYS_ITEM_STATUS = "Status";
pub const GGO_GRAY2_BITMAP = 4;
pub const PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_OFF = if (@typeId(@typeOf(i64 << 36)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 2), i64 << 36) else if (@typeId(@typeOf(i64 << 36)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 2), i64 << 36) else @as(c_uint, 2)(i64 << 36);
pub const LR_MONOCHROME = 1;
pub const RIM_INPUTSINK = 1;
pub const ES_CONTINUOUS = if (@typeId(@typeOf(2147483648)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 2147483648) else if (@typeId(@typeOf(2147483648)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 2147483648) else DWORD(2147483648);
pub const STATUS_USER_APC = if (@typeId(@typeOf(@as(c_long, 192))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 192)) else if (@typeId(@typeOf(@as(c_long, 192))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 192)) else DWORD(@as(c_long, 192));
pub const ERROR_CANT_CROSS_RM_BOUNDARY = @as(c_long, 6825);
pub const ERROR_DS_KEY_NOT_UNIQUE = @as(c_long, 8527);
pub const szOID_KP_KEY_RECOVERY_AGENT = "1.3.6.1.4.1.311.21.6";
pub const PERF_DISPLAY_PER_SEC = 268435456;
pub const ERROR_INVALID_MEDIA = @as(c_long, 4300);
pub const ERROR_IPSEC_IKE_SA_REAPED = @as(c_long, 13808);
pub const STATUS_DATATYPE_MISALIGNMENT = if (@typeId(@typeOf(@as(c_long, 2147483650))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 2147483650)) else if (@typeId(@typeOf(@as(c_long, 2147483650))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 2147483650)) else DWORD(@as(c_long, 2147483650));
pub const FILE_LIST_DIRECTORY = 1;
pub const CRYPT_READ = 8;
pub const SetPrinterData = SetPrinterDataA;
pub const EFS_COMPATIBILITY_VERSION_NCRYPT_PROTECTOR = 5;
pub const LOCALE_TRANSIENT_KEYBOARD1 = 8192;
pub const ERROR_FLOPPY_WRONG_CYLINDER = @as(c_long, 1123);
pub const SHOW_OPENWINDOW = 1;
pub const PROCESS_CREATION_CHILD_PROCESS_OVERRIDE = 2;
pub const TXFS_LOGGING_MODE_FULL = 2;
pub const KF_EXTENDED = 256;
pub const lst5 = 1124;
pub const ERROR_CURRENT_TRANSACTION_NOT_VALID = @as(c_long, 6714);
pub const MOD_ALT = 1;
pub const MUI_PARTIAL_LANGUAGE = 2;
pub const DMPAPER_A6_ROTATED = 83;
pub const PRINTER_STATUS_USER_INTERVENTION = 1048576;
pub const IN_CLASSC_HOST = 255;
pub const DDE_FBUSY = 16384;
pub const RPC_S_SERVER_OUT_OF_MEMORY = ERROR_NOT_ENOUGH_SERVER_MEMORY;
pub const GetPrinterData = GetPrinterDataA;
pub const MMIO_TOUPPER = 16;
pub const BCRYPT_ECDSA_PUBLIC_P256_MAGIC = 827540293;
pub const JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP = 4;
pub const ERROR_DC_NOT_FOUND = @as(c_long, 1425);
pub const NTM_NONNEGATIVE_AC = 65536;
pub const MEM_WRITE_WATCH = 2097152;
pub const SEF_MACL_NO_EXECUTE_UP = 1024;
pub const chx12 = 1051;
pub const ERROR_BAD_USERNAME = @as(c_long, 2202);
pub const ERROR_TOO_MANY_MUXWAITERS = @as(c_long, 152);
pub const SM_CYKANJIWINDOW = 18;
pub const XSTATE_MASK_LEGACY_SSE = if (@typeId(@typeOf(i64 << XSTATE_LEGACY_SSE)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << XSTATE_LEGACY_SSE) else if (@typeId(@typeOf(i64 << XSTATE_LEGACY_SSE)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << XSTATE_LEGACY_SSE) else @as(c_uint, 1)(i64 << XSTATE_LEGACY_SSE);
pub const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_CURRENT_VERSION = NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_V0;
pub const X509_BITS = if (@typeId(@typeOf(26)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 26) else if (@typeId(@typeOf(26)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 26) else LPCSTR(26);
pub const LC_POLYLINE = 2;
pub const FACILITY_AUDCLNT = 2185;
pub const VarUI4FromUint = VarUI4FromUI4;
pub const SKF_STICKYKEYSON = 1;
pub const IPPORT_EXECSERVER = 512;
pub const WM_CTLCOLORMSGBOX = 306;
pub const PKCS12_DISABLE_ENCRYPT_CERTIFICATES = 256;
pub const ERROR_ALREADY_REGISTERED = @as(c_long, 1242);
pub const WS_CLIPCHILDREN = @as(c_long, 33554432);
pub const VarUintFromUI1 = VarUI4FromUI1;
pub const szOID_X21_ADDRESS = "2.5.4.24";
pub const DOF_MULTIPLE = 32772;
pub const MAXLONG = 2147483647;
pub const __INT64_MAX__ = @as(c_longlong, 9223372036854775807);
pub const ERROR_PRI_MERGE_LOAD_FILE_FAILED = @as(c_long, 15150);
pub const VT_HARDTYPE = VT_RESERVED;
pub const SPI_GETICONTITLELOGFONT = 31;
pub const MCI_FREEZE = 2116;
pub const DMLERR_LAST = 16401;
pub const CRL_REASON_CESSATION_OF_OPERATION_FLAG = 4;
pub const CTRY_JAMAICA = 1;
pub const FR_NOWHOLEWORD = 4096;
pub const ERROR_IPSEC_MM_POLICY_EXISTS = @as(c_long, 13003);
pub const ERROR_INVALID_MESSAGENAME = @as(c_long, 1217);
pub const VK_LAUNCH_MAIL = 180;
pub const EVENT_CONSOLE_CARET = 16385;
pub const IMAGE_REL_I386_SECREL7 = 13;
pub const ERROR_CANTREAD = @as(c_long, 1012);
pub const IMAGE_COMDAT_SELECT_LARGEST = 6;
pub const IO_REPARSE_TAG_CLOUD_D = @as(c_long, 2415972378);
pub const MDM_PROTOCOLID_HDLCPPP = 1;
pub const ERROR_SERVICE_ALREADY_RUNNING = @as(c_long, 1056);
pub const WM_MDIRESTORE = 547;
pub const CERT_STORE_SET_LOCALIZED_NAME_FLAG = 2;
pub const PP_KEYSTORAGE = 17;
pub const GL_LEVEL_FATAL = 1;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INT64 = 1;
pub const GC_TWOFINGERTAP = 1;
pub const DTR_CONTROL_HANDSHAKE = 2;
pub const CRYPT_OID_USE_CURVE_PARAMETERS_FOR_ENCODE_FLAG = 268435456;
pub const __SIG_ATOMIC_WIDTH__ = 32;
pub const DNS_ERROR_BAD_PACKET = @as(c_long, 9502);
pub const CMSG_ENVELOPED_DATA_V0 = 0;
pub const TAPE_DRIVE_SPACE_IMMEDIATE = 2155872256;
pub const DMDUP_VERTICAL = 2;
pub const NTDDI_VERSION = WDK_NTDDI_VERSION;
pub const _Deref2_ret1_impl_ = p1;
pub const URLACTION_SHELL_REMOTEQUERY = 6158;
pub const ANSI_CHARSET = 0;
pub const MIIM_BITMAP = 128;
pub const NCRYPT_UNREGISTER_NOTIFY_FLAG = 2;
pub const RPC_QUERY_CLIENT_PRINCIPAL_NAME = 4;
pub const MONITORINFOF_PRIMARY = 1;
pub const FS_CHINESETRAD = @as(c_long, 1048576);
pub const LGRPID_INSTALLED = 1;
pub const CO_E_FIRST = @as(c_long, 2147746288);
pub const MIXERCONTROL_CT_UNITS_DECIBELS = @as(c_long, 262144);
pub const SCardConnect = SCardConnectA;
pub const FADF_STATIC = 2;
pub const DMPAPER_JENV_CHOU4 = 74;
pub const DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP = @as(c_long, 573);
pub const __DBL_MIN_EXP__ = -1021;
pub const ERROR_SXS_XML_E_UNBALANCEDPAREN = @as(c_long, 14040);
pub const DFCS_MONO = 32768;
pub const CTRY_SLOVAK = 421;
pub const CTRY_PARAGUAY = 595;
pub const TA_RTLREADING = 256;
pub const MF_SYSMENU = @as(c_long, 8192);
pub const GETTECHNOLGY = 20;
pub const GCP_DISPLAYZWG = @as(c_long, 4194304);
pub const APPIDREGFLAGS_RESERVED5 = 1024;
pub const PP_KEYEXCHANGE_ALG = 14;
pub const CRL_REASON_CA_COMPROMISE_FLAG = 32;
pub const FAST_FAIL_INVALID_BALANCED_TREE = 29;
pub const CMSG_RECIPIENT_INFO_PARAM = 19;
pub const PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_MASK = 3 << 12;
pub const SERVICE_STOP_REASON_MINOR_MAX_CUSTOM = 65535;
pub const DS_CONTROL = @as(c_long, 1024);
pub const CONTACTVISUALIZATION_OFF = 0;
pub const CERT_CHAIN_POLICY_IGNORE_NOT_TIME_NESTED_FLAG = 4;
pub const CTLCOLOR_LISTBOX = 2;
pub const WS_MAXIMIZEBOX = @as(c_long, 65536);
pub const BCRYPT_CIPHER_OPERATION = 1;
pub const WSAEMSGSIZE = @as(c_long, 10040);
pub const ERROR_CLUSTER_RESOURCE_IS_IN_MAINTENANCE_MODE = @as(c_long, 5970);
pub const DOMAIN_ALIAS_RID_ADMINS = @as(c_long, 544);
pub const ERROR_ACPI_ERROR = @as(c_long, 669);
pub const ERROR_SXS_DUPLICATE_TLBID = @as(c_long, 14025);
pub const ERROR_COM_TASK_STOP_PENDING = @as(c_long, 15501);
pub const WM_NCXBUTTONDOWN = 171;
pub const szOID_CMC_REVOKE_REQUEST = "1.3.6.1.5.5.7.7.17";
pub const PARTITION_XENIX_2 = 3;
pub const EM_LINEINDEX = 187;
pub const X3_D_WH_SIGN_VAL_POS_X = 0;
pub const PRINTER_ATTRIBUTE_FAX = 16384;
pub const APPCOMMAND_MEDIA_PLAY = 46;
pub const ERROR_WAKE_SYSTEM_DEBUGGER = @as(c_long, 675);
pub const ERROR_SINGLE_INSTANCE_APP = @as(c_long, 1152);
pub const URLOSTRM_GETNEWESTVERSION = 3;
pub const VK_MEDIA_PREV_TRACK = 177;
pub const VOS_WINCE = @as(c_long, 327680);
pub const VarDecFromInt = VarDecFromI4;
pub const TAPE_DRIVE_RELATIVE_BLKS = 2147614720;
pub const META_CREATEFONTINDIRECT = 763;
pub const CDS_RESET_EX = 536870912;
pub const ERROR_DS_NO_CHECKPOINT_WITH_PDC = @as(c_long, 8551);
pub const DNS_ERROR_LOAD_ZONESCOPE_FAILED = @as(c_long, 9956);
pub const MDMSPKRFLAG_ON = 4;
pub const WSAEAFNOSUPPORT = @as(c_long, 10047);
pub const EFS_METADATA_REPLACE_USER = 4;
pub const STORAGE_TEMPERATURE_THRESHOLD_FLAG_ADAPTER_REQUEST = 1;
pub const ERROR_CLUSTER_SHARED_VOLUME_REDIRECTED = @as(c_long, 5966);
pub const POSTSCRIPT_IGNORE = 38;
pub const CMSG_SIGNER_CERT_ID_PARAM = 38;
pub const szOID_ISSUER_ALT_NAME2 = "2.5.29.18";
pub const SPI_GETTHREADLOCALINPUTSETTINGS = 4174;
pub const WNetDisconnectDialog1 = WNetDisconnectDialog1A;
pub const SECURITY_CRED_TYPE_RID_COUNT = @as(c_long, 2);
pub const lst6 = 1125;
pub const szOID_HPKP_HEADER_VALUE_CTL = "1.3.6.1.4.1.311.10.3.61";
pub const FILE_DEVICE_PMI = 69;
pub const PDERR_RETDEFFAILURE = 4099;
pub const FS_WANSUNG = @as(c_long, 524288);
pub const MM_ISOTROPIC = 7;
pub const EVENT_OBJECT_INVOKED = 32787;
pub const VkKeyScanEx = VkKeyScanExA;
pub const DIALOPTION_DIALTONE = 256;
pub const IMAGE_REL_M32R_REFHI = 9;
pub const CRYPT_OID_REG_ENCODING_TYPE_PREFIX = "EncodingType ";
pub const MIXER_LONG_NAME_CHARS = 64;
pub const DRV_OK = DRVCNF_OK;
pub const PRODUCT_CORE_CONNECTED_N = 113;
pub const IMAGE_REL_MIPS_REFHI = 4;
pub const S_SERDSH = -11;
pub const szOID_CERT_MANIFOLD = "1.3.6.1.4.1.311.20.3";
pub const chx15 = 1054;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_SWITCHTABLE_BRANCH = 5;
pub const ERROR_MULTIPLE_FAULT_VIOLATION = @as(c_long, 640);
pub const FILE_DEVICE_MIDI_IN = 13;
pub const SERVICES_FAILED_DATABASEA = "ServicesFailed";
pub const SPI_GETSCREENSAVEACTIVE = 16;
pub const ERROR_DS_EXISTS_IN_MAY_HAVE = @as(c_long, 8386);
pub const TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MAX = 4;
pub const CTRY_UNITED_STATES = 1;
pub const PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_PREFER_SYSTEM32_DEFER = if (@typeId(@typeOf(i64 << 60)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), i64 << 60) else if (@typeId(@typeOf(i64 << 60)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), i64 << 60) else @as(c_uint, 0)(i64 << 60);
pub const GetFirmwareEnvironmentVariableEx = GetFirmwareEnvironmentVariableExA;
pub const SUBLANG_PUNJABI_INDIA = 1;
pub const ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED = @as(c_long, 13860);
pub const RegQueryInfoKey = RegQueryInfoKeyA;
pub const TAPE_SPACE_END_OF_DATA = @as(c_long, 4);
pub const VarUintFromUI2 = VarUI4FromUI2;
pub const DMBIN_LAST = DMBIN_FORMSOURCE;
pub const CreateDC = CreateDCA;
pub const IMAGE_REL_SH3_DIRECT16 = 1;
pub const TIMESTAMP_INFO = if (@typeId(@typeOf(80)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 80) else if (@typeId(@typeOf(80)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 80) else LPCSTR(80);
pub const CERT_INFO_ISSUER_UNIQUE_ID_FLAG = 9;
pub const CMSG_ALL_FLAGS = ~@as(c_ulong, 0);
pub const FD_OOB = 4;
pub const REG_OPENED_EXISTING_KEY = @as(c_long, 2);
pub const PRINTER_CHANGE_DELETE_FORM = 262144;
pub const REG_LINK = @as(c_ulong, 6);
pub const MWT_RIGHTMULTIPLY = 3;
pub const IMAGE_RESOURCE_NAME_IS_STRING = 2147483648;
pub const SYSTEM_ALARM_ACE_TYPE = 3;
pub const WriteConsole = WriteConsoleA;
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES = 3;
pub const ERROR_REMOTE_STORAGE_MEDIA_ERROR = @as(c_long, 4352);
pub const RPI_SMB2_FLAG_SERVERCAP_PERSISTENT_HANDLES = 16;
pub const LANG_LITHUANIAN = 39;
pub const XSTATE_GSSE = 2;
pub const POINTER_FLAG_HWHEEL = 1048576;
pub const IO_REPARSE_TAG_CLOUD_E = @as(c_long, 2415976474);
pub const REG_OPTION_NON_VOLATILE = @as(c_long, 0);
pub const SERVICE_ERROR_IGNORE = 0;
pub const POINTER_FLAG_UPDATE = 131072;
pub const PAN_MIDLINE_LOW_SERIFED = 13;
pub const EMR_SETICMPROFILEW = 113;
pub const SEC_FILE = 8388608;
pub const DEFAULT_PITCH = 0;
pub const PROCESSOR_ARM_7TDMI = 70001;
pub const PAGE_WRITECOPY = 8;
pub const GRADIENT_FILL_RECT_H = 0;
pub const MCI_FORMAT_FRAMES = 3;
pub const SM_CXDOUBLECLK = 36;
pub const MCI_SEQ_STATUS_MASTER = @as(c_long, 16392);
pub const STORAGE_TIER_FLAG_READ_CACHE = 4194304;
pub const INPLACE_S_LAST = @as(c_long, 262575);
pub const LANG_GEORGIAN = 55;
pub const LOAD_TLB_AS_32BIT = 32;
pub const MOUSEEVENTF_MIDDLEUP = 64;
pub const DT_RASCAMERA = 3;
pub const DC_FILEDEPENDENCIES = 14;
pub const NTDDI_WINXP = 83951616;
pub const szOID_PKIX_CA_REPOSITORY = "1.3.6.1.5.5.7.48.5";
pub const CALG_OID_INFO_CNG_ONLY = 4294967295;
pub const CMSG_HASHED_DATA_V0 = 0;
pub const MDM_PROTOCOLID_ANALOG = 7;
pub const STARTF_PREVENTPINNING = 8192;
pub const LPD_SHARE_ACCUM = 256;
pub const BCRYPT_ECDH_P384_ALG_HANDLE = if (@typeId(@typeOf(689)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 689) else if (@typeId(@typeOf(689)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 689) else BCRYPT_ALG_HANDLE(689);
pub const CERT_ISSUER_SERIAL_NUMBER_MD5_HASH_PROP_ID = 28;
pub const FORMAT_MESSAGE_ALLOCATE_BUFFER = 256;
pub const SM_RESERVED2 = 25;
pub const ALG_SID_RC2 = 2;
pub const ERROR_PIPE_NOT_CONNECTED = @as(c_long, 233);
pub const FRS_ERR_PARENT_INSUFFICIENT_PRIV = @as(c_long, 8009);
pub const STREAM_EXTENT_ENTRY_ALL_EXTENTS = 2;
pub const ERROR_VALIDATE_CONTINUE = @as(c_long, 625);
pub const META_CREATEREGION = 1791;
pub const EMR_SAVEDC = 33;
pub const ERROR_PROFILING_AT_LIMIT = @as(c_long, 553);
pub const NCRYPT_DH_PARAMETERS_PROPERTY = BCRYPT_DH_PARAMETERS;
pub const NCRYPT_RSA_SIGN_ALGORITHM = BCRYPT_RSA_SIGN_ALGORITHM;
pub const ERROR_REMOTE_SESSION_LIMIT_EXCEEDED = @as(c_long, 1220);
pub const CERT_INFO_SUBJECT_FLAG = 7;
pub const SUBLANG_TIBETAN_PRC = 1;
pub const APPIDREGFLAGS_RESERVED4 = 512;
pub const CTRY_MALAYSIA = 60;
pub const ERROR_CANTFETCHBACKWARDS = @as(c_long, 770);
pub const NCRYPT_OVERWRITE_KEY_FLAG = 128;
pub const ERROR_FATAL_APP_EXIT = @as(c_long, 713);
pub const IO_REPARSE_TAG_MOUNT_POINT = @as(c_long, 2684354563);
pub const GGL_STRING = 3;
pub const FONTDLGORD = 1542;
pub const RDW_INVALIDATE = 1;
pub const ERROR_INVALID_SCROLLBAR_RANGE = @as(c_long, 1448);
pub const RPC_S_NOT_LISTENING = @as(c_long, 1715);
pub const LGRPID_VIETNAMESE = 14;
pub const SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA = 1;
pub const ERROR_COMPRESSION_NOT_BENEFICIAL = @as(c_long, 344);
pub const CERT_CHAIN_DISABLE_MD2_MD4 = 4096;
pub const CreateWaitableTimer = CreateWaitableTimerA;
pub const CONNECT_WRITE_THROUGH_SEMANTICS = 65536;
pub const __SIZEOF_LONG_DOUBLE__ = 8;
pub const GetVolumeInformation = GetVolumeInformationA;
pub const LoadLibraryEx = LoadLibraryExA;
pub const POWERBUTTON_ACTION_VALUE_SHUTDOWN = 6;
pub const CRYPT_OID_ENUM_PHYSICAL_STORE_FUNC = "CertDllEnumPhysicalStore";
pub const ERROR_NOT_FOUND = @as(c_long, 1168);
pub const LPOINETPRIORITY = LPIINTERNETPRIORITY;
pub const CERT_ACCESS_STATE_SYSTEM_STORE_FLAG = 2;
pub const SPI_SETLOWPOWERACTIVE = 85;
pub const STORAGE_PROTOCOL_STATUS_ERROR = 2;
pub const IN_CLASSB_HOST = 65535;
pub const PP_VERSION = 5;
pub const ERROR_KM_DRIVER_BLOCKED = @as(c_long, 1930);
pub const WARNING_IPSEC_QM_POLICY_PRUNED = @as(c_long, 13025);
pub const LZERROR_GLOBALLOC = -5;
pub const MAXCHAR = 127;
pub const ERROR_CTX_LOGON_DISABLED = @as(c_long, 7037);
pub const CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG = 1;
pub const __UINT64_FMTu__ = "llu";
pub const LBS_USETABSTOPS = @as(c_long, 128);
pub const CERT_RDN_DISABLE_CHECK_TYPE_FLAG = 1073741824;
pub const lst7 = 1126;
pub const ERROR_NO_SUCH_PRIVILEGE = @as(c_long, 1313);
pub const NCRYPT_SHA512_ALGORITHM = BCRYPT_SHA512_ALGORITHM;
pub const SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_BASE_RID = @as(c_long, 85);
pub const CorePrinterDriverInstalled = CorePrinterDriverInstalledA;
pub const WRITE_NV_MEMORY_FLAG_FLUSH = 1;
pub const PIPE_UNLIMITED_INSTANCES = 255;
pub const CFSTR_MIME_HTA = if (@typeId(@typeOf("application/hta")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "application/hta") else if (@typeId(@typeOf("application/hta")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "application/hta") else TEXT("application/hta");
pub const FLOODFILLSURFACE = 1;
pub const RPC_C_AUTHN_LEVEL_DEFAULT = 0;
pub const SECURITY_PROXY_RID = @as(c_long, 8);
pub const ERROR_DBG_EXCEPTION_HANDLED = @as(c_long, 766);
pub const chx14 = 1053;
pub const CB_INSERTSTRING = 330;
pub const ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION = @as(c_long, 783);
pub const PROCESS_SET_SESSIONID = 4;
pub const EMR_BEGINPATH = 59;
pub const LOCALE_SSORTNAME = 4115;
pub const UOI_TYPE = 3;
pub const SUBLANG_URDU_INDIA = 2;
pub const SIZEZOOMSHOW = SIZE_MAXSHOW;
pub const _Deref2_pre1_impl_ = p1;
pub const SERVICE_STOP_REASON_MINOR_MMC = 22;
pub const JOY_CAL_READVONLY = @as(c_long, 134217728);
pub const LBN_ERRSPACE = -2;
pub const HSHELL_REDRAW = 6;
pub const MCI_PAUSE = 2057;
pub const TA_CENTER = 6;
pub const szOID_CMC_TRANSACTION_ID = "1.3.6.1.5.5.7.7.5";
pub const ERROR_CALLBACK_INVOKE_INLINE = @as(c_long, 812);
pub const HSHELL_GETMINRECT = 5;
pub const szOID_OIWSEC_sha1 = "1.3.14.3.2.26";
pub const ERROR_CTX_PD_NOT_FOUND = @as(c_long, 7003);
pub const PRINTER_CHANGE_CONFIGURE_PORT = 2097152;
pub const ERROR_CONNECTION_ABORTED = @as(c_long, 1236);
pub const GID_ZOOM = 3;
pub const PAN_SERIF_THIN = 7;
pub const mciGetDeviceIDFromElementID = mciGetDeviceIDFromElementIDA;
pub const CERT_TRUST_HAS_EXCLUDED_NAME_CONSTRAINT = 32768;
pub const COLOR_ACTIVEBORDER = 10;
pub const SMART_READ_LOG = 213;
pub const CLIP_LH_ANGLES = 1 << 4;
pub const EC_RIGHTMARGIN = 2;
pub const META_SETPALENTRIES = 55;
pub const WM_PALETTEISCHANGING = 784;
pub const HEAP_GENERATE_EXCEPTIONS = 4;
pub const SM_CYBORDER = 6;
pub const VK_OEM_102 = 226;
pub const SUBLANG_MALAY_BRUNEI_DARUSSALAM = 2;
pub const IO_REPARSE_TAG_CLOUD_F = @as(c_long, 2415980570);
pub const FACILITY_WINDOWS_SETUP = 48;
pub const ERROR_MCA_INTERNAL_ERROR = @as(c_long, 15205);
pub const MDM_MASK_V120_SPEED = 7;
pub const EMR_SETCOLORSPACE = 100;
pub const ERROR_NO_NVRAM_RESOURCES = @as(c_long, 1470);
pub const KDF_SUPPPRIVINFO = 12;
pub const CMSG_ENVELOPED_DATA_V2 = 2;
pub const ICM_DELETEPROFILE = 2;
pub const PIDSI_KEYWORDS = @as(c_long, 5);
pub const MSGFLT_REMOVE = 2;
pub const FACILITY_SCRIPT = 112;
pub const ERROR_DS_STRING_SD_CONVERSION_FAILED = @as(c_long, 8522);
pub const FILE_DEVICE_FIPS = 58;
pub const DNS_ERROR_POLICY_INVALID_SETTINGS = @as(c_long, 9974);
pub const SO_OOBINLINE = 256;
pub const WB_ISDELIMITER = 2;
pub const SetPrinterDataEx = SetPrinterDataExA;
pub const CTL_FIND_SUBJECT = 4;
pub const IMPLTYPEFLAG_FRESTRICTED = 4;
pub const CLAIM_SECURITY_ATTRIBUTE_MANDATORY = 32;
pub const ASPECTXY = 44;
pub const VS_FFI_FILEFLAGSMASK = @as(c_long, 63);
pub const IMAGE_REL_IA64_PCREL60I = 24;
pub const GDICOMMENT_BEGINGROUP = 2;
pub const FACILITY_WIN32 = 7;
pub const SM_REMOTECONTROL = 8193;
pub const InterlockedAddNoFence = _InlineInterlockedAdd;
pub const FILE_SHARE_DELETE = 4;
pub const SM_RESERVED3 = 26;
pub const BCRYPT_HMAC_SHA512_ALG_HANDLE = if (@typeId(@typeOf(209)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 209) else if (@typeId(@typeOf(209)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 209) else BCRYPT_ALG_HANDLE(209);
pub const CERT_CHAIN_ENABLE_SHARE_STORE = 32;
pub const GENERIC_EXECUTE = @as(c_long, 536870912);
pub const GCL_CONVERSION = 1;
pub const DCX_PARENTCLIP = @as(c_long, 32);
pub const WM_CLEAR = 771;
pub const SIZE_MAXSHOW = 3;
pub const APPIDREGFLAGS_RESERVED7 = 4096;
pub const URLACTION_HTML_META_REFRESH = 5640;
pub const ALERT_SYSTEM_CRITICAL = 5;
pub const OLEIVERB_PRIMARY = @as(c_long, 0);
pub const LB_DIR = 397;
pub const ERROR_RESOURCE_DISABLED = @as(c_long, 4309);
pub const ERROR_INDOUBT_TRANSACTIONS_EXIST = @as(c_long, 6827);
pub const LR_COPYFROMRESOURCE = 16384;
pub const MIDIPROP_SET = @as(c_long, 2147483648);
pub const SPI_GETDRAGFULLWINDOWS = 38;
pub const CA_LOG_FILTER = 2;
pub const SHTDN_REASON_MINOR_HOTFIX = 17;
pub const FACILITY_DEPLOYMENT_SERVICES_SERVER = 257;
pub const IMAGE_REL_BASED_ARM_MOV32 = 5;
pub const ERROR_DS_MODIFYDN_WRONG_GRANDPARENT = @as(c_long, 8582);
pub const CAL_SENGLISHERANAME = 59;
pub const PRINTER_NOTIFY_FIELD_SHARE_NAME = 2;
pub const CERT_SET_PROPERTY_INHIBIT_PERSIST_FLAG = 1073741824;
pub const QueryServiceConfig2 = QueryServiceConfig2A;
pub const ERROR_UNIDENTIFIED_ERROR = @as(c_long, 1287);
pub const IMAGE_SCN_ALIGN_MASK = 15728640;
pub const SPI_GETMOUSEHOVERWIDTH = 98;
pub const EM_SETMODIFY = 185;
pub const ERROR_BIDI_NOT_SUPPORTED = ERROR_NOT_SUPPORTED;
pub const MB_YESNOCANCEL = @as(c_long, 3);
pub const ERROR_DS_CANT_MOD_PRIMARYGROUPID = @as(c_long, 8506);
pub const ERROR_PROC_NOT_FOUND = @as(c_long, 127);
pub const LPCPROPSHEETHEADER = LPCPROPSHEETHEADERA;
pub const BSM_INSTALLABLEDRIVERS = 4;
pub const BCRYPT_KEY_DERIVATION_INTERFACE = 7;
pub const IMAGE_REL_IA64_ADDEND = 31;
pub const THREAD_GET_CONTEXT = 8;
pub const FILE_ACTION_MODIFIED = 3;
pub const TXFS_RM_STATE_NOT_STARTED = 0;
pub const ECONNABORTED = 106;
pub const JOB_OBJECT_SECURITY_NO_ADMIN = 1;
pub const LOCALE_TRANSIENT_KEYBOARD4 = 11264;
pub const EM_SETRECT = 179;
pub const szOID_ECDSA_SHA256 = "1.2.840.10045.4.3.2";
pub const VarBoolFromInt = VarBoolFromI4;
pub const ERROR_DS_RANGE_CONSTRAINT = @as(c_long, 8322);
pub const STGM_SHARE_DENY_WRITE = @as(c_long, 32);
pub const ERROR_DS_CANT_FIND_EXPECTED_NC = @as(c_long, 8420);
pub const AC_SRC_ALPHA = 1;
pub const RotateRight16 = _rotr16;
pub const CERT_CROSS_CERT_DIST_POINTS_PROP_ID = 23;
pub const NI_IMEMENUSELECTED = 24;
pub const DRV_QUERYCONFIGURE = 8;
pub const SUBLANG_ENGLISH_SINGAPORE = 18;
pub const PSWIZB_CANCEL = 16;
pub const ERROR_COUNTER_TIMEOUT = @as(c_long, 1121);
pub const CERT_DATE_STAMP_PROP_ID = 27;
pub const ENLISTMENT_RECOVER = 4;
pub const IMAGE_DEBUG_TYPE_CLSID = 11;
pub const CERT_RDN_DISABLE_IE4_UTF8_FLAG = 16777216;
pub const DEVICE_DSM_FLAG_REPAIR_INPUT_TOPOLOGY_ID_PRESENT = 1073741824;
pub const InterlockedAndRelease = _InterlockedAnd;
pub const META_REALIZEPALETTE = 53;
pub const DMLERR_NO_ERROR = 0;
pub const DOMAIN_ALIAS_RID_DEVICE_OWNERS = @as(c_long, 583);
pub const InterlockedExchange64 = _InterlockedExchange64;
pub const ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE = @as(c_long, 8502);
pub const CERT_CHAIN_ENABLE_ALL_EKU_HYGIENE_FLAG = 131072;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_BUSY = @as(c_long, 371);
pub const ERROR_CLUSTER_NODE_PAUSED = @as(c_long, 5070);
pub const USAGE_MATCH_TYPE_OR = 1;
pub const VarUintFromUI4 = VarUI4FromUI4;
pub const ERROR_OFFSET_ALIGNMENT_VIOLATION = @as(c_long, 327);
pub const STORAGE_PROTOCOL_STATUS_DATA_OVERRUN = 6;
pub const CBR_19200 = 19200;
pub const CRYPT_MODE_OFBP = 8;
pub const CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG = 1;
pub const CERT_TRUST_IS_COMPLEX_CHAIN = 65536;
pub const szOID_KP_KERNEL_MODE_HAL_EXTENSION_SIGNING = "1.3.6.1.4.1.311.61.5.1";
pub const HS_VERTICAL = 1;
pub const FILE_PROVIDER_COMPRESSION_XPRESS8K = 2;
pub const ERROR_NULL_LM_PASSWORD = @as(c_long, 1304);
pub const PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_DEFER = 0 << 12;
pub const InterlockedCompareExchange64 = _InterlockedCompareExchange64;
pub const LOCALE_WINDOWS = 1;
pub const PERSISTENT_VOLUME_STATE_GLOBAL_METADATA_NO_SEEK_PENALTY = 4;
pub const SM_CYICON = 12;
pub const DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP = @as(c_long, 574);
pub const ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG = @as(c_long, 13873);
pub const PAN_LETT_OBLIQUE_OFF_CENTER = 14;
pub const IMAGE_FILE_EXECUTABLE_IMAGE = 2;
pub const PROCESSOR_IDLESTATE_POLICY_COUNT = 3;
pub const TPM_BOTTOMALIGN = @as(c_long, 32);
pub const PENARBITRATIONTYPE_SPT = 3;
pub const SESSION_MODIFY_ACCESS = 2;
pub const ERROR_DS_GC_NOT_AVAILABLE = @as(c_long, 8217);
pub const ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED = @as(c_long, 1934);
pub const ERROR_INVALID_SEGMENT_NUMBER = @as(c_long, 180);
pub const X3_I_SIGN_VAL_POS_X = 59;
pub const ERROR_ACCOUNT_RESTRICTION = @as(c_long, 1327);
pub const GRADIENT_FILL_RECT_V = 1;
pub const EVENTLOG_INFORMATION_TYPE = 4;
pub const BCRYPT_DES_ECB_ALG_HANDLE = if (@typeId(@typeOf(513)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 513) else if (@typeId(@typeOf(513)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 513) else BCRYPT_ALG_HANDLE(513);
pub const PRF_ERASEBKGND = @as(c_long, 8);
pub const PARTITION_DM = 84;
pub const SW_SMOOTHSCROLL = 16;
pub const __UINT8_FMTo__ = "hho";
pub const EM_CHARFROMPOS = 215;
pub const SBS_SIZEBOX = @as(c_long, 8);
pub const __UINT_FAST8_FMTu__ = "hhu";
pub const RPC_S_DUPLICATE_ENDPOINT = @as(c_long, 1740);
pub const OPENCHANNEL = 4110;
pub const ERROR_IPSEC_IKE_SHUTTING_DOWN = @as(c_long, 13891);
pub const X509_BASIC_CONSTRAINTS = if (@typeId(@typeOf(13)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 13) else if (@typeId(@typeOf(13)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 13) else LPCSTR(13);
pub const DRV_CONFIGURE = 7;
pub const PAGESETUPDLGORD = 1546;
pub const LANG_THAI = 30;
pub const ERROR_STACK_BUFFER_OVERRUN = @as(c_long, 1282);
pub const CONTACTVISUALIZATION_PRESENTATIONMODE = 2;
pub const szOID_KP_PRIVACY_CA = "1.3.6.1.4.1.311.21.36";
pub const MOUSE_MOVE_RELATIVE = 0;
pub const ERROR_TRANSACTION_NOT_ACTIVE = @as(c_long, 6701);
pub const PRINTER_NOTIFY_FIELD_SECURITY_DESCRIPTOR = 12;
pub const ERROR_CLUSTER_GROUP_MOVING = @as(c_long, 5908);
pub const MMIO_FINDCHUNK = 16;
pub const MSG_MAXIOVLEN = 16;
pub const RTS_CONTROL_ENABLE = 1;
pub const DOMAIN_USER_RID_KRBTGT = @as(c_long, 502);
pub const DNS_ERROR_SERVERSCOPE_IS_REFERENCED = @as(c_long, 9988);
pub const ESB_DISABLE_UP = 1;
pub const IMAGE_REL_SHM_REFLO = 20;
pub const EVENT_OBJECT_CONTENTSCROLLED = 32789;
pub const DFCS_MENUARROWRIGHT = 4;
pub const RPC_S_NO_CONTEXT_AVAILABLE = @as(c_long, 1765);
pub const URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY = 4612;
pub const RPC_S_UNKNOWN_AUTHN_TYPE = @as(c_long, 1741);
pub const MultinetGetConnectionPerformance = MultinetGetConnectionPerformanceA;
pub const CERT_ENCIPHER_ONLY_KEY_USAGE = 1;
pub const CTRY_PAKISTAN = 92;
pub const ERROR_INSTRUCTION_MISALIGNMENT = @as(c_long, 549);
pub const RPC_C_AUTHN_LIVE_SSP = 32;
pub const STORAGE_PROTOCOL_STATUS_PENDING = 0;
pub const _IRQL_requires_min_ = irql;
pub const RPC_S_NO_ENDPOINT_FOUND = @as(c_long, 1708);
pub const EMR_GRADIENTFILL = 118;
pub const MDM_HDLCPPP_AUTH_CHAP = 3;
pub const GC_ALLGESTURES = 1;
pub const TRANSACTION_NOTIFY_PREPREPARE = 1;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_AUTHOR_ID = 2;
pub const NRC_OSRESNOTAV = 53;
pub const WM_CHARTOITEM = 47;
pub const EMARCH_ENC_I17_IMM5C_VAL_POS_X = 16;
pub const EMARCH_ENC_I17_IMM9D_VAL_POS_X = 7;
pub const PA_ACTIVATE = MA_ACTIVATE;
pub const ERROR_SXS_XML_E_BADNAMECHAR = @as(c_long, 14033);
pub const _SAL_nop_impl_ = X;
pub const FACILITY_FWP = 50;
pub const DESKTOPVERTRES = 117;
pub const DefMDIChildProc = DefMDIChildProcA;
pub const IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT = 13;
pub const CURSOR_SHOWING = 1;
pub const EVENPARITY = 2;
pub const lst1 = 1120;
pub const CRYPT_OBJECT_LOCATOR_FIRST_RESERVED_USER_NAME_TYPE = 33;
pub const DCBA_FACEDOWNLEFT = 258;
pub const ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST = @as(c_long, 5082);
pub const SSWF_NONE = 0;
pub const IMAGE_REL_PPC_SECTION = 12;
pub const ERROR_NOT_SUPPORTED_ON_DAX = @as(c_long, 360);
pub const WNNC_NET_IBMAL = 3407872;
pub const IMAGE_REL_MIPS_REFWORD = 2;
pub const ERROR_CROSS_PARTITION_VIOLATION = @as(c_long, 1661);
pub const chx16 = 1055;
pub const EWX_RESTARTAPPS = 64;
pub const WS_EX_RTLREADING = @as(c_long, 8192);
pub const SET_SPREAD = 4106;
pub const PPM_FIRMWARE_LPI = 524288;
pub const ASYNC_MODE_COMPATIBILITY = @as(c_long, 1);
pub const _IRQL_requires_ = irql;
pub const DCTT_BITMAP = @as(c_long, 1);
pub const BCRYPT_3DES_112_CBC_ALG_HANDLE = if (@typeId(@typeOf(369)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 369) else if (@typeId(@typeOf(369)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 369) else BCRYPT_ALG_HANDLE(369);
pub const NCRYPT_CIPHER_OPERATION = BCRYPT_CIPHER_OPERATION;
pub const CERT_FIND_ENHKEY_USAGE = CERT_COMPARE_ENHKEY_USAGE << CERT_COMPARE_SHIFT;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY = @as(c_long, 15640);
pub const SERVICE_STOP_REASON_FLAG_MIN = 0;
pub const RpcBindingSetAuthInfo = RpcBindingSetAuthInfoA;
pub const FILE_INITIATE_REPAIR_HINT1_SID_MISMATCH = 4194304;
pub const RPC_S_FP_DIV_ZERO = @as(c_long, 1769);
pub const TOUCH_FEEDBACK_DEFAULT = 1;
pub const ERROR_GROUPSET_NOT_FOUND = @as(c_long, 5992);
pub const EM_GETWORDBREAKPROC = 209;
pub const MAXUINT32 = if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT32, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT32, 0) else UINT32(0))) == @import("builtin").TypeId.Pointer) @ptrCast(UINT32, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT32, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT32, 0) else UINT32(0)) else if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT32, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT32, 0) else UINT32(0))) == @import("builtin").TypeId.Int) @intToPtr(UINT32, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT32, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT32, 0) else UINT32(0)) else UINT32(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT32, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT32, 0) else UINT32(0));
pub const ERROR_LOG_RECORD_NONEXISTENT = @as(c_long, 6624);
pub const MEVT_SHORTMSG = if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(BYTE, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(BYTE, 0) else BYTE(0);
pub const ERROR_LOST_WRITEBEHIND_DATA = @as(c_long, 596);
pub const __INT16_FMTd__ = "hd";
pub const ERROR_UNRECOGNIZED_VOLUME = @as(c_long, 1005);
pub const CAL_SSHORTDATE = 5;
pub const CRYPT_SEC_DESCR = 1;
pub const CERT_SELECT_ALLOW_EXPIRED = 1;
pub const SetUserObjectInformation = SetUserObjectInformationA;
pub const DOMAIN_GROUP_RID_ADMINS = @as(c_long, 512);
pub const ERROR_DS_CODE_INCONSISTENCY = @as(c_long, 8408);
pub const ERROR_DBG_EXCEPTION_NOT_HANDLED = @as(c_long, 688);
pub const FAPPCOMMAND_KEY = 0;
pub const RPC_S_INVALID_ASYNC_HANDLE = @as(c_long, 1914);
pub const ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED = @as(c_long, 14015);
pub const CERT_BIOMETRIC_PICTURE_TYPE = 0;
pub const LOCALE_SMONTHNAME11 = 66;
pub const HTTOPLEFT = 13;
pub const CERT_CHAIN_POLICY_THIRD_PARTY_ROOT = if (@typeId(@typeOf(11)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 11) else if (@typeId(@typeOf(11)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 11) else LPCSTR(11);
pub const FILE_FLAG_OPEN_REQUIRING_OPLOCK = 262144;
pub const ERROR_MRM_DIRECT_REF_TO_NON_DEFAULT_RESOURCE = @as(c_long, 15146);
pub const ERROR_IPSEC_IKE_TIMED_OUT = @as(c_long, 13805);
pub const DBG_COMMAND_EXCEPTION = if (@typeId(@typeOf(@as(c_long, 1073807369))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 1073807369)) else if (@typeId(@typeOf(@as(c_long, 1073807369))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 1073807369)) else DWORD(@as(c_long, 1073807369));
pub const MS_DSR_ON = if (@typeId(@typeOf(32)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 32) else if (@typeId(@typeOf(32)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 32) else DWORD(32);
pub const LAYOUT_BTT = 2;
pub const PSP_USEHEADERSUBTITLE = 8192;
pub const SetWindowText = SetWindowTextA;
pub const GDI_ERROR = @as(c_long, 4294967295);
pub const IMAGE_REL_M32R_GPREL16 = 4;
pub const TAPE_DRIVE_SET_ECC = 2147483904;
pub const CBS_DISABLENOSCROLL = @as(c_long, 2048);
pub const __requires_shared_lock_held = lock;
pub const DOMAIN_GROUP_RID_AUTHORIZATION_DATA_IS_COMPOUNDED = @as(c_long, 496);
pub const __drv_typeConst = 0;
pub const CERT_CREATE_CONTEXT_SORTED_FLAG = 2;
pub const BitTestAndReset64 = _bittestandreset64;
pub const MCI_LAST = 4095;
pub const ERROR_RESOURCE_NOT_PRESENT = @as(c_long, 4316);
pub const MAX_SIZE_SECURITY_ID = 512;
pub const PROC_THREAD_ATTRIBUTE_THREAD = 65536;
pub const CLIENTSITE_E_LAST = @as(c_long, 2147746207);
pub const PRODUCT_DATACENTER_A_SERVER_CORE = 145;
pub const GetKerningPairs = GetKerningPairsA;
pub const szOID_DSALG_CRPT = "2.5.8.1";
pub const VFT2_FONT_RASTER = @as(c_long, 1);
pub const PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_OFF = 2 << 28;
pub const szOID_PKCS_7_DIGESTED = "1.2.840.113549.1.7.5";
pub const RPC_X_PIPE_DISCIPLINE_ERROR = @as(c_long, 1917);
pub const FRS_ERR_SYSVOL_POPULATE_TIMEOUT = @as(c_long, 8014);
pub const SM_RESERVED1 = 24;
pub const REMOTE_NAME_INFO_LEVEL = 2;
pub const CERT_COMPARE_ENHKEY_USAGE = 10;
pub const STARTF_USESHOWWINDOW = 1;
pub const ALG_SID_DH_SANDF = 1;
pub const SERVICE_TRIGGER_DATA_TYPE_KEYWORD_ANY = 4;
pub const QUOTA_LIMITS_HARDWS_MAX_DISABLE = 8;
pub const COLOR_BACKGROUND = 1;
pub const MIXERLINE_TARGETTYPE_MIDIOUT = 3;
pub const InterlockedOrAcquire = _InterlockedOr;
pub const _WIN32_WINNT_WINBLUE = 1539;
pub const OUT_SCREEN_OUTLINE_PRECIS = 9;
pub const WSAECONNABORTED = @as(c_long, 10053);
pub const RPC_S_INTERFACE_NOT_EXPORTED = @as(c_long, 1924);
pub const IPPROTO_TCP = 6;
pub const DNS_ERROR_NOT_UNIQUE = @as(c_long, 9555);
pub const APPIDREGFLAGS_RESERVED1 = 64;
pub const RI_MOUSE_LEFT_BUTTON_UP = 2;
pub const CB_SHOWDROPDOWN = 335;
pub const EXTTEXTOUT = 512;
pub const _WIN32_IE_XP = _WIN32_IE_IE60;
pub const DS_CENTER = @as(c_long, 2048);
pub const PF_DLI = AF_DLI;
pub const PP_KEYEXCHANGE_KEYSIZE = 12;
pub const CERT_SCEP_GUID_PROP_ID = 116;
pub const GGO_GRAY4_BITMAP = 5;
pub const CP_WINNEUTRAL = CP_WINANSI;
pub const BS_NULL = 1;
pub const SM_CYEDGE = 46;
pub const mciGetErrorString = mciGetErrorStringA;
pub const SIZE_MAX = _UI64_MAX;
pub const CERT_NAME_UPN_TYPE = 8;
pub const ES_UPPERCASE = @as(c_long, 8);
pub const CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG = 32768;
pub const OpenSemaphore = OpenSemaphoreA;
pub const PRINTRATEUNIT_CPS = 2;
pub const PROCESS_CREATION_MITIGATION_POLICY2_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY_MASK = if (@typeId(@typeOf(i64 << 20)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 20) else if (@typeId(@typeOf(i64 << 20)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 20) else @as(c_uint, 3)(i64 << 20);
pub const WN_NOT_CONNECTED = ERROR_NOT_CONNECTED;
pub const OF_SHARE_EXCLUSIVE = 16;
pub const DDL_READWRITE = 0;
pub const PIDSI_SUBJECT = @as(c_long, 3);
pub const PS_DASHDOT = 3;
pub const XSTATE_CONTROLFLAG_XSAVEOPT_MASK = 1;
pub const __writableTo = size;
pub const IMAGE_REL_ALPHA_REFQUAD = 2;
pub const SPI_SETSTICKYKEYS = 59;
pub const CFSTR_MIME_RAWDATA = if (@typeId(@typeOf("application/octet-stream")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "application/octet-stream") else if (@typeId(@typeOf("application/octet-stream")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "application/octet-stream") else TEXT("application/octet-stream");
pub const DT_NOCLIP = 256;
pub const ERROR_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND = @as(c_long, 4574);
pub const MCI_VD_GETDEVCAPS_CAN_REVERSE = @as(c_long, 16386);
pub const SDC_APPLY = 128;
pub const S_STACCATO = 2;
pub const CRYPT_MESSAGE_BARE_CONTENT_OUT_FLAG = 1;
pub const ERROR_DIFFERENT_VERSION_OF_PACKAGED_SERVICE_INSTALLED = @as(c_long, 15654);
pub const MMSYSERR_NOERROR = 0;
pub const LANG_SPANISH = 10;
pub const __UINT32_FMTo__ = "o";
pub const IMN_PRIVATE = 14;
pub const lst2 = 1121;
pub const CERT_CHAIN_USE_LOCAL_MACHINE_STORE = 8;
pub const ERROR_INVALID_DWP_HANDLE = @as(c_long, 1405);
pub const SERVICE_WIN32_SHARE_PROCESS = 32;
pub const SET_REPAIR_DISABLED_AND_BUGCHECK_ON_CORRUPT = 16;
pub const ERROR_DS_NO_CROSSREF_FOR_NC = @as(c_long, 8363);
pub const PSH_WIZARDCONTEXTHELP = 4096;
pub const FROM_LEFT_4TH_BUTTON_PRESSED = 16;
pub const PKCS_RSA_SSA_PSS_PARAMETERS = if (@typeId(@typeOf(75)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 75) else if (@typeId(@typeOf(75)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 75) else LPCSTR(75);
pub const SO_ERROR = 4103;
pub const LOCALE_STHOUSAND = 15;
pub const META_DELETEOBJECT = 496;
pub const LCMAP_HASH = 262144;
pub const SUBLANG_SPANISH_ECUADOR = 12;
pub const PKCS_ENCRYPTED_PRIVATE_KEY_INFO = if (@typeId(@typeOf(45)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 45) else if (@typeId(@typeOf(45)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 45) else LPCSTR(45);
pub const CFSTR_MIME_XHTML = if (@typeId(@typeOf("application/xhtml+xml")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "application/xhtml+xml") else if (@typeId(@typeOf("application/xhtml+xml")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "application/xhtml+xml") else TEXT("application/xhtml+xml");
pub const WNNC_NET_FTP_NFS = 786432;
pub const PFD_SWAP_LAYER_BUFFERS = 2048;
pub const VTA_TOP = TA_LEFT;
pub const PP_PROVTYPE = 16;
pub const RI_MOUSE_BUTTON_4_UP = 128;
pub const WH_DEBUG = 9;
pub const NRC_ACTSES = 15;
pub const PD_ENABLEPRINTTEMPLATE = 16384;
pub const UNIFIEDBUILDREVISION_MIN = 0;
pub const INVALID_P_ROOT_SECURITY_ID = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast([*c]BYTE, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr([*c]BYTE, -1) else ([*c]BYTE)(-1);
pub const ENOMEM = 12;
pub const DCOMSCM_PING_USE_MID_AUTHNSERVICE = 16;
pub const IMAGE_REL_PPC_TOCDEFN = 2048;
pub const szOID_INFOSEC_mosaicUpdatedSig = "2.16.840.1.101.2.1.1.19";
pub const MDM_SHIFT_X75_DATA = 0;
pub const MCI_CDA_STATUS_TYPE_TRACK = @as(c_long, 16385);
pub const LR_CREATEDIBSECTION = 8192;
pub const DISK_LOGGING_STOP = 1;
pub const DEVICE_DSM_FLAG_SCRUB_OUTPUT_PARITY_EXTENT = 536870912;
pub const URLOSTRM_USECACHEDCOPY = 2;
pub const WM_POINTERROUTEDRELEASED = 595;
pub const STORAGE_HW_FIRMWARE_REQUEST_FLAG_LAST_SEGMENT = 2;
pub const EMARCH_ENC_I17_IMM7B_INST_WORD_X = 3;
pub const ERROR_INVALID_PRIORITY = @as(c_long, 1800);
pub const FACILITY_USERMODE_VOLMGR = 56;
pub const RPC_S_INCOMPLETE_NAME = @as(c_long, 1755);
pub const DIAGNOSTIC_REASON_INVALID_FLAGS = ~2147483655;
pub const SECURITY_APP_PACKAGE_BASE_RID = @as(c_long, 2);
pub const CRL_REASON_CA_COMPROMISE = 2;
pub const PRINTER_ATTRIBUTE_DEFAULT = 4;
pub const IO_REPARSE_TAG_CLOUD_A = @as(c_long, 2415960090);
pub const DNS_ERROR_RECORD_FORMAT = @as(c_long, 9702);
pub const RESOURCEDISPLAYTYPE_GROUP = 5;
pub const LOCALE_SMONTHNAME10 = 65;
pub const PAGE_EXECUTE = 16;
pub const TAPE_DRIVE_SET_COMPRESSION = 2147484160;
pub const ERROR_NOT_SNAPSHOT_VOLUME = @as(c_long, 6841);
pub const CTRY_LATVIA = 371;
pub const RPC_NCA_FLAGS_DEFAULT = 0;
pub const HEAP_CREATE_ALIGN_16 = 65536;
pub const SET_FEATURE_ON_THREAD = 1;
pub const CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG = 1;
pub const EIMES_CANCELCOMPSTRINFOCUS = 2;
pub const PRINTER_DRIVER_CATEGORY_FAX = 64;
pub const PeekMessage = PeekMessageA;
pub const szOID_CERT_STRONG_KEY_OS_1 = "1.3.6.1.4.1.311.72.2.1";
pub const RegUnLoadKey = RegUnLoadKeyA;
pub const META_SCALEVIEWPORTEXT = 1042;
pub const CB_FINDSTRING = 332;
pub const VS_FF_INFOINFERRED = @as(c_long, 16);
pub const WS_EX_ACCEPTFILES = @as(c_long, 16);
pub const WM_POINTERDEVICECHANGE = 568;
pub const TA_BOTTOM = 8;
pub const STATE_SYSTEM_EXTSELECTABLE = 33554432;
pub const KP_Q = 13;
pub const UNDEFINE_ALTERNATE = 13;
pub const CRYPT_LOCAL = 1;
pub const DOMAIN_ALIAS_RID_STORAGE_REPLICA_ADMINS = @as(c_long, 582);
pub const DNS_ERROR_INVALID_ROLLOVER_PERIOD = @as(c_long, 9114);
pub const LPOINETPROTOCOLSINKSTACKABLE = LPIINTERNETPROTOCOLSINKSTACKABLE;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INVALID = 0;
pub const WM_TABLET_FIRST = 704;
pub const WSABASEERR = 10000;
pub const MDM_CCITT_OVERRIDE = 64;
pub const FOCUS_EVENT = 16;
pub const NCBSENDNA = 113;
pub const MB_SYSTEMMODAL = @as(c_long, 4096);
pub const PP_PIN_PROMPT_STRING = 44;
pub const FILE_TYPE_REMOTE = 32768;
pub const __ATOMIC_RELAXED = 0;
pub const DC_SIZE = 8;
pub const R2_NOTCOPYPEN = 4;
pub const ChangeDisplaySettingsEx = ChangeDisplaySettingsExA;
pub const ENABLE_EXTENDED_FLAGS = 128;
pub const GetOpenFileName = GetOpenFileNameA;
pub const CLRRTS = 4;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN = 5;
pub const FO_MOVE = 1;
pub const TRANSPORT_TYPE_DG = 2;
pub const TC_SA_DOUBLE = 64;
pub const ERROR_INVALID_LOCK_RANGE = @as(c_long, 307);
pub const ERROR_APP_DATA_NOT_FOUND = @as(c_long, 4400);
pub const PROCESSOR_THROTTLE_ENABLED = 1;
pub const IMFT_SUBMENU = 4;
pub const MOUSEEVENTF_VIRTUALDESK = 16384;
pub const __FLT16_MIN_EXP__ = -14;
pub const URLPOLICY_JAVA_HIGH = 65536;
pub const MMIO_WRITE = 1;
pub const S_WHITEVOICE = 7;
pub const C3_KATAKANA = 16;
pub const X3_TMPLT_INST_WORD_X = 0;
pub const PIDDSI_SCALE = 11;
pub const CERT_STORE_LOCALIZED_NAME_PROP_ID = 4096;
pub const DOMAIN_ALIAS_RID_PREW2KCOMPACCESS = @as(c_long, 554);
pub const EXCEPTION_TARGET_UNWIND = 32;
pub const IMAGE_FILE_MACHINE_AXP64 = IMAGE_FILE_MACHINE_ALPHA64;
pub const AF_DLI = 13;
pub const SC_ZOOM = SC_MAXIMIZE;
pub const LOAD_DLL_DEBUG_EVENT = 6;
pub const S_SERDMD = -10;
pub const OpenEncryptedFileRaw = OpenEncryptedFileRawA;
pub const lst3 = 1122;
pub const SM_MOUSEWHEELPRESENT = 75;
pub const szOID_INFOSEC_mosaicUpdatedInteg = "2.16.840.1.101.2.1.1.21";
pub const CMSG_SIGNED_DATA_CMS_VERSION = CMSG_SIGNED_DATA_V3;
pub const MEDIA_WRITE_ONCE = 2;
pub const CHANGER_CLOSE_IEPORT = 4;
pub const SBM_SETRANGEREDRAW = 230;
pub const ERROR_PRINTER_DRIVER_BLOCKED = @as(c_long, 3014);
pub const SE_GROUP_INTEGRITY_ENABLED = @as(c_long, 64);
pub const MAP_FOLDCZONE = 16;
pub const LoadCursor = LoadCursorA;
pub const EHOSTUNREACH = 110;
pub const ENLISTMENT_MAXIMUM_OPTION = 1;
pub const CMSG_LENGTH_ONLY_FLAG = 2;
pub const PSM_SETNEXTTEXT = PSM_SETNEXTTEXTW;
pub const DNS_ERROR_NOT_ALLOWED_ON_ACTIVE_SKD = @as(c_long, 9119);
pub const SUBLANG_KYRGYZ_KYRGYZSTAN = 1;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_TIME_OF_DAY = @as(c_long, 9996);
pub const PRINTER_NOTIFY_FIELD_STATUS = 18;
pub const ACCESS_OBJECT_GUID = 0;
pub const CRYPT_OID_INFO_OID_GROUP_BIT_LEN_SHIFT = 16;
pub const CRYPT_SSL2_FALLBACK = 2;
pub const InterlockedAnd8 = _InterlockedAnd8;
pub const CTRY_VENEZUELA = 58;
pub const IMN_SETSTATUSWINDOWPOS = 12;
pub const CRYPTPROTECT_PROMPT_ON_UNPROTECT = 1;
pub const WSAEPROVIDERFAILEDINIT = @as(c_long, 10106);
pub const MEM_DECOMMIT = 16384;
pub const ERROR_DS_LOW_DSA_VERSION = @as(c_long, 8568);
pub const CTRY_HUNGARY = 36;
pub const PAN_MIDLINE_LOW_POINTED = 12;
pub const PSWIZB_BACK = 1;
pub const OBJ_EXTPEN = 11;
pub const IMAGE_REL_AMD64_PAIR = 15;
pub const RPI_FLAG_SMB2_SHARECAP_CONTINUOUS_AVAILABILITY = 16;
pub const PIDMSI_SEQUENCE_NO = @as(c_long, 5);
pub const CB_RESETCONTENT = 331;
pub const CFORCEINLINE = FORCEINLINE;
pub const EVENT_OBJECT_HIDE = 32771;
pub const DocumentProperties = DocumentPropertiesA;
pub const MDM_X75_DATA_64K = 1;
pub const VK_SELECT = 41;
pub const STGM_READ = @as(c_long, 0);
pub const CRYPTPROTECT_PROMPT_REQUIRE_STRONG = 16;
pub const __corei7__ = 1;
pub const UPDP_SILENT_UPLOAD = 1;
pub const CLIPBRD_E_LAST = @as(c_long, 2147746271);
pub const GWL_STYLE = -16;
pub const BCRYPT_ECDH_PUBLIC_P384_MAGIC = 860570437;
pub const PRINTER_NOTIFY_FIELD_UNTIL_TIME = 17;
pub const SW_PARENTOPENING = 3;
pub const EMR_SETLAYOUT = 115;
pub const RegDeleteTree = RegDeleteTreeA;
pub const IO_REPARSE_TAG_CLOUD_B = @as(c_long, 2415964186);
pub const MultiplyHigh = __mulh;
pub const LOCALE_SMONTHNAME13 = 4110;
pub const SIF_POS = 4;
pub const WAVE_FORMAT_44M16 = 1024;
pub const WriteProfileSection = WriteProfileSectionA;
pub const LB_SETTABSTOPS = 402;
pub const FAST_FAIL_DLOAD_PROTECTION_FAILURE = 25;
pub const RPC_C_EP_ALL_ELTS = 0;
pub const OLE_S_LAST = if (@typeId(@typeOf(@as(c_long, 262399))) == @import("builtin").TypeId.Pointer) @ptrCast(HRESULT, @as(c_long, 262399)) else if (@typeId(@typeOf(@as(c_long, 262399))) == @import("builtin").TypeId.Int) @intToPtr(HRESULT, @as(c_long, 262399)) else HRESULT(@as(c_long, 262399));
pub const szOID_RSA_hashedData = "1.2.840.113549.1.7.5";
pub const DEFAULT_PALETTE = 15;
pub const VOS_OS232 = @as(c_long, 196608);
pub const JOB_OBJECT_SET_SECURITY_ATTRIBUTES = 16;
pub const CDN_FOLDERCHANGE = if (@typeId(@typeOf(-2)) == @import("builtin").TypeId.Pointer) @ptrCast(CDN_FIRST, -2) else if (@typeId(@typeOf(-2)) == @import("builtin").TypeId.Int) @intToPtr(CDN_FIRST, -2) else CDN_FIRST(-2);
pub const FAST_FAIL_VTGUARD_CHECK_FAILURE = 1;
pub const X509_CRL_DIST_POINTS = if (@typeId(@typeOf(35)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 35) else if (@typeId(@typeOf(35)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 35) else LPCSTR(35);
pub const JOY_BUTTON2CHG = 512;
pub const CERT_STORE_SAVE_AS_STORE = 1;
pub const SKF_RWINLATCHED = 2147483648;
pub const LOCALE_SENGLISHDISPLAYNAME = 114;
pub const PKCS12_EXPORT_ECC_CURVE_PARAMETERS = 4096;
pub const CRL_REASON_PRIVILEGE_WITHDRAWN_FLAG = 1;
pub const KP_ADMIN_PIN = 31;
pub const MEM_ROTATE = 8388608;
pub const ERROR_CAPAUTHZ_NOT_DEVUNLOCKED = @as(c_long, 450);
pub const FILE_DEVICE_TAPE_FILE_SYSTEM = 32;
pub const CONNECT_TEMPORARY = 4;
pub const KP_P = 11;
pub const SUBLANG_SAMI_NORTHERN_NORWAY = 1;
pub const CTRY_THAILAND = 66;
pub const CERT_SMART_CARD_READER_NON_REMOVABLE_PROP_ID = 106;
pub const CMSG_ENCODED_MESSAGE = 29;
pub const KEY_WOW64_32KEY = 512;
pub const DNS_ERROR_RCODE_YXRRSET = @as(c_long, 9007);
pub const CRYPT_ACQUIRE_NCRYPT_KEY_FLAGS_MASK = 458752;
pub const SecureZeroMemory = RtlSecureZeroMemory;
pub const BS_DEFPUSHBUTTON = @as(c_long, 1);
pub const PFD_DOUBLEBUFFER = 1;
pub const EMR_RESERVED_120 = 120;
pub const NCRYPT_NO_CACHED_PASSWORD = 16384;
pub const CERT_SELECT_LAST = CERT_SELECT_BY_TLS_SIGNATURES;
pub const FEATURESETTING_PROTOCOL = 6;
pub const ERROR_LOG_RESERVATION_INVALID = @as(c_long, 6615);
pub const CHANGER_TRUE_EXCHANGE_CAPABLE = 2147483656;
pub const APPIDREGFLAGS_RESERVED3 = 256;
pub const FILE_DEVICE_UNKNOWN = 34;
pub const PST_X25 = if (@typeId(@typeOf(259)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 259) else if (@typeId(@typeOf(259)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 259) else DWORD(259);
pub const COMMON_LVB_GRID_LVERTICAL = 2048;
pub const PST_RS232 = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 1) else DWORD(1);
pub const IMAGE_HOT_PATCH_NONE = 0;
pub const EILSEQ = 42;
pub const OPLOCK_LEVEL_CACHE_WRITE = 4;
pub const __UINT_FAST32_MAX__ = @as(c_uint, 4294967295);
pub const SUBLANG_KASHMIRI_SASIA = 2;
pub const ReadSizeTAcquire = ReadULongPtrAcquire;
pub const ERROR_RESTART_APPLICATION = @as(c_long, 1467);
pub const LOCALE_SABBREVCTRYNAME = 7;
pub const JOB_ACCESS_READ = 32;
pub const GMEM_NODISCARD = 32;
pub const IMAGE_REL_PPC_ADDR14 = 5;
pub const CERT_AIA_URL_RETRIEVED_PROP_ID = 67;
pub const URLACTION_ACTIVEX_DYNSRC_VIDEO_AND_ANIMATION = 4618;
pub const szOID_ENROLL_SCEP_SERVER_SECRET = "1.3.6.1.4.1.311.21.40";
pub const RPC_C_PROTECT_LEVEL_PKT_INTEGRITY = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
pub const RPC_C_USE_INTERNET_PORT = 1;
pub const USN_REASON_STREAM_CHANGE = 2097152;
pub const LOCALE_SSORTLOCALE = 123;
pub const CMSG_SIGNER_COUNT_PARAM = 5;
pub const CRYPT_STRING_STRICT = 536870912;
pub const POINTER_MESSAGE_FLAG_INRANGE = 2;
pub const GCL_STYLE = -26;
pub const ARW_STARTTOP = @as(c_long, 2);
pub const NDR_LOCAL_ENDIAN = NDR_LITTLE_ENDIAN;
pub const ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN = @as(c_long, 8569);
pub const SCardListReaders = SCardListReadersA;
pub const QUERYDIBSUPPORT = 3073;
pub const MUI_QUERY_CHECKSUM = 2;
pub const ERROR_STACK_OVERFLOW = @as(c_long, 1001);
pub const PSD_SHOWHELP = 2048;
pub const SPI_SETDOUBLECLKHEIGHT = 30;
pub const EMR_SETVIEWPORTORGEX = 12;
pub const WNNC_NET_OBJECT_DIRE = 3145728;
pub const URLACTION_WINDOWS_BROWSER_APPLICATIONS = 9216;
pub const ERROR_DISK_RESET_FAILED = @as(c_long, 1128);
pub const SECURITY_MIN_IMPERSONATION_LEVEL = SecurityAnonymous;
pub const CBF_FAIL_ALLSVRXACTIONS = 258048;
pub const RPC_S_SERVER_UNAVAILABLE = @as(c_long, 1722);
pub const ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER = @as(c_long, 8497);
pub const MF_BYCOMMAND = @as(c_long, 0);
pub const LB_RESETCONTENT = 388;
pub const SHUTDOWN_RESTART_BOOTOPTIONS = 1024;
pub const MDM_SHIFT_BEARERMODE = 12;
pub const ERROR_TOO_MANY_THREADS = @as(c_long, 565);
pub const PAN_STRAIGHT_ARMS_WEDGE = 3;
pub const MS_ENH_RSA_AES_PROV = MS_ENH_RSA_AES_PROV_A;
pub const SHGFI_SELECTED = 65536;
pub const ChangeServiceConfig2 = ChangeServiceConfig2A;
pub const IMAGE_REL_ARM_ADDR32 = 1;
pub const DM_DITHERTYPE = @as(c_long, 67108864);
pub const WSA_QOS_EFILTERCOUNT = @as(c_long, 11021);
pub const SPI_ICONHORIZONTALSPACING = 13;
pub const URLACTION_SCRIPT_NAVIGATE = 5130;
pub const RpcServerUseProtseqEpEx = RpcServerUseProtseqEpExA;
pub const DOMAIN_ALIAS_RID_ACCOUNT_OPS = @as(c_long, 548);
pub const SCARD_CLASS_SYSTEM = 32767;
pub const szOID_NETSCAPE_CERT_RENEWAL_URL = "2.16.840.1.113730.1.7";
pub const IMPLINK_HIGHEXPER = 158;
pub const ERROR_DS_NO_MSDS_INTID = @as(c_long, 8596);
pub const LANG_JAPANESE = 17;
pub const WAVE_ALLOWSYNC = 2;
pub const GESTUREVISUALIZATION_PRESSANDHOLD = 8;
pub const EN_KILLFOCUS = 512;
pub const VIF_OUTOFSPACE = @as(c_long, 256);
pub const ERROR_EVENTLOG_CANT_START = @as(c_long, 1501);
pub const DI_COMPAT = 4;
pub const FILE_ADD_FILE = 2;
pub const IMR_QUERYCHARPOSITION = 6;
pub const IMC_CLOSESTATUSWINDOW = 33;
pub const EVENT_OBJECT_FOCUS = 32773;
pub const szOID_NTDS_REPLICATION = "1.3.6.1.4.1.311.25.1";
pub const VarUintFromUI8 = VarUI4FromUI8;
pub const CERT_ENHKEY_USAGE_PROP_ID = 9;
pub const BN_HILITE = 2;
pub const FEATURESETTING_PRIVATE_BEGIN = 4096;
pub const WM_DELETEITEM = 45;
pub const USER_TIMER_MINIMUM = 10;
pub const ERROR_APPHELP_BLOCK = @as(c_long, 1259);
pub const WM_CTLCOLORSCROLLBAR = 311;
pub const ERROR_RUNLEVEL_SWITCH_TIMEOUT = @as(c_long, 15402);
pub const ERROR_NO_SUCH_DEVICE = @as(c_long, 433);
pub const ERROR_RESUME_HIBERNATION = @as(c_long, 727);
pub const CDB_SIZE = 16;
pub const ERROR_INVALID_CLUSTER_IPV6_ADDRESS = @as(c_long, 5911);
pub const EMARCH_ENC_I17_SIGN_INST_WORD_X = 3;
pub const DFCS_CAPTIONHELP = 4;
pub const IO_REPARSE_TAG_CLOUD_C = @as(c_long, 2415968282);
pub const ERROR_BLOCKED_BY_PARENTAL_CONTROLS = @as(c_long, 346);
pub const LISTEN_OUTSTANDING = 1;
pub const DMPAPER_LETTER_ROTATED = 75;
pub const SECURITY_CAPABILITY_INTERNET_EXPLORER = @as(c_long, 4096);
pub const LOCALE_SMONTHNAME12 = 67;
pub const HBMMENU_MBAR_MINIMIZE_D = if (@typeId(@typeOf(7)) == @import("builtin").TypeId.Pointer) @ptrCast(HBITMAP, 7) else if (@typeId(@typeOf(7)) == @import("builtin").TypeId.Int) @intToPtr(HBITMAP, 7) else HBITMAP(7);
pub const ERROR_WRITE_PROTECT = @as(c_long, 19);
pub const CAL_IYEAROFFSETRANGE = 3;
pub const ERROR_LOG_CONTAINER_LIMIT_EXCEEDED = @as(c_long, 6617);
pub const FACILITY_DLS = 153;
pub const IMAGE_REL_ARM_GPREL7 = 7;
pub const MAX_REASON_COMMENT_LEN = 512;
pub const FEATURESETTING_PRIVATE_END = 8191;
pub const WNNC_NET_OPENAFS = 3735552;
pub const CERT_BUNDLE_CERTIFICATE = 0;
pub const ERROR_DS_CANT_RETRIEVE_INSTANCE = @as(c_long, 8407);
pub const PROOF_QUALITY = 2;
pub const RPC_C_OPT_RESOURCE_TYPE_UUID = 8;
pub const DCB_DIRTY = DCB_ACCUMULATE;
pub const EMR_POLYTEXTOUTW = 97;
pub const LPD_TRANSPARENT = 4096;
pub const WM_SIZING = 532;
pub const ERROR_LOCAL_USER_SESSION_KEY = @as(c_long, 1303);
pub const MH_DELETE = 3;
pub const ERROR_CALL_NOT_IMPLEMENTED = @as(c_long, 120);
pub const PRODUCT_CORE_COUNTRYSPECIFIC = 99;
pub const STATUS_ILLEGAL_INSTRUCTION = if (@typeId(@typeOf(@as(c_long, 3221225501))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225501)) else if (@typeId(@typeOf(@as(c_long, 3221225501))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225501)) else DWORD(@as(c_long, 3221225501));
pub const ERROR_CIRCULAR_DEPENDENCY = @as(c_long, 1059);
pub const IMAGE_REL_CEF_ADDR32 = 1;
pub const CERT_STORE_PROV_FREE_FIND_CERT_FUNC = 15;
pub const SM_RESERVED4 = 27;
pub const Uri_CREATE_CRACK_UNKNOWN_SCHEMES = 512;
pub const IMAGE_REL_AMD64_SECREL = 11;
pub const FIBER_FLAG_FLOAT_SWITCH = 1;
pub const CFSTR_MIME_X_SGI_MOVIE = if (@typeId(@typeOf("video/x-sgi-movie")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "video/x-sgi-movie") else if (@typeId(@typeOf("video/x-sgi-movie")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "video/x-sgi-movie") else TEXT("video/x-sgi-movie");
pub const MMIO_DENYREAD = 48;
pub const DM_PRINTQUALITY = @as(c_long, 1024);
pub const APPIDREGFLAGS_RESERVED2 = 128;
pub const ERROR_EVT_EVENT_DEFINITION_NOT_FOUND = @as(c_long, 15032);
pub const CHECKPNGFORMAT = 4120;
pub const SPI_GETPENSIDEMOVETHRESHOLD = 138;
pub const DM_OUT_DEFAULT = DM_UPDATE;
pub const NeedCurrentDirectoryForExePath = NeedCurrentDirectoryForExePathA;
pub const WC_ERR_INVALID_CHARS = 128;
pub const ERROR_SPL_NO_STARTDOC = @as(c_long, 3003);
pub const VIF_CANNOTDELETECUR = @as(c_long, 16384);
pub const ERROR_PNP_QUERY_REMOVE_DEVICE_TIMEOUT = @as(c_long, 480);
pub const CRYPT_OID_REGISTER_SYSTEM_STORE_FUNC = "CertDllRegisterSystemStore";
pub const SBS_SIZEGRIP = @as(c_long, 16);
pub const FILE_DEVICE_BLUETOOTH = 65;
pub const ID_CMD = 236;
pub const QDC_INCLUDE_HMD = 32;
pub const ERROR_DEVICE_NOT_CONNECTED = @as(c_long, 1167);
pub const CERT_STORE_SAVE_AS_PKCS12 = 3;
pub const ERROR_DS_BAD_RDN_ATT_ID_SYNTAX = @as(c_long, 8392);
pub const LGRPID_WESTERN_EUROPE = 1;
pub const PRINTER_ATTRIBUTE_PUSHED_USER = 131072;
pub const NRC_MAXAPPS = 54;
pub const PRODUCT_SERVER_FOUNDATION = 33;
pub const ERROR_ENCRYPTED_IO_NOT_POSSIBLE = @as(c_long, 808);
pub const MS_SCARD_PROV = MS_SCARD_PROV_A;
pub const DRIVE_REMOVABLE = 2;
pub const IMAGE_REL_AMD64_CFG_CALL = 22;
pub const TME_CANCEL = 2147483648;
pub const VTA_LEFT = TA_BOTTOM;
pub const ERROR_ENCRYPTING_METADATA_DISALLOWED = @as(c_long, 431);
pub const MFS_UNHILITE = MF_UNHILITE;
pub const FILE_NOTIFY_CHANGE_LAST_WRITE = 16;
pub const SCARD_READER_SWALLOWS = 1;
pub const CAL_PERSIAN = 22;
pub const WM_CTLCOLOREDIT = 307;
pub const SEC_COMMIT = 134217728;
pub const STREAMS_ASSOCIATE_ID_SET = 2;
pub const CDERR_LOADSTRFAILURE = 5;
pub const WM_INPUTLANGCHANGE = 81;
pub const CWF_CREATE_ONLY = 1;
pub const WriteSizeTRelease = WriteULongPtrRelease;
pub const SetICMProfile = SetICMProfileA;
pub const ERROR_SECUREBOOT_POLICY_NOT_AUTHORIZED = @as(c_long, 4427);
pub const SPI_GETTOOLTIPFADE = 4120;
pub const CMSG_OID_CNG_IMPORT_KEY_TRANS_FUNC = "CryptMsgDllCNGImportKeyTrans";
pub const __LZCNT__ = 1;
pub const APPIDREGFLAGS_IUSERVER_UNMODIFIED_LOGON_TOKEN = 8;
pub const COLOR_HOTLIGHT = 26;
pub const PAN_CONTRAST_LOW = 4;
pub const RESOURCEDISPLAYTYPE_TREE = 10;
pub const CERT_STORE_PROV_DELETE_CRL_FUNC = 7;
pub const TXFS_START_RM_FLAG_PREFER_CONSISTENCY = 4096;
pub const VarI4FromInt = VarI4FromI4;
pub const OLEOBJ_S_LAST = @as(c_long, 262543);
pub const CRYPT_RC2_64BIT_VERSION = 120;
pub const PROCESS_CREATION_MITIGATION_POLICY2_MODULE_TAMPERING_PROTECTION_NOINHERIT = if (@typeId(@typeOf(i64 << 12)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 12) else if (@typeId(@typeOf(i64 << 12)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 12) else @as(c_uint, 3)(i64 << 12);
pub const ERROR_DS_AUTH_METHOD_NOT_SUPPORTED = @as(c_long, 8231);
pub const ELEMENT_STATUS_INENAB = 32;
pub const Uri_PUNYCODE_IDN_HOST = 2;
pub const __FMA__ = 1;
pub const PIDDSI_COMPANY = 15;
pub const SPI_SETLISTBOXSMOOTHSCROLLING = 4103;
pub const IMR_DOCUMENTFEED = 7;
pub const EEInfoGCCOM = 11;
pub const SECURITY_PROCESS_PROTECTION_TYPE_LITE_RID = @as(c_long, 512);
pub const LOCALE_SABBREVMONTHNAME2 = 69;
pub const ERROR_SERVICE_EXISTS_AS_NON_PACKAGED_SERVICE = @as(c_long, 15655);
pub const ALG_CLASS_HASH = 4 << 13;
pub const CTLCOLOR_MSGBOX = 0;
pub const REASON_LEGACY_API = SHTDN_REASON_LEGACY_API;
pub const PERSISTENT_VOLUME_STATE_SHORT_NAME_CREATION_DISABLED = 1;
pub const PID_FIRST_USABLE = 2;
pub const PMB_ACTIVE = 1;
pub const VIF_FILEINUSE = @as(c_long, 128);
pub const LOCALE_SDAYNAME2 = 43;
pub const STORAGE_EVENT_MEDIA_STATUS = 1;
pub const OpenDesktop = OpenDesktopA;
pub const DMLERR_EXECACKTIMEOUT = 16389;
pub const DISP_CHANGE_BADPARAM = -5;
pub const __UINT_LEAST64_FMTx__ = "llx";
pub const PKCS_RC2_CBC_PARAMETERS = if (@typeId(@typeOf(41)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 41) else if (@typeId(@typeOf(41)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 41) else LPCSTR(41);
pub const CERT_STORE_PROV_WRITE_CRL_FUNC = 6;
pub const SPI_GETCLIENTAREAANIMATION = 4162;
pub const ALG_SID_SKIPJACK = 10;
pub const szOID_CT_CERT_SCTLIST = "1.3.6.1.4.1.11129.2.4.2";
pub const DMPAPER_LETTER_EXTRA_TRANSVERSE = 56;
pub const DM_MEDIATYPE = @as(c_long, 33554432);
pub const InterlockedExchangeAddRelease64 = _InterlockedExchangeAdd64;
pub const DC_VERSION = 10;
pub const FR_FINDNEXT = 8;
pub const CRYPT_ENCODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG = 8;
pub const STDOLE2_LCID = 0;
pub const LOCALE_IGEOID = 91;
pub const MCI_DEVTYPE_LAST = MCI_DEVTYPE_SEQUENCER;
pub const ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED = @as(c_long, 8536);
pub const GWLP_HINSTANCE = -6;
pub const ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH = @as(c_long, 13887);
pub const OCSP_BASIC_UNKNOWN_CERT_STATUS = 2;
pub const FS_JOHAB = @as(c_long, 2097152);
pub const ERROR_PWD_TOO_SHORT = @as(c_long, 615);
pub const FLASHW_TRAY = 2;
pub const IMAGE_REL_PPC_IMGLUE = 14;
pub const APPCOMMAND_BROWSER_REFRESH = 3;
pub const GW_ENABLEDPOPUP = 6;
pub const CMC_STATUS_PENDING = 3;
pub const ERROR_IRQ_BUSY = @as(c_long, 1119);
pub const INET_E_ERROR_LAST = INET_E_DOWNLOAD_BLOCKED_BY_CSP;
pub const MF_DELETE = @as(c_long, 512);
pub const IMAGE_DLLCHARACTERISTICS_WDM_DRIVER = 8192;
pub const MNS_CHECKORBMP = 67108864;
pub const BCRYPT_RNG_ALG_HANDLE = if (@typeId(@typeOf(129)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 129) else if (@typeId(@typeOf(129)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 129) else BCRYPT_ALG_HANDLE(129);
pub const SHRT_MIN = -32768;
pub const PROCESS_CREATION_MITIGATION_POLICY2_MODULE_TAMPERING_PROTECTION_ALWAYS_OFF = if (@typeId(@typeOf(i64 << 12)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 2), i64 << 12) else if (@typeId(@typeOf(i64 << 12)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 2), i64 << 12) else @as(c_uint, 2)(i64 << 12);
pub const SHGNLI_PREFIXNAME = 2;
pub const CERT_CHAIN_DISABLE_MOTW_FILE_HASH_WEAK_FLAG = 8192;
pub const szOID_KP_QUALIFIED_SUBORDINATION = "1.3.6.1.4.1.311.10.3.10";
pub const OFN_NODEREFERENCELINKS = 1048576;
pub const szOID_ENROLL_KEY_AFFINITY = "1.3.6.1.4.1.311.21.41";
pub const SPI_SETCLEARTYPE = 4169;
pub const CERT_TRUST_HAS_NAME_MATCH_ISSUER = 4;
pub const ERROR_APP_INIT_FAILURE = @as(c_long, 575);
pub const IMAGE_REL_ARM_BRANCH24 = 3;
pub const MCI_DEVTYPE_WAVEFORM_AUDIO = 522;
pub const WS_VISIBLE = @as(c_long, 268435456);
pub const COMPRESSION_ENGINE_HIBER = 512;
pub const IPPORT_MTP = 57;
pub const LPOINETPROTOCOLINFO = LPIINTERNETPROTOCOLINFO;
pub const FACILITY_GAME = 2340;
pub const PRINT_PROP_FORCE_NAME = 1;
pub const DEVICEFAMILYINFOENUM_UAP = 0;
pub const JOB_OBJECT_MSG_SILO_TERMINATED = 13;
pub const SPI_SETPENDRAGOUTTHRESHOLD = 135;
pub const RETURN_SMART_STATUS = 218;
pub const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_READ_FLAG = 1;
pub const szOID_INFOSEC_SuiteAConfidentiality = "2.16.840.1.101.2.1.1.14";
pub const ENCLAVE_SHORT_ID_LENGTH = 16;
pub const ERROR_CRM_PROTOCOL_ALREADY_EXISTS = @as(c_long, 6710);
pub const InterlockedAdd64 = _InlineInterlockedAdd64;
pub const CRYPT_CREATE_IV = 512;
pub const NUMFONTS = 22;
pub const X3_EMPTY_INST_WORD_X = 1;
pub const IMAGE_REL_PPC_ADDR16 = 4;
pub const RPC_C_OPT_TRANS_SEND_BUFFER_SIZE = 5;
pub const AbnormalTermination = _abnormal_termination;
pub const POWERBUTTON_ACTION_VALUE_SLEEP = 2;
pub const FindText = FindTextA;
pub const szOID_ECC_CURVE_WTLS7 = szOID_ECC_CURVE_SECP160R2;
pub const ERROR_STREAM_MINIVERSION_NOT_VALID = @as(c_long, 6809);
pub const MB_DEFBUTTON2 = @as(c_long, 256);
pub const COM_RIGHTS_RESERVED1 = 32;
pub const ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET = @as(c_long, 6836);
pub const AF_PUP = 4;
pub const DMICMMETHOD_NONE = 1;
pub const WINSTA_EXITWINDOWS = @as(c_long, 64);
pub const ERROR_MRM_INVALID_RESOURCE_IDENTIFIER = @as(c_long, 15120);
pub const CERT_RDN_ENABLE_UTF8_UNICODE_FLAG = 536870912;
pub const UIS_INITIALIZE = 3;
pub const SYSTEM_ACCESS_FILTER_VALID_MASK = 16777215;
pub const TabbedTextOut = TabbedTextOutA;
pub const X509_CERT_TO_BE_SIGNED = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 2) else LPCSTR(2);
pub const VTBIT_R8 = 1 << VT_R8;
pub const IMAGE_DOS_SIGNATURE = 23117;
pub const ERROR_IPSEC_MM_AUTH_EXISTS = @as(c_long, 13010);
pub const __RPCNDR_H_VERSION__ = 500;
pub const CERT_CHAIN_POLICY_TRUST_TESTROOT_FLAG = 16384;
pub const RSA1024BIT_KEY = 67108864;
pub const szOID_CERTIFICATE_TEMPLATE = "1.3.6.1.4.1.311.21.7";
pub const RPC_C_HTTP_AUTHN_SCHEME_PASSPORT = 4;
pub const ERROR_INVALID_STARTING_CODESEG = @as(c_long, 188);
pub const MF_CHECKED = @as(c_long, 8);
pub const SPI_SETMENUANIMATION = 4099;
pub const SystemParametersInfo = SystemParametersInfoA;
pub const EVENT_SYSTEM_DRAGDROPSTART = 14;
pub const KLF_RESET = 1073741824;
pub const MMIO_CREATELIST = 64;
pub const DRIVE_RAMDISK = 6;
pub const CERT_CHAIN_POLICY_SSL_F12_WARNING_LEVEL = 1;
pub const NCRYPT_PCP_IDENTITY_KEY = 8;
pub const ERROR_DATABASE_DOES_NOT_EXIST = @as(c_long, 1065);
pub const PRINTER_ATTRIBUTE_FRIENDLY_NAME = 1048576;
pub const CFSTR_MIME_NULL = NULL;
pub const INPUTLANGCHANGE_BACKWARD = 4;
pub const CMSG_CTRL_KEY_TRANS_DECRYPT = 16;
pub const TAPE_DRIVE_LOAD_UNLD_IMMED = 2147483680;
pub const szOID_DEVICE_SERIAL_NUMBER = "2.5.4.5";
pub const ERROR_CLUSTER_NODE_DRAIN_IN_PROGRESS = @as(c_long, 5962);
pub const FindAtom = FindAtomA;
pub const COLOR_WINDOWFRAME = 6;
pub const DM_INTERLACED = 2;
pub const CERT_CHAIN_EXCLUSIVE_ENABLE_CA_FLAG = 1;
pub const RPC_S_NO_PROTSEQS_REGISTERED = @as(c_long, 1714);
pub const ES_NOHIDESEL = @as(c_long, 256);
pub const PAN_LETT_OBLIQUE_ROUNDED = 13;
pub const CMSG_OID_IMPORT_KEY_AGREE_FUNC = "CryptMsgDllImportKeyAgree";
pub const ABS_AUTOHIDE = 1;
pub const XSTATE_MPX_BNDCSR = 4;
pub const LOCALE_SABBREVMONTHNAME3 = 70;
pub const SECURITY_DESCRIPTOR_MIN_LENGTH = if (@typeId(@typeOf(SECURITY_DESCRIPTOR)) == @import("builtin").TypeId.Pointer) @ptrCast(sizeof, SECURITY_DESCRIPTOR) else if (@typeId(@typeOf(SECURITY_DESCRIPTOR)) == @import("builtin").TypeId.Int) @intToPtr(sizeof, SECURITY_DESCRIPTOR) else sizeof(SECURITY_DESCRIPTOR);
pub const LPOINETBINDINFO = LPIINTERNETBINDINFO;
pub const ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE = @as(c_long, 14045);
pub const STARTF_USESIZE = 2;
pub const LOCALE_SDAYNAME3 = 44;
pub const AddPrintProcessor = AddPrintProcessorA;
pub const PIDSI_THUMBNAIL = @as(c_long, 17);
pub const STG_TOEND = @as(c_long, 4294967295);
pub const CBS_HASSTRINGS = @as(c_long, 512);
pub const LOCALE_SPARENT = 109;
pub const _DEBUG = 1;
pub const COPY_FILE_COPY_SYMLINK = 2048;
pub const REGDB_E_FIRST = @as(c_long, 2147746128);
pub const R2_LAST = 16;
pub const SUBLANG_KANNADA_INDIA = 1;
pub const DMPAPER_ENV_C3 = 29;
pub const VFT2_DRV_COMM = @as(c_long, 10);
pub const ERROR_IPSEC_IKE_INVALID_FILTER = @as(c_long, 13858);
pub const ImmUnregisterWord = ImmUnregisterWordA;
pub const ERROR_CANT_ENABLE_DENY_ONLY = @as(c_long, 629);
pub const EVENT_OBJECT_TEXTEDIT_CONVERSIONTARGETCHANGED = 32816;
pub const COPY_FILE_NO_BUFFERING = 4096;
pub const AnsiLowerBuff = CharLowerBuffA;
pub const FILE_READ_EA = 8;
pub const ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ = @as(c_long, 8560);
pub const CERT_STORE_PROV_FREE_FIND_CRL_FUNC = 18;
pub const DNS_ERROR_ZONE_CREATION_FAILED = @as(c_long, 9608);
pub const SUBLANG_SCOTTISH_GAELIC = 1;
pub const WM_DISPLAYCHANGE = 126;
pub const ERROR_MUI_INVALID_RC_CONFIG = @as(c_long, 15102);
pub const PSINJECT_DOCUMENTPROCESSCOLORS = 10;
pub const ERROR_BAD_DEVICE = @as(c_long, 1200);
pub const KDF_PARTYUINFO = 9;
pub const DNS_ERROR_INVALID_SIGNATURE_VALIDITY_PERIOD = @as(c_long, 9123);
pub const SPI_SETSNAPTODEFBUTTON = 96;
pub const ENABLE_LVB_GRID_WORLDWIDE = 16;
pub const __UINT_LEAST32_FMTo__ = "o";
pub const IDLFLAG_FIN = PARAMFLAG_FIN;
pub const DISPLAYCONFIG_PATH_SOURCE_MODE_IDX_INVALID = 65535;
pub const MNC_IGNORE = 0;
pub const WM_LBUTTONUP = 514;
pub const DEVICEFAMILYDEVICEFORM_STICKPC = 8;
pub const ERROR_CONNECTED_OTHER_PASSWORD = @as(c_long, 2108);
pub const CERT_BIOMETRIC_SIGNATURE_TYPE = 1;
pub const RPC_S_PROTSEQ_NOT_SUPPORTED = @as(c_long, 1703);
pub const DMPAPER_DBL_JAPANESE_POSTCARD = 69;
pub const NCBENUM = 55;
pub const ERROR_IPSEC_IKE_QM_DELAY_DROP = @as(c_long, 13815);
pub const WM_NCLBUTTONDBLCLK = 163;
pub const SHTDN_REASON_MINOR_RECONFIG = 4;
pub const URLACTION_ACTIVEX_MAX = 5119;
pub const ALL_TRANSPORTS = "M\x00\x00\x00";
pub const RIGHT_ALT_PRESSED = 1;
pub const ERROR_CLOUD_FILE_NOT_UNDER_SYNC_ROOT = @as(c_long, 390);
pub const PW_CLIENTONLY = 1;
pub const PRINTER_NOTIFY_FIELD_PRIORITY = 14;
pub const OUT_PS_ONLY_PRECIS = 10;
pub const InitiateSystemShutdown = InitiateSystemShutdownA;
pub const MKF_MOUSEMODE = 2147483648;
pub const METHOD_IN_DIRECT = 1;
pub const WNNC_NET_KWNP = 3932160;
pub const PERF_INVERSE_COUNTER = 16777216;
pub const CTRY_SWITZERLAND = 41;
pub const CRYPT_RECIPIENT = 16;
pub const DTR_CONTROL_DISABLE = 0;
pub const OPLOCK_LEVEL_CACHE_HANDLE = 2;
pub const HTMENU = 5;
pub const SND_SENTRY = @as(c_long, 524288);
pub const DFC_BUTTON = 4;
pub const SM_CYFULLSCREEN = 17;
pub const SOUND_SYSTEM_APPSTART = 12;
pub const VK_OEM_FJ_ROYA = 150;
pub const BATTERY_DISCHARGE_FLAGS_ENABLE = 2147483648;
pub const DCX_INTERSECTRGN = @as(c_long, 128);
pub const XBUTTON2 = 2;
pub const PROCESS_MODE_BACKGROUND_END = 2097152;
pub const __SIZE_FMTu__ = "llu";
pub const ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION = @as(c_long, 5915);
pub const MB_DEFBUTTON3 = @as(c_long, 512);
pub const IMAGE_POLICY_SECTION_NAME = ".tPolicy";
pub const WT_TRANSFER_IMPERSONATION = 256;
pub const EV_TXEMPTY = 4;
pub const NRC_SCLOSED = 10;
pub const CryptEnumProviders = CryptEnumProvidersA;
pub const ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER = @as(c_long, 8615);
pub const R2_NOTXORPEN = 10;
pub const ERROR_INSTALL_FAILED = @as(c_long, 15609);
pub const QS_RAWINPUT = 1024;
pub const PDCAP_D0_SUPPORTED = 1;
pub const szOID_TIMESTAMP_TOKEN = "1.2.840.113549.1.9.16.1.4";
pub const ERROR_CTX_INVALID_WD = @as(c_long, 7049);
pub const PRAGMA_DEPRECATED_DDK = 0;
pub const ERROR_INVALID_LOGON_TYPE = @as(c_long, 1367);
pub const ERROR_LOG_POLICY_NOT_INSTALLED = @as(c_long, 6620);
pub const PROCESS_HEAP_ENTRY_MOVEABLE = 16;
pub const STRETCH_HALFTONE = HALFTONE;
pub const IMEVER_0310 = 196618;
pub const EBUSY = 16;
pub const szOID_ENHANCED_KEY_USAGE = "2.5.29.37";
pub const EnumDisplaySettings = EnumDisplaySettingsA;
pub const HCCE_SERIAL_LOCAL_MACHINE = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(HCERTCHAINENGINE, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(HCERTCHAINENGINE, 2) else HCERTCHAINENGINE(2);
pub const EMR_SETMITERLIMIT = 58;
pub const RpcServerUseProtseqIfEx = RpcServerUseProtseqIfExA;
pub const DSPRINT_PUBLISH = 1;
pub const MAXIMUM_PROCESSORS = MAXIMUM_PROC_PER_GROUP;
pub const ERROR_CTX_CDM_CONNECT = @as(c_long, 7066);
pub const ERROR_REC_NON_EXISTENT = @as(c_long, 4005);
pub const NMPWAIT_USE_DEFAULT_WAIT = 0;
pub const VarIntFromDisp = VarI4FromDisp;
pub const SCARD_T1_EPILOGUE_LENGTH_LRC = 1;
pub const DSS_UNION = 16;
pub const szOID_CA_CERTIFICATE = "2.5.4.37";
pub const EVENT_SYSTEM_CONTEXTHELPEND = 13;
pub const SORT_CHINESE_PRCP = 0;
pub const DC_BRUSH = 18;
pub const JOB_OBJECT_TERMINATE_AT_END_OF_JOB = 0;
pub const ERROR_EXCEPTION_IN_SERVICE = @as(c_long, 1064);
pub const CERT_CHAIN_AUTO_FLUSH_DISABLE_FLAG = 1;
pub const PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_DEFER = if (@typeId(@typeOf(i64 << 36)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), i64 << 36) else if (@typeId(@typeOf(i64 << 36)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), i64 << 36) else @as(c_uint, 0)(i64 << 36);
pub const GetObject = GetObjectA;
pub const FACILITY_USN = 129;
pub const FACILITY_BLUETOOTH_ATT = 101;
pub const szOID_KEYID_RDN = "1.3.6.1.4.1.311.10.7.1";
pub const IMAGE_DEBUG_TYPE_BORLAND = 9;
pub const DMPAPER_PENV_7_ROTATED = 115;
pub const FAST_FAIL_UNHANDLED_LSS_EXCEPTON = 54;
pub const CERT_AUTO_ENROLL_PROP_ID = 21;
pub const EVENTLOG_SEEK_READ = 2;
pub const ARW_UP = @as(c_long, 4);
pub const ENLISTMENT_SUBORDINATE_RIGHTS = 8;
pub const CRYPT_OID_EXPORT_PUBLIC_KEY_INFO_FUNC = "CryptDllExportPublicKeyInfoEx";
pub const MDM_PROTOCOLID_V128 = 2;
pub const ERROR_VOLSNAP_HIBERNATE_READY = @as(c_long, 761);
pub const CERT_VERIFY_REV_SERVER_OCSP_WIRE_ONLY_FLAG = 32;
pub const SHAREVISTRING = SHAREVISTRINGA;
pub const MIIM_CHECKMARKS = 8;
pub const LZERROR_GLOBLOCK = -6;
pub const EMR_PIE = 47;
pub const ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED = @as(c_long, 8557);
pub const PROCESS_LEAP_SECOND_INFO_VALID_FLAGS = PROCESS_LEAP_SECOND_INFO_FLAG_ENABLE_SIXTY_SECOND;
pub const KP_VERIFY_PARAMS = 40;
pub const ERROR_INVALID_INDEX = @as(c_long, 1413);
pub const VK_OEM_CUSEL = 239;
pub const ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER = @as(c_long, 1278);
pub const CERT_SCEP_NONCE_PROP_ID = 113;
pub const ERROR_CLUSTER_INVALID_IPV6_NETWORK = @as(c_long, 5926);
pub const DNS_ERROR_INVALID_NAME_CHAR = @as(c_long, 9560);
pub const ERROR_TOO_MANY_NAMES = @as(c_long, 68);
pub const NUMPRS_STD = 8191;
pub const GetVolumePathNamesForVolumeName = GetVolumePathNamesForVolumeNameA;
pub const ODS_NOACCEL = 256;
pub const PF_RDTSCP_INSTRUCTION_AVAILABLE = 32;
pub const GetCompressedFileSize = GetCompressedFileSizeA;
pub const ERROR_SHUTDOWN_USERS_LOGGED_ON = @as(c_long, 1191);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_ERROR = -2;
pub const PRODUCT_EDUCATION = 121;
pub const SUBLANG_GUJARATI_INDIA = 1;
pub const MIXERLINE_TARGETTYPE_WAVEIN = 2;
pub const szOID_PKCS_12_KEY_PROVIDER_NAME_ATTR = "1.3.6.1.4.1.311.17.1";
pub const szOID_DSALG_SIGN = "2.5.8.3";
pub const COLORMGMTDLGORD = 1551;
pub const DFC_POPUPMENU = 5;
pub const STORAGE_ATTRIBUTE_PERF_SIZE_INDEPENDENT = 32;
pub const MAXULONG_PTR = ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(ULONG_PTR, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(ULONG_PTR, 0) else ULONG_PTR(0);
pub const RPC_C_AUTHZ_DCE = 2;
pub const BCRYPT_MULTI_FLAG = 64;
pub const SHTDN_REASON_MAJOR_NONE = 0;
pub const WM_DRAWITEM = 43;
pub const COLOR_BTNSHADOW = 16;
pub const PRINTER_ENUM_ICON3 = 262144;
pub const ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS = @as(c_long, 13902);
pub const CRYPTNET_URL_CACHE_RESPONSE_VALIDATED = 32768;
pub const BS_RIGHTBUTTON = BS_LEFTTEXT;
pub const SPI_SETCURSORS = 87;
pub const IMAGE_DEBUG_TYPE_RESERVED10 = 10;
pub const NOTIFYICON_VERSION_4 = 4;
pub const ERROR_DS_CANT_ON_NON_LEAF = @as(c_long, 8213);
pub const SDC_TOPOLOGY_EXTEND = 4;
pub const MIDICAPS_LRVOLUME = 2;
pub const PPCAPS_DOWN_THEN_LEFT = 1 << 3;
pub const RDW_ERASENOW = 512;
pub const MUTZ_ACCEPT_WILDCARD_SCHEME = 128;
pub const ERROR_DS_ATT_ALREADY_EXISTS = @as(c_long, 8318);
pub const URLACTION_SCRIPT_XSSFILTER = 5129;
pub const ERROR_WOF_FILE_RESOURCE_TABLE_CORRUPT = @as(c_long, 4448);
pub const URLACTION_INFODELIVERY_MAX = 7679;
pub const GetTimeFormat = GetTimeFormatA;
pub const PERF_NUMBER_DEC_1000 = 131072;
pub const SM_CYSIZE = 31;
pub const STM_MSGMAX = 372;
pub const ENCLAVE_TYPE_VBS_BASIC = 17;
pub const RESTORE_CTM = 4100;
pub const ERROR_IPSEC_MM_FILTER_PENDING_DELETION = @as(c_long, 13018);
pub const META_RESTOREDC = 295;
pub const MIDICAPS_CACHE = 4;
pub const MCI_OVLY_PUT_DESTINATION = @as(c_long, 262144);
pub const PF_ALPHA_BYTE_INSTRUCTIONS = 5;
pub const LOCALE_IOPTIONALCALENDAR = 4107;
pub const PP_SGC_INFO = 37;
pub const szOID_CERT_STRONG_SIGN_OS_CURRENT = szOID_CERT_STRONG_SIGN_OS_1;
pub const CONSOLE_TEXTMODE_BUFFER = 1;
pub const DM_PELSHEIGHT = @as(c_long, 1048576);
pub const ERROR_DS_GENERIC_ERROR = @as(c_long, 8341);
pub const ERROR_EVT_FILTER_UNEXPECTEDTOKEN = @as(c_long, 15021);
pub const ERROR_LOG_POLICY_INVALID = @as(c_long, 6621);
pub const MCI_VD_GETDEVCAPS_CAV = @as(c_long, 131072);
pub const POWER_ACTION_USER_NOTIFY = 16;
pub const ERROR_PREDEFINED_HANDLE = @as(c_long, 714);
pub const XBUTTON1 = 1;
pub const PSH_MODELESS = 1024;
pub const szOID_ECC_CURVE_WTLS9 = "2.23.43.1.4.9";
pub const ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT = @as(c_long, 308);
pub const DMTT_DOWNLOAD_OUTLINE = 4;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE = 2;
pub const MENU_EVENT = 8;
pub const szOID_SYNC_ROOT_CTL_EXT = "1.3.6.1.4.1.311.10.3.50";
pub const NCRYPTBUFFER_PKCS_ALG_OID = 41;
pub const ERROR_DS_INVALID_SCRIPT = @as(c_long, 8600);
pub const SZDDESYS_ITEM_HELP = "Help";
pub const CRYPT_ALL_PROVIDERS = 2;
pub const ERROR_IPSEC_IKE_FAILSSPINIT = @as(c_long, 13853);
pub const PROV_SSL = 6;
pub const SB_PIXEL_ALPHA = 2;
pub const ERROR_SECTOR_NOT_FOUND = @as(c_long, 27);
pub const szOID_ECC_CURVE_SECP224K1 = "1.3.132.0.32";
pub const VP_FLAGS_POSITION = 32;
pub const FAST_FAIL_INVALID_LONGJUMP_TARGET = 38;
pub const PAN_CONTRAST_MEDIUM = 6;
pub const ARW_RIGHT = @as(c_long, 0);
pub const PP_KEYSET_SEC_DESCR = 8;
pub const ERROR_USER_PROFILE_LOAD = @as(c_long, 500);
pub const __LDBL_MANT_DIG__ = 53;
pub const OF_READ = 0;
pub const DT_MODIFYSTRING = 65536;
pub const WM_CHANGEUISTATE = 295;
pub const DRV_MCI_FIRST = DRV_RESERVED;
pub const lst8 = 1127;
pub const RPC_S_SEC_PKG_ERROR = @as(c_long, 1825);
pub const ST_CONNECTED = 1;
pub const szOID_OIWSEC_desOFB = "1.3.14.3.2.8";
pub const EVENT_OEM_DEFINED_END = 511;
pub const PDEVICESIZE = 26;
pub const SUBLANG_KICHE_GUATEMALA = 1;
pub const CREATE_PROCESS_DEBUG_EVENT = 3;
pub const EnumWindowStations = EnumWindowStationsA;
pub const __SSE__ = 1;
pub const IMAGE_ENCLAVE_SHORT_ID_LENGTH = ENCLAVE_SHORT_ID_LENGTH;
pub const MUI_IMMUTABLE_LOOKUP = 16;
pub const CACHE_E_LAST = @as(c_long, 2147746175);
pub const ERROR_DS_CANT_MOVE_RESOURCE_GROUP = @as(c_long, 8499);
pub const IMAGE_ENCLAVE_IMPORT_MATCH_UNIQUE_ID = 1;
pub const TXFS_START_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT = 16;
pub const ERROR_EC_NO_ACTIVE_CHANNEL = @as(c_long, 15085);
pub const RPC_C_AUTHN_LEVEL_PKT_PRIVACY = 6;
pub const LOCALE_SABBREVMONTHNAME1 = 68;
pub const CRYPT_FLAG_PCT1 = 1;
pub const STATE_SYSTEM_MOVEABLE = 262144;
pub const LANG_DUTCH = 19;
pub const PSIDENT_GDICENTRIC = 0;
pub const CERT_NAME_STR_REVERSE_FLAG = 33554432;
pub const MUTZ_DONT_UNESCAPE = 2048;
pub const LOCALE_SDAYNAME1 = 42;
pub const URLACTION_ACTIVEX_MIN = 4608;
pub const GCS_DELTASTART = 256;
pub const MUI_FILETYPE_LANGUAGE_NEUTRAL_MAIN = 2;
pub const SHGFI_PIDL = 8;
pub const ERROR_CLUSTER_NODE_ALREADY_UP = @as(c_long, 5061);
pub const SERIAL_LSRMST_LSR_NODATA = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(BYTE, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(BYTE, 2) else BYTE(2);
pub const PROCESSOR_PERF_ENERGY_PREFERENCE = 0;
pub const ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST = @as(c_long, 8635);
pub const PRINTER_ENUM_HIDE = 16777216;
pub const ERROR_INVALID_PRINTER_NAME = @as(c_long, 1801);
pub const ERROR_CLUSTER_PARTIAL_SEND = @as(c_long, 5914);
pub const SPCLPASSTHROUGH2 = 4568;
pub const LOCALE_SSHORTDATE = 31;
pub const _Releases_nonreentrant_lock_ = lock;
pub const WSAESTALE = @as(c_long, 10070);
pub const PAN_WEIGHT_LIGHT = 3;
pub const CTRY_OMAN = 968;
pub const ERROR_CSV_VOLUME_NOT_LOCAL = @as(c_long, 5951);
pub const sz_CERT_STORE_PROV_PKCS7 = "PKCS7";
pub const URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY = 4611;
pub const CS_IME = 65536;
pub const PAN_CONTRAST_INDEX = 4;
pub const PRINTER_STATUS_PAPER_JAM = 8;
pub const CRYPT_OBJECT_LOCATOR_LAST_RESERVED_NAME_TYPE = 32;
pub const GetBinaryType = GetBinaryTypeA;
pub const RPC_ENDPOINT_TEMPLATE = RPC_ENDPOINT_TEMPLATEA;
pub const PKCS12_PBKDF2_ID_HMAC_SHA1 = "1.2.840.113549.2.7";
pub const IMAGE_REL_ALPHA_SECRELHI = 18;
pub const EMR_SETICMPROFILEA = 112;
pub const MFS_CHECKED = MF_CHECKED;
pub const SECURITY_MANDATORY_LOW_RID = @as(c_long, 4096);
pub const ERROR_SXS_XML_E_RESERVEDNAMESPACE = @as(c_long, 14066);
pub const ERROR_WAIT_1 = @as(c_long, 731);
pub const ALG_CLASS_DATA_ENCRYPT = 3 << 13;
pub const GCW_ATOM = -32;
pub const DFCS_CAPTIONRESTORE = 3;
pub const ERROR_DEVICE_REQUIRES_CLEANING = @as(c_long, 1165);
pub const ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT = @as(c_long, 1808);
pub const GCLP_HICONSM = -34;
pub const CDN_FILEOK = if (@typeId(@typeOf(-5)) == @import("builtin").TypeId.Pointer) @ptrCast(CDN_FIRST, -5) else if (@typeId(@typeOf(-5)) == @import("builtin").TypeId.Int) @intToPtr(CDN_FIRST, -5) else CDN_FIRST(-5);
pub const CERT_TRUST_HAS_KEY_MATCH_ISSUER = 2;
pub const ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT = @as(c_long, 8544);
pub const PRINTER_ENUM_ICON2 = 131072;
pub const META_SETWINDOWEXT = 524;
pub const LR_LOADFROMFILE = 16;
pub const HCF_LOGONDESKTOP = 256;
pub const APPMODEL_ERROR_DYNAMIC_PROPERTY_READ_FAILED = @as(c_long, 15704);
pub const CERT_CHAIN_DISABLE_PASS1_QUALITY_FILTERING = 64;
pub const CC_SHOWHELP = 8;
pub const PAN_WEIGHT_THIN = 4;
pub const CFSTR_MIME_WAV = if (@typeId(@typeOf("audio/wav")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "audio/wav") else if (@typeId(@typeOf("audio/wav")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "audio/wav") else TEXT("audio/wav");
pub const CBN_DROPDOWN = 7;
pub const IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER = 12;
pub const IMAGE_DIRECTORY_ENTRY_ARCHITECTURE = 7;
pub const SERKF_INDICATOR = 4;
pub const LANG_XHOSA = 52;
pub const __UINT_LEAST32_FMTX__ = "X";
pub const IMAGE_REL_EBC_ABSOLUTE = 0;
pub const __inout_ecount_nz = size;
pub const ALG_SID_SCHANNEL_ENC_KEY = 7;
pub const URLACTION_SHELL_MOVE_OR_COPY = 6146;
pub const ERROR_SMR_GARBAGE_COLLECTION_REQUIRED = @as(c_long, 4445);
pub const DATE_AUTOLAYOUT = 64;
pub const C2_EUROPETERMINATOR = 5;
pub const ERROR_DS_DRA_ACCESS_DENIED = @as(c_long, 8453);
pub const INTERFACE = IPrintDialogCallback;
pub const __drv_typeBitset = 2;
pub const LANG_SWEDISH = 29;
pub const MCI_VD_SPIN_DOWN = @as(c_long, 131072);
pub const FILE_FLAG_FIRST_PIPE_INSTANCE = 524288;
pub const AC_LINE_ONLINE = 1;
pub const PLAINTEXTKEYBLOB = 8;
pub const SB_LINEUP = 0;
pub const IMAGE_GUARD_RF_ENABLE = 262144;
pub const ERROR_SECRET_TOO_LONG = @as(c_long, 1382);
pub const ERROR_WMI_ALREADY_DISABLED = @as(c_long, 4212);
pub const PSBTN_OK = 3;
pub const BCRYPT_USE_SYSTEM_PREFERRED_RNG = 2;
pub const IMAGE_REL_M32R_SECTION = 12;
pub const ERROR_DBG_CONTROL_BREAK = @as(c_long, 696);
pub const DNS_ERROR_INVAILD_VIRTUALIZATION_INSTANCE_NAME = @as(c_long, 9924);
pub const SS_USERITEM = @as(c_long, 10);
pub const MB_DEFBUTTON1 = @as(c_long, 0);
pub const COM_RIGHTS_RESERVED2 = 64;
pub const ALG_SID_SAFERSK64 = 7;
pub const InterlockedDecrementNoFence64 = _InterlockedDecrement64;
pub const OUT_TT_ONLY_PRECIS = 7;
pub const szOID_DH_SINGLE_PASS_STDDH_SHA256_KDF = "1.3.132.1.11.1";
pub const SPI_SETHANDHELD = 78;
pub const ERROR_NO_WILDCARD_CHARACTERS = @as(c_long, 1417);
pub const ERROR_ROLLBACK_TIMER_EXPIRED = @as(c_long, 6829);
pub const PBT_APMOEMEVENT = 11;
pub const DC_GRADIENT = 32;
pub const ERROR_EA_TABLE_FULL = @as(c_long, 277);
pub const STDOLE2_MINORVERNUM = 0;
pub const MIXERCONTROL_CT_SC_SWITCH_BUTTON = @as(c_long, 16777216);
pub const SPI_SETDESKWALLPAPER = 20;
pub const szOID_CRL_NUMBER = "2.5.29.20";
pub const lst9 = 1128;
pub const NIIF_RESPECT_QUIET_TIME = 128;
pub const DEVICEFAMILYINFOENUM_SERVER = 9;
pub const FACILITY_ONLINE_ID = 134;
pub const IMAGE_FILE_MACHINE_EBC = 3772;
pub const WH_GETMESSAGE = 3;
pub const SUBLANG_DEFAULT = 1;
pub const KEY_ENUMERATE_SUB_KEYS = 8;
pub const EMR_MASKBLT = 78;
pub const PRODUCT_MULTIPOINT_PREMIUM_SERVER = 77;
pub const RPC_S_INVALID_NAF_ID = @as(c_long, 1763);
pub const ERROR_NETWORK_ACCESS_DENIED = @as(c_long, 65);
pub const WM_MDIMAXIMIZE = 549;
pub const LOCALE_SABBREVMONTHNAME6 = 73;
pub const RPC_X_ENUM_VALUE_TOO_LARGE = RPC_X_ENUM_VALUE_OUT_OF_RANGE;
pub const ERROR_SXS_SETTING_NOT_REGISTERED = @as(c_long, 14106);
pub const PURGE_TXCLEAR = 4;
pub const SM_CYFIXEDFRAME = SM_CYDLGFRAME;
pub const ERROR_DS_CANT_RETRIEVE_DN = @as(c_long, 8405);
pub const COPY_FILE_OPEN_SOURCE_FOR_WRITE = 4;
pub const LOCALE_SDAYNAME6 = 47;
pub const VK_ATTN = 246;
pub const ERROR_TXF_METADATA_ALREADY_PRESENT = @as(c_long, 6835);
pub const WGL_SWAP_OVERLAY8 = 256;
pub const WM_POINTERACTIVATE = 587;
pub const ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP = @as(c_long, 5896);
pub const TPM_HORNEGANIMATION = @as(c_long, 2048);
pub const SESSION_ABORTED = 6;
pub const CRYPTPROTECT_UI_FORBIDDEN = 1;
pub const MS_DEF_DSS_PROV_A = "Microsoft Base DSS Cryptographic Provider";
pub const ELEMENT_STATUS_PVOLTAG = 268435456;
pub const DMPAPER_ENV_C6 = 31;
pub const ESB_DISABLE_LEFT = 1;
pub const CRL_REASON_PRIVILEGE_WITHDRAWN = 9;
pub const szOID_RSA_MD2 = "1.2.840.113549.2.2";
pub const FADF_EMBEDDED = 4;
pub const FRS_ERR_PARENT_AUTHENTICATION = @as(c_long, 8010);
pub const SetForm = SetFormA;
pub const ERROR_DS_UNDELETE_SAM_VALIDATION_FAILED = @as(c_long, 8645);
pub const FILE_DEVICE_PHYSICAL_NETCARD = 23;
pub const CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_WEAK_FLAG = 134217728;
pub const EMR_POLYPOLYGON = 8;
pub const UNIQUE_NAME = 0;
pub const AF_ECMA = 8;
pub const PRODUCT_ENTERPRISE_E = 70;
pub const CMSG_CMS_ENCAPSULATED_CTL_FLAG = 32768;
pub const DISPLAY_DEVICE_RDPUDD = 16777216;
pub const COLORMATCHTOTARGET_EMBEDED = 1;
pub const CRYPT_FORMAT_COMMA = 4096;
pub const ERROR_FILE_ENCRYPTED = @as(c_long, 6002);
pub const NTDDI_LONGHORN = NTDDI_VISTA;
pub const DT_CENTER = 1;
pub const ERROR_WAIT_2 = @as(c_long, 732);
pub const MUTZ_NOSAVEDFILECHECK = 1;
pub const EVENT_S_FIRST = @as(c_long, 262656);
pub const RI_MOUSE_WHEEL = 1024;
pub const BS_BITMAP = @as(c_long, 128);
pub const FILE_DEVICE_UCMTCPCI = 88;
pub const ICMENUMPROC = ICMENUMPROCA;
pub const CERT_EXTENDED_ERROR_INFO_PROP_ID = 30;
pub const MF_INSERT = @as(c_long, 0);
pub const EnumPorts = EnumPortsA;
pub const EV_DSR = 16;
pub const PRINTER_ENUM_ICON1 = 65536;
pub const EN_ALIGN_RTL_EC = 1793;
pub const ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED = @as(c_long, 3019);
pub const WM_DWMCOLORIZATIONCOLORCHANGED = 800;
pub const PRODUCT_SB_SOLUTION_SERVER_EM = 54;
pub const FILE_ATTRIBUTE_SPARSE_FILE = 512;
pub const MEM_TOP_DOWN = 1048576;
pub const NCRYPT_UI_FORCE_HIGH_PROTECTION_FLAG = 2;
pub const SECURITY_ENTERPRISE_READONLY_CONTROLLERS_RID = @as(c_long, 22);
pub const FACILITY_SYNCENGINE = 2050;
pub const CRYPT_REGISTER_LAST_INDEX = 4294967295;
pub const ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE = @as(c_long, 800);
pub const PIDMSI_COPYRIGHT = @as(c_long, 11);
pub const ALG_SID_RSA_MSATWORK = 2;
pub const RPC_S_COOKIE_AUTH_FAILED = @as(c_long, 1833);
pub const VerInstallFile = VerInstallFileA;
pub const MUI_MERGE_USER_FALLBACK = 32;
pub const LEFT_CTRL_PRESSED = 8;
pub const WM_POWERBROADCAST = 536;
pub const CERT_RDN_OCTET_STRING = 2;
pub const szOID_CMC_REG_INFO = "1.3.6.1.5.5.7.7.18";
pub const CMSG_VERIFY_SIGNER_CERT = 2;
pub const APPIDREGFLAGS_RESERVED9 = 16384;
pub const szOID_CERT_STRONG_KEY_OS_PREFIX = "1.3.6.1.4.1.311.72.2.";
pub const PAGE_ENCLAVE_THREAD_CONTROL = 2147483648;
pub const ERROR_DS_DRA_NO_REPLICA = @as(c_long, 8452);
pub const LB_SELITEMRANGE = 411;
pub const DMPAPER_P16K = 93;
pub const DISC_NO_FORCE = 64;
pub const FLOODFILLBORDER = 0;
pub const LLONG_MAX = __LONG_LONG_MAX__;
pub const DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER = @as(c_long, 9562);
pub const CERT_CHAIN_POLICY_IGNORE_NOT_SUPPORTED_CRITICAL_EXT_FLAG = 8192;
pub const FORMAT_MESSAGE_FROM_HMODULE = 2048;
pub const CTRL_C_EVENT = 0;
pub const ERROR_RXACT_INVALID_STATE = @as(c_long, 1369);
pub const CF_SELECTSCRIPT = @as(c_long, 4194304);
pub const FLAG_USN_TRACK_MODIFIED_RANGES_ENABLE = 1;
pub const RPC_S_PROTSEQ_NOT_FOUND = @as(c_long, 1744);
pub const lstrcat = lstrcatA;
pub const ERROR_INVALID_ID_AUTHORITY = @as(c_long, 1343);
pub const ERROR_DS_DRA_MISSING_PARENT = @as(c_long, 8460);
pub const IMAGE_REL_BASED_THUMB_MOV32 = 7;
pub const VFT2_DRV_NETWORK = @as(c_long, 6);
pub const GESTUREVISUALIZATION_PRESSANDTAP = 4;
pub const SPI_GETKEYBOARDCUES = 4106;
pub const CRYPT_WIRE_ONLY_RETRIEVAL = 4;
pub const SMART_EXTENDED_SELFTEST_CAPTIVE = 130;
pub const CERT_NO_EXPIRE_NOTIFICATION_PROP_ID = 97;
pub const BEGIN_PATH = 4096;
pub const ERROR_MRM_INVALID_FILE_TYPE = @as(c_long, 15112);
pub const _TRUNCATE = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(size_t, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(size_t, -1) else size_t(-1);
pub const GETTECHNOLOGY = 20;
pub const NIIF_NOSOUND = 16;
pub const pshHelp = psh15;
pub const VS_USER_DEFINED = 100;
pub const RpcStringBindingCompose = RpcStringBindingComposeA;
pub const CRYPT_ASN_ENCODING = 1;
pub const VTBIT_R4 = 1 << VT_R4;
pub const URLACTION_HTML_ALLOW_INJECTED_DYNAMIC_HTML = 5643;
pub const BCRYPT_AES_ECB_ALG_HANDLE = if (@typeId(@typeOf(433)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 433) else if (@typeId(@typeOf(433)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 433) else BCRYPT_ALG_HANDLE(433);
pub const STORAGE_COMPONENT_ROLE_CACHE = 1;
pub const RPC_C_AUTHN_MQ = 100;
pub const CP_RECTANGLE = 1;
pub const MS_DEF_DH_SCHANNEL_PROV_A = "Microsoft DH SChannel Cryptographic Provider";
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE = 4;
pub const DNS_ERROR_NO_MEMORY = ERROR_OUTOFMEMORY;
pub const NCRYPT_ECDSA_P521_ALGORITHM = BCRYPT_ECDSA_P521_ALGORITHM;
pub const IMAGE_REL_SH3_GPREL4_LONG = 17;
pub const CRL_REASON_AA_COMPROMISE = 10;
pub const HWND_NOTOPMOST = if (@typeId(@typeOf(-2)) == @import("builtin").TypeId.Pointer) @ptrCast(HWND, -2) else if (@typeId(@typeOf(-2)) == @import("builtin").TypeId.Int) @intToPtr(HWND, -2) else HWND(-2);
pub const szOID_NIST_AES128_CBC = "2.16.840.1.101.3.4.1.2";
pub const MCI_RECORD_INSERT = @as(c_long, 256);
pub const CERT_DSS_S_LEN = 20;
pub const ERROR_DS_MISSING_FSMO_SETTINGS = @as(c_long, 8434);
pub const COLOR_3DHILIGHT = COLOR_BTNHIGHLIGHT;
pub const PT_LINETO = 2;
pub const ENABLEPAIRKERNING = 769;
pub const APPCOMMAND_MEDIA_RECORD = 48;
pub const EMR_ARCTO = 55;
pub const JOYERR_BASE = 160;
pub const VK_CANCEL = 3;
pub const PARTITION_FAT32 = 11;
pub const __STDC_VERSION__ = @as(c_long, 201112);
pub const DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION = @as(c_long, 9563);
pub const ERROR_APPEXEC_UNKNOWN_USER = @as(c_long, 3067);
pub const REG_OPEN_READ_ONLY = @as(c_long, 8192);
pub const JOB_STATUS_RENDERING_LOCALLY = 16384;
pub const URLACTION_ALLOW_AUDIO_VIDEO = 9985;
pub const DMPAPER_P32K = 94;
pub const LOCALE_SABBREVMONTHNAME7 = 74;
pub const MUI_USE_INSTALLED_LANGUAGES = 32;
pub const ALG_SID_DSS_PKCS = 1;
pub const szOID_POLICY_MAPPINGS = "2.5.29.33";
pub const X509_NDR_ENCODING = 2;
pub const MIDIPROP_GET = @as(c_long, 1073741824);
pub const REMOTE_PROTOCOL_INFO_FLAG_LOOPBACK = 1;
pub const GDIPLUS_TS_RECORD = 4123;
pub const CERT_ALT_NAME_IP_ADDRESS = 8;
pub const LOCALE_SDAYNAME7 = 48;
pub const ABOVE_NORMAL_PRIORITY_CLASS = 32768;
pub const ERROR_XML_ENCODING_MISMATCH = @as(c_long, 14100);
pub const VER_PRODUCT_TYPE = 128;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16 = 1;
pub const SPI_GETMENURECT = 162;
pub const WGL_SWAP_OVERLAY9 = 512;
pub const WM_CANCELMODE = 31;
pub const SPI_GETMINIMIZEDMETRICS = 43;
pub const szOID_SUBJECT_DIR_ATTRS = "2.5.29.9";
pub const STREAM_LAYOUT_ENTRY_IMMOVABLE = 1;
pub const CTRY_MACAU = 853;
pub const SECURITY_WINDOWSMOBILE_ID_BASE_RID = @as(c_long, 112);
pub const FILE_TYPE_UNKNOWN = 0;
pub const __FLT_EVAL_METHOD__ = 0;
pub const __SSE_MATH__ = 1;
pub const __UINT_FAST8_FMTo__ = "hho";
pub const ENABLE_LINE_INPUT = 2;
pub const WNetGetResourceInformation = WNetGetResourceInformationA;
pub const ERROR_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED = @as(c_long, 4572);
pub const ENHMETA_STOCK_OBJECT = 2147483648;
pub const STGM_SHARE_DENY_NONE = @as(c_long, 64);
pub const TOUCH_FEEDBACK_NONE = 3;
pub const LPD_SUPPORT_OPENGL = 32;
pub const FILE_DEVICE_NETWORK = 18;
pub const VFF_FILEINUSE = 2;
pub const DCOMSCM_ACTIVATION_DISALLOW_UNSECURE_CALL = 2;
pub const URLACTION_JAVA_PERMISSIONS = 7168;
pub const S_SEROFM = -2;
pub const ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED = @as(c_long, 763);
pub const MEDIA_WRITE_PROTECTED = 256;
pub const CERT_UNICODE_VALUE_ERR_INDEX_SHIFT = 0;
pub const ERROR_MEDIA_CHECK = @as(c_long, 679);
pub const URLACTION_JAVA_CURR_MAX = 7168;
pub const DISPLAYCONFIG_TARGET_FORCED_AVAILABILITY_BOOT = 4;
pub const ERROR_WAIT_3 = @as(c_long, 733);
pub const POWER_ACTION_PSEUDO_TRANSITION = 134217728;
pub const LOGON32_LOGON_NETWORK = 3;
pub const PERF_QUERY_GLOBAL = if (@typeId(@typeOf(2147483649)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG, 2147483649) else if (@typeId(@typeOf(2147483649)) == @import("builtin").TypeId.Int) @intToPtr(LONG, 2147483649) else LONG(2147483649);
pub const CharToOemBuff = CharToOemBuffA;
pub const URLACTION_INFODELIVERY_NO_CHANNEL_LOGGING = 7430;
pub const SET_ARC_DIRECTION = 4102;
pub const ERROR_SOME_NOT_MAPPED = @as(c_long, 1301);
pub const CTRY_TATARSTAN = 7;
pub const IMAGE_SYM_CLASS_CLR_TOKEN = 107;
pub const ERROR_DS_OBJ_GUID_EXISTS = @as(c_long, 8361);
pub const _MAX_PATH = 260;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_TXF_ATTRIBUTE = 512;
pub const PS_COSMETIC = 0;
pub const STORE_ERROR_UNLICENSED = @as(c_long, 15861);
pub const HELP_TCARD_OTHER_CALLER = 17;
pub const PKCS12_ONLY_CERTIFICATES = 1024;
pub const KP_Y = 15;
pub const CERT_STORE_CTRL_RESYNC = 1;
pub const PIPE_TYPE_BYTE = 0;
pub const SECURITY_USERMANAGER_ID_BASE_RID = @as(c_long, 93);
pub const DROPEFFECT_LINK = 4;
pub const FILE_MAP_RESERVE = 2147483648;
pub const PERF_DATA_REVISION = 1;
pub const MININT64 = if (@typeId(@typeOf(~MAXINT64)) == @import("builtin").TypeId.Pointer) @ptrCast(INT64, ~MAXINT64) else if (@typeId(@typeOf(~MAXINT64)) == @import("builtin").TypeId.Int) @intToPtr(INT64, ~MAXINT64) else INT64(~MAXINT64);
pub const JOB_OBJECT_LIMIT_BREAKAWAY_OK = 2048;
pub const SSL_KEY_PIN_ERROR_TEXT_LENGTH = 512;
pub const URLACTION_SHELL_ALLOW_CROSS_SITE_SHARE = 6161;
pub const PHYSICALWIDTH = 110;
pub const APPIDREGFLAGS_RESERVED8 = 8192;
pub const SCARD_ABSENT = 1;
pub const PAN_WEIGHT_VERY_LIGHT = 2;
pub const __UINT_FAST32_FMTx__ = "x";
pub const MINLONG32 = if (@typeId(@typeOf(~MAXLONG32)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG32, ~MAXLONG32) else if (@typeId(@typeOf(~MAXLONG32)) == @import("builtin").TypeId.Int) @intToPtr(LONG32, ~MAXLONG32) else LONG32(~MAXLONG32);
pub const GetCurrencyFormat = GetCurrencyFormatA;
pub const CALLBACK = __stdcall;
pub const ERROR_DS_OUT_OF_VERSION_STORE = @as(c_long, 8573);
pub const PCF_INTTIMEOUTS = if (@typeId(@typeOf(128)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 128) else if (@typeId(@typeOf(128)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 128) else DWORD(128);
pub const SPI_GETFOREGROUNDFLASHCOUNT = 8196;
pub const EM_SETLIMITTEXT = EM_LIMITTEXT;
pub const ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION = 1;
pub const DMPAPER_ENV_INVITE = 47;
pub const WS_EX_RIGHT = @as(c_long, 4096);
pub const PRF_OWNED = @as(c_long, 32);
pub const PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_NO_REMOTE_DEFER = if (@typeId(@typeOf(i64 << 52)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), i64 << 52) else if (@typeId(@typeOf(i64 << 52)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), i64 << 52) else @as(c_uint, 0)(i64 << 52);
pub const META_RESIZEPALETTE = 313;
pub const OFN_ALLOWMULTISELECT = 512;
pub const DEVICEFAMILYINFOENUM_MOBILE = 4;
pub const APPCOMMAND_CORRECTION_LIST = 45;
pub const FatalAppExit = FatalAppExitA;
pub const ERROR_BAD_CONFIGURATION = @as(c_long, 1610);
pub const HP_ALGID = 1;
pub const NCRYPT_DH_ALGORITHM = BCRYPT_DH_ALGORITHM;
pub const MDM_FLOWCONTROL_SOFT = 32;
pub const EV_RING = 256;
pub const SPI_SETACTIVEWNDTRKTIMEOUT = 8195;
pub const CRYPT_DECODE_NO_SIGNATURE_BYTE_REVERSAL_FLAG = 8;
pub const DFC_SCROLL = 3;
pub const CERT_SELECT_ALLOW_DUPLICATES = 128;
pub const FILE_UNKNOWN = 5;
pub const szOID_ENROLL_SCEP_CHALLENGE_ANSWER = "1.3.6.1.4.1.311.21.35";
pub const WNNC_NET_SYMFONET = 1376256;
pub const NCRYPT_PIN_CACHE_REQUIRE_GESTURE_FLAG = 1;
pub const CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC = 8;
pub const NIM_ADD = 0;
pub const CONNECT_CURRENT_MEDIA = 512;
pub const ERROR_MISSING_SYSTEMFILE = @as(c_long, 573);
pub const IPPORT_FTP = 21;
pub const PPCAPS_DOWN_THEN_RIGHT = 1 << 1;
pub const PC_RESERVED = 1;
pub const ERROR_CTX_MODEM_RESPONSE_NO_CARRIER = @as(c_long, 7013);
pub const ERROR_SPOOL_FILE_NOT_FOUND = @as(c_long, 3002);
pub const WVR_HREDRAW = 256;
pub const ERROR_TLW_WITH_WSCHILD = @as(c_long, 1406);
pub const ALG_SID_SAFERSK128 = 8;
pub const IMM_ERROR_GENERAL = -2;
pub const ERROR_OPERATION_IN_PROGRESS = @as(c_long, 329);
pub const CTRY_MALDIVES = 960;
pub const ERROR_SERVICE_NO_THREAD = @as(c_long, 1054);
pub const SHTDN_REASON_MINOR_TERMSRV = 32;
pub const _Satisfies_impl_ = expr;
pub const CRYPT_OID_INFO_CNG_ALGID_KEY = 5;
pub const IMAGE_REL_AMD64_INDIR_BR_REX = 24;
pub const LANG_KASHMIRI = 96;
pub const S_WHITE2048 = 6;
pub const ERROR_DS_NAMING_VIOLATION = @as(c_long, 8247);
pub const OFN_EXTENSIONDIFFERENT = 1024;
pub const VIF_DIFFCODEPG = @as(c_long, 16);
pub const RPC_S_ALREADY_REGISTERED = @as(c_long, 1711);
pub const SCardReadCache = SCardReadCacheA;
pub const ELEMENT_STATUS_IMPEXP = 2;
pub const SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC = 12;
pub const __LDBL_MIN__ = 0.000000;
pub const VK_BROWSER_SEARCH = 170;
pub const LOCALE_SABBREVMONTHNAME4 = 71;
pub const CONNECT_REDIRECT = 128;
pub const WM_CONTEXTMENU = 123;
pub const REG_NO_COMPRESSION = 4;
pub const LOCALE_SDAYNAME4 = 45;
pub const NCRYPT_PAD_PKCS1_FLAG = 2;
pub const szOID_PKIX_CA_ISSUERS = "1.3.6.1.5.5.7.48.2";
pub const XSTATE_MASK_CET_U = if (@typeId(@typeOf(i64 << XSTATE_CET_U)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << XSTATE_CET_U) else if (@typeId(@typeOf(i64 << XSTATE_CET_U)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << XSTATE_CET_U) else @as(c_uint, 1)(i64 << XSTATE_CET_U);
pub const ST_CLIENT = 16;
pub const IME_CHOTKEY_SYMBOL_TOGGLE = 18;
pub const FW_DONTCARE = 0;
pub const LANG_IGBO = 112;
pub const PO_PORTCHANGE = 32;
pub const CF_WYSIWYG = @as(c_long, 32768);
pub const WM_WTSSESSION_CHANGE = 689;
pub const PEN_MASK_PRESSURE = 1;
pub const SUBLANG_XHOSA_SOUTH_AFRICA = 1;
pub const DMPAPER_ENV_C4 = 30;
pub const WM_CHANGECBCHAIN = 781;
pub const PRINTER_STATUS_OUT_OF_MEMORY = 2097152;
pub const LOCALE_USE_NLS = 268435456;
pub const PCF_DTRDSR = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 1) else DWORD(1);
pub const CONNECT_UPDATE_PROFILE = 1;
pub const NCRYPT_WRITE_KEY_TO_LEGACY_STORE_FLAG = 512;
pub const NRC_IFBUSY = 33;
pub const LANG_QUECHUA = 107;
pub const CERT_CHAIN_POLICY_EV = if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 8) else if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 8) else LPCSTR(8);
pub const HALFTONE = 4;
pub const IMAGE_SYM_TYPE_ENUM = 10;
pub const ERROR_TOO_MANY_TCBS = @as(c_long, 155);
pub const STGM_WRITE = @as(c_long, 1);
pub const SW_SHOWMINNOACTIVE = 7;
pub const ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED = @as(c_long, 5076);
pub const MCI_WAVE_SET_BITSPERSAMPLE = @as(c_long, 2097152);
pub const URLACTION_JAVA_MIN = 7168;
pub const DI_CHANNEL = 1;
pub const TRANSACTION_NOTIFY_LAST_RECOVER = 8192;
pub const PAGE_GRAPHICS_READWRITE = 8192;
pub const WSAEOPNOTSUPP = @as(c_long, 10045);
pub const SBS_HORZ = @as(c_long, 0);
pub const SHERB_NOSOUND = 4;
pub const ERROR_ILL_FORMED_PASSWORD = @as(c_long, 1324);
pub const IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA = 32;
pub const VFF_CURNEDEST = 1;
pub const THREAD_SET_LIMITED_INFORMATION = 1024;
pub const VK_NEXT = 34;
pub const CERT_TRUST_AUTO_UPDATE_END_REVOCATION = 32;
pub const MS_DEF_DH_SCHANNEL_PROV = MS_DEF_DH_SCHANNEL_PROV_A;
pub const VK_LBUTTON = 1;
pub const PARITY_MARK = if (@typeId(@typeOf(2048)) == @import("builtin").TypeId.Pointer) @ptrCast(WORD, 2048) else if (@typeId(@typeOf(2048)) == @import("builtin").TypeId.Int) @intToPtr(WORD, 2048) else WORD(2048);
pub const CTRY_AUSTRALIA = 61;
pub const ERROR_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY = @as(c_long, 4435);
pub const PRINTER_ENUM_ICON7 = 4194304;
pub const ERROR_NOT_LOCKED = @as(c_long, 158);
pub const NCRYPT_TREAT_NIST_AS_GENERIC_ECC_FLAG = 8192;
pub const KP_X = 14;
pub const CB_GETDROPPEDCONTROLRECT = 338;
pub const MCI_DEVTYPE_SEQUENCER = 523;
pub const CF_PRIVATELAST = 767;
pub const PF_TEMPORAL_LEVEL_1 = _MM_HINT_T0;
pub const GCP_NUMERICSLOCAL = @as(c_long, 134217728);
pub const CRYPT_X931_FORMAT = 4;
pub const OBJ_COLORSPACE = 14;
pub const WIM_CLOSE = MM_WIM_CLOSE;
pub const BAUD_19200 = if (@typeId(@typeOf(8192)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 8192) else if (@typeId(@typeOf(8192)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 8192) else DWORD(8192);
pub const WM_HSCROLL = 276;
pub const ERROR_GPIO_VERSION_NOT_SUPPORTED = @as(c_long, 15323);
pub const POINTER_FLAG_CONFIDENCE = 16384;
pub const IMC_GETCANDIDATEPOS = 7;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE = 2;
pub const ASPECTY = 42;
pub const RPC_S_BINDING_INCOMPLETE = @as(c_long, 1819);
pub const SOCK_STREAM = 1;
pub const WINSHELLAPI = DECLSPEC_IMPORT;
pub const META_POLYGON = 804;
pub const LookupPrivilegeValue = LookupPrivilegeValueA;
pub const GetModuleFileName = GetModuleFileNameA;
pub const ERROR_DEVICE_SUPPORT_IN_PROGRESS = @as(c_long, 171);
pub const MDM_SHIFT_HDLCPPP_ML = 6;
pub const SPI_SETLOGICALDPIOVERRIDE = 159;
pub const GL_ID_REVERSECONVERSION = 41;
pub const CERT_V2 = 1;
pub const NORM_IGNORENONSPACE = 2;
pub const szOID_ECC_CURVE_BRAINPOOLP256R1 = "1.3.36.3.3.2.8.1.1.7";
pub const THREAD_PRIORITY_LOWEST = THREAD_BASE_PRIORITY_MIN;
pub const IMAGE_REL_SH3_DIRECT8 = 3;
pub const MB_DEFBUTTON4 = @as(c_long, 768);
pub const LOCALE_SENGCURRNAME = 4103;
pub const WINVER = _WIN32_WINNT;
pub const TXFS_START_RM_FLAG_RECOVER_BEST_EFFORT = 512;
pub const ERROR_MOUNT_POINT_NOT_RESOLVED = @as(c_long, 649);
pub const PERF_NUMBER_HEX = 0;
pub const SetFileShortName = SetFileShortNameA;
pub const PAN_PROP_VERY_CONDENSED = 8;
pub const Uri_HAS_USER_INFO = 1 << Uri_PROPERTY_USER_INFO;
pub const COMMPROP_INITIALIZED = if (@typeId(@typeOf(3879531822)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 3879531822) else if (@typeId(@typeOf(3879531822)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 3879531822) else DWORD(3879531822);
pub const LOGON32_LOGON_BATCH = 4;
pub const sz_CERT_STORE_PROV_PHYSICAL = sz_CERT_STORE_PROV_PHYSICAL_W;
pub const ERROR_NO_NETWORK = @as(c_long, 1222);
pub const VK_EXSEL = 248;
pub const szOID_NIST_AES256_WRAP = "2.16.840.1.101.3.4.1.45";
pub const DT_PREFIXONLY = 2097152;
pub const CRYPTNET_URL_CACHE_PRE_FETCH_OCSP = 3;
pub const SM_MENUDROPALIGNMENT = 40;
pub const SUBLANG_TIGRINYA_ERITREA = 2;
pub const ERROR_NOT_CONTAINER = @as(c_long, 1207);
pub const SM_MAXIMUMTOUCHES = 95;
pub const PAGE_REVERT_TO_FILE_MAP = 2147483648;
pub const PIPE_REJECT_REMOTE_CLIENTS = 8;
pub const __SIZE_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const MDM_SHIFT_PROTOCOLINFO = MDM_SHIFT_PROTOCOLID;
pub const BLTALIGNMENT = 119;
pub const FACILITY_DELIVERY_OPTIMIZATION = 208;
pub const DEVICEFAMILYINFOENUM_WINDOWS_8X = 1;
pub const ENAMETOOLONG = 38;
pub const FR_DIALOGTERM = 64;
pub const IMAGE_SYM_TYPE_DOUBLE = 7;
pub const SERVICE_STOP_REASON_FLAG_UNPLANNED = 268435456;
pub const ST_BLOCKED = 8;
pub const szOID_RSA_MD4RSA = "1.2.840.113549.1.1.3";
pub const LoadBitmap = LoadBitmapA;
pub const ERROR_DS_PDC_OPERATION_IN_PROGRESS = @as(c_long, 8490);
pub const SCARD_SHARE_DIRECT = 3;
pub const ERROR_FLOAT_MULTIPLE_FAULTS = @as(c_long, 630);
pub const HELP_CONTENTS = @as(c_long, 3);
pub const FILE_REGION_USAGE_OTHER_PAGE_ALIGNMENT = 4;
pub const DNS_ERROR_RCODE_SERVER_FAILURE = @as(c_long, 9002);
pub const LOCALE_SABBREVMONTHNAME5 = 72;
pub const DOF_DIRECTORY = 32771;
pub const ERROR_DS_BAD_ATT_SCHEMA_SYNTAX = @as(c_long, 8400);
pub const CTRY_BELIZE = 501;
pub const _WIN32_WINNT = 2560;
pub const ERROR_DEPENDENT_RESOURCE_EXISTS = @as(c_long, 5001);
pub const SORT_HUNGARIAN_TECHNICAL = 1;
pub const LOCALE_SDAYNAME5 = 46;
pub const GET_PS_FEATURESETTING = 4121;
pub const NCRYPT_PCP_ENCRYPTION_KEY = 2;
pub const CFSTR_MIME_APPLICATION_JAVASCRIPT = if (@typeId(@typeOf("application/javascript")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "application/javascript") else if (@typeId(@typeOf("application/javascript")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "application/javascript") else TEXT("application/javascript");
pub const RIDEV_REMOVE = 1;
pub const DFC_CAPTION = 1;
pub const STATE_SYSTEM_SIZEABLE = 131072;
pub const PRODUCT_PROFESSIONAL_STUDENT_N = 114;
pub const PDCAP_WAKE_FROM_D0_SUPPORTED = 16;
pub const ERROR_DS_NO_TREE_DELETE_ABOVE_NC = @as(c_long, 8501);
pub const DNS_ERROR_ZONE_ALREADY_EXISTS = @as(c_long, 9609);
pub const CACHE_FULLY_ASSOCIATIVE = 255;
pub const EIMES_COMPLETECOMPSTRKILLFOCUS = 4;
pub const CERT_REGISTRY_STORE_CLIENT_GPT_FLAG = 2147483648;
pub const ERROR_ASSERTION_FAILURE = @as(c_long, 668);
pub const ERROR_LOG_RESIZE_INVALID_SIZE = @as(c_long, 6806);
pub const FILE_DEVICE_PERSISTENT_MEMORY = 89;
pub const IPPORT_FINGER = 79;
pub const DMPAPER_ENV_C5 = 28;
pub const CRL_FIND_ISSUED_BY_BASE_FLAG = 8;
pub const abnormal_termination = _abnormal_termination;
pub const EXIT_PROCESS_DEBUG_EVENT = 5;
pub const __LDBL_MAX_10_EXP__ = 308;
pub const DDE_FAPPSTATUS = 255;
pub const IDI_INFORMATION = IDI_ASTERISK;
pub const s_impno = S_un.S_un_b.s_b4;
pub const DLL_PROCESS_DETACH = 0;
pub const MIM_DATA = MM_MIM_DATA;
pub const SHIL_LARGE = 0;
pub const URLPOLICY_BEHAVIOR_CHECK_LIST = 65536;
pub const ERROR_DISK_CHANGE = @as(c_long, 107);
pub const NUMPRS_USE_ALL = 4096;
pub const WRITE_COMPRESSION_INFO_VALID = 16;
pub const szOID_RSA_certExtensions = "1.2.840.113549.1.9.14";
pub const MOUSEEVENTF_XDOWN = 128;
pub const SC_DEFAULT = 61792;
pub const STN_DBLCLK = 1;
pub const WM_QUERYDRAGICON = 55;
pub const ERROR_DS_NTDSCRIPT_SYNTAX_ERROR = @as(c_long, 8591);
pub const DNS_ERROR_NO_ZONE_INFO = @as(c_long, 9602);
pub const CMSG_OID_CAPI1_GEN_CONTENT_ENCRYPT_KEY_FUNC = CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC;
pub const PRINTER_ENUM_ICON6 = 2097152;
pub const HEAP_MAXIMUM_TAG = 4095;
pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE = @as(c_long, 13905);
pub const ERROR_INVALID_PRINT_MONITOR = @as(c_long, 3007);
pub const IID_IOInetProtocolSink = IID_IInternetProtocolSink;
pub const PURGE_RXCLEAR = 8;
pub const szOID_BASIC_CONSTRAINTS2 = "2.5.29.19";
pub const FS_UNICODE_STORED_ON_DISK = FILE_UNICODE_ON_DISK;
pub const ERROR_DS_CHILDREN_EXIST = @as(c_long, 8332);
pub const IMAGE_HOT_PATCH_CHUNK_OBLIGATORY = 1073741824;
pub const MIXER_GETCONTROLDETAILSF_LISTTEXT = @as(c_long, 1);
pub const IMAGE_FILE_DLL = 8192;
pub const DMPAPER_ENV_ITALY = 36;
pub const EMSIS_COMPOSITIONSTRING = 1;
pub const IMAGE_DEBUG_TYPE_ILTCG = 14;
pub const WOF_PROVIDER_WIM = 1;
pub const TAPE_DRIVE_FORMAT_IMMEDIATE = 3221225472;
pub const FS_ARABIC = @as(c_long, 64);
pub const PF_TEMPORAL_LEVEL_2 = _MM_HINT_T1;
pub const DMPAPER_USER = 256;
pub const ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME = @as(c_long, 5900);
pub const __SIZEOF_FLOAT__ = 4;
pub const GL_ID_TOOMANYSTROKE = 34;
pub const ERROR_DS_NTDSCRIPT_PROCESS_ERROR = @as(c_long, 8592);
pub const CERT_RDN_INT4_STRING = 11;
pub const TAPE_DRIVE_ERASE_SHORT = 16;
pub const DNS_ERROR_DATAFILE_OPEN_FAILURE = @as(c_long, 9653);
pub const ERROR_ILLEGAL_ELEMENT_ADDRESS = @as(c_long, 1162);
pub const PSINJECT_ENDPAGESETUP = 102;
pub const MCI_WAVE_GETDEVCAPS_INPUTS = @as(c_long, 16385);
pub const RPC_NCA_FLAGS_BROADCAST = 2;
pub const SPI_SETMOUSEDOCKTHRESHOLD = 127;
pub const RTL_UMS_VERSION = 256;
pub const ASPECTX = 40;
pub const CRYPTNET_URL_CACHE_PRE_FETCH_PIN_RULES_CAB = 7;
pub const MDMVOLFLAG_MEDIUM = 2;
pub const FindFirstFile = FindFirstFileA;
pub const ERROR_NOT_EMPTY = @as(c_long, 4307);
pub const DC_ENUMRESOLUTIONS = 13;
pub const CMC_FAIL_POP_REQUIRED = 8;
pub const SMART_NO_ERROR = 0;
pub const CRYPT_OID_REG_FUNC_NAME_VALUE_NAME_A = "FuncName";
pub const ERROR_SOURCE_ELEMENT_EMPTY = @as(c_long, 1160);
pub const ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS = @as(c_long, 6632);
pub const NTDDI_WINTHRESHOLD = 167772160;
pub const ERROR_CTX_MODEM_RESPONSE_BUSY = @as(c_long, 7015);
pub const TOKEN_ADJUST_PRIVILEGES = 32;
pub const CERT_V3 = 2;
pub const LOCALE_ICURRDIGITS = 25;
pub const GUID_SERENUM_BUS_ENUMERATOR = GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR;
pub const SERVICE_CONFIG_DELAYED_AUTO_START_INFO = 3;
pub const ENABLE_MOUSE_INPUT = 16;
pub const __drv_setsIRQL = irql;
pub const CERT_FIND_VALID_CTL_USAGE_FLAG = CERT_FIND_VALID_ENHKEY_USAGE_FLAG;
pub const EPIPE = 32;
pub const LPPROPSHEETHEADER = LPPROPSHEETHEADERA;
pub const ETXTBSY = 139;
pub const PDERR_SETUPFAILURE = 4097;
pub const __DBL_HAS_DENORM__ = 1;
pub const ERROR_NO_TRACKING_SERVICE = @as(c_long, 1172);
pub const IMAGE_FILE_LINE_NUMS_STRIPPED = 4;
pub const ERROR_CTX_CLIENT_QUERY_TIMEOUT = @as(c_long, 7040);
pub const IMAGE_REL_MIPS_TOKEN = 14;
pub const NETSCAPE_SIGN_CERT_TYPE = 16;
pub const ERROR_DS_DRA_CORRUPT_UTD_VECTOR = @as(c_long, 8629);
pub const SPI_GETMOUSEDOCKTHRESHOLD = 126;
pub const MIXER_GETLINEINFOF_TARGETTYPE = @as(c_long, 4);
pub const CROSS_CERT_DIST_POINT_ERR_INDEX_SHIFT = 24;
pub const RegDeleteKeyTransacted = RegDeleteKeyTransactedA;
pub const IOInetProtocolRoot = IInternetProtocolRoot;
pub const SEC_WRITECOMBINE = 1073741824;
pub const IMAGE_FILE_MACHINE_R3000 = 354;
pub const ERROR_CLUSTER_NODE_DOWN = @as(c_long, 5050);
pub const Uri_CREATE_ALLOW_RELATIVE = 1;
pub const SETXON = 2;
pub const PRODUCT_CLOUD_HOST_INFRASTRUCTURE_SERVER = 124;
pub const NCBUNLINK = 112;
pub const LB_OKAY = 0;
pub const ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE = @as(c_long, 14079);
pub const LOCALE_SNATIVECURRNAME = 4104;
pub const CF_TEXT = 1;
pub const ERROR_WOF_WIM_HEADER_CORRUPT = @as(c_long, 4446);
pub const VOS_NT = @as(c_long, 262144);
pub const C3_LOWSURROGATE = 4096;
pub const MCI_COPY = 2130;
pub const CRYPT_ENHKEY_USAGE_OID_GROUP_ID = 7;
pub const IMAGE_REL_IA64_GPREL22 = 9;
pub const CTRY_NORWAY = 47;
pub const FACILITY_AUDIO = 102;
pub const ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF = @as(c_long, 8589);
pub const VK_GAMEPAD_LEFT_THUMBSTICK_LEFT = 214;
pub const szOID_PKIX_POLICY_QUALIFIER_USERNOTICE = "1.3.6.1.5.5.7.2.2";
pub const ERROR_MARKED_TO_DISALLOW_WRITES = @as(c_long, 348);
pub const FindFirstFileEx = FindFirstFileExA;
pub const DS_CONTEXTHELP = @as(c_long, 8192);
pub const STATE_SYSTEM_PROTECTED = 536870912;
pub const CRYPT_ACQUIRE_NO_HEALING = 8;
pub const NUMPRS_CURRENCY = 1024;
pub const RpcBindingToStringBinding = RpcBindingToStringBindingA;
pub const ETO_GLYPH_INDEX = 16;
pub const MF_DISABLED = @as(c_long, 2);
pub const ERROR_NO_INHERITANCE = @as(c_long, 1391);
pub const SM_CXSMSIZE = 52;
pub const BACKGROUND_INTENSITY = 128;
pub const szOID_SUBJECT_KEY_IDENTIFIER = "2.5.29.14";
pub const CERT_RETRIEVE_BIOMETRIC_PREDEFINED_BASE_TYPE = if (@typeId(@typeOf(1000)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 1000) else if (@typeId(@typeOf(1000)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 1000) else LPCSTR(1000);
pub const RPC_C_AUTHN_KERNEL = 20;
pub const CERT_CHAIN_REVOCATION_CHECK_CHAIN = 536870912;
pub const SOUND_SYSTEM_ERROR = 4;
pub const VK_SNAPSHOT = 44;
pub const SC_HSCROLL = 61568;
pub const ERROR_UNABLE_TO_LOCK_MEDIA = @as(c_long, 1108);
pub const SPI_GETMOUSETRAILS = 94;
pub const EVENT_CONSOLE_END = 16639;
pub const PP_SIGNATURE_ALG = 15;
pub const RPC_C_PROFILE_MATCH_BY_BOTH = 4;
pub const SUBLANG_FRENCH = 1;
pub const NIF_GUID = 32;
pub const COM_RIGHTS_EXECUTE_LOCAL = 2;
pub const CMC_OTHER_INFO_FAIL_CHOICE = 1;
pub const FILE_ATTRIBUTE_NORMAL = 128;
pub const ALG_SID_DESX = 4;
pub const WTS_CONSOLE_DISCONNECT = 2;
pub const __DBL_MIN__ = 0.000000;
pub const LB_SETCURSEL = 390;
pub const URLACTION_SHELL_POPUPMGR = 6153;
pub const FindNextFile = FindNextFileA;
pub const _WIN32 = 1;
pub const ERROR_DS_SRC_GUID_MISMATCH = @as(c_long, 8488);
pub const FAST_FAIL_INVALID_IDLE_STATE = 33;
pub const RIDEV_NOHOTKEYS = 512;
pub const CharUpperBuff = CharUpperBuffA;
pub const CDN_LAST = if (@typeId(@typeOf(-@as(c_uint, 699))) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), -@as(c_uint, 699)) else if (@typeId(@typeOf(-@as(c_uint, 699))) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), -@as(c_uint, 699)) else @as(c_uint, 0)(-@as(c_uint, 699));
pub const CBR_300 = 300;
pub const ERROR_MEDIUM_NOT_ACCESSIBLE = @as(c_long, 4323);
pub const IMAGE_REL_PPC_TOKEN = 22;
pub const SM_CXMENUSIZE = 54;
pub const MIDI_CACHE_BESTFIT = 2;
pub const ERROR_OFFLOAD_READ_FLT_NOT_SUPPORTED = @as(c_long, 4440);
pub const VerQueryValue = VerQueryValueA;
pub const PRINTER_ENUM_ICON5 = 1048576;
pub const _Group_impl_ = annos;
pub const STORAGE_CRYPTO_CAPABILITY_VERSION_1 = 1;
pub const TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_NUM_CONTAINERS = 16;
pub const ERROR_IO_PENDING = @as(c_long, 997);
pub const SMART_LOG_SECTOR_SIZE = 512;
pub const WN_EXTENDED_ERROR = ERROR_EXTENDED_ERROR;
pub const MONITOR_DEFAULTTOPRIMARY = 1;
pub const CC_PIE = 2;
pub const VK_SUBTRACT = 109;
pub const ERROR_INVALID_COLORINDEX = @as(c_long, 2022);
pub const PF_TEMPORAL_LEVEL_3 = _MM_HINT_T2;
pub const RPC_C_AUTHN_LEVEL_CONNECT = 2;
pub const SUBLANG_GERMAN = 1;
pub const GSS_ALLOW_INHERITED_COMMON = 1;
pub const WNNC_NET_DOCUSHARE = 4521984;
pub const LANG_KINYARWANDA = 135;
pub const ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH = @as(c_long, 6727);
pub const OFN_ENABLEINCLUDENOTIFY = 4194304;
pub const DM_DISPLAYFIXEDOUTPUT = @as(c_long, 536870912);
pub const TIME_VALID_OID_GET_CTL = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 1) else LPCSTR(1);
pub const ERROR_NON_DOMAIN_SID = @as(c_long, 1258);
pub const WA_INACTIVE = 0;
pub const VFT2_DRV_KEYBOARD = @as(c_long, 2);
pub const CERT_CHAIN_RETURN_LOWER_QUALITY_CONTEXTS = 128;
pub const LGRPID_THAI = 11;
pub const MININT8 = if (@typeId(@typeOf(~MAXINT8)) == @import("builtin").TypeId.Pointer) @ptrCast(INT8, ~MAXINT8) else if (@typeId(@typeOf(~MAXINT8)) == @import("builtin").TypeId.Int) @intToPtr(INT8, ~MAXINT8) else INT8(~MAXINT8);
pub const PKCS12_ONLY_NOT_ENCRYPTED_CERTIFICATES = 2048;
pub const ERROR_NOT_REDUNDANT_STORAGE = @as(c_long, 333);
pub const SERVICE_TRIGGER_DATA_TYPE_KEYWORD_ALL = 5;
pub const DOCKINFO_DOCKED = 2;
pub const ExpandEnvironmentStrings = ExpandEnvironmentStringsA;
pub const AnsiNext = CharNextA;
pub const midiOutGetDevCaps = midiOutGetDevCapsA;
pub const JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK = 4096;
pub const SUBLANG_ENGLISH_NZ = 5;
pub const OCSP_TRY_LATER_RESPONSE = 3;
pub const SID_REVISION = 1;
pub const MMIO_FHOPEN = 16;
pub const ERROR_EVENT_DONE = @as(c_long, 710);
pub const CERT_CEP_PROP_ID = 87;
pub const CRL_FIND_ISSUED_FOR_SET_STRONG_PROPERTIES_FLAG = 16;
pub const ERROR_UNEXP_NET_ERR = @as(c_long, 59);
pub const SCardListInterfaces = SCardListInterfacesA;
pub const DI_MASK = 1;
pub const ERROR_PAGEFILE_CREATE_FAILED = @as(c_long, 576);
pub const CF_EFFECTS = @as(c_long, 256);
pub const IO_REPARSE_TAG_HSM = @as(c_long, 3221225476);
pub const ERROR_PLATFORM_MANIFEST_INVALID = @as(c_long, 4571);
pub const WNetOpenEnum = WNetOpenEnumA;
pub const GetKeyboardLayoutName = GetKeyboardLayoutNameA;
pub const IMAGE_SCN_LNK_INFO = 512;
pub const SERVICE_STOP_REASON_MINOR_DISK = 8;
pub const ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE = @as(c_long, 13899);
pub const EMR_MAX = 122;
pub const CERT_RDN_UNIVERSAL_STRING = 11;
pub const IGIMII_OTHER = 32;
pub const IMAGE_REL_ARM_ABSOLUTE = 0;
pub const IMAGE_REL_AMD64_INDIR_BR = 23;
pub const DNS_ERROR_ZONE_REQUIRES_MASTER_IP = @as(c_long, 9620);
pub const CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG = 16;
pub const RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH = 1;
pub const ERROR_INVALID_MSGBOX_STYLE = @as(c_long, 1438);
pub const URLACTION_INFODELIVERY_NO_EDITING_CHANNELS = 7425;
pub const PSD_ENABLEPAGESETUPTEMPLATE = 32768;
pub const IO_REPARSE_TAG_FILE_PLACEHOLDER = @as(c_long, 2147483669);
pub const PROTOCOLFLAG_NO_PICS_CHECK = 1;
pub const SND_RING = @as(c_long, 1048576);
pub const NORMAL_PRIORITY_CLASS = 32;
pub const HCF_HOTKEYSOUND = 16;
pub const SERVICE_NOTIFY_PAUSED = 64;
pub const __sdv_retrieve_request = r;
pub const IMAGE_DIRECTORY_ENTRY_GLOBALPTR = 8;
pub const CF_ENABLEHOOK = @as(c_long, 8);
pub const ERROR_NO_SECURITY_ON_OBJECT = @as(c_long, 1350);
pub const MCI_SEQ_STATUS_SLAVE = @as(c_long, 16391);
pub const DMBIN_SMALLFMT = 9;
pub const VP_TV_STANDARD_SECAM_K1 = 8192;
pub const GETVECTORPENSIZE = 26;
pub const LOCALE_ALTERNATE_SORTS = 4;
pub const SIF_DISABLENOSCROLL = 8;
pub const IMAGE_GUARD_PROTECT_DELAYLOAD_IAT = 4096;
pub const CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR = 8;
pub const FILE_WRITE_ACCESS = 2;
pub const LB_GETSELCOUNT = 400;
pub const DC_MINEXTENT = 4;
pub const RPC_C_MGMT_IS_SERVER_LISTEN = 3;
pub const _WIN32_WINNT_NT4 = 1024;
pub const SCARD_PROVIDER_PRIMARY = 1;
pub const ERROR_TRANSACTION_RECORD_TOO_LONG = @as(c_long, 6724);
pub const PF_NS = AF_NS;
pub const X3_IMM39_1_INST_WORD_X = 2;
pub const TAPE_SELECT_PARTITIONS = @as(c_long, 1);
pub const CTRY_URUGUAY = 598;
pub const szOID_ENROLL_SCEP_ERROR = "1.3.6.1.4.1.311.21.33";
pub const CD_LBSELNOITEMS = -1;
pub const IMAGE_DEBUG_TYPE_COFF = 1;
pub const DMPAPER_12X11 = 90;
pub const DOMAIN_ALIAS_RID_PRINT_OPS = @as(c_long, 550);
pub const IMAGE_FILE_MACHINE_POWERPCFP = 497;
pub const CALLBACK_FUNCTION = @as(c_long, 196608);
pub const ERROR_SXS_XML_E_MISSINGWHITESPACE = @as(c_long, 14037);
pub const SECURITY_MAX_ALWAYS_FILTERED = @as(c_long, 999);
pub const CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE = 32768;
pub const ERROR_SUBST_TO_JOIN = @as(c_long, 141);
pub const CONVERT10_S_FIRST = @as(c_long, 262592);
pub const ILLUMINANT_F2 = 8;
pub const MDM_X75_DATA_DEFAULT = 0;
pub const stc23 = 1110;
pub const ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND = @as(c_long, 15003);
pub const DMPAPER_PENV_3_ROTATED = 111;
pub const szOID_RSA_MD5 = "1.2.840.113549.2.5";
pub const BCRYPT_ECDSA_P521_ALG_HANDLE = if (@typeId(@typeOf(769)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 769) else if (@typeId(@typeOf(769)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 769) else BCRYPT_ALG_HANDLE(769);
pub const SE_SIGNING_LEVEL_WINDOWS = 12;
pub const IPPROTO_RAW = 255;
pub const C3_HALFWIDTH = 64;
pub const RPC_C_NO_CREDENTIALS = if (@typeId(@typeOf(MAXUINT_PTR)) == @import("builtin").TypeId.Pointer) @ptrCast(RPC_AUTH_IDENTITY_HANDLE, MAXUINT_PTR) else if (@typeId(@typeOf(MAXUINT_PTR)) == @import("builtin").TypeId.Int) @intToPtr(RPC_AUTH_IDENTITY_HANDLE, MAXUINT_PTR) else RPC_AUTH_IDENTITY_HANDLE(MAXUINT_PTR);
pub const DISK_LOGGING_START = 0;
pub const PSNRET_INVALID = 1;
pub const X3_TMPLT_INST_WORD_POS_X = 0;
pub const WM_GETOBJECT = 61;
pub const szOID_ENROLL_ENCRYPTION_ALGORITHM = "1.3.6.1.4.1.311.21.29";
pub const SCardAddReaderToGroup = SCardAddReaderToGroupA;
pub const __CLRCALL_PURE_OR_CDECL = __cdecl;
pub const CP_SUPPORTED = 2;
pub const DMPAPER_LETTER = 1;
pub const ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA = @as(c_long, 4330);
pub const szOID_OIWSEC_desEDE = "1.3.14.3.2.17";
pub const GetPrinterDataEx = GetPrinterDataExA;
pub const MIDI_CACHE_QUERY = 3;
pub const SERIAL_NUMBER_LENGTH = 32;
pub const EC_QUERYWAITING = 2;
pub const BATTERY_FLAG_HIGH = 1;
pub const POSTSCRIPT_PASSTHROUGH = 4115;
pub const DD_DEFSCROLLINSET = 11;
pub const IOInetProtocolSinkStackable = IInternetProtocolSinkStackable;
pub const LOCALE_SPM = 41;
pub const PRINTER_ENUM_ICON4 = 524288;
pub const ERROR_CLUSTER_SHUTTING_DOWN = @as(c_long, 5022);
pub const JOB_NOTIFY_FIELD_SECURITY_DESCRIPTOR = 12;
pub const EEInfoUseFileTime = 4;
pub const ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS = @as(c_long, 8205);
pub const CERT_TRUST_INVALID_NAME_CONSTRAINTS = 2048;
pub const IMAGE_REL_IA64_PCREL60X = 21;
pub const ERROR_SERVICE_REQUEST_TIMEOUT = @as(c_long, 1053);
pub const szOIDVerisign_FailInfo = "2.16.840.1.113733.1.9.4";
pub const TKF_CONFIRMHOTKEY = 8;
pub const CB_GETITEMHEIGHT = 340;
pub const OBJ_BITMAP = 7;
pub const SE_DACL_PROTECTED = 4096;
pub const DFCS_MENUCHECK = 1;
pub const ERROR_SPECIAL_ACCOUNT = @as(c_long, 1371);
pub const FILE_FILE_COMPRESSION = 16;
pub const ISMEX_SEND = 1;
pub const SERVICE_ERROR_SEVERE = 2;
pub const DMPAPER_A3_TRANSVERSE = 67;
pub const CERT_CHAIN_DISABLE_CODE_SIGNING_WEAK_FLAG = 4194304;
pub const SUBLANG_ARABIC_SYRIA = 10;
pub const TKF_AVAILABLE = 2;
pub const URLACTION_SCRIPT_CURR_MAX = 5132;
pub const JOYERR_NOERROR = 0;
pub const EXCEPTION_READ_FAULT = 0;
pub const TRANSACTION_NOTIFY_ROLLBACK = 8;
pub const WM_DWMSENDICONICTHUMBNAIL = 803;
pub const MCI_STATUS_ITEM = @as(c_long, 256);
pub const ERROR_IPSEC_IKE_RATELIMIT_DROP = @as(c_long, 13903);
pub const FILE_SHARE_READ = 1;
pub const ERROR_FT_DI_SCAN_REQUIRED = @as(c_long, 339);
pub const CERT_V1 = 0;
pub const PRODUCT_BUSINESS = 6;
pub const PRINTER_CHANGE_ADD_PRINT_PROCESSOR = 16777216;
pub const ERROR_IPSEC_MM_POLICY_IN_USE = @as(c_long, 13005);
pub const MIXERLINE_TARGETTYPE_WAVEOUT = 1;
pub const PD_CURRENTPAGE = 4194304;
pub const MK_E_LAST = @as(c_long, 2147746287);
pub const ERROR_FILE_READ_ONLY = @as(c_long, 6009);
pub const ERROR_INSUFFICIENT_BUFFER = @as(c_long, 122);
pub const IMAGE_REL_M32R_TOKEN = 14;
pub const DEVICEFAMILYINFOENUM_TEAM = 6;
pub const IMAGE_COMDAT_SELECT_ASSOCIATIVE = 5;
pub const STGM_FAILIFTHERE = @as(c_long, 0);
pub const CF_DSPTEXT = 129;
pub const DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS = @as(c_long, 561);
pub const CB_GETLOCALE = 346;
pub const GETDEVICEUNITS = 42;
pub const NCBDGRECV = 33;
pub const ERROR_SUBST_TO_SUBST = @as(c_long, 139);
pub const GUI_CARETBLINKING = 1;
pub const ERROR_NODE_NOT_ACTIVE_CLUSTER_MEMBER = @as(c_long, 5980);
pub const CONTEXT_EXCEPTION_ACTIVE = @as(c_long, 134217728);
pub const OBJID_CARET = if (@typeId(@typeOf(4294967288)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG, 4294967288) else if (@typeId(@typeOf(4294967288)) == @import("builtin").TypeId.Int) @intToPtr(LONG, 4294967288) else LONG(4294967288);
pub const QUERY_STORAGE_CLASSES_FLAGS_MEASURE_READ = 1073741824;
pub const ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND = @as(c_long, 5032);
pub const RegDeleteKey = RegDeleteKeyA;
pub const URLACTION_ALLOW_XDOMAIN_SUBFRAME_RESIZE = 5128;
pub const __WCHAR_MAX__ = 65535;
pub const VK_OEM_PLUS = 187;
pub const NORM_IGNOREWIDTH = 131072;
pub const READ_THRESHOLDS = 209;
pub const VIF_OUTOFMEMORY = @as(c_long, 32768);
pub const MMIO_CREATERIFF = 32;
pub const DMLERR_DLL_USAGE = 16388;
pub const DNS_ERROR_RCODE_BADSIG = @as(c_long, 9016);
pub const POWER_ACTION_QUERY_ALLOWED = 1;
pub const ERROR_DISK_REPAIR_DISABLED = @as(c_long, 780);
pub const XST_POKEACKRCVD = 8;
pub const ERROR_EVT_VERSION_TOO_NEW = @as(c_long, 15035);
pub const IMAGE_REL_PPC_SECREL16 = 15;
pub const _Deref2_post1_impl_ = p1;
pub const ERROR_GROUP_EXISTS = @as(c_long, 1318);
pub const CTRY_KUWAIT = 965;
pub const CRL_REASON_REMOVE_FROM_CRL = 8;
pub const LOCALE_SABBREVMONTHNAME8 = 75;
pub const EXDEV = 18;
pub const PRODUCT_UNDEFINED = 0;
pub const BCRYPT_ECDH_PRIVATE_P256_MAGIC = 843793221;
pub const MDM_PROTOCOLID_V120 = 5;
pub const THREAD_QUERY_LIMITED_INFORMATION = 2048;
pub const NCBHANGUP = 18;
pub const BSM_NETDRIVER = 2;
pub const ERROR_CALLBACK_POP_STACK = @as(c_long, 768);
pub const ERROR_TXF_DIR_NOT_EMPTY = @as(c_long, 6826);
pub const OUT_STRING_PRECIS = 1;
pub const FILE_DEVICE_STORAGE_REPLICATION = 85;
pub const CERT_FIND_ANY = CERT_COMPARE_ANY << CERT_COMPARE_SHIFT;
pub const CRYPTPROTECT_FIRST_RESERVED_FLAGVAL = 268435455;
pub const WGL_SWAP_OVERLAY2 = 4;
pub const RPC_S_UNKNOWN_IF = @as(c_long, 1717);
pub const DT_NOPREFIX = 2048;
pub const RPC_C_QOS_CAPABILITIES_IGNORE_DELEGATE_FAILURE = 8;
pub const CopyFileTransacted = CopyFileTransactedA;
pub const TapeClassGuid = GUID_DEVINTERFACE_TAPE;
pub const WAVECAPS_LRVOLUME = 8;
pub const DC_MEDIATYPENAMES = 34;
pub const LBS_OWNERDRAWVARIABLE = @as(c_long, 32);
pub const SetConsoleNumberOfCommands = SetConsoleNumberOfCommandsA;
pub const stc22 = 1109;
pub const DATEFMT_ENUMPROC = DATEFMT_ENUMPROCA;
pub const szOID_RSA_MD4 = "1.2.840.113549.2.4";
pub const LOCALE_IMEASURE = 13;
pub const GetConsoleOriginalTitle = GetConsoleOriginalTitleA;
pub const ERROR_NETWORK_UNREACHABLE = @as(c_long, 1231);
pub const CERT_NCRYPT_KEY_HANDLE_PROP_ID = 78;
pub const _WIN32_IE_IE70 = 1792;
pub const NID_MULTI_INPUT = 64;
pub const CTL_FIND_NO_LIST_ID_CBDATA = 4294967295;
pub const ALG_SID_SHA_256 = 12;
pub const IMAGE_REL_SH3_TOKEN = 18;
pub const X509_SEQUENCE_OF_ANY = if (@typeId(@typeOf(34)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 34) else if (@typeId(@typeOf(34)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 34) else LPCSTR(34);
pub const DNS_ERROR_UNSECURE_PACKET = @as(c_long, 9505);
pub const SE_SIGNING_LEVEL_DYNAMIC_CODEGEN = 11;
pub const CRYPT_OID_DECODE_OBJECT_EX_FUNC = "CryptDllDecodeObjectEx";
pub const PORT_STATUS_OUT_OF_MEMORY = 9;
pub const CE_RXPARITY = 4;
pub const ERROR_INVALID_COMBOBOX_MESSAGE = @as(c_long, 1422);
pub const BACKUP_SPARSE_BLOCK = 9;
pub const GL_ID_NOMODULE = 1;
pub const VER_SUITE_EMBEDDEDNT = 64;
pub const sys_nerr = _sys_nerr;
pub const ENABLERELATIVEWIDTHS = 768;
pub const EVENT_OBJECT_DRAGDROPPED = 32806;
pub const URLACTION_HTML_REQUIRE_UTF8_DOCUMENT_CODEPAGE = 5644;
pub const PD_ENABLESETUPHOOK = 8192;
pub const MCI_OVLY_WHERE_VIDEO = @as(c_long, 1048576);
pub const EXCEPTION_FLT_STACK_CHECK = STATUS_FLOAT_STACK_CHECK;
pub const PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE = 31;
pub const EVENT_OBJECT_DESCRIPTIONCHANGE = 32781;
pub const MEM_RESERVE_PLACEHOLDER = 262144;
pub const CREATE_PROTECTED_PROCESS = 262144;
pub const ERROR_DS_DST_NC_MISMATCH = @as(c_long, 8486);
pub const mciGetDeviceID = mciGetDeviceIDA;
pub const URLACTION_ACTIVEX_TREATASUNTRUSTED = 4613;
pub const szOID_OIWDIR_md2RSA = "1.3.14.7.2.3.1";
pub const CERT_UNICODE_ATTR_ERR_INDEX_MASK = 63;
pub const AccessCheckByTypeResultListAndAuditAlarm = AccessCheckByTypeResultListAndAuditAlarmA;
pub const EMR_EOF = 14;
pub const PENARBITRATIONTYPE_MAX = 4;
pub const SUBLANG_SLOVAK_SLOVAKIA = 1;
pub const GWL_HWNDPARENT = -8;
pub const ERROR_NOT_A_CLOUD_FILE = @as(c_long, 376);
pub const SID_MAX_SUB_AUTHORITIES = 15;
pub const Uri_HAS_ZONE = 1 << Uri_PROPERTY_ZONE;
pub const DMPAPER_PENV_10 = 105;
pub const SHGFI_ADDOVERLAYS = 32;
pub const BCRYPT_SECRET_AGREEMENT_INTERFACE = 4;
pub const ERROR_DS_CANT_REPLACE_HIDDEN_REC = @as(c_long, 8424);
pub const ERROR_RESOURCE_TYPE_NOT_FOUND = @as(c_long, 1813);
pub const MDM_SHIFT_EXTENDEDINFO = MDM_SHIFT_BEARERMODE;
pub const ERROR_INVALID_ACCEL_HANDLE = @as(c_long, 1403);
pub const INPLACE_E_FIRST = @as(c_long, 2147746208);
pub const WM_ENTERSIZEMOVE = 561;
pub const MCI_BREAK = 2065;
pub const POINTER_FLAG_CANCELED = 32768;
pub const DNS_ERROR_INVALID_NSEC3_ITERATION_COUNT = @as(c_long, 9124);
pub const CERT_TRUST_PUB_ALLOW_END_USER_TRUST = 0;
pub const SUBLANG_SPANISH_DOMINICAN_REPUBLIC = 7;
pub const TIMESTAMP_FAILURE_BAD_FORMAT = 5;
pub const MEM_EXTENDED_PARAMETER_NONPAGED = 2;
pub const MoveFileEx = MoveFileExA;
pub const ERROR_REMOTE_FILE_VERSION_MISMATCH = @as(c_long, 6814);
pub const ILLUMINANT_DAYLIGHT = ILLUMINANT_C;
pub const FRAME_NONFPO = 3;
pub const ERROR_FILE_SYSTEM_LIMITATION = @as(c_long, 665);
pub const GR_GLOBAL = if (@typeId(@typeOf(-2)) == @import("builtin").TypeId.Pointer) @ptrCast(HANDLE, -2) else if (@typeId(@typeOf(-2)) == @import("builtin").TypeId.Int) @intToPtr(HANDLE, -2) else HANDLE(-2);
pub const IMAGE_NT_SIGNATURE = 17744;
pub const CertStrToName = CertStrToNameA;
pub const StartService = StartServiceA;
pub const SECURITY_SERVER_LOGON_RID = SECURITY_ENTERPRISE_CONTROLLERS_RID;
pub const DMLERR_SYS_ERROR = 16399;
pub const TC_CP_STROKE = 4;
pub const DT_SINGLELINE = 32;
pub const MCI_VD_GETDEVCAPS_FAST_RATE = @as(c_long, 16387);
pub const IO_REPARSE_TAG_UNHANDLED = @as(c_long, 2147483680);
pub const SHGetFileInfo = SHGetFileInfoA;
pub const TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MAX = 64;
pub const WM_HOTKEY = 786;
pub const DC_SMALLCAP = 2;
pub const ERROR_GENERIC_COMMAND_FAILED = @as(c_long, 14109);
pub const CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST = 2;
pub const CFG_CALL_TARGET_CONVERT_EXPORT_SUPPRESSED_TO_VALID = 4;
pub const FILE_ATTRIBUTE_REPARSE_POINT = 1024;
pub const PRODUCT_EMBEDDED = 65;
pub const DMMEDIA_STANDARD = 1;
pub const FILE_DEVICE_CONSOLE = 80;
pub const DETACHED_PROCESS = 8;
pub const PFD_DOUBLEBUFFER_DONTCARE = 1073741824;
pub const PSH_USEICONID = 4;
pub const IDLFLAG_FRETVAL = PARAMFLAG_FRETVAL;
pub const PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_DEFER = if (@typeId(@typeOf(i64 << 48)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), i64 << 48) else if (@typeId(@typeOf(i64 << 48)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), i64 << 48) else @as(c_uint, 0)(i64 << 48);
pub const ERROR_DS_CONFIDENTIALITY_REQUIRED = @as(c_long, 8237);
pub const ENOSYS = 40;
pub const ERROR_INSTALL_SOURCE_ABSENT = @as(c_long, 1612);
pub const STORAGE_DEVICE_POWER_CAP_VERSION_V1 = 1;
pub const SHTDN_REASON_MINOR_HUNG = 5;
pub const SERVICE_KERNEL_DRIVER = 1;
pub const ERROR_TIME_SKEW = @as(c_long, 1398);
pub const SPI_SETMOUSESIDEMOVETHRESHOLD = 137;
pub const ERROR_OUT_OF_STRUCTURES = @as(c_long, 84);
pub const RPC_TYPE_STRICT_CONTEXT_HANDLE = @as(c_ulong, 1073741824);
pub const TA_LEFT = 0;
pub const ERROR_CLOUD_FILE_REQUEST_ABORTED = @as(c_long, 393);
pub const SHTDN_REASON_MINOR_NETWORK_CONNECTIVITY = 20;
pub const DMLERR_DATAACKTIMEOUT = 16386;
pub const FILE_RENAME_FLAG_POSIX_SEMANTICS = 2;
pub const LGRPID_TRADITIONAL_CHINESE = 9;
pub const KP_KEYEXCHANGE_PIN = 32;
pub const ERROR_RANGE_NOT_FOUND = @as(c_long, 644);
pub const DMPAPER_STATEMENT = 6;
pub const PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_DEFER = 0 << 28;
pub const RIDI_PREPARSEDDATA = 536870917;
pub const SOFTDIST_ADSTATE_DOWNLOADED = 2;
pub const LOCALE_SABBREVMONTHNAME9 = 76;
pub const LMEM_DISCARDABLE = 3840;
pub const __UINTMAX_WIDTH__ = 64;
pub const STREAM_MODIFIED_WHEN_READ = 1;
pub const DS_ABSALIGN = @as(c_long, 1);
pub const ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE = @as(c_long, 5933);
pub const SHGNLI_USEURLEXT = 32;
pub const IMAGE_SUBSYSTEM_WINDOWS_CE_GUI = 9;
pub const CreateDirectoryEx = CreateDirectoryExA;
pub const ERROR_BAD_DEVICE_PATH = @as(c_long, 330);
pub const EMR_CREATEBRUSHINDIRECT = 39;
pub const ERROR_BADDB = @as(c_long, 1009);
pub const WGL_SWAP_OVERLAY3 = 8;
pub const ERROR_PARTITION_FAILURE = @as(c_long, 1105);
pub const ERROR_REGISTRY_CORRUPT = @as(c_long, 1015);
pub const URLACTION_HTML_SUBMIT_FORMS_TO = 5635;
pub const ERROR_DEVICE_REMOVED = @as(c_long, 1617);
pub const EnumResourceLanguages = EnumResourceLanguagesA;
pub const MIXERCONTROL_CT_CLASS_FADER = @as(c_long, 1342177280);
pub const DNS_ERROR_DWORD_VALUE_TOO_SMALL = @as(c_long, 9566);
pub const szOID_CERTSRV_CA_VERSION = "1.3.6.1.4.1.311.21.1";
pub const stc21 = 1108;
pub const GCLP_MENUNAME = -8;
pub const ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT = @as(c_long, 14103);
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ = @as(c_long, 13836);
pub const TRANSACTIONMANAGER_BIND_TRANSACTION = 32;
pub const ERROR_CANT_DELETE_LAST_ITEM = @as(c_long, 4335);
pub const DNS_ERROR_NO_DNS_SERVERS = @as(c_long, 9852);
pub const ERROR_INFLOOP_IN_RELOC_CHAIN = @as(c_long, 202);
pub const IO_REPARSE_TAG_HSM2 = @as(c_long, 2147483654);
pub const CERT_STORE_READONLY_FLAG = 32768;
pub const DMLERR_MEMORY_ERROR = 16392;
pub const CERT_STORE_PROV_LM_SYSTEM_STORE_FLAG = 16;
pub const MCI_DEVTYPE_FIRST = MCI_DEVTYPE_VCR;
pub const WHITEONBLACK = 2;
pub const NCRYPT_ISOLATED_KEY_FLAG_CREATED_IN_ISOLATION = 1;
pub const ERROR_JOURNAL_NOT_ACTIVE = @as(c_long, 1179);
pub const PRODUCT_ENTERPRISE_N = 27;
pub const PP_SMARTCARD_GUID = 45;
pub const CERT_TRUST_IS_PARTIAL_CHAIN = 65536;
pub const INDEXID_OBJECT = 0;
pub const ERROR_INVALID_ADDRESS = @as(c_long, 487);
pub const DOMAIN_ALIAS_RID_BACKUP_OPS = @as(c_long, 551);
pub const HC_GETNEXT = 1;
pub const PAN_PROP_VERY_EXPANDED = 7;
pub const USN_REASON_DATA_EXTEND = 2;
pub const SPI_GETUIEFFECTS = 4158;
pub const MNGOF_BOTTOMGAP = 2;
pub const ResetPrinter = ResetPrinterA;
pub const IMAGE_REL_AMD64_EHANDLER = 17;
pub const MUI_FORMAT_REG_COMPAT = 1;
pub const SCS_64BIT_BINARY = 6;
pub const CreateWindowEx = CreateWindowExA;
pub const HANDLE_FLAG_INHERIT = 1;
pub const IMAGE_DIRECTORY_ENTRY_TLS = 9;
pub const CommDlg_OpenSave_GetFilePath = CommDlg_OpenSave_GetFilePathA;
pub const VK_CONVERT = 28;
pub const XST_ADVDATAACKRCVD = 16;
pub const ERROR_EVT_CONFIGURATION_ERROR = @as(c_long, 15010);
pub const ERROR_VOLUME_CONTAINS_SYS_FILES = @as(c_long, 4337);
pub const GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT = 2;
pub const FACILITY_USER_MODE_SECURITY_CORE = 232;
pub const COLOR_DESKTOP = COLOR_BACKGROUND;
pub const MSGFLTINFO_NONE = 0;
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_TOO_SMALL = 68719476736;
pub const SPI_GETMOUSEHOVERHEIGHT = 100;
pub const IMAGE_REL_I386_TOKEN = 12;
pub const EV_CTS = 8;
pub const RESOURCEDISPLAYTYPE_ROOT = 7;
pub const SCardUIDlgSelectCard = SCardUIDlgSelectCardA;
pub const environ = _environ;
pub const szOID_WINDOWS_STORE_SIGNER = "1.3.6.1.4.1.311.76.3.1";
pub const ERROR_CLUSTER_NODE_NOT_FOUND = @as(c_long, 5042);
pub const __SIZE_FMTo__ = "llo";
pub const CERT_TRUST_SSL_HANDSHAKE_OCSP = 262144;
pub const ERROR_DOMAIN_CONTROLLER_EXISTS = @as(c_long, 1250);
pub const MAX_PERF_OBJECTS_IN_QUERY_FUNCTION = @as(c_long, 64);
pub const DCB_ACCUMULATE = 2;
pub const CreateJobObject = CreateJobObjectA;
pub const LoadLibrary = LoadLibraryA;
pub const MIM_MAXHEIGHT = 1;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_RIGHT = 213;
pub const PRINTER_NOTIFY_FIELD_PORT_NAME = 3;
pub const CreateSymbolicLinkTransacted = CreateSymbolicLinkTransactedA;
pub const EXCEPTION_FLT_DENORMAL_OPERAND = STATUS_FLOAT_DENORMAL_OPERAND;
pub const PROCESS_POWER_THROTTLING_CURRENT_VERSION = 1;
pub const SHOW_FULLSCREEN = 3;
pub const DMLERR_LOW_MEMORY = 16391;
pub const CERT_RDN_VIDEOTEX_STRING = 6;
pub const WS_TILED = WS_OVERLAPPED;
pub const RegLoadKey = RegLoadKeyA;
pub const CMSG_CONTENT_ENCRYPT_FREE_OBJID_FLAG = 2;
pub const URLACTION_HTML_INCLUDE_FILE_PATH = 5642;
pub const ERROR_SXS_COMPONENT_STORE_CORRUPT = @as(c_long, 14098);
pub const DBG_TERMINATE_THREAD = if (@typeId(@typeOf(@as(c_long, 1073807363))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 1073807363)) else if (@typeId(@typeOf(@as(c_long, 1073807363))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 1073807363)) else DWORD(@as(c_long, 1073807363));
pub const ERROR_IPSEC_MM_POLICY_NOT_FOUND = @as(c_long, 13004);
pub const X509_BIOMETRIC_EXT = if (@typeId(@typeOf(71)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 71) else if (@typeId(@typeOf(71)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 71) else LPCSTR(71);
pub const PORT_STATUS_NO_TONER = 6;
pub const ERROR_SAME_DRIVE = @as(c_long, 143);
pub const BCRYPT_DSA_ALG_HANDLE = if (@typeId(@typeOf(721)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 721) else if (@typeId(@typeOf(721)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 721) else BCRYPT_ALG_HANDLE(721);
pub const CFSTR_MIME_X_ICON = if (@typeId(@typeOf("image/x-icon")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "image/x-icon") else if (@typeId(@typeOf("image/x-icon")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "image/x-icon") else TEXT("image/x-icon");
pub const EXCEPTION_NESTED_CALL = 16;
pub const WGL_SWAPMULTIPLE_MAX = 16;
pub const OF_PARSE = 256;
pub const CMSG_CTRL_ADD_CMS_SIGNER_INFO = 20;
pub const SCHEME_OID_RETRIEVE_ENCODED_OBJECTW_FUNC = "SchemeDllRetrieveEncodedObjectW";
pub const TARGET_IS_NT60_OR_LATER = 1;
pub const GCPCLASS_POSTBOUNDRTL = 16;
pub const ERROR_DBG_TERMINATE_PROCESS = @as(c_long, 692);
pub const DNS_ERROR_NO_CREATE_CACHE_DATA = @as(c_long, 9713);
pub const AccessCheckByTypeResultListAndAuditAlarmByHandle = AccessCheckByTypeResultListAndAuditAlarmByHandleA;
pub const NCBACTION = 119;
pub const GCL_HICONSM = -34;
pub const TAPE_DRIVE_GET_ABSOLUTE_BLK = 1048576;
pub const MAX_LANA = 254;
pub const LOCALE_ILANGUAGE = 1;
pub const DM_PELSWIDTH = @as(c_long, 524288);
pub const EVENT_OBJECT_DESTROY = 32769;
pub const SO_MAXDG = 28681;
pub const FILESYSTEM_STATISTICS_TYPE_NTFS = 1;
pub const STREAM_LAYOUT_ENTRY_RESIDENT = 4;
pub const DDD_RAW_TARGET_PATH = 1;
pub const FSHIFT = 4;
pub const CF_PENDATA = 10;
pub const ERROR_SERVICE_NOTIFICATION = @as(c_long, 716);
pub const MB_RETRYCANCEL = @as(c_long, 5);
pub const MM_WOM_CLOSE = 956;
pub const VARCMP_NULL = 3;
pub const ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED = @as(c_long, 15107);
pub const MCI_WAVE_STATUS_CHANNELS = @as(c_long, 16386);
pub const MCI_WAVE_OFFSET = 1152;
pub const XSTATE_MASK_AVX = XSTATE_MASK_GSSE;
pub const BM_SETSTYLE = 244;
pub const DEBUG_ONLY_THIS_PROCESS = 2;
pub const SM_MOUSEHORIZONTALWHEELPRESENT = 91;
pub const ERROR_DBG_CONTROL_C = @as(c_long, 693);
pub const MCI_ANIM_WHERE_SOURCE = @as(c_long, 131072);
pub const X509_OCTET_STRING = if (@typeId(@typeOf(25)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 25) else if (@typeId(@typeOf(25)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 25) else LPCSTR(25);
pub const FACILITY_NULL = 0;
pub const CERT_SERVER_OCSP_RESPONSE_OPEN_PARA_WRITE_FLAG = 2;
pub const SM_CYVSCROLL = 20;
pub const CreateScalableFontResource = CreateScalableFontResourceA;
pub const URL_OID_CROSS_CERT_DIST_POINT = if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 8) else if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 8) else LPCSTR(8);
pub const GMEM_FIXED = 0;
pub const SND_NODEFAULT = 2;
pub const szOID_APPLICATION_CERT_POLICIES = "1.3.6.1.4.1.311.21.10";
pub const USN_REASON_EA_CHANGE = 1024;
pub const SEC_PROTECTED_IMAGE = 33554432;
pub const CRYPT_ASYNC_RETRIEVAL = 16;
pub const PSN_HELP = if (@typeId(@typeOf(-5)) == @import("builtin").TypeId.Pointer) @ptrCast(PSN_FIRST, -5) else if (@typeId(@typeOf(-5)) == @import("builtin").TypeId.Int) @intToPtr(PSN_FIRST, -5) else PSN_FIRST(-5);
pub const BCRYPT_TLS_CBC_HMAC_VERIFY_FLAG = 4;
pub const mmioInstallIOProc = mmioInstallIOProcA;
pub const PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_NO_REMOTE_RESERVED = if (@typeId(@typeOf(i64 << 52)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 52) else if (@typeId(@typeOf(i64 << 52)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 52) else @as(c_uint, 3)(i64 << 52);
pub const EVENT_UIA_EVENTID_END = 20223;
pub const WM_COMMAND = 273;
pub const CREATE_FORCEDOS = 8192;
pub const SECURITY_PROCESS_PROTECTION_TYPE_FULL_RID = @as(c_long, 1024);
pub const RTL_CRITICAL_SECTION_FLAG_STATIC_INIT = 67108864;
pub const FRAME_TRAP = 1;
pub const FOREGROUND_INTENSITY = 8;
pub const ERROR_PARTITION_TERMINATING = @as(c_long, 1184);
pub const stc20 = 1107;
pub const PROP_SM_CXDLG = 212;
pub const SECURITY_LOCAL_RID = @as(c_long, 0);
pub const __SIZEOF_INT__ = 4;
pub const ERROR_SXS_INVALID_ACTCTXDATA_FORMAT = @as(c_long, 14002);
pub const EVENT_SYSTEM_ARRANGMENTPREVIEW = 32790;
pub const LoadImage = LoadImageA;
pub const OWNER_SECURITY_INFORMATION = @as(c_long, 1);
pub const HWND_BOTTOM = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(HWND, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(HWND, 1) else HWND(1);
pub const LOCALE_ICURRENCY = 27;
pub const PSINJECT_PAGETRAILER = 103;
pub const JOB_OBJECT_UILIMIT_READCLIPBOARD = 2;
pub const MCI_SEQ_MAPPER = 65535;
pub const SEE_MASK_DEFAULT = 0;
pub const ERROR_STATE_WRITE_SETTING_FAILED = @as(c_long, 15808);
pub const STD_ERROR_HANDLE = if (@typeId(@typeOf(-12)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, -12) else if (@typeId(@typeOf(-12)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, -12) else DWORD(-12);
pub const MCI_OVLY_RECT = @as(c_long, 65536);
pub const BS_TEXT = @as(c_long, 0);
pub const MCI_ANIM_PUT_SOURCE = @as(c_long, 131072);
pub const CERT_FIND_OPTIONAL_CTL_USAGE_FLAG = CERT_FIND_OPTIONAL_ENHKEY_USAGE_FLAG;
pub const DMPAPER_9X11 = 44;
pub const IMAGE_REL_AMD64_INDIR_BR_SWITCHTABLE_LAST = 47;
pub const CERT_STORE_PROV_WRITE_CERT_FUNC = 2;
pub const C3_NOTAPPLICABLE = 0;
pub const EVENT_SYSTEM_MINIMIZESTART = 22;
pub const PARTITION_DPP = 44;
pub const GetPrinterDriverPackagePath = GetPrinterDriverPackagePathA;
pub const EnumCalendarInfo = EnumCalendarInfoA;
pub const CRYPT_FORCE_KEY_PROTECTION_HIGH = 32768;
pub const __ATOMIC_ACQ_REL = 4;
pub const szOID_ANSI_X942 = "1.2.840.10046";
pub const PIDSI_LASTAUTHOR = @as(c_long, 8);
pub const SECURITY_CRED_TYPE_THIS_ORG_CERT_RID = @as(c_long, 1);
pub const PRODUCT_IOTENTERPRISES = 191;
pub const CTRY_LIECHTENSTEIN = 41;
pub const DOMAIN_ALIAS_RID_ACCESS_CONTROL_ASSISTANCE_OPS = @as(c_long, 579);
pub const PROV_RNG = 21;
pub const PSH_USEHBMWATERMARK = 65536;
pub const ERROR_CANNOT_SWITCH_RUNLEVEL = @as(c_long, 15400);
pub const URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY = 4610;
pub const CopyMemory = RtlCopyMemory;
pub const VIF_CANNOTDELETE = @as(c_long, 4096);
pub const IMAGE_REL_ALPHA_HINT = 8;
pub const ERROR_DEVICE_DOOR_OPEN = @as(c_long, 1166);
pub const DCX_INTERSECTUPDATE = @as(c_long, 512);
pub const I_RpcServerUseProtseq2 = I_RpcServerUseProtseq2A;
pub const CRYPTPROTECT_LOCAL_MACHINE = 4;
pub const szOID_FRESHEST_CRL = "2.5.29.46";
pub const MB_YESNO = @as(c_long, 4);
pub const ERROR_SECUREBOOT_NOT_BASE_POLICY = @as(c_long, 4434);
pub const FACILITY_SCARD = 16;
pub const URLACTION_INFODELIVERY_NO_EDITING_SUBSCRIPTIONS = 7428;
pub const MKF_LEFTBUTTONSEL = 268435456;
pub const EMR_RECTANGLE = 43;
pub const ERROR_DS_DRA_REF_ALREADY_EXISTS = @as(c_long, 8448);
pub const EM_LINEFROMCHAR = 201;
pub const MM_JOY1MOVE = 928;
pub const IDN_EMAIL_ADDRESS = 4;
pub const CTRY_SWEDEN = 46;
pub const XSTATE_LEGACY_SSE = 1;
pub const ERROR_INVALID_SUB_AUTHORITY = @as(c_long, 1335);
pub const PRINTER_ATTRIBUTE_TS = 32768;
pub const DEACTIVATE_ACTCTX_FLAG_FORCE_EARLY_DEACTIVATION = 1;
pub const _Analysis_assume_ = expr;
pub const IMAGE_REL_MIPS_SECRELLO = 12;
pub const ERROR_DS_LDAP_SEND_QUEUE_FULL = @as(c_long, 8616);
pub const PARITY_NONE = if (@typeId(@typeOf(256)) == @import("builtin").TypeId.Pointer) @ptrCast(WORD, 256) else if (@typeId(@typeOf(256)) == @import("builtin").TypeId.Int) @intToPtr(WORD, 256) else WORD(256);
pub const SUBLANG_LATVIAN_LATVIA = 1;
pub const LCMAP_KATAKANA = 2097152;
pub const ERROR_DS_LOOP_DETECT = @as(c_long, 8246);
pub const USN_DELETE_VALID_FLAGS = 3;
pub const FACILITY_CONTROL = 10;
pub const FACILITY_SETUPAPI = 15;
pub const STATUS_INTEGER_OVERFLOW = if (@typeId(@typeOf(@as(c_long, 3221225621))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225621)) else if (@typeId(@typeOf(@as(c_long, 3221225621))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225621)) else DWORD(@as(c_long, 3221225621));
pub const PSIDENT_PSCENTRIC = 1;
pub const SMART_NOT_SUPPORTED = 9;
pub const QUERY_FILE_LAYOUT_INCLUDE_NAMES = 2;
pub const POINTER_MESSAGE_FLAG_INCONTACT = 4;
pub const SM_CYHSCROLL = 3;
pub const IMAGE_REL_ARM64_BRANCH19 = 15;
pub const ERROR_LOGON_TYPE_NOT_GRANTED = @as(c_long, 1385);
pub const EM_LINELENGTH = 193;
pub const HINSTANCE_ERROR = 32;
pub const PRODUCT_CLOUD_STORAGE_SERVER = 110;
pub const RC_GDI20_OUTPUT = 16;
pub const CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED = 10;
pub const __byte_readableTo = size;
pub const ImmGetImeMenuItems = ImmGetImeMenuItemsA;
pub const NIIF_USER = 4;
pub const _WIN32_IE_WIN98 = _WIN32_IE_IE401;
pub const EPROTONOSUPPORT = 135;
pub const MDM_MASK_HDLCPPP_ML = 3 << 6;
pub const POWERBUTTON_ACTION_INDEX_SLEEP = 1;
pub const PDC_MODE_DEFAULT = 64;
pub const CRYPT_ACQUIRE_COMPARE_KEY_FLAG = 4;
pub const ERROR_DS_DRA_DN_EXISTS = @as(c_long, 8441);
pub const JOB_OBJECT_MSG_NOTIFICATION_LIMIT = 11;
pub const TRANSFORM_CTM = 4107;
pub const IMAGE_REL_CEE_ADDR64 = 2;
pub const BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE = 65536;
pub const PRODUCT_ULTIMATE_N = 28;
pub const MB_USEGLYPHCHARS = 4;
pub const RPC_S_UNSUPPORTED_TRANS_SYN = @as(c_long, 1730);
pub const END_PATH = 4098;
pub const ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY = @as(c_long, 6824);
pub const LB_SELITEMRANGEEX = 387;
pub const RPCFLG_ACCESS_LOCAL = @as(c_ulong, 4194304);
pub const VK_OEM_MINUS = 189;
pub const VP_CP_TYPE_MACROVISION = 2;
pub const ERROR_IPSEC_IKE_INVALID_HASH = @as(c_long, 13870);
pub const SE_ERR_FNF = 2;
pub const Uri_CREATE_NO_CANONICALIZE = 16;
pub const WNetCancelConnection = WNetCancelConnectionA;
pub const ERROR_MEMBER_IN_ALIAS = @as(c_long, 1378);
pub const X509_NAME = if (@typeId(@typeOf(7)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 7) else if (@typeId(@typeOf(7)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 7) else LPCSTR(7);
pub const FOF_WANTNUKEWARNING = 16384;
pub const ERROR_RM_NOT_ACTIVE = @as(c_long, 6801);
pub const X509_DH_PUBLICKEY = X509_MULTI_BYTE_UINT;
pub const ACTIVEOBJECT_WEAK = 1;
pub const DST_COMPLEX = 0;
pub const DMPAPER_ENV_14 = 23;
pub const szOID_RSA_PSPECIFIED = "1.2.840.113549.1.1.9";
pub const ERROR_SXS_DUPLICATE_ACTIVATABLE_CLASS = @as(c_long, 14111);
pub const InterlockedXorNoFence = _InterlockedXor;
pub const POWER_USER_NOTIFY_BUTTON = 8;
pub const CRYPT_OBJECT_LOCATOR_LAST_RESERVED_USER_NAME_TYPE = 65535;
pub const ERROR_PROCESS_MODE_NOT_BACKGROUND = @as(c_long, 403);
pub const IGIMIF_RIGHTMENU = 1;
pub const WGL_SWAP_OVERLAY1 = 2;
pub const CERT_STORE_ADD_ALWAYS = 4;
pub const R2_MERGENOTPEN = 12;
pub const ALERT_SYSTEM_INFORMATIONAL = 1;
pub const InterlockedExchangeAddAcquire64 = _InterlockedExchangeAdd64;
pub const VRL_ENABLE_KERNEL_BREAKS = 1 << 31;
pub const IO_REPARSE_TAG_SIS = @as(c_long, 2147483655);
pub const X3_EMPTY_INST_VAL_POS_X = 0;
pub const GETSETPRINTORIENT = 30;
pub const szOID_ROOT_PROGRAM_NO_OCSP_FAILOVER_TO_CRL = "1.3.6.1.4.1.311.60.3.3";
pub const SHUTDOWN_HYBRID = 512;
pub const FAST_FAIL_APCS_DISABLED = 32;
pub const EncryptFile = EncryptFileA;
pub const ERROR_NO_RECOVERY_PROGRAM = @as(c_long, 1082);
pub const APD_COPY_ALL_FILES = 4;
pub const BroadcastSystemMessageEx = BroadcastSystemMessageExA;
pub const COLOR_3DSHADOW = COLOR_BTNSHADOW;
pub const MAPVK_VSC_TO_VK = 1;
pub const stc27 = 1114;
pub const SUBLANG_SAMI_SOUTHERN_NORWAY = 6;
pub const ERROR_DS_RESERVED_LINK_ID = @as(c_long, 8576);
pub const IMAGE_SCN_ALIGN_128BYTES = 8388608;
pub const STORAGE_HW_FIRMWARE_REVISION_LENGTH = 16;
pub const ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND = @as(c_long, 13014);
pub const SCardGetStatusChange = SCardGetStatusChangeA;
pub const WINSWDEVICEAPI = DECLSPEC_IMPORT;
pub const PORT_STATUS_PAPER_JAM = 2;
pub const ERROR_DS_THREAD_LIMIT_EXCEEDED = @as(c_long, 8587);
pub const ACTCTX_FLAG_RESOURCE_NAME_VALID = 8;
pub const ERROR_DS_MAPI_ID_NOT_AVAILABLE = @as(c_long, 8632);
pub const MIM_LONGDATA = MM_MIM_LONGDATA;
pub const PROCESSOR_PERF_BOOST_MODE_ENABLED = 1;
pub const RESOURCE_ENUM_MUI = 2;
pub const DEVICEFAMILYDEVICEFORM_DIGITAL_SIGNAGE = 16;
pub const DDL_EXCLUSIVE = 32768;
pub const PRODUCT_HOME_BASIC = 2;
pub const DOMAIN_ALIAS_RID_DEFAULT_ACCOUNT = @as(c_long, 581);
pub const RI_MOUSE_BUTTON_4_DOWN = 64;
pub const FAST_FAIL_DEPRECATED_SERVICE_INVOKED = 27;
pub const SUBVERSION_MASK = 255;
pub const ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END = @as(c_long, 13909);
pub const SHTDN_REASON_MINOR_POWER_SUPPLY = 10;
pub const IMC_SETCANDIDATEPOS = 8;
pub const RpcBindingInqAuthClient = RpcBindingInqAuthClientA;
pub const I_RpcServerUseProtseqEp2 = I_RpcServerUseProtseqEp2A;
pub const STATUS_ARRAY_BOUNDS_EXCEEDED = if (@typeId(@typeOf(@as(c_long, 3221225612))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225612)) else if (@typeId(@typeOf(@as(c_long, 3221225612))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225612)) else DWORD(@as(c_long, 3221225612));
pub const CERT_LDAP_STORE_AREC_EXCLUSIVE_FLAG = 131072;
pub const EnumDateFormats = EnumDateFormatsA;
pub const SPACES_TRACKED_OFFSET_HEADER_FLAG = 2;
pub const DNS_ERROR_ZONE_HAS_NO_NS_RECORDS = @as(c_long, 9606);
pub const MMIO_READWRITE = 2;
pub const LPFNPSPCALLBACK = LPFNPSPCALLBACKA;
pub const WM_MOUSELAST = 526;
pub const MSGF_SCROLLBAR = 5;
pub const PRINTER_ENUM_ICON8 = 8388608;
pub const PD_RESULT_PRINT = 1;
pub const FILE_READ_DATA = 1;
pub const CERT_REGISTRY_STORE_SERIALIZED_FLAG = 131072;
pub const SM_CARETBLINKINGENABLED = 8194;
pub const RPC_S_UUID_LOCAL_ONLY = @as(c_long, 1824);
pub const PAN_XHEIGHT_DUCKING_LARGE = 7;
pub const WRITE_OWNER = @as(c_long, 524288);
pub const InterlockedOr8 = _InterlockedOr8;
pub const DNS_REGISTER = 1;
pub const szPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS = "PrivKeyCachePurgeIntervalSeconds";
pub const DNS_ERROR_POLICY_MISSING_CRITERIA = @as(c_long, 9983);
pub const ERROR_IPSEC_IKE_CGA_AUTH_FAILED = @as(c_long, 13892);
pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE = @as(c_long, 13906);
pub const GetCurrentDirectory = GetCurrentDirectoryA;
pub const PIPE_READMODE_BYTE = 0;
pub const PP_USE_HARDWARE_RNG = 38;
pub const XSTATE_AVX = XSTATE_GSSE;
pub const CMC_STATUS_NO_SUPPORT = 4;
pub const NIIF_WARNING = 2;
pub const CP_NONE = 0;
pub const MB_OK = @as(c_long, 0);
pub const CTRY_FRANCE = 33;
pub const PROTECTION_LEVEL_PPL_APP = 8;
pub const DNS_ERROR_INVALID_CLIENT_SUBNET_NAME = @as(c_long, 9984);
pub const __XSAVE__ = 1;
pub const IME_CMODE_ALPHANUMERIC = 0;
pub const szOID_KP_DOCUMENT_SIGNING = "1.3.6.1.4.1.311.10.3.12";
pub const WH_SHELL = 10;
pub const MDM_MASK_PROTOCOLID = 983040;
pub const ua_tcscpy_s = strcpy_s;
pub const APPCOMMAND_MICROPHONE_VOLUME_DOWN = 25;
pub const CBS_DROPDOWNLIST = @as(c_long, 3);
pub const WOW64_CONTEXT_i386 = 65536;
pub const LANG_MARATHI = 78;
pub const IMAGE_WEAK_EXTERN_SEARCH_ALIAS = 3;
pub const PRODUCT_HOME_PREMIUM_SERVER = 34;
pub const SPI_SETACTIVEWNDTRKZORDER = 4109;
pub const ERROR_DS_MISSING_SUPREF = @as(c_long, 8406);
pub const DMORIENT_LANDSCAPE = 2;
pub const MFS_ENABLED = MF_ENABLED;
pub const COPY_FILE_IGNORE_EDP_BLOCK = 4194304;
pub const ERROR_MRM_PACKAGE_NOT_FOUND = @as(c_long, 15159);
pub const CRYPT_FORMAT_RDN_SEMICOLON = 256;
pub const FILE_DEVICE_NVDIMM = 90;
pub const EVENT_OBJECT_CREATE = 32768;
pub const DROPEFFECT_SCROLL = 2147483648;
pub const ERROR_SXS_INVALID_XML_NAMESPACE_URI = @as(c_long, 14014);
pub const GMEM_LOCKCOUNT = 255;
pub const STORAGE_ADDRESS_TYPE_BTL8 = 0;
pub const QUERY_STORAGE_CLASSES_FLAGS_MEASURE_WRITE = 2147483648;
pub const CERT_STORE_PROV_FIND_CRL_FUNC = 17;
pub const SERVICE_STOP_REASON_MINOR_ENVIRONMENT = 10;
pub const URLACTION_SHELL_MAX = 6655;
pub const ULW_OPAQUE = 4;
pub const ERROR_INVALID_THREAD_ID = @as(c_long, 1444);
pub const __analysis_assume = expr;
pub const ERROR_DS_CANT_CREATE_UNDER_SCHEMA = @as(c_long, 8510);
pub const RPC_C_PROTECT_LEVEL_PKT_PRIVACY = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
pub const PIDDSI_DOCPARTS = 13;
pub const FACILITY_RESTORE = 256;
pub const MDM_HDLCPPP_AUTH_DEFAULT = 0;
pub const URLACTION_SCRIPT_JAVA_USE = 5122;
pub const ERROR_NO_SAVEPOINT_WITH_OPEN_FILES = @as(c_long, 6842);
pub const CERT_PROT_ROOT_INHIBIT_PURGE_LM_FLAG = 4;
pub const BCRYPTBUFFER_VERSION = 0;
pub const SM_CXFOCUSBORDER = 83;
pub const PSD_DISABLEPAPER = 512;
pub const CRYPT_PARAM_ASYNC_RETRIEVAL_COMPLETION = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 1) else LPCSTR(1);
pub const __UINT32_FMTX__ = "X";
pub const ERROR_DOMAIN_SID_SAME_AS_LOCAL_WORKSTATION = @as(c_long, 8644);
pub const DMLERR_NOTPROCESSED = 16393;
pub const CRYPT_UM = 1;
pub const VTA_BOTTOM = TA_RIGHT;
pub const VFT_DRV = @as(c_long, 3);
pub const ERROR_DS_NO_SUCH_OBJECT = @as(c_long, 8240);
pub const CB_DELETESTRING = 324;
pub const IMAGE_REL_MIPS_ABSOLUTE = 0;
pub const FILE_ACTION_RENAMED_OLD_NAME = 4;
pub const IMN_SETCOMPOSITIONFONT = 10;
pub const DUPLICATE_CLOSE_SOURCE = 1;
pub const RES_ICON = 1;
pub const WGL_SWAP_OVERLAY6 = 64;
pub const szOID_RDN_TPM_MODEL = "2.23.133.2.2";
pub const szOID_ATTR_PLATFORM_SPECIFICATION = "2.23.133.2.17";
pub const SERVICE_TRIGGER_TYPE_GROUP_POLICY = 5;
pub const RpcServerRegisterAuthInfo = RpcServerRegisterAuthInfoA;
pub const PD_NOPAGENUMS = 8;
pub const CRYPT_FASTSGC = 2;
pub const PIDDSI_PRESFORMAT = 3;
pub const RPC_IF_SEC_NO_CACHE = 64;
pub const IMAGE_REL_MIPS_SECRELHI = 13;
pub const stc26 = 1113;
pub const DDD_NO_BROADCAST_SYSTEM = 8;
pub const VIEW_E_FIRST = @as(c_long, 2147746112);
pub const ERROR_INSUFFICIENT_LOGON_INFO = @as(c_long, 608);
pub const BCRYPT_SIGNATURE_INTERFACE = 5;
pub const LOAD_LIBRARY_REQUIRE_SIGNED_TARGET = 128;
pub const MKF_HOTKEYSOUND = 16;
pub const GWL_USERDATA = -21;
pub const SERVICE_LAUNCH_PROTECTED_NONE = 0;
pub const szOID_RSA_DH = "1.2.840.113549.1.3.1";
pub const STATUS_UNWIND_CONSOLIDATE = if (@typeId(@typeOf(@as(c_long, 2147483689))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 2147483689)) else if (@typeId(@typeOf(@as(c_long, 2147483689))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 2147483689)) else DWORD(@as(c_long, 2147483689));
pub const WSASYSCALLFAILURE = @as(c_long, 10107);
pub const CERT_TRUST_IS_EXPLICIT_DISTRUST = 67108864;
pub const XACT_E_LAST = 2147799083;
pub const ERROR_WMI_ITEMID_NOT_FOUND = @as(c_long, 4202);
pub const HP_TLS1PRF_SEED = 7;
pub const LOCALE_SINTLSYMBOL = 21;
pub const DFCS_INACTIVE = 256;
pub const PEERDIST_ERROR_ALREADY_INITIALIZED = @as(c_long, 4055);
pub const DISPLAYCONFIG_TARGET_FORCIBLE = 2;
pub const ERROR_DS_INVALID_DN_SYNTAX = @as(c_long, 8242);
pub const ERROR_SLOT_NOT_PRESENT = 4;
pub const X3_EMPTY_INST_WORD_POS_X = 14;
pub const SUBLANG_FULAH_SENEGAL = 2;
pub const STGM_NOSNAPSHOT = @as(c_long, 2097152);
pub const ERROR_INSTALL_PACKAGE_REJECTED = @as(c_long, 1625);
pub const BCRYPT_OBJECT_ALIGNMENT = 16;
pub const AUTHTYPE_CLIENT = 1;
pub const ERROR_DS_DRA_SINK_DISABLED = @as(c_long, 8457);
pub const MIXERCONTROL_CT_SC_TIME_MILLISECS = @as(c_long, 16777216);
pub const RGN_ERROR = ERROR;
pub const WM_GETDPISCALEDSIZE = 740;
pub const NRC_ENVNOTDEF = 52;
pub const CBS_LOWERCASE = @as(c_long, 16384);
pub const JOYCAPS_HASPOV = 16;
pub const HS_HORIZONTAL = 0;
pub const SECURITY_CAPABILITY_SHARED_USER_CERTIFICATES = @as(c_long, 9);
pub const UNW_FLAG_NO_EPILOGUE = @as(c_ulong, 2147483648);
pub const MCI_VD_SEEK_REVERSE = @as(c_long, 65536);
pub const ERROR_NOT_READY = @as(c_long, 21);
pub const ERROR_INSTALL_PACKAGE_INVALID = @as(c_long, 1620);
pub const IMAGE_FILE_NET_RUN_FROM_SWAP = 2048;
pub const CF_ANSIONLY = @as(c_long, 1024);
pub const CC_ANYCOLOR = 256;
pub const VK_CLEAR = 12;
pub const FILE_INITIATE_REPAIR_HINT1_DENY_DEFRAG = 274877906944;
pub const ERROR_MCA_OCCURED = @as(c_long, 651);
pub const SCARD_READER_TYPE_VENDOR = 240;
pub const IMFS_GRAYED = MFS_GRAYED;
pub const CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG = 1;
pub const ERROR_REGISTRY_IO_FAILED = @as(c_long, 1016);
pub const RpcNotificationCallStatusChange = RpcNotificationClientDisconnect;
pub const XST_EXECACKRCVD = 10;
pub const SPI_SETCLIENTAREAANIMATION = 4163;
pub const __INT_LEAST16_FMTd__ = "hd";
pub const DMPAPER_TABLOID_EXTRA = 52;
pub const DFCS_MENUBULLET = 2;
pub const OCSP_SIG_REQUIRED_RESPONSE = 5;
pub const WSAENETUNREACH = @as(c_long, 10051);
pub const __INT_LEAST64_FMTd__ = "lld";
pub const RPC_C_AUTHN_DCE_PRIVATE = 1;
pub const PROCESS_CREATION_MITIGATION_POLICY_DEP_ATL_THUNK_ENABLE = 2;
pub const MCI_ANIM_STATUS_STRETCH = @as(c_long, 16389);
pub const STREAM_SET_ENCRYPTION = 3;
pub const IMAGE_REL_M32R_ABSOLUTE = 0;
pub const DISPID_COLLECT = -8;
pub const MAXIMUM_SUSPEND_COUNT = MAXCHAR;
pub const OEM_CHARSET = 255;
pub const WM_SYSDEADCHAR = 263;
pub const GL_ID_PRIVATE_LAST = 65535;
pub const WH_CALLWNDPROCRET = 12;
pub const BS_BOTTOM = @as(c_long, 2048);
pub const FOREGROUND_GREEN = 2;
pub const CRYPT_MIN_DEPENDENCIES = 1;
pub const PEN_FLAG_INVERTED = 2;
pub const PROCESS_CREATION_MITIGATION_POLICY2_SPECULATIVE_STORE_BYPASS_DISABLE_ALWAYS_OFF = if (@typeId(@typeOf(i64 << 24)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 2), i64 << 24) else if (@typeId(@typeOf(i64 << 24)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 2), i64 << 24) else @as(c_uint, 2)(i64 << 24);
pub const EOWNERDEAD = 133;
pub const ERROR_IPSEC_IKE_INVALID_SIGNATURE = @as(c_long, 13826);
pub const WNCON_SLOWLINK = 4;
pub const SCARD_CLASS_PROTOCOL = 3;
pub const ERROR_IPSEC_IKE_FAILQUERYSSP = @as(c_long, 13854);
pub const _Requires_lock_not_held_ = lock;
pub const __amd64__ = 1;
pub const ERROR_SXS_UNKNOWN_ENCODING_GROUP = @as(c_long, 14012);
pub const LBS_HASSTRINGS = @as(c_long, 64);
pub const __PTRDIFF_FMTi__ = "lli";
pub const SECURITY_MANDATORY_MEDIUM_RID = @as(c_long, 8192);
pub const SECURITY_PROCESS_TRUST_AUTHORITY_RID_COUNT = @as(c_long, 2);
pub const PSPCB_CREATE = 2;
pub const szOID_VERISIGN_ONSITE_JURISDICTION_HASH = "2.16.840.1.113733.1.6.11";
pub const SID_SBindHost = IID_IBindHost;
pub const MUI_QUERY_LANGUAGE_NAME = 4;
pub const RESOURCE_ENUM_MODULE_EXACT = 16;
pub const PFD_STEREO = 2;
pub const SERIAL_IOC_FCR_RCVR_TRIGGER_LSB = if (@typeId(@typeOf(64)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 64) else if (@typeId(@typeOf(64)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 64) else DWORD(64);
pub const S_SERDSR = -15;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_TABLET = 13;
pub const ERROR_NT_CROSS_ENCRYPTION_REQUIRED = @as(c_long, 1386);
pub const X3_IMM20_INST_WORD_POS_X = 4;
pub const CERT_ALT_NAME_ENTRY_ERR_INDEX_MASK = 255;
pub const _CRT_FUNCTIONS_REQUIRED = 1;
pub const ETIMEDOUT = 138;
pub const InterlockedDecrementRelease64 = _InterlockedDecrement64;
pub const ARW_LEFT = @as(c_long, 0);
pub const SCARD_STATE_UNKNOWN = 4;
pub const QUERY_STORAGE_CLASSES_FLAGS_NO_DEFRAG_VOLUME = 536870912;
pub const PSN_KILLACTIVE = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(PSN_FIRST, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(PSN_FIRST, -1) else PSN_FIRST(-1);
pub const WN_CONNECTED_OTHER_PASSWORD_DEFAULT = ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT;
pub const GetFinalPathNameByHandle = GetFinalPathNameByHandleA;
pub const STATUS_NO_MEMORY = if (@typeId(@typeOf(@as(c_long, 3221225495))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225495)) else if (@typeId(@typeOf(@as(c_long, 3221225495))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225495)) else DWORD(@as(c_long, 3221225495));
pub const WGL_SWAP_OVERLAY7 = 128;
pub const szOID_NT5_CRYPTO = "1.3.6.1.4.1.311.10.3.6";
pub const BSF_IGNORECURRENTTASK = 2;
pub const _countof = __crt_countof;
pub const DMDO_90 = 1;
pub const EN_AFTER_PASTE = 2049;
pub const CRL_REASON_CERTIFICATE_HOLD = 6;
pub const CMS_SIGNER_INFO = if (@typeId(@typeOf(501)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 501) else if (@typeId(@typeOf(501)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 501) else LPCSTR(501);
pub const CM_SERVICE_RAM_DISK_BOOT_LOAD = 256;
pub const FAST_FAIL_GUARD_ICALL_CHECK_FAILURE = 10;
pub const GetOpenCardName = GetOpenCardNameA;
pub const VAR_LOCALBOOL = if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 16) else if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 16) else DWORD(16);
pub const stc25 = 1112;
pub const FS_GREEK = @as(c_long, 8);
pub const CLIP_MASK = 15;
pub const FILE_DEVICE_SERIAL_MOUSE_PORT = 26;
pub const VarDateFromInt = VarDateFromI4;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_WINTCB_RID = @as(c_long, 8192);
pub const KP_CERTIFICATE = 26;
pub const CMSG_CTRL_ADD_CRL = 12;
pub const EnumFontFamilies = EnumFontFamiliesA;
pub const DMPAPER_A5_EXTRA = 64;
pub const ERROR_WRONG_PASSWORD = @as(c_long, 1323);
pub const VK_GAMEPAD_LEFT_THUMBSTICK_UP = 211;
pub const SPI_GETMESSAGEDURATION = 8214;
pub const ERROR_INVALID_PRINTER_DRIVER_MANIFEST = @as(c_long, 3021);
pub const SUBLANG_URDU_PAKISTAN = 1;
pub const RTL_CORRELATION_VECTOR_VERSION_1 = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(CHAR, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(CHAR, 1) else CHAR(1);
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_HANDHELD = 12;
pub const ERROR_DS_NON_ASQ_SEARCH = @as(c_long, 8624);
pub const R2_MASKPEN = 9;
pub const KDF_SECRET_APPEND = 2;
pub const REGULAR_FONTTYPE = 1024;
pub const PS_STYLE_MASK = 15;
pub const ERROR_EVT_UNRESOLVED_PARAMETER_INSERT = @as(c_long, 15030);
pub const FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS = 4194304;
pub const VK_ZOOM = 251;
pub const THAI_CHARSET = 222;
pub const IMAGE_REL_MIPS_REFLO = 5;
pub const PP_ENUMCONTAINERS = 2;
pub const ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC = @as(c_long, 8553);
pub const STATUS_FLOAT_DIVIDE_BY_ZERO = if (@typeId(@typeOf(@as(c_long, 3221225614))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225614)) else if (@typeId(@typeOf(@as(c_long, 3221225614))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225614)) else DWORD(@as(c_long, 3221225614));
pub const ERROR_SHARING_BUFFER_EXCEEDED = @as(c_long, 36);
pub const ERROR_EVT_NON_VALIDATING_MSXML = @as(c_long, 15013);
pub const SOUND_SYSTEM_MENUPOPUP = 16;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER_CORE = 45;
pub const WNetUseConnection = WNetUseConnectionA;
pub const PRINTER_ENUM_DEFAULT = 1;
pub const META_ANIMATEPALETTE = 1078;
pub const REG_NOTIFY_THREAD_AGNOSTIC = @as(c_long, 268435456);
pub const GUI_16BITTASK = 0;
pub const CHANGER_VOLUME_REPLACE = 8388608;
pub const JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE = 8192;
pub const MCI_VD_PLAY_SCAN = @as(c_long, 524288);
pub const ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION = @as(c_long, 6831);
pub const CRYPT_PROXY_CACHE_RETRIEVAL = 2097152;
pub const INHERIT_ONLY_ACE = 8;
pub const PRINTER_CHANGE_SET_JOB = 512;
pub const ERROR_DS_NAME_TOO_LONG = @as(c_long, 8348);
pub const CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_URL_FLAG = 4;
pub const ENABLE_WINDOW_INPUT = 8;
pub const EVENT_SYSTEM_CAPTURESTART = 8;
pub const sz_CERT_STORE_PROV_PHYSICAL_W = "Physical";
pub const URLACTION_SHELL_SHELLEXECUTE = 6150;
pub const SUBLANG_SANSKRIT_INDIA = 1;
pub const szOID_REMOVE_CERTIFICATE = "1.3.6.1.4.1.311.10.8.1";
pub const FindFirstVolumeMountPoint = FindFirstVolumeMountPointA;
pub const IMAGE_REL_I386_REL32 = 20;
pub const SELECTPAPERSOURCE = 18;
pub const DNS_ERROR_RCODE_NAME_ERROR = @as(c_long, 9003);
pub const COLORRES = 108;
pub const SERVICE_TRIGGER_TYPE_CUSTOM = 20;
pub const X509_SUBJECT_DIR_ATTRS = if (@typeId(@typeOf(84)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 84) else if (@typeId(@typeOf(84)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 84) else LPCSTR(84);
pub const FACILITY_SECURITY = 9;
pub const __INTPTR_FMTi__ = "lli";
pub const ERROR_INVALID_CURSOR_HANDLE = @as(c_long, 1402);
pub const PERF_TYPE_TEXT = 2048;
pub const ERROR_TOO_MANY_POSTS = @as(c_long, 298);
pub const MCI_GETDEVCAPS = 2059;
pub const ERROR_IPSEC_IKE_AUTH_FAIL = @as(c_long, 13801);
pub const NID_READY = 128;
pub const RPC_C_BINDING_INFINITE_TIMEOUT = 10;
pub const POWER_USER_NOTIFY_SHUTDOWN = 16;
pub const NETINFO_DISKRED = 4;
pub const ERROR_MENU_ITEM_NOT_FOUND = @as(c_long, 1456);
pub const __fallthrough = __inner_fallthrough;
pub const szOID_ENROLL_EKVERIFYCREDS = "1.3.6.1.4.1.311.21.32";
pub const __drv_releasesExclusiveResource = kind;
pub const TAPE_DRIVE_TENSION_IMMED = 2147483712;
pub const DOMAIN_GROUP_RID_CONTROLLERS = @as(c_long, 516);
pub const PAN_MIDLINE_CONSTANT_POINTED = 9;
pub const SEE_MASK_FLAG_DDEWAIT = SEE_MASK_NOASYNC;
pub const PEN_MASK_NONE = 0;
pub const __UINT_LEAST8_FMTX__ = "hhX";
pub const CSV_QUERY_MDS_PATH_V2_VERSION_1 = 1;
pub const REG_FLUSH_HIVE_FILE_GROWTH = @as(c_long, 4096);
pub const szOID_CERT_MD5_HASH_PROP_ID = "1.3.6.1.4.1.311.10.11.4";
pub const WAVE_FORMAT_1S16 = 8;
pub const ERROR_PROFILING_NOT_STOPPED = @as(c_long, 551);
pub const CERT_ISSUER_CHAIN_SIGN_HASH_CNG_ALG_PROP_ID = 95;
pub const POWER_LEVEL_USER_NOTIFY_SOUND = 2;
pub const STRING_NONE = 1;
pub const EMR_SETWORLDTRANSFORM = 35;
pub const WNCON_DYNAMIC = 8;
pub const APPCOMMAND_DWM_FLIP3D = 54;
pub const DEVICE_DEFAULT_FONT = 14;
pub const SYSTEM_CPU_SET_INFORMATION_REALTIME = 8;
pub const JOB_OBJECT_CPU_RATE_CONTROL_VALID_FLAGS = 31;
pub const BCRYPT_DH_PUBLIC_MAGIC = 1112557636;
pub const ERROR_IS_SUBST_TARGET = @as(c_long, 149);
pub const SECURITY_THIS_ORGANIZATION_RID = @as(c_long, 15);
pub const POSTSCRIPT_INJECTION = 4118;
pub const CTRL_BREAK_EVENT = 1;
pub const CRYPT_CHECK_FRESHNESS_TIME_VALIDITY = 1024;
pub const PUBLICKEYBLOBEX = 10;
pub const ERROR_RESOURCEMANAGER_READ_ONLY = @as(c_long, 6707);
pub const MIXERLINE_TARGETTYPE_UNDEFINED = 0;
pub const SCARD_STATE_INUSE = 256;
pub const MCI_OVLY_OPEN_PARENT = @as(c_long, 131072);
pub const MAXDWORD32 = if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD32, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(DWORD32, 0) else DWORD32(0))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD32, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD32, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(DWORD32, 0) else DWORD32(0)) else if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD32, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(DWORD32, 0) else DWORD32(0))) == @import("builtin").TypeId.Int) @intToPtr(DWORD32, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD32, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(DWORD32, 0) else DWORD32(0)) else DWORD32(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD32, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(DWORD32, 0) else DWORD32(0));
pub const ERROR_DS_DS_REQUIRED = @as(c_long, 8478);
pub const FILE_INITIATE_REPAIR_HINT1_OUT_OF_RESOURCE = 2147483648;
pub const ERROR_DS_ROOT_CANT_BE_SUBREF = @as(c_long, 8326);
pub const EMR_STRETCHDIBITS = 81;
pub const SMTO_NORMAL = 0;
pub const WM_UNICHAR = 265;
pub const CREATE_NEW_PROCESS_GROUP = 512;
pub const mixerGetDevCaps = mixerGetDevCapsA;
pub const SERVICE_AUTO_START = 2;
pub const IME_ESC_HANJA_MODE = 4104;
pub const PRODUCT_IOTENTERPRISE = 188;
pub const WGL_SWAP_OVERLAY4 = 16;
pub const PPM_PERFORMANCE_IMPLEMENTATION_NONE = 0;
pub const SECURITY_PACKAGE_RID_COUNT = @as(c_long, 2);
pub const SCARD_READER_CONTACTLESS = 8;
pub const RECOVERY_DEFAULT_PING_INTERVAL = 5000;
pub const PAN_CONTRAST_HIGH = 8;
pub const IMAGE_REL_M32R_PCREL8 = 7;
pub const ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND = @as(c_long, 13013);
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_DESTINATION = @as(c_long, 5957);
pub const IME_ESC_QUERY_SUPPORT = 3;
pub const X509_EXTENSIONS = if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 5) else if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 5) else LPCSTR(5);
pub const RPC_BHO_EXCLUSIVE_AND_GUARANTEED = 4;
pub const stc24 = 1111;
pub const COMMON_LVB_UNDERSCORE = 32768;
pub const __DBL_MAX_10_EXP__ = 308;
pub const WC_DEFAULTCHAR = 64;
pub const GetLongPathNameTransacted = GetLongPathNameTransactedA;
pub const CMSG_DATA_FLAG = 1 << CMSG_DATA;
pub const PERF_SIZE_DWORD = 0;
pub const WM_COPY = 769;
pub const _WIN32_WINNT_WIN2K = 1280;
pub const DMRES_HIGH = -4;
pub const NTE_OP_OK = 0;
pub const LOCALE_SYEARMONTH = 4102;
pub const ERROR_THREAD_MODE_NOT_BACKGROUND = @as(c_long, 401);
pub const ENDSESSION_CRITICAL = 1073741824;
pub const SUBLANG_PUNJABI_PAKISTAN = 2;
pub const IO_REPARSE_TAG_PROJFS_TOMBSTONE = @as(c_long, 2684354594);
pub const RTL_CORRELATION_VECTOR_VERSION_2 = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(CHAR, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(CHAR, 2) else CHAR(2);
pub const szOID_AUTO_ENROLL_CTL_USAGE = "1.3.6.1.4.1.311.20.1";
pub const CRYPT_SIGN_ALG_OID_GROUP_ID = 4;
pub const EVENT_SYSTEM_MOVESIZESTART = 10;
pub const PSPROTOCOL_BCP = 1;
pub const SPI_GETBEEP = 1;
pub const PRINTRATEUNIT_LPM = 3;
pub const MCI_GETDEVCAPS_COMPOUND_DEVICE = @as(c_long, 6);
pub const IPPROTO_UDP = 17;
pub const URLOSTRM_USECACHEDCOPY_ONLY = 1;
pub const SM_CYSMICON = 50;
pub const ACCESS_ALLOWED_ACE_TYPE = 0;
pub const PARTITION_HUGE = 6;
pub const szOID_PKCS_12_pbeWithSHA1And40BitRC2 = "1.2.840.113549.1.12.1.6";
pub const CERT_AUTH_ROOT_CTL_FILENAME_A = "authroot.stl";
pub const Uri_CREATE_ALLOW_IMPLICIT_WILDCARD_SCHEME = 2;
pub const LANG_YAKUT = 133;
pub const WSA_QOS_EFILTERTYPE = @as(c_long, 11020);
pub const PERSISTENT_VOLUME_STATE_TXF_DISABLED = 256;
pub const IMAGE_REL_M32R_ADDR32NB = 2;
pub const _UNALIGNED = __unaligned;
pub const _Has_lock_kind_ = kind;
pub const SERVER_ACCESS_ADMINISTER = 1;
pub const JOB_OBJECT_UILIMIT_NONE = 0;
pub const ERROR_DS_NAME_UNPARSEABLE = @as(c_long, 8350);
pub const RPCFLG_NDR64_CONTAINS_ARM_LAYOUT = @as(c_ulong, 67108864);
pub const PSH_USEHPLWATERMARK = 131072;
pub const _Post_ = _Post_impl_;
pub const CERT_CHAIN_POLICY_SSL_F12_NONE_CATEGORY = 0;
pub const TIMESTAMP_FAILURE_POLICY_NOT_SUPPORTED = 15;
pub const VP_COMMAND_GET = 1;
pub const DMICMMETHOD_DRIVER = 3;
pub const CBR_38400 = 38400;
pub const mmioRename = mmioRenameA;
pub const CERT_STORE_ADD_REPLACE_EXISTING = 3;
pub const SUBLANG_ARABIC_UAE = 14;
pub const NCRYPT_SCHANNEL_SIGNATURE_INTERFACE = 65539;
pub const CERT_CHAIN_POLICY_SSL_F12_SUCCESS_LEVEL = 0;
pub const GetFileVersionInfoSize = GetFileVersionInfoSizeA;
pub const RPC_C_STATS_CALLS_IN = 0;
pub const ERROR_TOO_MANY_CONTEXT_IDS = @as(c_long, 1384);
pub const RPC_X_SS_IN_NULL_CONTEXT = @as(c_long, 1775);
pub const VarR8FromUint = VarR8FromUI4;
pub const WriteULongPtrNoFence = WriteULong64NoFence;
pub const ACCESS_MIN_MS_OBJECT_ACE_TYPE = 5;
pub const BAUD_4800 = if (@typeId(@typeOf(512)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 512) else if (@typeId(@typeOf(512)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 512) else DWORD(512);
pub const DNS_ERROR_INVALID_IP_ADDRESS = @as(c_long, 9552);
pub const GetProfileString = GetProfileStringA;
pub const DLGC_WANTCHARS = 128;
pub const __SAL_H_FULL_VER = 140050727;
pub const VREFRESH = 116;
pub const MCI_SET_ON = @as(c_long, 8192);
pub const RPCNSAPI = DECLSPEC_IMPORT;
pub const FAST_FAIL_GUARD_EXPORT_SUPPRESSION_FAILURE = 46;
pub const DM_MODIFY = 8;
pub const DN_DEFAULTPRN = 1;
pub const DEF_PRIORITY = 1;
pub const ERROR_TRANSACTION_NOT_REQUESTED = @as(c_long, 6703);
pub const __INT_FAST16_MAX__ = 32767;
pub const CRYPT_INITIATOR = 64;
pub const CERT_PHYSICAL_STORE_OPEN_DISABLE_FLAG = 2;
pub const COPYFILE_SIS_REPLACE = 2;
pub const MDM_ANALOG_RLP_OFF = 1;
pub const CERT_STORE_PROV_SYSTEM_STORE_FLAG = 8;
pub const MIN_LOGICALDPIOVERRIDE = -2;
pub const FILE_MAP_COPY = 1;
pub const DNS_ERROR_VIRTUALIZATION_INSTANCE_DOES_NOT_EXIST = @as(c_long, 9922);
pub const MILCORE_TS_QUERYVER_RESULT_TRUE = 2147483647;
pub const ERROR_EA_FILE_CORRUPT = @as(c_long, 276);
pub const BackupEventLog = BackupEventLogA;
pub const IMAGE_REL_SH3_PCREL8_LONG = 10;
pub const __FLT_DENORM_MIN__ = 0.000000;
pub const URLACTION_DOWNLOAD_UNSIGNED_ACTIVEX = 4100;
pub const PARTITION_NTFT = 128;
pub const URLACTION_ALLOW_VBSCRIPT_IE = 5132;
pub const NCRYPT_TPM_LOADABLE_KEY_BLOB_MAGIC = 1297371211;
pub const STG_LAYOUT_SEQUENTIAL = @as(c_long, 0);
pub const Uri_HAS_ABSOLUTE_URI = 1 << Uri_PROPERTY_ABSOLUTE_URI;
pub const UNICODE_NOCHAR = 65535;
pub const TLS_MINIMUM_AVAILABLE = 64;
pub const ACTCTX_FLAG_HMODULE_VALID = 128;
pub const FOF_WANTMAPPINGHANDLE = 32;
pub const GGO_BEZIER = 3;
pub const GW_MAX = 6;
pub const InterlockedExchange8 = _InterlockedExchange8;
pub const __UINT16_FMTu__ = "hu";
pub const NCRYPT_RC2_ALGORITHM = BCRYPT_RC2_ALGORITHM;
pub const FADF_FIXEDSIZE = 16;
pub const SYNCHRONIZATION_BARRIER_FLAGS_BLOCK_ONLY = 2;
pub const szOID_OIWSEC_mdc2 = "1.3.14.3.2.19";
pub const FLASHW_TIMERNOFG = 12;
pub const IN_CLASSA_NET = 4278190080;
pub const DC_PRINTRATEPPM = 31;
pub const OBJ_BRUSH = 2;
pub const ERROR_CTX_INVALID_MODEMNAME = @as(c_long, 7010);
pub const SCardRemoveReaderFromGroup = SCardRemoveReaderFromGroupA;
pub const USN_REASON_RENAME_OLD_NAME = 4096;
pub const MAX_NUM_REASONS = 256;
pub const NRC_SYSTEM = 64;
pub const DT_PLOTTER = 0;
pub const ERROR_NESTING_NOT_ALLOWED = @as(c_long, 215);
pub const VAR_TIMEVALUEONLY = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 1) else DWORD(1);
pub const ES_NUMBER = @as(c_long, 8192);
pub const LOCK_UNLOCK_DOOR = 2;
pub const NCRYPT_SHA256_ALGORITHM = BCRYPT_SHA256_ALGORITHM;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING = 32;
pub const ERROR_APPEXEC_HOST_ID_MISMATCH = @as(c_long, 3066);
pub const APPCOMMAND_MEDIA_PLAY_PAUSE = 14;
pub const DMPAPER_ENV_10 = 20;
pub const SOUND_SYSTEM_FAULT = 13;
pub const WGL_SWAP_OVERLAY5 = 32;
pub const WS_EX_NOINHERITLAYOUT = @as(c_long, 1048576);
pub const JOB_OBJECT_UILIMIT_ALL = 255;
pub const FILE_READ_ATTRIBUTES = 128;
pub const ERROR_INVALID_TRANSACTION = @as(c_long, 6700);
pub const HELPINFO_MENUITEM = 2;
pub const MARSHALINTERFACE_MIN = 500;
pub const ACTCTX_FLAG_SOURCE_IS_ASSEMBLYREF = 64;
pub const SECURITY_DASHOST_ID_BASE_RID = @as(c_long, 92);
pub const X509_CERT_POLICIES = if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 16) else if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 16) else LPCSTR(16);
pub const ERROR_IO_DEVICE = @as(c_long, 1117);
pub const SYSRGN = 4;
pub const ALG_CLASS_ANY = 0;
pub const MCI_WAVE_STATUS_LEVEL = @as(c_long, 16391);
pub const DRVCNF_CANCEL = 0;
pub const OLEIVERB_DISCARDUNDOSTATE = -@as(c_long, 6);
pub const __UINTMAX_FMTx__ = "llx";
pub const ST_ADVISE = 2;
pub const X509_DH_PARAMETERS = if (@typeId(@typeOf(47)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 47) else if (@typeId(@typeOf(47)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 47) else LPCSTR(47);
pub const SEE_MASK_UNICODE = 16384;
pub const CAL_SABBREVMONTHNAME8 = 41;
pub const CBS_AUTOHSCROLL = @as(c_long, 64);
pub const X509_CERT = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 1) else LPCSTR(1);
pub const BATTERY_FLAG_NO_BATTERY = 128;
pub const IS_TEXT_UNICODE_REVERSE_SIGNATURE = 128;
pub const szOID_KEY_USAGE_RESTRICTION = "2.5.29.4";
pub const LOAD_LIBRARY_SEARCH_SYSTEM32_NO_FORWARDER = 16384;
pub const SPI_SETMOUSEKEYS = 55;
pub const ERROR_TIMER_RESOLUTION_NOT_SET = @as(c_long, 607);
pub const WS_EX_STATICEDGE = @as(c_long, 131072);
pub const WM_PAINTICON = 38;
pub const NCRYPT_PREFER_VIRTUAL_ISOLATION_FLAG = 65536;
pub const CC_SOLIDCOLOR = 128;
pub const IME_SMODE_PHRASEPREDICT = 8;
pub const ERROR_PRINTER_DRIVER_ALREADY_INSTALLED = @as(c_long, 1795);
pub const InterlockedAddRelease64 = _InlineInterlockedAdd64;
pub const ERROR_DS_PROTOCOL_ERROR = @as(c_long, 8225);
pub const RpcNsBindingInqEntryName = RpcNsBindingInqEntryNameA;
pub const PROCESSOR_ARCHITECTURE_MIPS = 1;
pub const IMAGE_REL_AM_ADDR32NB = 2;
pub const DISPLAYCONFIG_PATH_PREFERRED_UNSCALED = 4;
pub const SM_CXSIZEFRAME = SM_CXFRAME;
pub const ReadConsoleInput = ReadConsoleInputA;
pub const psh4 = 1027;
pub const FILE_MAP_READ = SECTION_MAP_READ;
pub const DISPID_DESTRUCTOR = -7;
pub const ERROR_SYSTEM_INTEGRITY_ROLLBACK_DETECTED = @as(c_long, 4550);
pub const JOB_OBJECT_SECURITY_VALID_FLAGS = 15;
pub const CF_GDIOBJFIRST = 768;
pub const WSA_E_NO_MORE = @as(c_long, 10110);
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_RF_PROLOGUE = 1;
pub const ERROR_CLUSTER_INVALID_STRING_TERMINATION = @as(c_long, 5916);
pub const ERROR_DS_SRC_AND_DST_NC_IDENTICAL = @as(c_long, 8485);
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC = 7;
pub const ERROR_MRM_INVALID_QUALIFIER_VALUE = @as(c_long, 15114);
pub const IMAGE_SCN_ALIGN_4096BYTES = 13631488;
pub const PRODUCT_ULTIMATE = 1;
pub const _Analysis_assume_lock_held_ = lock;
pub const PSINJECT_PAGEBBOX = 106;
pub const SERVICE_ACCEPT_STOP = 1;
pub const IMAGE_FILE_MACHINE_ARMNT = 452;
pub const CERT_ACCESS_STATE_WRITE_PERSIST_FLAG = 1;
pub const DOMAIN_ALIAS_RID_RAS_SERVERS = @as(c_long, 553);
pub const STATUS_FLOAT_OVERFLOW = if (@typeId(@typeOf(@as(c_long, 3221225617))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225617)) else if (@typeId(@typeOf(@as(c_long, 3221225617))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225617)) else DWORD(@as(c_long, 3221225617));
pub const SHTDN_REASON_MINOR_OTHER = 0;
pub const SM_DBCSENABLED = 42;
pub const InterlockedCompareExchangePointerNoFence = _InterlockedCompareExchangePointer;
pub const HANGUP_COMPLETE = 5;
pub const szOID_DSALG = "2.5.8";
pub const FAST_FAIL_UNEXPECTED_CALL = 56;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM = 0;
pub const ERROR_CLUSTER_NODE_NOT_MEMBER = @as(c_long, 5052);
pub const CAL_THAI = 7;
pub const COLOR_3DFACE = COLOR_BTNFACE;
pub const SECURITY_IMPERSONATION = SecurityImpersonation << 16;
pub const DISPID_UNKNOWN = -1;
pub const URLPOLICY_CREDENTIALS_ANONYMOUS_ONLY = 196608;
pub const PP_KEYEXCHANGE_PIN = 32;
pub const SWP_NOMOVE = 2;
pub const CONNDLG_NOT_PERSIST = 32;
pub const MEM_FREE = 65536;
pub const MIXER_GETLINECONTROLSF_ONEBYTYPE = @as(c_long, 2);
pub const FR_MATCHKASHIDA = 1073741824;
pub const LookupAccountName = LookupAccountNameA;
pub const PROCESS_CREATION_MITIGATION_POLICY_CONTROL_FLOW_GUARD_ALWAYS_OFF = if (@typeId(@typeOf(i64 << 40)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 2), i64 << 40) else if (@typeId(@typeOf(i64 << 40)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 2), i64 << 40) else @as(c_uint, 2)(i64 << 40);
pub const BCRYPT_SECRET_AGREEMENT_OPERATION = 8;
pub const ERROR_TRANSACTION_ALREADY_ABORTED = @as(c_long, 6704);
pub const CC_ELLIPSES = 8;
pub const CERT_PROT_ROOT_DISABLE_NOT_DEFINED_NAME_CONSTRAINT_FLAG = 32;
pub const TRANSPARENT = 1;
pub const ERROR_RING2SEG_MUST_BE_MOVABLE = @as(c_long, 200);
pub const SUBLANG_DUTCH = 1;
pub const HP_HASHSIZE = 4;
pub const DM_FORMNAME = @as(c_long, 65536);
pub const VK_SHIFT = 16;
pub const PropertySheet = PropertySheetA;
pub const DRIVE_REMOTE = 4;
pub const ERROR_EVT_INVALID_EVENT_DATA = @as(c_long, 15005);
pub const VarUintFromDate = VarUI4FromDate;
pub const SCARD_READER_TYPE_NGC = 1024;
pub const PDC_ORIENTATION_270 = 32;
pub const FILE_NAME_NORMALIZED = 0;
pub const ERROR_BACKUP_CONTROLLER = @as(c_long, 586);
pub const ERROR_ACTIVATION_COUNT_EXCEEDED = @as(c_long, 7059);
pub const ERROR_CLUSTER_INVALID_NETWORK_PROVIDER = @as(c_long, 5049);
pub const FACILITY_MOBILE = 1793;
pub const ASSERT_ALTERNATE = 9;
pub const SM_CXSIZE = 30;
pub const SHUTDOWN_FORCE_OTHERS = 1;
pub const ERROR_CANNOT_DETECT_PROCESS_ABORT = @as(c_long, 1081);
pub const _WRITE_ABORT_MSG = 1;
pub const PF_3DNOW_INSTRUCTIONS_AVAILABLE = 7;
pub const RGN_DIFF = 4;
pub const ChangeServiceConfig = ChangeServiceConfigA;
pub const REG_REFRESH_HIVE = @as(c_long, 2);
pub const IME_CONFIG_SELECTDICTIONARY = 3;
pub const InterlockedCompareExchangePointer = _InterlockedCompareExchangePointer;
pub const TXFS_SAVEPOINT_CLEAR = 4;
pub const ERROR_DS_INSTALL_SCHEMA_MISMATCH = @as(c_long, 8467);
pub const APPIDREGFLAGS_SECURE_SERVER_PROCESS_SD_AND_BIND = 2;
pub const CTL_FIND_EXISTING = 5;
pub const VarBstrFromUint = VarBstrFromUI4;
pub const RPC_S_CALL_FAILED = @as(c_long, 1726);
pub const CFSTR_MIME_X_REALAUDIO = if (@typeId(@typeOf("audio/x-pn-realaudio")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "audio/x-pn-realaudio") else if (@typeId(@typeOf("audio/x-pn-realaudio")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "audio/x-pn-realaudio") else TEXT("audio/x-pn-realaudio");
pub const __STDC_HOSTED__ = 1;
pub const ERROR_DS_AFFECTS_MULTIPLE_DSAS = @as(c_long, 8249);
pub const CERT_EFS_PROP_ID = 17;
pub const BACKUP_TXFS_DATA = 10;
pub const DMPAPER_ENV_11 = 21;
pub const ERROR_CANT_RECOVER_WITH_HANDLE_OPEN = @as(c_long, 6818);
pub const MINLONG = 2147483648;
pub const EXCEPTION_INT_DIVIDE_BY_ZERO = STATUS_INTEGER_DIVIDE_BY_ZERO;
pub const CDERR_LOCKRESFAILURE = 8;
pub const WOM_OPEN = MM_WOM_OPEN;
pub const CERT_CHAIN_POLICY_IGNORE_WEAK_SIGNATURE_FLAG = 134217728;
pub const ERROR_BAD_NET_NAME = @as(c_long, 67);
pub const CAL_SABBREVMONTHNAME9 = 42;
pub const STARTF_FORCEONFEEDBACK = 64;
pub const CMC_ADD_ATTRIBUTES = if (@typeId(@typeOf(63)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 63) else if (@typeId(@typeOf(63)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 63) else LPCSTR(63);
pub const TRANSACTION_NOTIFY_COMMIT = 4;
pub const IMAGE_DLLCHARACTERISTICS_NO_ISOLATION = 512;
pub const CMSG_OID_EXPORT_KEY_AGREE_FUNC = "CryptMsgDllExportKeyAgree";
pub const FILE_DIR_DISALLOWED = 9;
pub const _WIN32_IE_IE501 = 1281;
pub const SHGFI_OPENICON = 2;
pub const VarIntFromI8 = VarI4FromI8;
pub const CMSG_HASHED = 5;
pub const SECURITY_MAX_IMPERSONATION_LEVEL = SecurityDelegation;
pub const ERROR_DS_OUT_OF_SCOPE = @as(c_long, 8338);
pub const IMAGE_REL_I386_SECTION = 10;
pub const SPI_GETPENARBITRATIONTYPE = 8224;
pub const FILE_DEVICE_SCREEN = 28;
pub const szOID_LEGACY_POLICY_MAPPINGS = "2.5.29.5";
pub const psh5 = 1028;
pub const RGN_COPY = 5;
pub const JOB_OBJECT_LIMIT_JOB_WRITE_BYTES = 131072;
pub const MCI_SEQ_FORMAT_SONGPTR = 16385;
pub const NIM_SETVERSION = 4;
pub const CRYPT_CACHE_ONLY_RETRIEVAL = 2;
pub const TARGET_IS_NT63_OR_LATER = 1;
pub const SERVICE_NOTIFY_STOP_PENDING = 4;
pub const CTRY_PERU = 51;
pub const CRYPT_NO_OCSP_FAILOVER_TO_CRL_RETRIEVAL = 33554432;
pub const __FLT_DIG__ = 6;
pub const SUBLANG_CHINESE_HONGKONG = 3;
pub const szOID_PKCS_12_pbeWithSHA1And40BitRC4 = "1.2.840.113549.1.12.1.2";
pub const CERT_CHAIN_DISABLE_MOTW_TIMESTAMP_HASH_WEAK_FLAG = 32768;
pub const DFCS_TRANSPARENT = 2048;
pub const ERROR_DS_BAD_HIERARCHY_FILE = @as(c_long, 8425);
pub const DM_PAPERLENGTH = @as(c_long, 4);
pub const SEARCH_PRIMARY = 1;
pub const MB_TASKMODAL = @as(c_long, 8192);
pub const WT_EXECUTEINPERSISTENTTHREAD = 128;
pub const ResetDC = ResetDCA;
pub const CERT_CHAIN_POLICY_NT_AUTH = if (@typeId(@typeOf(6)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 6) else if (@typeId(@typeOf(6)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 6) else LPCSTR(6);
pub const DeletePrinterData = DeletePrinterDataA;
pub const TIME_MIDI = 16;
pub const LANG_SOTHO = 108;
pub const STORAGE_PROTOCOL_COMMAND_FLAG_ADAPTER_REQUEST = 2147483648;
pub const CERT_CHAIN_POLICY_AUTHENTICODE_TS = if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 3) else if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 3) else LPCSTR(3);
pub const ERROR_ILLEGAL_FLOAT_CONTEXT = @as(c_long, 579);
pub const DMPAPER_A3_ROTATED = 76;
pub const AF_UNSPEC = 0;
pub const NEAR = near;
pub const ERROR_IPSEC_IKE_DROP_NO_RESPONSE = @as(c_long, 13813);
pub const szOID_ECC_CURVE_SECP192K1 = "1.3.132.0.31";
pub const STATUS_GUARD_PAGE_VIOLATION = if (@typeId(@typeOf(@as(c_long, 2147483649))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 2147483649)) else if (@typeId(@typeOf(@as(c_long, 2147483649))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 2147483649)) else DWORD(@as(c_long, 2147483649));
pub const RegSaveKeyEx = RegSaveKeyExA;
pub const NTAPI_INLINE = NTAPI;
pub const POINTER_MESSAGE_FLAG_FIFTHBUTTON = 256;
pub const ERROR_NOT_EXPORT_FORMAT = @as(c_long, 6008);
pub const JOY_USEDEADZONE = @as(c_long, 2048);
pub const IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR = 60;
pub const URLACTION_ALLOW_APEVALUATION = 8961;
pub const APPCOMMAND_BROWSER_HOME = 7;
pub const LBN_SELCHANGE = 1;
pub const NRC_LOCTFUL = 17;
pub const CERT_SCEP_CA_CERT_PROP_ID = 111;
pub const MF_DEFAULT = @as(c_long, 4096);
pub const ERROR_PRI_MERGE_MAIN_PACKAGE_REQUIRED = @as(c_long, 15156);
pub const SHGFI_SHELLICONSIZE = 4;
pub const ERROR_NEEDS_REGISTRATION = @as(c_long, 15631);
pub const BF_RIGHT = 4;
pub const SHGFI_TYPENAME = 1024;
pub const WTS_SESSION_REMOTE_CONTROL = 9;
pub const VP_TV_STANDARD_PAL_60 = 262144;
pub const PERF_COUNTER_PRECISION = 458752;
pub const UuidFromString = UuidFromStringA;
pub const WM_LBUTTONDBLCLK = 515;
pub const META_DIBCREATEPATTERNBRUSH = 322;
pub const IMAGE_REL_SH3_DIRECT4 = 6;
pub const IMAGE_SCN_ALIGN_1024BYTES = 11534336;
pub const ERROR_INSTALL_NOTUSED = @as(c_long, 1634);
pub const PF_NON_TEMPORAL_LEVEL_ALL = _MM_HINT_NTA;
pub const FILE_DEVICE_USBEX = 73;
pub const GETPHYSPAGESIZE = 12;
pub const IMAGE_SYM_CLASS_AUTOMATIC = 1;
pub const MB_MISCMASK = @as(c_long, 49152);
pub const EVENT_UIA_PROPID_END = 30207;
pub const CRL_DIST_POINT_FULL_NAME = 1;
pub const ERROR_TOO_MANY_SIDS = @as(c_long, 1389);
pub const FILE_CACHE_MAX_HARD_DISABLE = 2;
pub const URLACTION_SHELL_EXTENSIONSECURITY = 6156;
pub const STATE_SYSTEM_UNAVAILABLE = 1;
pub const SECURITY_SQOS_PRESENT = 1048576;
pub const TOUCHEVENTF_PEN = 64;
pub const szOID_OIWSEC = "1.3.14.3.2";
pub const SPI_GETKEYBOARDPREF = 68;
pub const CERT_CHAIN_POLICY_SSL_F12 = if (@typeId(@typeOf(9)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 9) else if (@typeId(@typeOf(9)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 9) else LPCSTR(9);
pub const IMC_GETCOMPOSITIONFONT = 9;
pub const CF_NOSIZESEL = @as(c_long, 2097152);
pub const wvsprintf = wvsprintfA;
pub const CMSG_OID_GEN_ENCRYPT_KEY_FUNC = "CryptMsgDllGenEncryptKey";
pub const dwFORCE_KEY_PROTECTION_USER_SELECT = 1;
pub const REG_NO_LAZY_FLUSH = @as(c_long, 4);
pub const IP_MAX_MEMBERSHIPS = 20;
pub const STATE_SYSTEM_SELECTED = 2;
pub const SUBLANG_TSWANA_BOTSWANA = 2;
pub const ERROR_NETWORK_ACCESS_DENIED_EDP = @as(c_long, 354);
pub const CREATE_SEPARATE_WOW_VDM = 2048;
pub const CERT_VERIFY_ALLOW_MORE_USAGE_FLAG = 8;
pub const VK_NUMPAD8 = 104;
pub const BCRYPT_DES_CBC_ALG_HANDLE = if (@typeId(@typeOf(497)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 497) else if (@typeId(@typeOf(497)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 497) else BCRYPT_ALG_HANDLE(497);
pub const MIXERLINE_LINEF_ACTIVE = @as(c_long, 1);
pub const CP_THREAD_ACP = 3;
pub const MUI_LANGUAGE_INSTALLED = 32;
pub const EVENT_OBJECT_TEXTSELECTIONCHANGED = 32788;
pub const SERVICE_ACCEPT_USER_LOGOFF = 2048;
pub const __UINT32_C_SUFFIX__ = U;
pub const DMPAPER_ENV_12 = 22;
pub const CERT_RDN_BMP_STRING = 12;
pub const ERROR_RESOURCE_ENUM_USER_STOP = @as(c_long, 15106);
pub const DT_RASPRINTER = 2;
pub const VP_FLAGS_TV_STANDARD = 2;
pub const OBJID_SYSMENU = if (@typeId(@typeOf(4294967295)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG, 4294967295) else if (@typeId(@typeOf(4294967295)) == @import("builtin").TypeId.Int) @intToPtr(LONG, 4294967295) else LONG(4294967295);
pub const FindNextVolumeMountPoint = FindNextVolumeMountPointA;
pub const CERT_CHAIN_REVOCATION_CHECK_END_CERT = 268435456;
pub const psh16 = 1039;
pub const CRL_REASON_KEY_COMPROMISE_FLAG = 64;
pub const SMART_OFFLINE_ROUTINE_OFFLINE = 0;
pub const EVENT_CONSOLE_END_APPLICATION = 16391;
pub const CreateFontIndirect = CreateFontIndirectA;
pub const ShellExecuteEx = ShellExecuteExA;
pub const MNGOF_TOPGAP = 1;
pub const PRINTER_CHANGE_DELETE_PORT = 4194304;
pub const NCRYPTBUFFER_DATA = 1;
pub const SM_MEDIACENTER = 87;
pub const ERROR_NOT_CHILD_WINDOW = @as(c_long, 1442);
pub const stc29 = 1116;
pub const FOF_SIMPLEPROGRESS = 256;
pub const EMR_PLGBLT = 79;
pub const EWX_FORCE = 4;
pub const PIDSI_DOC_SECURITY = @as(c_long, 19);
pub const STORAGE_HW_FIRMWARE_REQUEST_FLAG_FIRST_SEGMENT = 4;
pub const SUBLANG_KOREAN = 1;
pub const ERROR_INVALID_SERVICE_ACCOUNT = @as(c_long, 1057);
pub const LB_ERRSPACE = -2;
pub const SCARD_NEGOTIABLE = 5;
pub const VK_BROWSER_STOP = 169;
pub const APPCOMMAND_MIC_ON_OFF_TOGGLE = 44;
pub const DMDITHER_GRAYSCALE = 10;
pub const MINCHAR = 128;
pub const CFSTR_MIME_X_MSVIDEO = if (@typeId(@typeOf("video/x-msvideo")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "video/x-msvideo") else if (@typeId(@typeOf("video/x-msvideo")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "video/x-msvideo") else TEXT("video/x-msvideo");
pub const CRYPT_SORTED_CTL_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG = 65536;
pub const TRANSACTION_RIGHT_RESERVED1 = 64;
pub const CRL_REASON_AA_COMPROMISE_FLAG = 128;
pub const sz_CERT_STORE_PROV_FILENAME = sz_CERT_STORE_PROV_FILENAME_W;
pub const ERROR_PLATFORM_MANIFEST_NOT_ACTIVE = @as(c_long, 4575);
pub const OBJ_MEMDC = 10;
pub const DT_RIGHT = 2;
pub const psh6 = 1029;
pub const ENETUNREACH = 118;
pub const NCRYPTBUFFER_CLAIM_KEYATTESTATION_NONCE = 49;
pub const IDYES = 6;
pub const MCI_VD_STEP_REVERSE = @as(c_long, 131072);
pub const CERT_STORE_PROV_EXTERNAL_FLAG = 1;
pub const ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE = @as(c_long, 15207);
pub const ERROR_MRM_DUPLICATE_MAP_NAME = @as(c_long, 15118);
pub const SPI_GETHOTTRACKING = 4110;
pub const RESOURCEUSAGE_RESERVED = 2147483648;
pub const HTHELP = 21;
pub const BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE = 1;
pub const YieldProcessor = _mm_pause;
pub const CDN_HELP = if (@typeId(@typeOf(-4)) == @import("builtin").TypeId.Pointer) @ptrCast(CDN_FIRST, -4) else if (@typeId(@typeOf(-4)) == @import("builtin").TypeId.Int) @intToPtr(CDN_FIRST, -4) else CDN_FIRST(-4);
pub const IMFS_DISABLED = MFS_DISABLED;
pub const UPDFCACHE_NODATACACHE = 1;
pub const SE_ERR_DLLNOTFOUND = 32;
pub const NCRYPT_MD2_ALGORITHM = BCRYPT_MD2_ALGORITHM;
pub const FADF_VARIANT = 2048;
pub const WM_CHILDACTIVATE = 34;
pub const QUERYROPSUPPORT = 40;
pub const RPC_S_NOT_RPC_ERROR = @as(c_long, 1823);
pub const SUBLANG_CHINESE_SINGAPORE = 4;
pub const SUBLANG_UZBEK_CYRILLIC = 2;
pub const RPC_S_INVALID_NET_ADDR = @as(c_long, 1707);
pub const CERT_COMPARE_MD5_HASH = 4;
pub const PAGE_GRAPHICS_NOACCESS = 2048;
pub const RI_KEY_TERMSRV_SET_LED = 8;
pub const URL_OID_CRL_ISSUER = if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 5) else if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 5) else LPCSTR(5);
pub const CDERR_MEMLOCKFAILURE = 10;
pub const SPI_GETPENVISUALIZATION = 8222;
pub const EM_SETREADONLY = 207;
pub const PORT_TYPE_READ = 2;
pub const IMAGE_REL_AMD64_SECTION = 10;
pub const LGRPID_BALTIC = 3;
pub const THREAD_PRIORITY_TIME_CRITICAL = THREAD_BASE_PRIORITY_LOWRT;
pub const CTRY_MONACO = 33;
pub const ERROR_MR_MID_NOT_FOUND = @as(c_long, 317);
pub const WSA_QOS_SENDERS = @as(c_long, 11006);
pub const META_INVERTREGION = 298;
pub const WAVE_FORMAT_4S16 = 2048;
pub const ERROR_MRM_INDETERMINATE_QUALIFIER_VALUE = @as(c_long, 15138);
pub const FILE_REGION_USAGE_VALID_CACHED_DATA = 1;
pub const __INT_FAST16_FMTd__ = "hd";
pub const MDM_SHIFT_HDLCPPP_SPEED = 0;
pub const IMAGE_REL_IA64_SREL14 = 17;
pub const DNS_ERROR_VIRTUALIZATION_TREE_LOCKED = @as(c_long, 9923);
pub const MM_JOY1BUTTONUP = 951;
pub const VER_PLATFORM_WIN32s = 0;
pub const IMAGE_HOT_PATCH_INDIRECT = 376832;
pub const BCRYPT_ECDH_PRIVATE_GENERIC_MAGIC = 1447772997;
pub const EINPROGRESS = 112;
pub const EnumFontFamiliesEx = EnumFontFamiliesExA;
pub const DC_DATATYPE_PRODUCED = 21;
pub const DNS_ERROR_INCONSISTENT_ROOT_HINTS = @as(c_long, 9565);
pub const RPC_C_IMP_LEVEL_ANONYMOUS = 1;
pub const CMSG_HASHED_DATA_PKCS_1_5_VERSION = CMSG_HASHED_DATA_V0;
pub const DeleteFile = DeleteFileA;
pub const VS_ALLOW_LATIN = 1;
pub const ERROR_INVALID_TOKEN = @as(c_long, 315);
pub const MIXERCONTROL_CT_UNITS_UNSIGNED = @as(c_long, 196608);
pub const LANG_CHEROKEE = 92;
pub const NID_INTEGRATED_PEN = 4;
pub const RotateRight32 = _rotr;
pub const MM_LOENGLISH = 4;
pub const ERROR_STOPPED_ON_SYMLINK = @as(c_long, 681);
pub const PRINTER_STATUS_PENDING_DELETION = 4;
pub const ERROR_ALIAS_EXISTS = @as(c_long, 1379);
pub const ERROR_FUNCTION_FAILED = @as(c_long, 1627);
pub const ERROR_UNKNOWN_PRINTER_DRIVER = @as(c_long, 1797);
pub const CONNECT_REQUIRE_PRIVACY = 32768;
pub const LZERROR_READ = -3;
pub const TAPE_TENSION = @as(c_long, 2);
pub const InterlockedCompareExchangeRelease64 = InterlockedCompareExchange64;
pub const ERROR_RESOURCE_REQUIREMENTS_CHANGED = @as(c_long, 756);
pub const __UINT16_FMTx__ = "hx";
pub const WM_MOUSELEAVE = 675;
pub const CTL_ANY_SUBJECT_TYPE = 1;
pub const UNWIND_HISTORY_TABLE_SIZE = 12;
pub const ERROR_CTX_CONSOLE_CONNECT = @as(c_long, 7042);
pub const WNNC_NET_DOCUSPACE = 1769472;
pub const ODA_DRAWENTIRE = 1;
pub const PSD_ENABLEPAGESETUPTEMPLATEHANDLE = 131072;
pub const NID_EXTERNAL_TOUCH = 2;
pub const BitTestAndComplement64 = _bittestandcomplement64;
pub const Uri_CREATE_IE_SETTINGS = 8192;
pub const VK_NUMPAD9 = 105;
pub const PP_NAME = 4;
pub const __LONG_LONG_MAX__ = @as(c_longlong, 9223372036854775807);
pub const CERT_SYSTEM_STORE_SERVICES_ID = 5;
pub const szOID_PKIX_KP_OCSP_SIGNING = "1.3.6.1.5.5.7.3.9";
pub const STD_INPUT_HANDLE = if (@typeId(@typeOf(-10)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, -10) else if (@typeId(@typeOf(-10)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, -10) else DWORD(-10);
pub const ERROR_SHARED_POLICY = @as(c_long, 8218);
pub const ERROR_CLUSTER_FAULT_DOMAIN_FAILED_S2D_VALIDATION = @as(c_long, 5996);
pub const X509_CRL_REASON_CODE = X509_ENUMERATED;
pub const HIGH_PRIORITY_CLASS = 128;
pub const RI_MOUSE_BUTTON_2_DOWN = RI_MOUSE_RIGHT_BUTTON_DOWN;
pub const VarIntFromR4 = VarI4FromR4;
pub const EFSRPC_SECURE_ONLY = 8;
pub const STM_SETICON = 368;
pub const psh15 = 1038;
pub const SUBLANG_ALSATIAN_FRANCE = 1;
pub const DM_ICMMETHOD = @as(c_long, 8388608);
pub const CACHE_E_FIRST = @as(c_long, 2147746160);
pub const stc28 = 1115;
pub const SECURITY_MAX_BASE_RID = @as(c_long, 111);
pub const DCX_LOCKWINDOWUPDATE = @as(c_long, 1024);
pub const CODEPAGE_ENUMPROC = CODEPAGE_ENUMPROCA;
pub const VIF_CANNOTREADDST = @as(c_long, 131072);
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = 0;
pub const CERT_VERIFY_REV_NO_OCSP_FAILOVER_TO_CRL_FLAG = 16;
pub const GM_COMPATIBLE = 1;
pub const JOB_CONTROL_LAST_PAGE_EJECTED = 7;
pub const CHANGER_TO_IEPORT = 4;
pub const CHANGER_RTN_MEDIA_TO_ORIGINAL_ADDR = 2147483680;
pub const EMR_SETTEXTALIGN = 22;
pub const CONNECT_NEED_DRIVE = 32;
pub const ERROR_DS_OBJ_CLASS_VIOLATION = @as(c_long, 8212);
pub const FILE_INVALID_FILE_ID = if (@typeId(@typeOf(-@as(c_longlong, 1))) == @import("builtin").TypeId.Pointer) @ptrCast(LONGLONG, -@as(c_longlong, 1)) else if (@typeId(@typeOf(-@as(c_longlong, 1))) == @import("builtin").TypeId.Int) @intToPtr(LONGLONG, -@as(c_longlong, 1)) else LONGLONG(-@as(c_longlong, 1));
pub const ReadLongPtrRaw = ReadRaw64;
pub const __INVPCID__ = 1;
pub const ERROR_GRACEFUL_DISCONNECT = @as(c_long, 1226);
pub const DMPAPER_JAPANESE_POSTCARD_ROTATED = 81;
pub const ERROR_ACCOUNT_LOCKED_OUT = @as(c_long, 1909);
pub const CERT_ALT_NAME_VALUE_ERR_INDEX_MASK = 65535;
pub const COLOR_BTNTEXT = 18;
pub const PEERDIST_ERROR_CANNOT_PARSE_CONTENTINFO = @as(c_long, 4051);
pub const ERROR_TRANSACTION_REQUEST_NOT_VALID = @as(c_long, 6702);
pub const psh7 = 1030;
pub const X509_CERT_CRL_TO_BE_SIGNED = if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 3) else if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 3) else LPCSTR(3);
pub const ERROR_INVALID_EA_NAME = @as(c_long, 254);
pub const MMIO_READ = 0;
pub const SPI_GETCOMBOBOXANIMATION = 4100;
pub const PRODUCT_CORE_SINGLELANGUAGE = 100;
pub const WM_ASKCBFORMATNAME = 780;
pub const PBT_APMSUSPEND = 4;
pub const MIM_HELPID = 4;
pub const _Deref_post1_impl_ = p1;
pub const RPC_QUERY_CLIENT_PID = 16;
pub const __PTRDIFF_FMTd__ = "lld";
pub const VK_NAVIGATION_DOWN = 139;
pub const BSM_ALLDESKTOPS = 16;
pub const PKCS_RSAES_OAEP_PARAMETERS = if (@typeId(@typeOf(76)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 76) else if (@typeId(@typeOf(76)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 76) else LPCSTR(76);
pub const DnsHostnameToComputerName = DnsHostnameToComputerNameA;
pub const PERF_COUNTER_ELAPSED = 262144;
pub const SPI_SETDESKPATTERN = 21;
pub const COLOR_HIGHLIGHT = 13;
pub const DC_COPIES = 18;
pub const GCS_COMPSTR = 8;
pub const cmb9 = 1144;
pub const KP_GET_USE_COUNT = 42;
pub const DoEnvironmentSubst = DoEnvironmentSubstA;
pub const CRYPT_MACHINE_DEFAULT = 1;
pub const DS_LOCALEDIT = @as(c_long, 32);
pub const ERROR_NOT_AUTHENTICATED = @as(c_long, 1244);
pub const WriteConsoleOutputCharacter = WriteConsoleOutputCharacterA;
pub const _LEADBYTE = 32768;
pub const WM_MBUTTONDOWN = 519;
pub const SIF_TRACKPOS = 16;
pub const POWER_CONNECTIVITY_IN_STANDBY_ENABLED = 1;
pub const DEVICEFAMILYINFOENUM_IOT = 7;
pub const DISPATCH_METHOD = 1;
pub const MARK_HANDLE_ENABLE_USN_SOURCE_ON_PAGING_IO = 8192;
pub const STATUS_FATAL_APP_EXIT = if (@typeId(@typeOf(@as(c_long, 1073741845))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 1073741845)) else if (@typeId(@typeOf(@as(c_long, 1073741845))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 1073741845)) else DWORD(@as(c_long, 1073741845));
pub const szOID_CERT_STRONG_SIGN_OS_PREFIX = "1.3.6.1.4.1.311.72.1.";
pub const RpcNsBindingLookupBegin = RpcNsBindingLookupBeginA;
pub const PST_LAT = if (@typeId(@typeOf(257)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 257) else if (@typeId(@typeOf(257)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 257) else DWORD(257);
pub const FastFence = __faststorefence;
pub const LOGON32_PROVIDER_DEFAULT = 0;
pub const RETRACT_IEPORT = 3;
pub const DNS_ERROR_DNAME_COLLISION = @as(c_long, 9721);
pub const CMAPI = DECLSPEC_IMPORT;
pub const ERROR_NOT_CONNECTED = @as(c_long, 2250);
pub const IMAGE_REL_I386_DIR32NB = 7;
pub const ERROR_CLUSTER_RESOURCE_IS_REPLICA_VIRTUAL_MACHINE = @as(c_long, 5972);
pub const ERROR_DIRECTORY_NOT_SUPPORTED = @as(c_long, 336);
pub const NCRYPTBUFFER_PKCS_ALG_PARAM = 42;
pub const IMAGE_FILE_MACHINE_IA64 = 512;
pub const GetSystemWow64Directory2 = GetSystemWow64Directory2A;
pub const REPLACEFILE_WRITE_THROUGH = 1;
pub const IMAGE_SEPARATE_DEBUG_MISMATCH = 32768;
pub const ERROR_DBG_TERMINATE_THREAD = @as(c_long, 691);
pub const EXCEPTION_WRITE_FAULT = 1;
pub const GetFileTitle = GetFileTitleA;
pub const GPT_BASIC_DATA_ATTRIBUTE_OFFLINE = 576460752303423488;
pub const CMSG_OID_EXPORT_KEY_TRANS_FUNC = "CryptMsgDllExportKeyTrans";
pub const REG_NOTIFY_CHANGE_LAST_SET = @as(c_long, 4);
pub const WNNC_CRED_MANAGER = 4294901760;
pub const PROCESSOR_ARCHITECTURE_ALPHA64 = 7;
pub const ERROR_EVT_CHANNEL_CANNOT_ACTIVATE = @as(c_long, 15025);
pub const ERROR_CLUSTER_INVALID_STRING_FORMAT = @as(c_long, 5917);
pub const TEXTCAPS = 34;
pub const szOID_PKCS_7 = "1.2.840.113549.1.7";
pub const FACILITY_WINRM = 51;
pub const __UINT16_MAX__ = 65535;
pub const ERROR_IPSEC_IKE_PEER_CRL_FAILED = @as(c_long, 13848);
pub const ShiftRight128 = __shiftright128;
pub const szOID_PKCS_7_DATA = "1.2.840.113549.1.7.1";
pub const IE_NOPEN = -3;
pub const READ_ATTRIBUTE_BUFFER_SIZE = 512;
pub const CFSTR_MIME_FRACTALS = if (@typeId(@typeOf("application/fractals")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "application/fractals") else if (@typeId(@typeOf("application/fractals")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "application/fractals") else TEXT("application/fractals");
pub const CMSG_CRL_PARAM = 14;
pub const DeletePort = DeletePortA;
pub const OFN_SHAREFALLTHROUGH = 2;
pub const SERVICE_RUNNING = 4;
pub const __WINT_UNSIGNED__ = 1;
pub const ERROR_VERIFIER_STOP = @as(c_long, 537);
pub const PRINTER_ATTRIBUTE_KEEPPRINTEDJOBS = 256;
pub const SEE_MASK_IDLIST = 4;
pub const szOID_ANY_CERT_POLICY = "2.5.29.32.0";
pub const interface = @"struct";
pub const IMAGE_REL_ALPHA_REFHI = 10;
pub const ERROR_DISK_RECALIBRATE_FAILED = @as(c_long, 1126);
pub const CNG_RSA_PUBLIC_KEY_BLOB = if (@typeId(@typeOf(72)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 72) else if (@typeId(@typeOf(72)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 72) else LPCSTR(72);
pub const CERT_XML_NAME_STR = 4;
pub const S_SERDST = -16;
pub const CBN_ERRSPACE = -1;
pub const CF_FORCEFONTEXIST = @as(c_long, 65536);
pub const CTRY_INDIA = 91;
pub const szOID_RSA_SETOAEP_RSA = "1.2.840.113549.1.1.6";
pub const DMPAPER_B5_EXTRA = 65;
pub const CERT_TRUST_HAS_VALID_NAME_CONSTRAINTS = 1024;
pub const LOGON32_LOGON_INTERACTIVE = 2;
pub const ERROR_NOT_LOGGED_ON = @as(c_long, 1245);
pub const VK_NUMPAD6 = 102;
pub const STATE_SYSTEM_FOCUSABLE = 1048576;
pub const CERT_DISALLOWED_ENHKEY_USAGE_PROP_ID = 122;
pub const CRYPT_USER_DEFAULT = 2;
pub const ERROR_CLEANER_SLOT_NOT_SET = @as(c_long, 4332);
pub const CE_PTO = 512;
pub const IPPORT_SMTP = 25;
pub const LOCALE_SMONTHDAY = 120;
pub const NUMPRS_THOUSANDS = 512;
pub const EnumProps = EnumPropsA;
pub const CTRY_COLOMBIA = 57;
pub const IMAGE_SYM_TYPE_CHAR = 2;
pub const MS_DEF_DSS_PROV = MS_DEF_DSS_PROV_A;
pub const APPCOMMAND_SEND_MAIL = 41;
pub const GetWindowTextLength = GetWindowTextLengthA;
pub const DISPLAY_DEVICE_ACC_DRIVER = 64;
pub const CFSTR_MIME_JPEG_XR = if (@typeId(@typeOf("image/vnd.ms-photo")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "image/vnd.ms-photo") else if (@typeId(@typeOf("image/vnd.ms-photo")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "image/vnd.ms-photo") else TEXT("image/vnd.ms-photo");
pub const IMPLTYPEFLAG_FSOURCE = 2;
pub const WM_CLOSE = 16;
pub const VP_TV_STANDARD_WIN_VGA = 32768;
pub const SEVERITY_SUCCESS = 0;
pub const CRYPT_ENCODE_ALLOC_FLAG = 32768;
pub const RPI_FLAG_SMB2_SHARECAP_CLUSTER = 64;
pub const psh14 = 1037;
pub const szOID_PKINIT_KP_KDC = "1.3.6.1.5.2.3.5";
pub const ERROR_SXS_DUPLICATE_IID = @as(c_long, 14024);
pub const OFN_FORCESHOWHIDDEN = 268435456;
pub const LANG_CATALAN = 3;
pub const EVENT_OBJECT_DRAGENTER = 32804;
pub const IP_DONTFRAGMENT = 9;
pub const ERROR_CTX_BAD_VIDEO_MODE = @as(c_long, 7025);
pub const WM_NCCALCSIZE = 131;
pub const CERT_TRUST_NO_OCSP_FAILOVER_TO_CRL = 64;
pub const LOCALE_SCURRENCY = 20;
pub const USN_REASON_DATA_OVERWRITE = 1;
pub const FILE_PROVIDER_COMPRESSION_LZX = 1;
pub const GM_ADVANCED = 2;
pub const chx2 = 1041;
pub const SUBLANG_CHINESE_TRADITIONAL = 1;
pub const FILE_NOTIFY_CHANGE_FILE_NAME = 1;
pub const FILE_SUPPORTS_USN_JOURNAL = 33554432;
pub const MCI_INFO_COPYRIGHT = @as(c_long, 8192);
pub const ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED = @as(c_long, 6725);
pub const ERROR_DS_OBJ_CLASS_NOT_DEFINED = @as(c_long, 8371);
pub const RpcServerInqCallAttributes = RpcServerInqCallAttributesA;
pub const POINTER_MESSAGE_FLAG_FIRSTBUTTON = 16;
pub const PRODUCT_PROFESSIONAL_S_N = 128;
pub const FORMAT_MESSAGE_FROM_STRING = 1024;
pub const VER_SERVICEPACKMINOR = 16;
pub const EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X = 14;
pub const CERT_SCEP_SIGNER_CERT_PROP_ID = 112;
pub const __LDBL_DECIMAL_DIG__ = 17;
pub const FACILITY_DIRECT2D = 2201;
pub const STREAMS_ASSOCIATE_ID_CLEAR = 1;
pub const VAR_VALIDDATE = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 4) else DWORD(4);
pub const POWER_ACTION_ACPI_CRITICAL = 16777216;
pub const CERT_RDN_ENABLE_PUNYCODE_FLAG = 33554432;
pub const RPC_S_SYSTEM_HANDLE_COUNT_EXCEEDED = @as(c_long, 1835);
pub const FILE_MAP_WRITE = SECTION_MAP_WRITE;
pub const EMR_POLYTEXTOUTA = 96;
pub const RIM_TYPEMOUSE = 0;
pub const PRINTER_ENUM_ICONMASK = 16711680;
pub const STORAGE_ATTRIBUTE_ASYNC_EVENT_NOTIFICATION = 16;
pub const PP_APPLI_CERT = 18;
pub const __out_ecount_nz = size;
pub const CRYPTPROTECTMEMORY_CROSS_PROCESS = 1;
pub const MOUSE_ATTRIBUTES_CHANGED = 4;
pub const GID_ROTATE = 5;
pub const DDD_EXACT_MATCH_ON_REMOVE = 4;
pub const CMSG_SIGNER_INFO_PKCS_1_5_VERSION = CMSG_SIGNER_INFO_V1;
pub const NCRYPT_AES_ALGORITHM = BCRYPT_AES_ALGORITHM;
pub const SPI_SETSCREENREADER = 71;
pub const szOID_ECDSA_SHA512 = "1.2.840.10045.4.3.4";
pub const cmb8 = 1143;
pub const CHANGER_TO_SLOT = 2;
pub const ALG_SID_THIRDPARTY_ANY = 0;
pub const LoadEnclaveImage = LoadEnclaveImageA;
pub const PERFSTATE_POLICY_CHANGE_SINGLE = 1;
pub const INDEXID_CONTAINER = 0;
pub const CHANGER_PREDISMOUNT_EJECT_REQUIRED = 131072;
pub const LOCALE_IDEFAULTANSICODEPAGE = 4100;
pub const SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE = 16;
pub const PSP_USECALLBACK = 128;
pub const ERROR_CLUSTER_BACKUP_IN_PROGRESS = @as(c_long, 5949);
pub const LCMapString = LCMapStringA;
pub const RPC_PROXY_CONNECTION_TYPE_IN_PROXY = 0;
pub const TAPE_DRIVE_EJECT_MEDIA = 16777216;
pub const SHOW_ICONWINDOW = 2;
pub const DISPLAYCONFIG_PATH_CLONE_GROUP_INVALID = 65535;
pub const MMIOM_CLOSE = 4;
pub const VIF_CANNOTLOADLZ32 = @as(c_long, 524288);
pub const STORAGE_COMPONENT_ROLE_DATA = 4;
pub const JOB_OBJECT_QUERY = 4;
pub const ERROR_CLUSTER_RESOURCE_DOES_NOT_SUPPORT_UNMONITORED = @as(c_long, 5982);
pub const WM_TOUCH = 576;
pub const RPC_S_NO_MORE_MEMBERS = @as(c_long, 1757);
pub const IMAGE_COMDAT_SELECT_EXACT_MATCH = 4;
pub const EMARCH_ENC_I17_IMM41b_SIZE_X = 8;
pub const LGRPID_SUPPORTED = 2;
pub const VS_FF_SPECIALBUILD = @as(c_long, 32);
pub const PROPSHEETHEADER_V2_SIZE = PROPSHEETHEADERA_V2_SIZE;
pub const ERROR_NOT_LOGON_PROCESS = @as(c_long, 1362);
pub const SERVICE_NOTIFY_CREATED = 128;
pub const DMDFO_STRETCH = 1;
pub const WINBASEAPI = DECLSPEC_IMPORT;
pub const ERROR_SXS_POLICY_PARSE_ERROR = @as(c_long, 14029);
pub const ERROR_POLICY_ONLY_IN_DS = @as(c_long, 8220);
pub const SETCOPYCOUNT = 17;
pub const FAPPCOMMAND_OEM = 4096;
pub const OFN_ENABLETEMPLATE = 64;
pub const WNNC_NET_POWERLAN = 983040;
pub const ACL_REVISION = 2;
pub const EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X = 0;
pub const ERROR_DELETING_ICM_XFORM = @as(c_long, 2019);
pub const CF_NOOEMFONTS = CF_NOVECTORFONTS;
pub const SCM_PD_FIRMWARE_LAST_DOWNLOAD = 1;
pub const DDL_DRIVES = 16384;
pub const ERROR_INSTALL_REMOTE_PROHIBITED = @as(c_long, 1645);
pub const ERROR_DS_UNWILLING_TO_PERFORM = @as(c_long, 8245);
pub const SPI_SETHIGHCONTRAST = 67;
pub const CMSG_KEY_TRANS_ENCRYPT_FREE_PARA_FLAG = 1;
pub const PRODUCT_HOME_BASIC_N = 5;
pub const szOID_PKCS_6 = "1.2.840.113549.1.6";
pub const FILE_PROVIDER_COMPRESSION_MAXIMUM = 4;
pub const MCI_VD_SPIN_UP = @as(c_long, 65536);
pub const GCP_DBCS = 1;
pub const PRODUCT_ULTIMATE_E = 71;
pub const CRYPT_ACQUIRE_CACHE_FLAG = 1;
pub const CSTR_GREATER_THAN = 3;
pub const _CRT_INSECURE_DEPRECATE_MEMORY = _Replacement;
pub const FILE_DEVICE_STREAMS = 30;
pub const SERVICE_STOP_REASON_MAJOR_OPERATINGSYSTEM = 196608;
pub const REG_APP_HIVE = @as(c_long, 16);
pub const CERT_CHAIN_DISABLE_TIMESTAMP_WEAK_FLAG = 67108864;
pub const SERVICE_ACCEPT_HARDWAREPROFILECHANGE = 32;
pub const __LDBL_HAS_DENORM__ = 1;
pub const SPI_SETCURSORSHADOW = 4123;
pub const RPC_C_QOS_IDENTITY_STATIC = 0;
pub const PAN_MIDLINE_HIGH_POINTED = 6;
pub const SERVICE_ACCEPT_PAUSE_CONTINUE = 2;
pub const MCI_ANIM_GETDEVCAPS_MAX_WINDOWS = @as(c_long, 16392);
pub const VK_NUMPAD7 = 103;
pub const CTRY_ISRAEL = 972;
pub const szOID_DRM_INDIVIDUALIZATION = "1.3.6.1.4.1.311.10.5.2";
pub const MDITILE_SKIPDISABLED = 2;
pub const PDCAP_WAKE_FROM_D2_SUPPORTED = 64;
pub const AddConsoleAlias = AddConsoleAliasA;
pub const BitScanForward64 = _BitScanForward64;
pub const WM_TCARD = 82;
pub const psh13 = 1036;
pub const SUBLANG_SAMI_NORTHERN_SWEDEN = 2;
pub const BATTERY_LIFE_UNKNOWN = 4294967295;
pub const BCRYPT_SIGNATURE_OPERATION = 16;
pub const CRYPT_LOCALIZED_NAME_ENCODING_TYPE = 0;
pub const LINGUISTIC_IGNOREDIACRITIC = 32;
pub const APPCOMMAND_MEDIA_CHANNEL_UP = 51;
pub const GetSegmentLimit = __segmentlimit;
pub const FILESYSTEM_STATISTICS_TYPE_EXFAT = 3;
pub const WIZ_BODYX = 92;
pub const chx3 = 1042;
pub const szOID_ECDSA_SHA384 = "1.2.840.10045.4.3.3";
pub const LMEM_FIXED = 0;
pub const PSD_ENABLEPAGESETUPHOOK = 8192;
pub const FILE_ATTRIBUTE_TEMPORARY = 256;
pub const IMAGE_SYM_CLASS_SECTION = 104;
pub const POINTER_32 = __ptr32;
pub const TAPE_DRIVE_COMPRESSION = 131072;
pub const VarIntFromI4 = VarI4FromI4;
pub const WNNC_NET_DRIVEONWEB = 4063232;
pub const ERROR_IPSEC_QM_POLICY_NOT_FOUND = @as(c_long, 13001);
pub const SPI_GETFONTSMOOTHINGTYPE = 8202;
pub const PRINTER_STATUS_MANUAL_FEED = 32;
pub const PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_ON = 1 << 24;
pub const EAFNOSUPPORT = 102;
pub const psh1 = 1024;
pub const CRYPT_MODE_CFBP = 7;
pub const ERROR_MRM_UNKNOWN_QUALIFIER = @as(c_long, 15113);
pub const PS_ENDCAP_SQUARE = 256;
pub const DPI_AWARENESS_CONTEXT_UNAWARE_GDISCALED = if (@typeId(@typeOf(-5)) == @import("builtin").TypeId.Pointer) @ptrCast(DPI_AWARENESS_CONTEXT, -5) else if (@typeId(@typeOf(-5)) == @import("builtin").TypeId.Int) @intToPtr(DPI_AWARENESS_CONTEXT, -5) else DPI_AWARENESS_CONTEXT(-5);
pub const DNS_ERROR_PRIMARY_REQUIRES_DATAFILE = @as(c_long, 9651);
pub const ControlServiceEx = ControlServiceExA;
pub const REG_DWORD_BIG_ENDIAN = @as(c_ulong, 5);
pub const GETSETPAPERBINS = 29;
pub const RPC_IF_ASYNC_CALLBACK = 256;
pub const DOMAIN_ALIAS_RID_POWER_USERS = @as(c_long, 547);
pub const SCARD_T0_HEADER_LENGTH = 7;
pub const JOB_NOTIFY_FIELD_DATATYPE = 5;
pub const IACE_DEFAULT = 16;
pub const SECURITY_WMIHOST_ID_RID_COUNT = @as(c_long, 6);
pub const CERT_OFFLINE_CRL_SIGN_KEY_USAGE = 2;
pub const KLF_REORDER = 8;
pub const PST_MODEM = if (@typeId(@typeOf(6)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 6) else if (@typeId(@typeOf(6)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 6) else DWORD(6);
pub const PF_LAT = AF_LAT;
pub const CLSID_NULL = GUID_NULL;
pub const PASSTHROUGH = 19;
pub const CRYPT_FORMAT_RDN_CRLF = 512;
pub const HBMMENU_POPUP_MAXIMIZE = if (@typeId(@typeOf(10)) == @import("builtin").TypeId.Pointer) @ptrCast(HBITMAP, 10) else if (@typeId(@typeOf(10)) == @import("builtin").TypeId.Int) @intToPtr(HBITMAP, 10) else HBITMAP(10);
pub const CHANGER_MOVE_EXTENDS_IEPORT = 2147484160;
pub const BCRYPT_ECC_PARAMETERS_MAGIC = 1346585413;
pub const RPC_S_INVALID_ENDPOINT_FORMAT = @as(c_long, 1706);
pub const dwFORCE_KEY_PROTECTION_HIGH = 2;
pub const SE_GROUP_RESOURCE = @as(c_long, 536870912);
pub const szOID_CROSS_CERT_DIST_POINTS = "1.3.6.1.4.1.311.10.9.1";
pub const DMDUP_SIMPLEX = 1;
pub const CTL_ENTRY_FROM_PROP_CHAIN_FLAG = 1;
pub const _UPPER = 1;
pub const MUTZ_FORCE_INTRANET_FLAGS = 8192;
pub const X3_I_SIZE_X = 1;
pub const CDS_TEST = 2;
pub const APPIDREGFLAGS_IUSERVER_SELF_SID_IN_LAUNCH_PERMISSION = 16;
pub const IMAGE_POLICY_METADATA_NAME = __ImagePolicyMetadata;
pub const MUI_LANGUAGE_LICENSED = 64;
pub const SUBLANG_YAKUT_RUSSIA = 1;
pub const ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION = 5;
pub const ERROR_INVALID_COMMAND_LINE = @as(c_long, 1639);
pub const PSH_PROPSHEETPAGE = 8;
pub const CAL_GREGORIAN_ARABIC = 10;
pub const FOREGROUND_BLUE = 1;
pub const RPC_BINDING_HANDLE_TEMPLATE_V1 = RPC_BINDING_HANDLE_TEMPLATE_V1_A;
pub const SNAPSHOT_POLICY_NEVER = 0;
pub const NCRYPT_TPM12_PROVIDER = 65536;
pub const CRYPT_LAST_OID_GROUP_ID = 10;
pub const FILE_ATTRIBUTE_VIRTUAL = 65536;
pub const ERROR_LOG_EPHEMERAL = @as(c_long, 6634);
pub const EM_GETTHUMB = 190;
pub const BF_TOP = 2;
pub const PSM_SETBUTTONTEXT = PSM_SETBUTTONTEXTW;
pub const RESOURCEDISPLAYTYPE_DOMAIN = 1;
pub const PRINTER_ATTRIBUTE_DO_COMPLETE_FIRST = 512;
pub const LANG_WOLOF = 136;
pub const PEERDIST_ERROR_OPERATION_NOTFOUND = @as(c_long, 4059);
pub const MIXERCONTROL_CT_UNITS_MASK = @as(c_long, 16711680);
pub const WM_POINTERWHEEL = 590;
pub const PSEUDOCONSOLE_INHERIT_CURSOR = 1;
pub const szOID_OIWSEC_md2RSASign = "1.3.14.3.2.24";
pub const TAPE_DRIVE_LOCK_UNLK_IMMED = 2147483776;
pub const MFS_DEFAULT = MF_DEFAULT;
pub const PRINTER_ATTRIBUTE_TS_GENERIC_DRIVER = 2097152;
pub const __LDBL_EPSILON__ = 0.000000;
pub const ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY = @as(c_long, 15036);
pub const FE_FONTSMOOTHINGORIENTATIONRGB = 1;
pub const ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED = @as(c_long, 1936);
pub const szOID_PKCS_5 = "1.2.840.113549.1.5";
pub const szOID_IPSEC_KP_IKE_INTERMEDIATE = "1.3.6.1.5.5.8.2.2";
pub const InterlockedOr = _InterlockedOr;
pub const CFS_FORCE_POSITION = 32;
pub const BS_PATTERN = 3;
pub const SEF_DEFAULT_GROUP_FROM_PARENT = 64;
pub const KDF_HMAC_KEY = 3;
pub const PRIVILEGE_SET_ALL_NECESSARY = 1;
pub const PopulationCount64 = __popcnt64;
pub const ERROR_DEVICE_HINT_NAME_BUFFER_TOO_SMALL = @as(c_long, 355);
pub const KEYSTATEBLOB = 12;
pub const EVENT_SYSTEM_DIALOGEND = 17;
pub const ERROR_INSTALL_VOLUME_NOT_EMPTY = @as(c_long, 15628);
pub const RPCFLG_INPUT_SYNCHRONOUS = @as(c_ulong, 536870912);
pub const RPC_INTERFACE_TEMPLATE = RPC_INTERFACE_TEMPLATEA;
pub const MCI_SYSINFO_NAME = @as(c_long, 1024);
pub const FILE_DEVICE_SMARTCARD = 49;
pub const TIME_NOSECONDS = 2;
pub const ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED = @as(c_long, 5942);
pub const ERROR_TOO_MANY_SEM_REQUESTS = @as(c_long, 103);
pub const VK_NUMPAD4 = 100;
pub const SendMessageCallback = SendMessageCallbackA;
pub const WM_UPDATEUISTATE = 296;
pub const _RPC_BINDING_HANDLE_TEMPLATE_V1 = _RPC_BINDING_HANDLE_TEMPLATE_V1_A;
pub const FLUSH_NV_MEMORY_IN_FLAG_NO_DRAIN = 1;
pub const CERT_ROOT_PROGRAM_FLAG_SUBJECT_LOGO = 32;
pub const SECURITY_CREATOR_OWNER_SERVER_RID = @as(c_long, 2);
pub const TRANSACTION_QUERY_INFORMATION = 1;
pub const IGP_PROPERTY = 4;
pub const MM_MIM_LONGERROR = 966;
pub const psh12 = 1035;
pub const MARK_HANDLE_PROTECT_CLUSTERS = 1;
pub const JOB_STATUS_DELETED = 256;
pub const ERROR_DATABASE_FAILURE = @as(c_long, 4313);
pub const FILL_NV_MEMORY_FLAG_NON_TEMPORAL = 2;
pub const __SCHAR_MAX__ = 127;
pub const URLMON_OPTION_USE_BROWSERAPPSDOCUMENTS = 268435472;
pub const SUBLANG_CENTRAL_KURDISH_IRAQ = 1;
pub const LOCALE_SISO3166CTRYNAME2 = 104;
pub const DeletePrintProcessor = DeletePrintProcessorA;
pub const MoveFile = MoveFileA;
pub const ERROR_CANNOT_FIND_WND_CLASS = @as(c_long, 1407);
pub const TIMESTAMP_FAILURE_EXTENSION_NOT_SUPPORTED = 16;
pub const CAL_SABBREVMONTHNAME2 = 35;
pub const PAN_WEIGHT_BLACK = 10;
pub const FR_HIDEWHOLEWORD = 65536;
pub const __UINT64_FMTX__ = "llX";
pub const WSA_QOS_ESERVICETYPE = @as(c_long, 11016);
pub const ERROR_ROWSNOTRELEASED = @as(c_long, 772);
pub const SYSTEM_PROCESS_TRUST_LABEL_ACE_TYPE = 20;
pub const CMSG_SIGNER_ONLY_FLAG = 2;
pub const LPOINET = LPIINTERNET;
pub const PRF_CLIENT = @as(c_long, 4);
pub const GCS_COMPREADCLAUSE = 4;
pub const CBF_FAIL_POKES = 65536;
pub const CERT_RDN_ISO646_STRING = 9;
pub const CONTEXT_E_LAST = @as(c_long, 2147803183);
pub const ERROR_QUOTA_ACTIVITY = @as(c_long, 810);
pub const PRODUCT_AZURE_SERVER_CORE = 168;
pub const GID_PRESSANDTAP = 7;
pub const STGM_DIRECT = @as(c_long, 0);
pub const WS_SYSMENU = @as(c_long, 524288);
pub const MDM_BEARERMODE_ANALOG = 0;
pub const MDM_V120_ML_DEFAULT = 0;
pub const SSL_HPKP_PKP_HEADER_INDEX = 0;
pub const VIF_DIFFLANG = @as(c_long, 8);
pub const PENVISUALIZATION_DOUBLETAP = 2;
pub const psh2 = 1025;
pub const DC_TRUETYPE = 15;
pub const PROCESS_CREATION_MITIGATION_POLICY2_RESTRICT_INDIRECT_BRANCH_PREDICTION_RESERVED = if (@typeId(@typeOf(i64 << 16)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 16) else if (@typeId(@typeOf(i64 << 16)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 16) else @as(c_uint, 3)(i64 << 16);
pub const IMAGE_REL_M32R_REFLO = 10;
pub const LPOINETPROTOCOL = LPIINTERNETPROTOCOL;
pub const MUI_QUERY_RESOURCE_TYPES = 8;
pub const Uri_HAS_PORT = 1 << Uri_PROPERTY_PORT;
pub const IMAGE_SCN_MEM_WRITE = 2147483648;
pub const C2_WHITESPACE = 10;
pub const SERVICE_USER_DEFINED_CONTROL = 256;
pub const __int3264 = __int64;
pub const ERROR_CORRUPT_LOG_UNAVAILABLE = @as(c_long, 796);
pub const RPC_S_UNSUPPORTED_TYPE = @as(c_long, 1732);
pub const SM_STARTER = 88;
pub const ERROR_SET_POWER_STATE_FAILED = @as(c_long, 1141);
pub const _Analysis_assume_section_unlocked_ = name;
pub const SetVolumeLabel = SetVolumeLabelA;
pub const NRC_NORES = 9;
pub const TXFS_RM_FLAG_LOG_CONTAINER_COUNT_MIN = 8;
pub const IMAGE_SYM_CLASS_FILE = 103;
pub const URLACTION_FEATURE_ZONE_ELEVATION = 8449;
pub const WM_DWMNCRENDERINGCHANGED = 799;
pub const KEY_SET_VALUE = 2;
pub const BS_INDEXED = 4;
pub const MMIO_EMPTYBUF = 16;
pub const RPCFLG_ACCESSIBILITY_BIT1 = @as(c_ulong, 1048576);
pub const szOID_OIWSEC_md4RSA = "1.3.14.3.2.2";
pub const IMAGE_ARCHIVE_HYBRIDMAP_MEMBER = "/<HYBRIDMAP>/   ";
pub const GCPCLASS_NEUTRAL = 3;
pub const IMC_SETCOMPOSITIONFONT = 10;
pub const PAN_PROP_EXPANDED = 5;
pub const BCRYPT_DSA_PRIVATE_MAGIC = 1448104772;
pub const ATTR_FIXEDCONVERTED = 5;
pub const GETVECTORBRUSHSIZE = 27;
pub const LB_FINDSTRINGEXACT = 418;
pub const FORMAT_MESSAGE_ARGUMENT_ARRAY = 8192;
pub const ERROR_RESOURCE_PROPERTIES_STORED = @as(c_long, 5024);
pub const ERROR_DS_ROOT_MUST_BE_NC = @as(c_long, 8301);
pub const DMBIN_LARGEFMT = 10;
pub const VP_FLAGS_OVERSCAN = 8;
pub const EVENTLOG_PAIRED_EVENT_ACTIVE = 8;
pub const FACILITY_HTTP = 25;
pub const SOFTDIST_FLAG_DELETE_SUBSCRIPTION = 8;
pub const URLPOLICY_AUTHENTICATE_CLEARTEXT_OK = 0;
pub const PD_SHOWHELP = 2048;
pub const CERT_CHAIN_ENABLE_CODE_SIGNING_HYGIENE_FLAG = 16777216;
pub const ERROR_UNKNOWN_COMPONENT = @as(c_long, 1607);
pub const CRYPTPROTECTMEMORY_SAME_LOGON = 2;
pub const APPCOMMAND_LAUNCH_MAIL = 15;
pub const VarI2FromUint = VarI2FromUI4;
pub const TAPE_DRIVE_PADDING = 262144;
pub const SWP_NOCOPYBITS = 256;
pub const MF_ERRORS = 268435456;
pub const JOB_OBJECT_LIMIT_PROCESS_MEMORY = 256;
pub const ERROR_LIBRARY_OFFLINE = @as(c_long, 4305);
pub const hyper = __int64;
pub const SLE_WARNING = 3;
pub const EXCEPTION_ARRAY_BOUNDS_EXCEEDED = STATUS_ARRAY_BOUNDS_EXCEEDED;
pub const __readableTo = extent;
pub const PF_ARM_VFP_32_REGISTERS_AVAILABLE = 18;
pub const FACILITY_CERT = 11;
pub const ERROR_DS_EXISTS_IN_MUST_HAVE = @as(c_long, 8385);
pub const WNNC_NET_NETWARE = 196608;
pub const PWR_SUSPENDREQUEST = 1;
pub const IMAGE_REL_CEF_TOKEN = 6;
pub const __useHeader = _Use_decl_anno_impl_;
pub const __releases_shared_lock = lock;
pub const __inner_adt_transfer_prop = arg;
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE = @as(c_long, 14017);
pub const FR_ENABLETEMPLATEHANDLE = 8192;
pub const SPI_GETFOCUSBORDERHEIGHT = 8208;
pub const RPC_C_PROTECT_LEVEL_NONE = RPC_C_AUTHN_LEVEL_NONE;
pub const __UINT_FAST16_FMTo__ = "ho";
pub const CRYPT_ACQUIRE_ALLOW_NCRYPT_KEY_FLAG = 65536;
pub const DNS_ERROR_NEED_SECONDARY_ADDRESSES = @as(c_long, 9614);
pub const CP_MACCP = 2;
pub const MEM_EXTENDED_PARAMETER_NONPAGED_HUGE = 16;
pub const szOID_PKCS_4 = "1.2.840.113549.1.4";
pub const SERVICE_LAUNCH_PROTECTED_WINDOWS_LIGHT = 2;
pub const ENABLE_ECHO_INPUT = 4;
pub const WM_SETFOCUS = 7;
pub const XCLASS_BOOL = 4096;
pub const NO_PROPAGATE_INHERIT_ACE = 4;
pub const LOCALE_SCOUNTRY = LOCALE_SLOCALIZEDCOUNTRYNAME;
pub const EMR_SETWINDOWEXTEX = 9;
pub const ERROR_INIT_STATUS_NEEDED = 17;
pub const ABN_STATECHANGE = 0;
pub const RPC_PROXY_CONNECTION_TYPE_OUT_PROXY = 1;
pub const EMR_SETSTRETCHBLTMODE = 21;
pub const EM_SETTABSTOPS = 203;
pub const CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG = 2;
pub const PAN_ARMSTYLE_INDEX = 6;
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE = @as(c_long, 8495);
pub const MCI_INFO_MEDIA_UPC = @as(c_long, 1024);
pub const ERROR_NO_IMPERSONATION_TOKEN = @as(c_long, 1309);
pub const RPC_C_VERS_UPTO = 5;
pub const POINTER_SIGNED = __sptr;
pub const META_PAINTREGION = 299;
pub const ERROR_DS_DRA_DB_ERROR = @as(c_long, 8451);
pub const VK_NUMPAD5 = 101;
pub const HS_API_MAX = 12;
pub const PROP_MED_CYDLG = 215;
pub const CB_SETEDITSEL = 322;
pub const WM_TIMER = 275;
pub const PIDDSI_SLIDECOUNT = 7;
pub const __llvm__ = 1;
pub const MIXER_GETLINECONTROLSF_ONEBYID = @as(c_long, 1);
pub const __UINT_FAST64_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const FILE_ENCRYPTABLE = 0;
pub const CBS_SIMPLE = @as(c_long, 1);
pub const VarIntFromR8 = VarI4FromR8;
pub const ERROR_NO_PROC_SLOTS = @as(c_long, 89);
pub const CRYPTPROTECT_LAST_RESERVED_FLAGVAL = 4294967295;
pub const psh11 = 1034;
pub const SECURITY_DYNAMIC_TRACKING = TRUE;
pub const SendDlgItemMessage = SendDlgItemMessageA;
pub const FILE_FLAG_RANDOM_ACCESS = 268435456;
pub const SDC_VIRTUAL_MODE_AWARE = 32768;
pub const PSP_USEICONID = 4;
pub const CERT_STORE_PROV_READ_CERT_FUNC = 1;
pub const WM_MDISETMENU = 560;
pub const RPC_C_PARM_BUFFER_LENGTH = 2;
pub const RESOURCETYPE_RESERVED = 8;
pub const __INT32_MAX__ = 2147483647;
pub const PFD_UNDERLAY_PLANE = -1;
pub const __source_code_content = typ;
pub const JOB_NOTIFY_FIELD_DEVMODE = 9;
pub const OCSP_BASIC_BY_KEY_RESPONDER_ID = 2;
pub const STATUS_TIMEOUT = if (@typeId(@typeOf(@as(c_long, 258))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 258)) else if (@typeId(@typeOf(@as(c_long, 258))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 258)) else DWORD(@as(c_long, 258));
pub const CS_E_LAST = @as(c_long, 2147746159);
pub const RPC_S_INTERFACE_NOT_FOUND = @as(c_long, 1759);
pub const chx1 = 1040;
pub const DMPAPER_FANFOLD_STD_GERMAN = 40;
pub const WM_NCPOINTERUPDATE = 577;
pub const CAL_SABBREVMONTHNAME3 = 36;
pub const InterlockedCompareExchangeAcquire64 = InterlockedCompareExchange64;
pub const WOF_PROVIDER_CLOUD = 3;
pub const IMAGE_REL_ALPHA_ABSOLUTE = 0;
pub const CREATE_BREAKAWAY_FROM_JOB = 16777216;
pub const ERROR_GUID_SUBSTITUTION_MADE = @as(c_long, 680);
pub const DNS_ERROR_RESPONSE_CODES_BASE = 9000;
pub const FNERR_FILENAMECODES = 12288;
pub const SPI_SETDRAGWIDTH = 76;
pub const VarIntFromI2 = VarI4FromI2;
pub const REG_QWORD = @as(c_ulong, 11);
pub const CLOSECHANNEL = 4112;
pub const CERT_STORE_CTRL_COMMIT_FORCE_FLAG = 1;
pub const SERVICE_PAUSE_CONTINUE = 64;
pub const FACILITY_USERMODE_VOLSNAP = 130;
pub const LCMAP_HIRAGANA = 1048576;
pub const EVENT_UIA_PROPID_START = 29952;
pub const SBM_GETSCROLLINFO = 234;
pub const SCardIntroduceReader = SCardIntroduceReaderA;
pub const FILE_FLAG_DELETE_ON_CLOSE = 67108864;
pub const psh3 = 1026;
pub const GR_GDIOBJECTS = 0;
pub const SHEnumerateUnreadMailAccounts = SHEnumerateUnreadMailAccountsA;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_INDEX = 33554432;
pub const FORM_PRINTER = 2;
pub const LOCALE_ITIME = 35;
pub const SYNCHRONIZE = @as(c_long, 1048576);
pub const RTL_CORRELATION_VECTOR_V1_LENGTH = 64;
pub const DDL_SYSTEM = 4;
pub const NUMMARKERS = 20;
pub const SUBLANG_MALAYALAM_INDIA = 1;
pub const CMSG_CRL_COUNT_PARAM = 13;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH = JOB_OBJECT_LIMIT_JOB_MEMORY;
pub const cmb5 = 1140;
pub const MCI_GETDEVCAPS_DEVICE_TYPE = @as(c_long, 4);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_BITS_FLAG = 16;
pub const PPM_FIRMWARE_TSD = 8192;
pub const DIALOPTION_BILLING = 64;
pub const RPC_S_SERVER_TOO_BUSY = @as(c_long, 1723);
pub const SM_CYCURSOR = 14;
pub const RPCFLG_ACCESSIBILITY_BIT2 = @as(c_ulong, 2097152);
pub const RPC_S_INVALID_OBJECT = @as(c_long, 1900);
pub const EV_PERR = 512;
pub const Uri_ENCODING_USER_INFO_AND_PATH_IS_PERCENT_ENCODED_UTF8 = 1;
pub const RPC_C_IMP_LEVEL_IDENTIFY = 2;
pub const FILE_DEVICE_VDM = 44;
pub const CC_WIDESTYLED = 64;
pub const VK_RWIN = 92;
pub const BitTestAndComplement = _bittestandcomplement;
pub const EXCEPTION_FLT_DIVIDE_BY_ZERO = STATUS_FLOAT_DIVIDE_BY_ZERO;
pub const LB_GETTOPINDEX = 398;
pub const MFT_RIGHTJUSTIFY = MF_RIGHTJUSTIFY;
pub const ERROR_DS_ADMIN_LIMIT_EXCEEDED = @as(c_long, 8228);
pub const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT_CURRENT_VERSION = NCRYPT_VSM_KEY_ATTESTATION_STATEMENT_V0;
pub const QDC_VIRTUAL_MODE_AWARE = 16;
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_BASIC_CONSTRAINTS_FLAG = 8;
pub const CMC_TAGGED_CERT_REQUEST_CHOICE = 1;
pub const COPY_FILE_RESUME_FROM_PAUSE = 16384;
pub const __UINT16_FMTo__ = "ho";
pub const ClearEventLog = ClearEventLogA;
pub const WM_POINTERLEAVE = 586;
pub const CFSTR_MIME_RAWDATASTRM = if (@typeId(@typeOf("application/octet-stream")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "application/octet-stream") else if (@typeId(@typeOf("application/octet-stream")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "application/octet-stream") else TEXT("application/octet-stream");
pub const IME_ESC_IME_NAME = 4102;
pub const MCI_SEQ_SMPTE = 16388;
pub const TXFS_ROLLFORWARD_REDO_FLAG_USE_LAST_REDO_LSN = 1;
pub const HC_NOREM = HC_NOREMOVE;
pub const WN_NOT_SUPPORTED = ERROR_NOT_SUPPORTED;
pub const CFS_DEFAULT = 0;
pub const OBJID_VSCROLL = if (@typeId(@typeOf(4294967291)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG, 4294967291) else if (@typeId(@typeOf(4294967291)) == @import("builtin").TypeId.Int) @intToPtr(LONG, 4294967291) else LONG(4294967291);
pub const BCRYPT_HASH_INTERFACE = 2;
pub const FILE_READ_ACCESS = 1;
pub const HELP_PARTIALKEY = @as(c_long, 261);
pub const SERVICE_CONTROL_TIMECHANGE = 16;
pub const PROCESSOR_MOTOROLA_821 = 821;
pub const CERT_STORE_PROV_GET_CTL_PROPERTY_FUNC = 22;
pub const IME_CMODE_HANJACONVERT = 64;
pub const CFERR_NOFONTS = 8193;
pub const IsBadStringPtr = IsBadStringPtrA;
pub const SMB_CCF_APP_INSTANCE_EA_NAME = "ClusteredApplicationInstance";
pub const VFFF_ISSHAREDFILE = 1;
pub const LANG_BENGALI = 69;
pub const PROCESSOR_OPTIL = 18767;
pub const szOID_PKCS_3 = "1.2.840.113549.1.3";
pub const DISPLAYCONFIG_MAXPATH = 1024;
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MAX = 1;
pub const SETDIBSCALING = 32;
pub const MDM_PROTOCOLID_GPRS = 8;
pub const DISPATCH_PROPERTYGET = 2;
pub const COPY_FILE_NO_OFFLOAD = 262144;
pub const MUI_LIP_LANGUAGE = 4;
pub const IOC_IN = 2147483648;
pub const FAST_FAIL_GUARD_SS_FAILURE = 44;
pub const szOID_PKIX_OCSP_NOCHECK = "1.3.6.1.5.5.7.48.1.5";
pub const CERT_CHAIN_CACHE_END_CERT = 1;
pub const VK_NUMPAD2 = 98;
pub const PBT_APMRESUMESTANDBY = 8;
pub const szOID_PKIX_POLICY_QUALIFIER_CPS = "1.3.6.1.5.5.7.2.1";
pub const szOID_OIWDIR_CRPT = "1.3.14.7.2.1";
pub const ERROR_DS_SOURCE_DOMAIN_IN_FOREST = @as(c_long, 8534);
pub const EXCEPTION_COLLIDED_UNWIND = 64;
pub const VK_LAUNCH_MEDIA_SELECT = 181;
pub const TAPE_DRIVE_ERASE_LONG = 32;
pub const STRING_MUIDLL = 2;
pub const PARTITION_GPT = 238;
pub const EMR_SETMAPMODE = 17;
pub const FOF_CONFIRMMOUSE = 2;
pub const ERROR_IPSEC_IKE_INVALID_CERT_TYPE = @as(c_long, 13819);
pub const PAN_MIDLINE_LOW_TRIMMED = 11;
pub const RPC_S_INVALID_STRING_UUID = @as(c_long, 1705);
pub const ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND = @as(c_long, 13015);
pub const psh10 = 1033;
pub const SPI_GETBLOCKSENDINPUTRESETS = 4134;
pub const CLASSFACTORY_S_FIRST = @as(c_long, 262416);
pub const SCARD_READER_TYPE_SERIAL = 1;
pub const ENOTCONN = 126;
pub const ERROR_DS_NC_STILL_HAS_DSAS = @as(c_long, 8546);
pub const chx6 = 1045;
pub const DNS_ERROR_RRL_NOT_ENABLED = @as(c_long, 9911);
pub const FADF_BSTR = 256;
pub const OBJ_DC = 3;
pub const ERROR_SXS_IDENTITIES_DIFFERENT = @as(c_long, 14102);
pub const RpcNsGroupMbrInqNext = RpcNsGroupMbrInqNextA;
pub const DM_UPDATE = 1;
pub const APPCOMMAND_LAUNCH_APP1 = 17;
pub const TIME_BYTES = 4;
pub const JOY_BUTTON3CHG = 1024;
pub const SM_CXDRAG = 68;
pub const DMTT_DOWNLOAD = 2;
pub const IPPROTO_GGP = 3;
pub const DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT_V1 = 1;
pub const ERROR_EFS_DISABLED = @as(c_long, 6015);
pub const WM_MDIGETACTIVE = 553;
pub const NONZEROLPTR = LMEM_FIXED;
pub const GetTextExtentExPoint = GetTextExtentExPointA;
pub const EMR_CREATEDIBPATTERNBRUSHPT = 94;
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_POLICY_FLAG = 128;
pub const BLACK_PEN = 7;
pub const DRAGDROP_S_LAST = @as(c_long, 262415);
pub const STATUS_FLOAT_UNDERFLOW = if (@typeId(@typeOf(@as(c_long, 3221225619))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225619)) else if (@typeId(@typeOf(@as(c_long, 3221225619))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225619)) else DWORD(@as(c_long, 3221225619));
pub const LOCALE_SLOCALIZEDDISPLAYNAME = 2;
pub const MCI_ANIM_OPEN_NOSTATIC = @as(c_long, 262144);
pub const EVENT_AIA_START = 40960;
pub const RESOURCEDISPLAYTYPE_GENERIC = 0;
pub const DC_PEN = 19;
pub const PSINJECT_SHOWPAGE = 105;
pub const cmb4 = 1139;
pub const RPI_FLAG_SMB2_SHARECAP_TIMEWARP = 2;
pub const EMR_SETPALETTEENTRIES = 50;
pub const FILE_WRITE_DATA = 2;
pub const JOB_STATUS_SPOOLING = 8;
pub const szOID_RSA = "1.2.840.113549";
pub const ERROR_DS_DOMAIN_RENAME_IN_PROGRESS = @as(c_long, 8612);
pub const CERT_CHAIN_DISABLE_AUTH_ROOT_AUTO_UPDATE = 256;
pub const LC_MARKER = 4;
pub const ERROR_SET_CONTEXT_DENIED = @as(c_long, 1660);
pub const WM_IME_CHAR = 646;
pub const TAPE_RETURN_STATISTICS = @as(c_long, 0);
pub const CERT_LOGOTYPE_COLOR_IMAGE_INFO_CHOICE = 2;
pub const SHTDN_REASON_MINOR_BLUESCREEN = 15;
pub const CRYPT_RC2_56BIT_VERSION = 52;
pub const InterlockedIncrement64 = _InterlockedIncrement64;
pub const CF_INITTOLOGFONTSTRUCT = @as(c_long, 64);
pub const ERROR_QUORUM_RESOURCE = @as(c_long, 5020);
pub const CERT_REGISTRY_STORE_MY_IE_DIRTY_FLAG = 524288;
pub const FAST_FAIL_INVALID_JUMP_BUFFER = 18;
pub const DMPAPER_A2 = 66;
pub const SUBLANG_PORTUGUESE = 2;
pub const CERT_OID_NAME_STR = 2;
pub const INHERIT_CALLER_PRIORITY = 131072;
pub const ERROR_INVALID_PASSWORD = @as(c_long, 86);
pub const CRYPT_OID_ENCODE_OBJECT_FUNC = "CryptDllEncodeObject";
pub const URLPOLICY_DISALLOW = 3;
pub const THREAD_MODE_BACKGROUND_BEGIN = 65536;
pub const PPCAPS_SQUARE_SCALING = 1;
pub const LOCALE_SUPPLEMENTAL = 2;
pub const ALG_CLASS_MSG_ENCRYPT = 2 << 13;
pub const CRL_DIST_POINT_ERR_INDEX_MASK = 127;
pub const ENDSESSION_CLOSEAPP = 1;
pub const EASTEUROPE_CHARSET = 238;
pub const MDM_V120_SPEED_DEFAULT = 0;
pub const LOCALE_SSHORTESTPM = 127;
pub const FAST_FAIL_INVALID_CONTROL_STACK = 47;
pub const PRODUCT_PRO_FOR_EDUCATION = 164;
pub const MOUSEEVENTF_RIGHTUP = 16;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_PROCESS_EXIT = 3;
pub const META_POLYLINE = 805;
pub const EMR_GLSRECORD = 102;
pub const WM_ACTIVATEAPP = 28;
pub const RPC_C_OPT_COOKIE_AUTH = 7;
pub const __UINT_FAST8_FMTX__ = "hhX";
pub const DFCS_SCROLLUP = 0;
pub const PRODUCT_HOLOGRAPHIC = 135;
pub const RPC_S_NOT_ALL_OBJS_UNEXPORTED = @as(c_long, 1758);
pub const SM_CYDRAG = 69;
pub const szOID_PKCS_2 = "1.2.840.113549.1.2";
pub const RPC_S_ADDRESS_ERROR = @as(c_long, 1768);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN = if (@typeId(@typeOf(12)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 12) else if (@typeId(@typeOf(12)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 12) else LPCSTR(12);
pub const EMSGSIZE = 115;
pub const SHGNLI_PIDL = 1;
pub const RID_INPUT = 268435459;
pub const KP_PUB_PARAMS = 39;
pub const CTRY_BULGARIA = 359;
pub const WM_XBUTTONDBLCLK = 525;
pub const ACTCTX_FLAG_APPLICATION_NAME_VALID = 32;
pub const TXFS_SAVEPOINT_CLEAR_ALL = 16;
pub const CDS_NORESET = 268435456;
pub const CRYPT_CREATE_NEW_FLUSH_ENTRY = 268435456;
pub const CLIPCAPS = 36;
pub const EnumSystemLanguageGroups = EnumSystemLanguageGroupsA;
pub const DC_HASDEFID = 21323;
pub const FormatMessage = FormatMessageA;
pub const NLS_DBCSCHAR = 65536;
pub const JOB_OBJECT_LIMIT_SCHEDULING_CLASS = 128;
pub const ERROR_DS_SHUTTING_DOWN = @as(c_long, 8364);
pub const HCBT_SYSCOMMAND = 8;
pub const VK_NUMPAD3 = 99;
pub const DEVICEFAMILYDEVICEFORM_ALLINONE = 7;
pub const PERFSTATE_POLICY_CHANGE_INCREASE_MAX = PERFSTATE_POLICY_CHANGE_IDEAL_AGGRESSIVE;
pub const MDM_V110_SPEED_38DOT4K = 9;
pub const ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID = @as(c_long, 13888);
pub const IMAGE_SIZEOF_SECTION_HEADER = 40;
pub const CF_NOVERTFONTS = @as(c_long, 16777216);
pub const ERROR_USER_EXISTS = @as(c_long, 1316);
pub const ERROR_STORAGE_LOST_DATA_PERSISTENCE = @as(c_long, 368);
pub const DNS_WARNING_DOMAIN_UNDELETED = @as(c_long, 9716);
pub const RPC_X_WRONG_PIPE_VERSION = @as(c_long, 1832);
pub const PRINTER_ENUM_CONTAINER = 32768;
pub const ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT = @as(c_long, 585);
pub const CB_ERRSPACE = -2;
pub const X3_D_WH_INST_WORD_POS_X = 24;
pub const ACCESS_SYSTEM_SECURITY = @as(c_long, 16777216);
pub const NCRYPT_CLAIM_PLATFORM = 65536;
pub const FACILITY_DIRECTORYSERVICE = 37;
pub const EDS_ROTATEDMODE = 4;
pub const PAN_CONTRAST_VERY_LOW = 3;
pub const chx7 = 1046;
pub const TAPE_DRIVE_WRITE_LONG_FMKS = 2281701376;
pub const CAL_SABBREVMONTHNAME1 = 34;
pub const URLACTION_HTML_MIXED_CONTENT = 5641;
pub const szOID_SITE_PIN_RULES_FLAGS_ATTR = "1.3.6.1.4.1.311.10.4.3";
pub const IMAGE_REL_EBC_SECREL = 4;
pub const CHANGER_OPEN_IEPORT = 8;
pub const URLACTION_NETWORK_CURR_MAX = 6672;
pub const GCS_COMPREADATTR = 2;
pub const GA_PARENT = 1;
pub const VFT_VXD = @as(c_long, 5);
pub const DNS_ERROR_NOT_ALLOWED_ON_SIGNED_ZONE = @as(c_long, 9102);
pub const PRODUCT_PRO_FOR_EDUCATION_N = 165;
pub const ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD = @as(c_long, 8529);
pub const SW_SHOWNOACTIVATE = 4;
pub const RPC_C_FULL_CERT_CHAIN = 1;
pub const ERROR_INVALID_LEVEL = @as(c_long, 124);
pub const DNS_ERROR_KSP_NOT_ACCESSIBLE = @as(c_long, 9112);
pub const MM_MCINOTIFY = 953;
pub const DESKTOP_JOURNALRECORD = @as(c_long, 16);
pub const VTDATEGRE_MIN = -657434;
pub const OPEN_EXISTING = 3;
pub const ERROR_DS_DRA_BAD_INSTANCE_TYPE = @as(c_long, 8445);
pub const THREAD_PRIORITY_HIGHEST = THREAD_BASE_PRIORITY_MAX;
pub const S_OK = if (@typeId(@typeOf(@as(c_long, 0))) == @import("builtin").TypeId.Pointer) @ptrCast(HRESULT, @as(c_long, 0)) else if (@typeId(@typeOf(@as(c_long, 0))) == @import("builtin").TypeId.Int) @intToPtr(HRESULT, @as(c_long, 0)) else HRESULT(@as(c_long, 0));
pub const MOD_CONTROL = 2;
pub const FILE_SUPPORTS_TRANSACTIONS = 2097152;
pub const CERT_TRUST_NO_ERROR = 0;
pub const _CRT_SIZE_MAX = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(size_t, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(size_t, -1) else size_t(-1);
pub const CALG_OID_INFO_PARAMETERS = 4294967294;
pub const FACILITY_NAP = 39;
pub const CAL_USE_CP_ACP = LOCALE_USE_CP_ACP;
pub const MDM_SHIFT_PROTOCOLID = 16;
pub const IMAGE_ENCLAVE_FLAG_PRIMARY_IMAGE = 1;
pub const ERROR_CLUSTER_NETWORK_NOT_INTERNAL = @as(c_long, 5060);
pub const ERROR_DLL_INIT_FAILED = @as(c_long, 1114);
pub const SUBLANG_MARATHI_INDIA = 1;
pub const SEE_MASK_DOENVSUBST = 512;
pub const ERROR_IPSEC_BAD_SPI = @as(c_long, 13910);
pub const PRODUCT_EMBEDDED_E_EVAL = 108;
pub const PRODUCT_CLOUDN = 179;
pub const WM_INPUT = 255;
pub const NDR_SHAREABLE = __inline;
pub const WM_MOUSEHOVER = 673;
pub const HSHELL_HIGHBIT = 32768;
pub const cmb7 = 1142;
pub const THREAD_BASE_PRIORITY_LOWRT = 15;
pub const RPC_PROTSEQ_NMP = 2;
pub const ERROR_DYNLINK_FROM_INVALID_RING = @as(c_long, 196);
pub const ERROR_ACCOUNT_DISABLED = @as(c_long, 1331);
pub const FOF_SILENT = 4;
pub const WS_EX_NOREDIRECTIONBITMAP = @as(c_long, 2097152);
pub const WRITE_WATCH_FLAG_RESET = 1;
pub const SCARD_PRESENT = 2;
pub const SERVICE_PKG_SERVICE = 512;
pub const ENABLE_INSERT_MODE = 32;
pub const RPC_S_SEND_INCOMPLETE = @as(c_long, 1913);
pub const COLOR_3DLIGHT = 22;
pub const OBJID_SOUND = if (@typeId(@typeOf(4294967285)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG, 4294967285) else if (@typeId(@typeOf(4294967285)) == @import("builtin").TypeId.Int) @intToPtr(LONG, 4294967285) else LONG(4294967285);
pub const CRYPTNET_URL_CACHE_DISABLE_FLUSH = 4294967295;
pub const CreateFileMapping = CreateFileMappingA;
pub const MCI_SEQ_NONE = 65533;
pub const ERROR_IPSEC_IKE_TOO_MANY_FILTERS = @as(c_long, 13896);
pub const SMART_INVALID_REGISTER = 8;
pub const EVENT_CONSOLE_START_APPLICATION = 16390;
pub const CTRY_MEXICO = 52;
pub const DC_STAPLE = 30;
pub const DMDO_270 = 3;
pub const SetDefaultCommConfig = SetDefaultCommConfigA;
pub const __byte_writableTo = size;
pub const OF_SHARE_DENY_READ = 48;
pub const TF_WRITE_BEHIND = 4;
pub const RPC_C_OPT_PRIVATE_BREAK_ON_SUSPEND = 3;
pub const LCMAP_TITLECASE = 768;
pub const ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE = @as(c_long, 14107);
pub const SC_MAXIMIZE = 61488;
pub const FILE_ATTRIBUTE_ARCHIVE = 32;
pub const DMPAPER_A3 = 8;
pub const LOCK_UNLOCK_IEPORT = 1;
pub const PRINTER_STATUS_WAITING = 8192;
pub const szOID_RSA_MGF1 = "1.2.840.113549.1.1.8";
pub const ERROR_PROFILE_DOES_NOT_MATCH_DEVICE = @as(c_long, 2023);
pub const ESB_DISABLE_LTUP = ESB_DISABLE_LEFT;
pub const DEVICEFAMILYINFOENUM_7067329 = 15;
pub const ERROR_WAIT_FOR_OPLOCK = @as(c_long, 765);
pub const ABN_POSCHANGED = 1;
pub const RPC_X_PIPE_EMPTY = @as(c_long, 1918);
pub const META_SELECTPALETTE = 564;
pub const DOMAIN_ALIAS_RID_RDS_ENDPOINT_SERVERS = @as(c_long, 576);
pub const DMPAPER_FANFOLD_US = 39;
pub const CERT_FIND_NO_ENHKEY_USAGE_FLAG = 8;
pub const SHTDN_REASON_MINOR_NETWORKCARD = 9;
pub const SUBLANG_SPANISH_PUERTO_RICO = 20;
pub const VK_PLAY = 250;
pub const MAPVK_VK_TO_VSC = 0;
pub const IP_ADD_MEMBERSHIP = 5;
pub const SM_ARRANGE = 56;
pub const PORT_STATUS_TYPE_ERROR = 1;
pub const ERROR_CTX_CONSOLE_DISCONNECT = @as(c_long, 7041);
pub const FACILITY_USERMODE_SDBUS = 2305;
pub const VIFF_FORCEINSTALL = 1;
pub const __acquires_exclusive_lock = lock;
pub const WINAPI_PARTITION_PHONE = WINAPI_PARTITION_PHONE_APP;
pub const szOID_OS_VERSION = "1.3.6.1.4.1.311.13.2.3";
pub const ERROR_FAIL_REBOOT_REQUIRED = @as(c_long, 3017);
pub const szOID_PKCS_1 = "1.2.840.113549.1.1";
pub const SCARD_T1_PROLOGUE_LENGTH = 3;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_SID = 5;
pub const PKCS12_VIRTUAL_ISOLATION_KEY = 65536;
pub const __AVX__ = 1;
pub const SPI_GETMOUSEDRAGOUTTHRESHOLD = 132;
pub const SW_OTHERUNZOOM = 4;
pub const EWOULDBLOCK = 140;
pub const NI_OPENCANDIDATE = 16;
pub const ReadPMC = __readpmc;
pub const IOCTL_STORAGE_BASE = FILE_DEVICE_MASS_STORAGE;
pub const ERROR_DELETE_PENDING = @as(c_long, 303);
pub const MA_ACTIVATEANDEAT = 2;
pub const SECURITY_BUILTIN_CAPABILITY_RID_COUNT = @as(c_long, 2);
pub const CBF_FAIL_SELFCONNECTIONS = 4096;
pub const CURRENT_IMPORT_REDIRECTION_VERSION = 1;
pub const SHTDN_REASON_MINOR_ENVIRONMENT = 12;
pub const ERROR_VOLUME_DIRTY = @as(c_long, 6851);
pub const ERROR_MRM_NO_MATCH_OR_DEFAULT_CANDIDATE = @as(c_long, 15116);
pub const ERROR_SXS_RELEASE_ACTIVATION_CONTEXT = @as(c_long, 14088);
pub const VK_NUMPAD0 = 96;
pub const WM_POINTERDEVICEINRANGE = 569;
pub const PD_RESULT_APPLY = 2;
pub const STORAGE_HW_FIRMWARE_INVALID_SLOT = 255;
pub const BCRYPT_AES_CCM_ALG_HANDLE = if (@typeId(@typeOf(465)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 465) else if (@typeId(@typeOf(465)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 465) else BCRYPT_ALG_HANDLE(465);
pub const SUBLANG_AFRIKAANS_SOUTH_AFRICA = 1;
pub const CERT_CRL_SIGN_KEY_USAGE = 2;
pub const ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS = @as(c_long, 5067);
pub const BS_DIBPATTERNPT = 6;
pub const EnumDisplayDevices = EnumDisplayDevicesA;
pub const WM_MENUDRAG = 291;
pub const DCB_DISABLE = 8;
pub const SPI_SETFONTSMOOTHINGCONTRAST = 8205;
pub const SPI_SETSYSTEMLANGUAGEBAR = 4177;
pub const CBN_SELENDCANCEL = 10;
pub const ERROR_TRUSTED_RELATIONSHIP_FAILURE = @as(c_long, 1789);
pub const __SSE3__ = 1;
pub const BACKUP_EA_DATA = 2;
pub const szOID_RSA_unstructName = "1.2.840.113549.1.9.2";
pub const ERROR_TAG_NOT_PRESENT = @as(c_long, 2013);
pub const FILE_SYSTEM_DIR = 4;
pub const EV_RLSD = 32;
pub const WM_GETDLGCODE = 135;
pub const MK_XBUTTON2 = 64;
pub const CERT_NAME_STR_FORWARD_FLAG = 16777216;
pub const BROADCAST_QUERY_DENY = 1112363332;
pub const SPI_SETCONTACTVISUALIZATION = 8217;
pub const WSA_QOS_EFLOWCOUNT = @as(c_long, 11023);
pub const chx4 = 1043;
pub const ERROR_WRITE_FAULT = @as(c_long, 29);
pub const CAL_SABBREVMONTHNAME6 = 39;
pub const POWER_REQUEST_CONTEXT_VERSION = DIAGNOSTIC_REASON_VERSION;
pub const MCI_SEQ_MIDI = 16387;
pub const ERROR_DS_EXISTS_IN_SUB_CLS = @as(c_long, 8394);
pub const CERT_CHAIN_DISABLE_MY_PEER_TRUST = 2048;
pub const __WCHAR_UNSIGNED__ = 1;
pub const CFSTR_MIME_X_EMF = if (@typeId(@typeOf("image/x-emf")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "image/x-emf") else if (@typeId(@typeOf("image/x-emf")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "image/x-emf") else TEXT("image/x-emf");
pub const CRYPT_OID_DISABLE_SEARCH_DS_FLAG = 2147483648;
pub const SERVICE_RUNS_IN_SYSTEM_PROCESS = 1;
pub const HCBT_DESTROYWND = 4;
pub const STORAGE_OFFLOAD_TOKEN_INVALID = 2;
pub const URLACTION_ALLOW_RESTRICTEDPROTOCOLS = 8960;
pub const GCLP_HICON = -14;
pub const VarIntFromI1 = VarI4FromI1;
pub const ERROR_STATE_SET_VERSION_FAILED = @as(c_long, 15802);
pub const PERF_DISPLAY_PERCENT = 536870912;
pub const CRYPT_LOCALIZED_NAME_OID = "LocalizedNames";
pub const CF_MAX = 18;
pub const NLS_IME_DISABLE = 536870912;
pub const PC_WIDESTYLED = 64;
pub const DNS_ERROR_INVALID_ZONESCOPE_NAME = @as(c_long, 9954);
pub const szOID_BACKGROUND_OTHER_LOGOTYPE = "1.3.6.1.5.5.7.20.2";
pub const NRC_INVDDID = 59;
pub const JOB_CONTROL_DELETE = 5;
pub const CALLBACK_EVENT = @as(c_long, 327680);
pub const ERROR_CLUSTER_JOIN_IN_PROGRESS = @as(c_long, 5041);
pub const WINCRYPT32STRINGAPI = WINCRYPT32API;
pub const CERT_NEW_KEY_PROP_ID = 74;
pub const HELP_TCARD = 32768;
pub const ERROR_CLASS_DOES_NOT_EXIST = @as(c_long, 1411);
pub const szOID_OIWDIR = "1.3.14.7.2";
pub const DeletePrinterConnection = DeletePrinterConnectionA;
pub const ERROR_CTX_WINSTATION_ACCESS_DENIED = @as(c_long, 7045);
pub const PRODUCT_ENTERPRISE = 4;
pub const CTRY_ALBANIA = 355;
pub const ERROR_REPARSE_TAG_MISMATCH = @as(c_long, 4394);
pub const TOKEN_ASSIGN_PRIMARY = 1;
pub const WM_COMPACTING = 65;
pub const cmb6 = 1141;
pub const STANDARD_RIGHTS_REQUIRED = @as(c_long, 983040);
pub const CMSG_OID_CAPI1_IMPORT_MAIL_LIST_FUNC = CMSG_OID_IMPORT_MAIL_LIST_FUNC;
pub const DATE_RTLREADING = 32;
pub const STORAGE_TIER_FLAG_PARITY = 8388608;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT = @as(c_long, 13835);
pub const IME_PROP_SPECIAL_UI = 131072;
pub const SYNCHRONIZATION_BARRIER_FLAGS_NO_DELETE = 4;
pub const PRINTER_CHANGE_ADD_PRINTER_DRIVER = 268435456;
pub const EPSPRINTING = 33;
pub const szOID_WINDOWS_TCB_SIGNER = "1.3.6.1.4.1.311.10.3.23";
pub const LOCALE_SPECIFICDATA = 32;
pub const SWP_NOSENDCHANGING = 1024;
pub const NEWTRANSPARENT = 3;
pub const ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND = @as(c_long, 5078);
pub const SPI_GETSYSTEMLANGUAGEBAR = 4176;
pub const MAXSIZE_T = if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(SIZE_T, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(SIZE_T, 0) else SIZE_T(0))) == @import("builtin").TypeId.Pointer) @ptrCast(SIZE_T, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(SIZE_T, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(SIZE_T, 0) else SIZE_T(0)) else if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(SIZE_T, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(SIZE_T, 0) else SIZE_T(0))) == @import("builtin").TypeId.Int) @intToPtr(SIZE_T, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(SIZE_T, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(SIZE_T, 0) else SIZE_T(0)) else SIZE_T(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(SIZE_T, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(SIZE_T, 0) else SIZE_T(0));
pub const ELEMENT_STATUS_ID_VALID = 8192;
pub const TRANSACTION_DO_NOT_PROMOTE = 1;
pub const SORT_HUNGARIAN_DEFAULT = 0;
pub const SP_SERIALCOMM = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 1) else DWORD(1);
pub const WS_EX_CONTEXTHELP = @as(c_long, 1024);
pub const MIXER_GETLINECONTROLSF_QUERYMASK = @as(c_long, 15);
pub const HKL_PREV = 0;
pub const SCARD_PROTOCOL_OPTIMAL = 0;
pub const STORAGE_TIER_DESCRIPTION_LENGTH = 512;
pub const VK_RETURN = 13;
pub const SW_MINIMIZE = 6;
pub const __INT_FAST32_FMTd__ = "d";
pub const DMPAPER_A4 = 9;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER = 22;
pub const WSA_QOS_BAD_OBJECT = @as(c_long, 11013);
pub const RI_KEY_TERMSRV_SHADOW = 16;
pub const FAST_FAIL_INVALID_FIBER_SWITCH = 12;
pub const SEVERITY_ERROR = 1;
pub const BS_RADIOBUTTON = @as(c_long, 4);
pub const ERROR_DS_UPN_VALUE_NOT_UNIQUE_IN_FOREST = @as(c_long, 8648);
pub const ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_MERGE = @as(c_long, 15141);
pub const UINT_MAX = 4294967295;
pub const DEVICE_DSM_PHYSICAL_ADDRESS_HAS_MEMORY_ERROR = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(LONGLONG, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(LONGLONG, -1) else LONGLONG(-1);
pub const CRYPT_SECRETDIGEST = 1;
pub const PRODUCT_CLUSTER_SERVER = 18;
pub const STATUS_INTEGER_DIVIDE_BY_ZERO = if (@typeId(@typeOf(@as(c_long, 3221225620))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225620)) else if (@typeId(@typeOf(@as(c_long, 3221225620))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225620)) else DWORD(@as(c_long, 3221225620));
pub const __INT_LEAST64_MAX__ = @as(c_longlong, 9223372036854775807);
pub const PIDDSI_NOTECOUNT = 8;
pub const PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_MASK = if (@typeId(@typeOf(i64 << 44)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 44) else if (@typeId(@typeOf(i64 << 44)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 44) else @as(c_uint, 3)(i64 << 44);
pub const MCI_GETDEVCAPS_CAN_SAVE = @as(c_long, 9);
pub const WM_GETTEXTLENGTH = 14;
pub const ERROR_IPSEC_IKE_SRVACQFAIL = @as(c_long, 13855);
pub const szOID_SORTED_CTL = "1.3.6.1.4.1.311.10.1.1";
pub const JOB_OBJECT_ASSIGN_PROCESS = 1;
pub const NFR_ANSI = 1;
pub const IMAGE_REL_AM_SECTION = 8;
pub const SERVICE_BOOT_START = 0;
pub const SUBLANG_SPANISH_US = 21;
pub const PIPE_SERVER_END = 1;
pub const SEE_MASK_CLASSKEY = 3;
pub const SB_NONE = 0;
pub const OBJ_ENHMETADC = 12;
pub const ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC = @as(c_long, 8580);
pub const SCARD_PROTOCOL_DEFAULT = 2147483648;
pub const FloppyClassGuid = GUID_DEVINTERFACE_FLOPPY;
pub const CFS_CANDIDATEPOS = 64;
pub const IS_TEXT_UNICODE_REVERSE_CONTROLS = 64;
pub const DC_MAXEXTENT = 5;
pub const JOB_STATUS_PRINTING = 16;
pub const DM_BITSPERPEL = @as(c_long, 262144);
pub const EMR_ALPHABLEND = 114;
pub const CRYPT_OID_PUBKEY_SIGN_ONLY_FLAG = 2147483648;
pub const PROGRESS_CANCEL = 1;
pub const OpenPrivateNamespace = OpenPrivateNamespaceA;
pub const MM_MAX_FIXEDSCALE = MM_TWIPS;
pub const MCI_ESCAPE = 2053;
pub const ESB_ENABLE_BOTH = 0;
pub const ERROR_PRINTER_DRIVER_WARNED = @as(c_long, 3013);
pub const VK_NUMPAD1 = 97;
pub const WNNC_NET_MFILES = 4259840;
pub const FMFD_RESPECTTEXTPLAIN = 16;
pub const BATTERY_FLAG_CHARGING = 8;
pub const SUBLANG_SINDHI_PAKISTAN = 2;
pub const MAXUIDLEN = 64;
pub const PPM_FIRMWARE_PDC = 131072;
pub const CTRY_VIET_NAM = 84;
pub const WS_DISABLED = @as(c_long, 134217728);
pub const TIME_VALID_OID_GET_CRL = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 2) else LPCSTR(2);
pub const FOF_NORECURSEREPARSE = 32768;
pub const CRYPT_MAC = 32;
pub const PP_SIGNATURE_PIN = 33;
pub const EPERM = 1;
pub const CRYPT_OID_INFO_ALGID_KEY = 3;
pub const DD_DEFDRAGDELAY = 200;
pub const POWER_ACTION_DISABLE_WAKES = 1073741824;
pub const CERT_CHAIN_ENABLE_WEAK_RSA_ROOT_FLAG = 2;
pub const ERROR_EVENTLOG_FILE_CORRUPT = @as(c_long, 1500);
pub const SC_MOVE = 61456;
pub const DROPEFFECT_COPY = 1;
pub const chx5 = 1044;
pub const PDERR_PARSEFAILURE = 4098;
pub const CAL_SABBREVMONTHNAME7 = 40;
pub const PRPC_INTERFACE_TEMPLATE = PRPC_INTERFACE_TEMPLATEA;
pub const SDC_ALLOW_CHANGES = 1024;
pub const URLACTION_SCRIPT_MAX = 5631;
pub const MB_SETFOREGROUND = @as(c_long, 65536);
pub const _HAS_EXCEPTIONS = 1;
pub const szOID_DESCRIPTION = "2.5.4.13";
pub const ERROR_SXS_XML_E_INVALIDSWITCH = @as(c_long, 14068);
pub const APPCOMMAND_LAUNCH_APP2 = 18;
pub const OPERATION_START_TRACE_CURRENT_THREAD = 1;
pub const SHGSI_SMALLICON = SHGFI_SMALLICON;
pub const SPI_SETSHOWIMEUI = 111;
pub const PRPC_SECURITY_QOS_V4 = PRPC_SECURITY_QOS_V4_A;
pub const __deref_opt_inout_bcount_nz = size;
pub const INHERITED_ACE = 16;
pub const PROV_DH_SCHANNEL = 18;
pub const TIMESTAMP_VERIFY_CONTEXT_SIGNATURE = 32;
pub const MCI_FORMAT_SAMPLES = 9;
pub const USN_REASON_NAMED_DATA_TRUNCATION = 64;
pub const ELEMENT_STATUS_AVOLTAG = 536870912;
pub const DM_COPY = 2;
pub const FOF_FILESONLY = 128;
pub const PSH_NOAPPLYNOW = 128;
pub const ERROR_KEY_HAS_CHILDREN = @as(c_long, 1020);
pub const ERROR_NON_CSV_PATH = @as(c_long, 5950);
pub const ERROR_MALFORMED_SUBSTITUTION_STRING = @as(c_long, 14094);
pub const ERROR_DS_CANT_REMOVE_ATT_CACHE = @as(c_long, 8403);
pub const RTL_CORRELATION_VECTOR_VERSION_CURRENT = RTL_CORRELATION_VECTOR_VERSION_2;
pub const SO_CONNDATA = 28672;
pub const WM_XBUTTONDOWN = 523;
pub const MEHC_PATROL_SCRUBBER_PRESENT = 1;
pub const SW_SHOWNORMAL = 1;
pub const ERROR_UNSUPPORTED_TYPE = @as(c_long, 1630);
pub const NCRYPT_REGISTER_NOTIFY_FLAG = 1;
pub const DOMAIN_ALIAS_RID_REMOTE_MANAGEMENT_USERS = @as(c_long, 580);
pub const ERROR_NONPAGED_SYSTEM_RESOURCES = @as(c_long, 1451);
pub const STACK_SIZE_PARAM_IS_A_RESERVATION = 65536;
pub const MCI_FORMAT_BYTES = 8;
pub const SND_LOOP = 8;
pub const cmb1 = 1136;
pub const PROCESS_VM_OPERATION = 8;
pub const MCI_FORMAT_SMPTE_30 = 6;
pub const FILE_INITIATE_REPAIR_HINT1_CLUSTERS_ALREADY_IN_USE = 32768;
pub const PBT_APMRESUMEAUTOMATIC = 18;
pub const ERROR_PRI_MERGE_VERSION_MISMATCH = @as(c_long, 15148);
pub const ERROR_CLIPPING_NOT_SUPPORTED = @as(c_long, 2005);
pub const ERROR_CLUSTER_OBJECT_ALREADY_USED = @as(c_long, 5936);
pub const FD_SETSIZE = 64;
pub const ERROR_CLOUD_FILE_UNSUCCESSFUL = @as(c_long, 389);
pub const TREE_CONNECT_ATTRIBUTE_GLOBAL = 4;
pub const DMMEDIA_USER = 256;
pub const MCI_ANIM_STATUS_HPAL = @as(c_long, 16388);
pub const DIAGNOSTIC_REASON_SIMPLE_STRING = 1;
pub const IMAGE_REL_SH3_DIRECT4_WORD = 7;
pub const CMSG_COMPUTED_HASH_PARAM = 22;
pub const CMSG_OID_IMPORT_KEY_TRANS_FUNC = "CryptMsgDllImportKeyTrans";
pub const SM_CYMENU = 15;
pub const MM_MCISIGNAL = 971;
pub const ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE = @as(c_long, 6834);
pub const SIZEOF_RFPO_DATA = 16;
pub const CRYPT_ANY = 4;
pub const PFD_GENERIC_FORMAT = 64;
pub const DEVICEFAMILYINFOENUM_WINDOWS_CORE_HEADLESS = 17;
pub const EMR_SETCOLORADJUSTMENT = 23;
pub const GC_ROTATE = 1;
pub const DMPAPER_A5 = 11;
pub const REMOTE_PROTOCOL_INFO_FLAG_OFFLINE = 2;
pub const RPC_C_IMP_LEVEL_IMPERSONATE = 3;
pub const CERT_FIND_KEY_IDENTIFIER = CERT_COMPARE_KEY_IDENTIFIER << CERT_COMPARE_SHIFT;
pub const MessageBox = MessageBoxA;
pub const IMAGE_REL_SH3_DIRECT32_NB = 16;
pub const MB_OKCANCEL = @as(c_long, 1);
pub const GWFS_INCLUDE_ANCESTORS = 1;
pub const IMAGE_REL_SHM_REFHALF = 21;
pub const PAN_CULTURE_LATIN = 0;
pub const CERT_CHAIN_MOTW_IGNORE_AFTER_TIME_WEAK_FLAG = 1073741824;
pub const InterlockedIncrementNoFence16 = _InterlockedIncrement16;
pub const EVENT_OBJECT_IME_HIDE = 32808;
pub const CERT_STORE_PROV_DELETED_FLAG = 2;
pub const FACILITY_BLBUI = 128;
pub const PFD_SWAP_EXCHANGE = 512;
pub const ERROR_PAGE_FAULT_TRANSITION = @as(c_long, 747);
pub const CRYPT_PRIORITY_TOP = 0;
pub const WN_BAD_PROFILE = ERROR_BAD_PROFILE;
pub const ERROR_IPSEC_QM_POLICY_EXISTS = @as(c_long, 13000);
pub const IO_QOS_MAX_RESERVATION = @as(c_ulonglong, 1000000000);
pub const ERROR_IS_SUBSTED = @as(c_long, 135);
pub const BCRYPT_AUTH_MODE_CHAIN_CALLS_FLAG = 1;
pub const ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN = @as(c_long, 8514);
pub const PROTECTION_LEVEL_CODEGEN_LIGHT = 6;
pub const CMSG_KEY_TRANS_PKCS_1_5_VERSION = CMSG_ENVELOPED_RECIPIENT_V0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = 1;
pub const IMAGE_FILE_MACHINE_ARM64 = 43620;
pub const PRODUCT_HOME_BASIC_E = 67;
pub const ERROR_MAX_THRDS_REACHED = @as(c_long, 164);
pub const WINCOMMCTRLAPI = DECLSPEC_IMPORT;
pub const szOID_RSA_SMIMECapabilities = "1.2.840.113549.1.9.15";
pub const ERROR_BAD_IMPERSONATION_LEVEL = @as(c_long, 1346);
pub const BAUD_134_5 = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 4) else DWORD(4);
pub const IMAGE_FILE_MACHINE_WCEMIPSV2 = 361;
pub const PROCESS_CREATION_MITIGATION_POLICY_CONTROL_FLOW_GUARD_EXPORT_SUPPRESSION = if (@typeId(@typeOf(i64 << 40)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 40) else if (@typeId(@typeOf(i64 << 40)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 40) else @as(c_uint, 3)(i64 << 40);
pub const PKCS_SMIME_CAPABILITIES = if (@typeId(@typeOf(42)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 42) else if (@typeId(@typeOf(42)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 42) else LPCSTR(42);
pub const RegisterEventSource = RegisterEventSourceA;
pub const VFT_UNKNOWN = @as(c_long, 0);
pub const SERVICE_TRIGGER_TYPE_FIREWALL_PORT_EVENT = 4;
pub const ERROR_REVISION_MISMATCH = @as(c_long, 1306);
pub const HCBT_ACTIVATE = 5;
pub const ReadEventLog = ReadEventLogA;
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE = 2;
pub const EMR_SETBKCOLOR = 25;
pub const VARCMP_LT = 0;
pub const TOKEN_QUERY = 8;
pub const UISF_ACTIVE = 4;
pub const LANG_CENTRAL_KURDISH = 146;
pub const WM_GETICON = 127;
pub const PAN_MIDLINE_CONSTANT_SERIFED = 10;
pub const ERROR_DS_CROSS_REF_EXISTS = @as(c_long, 8374);
pub const ERROR_DS_REPLICATOR_ONLY = @as(c_long, 8370);
pub const ERROR_REGISTRY_RECOVERED = @as(c_long, 1014);
pub const NTDDI_WS03SP3 = 84017920;
pub const ERROR_FILE_EXISTS = @as(c_long, 80);
pub const DFCS_CAPTIONMAX = 2;
pub const DC_INBUTTON = 16;
pub const SEEK_CUR = 1;
pub const X509_AUTHORITY_KEY_ID = if (@typeId(@typeOf(9)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 9) else if (@typeId(@typeOf(9)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 9) else LPCSTR(9);
pub const ERROR_CLUSTER_RESOURCE_LOCKED_STATUS = @as(c_long, 5960);
pub const ERROR_SMI_PRIMITIVE_INSTALLER_FAILED = @as(c_long, 14108);
pub const IDCLOSE = 8;
pub const SMART_NO_IDE_DEVICE = 10;
pub const __FLT_EPSILON__ = 0.000000;
pub const SPI_SETWINARRANGING = 131;
pub const LPOINETPROTOCOLEX = LPIINTERNETPROTOCOLEX;
pub const PrivilegedServiceAuditAlarm = PrivilegedServiceAuditAlarmA;
pub const ERROR_CANNOT_DETECT_DRIVER_FAILURE = @as(c_long, 1080);
pub const FILE_ATTRIBUTE_OFFLINE = 4096;
pub const CERT_RETRIEVE_SUBJECT_LOGO = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 2) else LPCSTR(2);
pub const TC_RA_ABLE = 8192;
pub const EnumLanguageGroupLocales = EnumLanguageGroupLocalesA;
pub const RPC_C_QOS_CAPABILITIES_DEFAULT = 0;
pub const CAL_SABBREVMONTHNAME4 = 37;
pub const LookupPrivilegeDisplayName = LookupPrivilegeDisplayNameA;
pub const SetMenuItemInfo = SetMenuItemInfoA;
pub const DMPAPER_ENV_MONARCH = 37;
pub const SERVICE_USERSERVICE_INSTANCE = 128;
pub const PRPC_SECURITY_QOS_V5 = PRPC_SECURITY_QOS_V5_A;
pub const MHDR_ISSTRM = 8;
pub const ERROR_DS_SUB_CLS_TEST_FAIL = @as(c_long, 8391);
pub const szOID_CERT_KEY_IDENTIFIER_PROP_ID = "1.3.6.1.4.1.311.10.11.20";
pub const VK_NAVIGATION_CANCEL = 143;
pub const ERROR_NETWORK_NOT_AVAILABLE = @as(c_long, 5035);
pub const RPC_X_INVALID_TAG = RPC_S_INVALID_TAG;
pub const ERROR_DS_GROUP_CONVERSION_ERROR = @as(c_long, 8607);
pub const MF_OWNERDRAW = @as(c_long, 256);
pub const EPS_SIGNATURE = 1179865157;
pub const APPMODEL_ERROR_PACKAGE_RUNTIME_CORRUPT = @as(c_long, 15701);
pub const X3_D_WH_INST_WORD_X = 3;
pub const FS_SYMBOL = @as(c_long, 2147483648);
pub const psh8 = 1031;
pub const PSP_DLGINDIRECT = 1;
pub const NCRYPT_ECDSA_P256_ALGORITHM = BCRYPT_ECDSA_P256_ALGORITHM;
pub const SPI_GETACTIVEWNDTRKZORDER = 4108;
pub const ERROR_DISK_RESOURCES_EXHAUSTED = @as(c_long, 314);
pub const ERROR_SECUREBOOT_POLICY_ROLLBACK_DETECTED = @as(c_long, 4431);
pub const LANG_MACEDONIAN = 47;
pub const SO_MAXPATHDG = 28682;
pub const szOID_INFOSEC_sdnsKMandSig = "2.16.840.1.101.2.1.1.11";
pub const DMDITHER_LINEART = 4;
pub const DNS_ERROR_DP_ALREADY_EXISTS = @as(c_long, 9902);
pub const OBJID_WINDOW = if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(LONG, 0) else LONG(0);
pub const IMAGE_REL_PPC_REFHI = 16;
pub const ERROR_SWAPERROR = @as(c_long, 999);
pub const LB_SETLOCALE = 421;
pub const SW_SHOWMINIMIZED = 2;
pub const REG_NOTIFY_CHANGE_SECURITY = @as(c_long, 8);
pub const CFSTR_MIME_MANIFEST = if (@typeId(@typeOf("text/cache-manifest")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "text/cache-manifest") else if (@typeId(@typeOf("text/cache-manifest")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "text/cache-manifest") else TEXT("text/cache-manifest");
pub const CERT_SOURCE_URL_PROP_ID = 73;
pub const IMAGE_REL_IA64_SECREL64I = 13;
pub const ERROR_BROKEN_PIPE = @as(c_long, 109);
pub const SPI_SETFOREGROUNDFLASHCOUNT = 8197;
pub const IMN_GUIDELINE = 13;
pub const CERT_REQUEST_V1 = 0;
pub const NO_DATA = WSANO_DATA;
pub const APD_COPY_FROM_DIRECTORY = 16;
pub const GetFileAttributes = GetFileAttributesA;
pub const ERROR_READ_FAULT = @as(c_long, 30);
pub const IMAGE_SCN_ALIGN_2048BYTES = 12582912;
pub const LANG_TSWANA = 50;
pub const NRC_INVADDRESS = 57;
pub const IME_SMODE_RESERVED = 61440;
pub const __INT8_FMTi__ = "hhi";
pub const SW_SHOWMAXIMIZED = 3;
pub const ERROR_CLUSTER_PARTIAL_READ = @as(c_long, 5921);
pub const Uri_HAS_HOST = 1 << Uri_PROPERTY_HOST;
pub const Uri_HAS_USER_NAME = 1 << Uri_PROPERTY_USER_NAME;
pub const MDM_SHIFT_AUTO_SPEED = 0;
pub const ERROR_DS_AUTHORIZATION_FAILED = @as(c_long, 8599);
pub const WM_MOUSEHWHEEL = 526;
pub const SUBLANG_CUSTOM_DEFAULT = 3;
pub const ERROR_MCA_INVALID_VCP_VERSION = @as(c_long, 15201);
pub const SCS_CAP_MAKEREAD = 2;
pub const PAGE_EXECUTE_READ = 32;
pub const DMPAPER_A6 = 70;
pub const PRINTER_DRIVER_SANDBOX_DISABLED = 2048;
pub const CREATE_WAITABLE_TIMER_HIGH_RESOLUTION = 2;
pub const ERROR_UNABLE_TO_REMOVE_REPLACED = @as(c_long, 1175);
pub const CF_WAVE = 12;
pub const ERROR_IPSEC_IKE_INVALID_SITUATION = @as(c_long, 13863);
pub const IID_IOInetBindInfo = IID_IInternetBindInfo;
pub const EMR_CREATEMONOBRUSH = 93;
pub const PAN_WEIGHT_MEDIUM = 6;
pub const CallWindowProc = CallWindowProcA;
pub const InterlockedExchange = _InterlockedExchange;
pub const __analysis_assume_lock_released = lock;
pub const VER_PLATFORM_WIN32_WINDOWS = 1;
pub const MUI_LANGUAGE_ID = 4;
pub const ERROR_UNKNOWN_PRINT_MONITOR = @as(c_long, 3000);
pub const ERROR_APP_WRONG_OS = @as(c_long, 1151);
pub const DEVICEFAMILYDEVICEFORM_BUILDING_AUTOMATION = 15;
pub const PRINTER_ATTRIBUTE_MACHINE = 524288;
pub const FILE_ATTRIBUTE_SYSTEM = 4;
pub const MCI_OVLY_GETDEVCAPS_CAN_FREEZE = @as(c_long, 16386);
pub const ERROR_TXF_ATTRIBUTE_CORRUPT = @as(c_long, 6830);
pub const __SIZEOF_POINTER__ = 8;
pub const X509_ALGORITHM_IDENTIFIER = if (@typeId(@typeOf(74)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 74) else if (@typeId(@typeOf(74)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 74) else LPCSTR(74);
pub const CC_STYLED = 32;
pub const BN_PUSHED = BN_HILITE;
pub const SSL_OBJECT_LOCATOR_ISSUER_LIST_FUNC = "SslObjectLocatorInitializeIssuerList";
pub const FAST_FAIL_INVALID_SYSCALL_NUMBER = 41;
pub const IMAGE_DIRECTORY_ENTRY_IMPORT = 1;
pub const WS_CLIPSIBLINGS = @as(c_long, 67108864);
pub const MOUSE_MOVE_NOCOALESCE = 8;
pub const PRODUCT_PROFESSIONAL_WMC = 103;
pub const ERROR_IPSEC_IKE_BENIGN_REINIT = @as(c_long, 13878);
pub const szOID_TLS_FEATURES_EXT = "1.3.6.1.5.5.7.1.24";
pub const ALG_SID_RSA_PKCS = 1;
pub const sz_CERT_STORE_PROV_SYSTEM = sz_CERT_STORE_PROV_SYSTEM_W;
pub const RTS_CONTROL_HANDSHAKE = 2;
pub const JOB_OBJECT_LIMIT_CPU_RATE_CONTROL = JOB_OBJECT_LIMIT_RATE_CONTROL;
pub const MIXER_GETCONTROLDETAILSF_QUERYMASK = @as(c_long, 15);
pub const MDM_PROTOCOLID_DEFAULT = 0;
pub const ERROR_UNKNOWN_PRINTPROCESSOR = @as(c_long, 1798);
pub const PAN_SERIF_NORMAL_SANS = 11;
pub const CFSTR_MIME_XML = if (@typeId(@typeOf("text/xml")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "text/xml") else if (@typeId(@typeOf("text/xml")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "text/xml") else TEXT("text/xml");
pub const VarIntFromStr = VarI4FromStr;
pub const IPPORT_RESERVED = 1024;
pub const EMR_SELECTOBJECT = 37;
pub const ACTCTX_FLAG_PROCESSOR_ARCHITECTURE_VALID = 1;
pub const MCI_SET = 2061;
pub const URLACTION_CLIENT_CERT_PROMPT = 6660;
pub const SP_ERROR = -1;
pub const EMR_POLYLINETO16 = 89;
pub const CONNECT_COMMANDLINE = 2048;
pub const _CALL_REPORTFAULT = 2;
pub const GetGeoInfo = GetGeoInfoA;
pub const NTDDI_WS03SP2 = 84017664;
pub const NCBADDNAME = 48;
pub const CERT_KEY_AGREEMENT_KEY_USAGE = 8;
pub const lstrcmp = lstrcmpA;
pub const FILE_DEVICE_VIDEO = 35;
pub const szOID_PKIX_KP_EMAIL_PROTECTION = "1.3.6.1.5.5.7.3.4";
pub const VK_GAMEPAD_MENU = 207;
pub const FILE_PREFETCH_TYPE_MAX = 4;
pub const CreateEvent = CreateEventA;
pub const SOFTDIST_FLAG_USAGE_PRECACHE = 2;
pub const FILE_DEVICE_KSEC = 57;
pub const ERROR_SXS_MANIFEST_PARSE_ERROR = @as(c_long, 14005);
pub const TOUCH_HIT_TESTING_NONE = 2;
pub const COM_RIGHTS_EXECUTE = 1;
pub const MK_XBUTTON1 = 32;
pub const PSINJECT_BEGINPAGESETUP = 101;
pub const WM_WINDOWPOSCHANGED = 71;
pub const SOFTDIST_ADSTATE_AVAILABLE = 1;
pub const VER_WORKSTATION_NT = 1073741824;
pub const CAL_SABBREVMONTHNAME5 = 38;
pub const RPC_C_INFINITE_TIMEOUT = INFINITE;
pub const IMAGE_REL_SHM_PAIR = 24;
pub const SERVICE_CONFIG_FAILURE_ACTIONS_FLAG = 4;
pub const _WIN32_IE_WIN2K = _WIN32_IE_IE501;
pub const TRANSACTION_NOTIFY_PROPAGATE_PUSH = 65536;
pub const InterlockedAnd64Acquire = _InterlockedAnd64;
pub const PRPC_SECURITY_QOS_V2 = PRPC_SECURITY_QOS_V2_A;
pub const CommConfigDialog = CommConfigDialogA;
pub const ERROR_NO_SUCH_SITE = @as(c_long, 1249);
pub const WM_NCMBUTTONUP = 168;
pub const RTL_RUN_ONCE_CHECK_ONLY = @as(c_ulong, 1);
pub const MCI_OVLY_WINDOW_DISABLE_STRETCH = @as(c_long, 2097152);
pub const SERVICE_CONTROL_CONTINUE = 3;
pub const PARAMFLAG_FRETVAL = 8;
pub const IMAGE_REL_SH3_DIRECT8_LONG = 5;
pub const BATTERY_FLAG_LOW = 2;
pub const PRODUCT_ID_LENGTH = 16;
pub const IMAGE_SUBSYSTEM_XBOX = 14;
pub const ERROR_RESOURCE_CALL_TIMED_OUT = @as(c_long, 5910);
pub const psh9 = 1032;
pub const szOID_CERT_POLICIES_95_QUALIFIER1 = "2.16.840.1.113733.1.7.1.1";
pub const LOCALE_SLIST = 12;
pub const szOID_ECC_CURVE_BRAINPOOLP160T1 = "1.3.36.3.3.2.8.1.1.2";
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_DATA = 16777216;
pub const RI_KEY_E0 = 2;
pub const EVENTLOG_END_PAIRED_EVENT = 2;
pub const SB_BOTTOM = 7;
pub const RIDEV_CAPTUREMOUSE = 512;
pub const cmb3 = 1138;
pub const ERROR_NO_ACE_CONDITION = @as(c_long, 804);
pub const ERROR_BAD_PROFILE = @as(c_long, 1206);
pub const IID_IOInetPriority = IID_IInternetPriority;
pub const WSA_QOS_EPSFLOWSPEC = @as(c_long, 11027);
pub const SECURITY_CAPABILITY_INTERNET_CLIENT = @as(c_long, 1);
pub const szOID_PRODUCT_UPDATE = "1.3.6.1.4.1.311.31.1";
pub const SECURITY_CAPABILITY_PICTURES_LIBRARY = @as(c_long, 4);
pub const DNS_ERROR_DEFAULT_VIRTUALIZATION_INSTANCE = @as(c_long, 9925);
pub const DMPAPER_ENV_DL = 27;
pub const VOLUME_NAME_NT = 2;
pub const PROCESSOR_SHx_SH3 = 103;
pub const RESOURCE_REMEMBERED = 3;
pub const IME_ESC_SYNC_HOTKEY = 4103;
pub const FILE_VOLUME_IS_COMPRESSED = 32768;
pub const CB_SETCURSEL = 334;
pub const POINTER_DEVICE_PRODUCT_STRING_MAX = 520;
pub const LOCALE_SPOSINFINITY = 106;
pub const IPPORT_BIFFUDP = 512;
pub const Uri_CREATE_ALLOW_IMPLICIT_FILE_SCHEME = 4;
pub const PKCS_ATTRIBUTES = if (@typeId(@typeOf(48)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 48) else if (@typeId(@typeOf(48)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 48) else LPCSTR(48);
pub const DISPID_VALUE = 0;
pub const CRYPT_Y_ONLY = 1;
pub const ERROR_CLUSTER_INSTANCE_ID_MISMATCH = @as(c_long, 5893);
pub const SM_REMOTESESSION = 4096;
pub const DM_OUT_BUFFER = DM_COPY;
pub const EMR_SETTEXTCOLOR = 24;
pub const EVENT_SYSTEM_SWITCHSTART = 20;
pub const ERROR_HOST_NODE_NOT_AVAILABLE = @as(c_long, 5005);
pub const BCRYPT_3DES_ECB_ALG_HANDLE = if (@typeId(@typeOf(337)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 337) else if (@typeId(@typeOf(337)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 337) else BCRYPT_ALG_HANDLE(337);
pub const DT_HIDEPREFIX = 1048576;
pub const GGI_MARK_NONEXISTING_GLYPHS = 1;
pub const ERROR_POINT_NOT_FOUND = @as(c_long, 1171);
pub const META_SETSTRETCHBLTMODE = 263;
pub const USN_REASON_DATA_TRUNCATION = 4;
pub const IPPORT_EFSSERVER = 520;
pub const ERROR_PATH_NOT_FOUND = @as(c_long, 3);
pub const POINTER_FLAG_FIFTHBUTTON = 256;
pub const WSAETIMEDOUT = @as(c_long, 10060);
pub const szOID_COMMON_NAME = "2.5.4.3";
pub const ERROR_BADKEY = @as(c_long, 1010);
pub const ISC_SHOWUICANDIDATEWINDOW = 1;
pub const UOI_HEAPSIZE = 5;
pub const AnsiUpperBuff = CharUpperBuffA;
pub const JOB_OBJECT_MSG_MAXIMUM = 13;
pub const MUI_MACHINE_LANGUAGE_SETTINGS = 1024;
pub const KEYEVENTF_UNICODE = 4;
pub const CERT_STORE_PROV_WRITE_ADD_FLAG = 1;
pub const DFCS_PUSHED = 512;
pub const RPC_X_INVALID_PIPE_OPERATION = RPC_X_WRONG_PIPE_ORDER;
pub const VER_SUITE_EMBEDDED_RESTRICTED = 2048;
pub const ERROR_IO_PRIVILEGE_FAILED = @as(c_long, 571);
pub const CERT_ACCESS_STATE_GP_SYSTEM_STORE_FLAG = 8;
pub const SM_YVIRTUALSCREEN = 77;
pub const DRV_INSTALL = 9;
pub const PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE = 24;
pub const ERROR_FAILED_SERVICE_CONTROLLER_CONNECT = @as(c_long, 1063);
pub const MOUSEEVENTF_MOVE = 1;
pub const LOCALE_NAME_USER_DEFAULT = NULL;
pub const ERROR_CLUSTER_NODE_NOT_READY = @as(c_long, 5072);
pub const MNC_CLOSE = 1;
pub const IMFS_CHECKED = MFS_CHECKED;
pub const ERROR_HANDLE_EOF = @as(c_long, 38);
pub const ERROR_DIFFERENT_PROFILE_RESOURCE_MANAGER_EXIST = @as(c_long, 15144);
pub const MDM_BLIND_DIAL = 512;
pub const ERROR_HOST_NODE_NOT_GROUP_OWNER = @as(c_long, 5016);
pub const IO_REPARSE_TAG_RESERVED_ZERO = 0;
pub const NTDDI_WS03SP1 = 84017408;
pub const SITE_PIN_RULES_ALL_SUBDOMAINS_FLAG = 1;
pub const ERROR_RESMON_CREATE_FAILED = @as(c_long, 5017);
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_ID = 2;
pub const SUBLANG_CUSTOM_UNSPECIFIED = 4;
pub const AF_CHAOS = 5;
pub const _MSC_EXTENSIONS = 1;
pub const JOB_NOTIFY_FIELD_PARAMETERS = 7;
pub const DeletePrintProvidor = DeletePrintProvidorA;
pub const WSA_QOS_EFLOWSPEC = @as(c_long, 11017);
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE = @as(c_long, 8579);
pub const chx8 = 1047;
pub const szOID_ECC_CURVE_NISTP256 = szOID_ECC_CURVE_P256;
pub const META_EXTTEXTOUT = 2610;
pub const CTRY_TURKEY = 90;
pub const SERVICE_ACCEPT_SESSIONCHANGE = 128;
pub const S_SERDPT = -12;
pub const PROCESS_TRUST_LABEL_SECURITY_INFORMATION = @as(c_long, 128);
pub const CMC_FAIL_NO_KEY_REUSE = 10;
pub const SNAPSHOT_POLICY_ALWAYS = 1;
pub const CAT_E_FIRST = @as(c_long, 2147746144);
pub const PRPC_SECURITY_QOS_V3 = PRPC_SECURITY_QOS_V3_A;
pub const ERROR_SHUTDOWN_CLUSTER = @as(c_long, 5008);
pub const ERROR_CLUSTER_NETWORK_EXISTS = @as(c_long, 5044);
pub const PRINTER_NOTIFY_FIELD_OBJECT_GUID = 26;
pub const PROCESSOR_ARCHITECTURE_PPC = 3;
pub const EXCEPTION_EXIT_UNWIND = 4;
pub const ERROR_CLOUD_FILE_INCOMPATIBLE_HARDLINKS = @as(c_long, 396);
pub const SWP_SHOWWINDOW = 64;
pub const FILE_DEVICE_MODEM = 43;
pub const SERVICE_START_REASON_TRIGGER = 4;
pub const ERROR_UNKNOWN_FEATURE = @as(c_long, 1606);
pub const SUBLANG_SPANISH_ARGENTINA = 11;
pub const DMLERR_UNFOUND_QUEUE_ID = 16401;
pub const RI_KEY_E1 = 4;
pub const MCI_ANIM_WINDOW_ENABLE_STRETCH = @as(c_long, 1048576);
pub const ERROR_PRODUCT_UNINSTALLED = @as(c_long, 1614);
pub const GetTextMetrics = GetTextMetricsA;
pub const PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE = 27;
pub const SPI_SETWAITTOKILLSERVICETIMEOUT = 125;
pub const SPI_GETMENUUNDERLINES = SPI_GETKEYBOARDCUES;
pub const CMSG_RC4_NO_SALT_FLAG = 1073741824;
pub const PERF_TYPE_ZERO = 3072;
pub const CRYPT_STRING_HASHDATA = 268435456;
pub const ERROR_CTX_CLIENT_LICENSE_IN_USE = @as(c_long, 7052);
pub const FW_NORMAL = 400;
pub const cmb2 = 1137;
pub const URLACTION_SCRIPT_PASTE = 5127;
pub const SUBLANG_FRISIAN_NETHERLANDS = 1;
pub const WSAESHUTDOWN = @as(c_long, 10058);
pub const CERT_FIND_MD5_HASH = CERT_COMPARE_MD5_HASH << CERT_COMPARE_SHIFT;
pub const PEN_MASK_TILT_X = 4;
pub const MND_CONTINUE = 0;
pub const SM_CXCURSOR = 13;
pub const szOID_REVOKED_LIST_SIGNER = "1.3.6.1.4.1.311.10.3.19";
pub const VIEW_S_LAST = @as(c_long, 262479);
pub const SCRUB_DATA_OUTPUT_FLAG_PARITY_EXTENT_DATA_RETURNED = 131072;
pub const MCI_STATUS_TIME_FORMAT = @as(c_long, 6);
pub const IMAGE_REL_BASED_LOW = 2;
pub const POINTER_UNSIGNED = __uptr;
pub const SERVICE_CONFIG_SERVICE_SID_INFO = 5;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_IN_USE = 1;
pub const MCI_WAVE_GETDEVCAPS_OUTPUTS = @as(c_long, 16386);
pub const __out_bcount_nz_opt = size;
pub const MDM_SHIFT_HDLCPPP_AUTH = 3;
pub const COLOR_WINDOW = 5;
pub const ATTRIBUTE_SECURITY_INFORMATION = @as(c_long, 32);
pub const BST_INDETERMINATE = 2;
pub const _OUT_TO_STDERR = 1;
pub const LGRPID_HEBREW = 12;
pub const ERROR_IPSEC_IKE_LOAD_SOFT_SA = @as(c_long, 13844);
pub const ERROR_DOMAIN_EXISTS = @as(c_long, 1356);
pub const SB_GRAD_TRI = 32;
pub const GR_USEROBJECTS_PEAK = 4;
pub const DST_TEXT = 1;
pub const SZDDESYS_ITEM_TOPICS = "Topics";
pub const IID_IOInet = IID_IInternet;
pub const ERROR_DS_DRA_INCONSISTENT_DIT = @as(c_long, 8443);
pub const PIPE_WAIT = 0;
pub const RPC_CONTEXT_HANDLE_SERIALIZE = @as(c_ulong, 268435456);
pub const PRINTER_ENUM_FAVORITE = 4;
pub const SHGFI_ICONLOCATION = 4096;
pub const DM_IN_BUFFER = DM_MODIFY;
pub const CONTACTVISUALIZATION_ON = 1;
pub const CP_UTF7 = 65000;
pub const CERT_CHAIN_POLICY_SSL_F12_WEAK_CRYPTO_CATEGORY = 1;
pub const GCP_SYMSWAPOFF = @as(c_long, 8388608);
pub const SECURITY_AUTHENTICATION_AUTHORITY_ASSERTED_RID = @as(c_long, 1);
pub const ERROR_THREAD_NOT_IN_PROCESS = @as(c_long, 566);
pub const ERROR_EA_LIST_INCONSISTENT = @as(c_long, 255);
pub const ERROR_KEY_DELETED = @as(c_long, 1018);
pub const TIMESTAMP_RESPONSE = if (@typeId(@typeOf(79)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 79) else if (@typeId(@typeOf(79)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 79) else LPCSTR(79);
pub const CERT_TRUST_IS_NOT_TIME_NESTED = 2;
pub const MWMO_WAITALL = 1;
pub const ERROR_CLOUD_FILE_ACCESS_DENIED = @as(c_long, 395);
pub const CERT_STORE_PROV_SMART_CARD = CERT_STORE_PROV_SMART_CARD_W;
pub const CERT_COMPARE_CROSS_CERT_DIST_POINTS = 17;
pub const CERT_COMPARE_SUBJECT_CERT = 11;
pub const ERROR_DS_CONTROL_NOT_FOUND = @as(c_long, 8258);
pub const ARABIC_CHARSET = 178;
pub const WIM_BOOT_NOT_OS_WIM = 0;
pub const VER_NUM_BITS_PER_CONDITION_MASK = 3;
pub const IMAGE_SCN_ALIGN_8192BYTES = 14680064;
pub const GetIconInfoEx = GetIconInfoExA;
pub const CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE = 4;
pub const DUPLICATE_SAME_ACCESS = 2;
pub const IS_TEXT_UNICODE_REVERSE_ASCII16 = 16;
pub const WM_USER = 1024;
pub const __out_bcount_nz = size;
pub const __SIZE_WIDTH__ = 64;
pub const SPI_SETMENUFADE = 4115;
pub const IME_ESC_RESERVED_FIRST = 4;
pub const PROTECTION_LEVEL_WINTCB = 5;
pub const MDMSPKRFLAG_OFF = 1;
pub const IMAGE_FILE_AGGRESIVE_WS_TRIM = 16;
pub const SPI_SETSPEECHRECOGNITION = 4171;
pub const FAIL_FAST_NO_HARD_ERROR_DLG = 2;
pub const ERROR_NOT_APPCONTAINER = @as(c_long, 4250);
pub const SORT_CHINESE_RADICALSTROKE = 4;
pub const ERROR_REQUEST_REFUSED = @as(c_long, 4320);
pub const ERROR_INVALID_SEPARATOR_FILE = @as(c_long, 1799);
pub const CB_GETDROPPEDSTATE = 343;
pub const URLACTION_INFODELIVERY_NO_REMOVING_CHANNELS = 7426;
pub const EVENT_OBJECT_LOCATIONCHANGE = 32779;
pub const lst16 = 1135;
pub const KTM_MARSHAL_BLOB_VERSION_MAJOR = 1;
pub const IMAGE_REL_AM_CALL32 = 3;
pub const LOCALE_SNATIVELANGNAME = LOCALE_SNATIVELANGUAGENAME;
pub const TRANSACTION_NOTIFY_PROPAGATE_PULL = 32768;
pub const HWND_TOPMOST = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(HWND, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(HWND, -1) else HWND(-1);
pub const DATA_S_FIRST = @as(c_long, 262448);
pub const ERROR_SERVER_DISABLED = @as(c_long, 1341);
pub const LB_GETANCHORINDEX = 413;
pub const LTP_PC_SMT = 1;
pub const TIMERV_NO_COALESCING = 4294967295;
pub const FILE_END = 2;
pub const DMICM_ABS_COLORIMETRIC = 4;
pub const FILE_SUPPORTS_OPEN_BY_FILE_ID = 16777216;
pub const NIF_SHOWTIP = 128;
pub const szOID_OIWSEC_dsa = "1.3.14.3.2.12";
pub const LANG_DIVEHI = 101;
pub const ERROR_DS_NO_RESULTS_RETURNED = @as(c_long, 8257);
pub const CommDlg_OpenSave_GetFolderPath = CommDlg_OpenSave_GetFolderPathA;
pub const BCRYPT_HMAC_MD5_ALG_HANDLE = if (@typeId(@typeOf(145)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 145) else if (@typeId(@typeOf(145)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 145) else BCRYPT_ALG_HANDLE(145);
pub const chx9 = 1048;
pub const BS_3STATE = @as(c_long, 5);
pub const LOCALE_IDEFAULTCODEPAGE = 11;
pub const VK_TAB = 9;
pub const IMAGE_REL_THUMB_BLX23 = 21;
pub const szOID_RSA_MD2RSA = "1.2.840.113549.1.1.2";
pub const ERROR_PROCESS_NOT_IN_JOB = @as(c_long, 759);
pub const CP_INSTALLED = 1;
pub const PSNRET_INVALID_NOCHANGEPAGE = 2;
pub const ES_PASSWORD = @as(c_long, 32);
pub const UNDEFINE_PRIMARY = 12;
pub const PCF_RLSD = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 4) else DWORD(4);
pub const DOMAIN_ALIAS_RID_LOGGING_USERS = @as(c_long, 559);
pub const CTRY_CARIBBEAN = 1;
pub const DS_SETFONT = @as(c_long, 64);
pub const ERROR_INVALID_HANDLE = @as(c_long, 6);
pub const PSD_DISABLEPAGEPAINTING = 524288;
pub const SS_NOTIFY = @as(c_long, 256);
pub const ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION = @as(c_long, 6844);
pub const IMAGE_DLLCHARACTERISTICS_NO_SEH = 1024;
pub const __UINT32_FMTu__ = "u";
pub const ACCESS_MAX_MS_ACE_TYPE = 8;
pub const CRYPT_IPSEC_HMAC_KEY = 256;
pub const ERROR_DS_ALIAS_DEREF_PROBLEM = @as(c_long, 8244);
pub const BIDI_ACCESS_ADMINISTRATOR = 1;
pub const ERROR_UNSUPPORTED_COMPRESSION = @as(c_long, 618);
pub const KEY_LENGTH_MASK = 4294901760;
pub const SUBLANG_ORIYA_INDIA = 1;
pub const NRC_BRIDGE = 35;
pub const SUBLANG_THAI_THAILAND = 1;
pub const CERT_CHAIN_POLICY_AUTHENTICODE = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 2) else LPCSTR(2);
pub const ABM_GETTASKBARPOS = 5;
pub const ERROR_DS_SPN_VALUE_NOT_UNIQUE_IN_FOREST = @as(c_long, 8647);
pub const FEATURESETTING_PSLEVEL = 2;
pub const SECURITY_CAPABILITY_APP_RID = 1024;
pub const IMAGE_REL_AMD64_SECREL7 = 12;
pub const PEN_MASK_TILT_Y = 8;
pub const ERROR_REPARSE_POINT_ENCOUNTERED = @as(c_long, 4395);
pub const PSP_USEREFPARENT = 64;
pub const KLF_SETFORPROCESS = 256;
pub const NCRYPT_KEY_DERIVATION_INTERFACE = BCRYPT_KEY_DERIVATION_INTERFACE;
pub const MIDIPROP_TIMEDIV = @as(c_long, 1);
pub const COMMON_LVB_SBCSDBCS = 768;
pub const szOID_ECC_CURVE_SECP160R1 = "1.3.132.0.8";
pub const MININT = if (@typeId(@typeOf(~MAXINT)) == @import("builtin").TypeId.Pointer) @ptrCast(INT, ~MAXINT) else if (@typeId(@typeOf(~MAXINT)) == @import("builtin").TypeId.Int) @intToPtr(INT, ~MAXINT) else INT(~MAXINT);
pub const ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS = @as(c_long, 6812);
pub const BATTERY_PERCENTAGE_UNKNOWN = 255;
pub const STREAM_LAYOUT_ENTRY_NO_CLUSTERS_ALLOCATED = 8;
pub const MIXER_GETLINEINFOF_COMPONENTTYPE = @as(c_long, 3);
pub const DNS_ERROR_NO_TCPIP = @as(c_long, 9851);
pub const PRINTER_NOTIFY_FIELD_PAGES_PRINTED = 23;
pub const SPI_GETCONTACTVISUALIZATION = 8216;
pub const MB_ICONWARNING = MB_ICONEXCLAMATION;
pub const WOW64_CONTEXT_SERVICE_ACTIVE = 268435456;
pub const szOID_RSA_preferSignedData = "1.2.840.113549.1.9.15.1";
pub const SCERR_NOGUIDS = 32768;
pub const SPI_GETSCREENSAVESECURE = 118;
pub const ERROR_BAD_DESCRIPTOR_FORMAT = @as(c_long, 1361);
pub const STRUNCATE = 80;
pub const ERROR_INVALID_PRIMARY_GROUP = @as(c_long, 1308);
pub const szOID_CMC_STATUS_INFO = "1.3.6.1.5.5.7.7.1";
pub const ERROR_NOT_ENOUGH_QUOTA = @as(c_long, 1816);
pub const FILE_BEGIN = 0;
pub const JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = 2;
pub const HOLLOW_BRUSH = NULL_BRUSH;
pub const CFSTR_MIME_X_WAV = if (@typeId(@typeOf("audio/x-wav")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "audio/x-wav") else if (@typeId(@typeOf("audio/x-wav")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "audio/x-wav") else TEXT("audio/x-wav");
pub const CFSTR_MIME_X_WMF = if (@typeId(@typeOf("image/x-wmf")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "image/x-wmf") else if (@typeId(@typeOf("image/x-wmf")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "image/x-wmf") else TEXT("image/x-wmf");
pub const SPI_SETMOUSEDRAGOUTTHRESHOLD = 133;
pub const DDD_LUID_BROADCAST_DRIVE = 16;
pub const SUBLANG_SPANISH_COLOMBIA = 9;
pub const ReadULongPtrRaw = ReadULong64Raw;
pub const WINEVENT_OUTOFCONTEXT = 0;
pub const CryptStringToBinary = CryptStringToBinaryA;
pub const ID_DEFAULTINST = -2;
pub const WM_POINTERENTER = 585;
pub const PRINTER_CHANGE_SERVER = 134217728;
pub const GCP_REORDER = 2;
pub const LANG_VALENCIAN = 3;
pub const SECURITY_CONTEXT_TRACKING = 262144;
pub const LB_ITEMFROMPOINT = 425;
pub const MM_STREAM_ERROR = 983;
pub const AF_UNIX = 1;
pub const WM_ICONERASEBKGND = 39;
pub const CE_BREAK = 16;
pub const ERROR_DS_CONSTRAINT_VIOLATION = @as(c_long, 8239);
pub const VER_MAJORVERSION = 2;
pub const PROJFS_PROTOCOL_VERSION = 3;
pub const PO_RENAME = 20;
pub const ERROR_DS_MAX_OBJ_SIZE_EXCEEDED = @as(c_long, 8304);
pub const CERT_UNICODE_RDN_ERR_INDEX_SHIFT = 22;
pub const ENOSR = 124;
pub const MCI_WAVE_STATUS_AVGBYTESPERSEC = @as(c_long, 16388);
pub const ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT = @as(c_long, 14020);
pub const DNS_ERROR_DP_BASE = 9900;
pub const ERROR_SUCCESS_RESTART_REQUIRED = @as(c_long, 3011);
pub const NCRYPT_DESX_ALGORITHM = BCRYPT_DESX_ALGORITHM;
pub const ST_TERMINATED = 32;
pub const WNNC_NET_DFS = 3866624;
pub const WM_GETTITLEBARINFOEX = 831;
pub const RPC_X_WRONG_ES_VERSION = @as(c_long, 1828);
pub const COLOR_ACTIVECAPTION = 2;
pub const ERROR_IPSEC_IKE_QM_EXPIRED = @as(c_long, 13895);
pub const SCRUB_DATA_OUTPUT_FLAG_INCOMPLETE = 1;
pub const PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_MASK = 3 << 8;
pub const GetPrinterDriver2 = GetPrinterDriver2A;
pub const MCI_OVLY_OPEN_WS = @as(c_long, 65536);
pub const ES_DISPLAY_REQUIRED = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 2) else DWORD(2);
pub const JOB_NOTIFY_FIELD_STATUS_STRING = 11;
pub const toascii = __toascii;
pub const LPD_SWAP_COPY = 1024;
pub const GUID_CLASS_COMPORT = GUID_DEVINTERFACE_COMPORT;
pub const lst15 = 1134;
pub const ERROR_THREAD_MODE_ALREADY_BACKGROUND = @as(c_long, 400);
pub const _BLANK = 64;
pub const WGL_SWAP_UNDERLAY8 = 8388608;
pub const PPM_IDLE_IMPLEMENTATION_MICROPEP = 3;
pub const SETCOLORTABLE = 4;
pub const ALG_SID_RSA_PGP = 4;
pub const szOID_ENROLL_CERTTYPE_EXTENSION = "1.3.6.1.4.1.311.20.2";
pub const ERROR_CLUSTER_INVALID_REQUEST = @as(c_long, 5048);
pub const SERVICE_NOTIFY_STOPPED = 1;
pub const META_SETBKCOLOR = 513;
pub const IMAGE_REL_PPC_TYPEMASK = 255;
pub const TRANSACTION_NOTIFY_MASK = 1073741823;
pub const DMDFO_DEFAULT = 0;
pub const ERROR_PLUGPLAY_QUERY_VETOED = @as(c_long, 683);
pub const EMR_POLYPOLYGON16 = 91;
pub const MF_MENUBREAK = @as(c_long, 64);
pub const GetExpandedName = GetExpandedNameA;
pub const STRETCH_ANDSCANS = BLACKONWHITE;
pub const CERT_CHAIN_POLICY_SSL_HPKP_HEADER = if (@typeId(@typeOf(10)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 10) else if (@typeId(@typeOf(10)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 10) else LPCSTR(10);
pub const IGP_SENTENCE = 12;
pub const NCRYPT_ECDSA_P384_ALGORITHM = BCRYPT_ECDSA_P384_ALGORITHM;
pub const CERT_ROOT_PROGRAM_NAME_CONSTRAINTS_PROP_ID = 84;
pub const ERROR_LOG_CANT_DELETE = @as(c_long, 6616);
pub const ERROR_DS_ROLE_NOT_VERIFIED = @as(c_long, 8610);
pub const WN_BAD_PASSWORD = ERROR_INVALID_PASSWORD;
pub const IMAGE_SCN_LNK_NRELOC_OVFL = 16777216;
pub const ERROR_INVALID_PASSWORDNAME = @as(c_long, 1216);
pub const szOID_ATTEST_WHQL_CRYPTO = "1.3.6.1.4.1.311.10.3.5.1";
pub const CRYPT_DECODE_SHARE_OID_STRING_FLAG = 4;
pub const RRF_RT_REG_EXPAND_SZ = 4;
pub const SHERB_NOPROGRESSUI = 2;
pub const SSTF_DISPLAY = 3;
pub const WM_QUERYENDSESSION = 17;
pub const PDC_MODE_ASPECTRATIOPRESERVED = 2048;
pub const ERROR_DS_CANT_MIX_MASTER_AND_REPS = @as(c_long, 8331);
pub const ERROR_SERVICE_LOGON_FAILED = @as(c_long, 1069);
pub const CERT_QUERY_CONTENT_PFX_AND_LOAD = 14;
pub const SPI_SETCOMBOBOXANIMATION = 4101;
pub const COLOR_MENUBAR = 30;
pub const VS_FF_PATCHED = @as(c_long, 4);
pub const ALG_SID_ECDH_EPHEM = 6;
pub const SCHAR_MIN = -128;
pub const HTSIZE = HTGROWBOX;
pub const FAST_FAIL_LOW_LABEL_ACCESS_DENIED = 52;
pub const ERROR_CLUSTER_CSV_IO_PAUSE_TIMEOUT = @as(c_long, 5979);
pub const DeviceCapabilities = DeviceCapabilitiesA;
pub const szOID_ENTERPRISE_OID_ROOT = "1.3.6.1.4.1.311.21.8";
pub const HORZSIZE = 4;
pub const ERROR_NO_DATA_DETECTED = @as(c_long, 1104);
pub const FS_BALTIC = @as(c_long, 128);
pub const CTL_FIND_NO_SIGNER_PTR = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(PCERT_INFO, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(PCERT_INFO, -1) else PCERT_INFO(-1);
pub const MF_BYPOSITION = @as(c_long, 1024);
pub const szOID_SERIALIZED = "1.3.6.1.4.1.311.10.3.3.1";
pub const IMAGE_SYM_TYPE_DWORD = 15;
pub const USN_REASON_COMPRESSION_CHANGE = 131072;
pub const CMSG_DETACHED_FLAG = 4;
pub const IMAGE_SYM_DTYPE_POINTER = 1;
pub const PRINTACTION_SERVERPROPERTIES = 7;
pub const IMAGE_REL_ARM64_SECREL_LOW12A = 9;
pub const PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_PREFER_SYSTEM32_MASK = if (@typeId(@typeOf(i64 << 60)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 60) else if (@typeId(@typeOf(i64 << 60)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 60) else @as(c_uint, 3)(i64 << 60);
pub const VIF_DIFFTYPE = @as(c_long, 32);
pub const BCRYPT_ASYMMETRIC_ENCRYPTION_OPERATION = 4;
pub const IE_BADID = -1;
pub const CERT_QUERY_OBJECT_BLOB = 2;
pub const PAN_CONTRAST_MEDIUM_HIGH = 7;
pub const X509_ENUMERATED = if (@typeId(@typeOf(29)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 29) else if (@typeId(@typeOf(29)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 29) else LPCSTR(29);
pub const DNS_ERROR_CLIENT_SUBNET_ALREADY_EXISTS = @as(c_long, 9977);
pub const CERT_NAME_STR_FORCE_UTF8_DIR_STR_FLAG = 524288;
pub const CERT_CHAIN_AUTO_LOG_FREE_FLAG = 4;
pub const IMAGE_GUARD_DELAYLOAD_IAT_IN_ITS_OWN_SECTION = 8192;
pub const TAPE_DRIVE_GET_LOGICAL_BLK = 2097152;
pub const PROCESSOR_SHx_SH4 = 104;
pub const MCI_ANIM_STATUS_HWND = @as(c_long, 16387);
pub const META_FRAMEREGION = 1065;
pub const BS_RIGHT = @as(c_long, 512);
pub const ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION = 2;
pub const Uri_CREATE_NO_CRACK_UNKNOWN_SCHEMES = 1024;
pub const szOID_ECC_CURVE_NISTP224 = "1.3.132.0.33";
pub const ERROR_PATCH_NO_SEQUENCE = @as(c_long, 1648);
pub const WM_FONTCHANGE = 29;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE = 2;
pub const PRINTER_NOTIFY_FIELD_BYTES_PRINTED = 25;
pub const CERT_INFO_ISSUER_FLAG = 4;
pub const PDC_RESOLUTION = 512;
pub const __INT32_FMTd__ = "d";
pub const GetWindowsDirectory = GetWindowsDirectoryA;
pub const ERROR_CAPAUTHZ_SCCD_INVALID_CATALOG = @as(c_long, 456);
pub const THREAD_POWER_THROTTLING_CURRENT_VERSION = 1;
pub const UPDFCACHE_ONLYIFBLANK = 2147483648;
pub const CharUpper = CharUpperA;
pub const MSGFLTINFO_ALREADYALLOWED_FORWND = 1;
pub const SPI_SETMOUSEBUTTONSWAP = 33;
pub const SERVICE_TRIGGER_ACTION_SERVICE_START = 1;
pub const _Post1_impl_ = p1;
pub const DFCS_HOT = 4096;
pub const DMDITHER_ERRORDIFFUSION = 5;
pub const MCI_OPEN_TYPE_ID = @as(c_long, 4096);
pub const PRODUCT_HOLOGRAPHIC_BUSINESS = 136;
pub const S_SERMACT = -3;
pub const SC_DLG_FORCE_UI = 4;
pub const NT351_INTERFACE_SIZE = 64;
pub const FILE_INITIATE_REPAIR_HINT1_ORPHAN_GENERATED = 512;
pub const MCI_ANIM_PLAY_SPEED = @as(c_long, 65536);
pub const ERROR_DS_INSUFF_ACCESS_RIGHTS = @as(c_long, 8344);
pub const SECURITY_LOGON_IDS_RID_COUNT = @as(c_long, 3);
pub const DFCS_BUTTONCHECK = 0;
pub const CERT_ID_KEY_IDENTIFIER = 2;
pub const FACILITY_SPP = 256;
pub const ENUM_REGISTRY_SETTINGS = if (@typeId(@typeOf(-2)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, -2) else if (@typeId(@typeOf(-2)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, -2) else DWORD(-2);
pub const SPI_GETSHOWSOUNDS = 56;
pub const MFT_STRING = MF_STRING;
pub const PSH_AEROWIZARD = 16384;
pub const ERROR_SXS_XML_E_INVALID_UNICODE = @as(c_long, 14049);
pub const IE_MEMORY = -4;
pub const FILE_DEVICE_INPORT_PORT = 10;
pub const MEMORY_PRIORITY_VERY_LOW = 1;
pub const VarI2FromInt = VarI2FromI4;
pub const IMAGE_SYM_SECTION_MAX_EX = MAXLONG;
pub const RPC_S_UNSUPPORTED_AUTHN_LEVEL = @as(c_long, 1821);
pub const MCI_VD_STATUS_MEDIA_TYPE = @as(c_long, 16388);
pub const S_PERIOD512 = 0;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION_N = 141;
pub const CAL_ITWODIGITYEARMAX = 48;
pub const CERT_SOURCE_LOCATION_PROP_ID = 72;
pub const EMARCH_ENC_I17_IMM41a_SIZE_X = 10;
pub const ERROR_INSTALL_REJECTED = @as(c_long, 1654);
pub const NORM_IGNORESYMBOLS = 4;
pub const PO_THROTTLE_ADAPTIVE = 3;
pub const PARTIITON_OS_DATA = 41;
pub const VER_PLATFORMID = 8;
pub const ERROR_FUNCTION_NOT_CALLED = @as(c_long, 1626);
pub const lst14 = 1133;
pub const DRIVER_KERNELMODE = 1;
pub const ERROR_IO_REISSUE_AS_CACHED = @as(c_long, 3950);
pub const ERROR_STACK_OVERFLOW_READ = @as(c_long, 599);
pub const ERROR_DS_GC_REQUIRED = @as(c_long, 8547);
pub const SUBLANG_LOWER_SORBIAN_GERMANY = 2;
pub const EMR_SETICMMODE = 98;
pub const ERROR_DS_SRC_SID_EXISTS_IN_FOREST = @as(c_long, 8539);
pub const ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED = @as(c_long, 1274);
pub const RI_MOUSE_BUTTON_3_UP = RI_MOUSE_MIDDLE_BUTTON_UP;
pub const POINTER_FLAG_INRANGE = 2;
pub const TranslateAccelerator = TranslateAcceleratorA;
pub const WGL_SWAP_UNDERLAY9 = 16777216;
pub const CERT_PIN_RULES_CTL_FILENAME_A = "pinrules.stl";
pub const SERVICE_SID_TYPE_NONE = 0;
pub const ST_ISLOCAL = 4;
pub const WHEEL_DELTA = 120;
pub const ERROR_ACCESS_DENIED = @as(c_long, 5);
pub const FindFirstVolume = FindFirstVolumeA;
pub const ENABLE_PROCESSED_INPUT = 1;
pub const CreateSemaphoreEx = CreateSemaphoreExA;
pub const LOCALE_IPOSSEPBYSPACE = 85;
pub const ERROR_NO_ASSOCIATION = @as(c_long, 1155);
pub const IME_CMODE_RESERVED = 4026531840;
pub const VK_PRIOR = 33;
pub const PRINTER_ATTRIBUTE_LOCAL = 64;
pub const DNS_ERROR_AUTOZONE_ALREADY_EXISTS = @as(c_long, 9610);
pub const PAN_STROKE_GRADUAL_TRAN = 3;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_ANTIMALWARE_RID = @as(c_long, 1536);
pub const PC_NOCOLLAPSE = 4;
pub const LBS_DISABLENOSCROLL = @as(c_long, 4096);
pub const ERROR_KERNEL_APC = @as(c_long, 738);
pub const MOD_MIDIPORT = 1;
pub const szOID_PKCS_12_PROTECTED_PASSWORD_SECRET_BAG_TYPE_ID = "1.3.6.1.4.1.311.17.4";
pub const CTRY_COSTA_RICA = 506;
pub const CDN_INITDONE = if (@typeId(@typeOf(-0)) == @import("builtin").TypeId.Pointer) @ptrCast(CDN_FIRST, -0) else if (@typeId(@typeOf(-0)) == @import("builtin").TypeId.Int) @intToPtr(CDN_FIRST, -0) else CDN_FIRST(-0);
pub const ERROR_CLUSTERSET_MANAGEMENT_CLUSTER_UNREACHABLE = @as(c_long, 5999);
pub const TYPE1_FONTTYPE = 262144;
pub const QS_HOTKEY = 128;
pub const MND_ENDMENU = 1;
pub const NCRYPT_ALLOW_DECRYPT_FLAG = 1;
pub const WM_MOVING = 534;
pub const BCRYPT_SUPPORTED_PAD_PSS = 16;
pub const FILE_DEVICE_KS = 47;
pub const X509_CERT_BUNDLE = if (@typeId(@typeOf(81)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 81) else if (@typeId(@typeOf(81)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 81) else LPCSTR(81);
pub const FILE_NOTIFY_CHANGE_ATTRIBUTES = 4;
pub const FILE_DAX_VOLUME = 536870912;
pub const SE_SELF_RELATIVE = 32768;
pub const RegQueryValue = RegQueryValueA;
pub const REQUEST_OPLOCK_CURRENT_VERSION = 1;
pub const DNS_ERROR_NEED_WINS_SERVERS = @as(c_long, 9616);
pub const EVENT_MODIFY_STATE = 2;
pub const X509_BITS_WITHOUT_TRAILING_ZEROES = if (@typeId(@typeOf(51)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 51) else if (@typeId(@typeOf(51)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 51) else LPCSTR(51);
pub const WAVE_FORMAT_44S08 = 512;
pub const ERROR_INVALID_OPLOCK_PROTOCOL = @as(c_long, 301);
pub const DNS_ERROR_RRL_INVALID_TC_RATE = @as(c_long, 9915);
pub const CERT_PHYSICAL_STORE_PREDEFINED_ENUM_FLAG = 1;
pub const PPM_FIRMWARE_XPSS = 128;
pub const ESB_DISABLE_DOWN = 2;
pub const ASFW_ANY = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, -1) else DWORD(-1);
pub const TC_SCROLLBLT = 65536;
pub const ERROR_LOG_NO_RESTART = @as(c_long, 6611);
pub const ERROR_IPSEC_IKE_PROCESS_ERR_PROP = @as(c_long, 13831);
pub const OEM_FIXED_FONT = 10;
pub const IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG = 10;
pub const MMIO_UNICODEPROC = 16777216;
pub const CBN_SETFOCUS = 3;
pub const CERT_LOGOTYPE_INDIRECT_INFO_CHOICE = 2;
pub const DNS_ERROR_NOT_ALLOWED_UNDER_DNAME = @as(c_long, 9570);
pub const SERIAL_IOC_FCR_XMIT_RESET = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 4) else DWORD(4);
pub const LLMHF_LOWER_IL_INJECTED = 2;
pub const FOF_NOERRORUI = 1024;
pub const FACILITY_DIRECT3D12_DEBUG = 2175;
pub const InterlockedDecrementAcquire64 = _InterlockedDecrement64;
pub const HTCLIENT = 1;
pub const ENLISTMENT_QUERY_INFORMATION = 1;
pub const WSA_QOS_NO_RECEIVERS = @as(c_long, 11008);
pub const NFR_UNICODE = 2;
pub const USN_REASON_TRANSACTED_CHANGE = 4194304;
pub const ERROR_BAD_USER_PROFILE = @as(c_long, 1253);
pub const MEVT_F_LONG = @as(c_long, 2147483648);
pub const PROCESSOR_ARCHITECTURE_ARM64 = 12;
pub const SE_PRIVILEGE_USED_FOR_ACCESS = @as(c_long, 2147483648);
pub const InterlockedOrNoFence = _InterlockedOr;
pub const PDC_ORIENTATION_0 = 4;
pub const LOCALE_SABBREVLANGNAME = 3;
pub const InterlockedOr64 = _InterlockedOr64;
pub const WSA_QOS_EOBJLENGTH = @as(c_long, 11022);
pub const SWP_ASYNCWINDOWPOS = 16384;
pub const ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY = @as(c_long, 8201);
pub const REG_SZ = @as(c_ulong, 1);
pub const PBT_APMBATTERYLOW = 9;
pub const PROCESS_CREATION_MITIGATION_POLICY2_STRICT_CONTROL_FLOW_GUARD_ALWAYS_OFF = if (@typeId(@typeOf(i64 << 8)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 2), i64 << 8) else if (@typeId(@typeOf(i64 << 8)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 2), i64 << 8) else @as(c_uint, 2)(i64 << 8);
pub const CERT_CHAIN_DISABLE_SERVER_AUTH_WEAK_FLAG = 1048576;
pub const ERROR_INVALID_GROUP_ATTRIBUTES = @as(c_long, 1345);
pub const BCRYPT_PAD_NONE = 1;
pub const CRYPT_DEFAULT_OID = "DEFAULT";
pub const WM_MOUSEMOVE = 512;
pub const PRINTER_STATUS_PAUSED = 1;
pub const PENVISUALIZATION_CURSOR = 32;
pub const WM_MDIICONARRANGE = 552;
pub const STANDARD_RIGHTS_READ = READ_CONTROL;
pub const SUBLANG_NEPALI_NEPAL = 1;
pub const PSP_HIDEHEADER = 2048;
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_RIGHT = 217;
pub const EDEADLOCK = EDEADLK;
pub const CMSG_HASHED_FLAG = 1 << CMSG_HASHED;
pub const CERT_NAME_STR_NO_PLUS_FLAG = 536870912;
pub const WH_JOURNALRECORD = 0;
pub const CERT_RDN_NUMERIC_STRING = 3;
pub const VK_APPS = 93;
pub const szOID_PKCS_9 = "1.2.840.113549.1.9";
pub const PSH_HEADERBITMAP = 134217728;
pub const EnumMonitors = EnumMonitorsA;
pub const SM_DEBUG = 22;
pub const InterlockedCompareExchangePointerRelease = _InterlockedCompareExchangePointer;
pub const GEOID_NOT_AVAILABLE = -1;
pub const CERT_STORE_CERTIFICATE_CONTEXT = 1;
pub const SUBLANG_NORWEGIAN_BOKMAL = 1;
pub const RPC_C_QOS_CAPABILITIES_MAKE_FULLSIC = 2;
pub const MSGF_DIALOGBOX = 0;
pub const __ATOMIC_CONSUME = 1;
pub const WS_EX_LAYERED = 524288;
pub const ERROR_DS_WRONG_LINKED_ATT_SYNTAX = @as(c_long, 8528);
pub const PARTITION_WINDOWS_SYSTEM = 45;
pub const PRINTER_ATTRIBUTE_NETWORK = 16;
pub const WSAEADDRINUSE = @as(c_long, 10048);
pub const CBR_2400 = 2400;
pub const PROCESS_CREATION_MITIGATION_POLICY2_MODULE_TAMPERING_PROTECTION_ALWAYS_ON = if (@typeId(@typeOf(i64 << 12)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << 12) else if (@typeId(@typeOf(i64 << 12)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << 12) else @as(c_uint, 1)(i64 << 12);
pub const lst13 = 1132;
pub const NTDDI_VISTA = NTDDI_WIN6;
pub const SPI_SETFASTTASKSWITCH = 36;
pub const PROGRESS_CONTINUE = 0;
pub const WOW64_CONTEXT_EXCEPTION_REPORTING = 2147483648;
pub const ENCLAVE_TYPE_VBS = 16;
pub const WGL_SWAP_UNDERLAY6 = 2097152;
pub const STORAGE_PROTOCOL_STATUS_NOT_SUPPORTED = 255;
pub const InterlockedCompareExchangeRelease = _InterlockedCompareExchange;
pub const SERKF_AVAILABLE = 2;
pub const SCS_CAP_COMPSTR = 1;
pub const UNICODE_STRING_MAX_CHARS = 32767;
pub const DISPLAYCONFIG_TARGET_IN_USE = 1;
pub const szOID_NIST_AES128_WRAP = "2.16.840.1.101.3.4.1.5";
pub const NCBRECVANY = 22;
pub const LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE = 64;
pub const GetCommandLine = GetCommandLineA;
pub const QUERYESCSUPPORT = 8;
pub const ALG_SID_HASH_REPLACE_OWF = 11;
pub const STGFMT_FILE = 3;
pub const EVENT_MIN = 1;
pub const GetDateFormat = GetDateFormatA;
pub const TC_HARDERR = 1;
pub const EMR_OFFSETCLIPRGN = 26;
pub const SECURITY_SERVICE_RID = @as(c_long, 6);
pub const TAPE_DRIVE_TENSION = 2147483650;
pub const RegOpenKeyEx = RegOpenKeyExA;
pub const FILE_DEVICE_UCMUCSI = 93;
pub const TXFS_RM_FLAG_RESET_RM_AT_NEXT_START = 16384;
pub const WC_DIALOG = if (@typeId(@typeOf(32770)) == @import("builtin").TypeId.Pointer) @ptrCast(MAKEINTATOM, 32770) else if (@typeId(@typeOf(32770)) == @import("builtin").TypeId.Int) @intToPtr(MAKEINTATOM, 32770) else MAKEINTATOM(32770);
pub const PO_REN_PORT = 52;
pub const VK_FINAL = 24;
pub const SKF_CONFIRMHOTKEY = 8;
pub const PSP_RTLREADING = 16;
pub const ERROR_DS_POLICY_NOT_KNOWN = @as(c_long, 8618);
pub const BACKGROUND_GREEN = 32;
pub const SCALINGFACTORY = 115;
pub const __INTMAX_MAX__ = @as(c_longlong, 9223372036854775807);
pub const SECURITY_CAPABILITY_DOCUMENTS_LIBRARY = @as(c_long, 7);
pub const SORT_CHINESE_BIG5 = 0;
pub const DISPLAY_DEVICE_VGA_COMPATIBLE = 16;
pub const AF_DECnet = 12;
pub const CERT_COMPARE_HASH_STR = 20;
pub const GetWindowText = GetWindowTextA;
pub const PPM_FIRMWARE_ACPI1TSTATES = 4;
pub const szOID_ROLE_OCCUPANT = "2.5.4.33";
pub const DEVICEFAMILYDEVICEFORM_HMD = 11;
pub const SS_WHITEFRAME = @as(c_long, 9);
pub const CMSG_CTRL_ENABLE_STRONG_SIGNATURE = 21;
pub const RESOURCEDISPLAYTYPE_SHARE = 3;
pub const EISDIR = 21;
pub const DS_S_SUCCESS = NO_ERROR;
pub const PRINTER_CHANGE_FORM = 458752;
pub const RpcNetworkIsProtseqValid = RpcNetworkIsProtseqValidA;
pub const ALG_SID_SHA = 4;
pub const PAGE_ENCLAVE_DECOMMIT = 268435456;
pub const MICROSOFT_ROOT_CERT_CHAIN_POLICY_DISABLE_FLIGHT_ROOT_FLAG = 262144;
pub const SCARD_PROTOCOL_RAW = 65536;
pub const VFT_DLL = @as(c_long, 2);
pub const NEWFILEOPENV2ORD = 1552;
pub const SECURITY_INTERACTIVE_RID = @as(c_long, 4);
pub const SB_GRAD_RECT = 16;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE = 2;
pub const szOID_ECC_CURVE_SECP160R2 = "1.3.132.0.30";
pub const TXFS_START_RM_FLAG_LOGGING_MODE = 1024;
pub const STGM_CONVERT = @as(c_long, 131072);
pub const FILE_SUPPORTS_GHOSTING = 1073741824;
pub const GGO_METRICS = 0;
pub const PID_MIN_READONLY = 2147483648;
pub const SS_ENDELLIPSIS = @as(c_long, 16384);
pub const JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 1024;
pub const Uri_HAS_DOMAIN = 1 << Uri_PROPERTY_DOMAIN;
pub const DDL_ARCHIVE = 32;
pub const VarUI2FromInt = VarUI2FromI4;
pub const ERROR_DISK_QUOTA_EXCEEDED = @as(c_long, 1295);
pub const GetDriveType = GetDriveTypeA;
pub const OpenJobObject = OpenJobObjectA;
pub const PRODUCT_ENTERPRISEG = 171;
pub const ERROR_JOIN_TO_JOIN = @as(c_long, 138);
pub const FACILITY_AUDIOSTREAMING = 1094;
pub const IMPLINK_IP = 155;
pub const TOUCHEVENTF_DOWN = 2;
pub const _Requires_exclusive_lock_held_ = lock;
pub const LOAD_TLB_AS_64BIT = 64;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY = 31;
pub const DST_ICON = 3;
pub const RGN_AND = 1;
pub const szOID_AUTHORITY_REVOCATION_LIST = "2.5.4.38";
pub const JOY_BUTTON1CHG = 256;
pub const __SSSE3__ = 1;
pub const ERROR_CLOUD_FILE_REQUEST_TIMEOUT = @as(c_long, 426);
pub const VP_TV_STANDARD_NTSC_M_J = 2;
pub const WINAPIV = __cdecl;
pub const PARTITION_EZDRIVE = 85;
pub const ERROR_OFFLOAD_WRITE_FLT_NOT_SUPPORTED = @as(c_long, 4441);
pub const ERROR_ERRORS_ENCOUNTERED = @as(c_long, 774);
pub const ERROR_CLUSTER_RHS_FAILED_INITIALIZATION = @as(c_long, 5931);
pub const KDF_HKDF_INFO = 20;
pub const PERF_TYPE_COUNTER = 1024;
pub const NCRYPT_SECRET_AGREEMENT_OPERATION = BCRYPT_SECRET_AGREEMENT_OPERATION;
pub const CFSTR_MIME_BMP = if (@typeId(@typeOf("image/bmp")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "image/bmp") else if (@typeId(@typeOf("image/bmp")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "image/bmp") else TEXT("image/bmp");
pub const CHECKSUM_TYPE_FIRST_UNUSED_TYPE = 4;
pub const WSAEREMOTE = @as(c_long, 10071);
pub const PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_OFF = 2 << 8;
pub const FILE_FLAG_POSIX_SEMANTICS = 16777216;
pub const szOID_PKCS_8 = "1.2.840.113549.1.8";
pub const ERROR_DS_NO_RIDS_ALLOCATED = @as(c_long, 8208);
pub const CERT_TRUST_INVALID_EXTENSION = 256;
pub const IDN_RAW_PUNYCODE = 8;
pub const ERROR_DEVICE_NO_RESOURCES = @as(c_long, 322);
pub const MAPVK_VSC_TO_VK_EX = 3;
pub const IMAGE_REL_ARM_BLX23T = 21;
pub const SC_DLG_NO_UI = 2;
pub const PRINTACTION_NETINSTALLLINK = 3;
pub const CERT_SELECT_BY_PUBLIC_KEY = 10;
pub const MCI_SET_AUDIO_RIGHT = @as(c_long, 2);
pub const MDM_SPEED_ADJUST = 128;
pub const __UINT64_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const SECURITY_OTHER_ORGANIZATION_RID = @as(c_long, 1000);
pub const IMAGE_REL_PPC_ADDR32NB = 10;
pub const PSD_RETURNDEFAULT = 1024;
pub const WM_MDITILE = 550;
pub const WSAETOOMANYREFS = @as(c_long, 10059);
pub const PRODUCT_STANDARD_EVALUATION_SERVER = 79;
pub const ALG_TYPE_RSA = 2 << 9;
pub const ERROR_DS_CANT_REM_MISSING_ATT = @as(c_long, 8324);
pub const META_LINETO = 531;
pub const NTDDI_WS03SP4 = 84018176;
pub const lst12 = 1131;
pub const LZERROR_UNKNOWNALG = -8;
pub const ERROR_SXS_XML_E_EXPECTINGTAGEND = @as(c_long, 14038);
pub const ERROR_INSTALL_FAILURE = @as(c_long, 1603);
pub const MUTZ_DONT_USE_CACHE = 4096;
pub const SO_DISCOPTLEN = 28679;
pub const META_SETROP2 = 260;
pub const WGL_SWAP_UNDERLAY7 = 4194304;
pub const KF_REPEAT = 16384;
pub const LoadCursorFromFile = LoadCursorFromFileA;
pub const CB_OKAY = 0;
pub const ERROR_CLOUD_FILE_PROPERTY_CORRUPT = @as(c_long, 394);
pub const CF_LIMITSIZE = @as(c_long, 8192);
pub const URLACTION_FEATURE_WINDOW_RESTRICTIONS = 8450;
pub const ERROR_EVT_FILTER_INVARG = @as(c_long, 15016);
pub const VFT2_DRV_PRINTER = @as(c_long, 1);
pub const GET_FEATURE_FROM_PROCESS = 2;
pub const EXCEPTION_CONTINUE_SEARCH = 0;
pub const OLEOBJ_E_LAST = @as(c_long, 2147746191);
pub const PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_MASK = if (@typeId(@typeOf(i64 << 32)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 32) else if (@typeId(@typeOf(i64 << 32)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 32) else @as(c_uint, 3)(i64 << 32);
pub const WAIT_IO_COMPLETION = STATUS_USER_APC;
pub const VK_INSERT = 45;
pub const RPC_C_AUTHN_DEC_PUBLIC = 4;
pub const PAN_STRAIGHT_ARMS_DOUBLE_SERIF = 6;
pub const EN_HSCROLL = 1537;
pub const NCRYPT_KEY_ATTEST_MAGIC = 1146110283;
pub const EVENT_OBJECT_REORDER = 32772;
pub const GGL_PRIVATE = 4;
pub const XSTATE_AVX512_KMASK = 5;
pub const GetDefaultPrinter = GetDefaultPrinterA;
pub const stc3 = 1090;
pub const ACTIVATION_CONTEXT_PATH_TYPE_URL = 3;
pub const __tune_corei7__ = 1;
pub const GUI_SYSTEMMENUMODE = 8;
pub const PF_RDPID_INSTRUCTION_AVAILABLE = 33;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_PARAMETER = @as(c_long, 413);
pub const EVENT_SYSTEM_DRAGDROPEND = 15;
pub const FAST_FAIL_HEAP_METADATA_CORRUPTION = 50;
pub const CreateWaitableTimerEx = CreateWaitableTimerExA;
pub const REASON_UNKNOWN = SHTDN_REASON_UNKNOWN;
pub const MIDICAPS_VOLUME = 1;
pub const FORCEINLINE = __forceinline;
pub const WGL_FONT_LINES = 0;
pub const SECURITY_PACKAGE_BASE_RID = @as(c_long, 64);
pub const ua_CharUpper = CharUpperA;
pub const ERROR_NO_SUCH_LOGON_SESSION = @as(c_long, 1312);
pub const FILE_PERSISTENT_ACLS = 8;
pub const SCALINGFACTORX = 114;
pub const LMEM_DISCARDED = 16384;
pub const ERROR_SXS_UNTRANSLATABLE_HRESULT = @as(c_long, 14077);
pub const SORT_CHINESE_BOPOMOFO = 3;
pub const IsCharAlphaNumeric = IsCharAlphaNumericA;
pub const SEE_MASK_FLAG_HINST_IS_SITE = 134217728;
pub const DNS_ERROR_NODE_IS_CNAME = @as(c_long, 9708);
pub const SMART_SHORT_SELFTEST_OFFLINE = 1;
pub const NEWFILEOPENV3ORD = 1553;
pub const ERROR_IPSEC_IKE_INVALID_KEY_USAGE = @as(c_long, 13818);
pub const QS_TIMER = 16;
pub const URLACTION_DOWNLOAD_MAX = 4607;
pub const DMCOLOR_COLOR = 2;
pub const PRINTER_ERROR_WARNING = 1073741824;
pub const FACILITY_SXS = 23;
pub const DEFAULT_QUALITY = 0;
pub const ULW_ALPHA = 2;
pub const REFS_SMR_VOLUME_INFO_OUTPUT_VERSION_V1 = 1;
pub const ACTIVATION_CONTEXT_SECTION_APPLICATION_SETTINGS = 10;
pub const szOID_ECC_CURVE_SECP224R1 = szOID_ECC_CURVE_NISTP224;
pub const SCARD_READER_TYPE_EMBEDDEDSE = 2048;
pub const DPD_DELETE_SPECIFIC_VERSION = 2;
pub const IMAGE_REL_PPC_ADDR64 = 1;
pub const ERROR_ALERTED = @as(c_long, 739);
pub const ERROR_INVALID_GW_COMMAND = @as(c_long, 1443);
pub const SHGNLI_NOUNIQUE = 4;
pub const VS_FFI_STRUCVERSION = @as(c_long, 65536);
pub const MessageBoxEx = MessageBoxExA;
pub const EVENT_AIA_END = 45055;
pub const DNS_INFO_AXFR_COMPLETE = @as(c_long, 9751);
pub const SPI_GETFLATMENU = 4130;
pub const NCRYPT_CIPHER_KEY_BLOB_MAGIC = 1380470851;
pub const RegSetValue = RegSetValueA;
pub const OBJ_METAFILE = 9;
pub const ExtTextOut = ExtTextOutA;
pub const IMAGE_ARCHIVE_START_SIZE = 8;
pub const ERROR_DS_BACKLINK_WITHOUT_LINK = @as(c_long, 8482);
pub const SUBLANG_ITALIAN_SWISS = 2;
pub const CDS_SET_PRIMARY = 16;
pub const SPI_SETWHEELSCROLLLINES = 105;
pub const PSH_RTLREADING = 2048;
pub const OPERATION_API_VERSION = 1;
pub const PF_COMPARE_EXCHANGE128 = 14;
pub const DBG_PRINTEXCEPTION_WIDE_C = if (@typeId(@typeOf(@as(c_long, 1073807370))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 1073807370)) else if (@typeId(@typeOf(@as(c_long, 1073807370))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 1073807370)) else DWORD(@as(c_long, 1073807370));
pub const FEATURESETTING_NUP = 0;
pub const SS_SUNKEN = @as(c_long, 4096);
pub const DNS_ERROR_TOO_MANY_SKDS = @as(c_long, 9113);
pub const DMNUP_ONEUP = 2;
pub const GetPrintProcessorDirectory = GetPrintProcessorDirectoryA;
pub const BAUD_110 = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 2) else DWORD(2);
pub const SM_CYMAXTRACK = 60;
pub const BCRYPT_RNG_OPERATION = 32;
pub const MF_HELP = @as(c_long, 16384);
pub const ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING = @as(c_long, 14078);
pub const IOCTL_SCMBUS_BASE = FILE_DEVICE_PERSISTENT_MEMORY;
pub const DMPAPER_JAPANESE_POSTCARD = 43;
pub const ERROR_DS_DRA_SCHEMA_CONFLICT = @as(c_long, 8543);
pub const VFT2_DRV_LANGUAGE = @as(c_long, 3);
pub const LB_SETANCHORINDEX = 412;
pub const ERROR_NO_NET_OR_BAD_PATH = @as(c_long, 1203);
pub const PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_OFF = if (@typeId(@typeOf(i64 << 32)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 2), i64 << 32) else if (@typeId(@typeOf(i64 << 32)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 2), i64 << 32) else @as(c_uint, 2)(i64 << 32);
pub const ERROR_SXS_XML_E_MISSING_PAREN = @as(c_long, 14044);
pub const ERROR_WOW_ASSERTION = @as(c_long, 670);
pub const PAN_MIDLINE_CONSTANT_TRIMMED = 8;
pub const RPC_C_HTTP_AUTHN_TARGET_PROXY = 2;
pub const ERROR_IPSEC_IKE_NO_POLICY = @as(c_long, 13825);
pub const ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE = @as(c_long, 8512);
pub const SP_RLSD = if (@typeId(@typeOf(64)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 64) else if (@typeId(@typeOf(64)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 64) else DWORD(64);
pub const BI_RLE8 = @as(c_long, 1);
pub const SO_DISCDATALEN = 28678;
pub const CRYPT_STRING_NOCR = 2147483648;
pub const POWER_ACTION_DOZE_TO_HIBERNATE = 32;
pub const LONG_LONG_MIN = if (@typeId(@typeOf(-@as(c_longlong, 1))) == @import("builtin").TypeId.Pointer) @ptrCast(-__LONG_LONG_MAX__, -@as(c_longlong, 1)) else if (@typeId(@typeOf(-@as(c_longlong, 1))) == @import("builtin").TypeId.Int) @intToPtr(-__LONG_LONG_MAX__, -@as(c_longlong, 1)) else (-__LONG_LONG_MAX__)(-@as(c_longlong, 1));
pub const CRL_DIST_POINT_NO_NAME = 0;
pub const ERROR_DS_INSTALL_NO_SRC_SCH_VERSION = @as(c_long, 8511);
pub const FACILITY_WINDOWS_DEFENDER = 80;
pub const PRODUCT_STANDARD_SERVER_CORE_V = 40;
pub const CRYPT_MODE_CBCOFMI = 10;
pub const _Writable_bytes_impl_ = size;
pub const ERROR_FILE_HANDLE_REVOKED = @as(c_long, 806);
pub const CF_PRIVATEFIRST = 512;
pub const __INT_FAST8_FMTi__ = "hhi";
pub const BM_SETSTATE = 243;
pub const szOID_OIWSEC_rsaSign = "1.3.14.3.2.11";
pub const CryptEnumProviderTypes = CryptEnumProviderTypesA;
pub const DOCKINFO_USER_SUPPLIED = 4;
pub const URL_MK_UNIFORM = 1;
pub const PORT_STATUS_TONER_LOW = 10;
pub const CB_GETEDITSEL = 320;
pub const MCI_VD_OFFSET = 1024;
pub const DMPAPER_A3_EXTRA_TRANSVERSE = 68;
pub const PP_KEY_TYPE_SUBTYPE = 10;
pub const __FLT_MANT_DIG__ = 24;
pub const CONTROL_C_EXIT = STATUS_CONTROL_C_EXIT;
pub const __INTPTR_FMTd__ = "lld";
pub const WTS_SESSION_CREATE = 10;
pub const lst11 = 1130;
pub const DNS_STATUS_PACKET_UNSECURE = DNS_ERROR_UNSECURE_PACKET;
pub const BSF_ALLOWSFW = 128;
pub const PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_MASK = 3 << 28;
pub const THREAD_QUERY_INFORMATION = 64;
pub const CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG = 32;
pub const AddPrinterConnection = AddPrinterConnectionA;
pub const FILE_DEVICE_MT_TRANSPORT = 67;
pub const WGL_SWAP_UNDERLAY4 = 524288;
pub const IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION = 16;
pub const HCBT_SETFOCUS = 9;
pub const MF_SENDMSGS = 33554432;
pub const ERROR_OUTOFMEMORY = @as(c_long, 14);
pub const GetDiskFreeSpace = GetDiskFreeSpaceA;
pub const CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE = 2147483650;
pub const TAPE_DRIVE_INITIATOR = 4;
pub const BCRYPT_RC2_ECB_ALG_HANDLE = if (@typeId(@typeOf(609)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 609) else if (@typeId(@typeOf(609)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 609) else BCRYPT_ALG_HANDLE(609);
pub const ALERT_SYSTEM_QUERY = 4;
pub const MININT_PTR = ~MAXINT_PTR;
pub const CRYPT_OID_IMPORT_PRIVATE_KEY_INFO_FUNC = "CryptDllImportPrivateKeyInfoEx";
pub const SPI_SETSCREENSAVEACTIVE = 17;
pub const stc2 = 1089;
pub const ERROR_NOT_CAPABLE = @as(c_long, 775);
pub const GetCompressedFileSizeTransacted = GetCompressedFileSizeTransactedA;
pub const SPI_SETGESTUREVISUALIZATION = 8219;
pub const RPC_IF_AUTOLISTEN = 1;
pub const ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID = @as(c_long, 13886);
pub const DT_WORDBREAK = 16;
pub const NCRYPT_ECDH_ALGORITHM = BCRYPT_ECDH_ALGORITHM;
pub const DEVICEFAMILYDEVICEFORM_CONVERTIBLE = 5;
pub const CERT_COMPARE_KEY_IDENTIFIER = 15;
pub const SERVICE_ACCEPT_SYSTEMLOWRESOURCES = 16384;
pub const OPAQUEKEYBLOB = 9;
pub const FIEF_FLAG_RESERVED_0 = 8;
pub const OVERWRITE_HIDDEN = 4;
pub const PRODUCT_CLOUDE = 183;
pub const ERROR_FILE_SHARE_RESOURCE_CONFLICT = @as(c_long, 5938);
pub const WM_CTLCOLORSTATIC = 312;
pub const LOCALE_FONTSIGNATURE = 88;
pub const ERROR_DS_DRA_INVALID_PARAMETER = @as(c_long, 8437);
pub const _SECURECRT_FILL_BUFFER_PATTERN = 254;
pub const NTDDI_WIN10_RS1 = 167772162;
pub const PROPSHEETPAGE_V1_SIZE = PROPSHEETPAGEA_V1_SIZE;
pub const CERT_STORE_MANIFOLD_FLAG = 256;
pub const IME_CAND_READ = 1;
pub const EVENT_SYSTEM_MENUSTART = 4;
pub const CERT_X500_NAME_STR = 3;
pub const ERROR_CORRUPT_LOG_OVERFULL = @as(c_long, 794);
pub const ERROR_ITERATED_DATA_EXCEEDS_64k = @as(c_long, 194);
pub const VK_OEM_PERIOD = 190;
pub const Uri_CREATE_PRE_PROCESS_HTML_URI = 2048;
pub const DEVICEFAMILYDEVICEFORM_POINT_OF_SERVICE = 24;
pub const LOCALE_SRELATIVELONGDATE = 124;
pub const RegGetValue = RegGetValueA;
pub const STORAGE_IDLE_POWERUP_REASON_VERSION_V1 = 1;
pub const MCI_WINDOW = 2113;
pub const MCI_CUE = 2096;
pub const MIDI_IO_STATUS = @as(c_long, 32);
pub const C3_SYMBOL = 8;
pub const POINTER_FLAG_WHEEL = 524288;
pub const EEInfoPreviousRecordsMissing = 1;
pub const ISC_SHOWUICOMPOSITIONWINDOW = 2147483648;
pub const IO_REPARSE_TAG_CSV = @as(c_long, 2147483657);
pub const WINSTA_ACCESSCLIPBOARD = @as(c_long, 4);
pub const OInetQueryInfo = CoInternetQueryInfo;
pub const IMAGE_REL_ARM_MOV32T = 17;
pub const CERT_DATA_ENCIPHERMENT_KEY_USAGE = 16;
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_NULL = 4;
pub const IME_CMODE_LANGUAGE = 3;
pub const WHITE_PEN = 6;
pub const LOCALE_SLANGDISPLAYNAME = LOCALE_SLOCALIZEDLANGUAGENAME;
pub const RPC_PROTSEQ_VECTOR = RPC_PROTSEQ_VECTORA;
pub const ERROR_DS_SIZELIMIT_EXCEEDED = @as(c_long, 8227);
pub const TXFS_SAVEPOINT_ROLLBACK = 2;
pub const mmioStringToFOURCC = mmioStringToFOURCCA;
pub const ALL_PROCESSOR_GROUPS = 65535;
pub const FILE_DEVICE_BIOMETRIC = 68;
pub const SPI_SETMOUSECLICKLOCKTIME = 8201;
pub const ERROR_INDEX_ABSENT = @as(c_long, 1611);
pub const SUBLANG_AZERI_LATIN = 1;
pub const MB_APPLMODAL = @as(c_long, 0);
pub const STATE_SYSTEM_DEFAULT = 256;
pub const BCRYPT_DH_PARAMETERS_MAGIC = 1297107012;
pub const szOID_PKIX_KP = "1.3.6.1.5.5.7.3";
pub const SIMPLEBLOB = 1;
pub const META_EXCLUDECLIPRECT = 1045;
pub const PRINTER_CONTROL_RESUME = 2;
pub const __SSE4_1__ = 1;
pub const BCRYPT_SUPPORTED_PAD_OAEP = 8;
pub const ERROR_INVALID_TABLE = @as(c_long, 1628);
pub const TAPE_SPACE_RELATIVE_BLOCKS = @as(c_long, 5);
pub const EnumDateFormatsEx = EnumDateFormatsExA;
pub const PDERR_DEFAULTDIFFERENT = 4108;
pub const CERT_STORE_ENUM_ARCHIVED_FLAG = 512;
pub const DEFAULT_IMPERSONATION_LEVEL = SecurityImpersonation;
pub const SHTDN_REASON_MINOR_UNSTABLE = 6;
pub const WM_IME_CONTROL = 643;
pub const N_TMASK = 48;
pub const DISPLAYCONFIG_TARGET_FORCED_AVAILABILITY_PATH = 8;
pub const FILE_WRITE_ATTRIBUTES = 256;
pub const MCIERR_BASE = 256;
pub const WM_PARENTNOTIFY = 528;
pub const APPCLASS_STANDARD = @as(c_long, 0);
pub const GET_TAPE_DRIVE_INFORMATION = 1;
pub const RESOURCEUSAGE_NOLOCALDEVICE = 4;
pub const ERROR_BAD_NETPATH = @as(c_long, 53);
pub const ERROR_BAD_COMPRESSION_BUFFER = @as(c_long, 605);
pub const IMAGE_DLLCHARACTERISTICS_NO_BIND = 2048;
pub const SCARD_READER_EJECTS = 2;
pub const __DECIMAL_DIG__ = __LDBL_DECIMAL_DIG__;
pub const GCPCLASS_ARABIC = 2;
pub const STATUS_INVALID_PARAMETER = if (@typeId(@typeOf(@as(c_long, 3221225485))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225485)) else if (@typeId(@typeOf(@as(c_long, 3221225485))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225485)) else DWORD(@as(c_long, 3221225485));
pub const CFSTR_MIME_AIFF = if (@typeId(@typeOf("audio/aiff")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "audio/aiff") else if (@typeId(@typeOf("audio/aiff")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "audio/aiff") else TEXT("audio/aiff");
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT = 28;
pub const __INT32_FMTi__ = "i";
pub const PPM_PERFORMANCE_IMPLEMENTATION_CPPC = 3;
pub const URLPOLICY_CREDENTIALS_MUST_PROMPT_USER = 65536;
pub const CERT_CA_SUBJECT_FLAG = 128;
pub const PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_PREFER_SYSTEM32_RESERVED = if (@typeId(@typeOf(i64 << 60)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 60) else if (@typeId(@typeOf(i64 << 60)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 60) else @as(c_uint, 3)(i64 << 60);
pub const SUBLANG_QUECHUA_PERU = 3;
pub const ERROR_IPSEC_IKE_MM_EXPIRED = @as(c_long, 13885);
pub const SUBLANG_KINYARWANDA_RWANDA = 1;
pub const IPPORT_WHOSERVER = 513;
pub const ERROR_CLASS_HAS_WINDOWS = @as(c_long, 1412);
pub const LOCALE_IPOSITIVEPERCENT = 117;
pub const CERT_PUBKEY_ALG_PARA_PROP_ID = 22;
pub const VK_OEM_BACKTAB = 245;
pub const LBS_NOREDRAW = @as(c_long, 4);
pub const ERROR_NO_VOLUME_LABEL = @as(c_long, 125);
pub const lst10 = 1129;
pub const PROCESS_CREATION_MITIGATION_POLICY2_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY_ALWAYS_OFF = if (@typeId(@typeOf(i64 << 20)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 2), i64 << 20) else if (@typeId(@typeOf(i64 << 20)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 2), i64 << 20) else @as(c_uint, 2)(i64 << 20);
pub const META_SETVIEWPORTEXT = 526;
pub const WSAEINPROGRESS = @as(c_long, 10036);
pub const DNS_ERROR_INVALID_TYPE = @as(c_long, 9551);
pub const CMSG_VERSION_PARAM = 30;
pub const WGL_SWAP_UNDERLAY5 = 1048576;
pub const POWER_DEVICE_IDLE_POLICY_PERFORMANCE = 0;
pub const VP_COMMAND_SET = 2;
pub const X509_KEY_USAGE_RESTRICTION = if (@typeId(@typeOf(11)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 11) else if (@typeId(@typeOf(11)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 11) else LPCSTR(11);
pub const IMAGE_SYM_CLASS_FUNCTION = 101;
pub const JOB_STATUS_BLOCKED_DEVQ = 512;
pub const ERROR_LISTBOX_ID_NOT_FOUND = @as(c_long, 1416);
pub const CMSG_SIGNED_AND_ENVELOPED_FLAG = 1 << CMSG_SIGNED_AND_ENVELOPED;
pub const DECIMAL_NEG = if (@typeId(@typeOf(128)) == @import("builtin").TypeId.Pointer) @ptrCast(BYTE, 128) else if (@typeId(@typeOf(128)) == @import("builtin").TypeId.Int) @intToPtr(BYTE, 128) else BYTE(128);
pub const URLACTION_COOKIES_ENABLED = 6672;
pub const ERROR_INVALID_DATA = @as(c_long, 13);
pub const QUERY_ACTCTX_FLAG_USE_ACTIVE_ACTCTX = 4;
pub const RRF_RT_ANY = 65535;
pub const NCRYPTBUFFER_SSL_HIGHEST_VERSION = 22;
pub const ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME = @as(c_long, 15104);
pub const DEVICEFAMILYDEVICEFORM_DETACHABLE = 6;
pub const ERROR_AUTHENTICATION_FIREWALL_FAILED = @as(c_long, 1935);
pub const PRODUCT_LITE = 189;
pub const DCX_CACHE = @as(c_long, 2);
pub const stc1 = 1088;
pub const PKCS12_IMPORT_SILENT = 64;
pub const MM_STREAM_CLOSE = 981;
pub const DLL_PROCESS_ATTACH = 1;
pub const PKCS12_PREFER_CNG_KSP = 256;
pub const LB_GETHORIZONTALEXTENT = 403;
pub const SOCK_DGRAM = 2;
pub const META_SELECTOBJECT = 301;
pub const IDOK = 1;
pub const ERROR_WMI_TRY_AGAIN = @as(c_long, 4203);
pub const CERT_CHAIN_POLICY_SSL_F12_ERROR_LEVEL = 2;
pub const ES_AUTOVSCROLL = @as(c_long, 64);
pub const FSCTL_MARK_AS_SYSTEM_HIVE = FSCTL_SET_BOOTLOADER_ACCESSED;
pub const VP_FLAGS_BRIGHTNESS = 64;
pub const __INT_LEAST32_TYPE__ = int;
pub const MSGFLT_ALLOW = 1;
pub const szOID_SUBJECT_ALT_NAME = "2.5.29.7";
pub const WGL_SWAP_OVERLAY11 = 2048;
pub const IMAGE_SCN_LNK_COMDAT = 4096;
pub const PROCESS_HEAP_ENTRY_DDESHARE = 32;
pub const CMSG_HASH_DATA_PARAM = 21;
pub const EVENT_OBJECT_DRAGSTART = 32801;
pub const GetGlyphIndices = GetGlyphIndicesA;
pub const X509_UNICODE_NAME_VALUE = if (@typeId(@typeOf(24)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 24) else if (@typeId(@typeOf(24)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 24) else LPCSTR(24);
pub const ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD = @as(c_long, 8507);
pub const SECURITY_LOCAL_SYSTEM_RID = @as(c_long, 18);
pub const FIND_STARTSWITH = 1048576;
pub const szOID_CTL = "1.3.6.1.4.1.311.10.1";
pub const CRYPT_EXPORT_KEY = 64;
pub const ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL = @as(c_long, 8611);
pub const RPC_S_NOT_ENOUGH_QUOTA = ERROR_NOT_ENOUGH_QUOTA;
pub const SWP_HIDEWINDOW = 128;
pub const DRAFTMODE = 7;
pub const PSCB_INITIALIZED = 1;
pub const NUMCOLORS = 24;
pub const CERT_COMPARE_SIGNATURE_HASH = 14;
pub const RESOURCEDISPLAYTYPE_NETWORK = 6;
pub const NTDDI_WIN10_RS2 = 167772163;
pub const ACE_INHERITED_OBJECT_TYPE_PRESENT = 2;
pub const URL_MK_NO_CANONICALIZE = 2;
pub const IMAGE_SCN_NO_DEFER_SPEC_EXC = 16384;
pub const DRV_EXITSESSION = 11;
pub const CLIPBRD_S_FIRST = @as(c_long, 262608);
pub const ERROR_DS_DUPLICATE_ID_FOUND = @as(c_long, 8605);
pub const WH_FOREGROUNDIDLE = 11;
pub const ERROR_INSTALL_REMOTE_DISALLOWED = @as(c_long, 1640);
pub const BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_CA_FLAG = 2147483648;
pub const MININT16 = if (@typeId(@typeOf(~MAXINT16)) == @import("builtin").TypeId.Pointer) @ptrCast(INT16, ~MAXINT16) else if (@typeId(@typeOf(~MAXINT16)) == @import("builtin").TypeId.Int) @intToPtr(INT16, ~MAXINT16) else INT16(~MAXINT16);
pub const __inner_typefix = ctype;
pub const DEVICEFAMILYINFOENUM_MAX = 17;
pub const DUPLICATE_EXTENTS_DATA_EX_SOURCE_ATOMIC = 1;
pub const SEM_NOOPENFILEERRORBOX = 32768;
pub const VER_SUITE_DATACENTER = 128;
pub const ABM_ACTIVATE = 6;
pub const DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE = if (@typeId(@typeOf(-3)) == @import("builtin").TypeId.Pointer) @ptrCast(DPI_AWARENESS_CONTEXT, -3) else if (@typeId(@typeOf(-3)) == @import("builtin").TypeId.Int) @intToPtr(DPI_AWARENESS_CONTEXT, -3) else DPI_AWARENESS_CONTEXT(-3);
pub const CERT_QUERY_FORMAT_ASN_ASCII_HEX_ENCODED = 3;
pub const CTRY_GERMANY = 49;
pub const SO_ACCEPTCONN = 2;
pub const NCRYPT_DSA_ALGORITHM_GROUP = NCRYPT_DSA_ALGORITHM;
pub const RPC_C_AUTHN_NEGO_EXTENDER = 30;
pub const LR_LOADTRANSPARENT = 32;
pub const MDITILE_ZORDER = 4;
pub const ERROR_HANDLE_NO_LONGER_VALID = @as(c_long, 6815);
pub const C2_LEFTTORIGHT = 1;
pub const waveOutGetErrorText = waveOutGetErrorTextA;
pub const TOUCH_FLAG_NONE = 0;
pub const ENOTEMPTY = 41;
pub const SECURITY_REMOTE_LOGON_RID = @as(c_long, 14);
pub const PRINTDLGEXORD = 1549;
pub const ERROR_DS_HIERARCHY_TABLE_TOO_DEEP = @as(c_long, 8628);
pub const MM_MAX = MM_ANISOTROPIC;
pub const WM_IME_STARTCOMPOSITION = 269;
pub const CTRY_ROMANIA = 40;
pub const WM_VSCROLL = 277;
pub const DOF_DOCUMENT = 32770;
pub const DFCS_CHECKED = 1024;
pub const RPC_S_PROCNUM_OUT_OF_RANGE = @as(c_long, 1745);
pub const szOID_YESNO_TRUST_ATTR = "1.3.6.1.4.1.311.10.4.1";
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_EXCEPTION_ROOT = 16;
pub const _WIN32_WINNT_WINXP = 1281;
pub const FILE_DEVICE_VIRTUAL_BLOCK = 83;
pub const MOD_LEFT = 32768;
pub const DOMAIN_GROUP_RID_GUESTS = @as(c_long, 514);
pub const MOM_POSITIONCB = MM_MOM_POSITIONCB;
pub const IMAGE_DEBUG_TYPE_UNKNOWN = 0;
pub const WNNC_NET_GOOGLE = 4390912;
pub const ERROR_FT_READ_RECOVERY_FROM_BACKUP = @as(c_long, 704);
pub const WINPERF_LOG_USER = 1;
pub const LB_SETITEMHEIGHT = 416;
pub const PRINTER_STATUS_PAPER_OUT = 16;
pub const ReadSizeTRaw = ReadULongPtrRaw;
pub const EM_SCROLLCARET = 183;
pub const MemoryBarrier = __faststorefence;
pub const EMR_EXTSELECTCLIPRGN = 75;
pub const SHTDN_REASON_FLAG_COMMENT_REQUIRED = 16777216;
pub const PORT_STATUS_USER_INTERVENTION = 8;
pub const LANG_FRENCH = 12;
pub const TME_NONCLIENT = 16;
pub const SB_ENDSCROLL = 8;
pub const POLICY_SHOWREASONUI_SERVERONLY = 3;
pub const IMAGE_SYM_CLASS_END_OF_STRUCT = 102;
pub const FE_FONTSMOOTHINGORIENTATIONBGR = 0;
pub const __in_bcount_nz_opt = size;
pub const CONTEXT_SERVICE_ACTIVE = @as(c_long, 268435456);
pub const WSAEHOSTDOWN = @as(c_long, 10064);
pub const VIF_MISMATCH = @as(c_long, 2);
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILEOFFSET = @as(c_long, 411);
pub const ERROR_PWD_TOO_LONG = @as(c_long, 657);
pub const ERROR_SXS_XML_E_INCOMPLETE_ENCODING = @as(c_long, 14043);
pub const PRODUCT_ENTERPRISE_S_EVALUATION = 129;
pub const __INT32_TYPE__ = int;
pub const NCRYPTBUFFER_ATTESTATIONSTATEMENT_BLOB = 51;
pub const MIDICAPS_STREAM = 8;
pub const DMPAPER_PENV_10_ROTATED = 118;
pub const BitTest = _bittest;
pub const GL_ID_CHOOSECANDIDATE = 40;
pub const TXFS_RM_FLAG_DO_NOT_RESET_RM_AT_NEXT_START = 32768;
pub const ERROR_SEM_USER_LIMIT = @as(c_long, 106);
pub const ImmGetConversionList = ImmGetConversionListA;
pub const RegisterWindowMessage = RegisterWindowMessageA;
pub const MF_CHANGE = @as(c_long, 128);
pub const RPC_S_PRF_ELT_NOT_ADDED = @as(c_long, 1926);
pub const PF_XSAVE_ENABLED = 17;
pub const NTDDI_VISTASP3 = NTDDI_WIN6SP3;
pub const __INT_LEAST8_FMTd__ = "hhd";
pub const PR_JOBSTATUS = 0;
pub const ERROR_LICENSE_QUOTA_EXCEEDED = @as(c_long, 1395);
pub const WGL_SWAP_UNDERLAY2 = 131072;
pub const TXFS_RM_FLAG_SHRINK_LOG = 2048;
pub const SB_LINERIGHT = 1;
pub const ERROR_APPINSTALLER_ACTIVATION_BLOCKED = @as(c_long, 15646);
pub const ERROR_CLUSTER_NODE_NOT_PAUSED = @as(c_long, 5058);
pub const ERROR_APPX_RAW_DATA_WRITE_FAILED = @as(c_long, 15648);
pub const MAXINTATOM = 49152;
pub const IPPROTO_MAX = 256;
pub const ALG_SID_CAST = 6;
pub const WAVE_FORMAT_1M16 = 4;
pub const ENOLINK = 121;
pub const DNS_ERROR_WINS_INIT_FAILED = @as(c_long, 9615);
pub const CERT_QUERY_CONTENT_CRL = 3;
pub const OR_INVALID_SET = @as(c_long, 1912);
pub const CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC = "CryptMsgDllGenContentEncryptKey";
pub const szOID_LICENSES = "1.3.6.1.4.1.311.10.6.1";
pub const ERROR_CLOUD_FILE_METADATA_TOO_LARGE = @as(c_long, 364);
pub const FACILITY_WMAAECMA = 1996;
pub const WINSTA_READSCREEN = @as(c_long, 512);
pub const CF_PALETTE = 9;
pub const WM_NCRBUTTONDBLCLK = 166;
pub const IOInetProtocolEx = IInternetProtocolEx;
pub const RC_BITBLT = 1;
pub const DISPID_PROPERTYPUT = -3;
pub const WGL_SWAP_OVERLAY10 = 1024;
pub const FILE_SYSTEM_ATTR = 2;
pub const IME_CMODE_HANGEUL = IME_CMODE_NATIVE;
pub const ENUMRESNAMEPROC = ENUMRESNAMEPROCA;
pub const MDMVOL_HIGH = 2;
pub const ERROR_INVALID_COLORSPACE = @as(c_long, 2017);
pub const SHGetDiskFreeSpace = SHGetDiskFreeSpaceEx;
pub const LAYOUT_RTL = 1;
pub const SPI_GETWINDOWSEXTENSION = 92;
pub const SEF_FORCE_USER_MODE = 8192;
pub const NCRYPT_DO_NOT_FINALIZE_FLAG = 1024;
pub const LOCALE_SAM = 40;
pub const ERROR_GPIO_INCOMPATIBLE_CONNECT_MODE = @as(c_long, 15326);
pub const ERROR_MRM_UNSUPPORTED_DIRECTORY_TYPE = @as(c_long, 15122);
pub const ES_AUTOHSCROLL = @as(c_long, 128);
pub const CERT_STORE_PROV_PKCS7 = if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 5) else if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 5) else LPCSTR(5);
pub const PRODUCT_UNLICENSED = 2882382797;
pub const X509_ECC_PARAMETERS = if (@typeId(@typeOf(85)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 85) else if (@typeId(@typeOf(85)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 85) else LPCSTR(85);
pub const GetWindowLong = GetWindowLongA;
pub const RealGetWindowClass = RealGetWindowClassA;
pub const SYMBOL_FONTTYPE = 524288;
pub const NTDDI_WIN10_RS3 = 167772164;
pub const ERROR_CAN_NOT_DEL_LOCAL_WINS = @as(c_long, 4001);
pub const WAVE_FORMAT_44S16 = 2048;
pub const PAN_LETT_OBLIQUE_WEIGHTED = 10;
pub const MUI_LANGUAGE_NAME = 8;
pub const SPI_GETSELECTIONFADE = 4116;
pub const CERT_REGISTRY_STORE_REMOTE_FLAG = 65536;
pub const ERROR_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND = @as(c_long, 4423);
pub const SO_REUSEADDR = 4;
pub const COLOR_INACTIVECAPTIONTEXT = 19;
pub const FACILITY_NDIS = 52;
pub const szOID_OIWSEC_md5RSASign = "1.3.14.3.2.25";
pub const __BYTE_ORDER__ = __ORDER_LITTLE_ENDIAN__;
pub const FILE_PROVIDER_SINGLE_FILE = 1;
pub const SERVICE_STOP_PENDING = 3;
pub const VFT2_DRV_MOUSE = @as(c_long, 5);
pub const SNAPSHOT_POLICY_UNPLANNED = 2;
pub const szOID_CERT_STRONG_SIGN_OS_1 = "1.3.6.1.4.1.311.72.1.1";
pub const ERROR_NO_LINK_TRACKING_IN_TRANSACTION = @as(c_long, 6852);
pub const KP_SIGNATURE_PIN = 33;
pub const CRYPT_SGC = 1;
pub const ERROR_INVALID_QUOTA_LOWER = @as(c_long, 547);
pub const ERROR_INVALID_FUNCTION = @as(c_long, 1);
pub const MK_S_LAST = @as(c_long, 262639);
pub const LOAD_LIBRARY_SEARCH_APPLICATION_DIR = 512;
pub const CertGetNameString = CertGetNameStringA;
pub const ERROR_IPSEC_TUNNEL_FILTER_EXISTS = @as(c_long, 13016);
pub const NCRYPTBUFFER_TPM_SEAL_PASSWORD = 70;
pub const ERROR_REQUEST_PAUSED = @as(c_long, 3050);
pub const EVENT_OBJECT_ACCELERATORCHANGE = 32786;
pub const PAN_WEIGHT_HEAVY = 9;
pub const OCSP_INTERNAL_ERROR_RESPONSE = 2;
pub const AbortSystemShutdown = AbortSystemShutdownA;
pub const PSCB_BUTTONPRESSED = 3;
pub const EMARCH_ENC_I17_IMM5C_SIZE_X = 5;
pub const MUI_LANG_NEUTRAL_PE_FILE = 256;
pub const DS_MODALFRAME = @as(c_long, 128);
pub const STARTF_USEHOTKEY = 512;
pub const CCHFORMNAME = 32;
pub const CRYPT_DECODE_ENABLE_PUNYCODE_FLAG = 33554432;
pub const CMSG_CMS_ENCAPSULATED_CONTENT_FLAG = 64;
pub const RegDeleteValue = RegDeleteValueA;
pub const ACL_REVISION_DS = 4;
pub const WM_MBUTTONUP = 520;
pub const EXCEPTION_INVALID_DISPOSITION = STATUS_INVALID_DISPOSITION;
pub const BST_FOCUS = 8;
pub const FW_EXTRABOLD = 800;
pub const XSTATE_COMPACTION_ENABLE_MASK = if (@typeId(@typeOf(i64 << XSTATE_COMPACTION_ENABLE)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << XSTATE_COMPACTION_ENABLE) else if (@typeId(@typeOf(i64 << XSTATE_COMPACTION_ENABLE)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << XSTATE_COMPACTION_ENABLE) else @as(c_uint, 1)(i64 << XSTATE_COMPACTION_ENABLE);
pub const FILE_NAME_OPENED = 8;
pub const LANG_AFRIKAANS = 54;
pub const szOID_SUPPORTED_APPLICATION_CONTEXT = "2.5.4.30";
pub const IMAGE_SIZEOF_FILE_HEADER = 20;
pub const VP_FLAGS_CONTRAST = 128;
pub const BSF_RETURNHDESK = 512;
pub const ERROR_NO_CALLBACK_ACTIVE = @as(c_long, 614);
pub const JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT = 3;
pub const DATA_E_FORMATETC = DV_E_FORMATETC;
pub const PRINTER_STATUS_BUSY = 512;
pub const EC_ENABLEONE = ST_BLOCKNEXT;
pub const SB_LINEDOWN = 1;
pub const IGIMII_CMODE = 1;
pub const GCPCLASS_PREBOUNDLTR = 128;
pub const BCRYPT_HKDF_ALG_HANDLE = if (@typeId(@typeOf(913)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 913) else if (@typeId(@typeOf(913)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 913) else BCRYPT_ALG_HANDLE(913);
pub const CRYPT_OID_EXPORT_PRIVATE_KEY_INFO_FUNC = "CryptDllExportPrivateKeyInfoEx";
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE = 46;
pub const WRITE_RESTRICTED = 8;
pub const GetComputerNameEx = GetComputerNameExA;
pub const MAXULONGLONG = if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(ULONGLONG, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(ULONGLONG, 0) else ULONGLONG(0))) == @import("builtin").TypeId.Pointer) @ptrCast(ULONGLONG, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(ULONGLONG, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(ULONGLONG, 0) else ULONGLONG(0)) else if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(ULONGLONG, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(ULONGLONG, 0) else ULONGLONG(0))) == @import("builtin").TypeId.Int) @intToPtr(ULONGLONG, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(ULONGLONG, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(ULONGLONG, 0) else ULONGLONG(0)) else ULONGLONG(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(ULONGLONG, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(ULONGLONG, 0) else ULONGLONG(0));
pub const AnsiToOem = CharToOemA;
pub const GL_LEVEL_NOGUIDELINE = 0;
pub const S_FALSE = if (@typeId(@typeOf(@as(c_long, 1))) == @import("builtin").TypeId.Pointer) @ptrCast(HRESULT, @as(c_long, 1)) else if (@typeId(@typeOf(@as(c_long, 1))) == @import("builtin").TypeId.Int) @intToPtr(HRESULT, @as(c_long, 1)) else HRESULT(@as(c_long, 1));
pub const JOB_OBJECT_MSG_END_OF_PROCESS_TIME = 2;
pub const CreateSymbolicLink = CreateSymbolicLinkA;
pub const ERROR_LABEL_QUESTIONABLE = 2;
pub const QS_POINTER = 4096;
pub const SM_CXICON = 11;
pub const ERROR_INVALID_PRINTER_COMMAND = @as(c_long, 1803);
pub const WM_PENWINFIRST = 896;
pub const Uri_HAS_DISPLAY_URI = 1 << Uri_PROPERTY_DISPLAY_URI;
pub const SM_CXVIRTUALSCREEN = 78;
pub const PRSPEC_INVALID = 4294967295;
pub const CRYPT_MESSAGE_KEYID_RECIPIENT_FLAG = 4;
pub const GRAY_BRUSH = 2;
pub const PD_NOSELECTION = 4;
pub const IMAGE_REL_SHM_RELHALF = 23;
pub const NTDDI_VISTASP2 = NTDDI_WIN6SP2;
pub const ERROR_UNDEFINED_SCOPE = @as(c_long, 319);
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_ARRAY_LENGTH_COUNT = 1048576;
pub const USN_SOURCE_REPLICATION_MANAGEMENT = 4;
pub const CAL_SABBREVERASTRING = 57;
pub const ERROR_DS_NAME_ERROR_NO_MAPPING = @as(c_long, 8472);
pub const WGL_SWAP_UNDERLAY3 = 262144;
pub const CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION = 2;
pub const PGET_MODULE_HANDLE_EX = PGET_MODULE_HANDLE_EXA;
pub const PRODUCT_STANDARD_A_SERVER_CORE = 146;
pub const CRYPT_SF = 256;
pub const WNNC_NET_MS_NFS = 4325376;
pub const LOCALE_SGROUPING = 16;
pub const STARTF_FORCEOFFFEEDBACK = 128;
pub const RPC_C_MGMT_STOP_SERVER_LISTEN = 4;
pub const MIIM_FTYPE = 256;
pub const CTRY_ESTONIA = 372;
pub const WN_FUNCTION_BUSY = ERROR_BUSY;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_SERVICE_STOP = 2;
pub const SHIFT_PRESSED = 16;
pub const URLACTION_SHELL_CURR_MAX = 6162;
pub const TAPE_SETMARKS = @as(c_long, 0);
pub const SECURITY_ANONYMOUS_LOGON_RID = @as(c_long, 7);
pub const PRINTER_STATUS_NOT_AVAILABLE = 4096;
pub const stc7 = 1094;
pub const HTZOOM = HTMAXBUTTON;
pub const NCRYPT_ECC_PARAMETERS_PROPERTY = BCRYPT_ECC_PARAMETERS;
pub const PSD_DISABLEORIENTATION = 256;
pub const IMC_GETSTATUSWINDOWPOS = 15;
pub const __UINTPTR_FMTu__ = "llu";
pub const WS_EX_APPWINDOW = @as(c_long, 262144);
pub const FS_HEBREW = @as(c_long, 32);
pub const ES_USER_PRESENT = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 4) else DWORD(4);
pub const CD_LBSELCHANGE = 0;
pub const SYSTEM_STATUS_FLAG_POWER_SAVING_ON = 1;
pub const ERROR_PAGE_FAULT_COPY_ON_WRITE = @as(c_long, 749);
pub const ERROR_INVALID_DATATYPE = @as(c_long, 1804);
pub const RPC_S_INVALID_BINDING = @as(c_long, 1702);
pub const ICON_BIG = 1;
pub const IMN_CLOSESTATUSWINDOW = 1;
pub const SHIL_JUMBO = 4;
pub const PSN_FIRST = if (@typeId(@typeOf(-@as(c_uint, 200))) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), -@as(c_uint, 200)) else if (@typeId(@typeOf(-@as(c_uint, 200))) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), -@as(c_uint, 200)) else @as(c_uint, 0)(-@as(c_uint, 200));
pub const MIDIMAPPER = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(UINT, -1) else UINT(-1);
pub const szOID_ARCHIVED_KEY_CERT_HASH = "1.3.6.1.4.1.311.21.16";
pub const SERVICE_STOP_REASON_MINOR_SECURITYFIX_UNINSTALL = 21;
pub const WGL_SWAP_OVERLAY13 = 8192;
pub const SERVICE_STOP_REASON_MINOR_SECURITYFIX = 15;
pub const VER_EQUAL = 1;
pub const ShiftLeft128 = __shiftleft128;
pub const BACKUP_SECURITY_INFORMATION = @as(c_long, 65536);
pub const MapVirtualKey = MapVirtualKeyA;
pub const ShellMessageBox = ShellMessageBoxA;
pub const CERT_SELECT_BY_SUBJECT_ATTR = 8;
pub const AF_BAN = 21;
pub const FACILITY_INTERNET = 12;
pub const SS_CENTERIMAGE = @as(c_long, 512);
pub const MCI_SET_DOOR_OPEN = @as(c_long, 256);
pub const CRYPT_ACQUIRE_USE_PROV_INFO_FLAG = 2;
pub const MCI_OVLY_WHERE_FRAME = @as(c_long, 524288);
pub const PRODUCT_ARM64_SERVER = 120;
pub const ERROR_CLEANER_CARTRIDGE_INSTALLED = @as(c_long, 4340);
pub const RI_MOUSE_RIGHT_BUTTON_DOWN = 4;
pub const ERROR_DS_REFUSING_FSMO_ROLES = @as(c_long, 8433);
pub const ICM_UNREGISTERICMATCHER = 6;
pub const STORE_ERROR_UNLICENSED_USER = @as(c_long, 15862);
pub const NTDDI_WIN10_RS4 = 167772165;
pub const szOID_BUSINESS_CATEGORY = "2.5.4.15";
pub const ASYNC_MODE_DEFAULT = @as(c_long, 0);
pub const URLACTION_ALLOW_ANTIMALWARE_SCANNING_OF_ACTIVEX = 9996;
pub const __INT64_FMTd__ = "lld";
pub const SUBLANG_SERBIAN_SERBIA_LATIN = 9;
pub const URLACTION_AUTOMATIC_DOWNLOAD_UI_MIN = 8704;
pub const WINAPI_FAMILY_APP = WINAPI_FAMILY_PC_APP;
pub const ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT = @as(c_long, 5924);
pub const PRODUCT_CORE_CONNECTED_SINGLELANGUAGE = 115;
pub const SPI_GETGRIDGRANULARITY = 18;
pub const USER_DEFAULT_SCREEN_DPI = 96;
pub const DPD_DELETE_ALL_FILES = 4;
pub const FILE_DEVICE_BUS_EXTENDER = 42;
pub const sz_CERT_STORE_PROV_COLLECTION = "Collection";
pub const DNS_ERROR_POLICY_PROCESSING_ORDER_INVALID = @as(c_long, 9985);
pub const EVENT_OEM_DEFINED_START = 257;
pub const URLACTION_HTML_ALLOW_CROSS_DOMAIN_WEBWORKER = 5647;
pub const IMN_SETOPENSTATUS = 8;
pub const ERROR_ABANDONED_WAIT_0 = @as(c_long, 735);
pub const RUNTIME_FUNCTION_INDIRECT = 1;
pub const IMAGE_REL_BASED_MIPS_JMPADDR = 5;
pub const ERROR_LOG_READ_MODE_INVALID = @as(c_long, 6610);
pub const ENHANCED_KEY = 256;
pub const MB_TOPMOST = @as(c_long, 262144);
pub const CP_SYMBOL = 42;
pub const CERT_CHAIN_AUTO_LOCAL_MACHINE = 2;
pub const CERT_STORE_CTRL_INHIBIT_DUPLICATE_HANDLE_FLAG = 1;
pub const CWMO_MAX_HANDLES = 56;
pub const RegisterDeviceNotification = RegisterDeviceNotificationA;
pub const MKSYS_URLMONIKER = 6;
pub const EM_LINESCROLL = 182;
pub const MDM_ANALOG_RLP_ON = 0;
pub const CP_UTF8 = 65001;
pub const szOID_ECDSA_SHA1 = "1.2.840.10045.4.1";
pub const szOID_STATE_OR_PROVINCE_NAME = "2.5.4.8";
pub const SECURITY_CREATOR_GROUP_RID = @as(c_long, 1);
pub const DOMAIN_USER_RID_WDAG_ACCOUNT = @as(c_long, 504);
pub const BI_RLE4 = @as(c_long, 2);
pub const NRC_REMTFUL = 18;
pub const GetConsoleCommandHistoryLength = GetConsoleCommandHistoryLengthA;
pub const XST_REQSENT = 5;
pub const DNS_STATUS_CONTINUE_NEEDED = @as(c_long, 9801);
pub const HELP_CONTEXTMENU = 10;
pub const DMBIN_MIDDLE = 3;
pub const RPC_S_CANNOT_SUPPORT = @as(c_long, 1764);
pub const ERROR_FLOPPY_ID_MARK_NOT_FOUND = @as(c_long, 1122);
pub const MOVEFILE_DELAY_UNTIL_REBOOT = 4;
pub const CERT_REGISTRY_STORE_LM_GPT_FLAG = 16777216;
pub const GMMP_USE_HIGH_RESOLUTION_POINTS = 2;
pub const SB_PAGEUP = 2;
pub const ERROR_DS_INTERNAL_FAILURE = @as(c_long, 8430);
pub const IME_ESC_PRIVATE_HOTKEY = 4106;
pub const CCHDEVICENAME = 32;
pub const ASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION = ASSEMBLY_FILE_DETAILED_INFORMATION;
pub const IMAGE_REL_I386_DIR16 = 1;
pub const __sdv_save_adapter_context = c;
pub const MCI_SEQ_STATUS_COPYRIGHT = @as(c_long, 16396);
pub const LANG_FILIPINO = 100;
pub const PIPE_NOWAIT = 1;
pub const PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON_ALLOW_OPT_OUT = if (@typeId(@typeOf(i64 << 36)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 36) else if (@typeId(@typeOf(i64 << 36)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 36) else @as(c_uint, 3)(i64 << 36);
pub const SPI_SETDRAGHEIGHT = 77;
pub const BitTest64 = _bittest64;
pub const FILE_IS_ENCRYPTED = 1;
pub const RPC_IF_ALLOW_LOCAL_ONLY = 32;
pub const BM_SETIMAGE = 247;
pub const ILLUMINANT_D75 = 7;
pub const JOB_OBJECT_SECURITY_ONLY_TOKEN = 4;
pub const STORAGE_PROTOCOL_STATUS_INSUFFICIENT_RESOURCES = 7;
pub const CRYPT_DONT_CHECK_TIME_VALIDITY = 512;
pub const URLPOLICY_CREDENTIALS_CONDITIONAL_PROMPT = 131072;
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_STATIC_CREATE = 82;
pub const DNS_ERROR_DELEGATION_REQUIRED = @as(c_long, 9571);
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_ENABLED = 3;
pub const RegisterServiceCtrlHandler = RegisterServiceCtrlHandlerA;
pub const CMSG_CTRL_VERIFY_SIGNATURE_EX = 19;
pub const DMPAPER_PENV_3 = 98;
pub const DNS_ERROR_SUBNET_ALREADY_EXISTS = @as(c_long, 9979);
pub const NTDDI_VISTASP1 = NTDDI_WIN6SP1;
pub const CreateFileTransacted = CreateFileTransactedA;
pub const MSGF_MENU = 2;
pub const SBS_TOPALIGN = @as(c_long, 2);
pub const ERROR_INVALID_NETNAME = @as(c_long, 1214);
pub const frm4 = 1079;
pub const FACILITY_DIRECT3D11_DEBUG = 2173;
pub const OPENCARDNAMEA_EX = OPENCARDNAME_EXA;
pub const SECURITY_BUILTIN_PACKAGE_ANY_RESTRICTED_PACKAGE = @as(c_long, 2);
pub const IMAGE_REL_SH3_STARTOF_SECTION = 12;
pub const RegLoadMUIString = RegLoadMUIStringA;
pub const __UINT_LEAST16_FMTx__ = "hx";
pub const TAPE_QUERY_MEDIA_CAPACITY = @as(c_long, 1);
pub const BSF_QUERY = 1;
pub const _Post_satisfies_impl_ = expr;
pub const EOVERFLOW = 132;
pub const RESTART_NO_REBOOT = 8;
pub const SPI_GETSOUNDSENTRY = 64;
pub const XST_DATARCVD = 6;
pub const SS_REALSIZECONTROL = @as(c_long, 64);
pub const CBR_115200 = 115200;
pub const ELEMENT_STATUS_SVALID = 8388608;
pub const stc6 = 1093;
pub const PRINTER_ERROR_INFORMATION = 2147483648;
pub const ERROR_UNEXPECTED_MM_EXTEND_ERR = @as(c_long, 558);
pub const URLACTION_PLUGGABLE_PROTOCOL_XHR = 5131;
pub const URL_OID_CERTIFICATE_CRL_DIST_POINT = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 2) else LPCSTR(2);
pub const CWCSTORAGENAME = 32;
pub const LANG_TELUGU = 74;
pub const WM_DESTROY = 2;
pub const PSP_USEFUSIONCONTEXT = 16384;
pub const MIXER_SHORT_NAME_CHARS = 16;
pub const RpcNsBindingUnexportPnP = RpcNsBindingUnexportPnPA;
pub const GROUP_SECURITY_INFORMATION = @as(c_long, 2);
pub const CERT_RDN_TYPE_MASK = 255;
pub const DO_DROPFILE = @as(c_long, 1162627398);
pub const ALG_SID_3DES = 3;
pub const FILE_DELETE_CHILD = 64;
pub const ERROR_PACKAGES_IN_USE = @as(c_long, 15618);
pub const VK_HANGEUL = 21;
pub const WGL_SWAP_OVERLAY12 = 4096;
pub const CTLCOLOR_BTN = 3;
pub const IO_REPARSE_TAG_DFSR = @as(c_long, 2147483666);
pub const ERROR_PACKAGE_MOVE_FAILED = @as(c_long, 15627);
pub const SERVICE_STOP_REASON_MINOR_INSTALLATION = 3;
pub const szOID_INFOSEC_SuiteAKMandSig = "2.16.840.1.101.2.1.1.18";
pub const CTRY_UZBEKISTAN = 7;
pub const PME_FAILFAST_ON_COMMIT_FAIL_ENABLE = 1;
pub const DNS_ERROR_SCOPE_ALREADY_EXISTS = @as(c_long, 9963);
pub const GetVolumeNameForVolumeMountPoint = GetVolumeNameForVolumeMountPointA;
pub const SYSTEM_ACCESS_FILTER_NOCONSTRAINT_MASK = 4294967295;
pub const RPC_SYSTEM_HANDLE_FREE_ERROR_ON_CLOSE = 4;
pub const CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG = 1;
pub const RPC_S_PRF_ELT_NOT_REMOVED = @as(c_long, 1927);
pub const CERT_QUERY_CONTENT_CERT_PAIR = 13;
pub const NTDDI_WIN10_RS5 = 167772166;
pub const METHOD_DIRECT_TO_HARDWARE = METHOD_IN_DIRECT;
pub const IMAGE_DIRECTORY_ENTRY_EXCEPTION = 3;
pub const ERROR_PIPE_LISTENING = @as(c_long, 536);
pub const LANG_GUJARATI = 71;
pub const ERROR_CLEANER_SLOT_SET = @as(c_long, 4331);
pub const CLAIM_SECURITY_ATTRIBUTE_NON_INHERITABLE = 1;
pub const ALG_SID_SHA_384 = 13;
pub const FACILITY_BLB = 120;
pub const PRINTER_NOTIFY_FIELD_COMMENT = 5;
pub const IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = 14;
pub const ERROR_BAD_CURRENT_DIRECTORY = @as(c_long, 703);
pub const NRC_BUFLEN = 1;
pub const JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME = 64;
pub const __in_ecount_nz = size;
pub const RPI_SMB2_FLAG_SERVERCAP_LARGEMTU = 4;
pub const STREAM_CONTAINS_GHOSTED_FILE_EXTENTS = 16;
pub const DNS_FILTERON = 4;
pub const ERROR_INVALID_OPERATION_ON_QUORUM = @as(c_long, 5068);
pub const FILE_DEVICE_POINT_OF_SERVICE = 84;
pub const VK_RIGHT = 39;
pub const CTRY_SOUTH_AFRICA = 27;
pub const META_EXTFLOODFILL = 1352;
pub const SYSPAL_NOSTATIC256 = 3;
pub const IMAGE_REL_ARM64_ABSOLUTE = 0;
pub const FILE_DEVICE_INFINIBAND = 59;
pub const WNetAddConnection2 = WNetAddConnection2A;
pub const RI_MOUSE_BUTTON_1_DOWN = RI_MOUSE_LEFT_BUTTON_DOWN;
pub const PARTITION_XINT13_EXTENDED = 15;
pub const MSGFLTINFO_ALLOWED_HIGHER = 3;
pub const CRYPT_HTTP_POST_RETRIEVAL = 1048576;
pub const szOID_ATTR_SUPPORTED_ALGORITHMS = "2.5.4.52";
pub const PARAMFLAG_NONE = 0;
pub const HIGH_LEVEL = 15;
pub const CAT_E_LAST = @as(c_long, 2147746145);
pub const BCRYPT_AES_CMAC_ALG_HANDLE = if (@typeId(@typeOf(257)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 257) else if (@typeId(@typeOf(257)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 257) else BCRYPT_ALG_HANDLE(257);
pub const META_SETBKMODE = 258;
pub const MCI_OVLY_PUT_FRAME = @as(c_long, 524288);
pub const ERROR_GROUP_NOT_ONLINE = @as(c_long, 5014);
pub const VER_SUITE_SMALLBUSINESS = 1;
pub const DIFFERENCE = 11;
pub const ERROR_DEVICE_NOT_PARTITIONED = @as(c_long, 1107);
pub const ERROR_SEVERITY_ERROR = 3221225472;
pub const ERROR_TRANSACTION_NOT_JOINED = @as(c_long, 6708);
pub const CRYPT_STRING_RESERVED100 = 256;
pub const ERROR_ARENA_TRASHED = @as(c_long, 7);
pub const WS_CAPTION = @as(c_long, 12582912);
pub const RPC_X_INVALID_ES_ACTION = @as(c_long, 1827);
pub const MMIO_RWMODE = 3;
pub const SESSION_QUERY_ACCESS = 1;
pub const ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION = @as(c_long, 6838);
pub const PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_OFF = 2 << 12;
pub const CMSG_CTRL_ADD_SIGNER = 6;
pub const EVENT_OBJECT_SELECTIONWITHIN = 32777;
pub const SERIAL_LSRMST_LSR_DATA = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(BYTE, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(BYTE, 1) else BYTE(1);
pub const EVENT_SYSTEM_DESKTOPSWITCH = 32;
pub const ERROR_OUT_OF_PAPER = @as(c_long, 28);
pub const WOF_PROVIDER_FILE = 2;
pub const BSM_ALLCOMPONENTS = 0;
pub const LOCALE_STIMEFORMAT = 4099;
pub const IS_TEXT_UNICODE_DBCS_LEADBYTE = 1024;
pub const RPC_S_ENTRY_ALREADY_EXISTS = @as(c_long, 1760);
pub const SESSION_ESTABLISHED = 3;
pub const __FLT_MIN_EXP__ = -125;
pub const CERT_LDAP_STORE_SIGN_FLAG = 65536;
pub const DMICM_CONTRAST = 2;
pub const ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME = @as(c_long, 15108);
pub const DMPAPER_PENV_2 = 97;
pub const OCSP_BASIC_RESPONSE_V1 = 0;
pub const ERROR_DS_DRA_GENERIC = @as(c_long, 8436);
pub const MFS_UNCHECKED = MF_UNCHECKED;
pub const EC_DISABLE = ST_BLOCKED;
pub const CBR_128000 = 128000;
pub const GW_HWNDPREV = 3;
pub const CMSG_DEFAULT_INSTALLABLE_FUNC_OID = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 1) else LPCSTR(1);
pub const READ_COPY_NUMBER_KEY = 1380142592;
pub const DISP_CHANGE_BADMODE = -2;
pub const MCI_VD_PLAY_SPEED = @as(c_long, 262144);
pub const WGL_SWAP_UNDERLAY1 = 65536;
pub const ILLUMINANT_FLUORESCENT = ILLUMINANT_F2;
pub const VFT_APP = @as(c_long, 1);
pub const szOID_CERT_PROP_ID_PREFIX = "1.3.6.1.4.1.311.10.11.";
pub const SKF_TRISTATE = 128;
pub const VAR_CALENDAR_GREGORIAN = if (@typeId(@typeOf(256)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 256) else if (@typeId(@typeOf(256)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 256) else DWORD(256);
pub const ERROR_DDE_FAIL = @as(c_long, 1156);
pub const ERROR_INVALID_GROUPNAME = @as(c_long, 1209);
pub const LANG_KHMER = 83;
pub const IMAGE_FILE_MACHINE_CEE = 49390;
pub const _Notref_ = _Notref_impl_;
pub const ERROR_DS_SORT_CONTROL_MISSING = @as(c_long, 8261);
pub const PS_INSIDEFRAME = 6;
pub const CUR_BLOB_VERSION = 2;
pub const ERROR_NOTIFY_ENUM_DIR = @as(c_long, 1022);
pub const CTRY_BRAZIL = 55;
pub const PRINTER_DRIVER_NOT_SHAREABLE = 32;
pub const __DBL_DENORM_MIN__ = 0.000000;
pub const WS_EX_DLGMODALFRAME = @as(c_long, 1);
pub const SO_DISCOPT = 28675;
pub const SCARD_CLASS_IFD_PROTOCOL = 8;
pub const UNW_FLAG_CHAININFO = 4;
pub const RASTERCAPS = 38;
pub const VARIANT_FALSE = if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(VARIANT_BOOL, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(VARIANT_BOOL, 0) else VARIANT_BOOL(0);
pub const LANG_PASHTO = 99;
pub const FAST_FAIL_LEGACY_GS_VIOLATION = 0;
pub const CERT_ALT_NAME_VALUE_ERR_INDEX_SHIFT = 0;
pub const stc5 = 1092;
pub const MM_MOM_POSITIONCB = 970;
pub const CMC_STATUS = if (@typeId(@typeOf(61)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 61) else if (@typeId(@typeOf(61)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 61) else LPCSTR(61);
pub const ERROR_PRI_MERGE_MULTIPLE_PACKAGE_FAMILIES_NOT_ALLOWED = @as(c_long, 15153);
pub const SM_CYDLGFRAME = 8;
pub const FRS_ERR_INSUFFICIENT_PRIV = @as(c_long, 8007);
pub const ALG_SID_SSL3_MASTER = 1;
pub const APPIDREGFLAGS_IUSERVER_ACTIVATE_IN_CLIENT_SESSION_ONLY = 32;
pub const KDF_LABEL = 13;
pub const szOID_ECC_CURVE_BRAINPOOLP224R1 = "1.3.36.3.3.2.8.1.1.5";
pub const SpeculationFence = LoadFence;
pub const CBR_14400 = 14400;
pub const SET_FEATURE_ON_THREAD_RESTRICTED = 128;
pub const SETALLJUSTVALUES = 771;
pub const WAVE_FORMAT_DIRECT = 8;
pub const MUI_USER_PREFERRED_UI_LANGUAGES = 16;
pub const SCS_THIS_PLATFORM_BINARY = SCS_64BIT_BINARY;
pub const SPI_GETFONTSMOOTHINGORIENTATION = 8210;
pub const DT_END_ELLIPSIS = 32768;
pub const DeviceDsmAction_OffloadWrite = @as(c_uint, 4);
pub const FR_PRIVATE = 16;
pub const WGL_SWAP_OVERLAY15 = 32768;
pub const UI_CAP_ROTANY = 4;
pub const FOF_NOCONFIRMATION = 16;
pub const LOCALE_SLANGUAGE = LOCALE_SLOCALIZEDDISPLAYNAME;
pub const ERROR_ALREADY_HAS_STREAM_ID = @as(c_long, 4444);
pub const PEERDIST_ERROR_NOT_INITIALIZED = @as(c_long, 4054);
pub const ERROR_CLUSTER_EVICT_INVALID_REQUEST = @as(c_long, 5939);
pub const CTRY_IRELAND = 353;
pub const szOID_RSA_envelopedData = "1.2.840.113549.1.7.3";
pub const ExtractAssociatedIconEx = ExtractAssociatedIconExA;
pub const Uri_DISPLAY_IDN_HOST = 4;
pub const SSTF_CHARS = 1;
pub const CERT_NAME_FRIENDLY_DISPLAY_TYPE = 5;
pub const ERROR_DBG_PRINTEXCEPTION_C = @as(c_long, 694);
pub const PROCESSOR_ARM820 = 2080;
pub const CHANGER_PREDISMOUNT_ALIGN_TO_SLOT = 2147483649;
pub const CERT_CHAIN_POLICY_IGNORE_NOT_TIME_VALID_FLAG = 1;
pub const DNS_ERROR_ZONE_HAS_NO_SOA_RECORD = @as(c_long, 9605);
pub const ESB_DISABLE_RIGHT = 2;
pub const CONST = @"const";
pub const WIM_PROVIDER_EXTERNAL_FLAG_NOT_ACTIVE = 1;
pub const InterlockedBitTestAndReset64 = _interlockedbittestandreset64;
pub const APPCOMMAND_PASTE = 38;
pub const WM_IME_KEYLAST = 271;
pub const WSA_QOS_EFILTERSTYLE = @as(c_long, 11019);
pub const ERROR_DS_SINGLE_VALUE_CONSTRAINT = @as(c_long, 8321);
pub const MCI_WAVE_OPEN_BUFFER = @as(c_long, 65536);
pub const ERROR_CLUSTER_UPGRADE_INCOMPATIBLE_VERSIONS = @as(c_long, 5973);
pub const DKGRAY_BRUSH = 3;
pub const XSTATE_CONTROLFLAG_XSAVEC_MASK = 2;
pub const SERVICE_ACCEPT_LOWRESOURCES = 8192;
pub const szOID_RSA_emailAddr = "1.2.840.113549.1.9.1";
pub const ERROR_APP_HANG = @as(c_long, 1298);
pub const PC_SCANLINE = 8;
pub const WNetAddConnection3 = WNetAddConnection3A;
pub const ERROR_APPEXEC_HANDLE_INVALIDATED = @as(c_long, 3061);
pub const CAL_GREGORIAN_XLIT_FRENCH = 12;
pub const ERROR_DS_UNAVAILABLE = @as(c_long, 8207);
pub const ERROR_DRIVER_CANCEL_TIMEOUT = @as(c_long, 594);
pub const OCSP_BASIC_SIGNED_RESPONSE = if (@typeId(@typeOf(68)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 68) else if (@typeId(@typeOf(68)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 68) else LPCSTR(68);
pub const VK_OEM_ATTN = 240;
pub const EFBIG = 27;
pub const MIM_CLOSE = MM_MIM_CLOSE;
pub const FILE_ATTRIBUTE_DEVICE = 64;
pub const MMIOM_SEEK = 2;
pub const joyGetDevCaps = joyGetDevCapsA;
pub const DESKTOP_WRITEOBJECTS = @as(c_long, 128);
pub const __LDBL_DIG__ = 15;
pub const szOID_PKCS_7_SIGNED = "1.2.840.113549.1.7.2";
pub const ENODEV = 19;
pub const WAVE_FORMAT_4M08 = 256;
pub const CF_TTONLY = @as(c_long, 262144);
pub const ERROR_IPSEC_REPLAY_CHECK_FAILED = @as(c_long, 13913);
pub const CM_SERVICE_MEASURED_BOOT_LOAD = 32;
pub const WNNC_NET_TERMSRV = 3538944;
pub const DMPAPER_ENV_B5 = 34;
pub const OBJID_HSCROLL = if (@typeId(@typeOf(4294967290)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG, 4294967290) else if (@typeId(@typeOf(4294967290)) == @import("builtin").TypeId.Int) @intToPtr(LONG, 4294967290) else LONG(4294967290);
pub const CERT_STORE_TIME_VALIDITY_FLAG = 2;
pub const FKF_CLICKON = 64;
pub const CMSG_VERIFY_SIGNER_NULL = 4;
pub const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS_V0 = 0;
pub const szOID_ENROLL_SCEP_SIGNER_HASH = "1.3.6.1.4.1.311.21.42";
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION = 128;
pub const szOID_PROTECTED_PROCESS_LIGHT_SIGNER = "1.3.6.1.4.1.311.10.3.22";
pub const RPC_C_HTTP_FLAG_IGNORE_CERT_CN_INVALID = 8;
pub const ERROR_LOGON_SERVER_CONFLICT = @as(c_long, 568);
pub const HELP_KEY = @as(c_long, 257);
pub const DC_DRIVER = 11;
pub const ERROR_DUP_NAME = @as(c_long, 52);
pub const szOID_NEXT_UPDATE_LOCATION = "1.3.6.1.4.1.311.10.2";
pub const DMDITHER_FINE = 3;
pub const ERROR_LOG_POLICY_ALREADY_INSTALLED = @as(c_long, 6619);
pub const DMPAPER_PENV_1 = 96;
pub const PDERR_PRINTERCODES = 4096;
pub const JOB_OBJECT_LIMIT_AFFINITY = 16;
pub const CERT_STORE_PROV_GET_CERT_PROPERTY_FUNC = 16;
pub const ERROR_DS_DRA_RECYCLED_TARGET = @as(c_long, 8639);
pub const CRYPT_TEMPLATE_OID_GROUP_ID = 9;
pub const MOUSEEVENTF_XUP = 256;
pub const MCI_INFO_PRODUCT = @as(c_long, 256);
pub const IMAGE_SCN_MEM_DISCARDABLE = 33554432;
pub const UpdateICMRegKey = UpdateICMRegKeyA;
pub const WSAENOMORE = @as(c_long, 10102);
pub const ERROR_INVALID_USER_PRINCIPAL_NAME = @as(c_long, 8636);
pub const PAN_PROP_MODERN = 3;
pub const WM_NCPOINTERUP = 579;
pub const _STRALIGN_USE_SECURE_CRT = 1;
pub const FACILITY_WPN = 62;
pub const ERROR_PATCH_PACKAGE_REJECTED = @as(c_long, 1643);
pub const SCARD_SCOPE_USER = 0;
pub const IMAGE_FILE_MACHINE_CEF = 3311;
pub const ERROR_NEEDS_REMEDIATION = @as(c_long, 15612);
pub const VBS_BASIC_PAGE_ZERO_FILL = 3;
pub const NCRYPT_SEALING_FLAG = 256;
pub const FMFD_RESERVED_1 = 64;
pub const ERROR_MCA_UNSUPPORTED_MCCS_VERSION = @as(c_long, 15204);
pub const VK_EXECUTE = 43;
pub const MAX_REASON_BUGID_LEN = 32;
pub const CreateProcessAsUser = CreateProcessAsUserA;
pub const ERROR_WMI_UNRESOLVED_INSTANCE_REF = @as(c_long, 4205);
pub const NCRYPTBUFFER_ATTESTATION_CLAIM_CHALLENGE_REQUIRED = 53;
pub const stc4 = 1091;
pub const CreateMutexEx = CreateMutexExA;
pub const RemoveFontResource = RemoveFontResourceA;
pub const WH_CALLWNDPROC = 4;
pub const OUT_DEVICE_PRECIS = 5;
pub const STORAGE_PROTOCOL_STRUCTURE_VERSION = 1;
pub const BAUD_115200 = if (@typeId(@typeOf(131072)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 131072) else if (@typeId(@typeOf(131072)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 131072) else DWORD(131072);
pub const EVENTLOG_ERROR_TYPE = 1;
pub const FAST_FAIL_INCORRECT_STACK = 4;
pub const szOID_VERISIGN_ISS_STRONG_CRYPTO = "2.16.840.1.113733.1.8.1";
pub const FACILITY_LINGUISTIC_SERVICES = 305;
pub const PIDMSI_STATUS = @as(c_long, 7);
pub const DWLP_MSGRESULT = 0;
pub const IDLFLAG_NONE = PARAMFLAG_NONE;
pub const szOID_POSTAL_CODE = "2.5.4.17";
pub const ERROR_BEYOND_VDL = @as(c_long, 1289);
pub const SORT_JAPANESE_UNICODE = 1;
pub const TOUCHINPUTMASKF_EXTRAINFO = 2;
pub const IME_HOTKEY_DSWITCH_LAST = 287;
pub const szOID_OIWSEC_keyHashSeal = "1.3.14.3.2.23";
pub const RegEnumKey = RegEnumKeyA;
pub const MCI_SEQ_SET_MASTER = @as(c_long, 524288);
pub const WM_RENDERFORMAT = 773;
pub const WGL_SWAP_OVERLAY14 = 16384;
pub const ERROR_BAD_INHERITANCE_ACL = @as(c_long, 1340);
pub const MIXERLINE_TARGETTYPE_AUX = 5;
pub const GCP_LIGATE = 32;
pub const DRV_RESERVED = 2048;
pub const HCF_DEFAULTDESKTOP = 512;
pub const SKF_LWINLOCKED = 4194304;
pub const RESOURCE_RECENT = 4;
pub const DMICM_USER = 256;
pub const X509_KEY_USAGE = if (@typeId(@typeOf(14)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 14) else if (@typeId(@typeOf(14)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 14) else LPCSTR(14);
pub const SND_RESOURCE = @as(c_long, 262148);
pub const APPMODEL_ERROR_NO_PACKAGE = @as(c_long, 15700);
pub const EM_GETFIRSTVISIBLELINE = 206;
pub const ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER = @as(c_long, 8518);
pub const SCardGetProviderId = SCardGetProviderIdA;
pub const LANG_IRISH = 60;
pub const _Analysis_suppress_lock_checking_ = lock;
pub const IO_REPARSE_TAG_WOF = @as(c_long, 2147483671);
pub const PID_SECURITY = 2147483650;
pub const PF_DATAKIT = AF_DATAKIT;
pub const CAL_SMONTHDAY = 56;
pub const VK_EREOF = 249;
pub const CONSOLE_SELECTION_NOT_EMPTY = 2;
pub const WM_HANDHELDFIRST = 856;
pub const FILE_DEVICE_MOUSE = 15;
pub const ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY = @as(c_long, 14104);
pub const CRYPT_STRING_PERCENTESCAPE = 134217728;
pub const APPCOMMAND_SPELL_CHECK = 42;
pub const EVENT_OBJECT_DRAGCANCEL = 32802;
pub const LOCALE_S2359 = LOCALE_SPM;
pub const CDS_ENABLE_UNSAFE_MODES = 256;
pub const BCRYPT_HMAC_SHA1_ALG_HANDLE = if (@typeId(@typeOf(161)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 161) else if (@typeId(@typeOf(161)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 161) else BCRYPT_ALG_HANDLE(161);
pub const ERROR_STATE_READ_SETTING_FAILED = @as(c_long, 15807);
pub const SECURITY_LOCAL_LOGON_RID = @as(c_long, 1);
pub const URL_OID_GET_OBJECT_URL_FUNC = "UrlDllGetObjectUrl";
pub const MARK_HANDLE_RETURN_PURGE_FAILURE = 1024;
pub const ERROR_FULLSCREEN_MODE = @as(c_long, 1007);
pub const ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN = @as(c_long, 13881);
pub const FILE_SKIP_SET_EVENT_ON_HANDLE = 2;
pub const MS_PPM_SOFTWARE_ALL = 1;
pub const EMR_CREATECOLORSPACE = 99;
pub const TIME_ZONE_ID_UNKNOWN = 0;
pub const CERT_FIND_EXISTING = CERT_COMPARE_EXISTING << CERT_COMPARE_SHIFT;
pub const ERROR_EXTRANEOUS_INFORMATION = @as(c_long, 677);
pub const SCARD_READERSTATE_W = SCARD_READERSTATEW;
pub const CRYPTNET_URL_CACHE_DEFAULT_FLUSH = 0;
pub const CERT_TRUST_HAS_CRL_VALIDITY_EXTENDED = 4096;
pub const EMR_SELECTCLIPPATH = 67;
pub const IO_REPARSE_TAG_WCI_TOMBSTONE = @as(c_long, 2684354591);
pub const CBF_SKIP_UNREGISTRATIONS = 1048576;
pub const IMAGE_SYM_DTYPE_ARRAY = 3;
pub const __UINTPTR_FMTX__ = "llX";
pub const RPC_PROTSEQ_HTTP = 4;
pub const szOID_CMC = "1.3.6.1.5.5.7.7";
pub const TWOSTOPBITS = 2;
pub const ERROR_LOG_CLIENT_ALREADY_REGISTERED = @as(c_long, 6636);
pub const _Create_lock_level_ = level;
pub const DialogBoxIndirect = DialogBoxIndirectA;
pub const CMSG_CMS_RECIPIENT_INFO_PARAM = 36;
pub const RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH = 16;
pub const REG_APP_HIVE_OPEN_READ_ONLY = REG_OPEN_READ_ONLY;
pub const PROCESSOR_ARCHITECTURE_INTEL = 0;
pub const APPCOMMAND_BROWSER_STOP = 4;
pub const CERT_INFO_SERIAL_NUMBER_FLAG = 2;
pub const DMPAPER_PENV_8_ROTATED = 116;
pub const EMR_MODIFYWORLDTRANSFORM = 36;
pub const ABM_REMOVE = 1;
pub const MDM_SHIFT_V120_SPEED = 0;
pub const RPC_S_UNKNOWN_AUTHZ_SERVICE = @as(c_long, 1750);
pub const CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG = 2;
pub const s_imp = S_un.S_un_w.s_w2;
pub const SUBLANG_FRENCH_CANADIAN = 3;
pub const ERROR_THREAD_1_INACTIVE = @as(c_long, 210);
pub const DMPAPER_ENV_B4 = 33;
pub const ERROR_CLUSTER_TOKEN_DELEGATION_NOT_SUPPORTED = @as(c_long, 5988);
pub const RPC_S_ENTRY_TYPE_MISMATCH = @as(c_long, 1922);
pub const ERROR_UNKNOWN_PATCH = @as(c_long, 1647);
pub const szOID_ENROLL_KSP_NAME = "1.3.6.1.4.1.311.21.25";
pub const EDOM = 33;
pub const PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_RESERVED = 3 << 24;
pub const IMAGE_REL_AMD64_SREL32 = 14;
pub const DCX_CLIPSIBLINGS = @as(c_long, 16);
pub const ERROR_INSTALL_LOG_FAILURE = @as(c_long, 1622);
pub const LBS_NOSEL = @as(c_long, 16384);
pub const SUBLANG_YORUBA_NIGERIA = 1;
pub const IMAGE_DEBUG_TYPE_VC_FEATURE = 12;
pub const TIME_ONESHOT = 0;
pub const CERT_CHAIN_OPTION_DISABLE_AIA_URL_RETRIEVAL = 2;
pub const RPC_S_FP_UNDERFLOW = @as(c_long, 1770);
pub const WM_QUIT = 18;
pub const GC_PRESSANDTAP = 1;
pub const WNNC_NET_FJ_REDIR = 2228224;
pub const HANGEUL_CHARSET = 129;
pub const SPI_GETWAITTOKILLSERVICETIMEOUT = 124;
pub const NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR = 1;
pub const DeletePrinterKey = DeletePrinterKeyA;
pub const URLACTION_HTML_FONT_DOWNLOAD = 5636;
pub const MMIOM_READ = MMIO_READ;
pub const WINDEVQUERYAPI = DECLSPEC_IMPORT;
pub const IDANI_CAPTION = 3;
pub const CERT_FRIENDLY_NAME_PROP_ID = 11;
pub const VarUintFromCy = VarUI4FromCy;
pub const IMAGE_REL_ARM64_ADDR32NB = 2;
pub const PP_KEYSPEC = 39;
pub const PP_ENUMMANDROOTS = 25;
pub const CTRY_PRCHINA = 86;
pub const RESOURCE_CONTEXT = 5;
pub const MEDIA_READ_WRITE = 8;
pub const FILE_CACHE_MIN_HARD_ENABLE = 4;
pub const SUBLANG_YI_PRC = 1;
pub const DEVICE_DATA_SET_LB_PROVISIONING_STATE_VERSION_V2 = DEVICE_DSM_ALLOCATION_OUTPUT_V2;
pub const IS_TEXT_UNICODE_ILLEGAL_CHARS = 256;
pub const ERROR_IPSEC_IKE_NOTCBPRIV = @as(c_long, 13851);
pub const SHGSI_LARGEICON = SHGFI_LARGEICON;
pub const EMR_RESTOREDC = 34;
pub const GR_GDIOBJECTS_PEAK = 2;
pub const IP_MULTICAST_TTL = 3;
pub const WSANO_ADDRESS = WSANO_DATA;
pub const FACILITY_DEPLOYMENT_SERVICES_CONTENT_PROVIDER = 293;
pub const CERT_COMPARE_ANY = 0;
pub const TOKEN_IMPERSONATE = 4;
pub const CAL_GREGORIAN = 1;
pub const MFT_RIGHTORDER = @as(c_long, 8192);
pub const IsDialogMessage = IsDialogMessageA;
pub const LR_VGACOLOR = 128;
pub const CS_ENABLE = @as(c_long, 1);
pub const PSD_DEFAULTMINMARGINS = 0;
pub const CREATE_EVENT_INITIAL_SET = 2;
pub const WN_RETRY = ERROR_RETRY;
pub const TARGET_IS_NT50_OR_LATER = 1;
pub const RPC_C_AUTHN_MSN = 18;
pub const BASE_SEARCH_PATH_PERMANENT = 32768;
pub const SERVICE_CONTROL_HARDWAREPROFILECHANGE = 12;
pub const SHTDN_REASON_MAJOR_POWER = 393216;
pub const SUPPORT_LANG_NUMBER = 32;
pub const FADF_UNKNOWN = 512;
pub const GetPrivateProfileInt = GetPrivateProfileIntA;
pub const FindNextVolume = FindNextVolumeA;
pub const VarUI4FromInt = VarUI4FromI4;
pub const PAN_LETT_NORMAL_ROUNDED = 6;
pub const ERROR_SXS_XML_E_DUPLICATEATTRIBUTE = @as(c_long, 14053);
pub const CMC_FAIL_TRY_LATER = 12;
pub const REG_IMMUTABLE = @as(c_long, 16384);
pub const STATE_SYSTEM_VALID = 1073741823;
pub const SERVICE_NOTIFY_START_PENDING = 2;
pub const DMPAPER_LAST = DMPAPER_PENV_10_ROTATED;
pub const DEVICEFAMILYDEVICEFORM_MAKER_BOARD = 21;
pub const STATE_SYSTEM_MARQUEED = 8192;
pub const CRYPT_ENCRYPT_ALG_OID_GROUP_ID = 2;
pub const CS_OWNDC = 32;
pub const PIDSI_CHARCOUNT = @as(c_long, 16);
pub const CERT_NAME_EMAIL_TYPE = 1;
pub const ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR = @as(c_long, 790);
pub const EVENT_OBJECT_IME_CHANGE = 32809;
pub const MEVT_COMMENT = if (@typeId(@typeOf(130)) == @import("builtin").TypeId.Pointer) @ptrCast(BYTE, 130) else if (@typeId(@typeOf(130)) == @import("builtin").TypeId.Int) @intToPtr(BYTE, 130) else BYTE(130);
pub const szOID_PKCS_9_MESSAGE_DIGEST = "1.2.840.113549.1.9.4";
pub const OLEIVERB_UIACTIVATE = -@as(c_long, 4);
pub const KDF_SECRET_PREPEND = 1;
pub const LANG_DARI = 140;
pub const IMAGE_GUARD_CF_INSTRUMENTED = 256;
pub const IMAGE_REL_ARM64_SECREL_LOW12L = 11;
pub const ERROR_DS_CANT_MOVE_ACCOUNT_GROUP = @as(c_long, 8498);
pub const LOCALE_IDAYLZERO = 38;
pub const VK_LMENU = 164;
pub const APPCOMMAND_HELP = 27;
pub const INPUT_HARDWARE = 2;
pub const JOB_CONTROL_RESTART = 4;
pub const CCERR_CHOOSECOLORCODES = 20480;
pub const rpc_binding_vector_t = RPC_BINDING_VECTOR;
pub const CTL_FIND_USAGE = 3;
pub const FILE_DEVICE_DFS_FILE_SYSTEM = 53;
pub const FILE_DEVICE_DISK = 7;
pub const ERROR_LOG_METADATA_INVALID = @as(c_long, 6613);
pub const sz_CERT_STORE_PROV_LDAP = sz_CERT_STORE_PROV_LDAP_W;
pub const RegSetValueEx = RegSetValueExA;
pub const ERROR_INSTALL_PLATFORM_UNSUPPORTED = @as(c_long, 1633);
pub const CURVECAPS = 28;
pub const CERT_STORE_UNSAFE_PHYSICAL_FLAG = 32;
pub const CMSG_ENCODING_TYPE_MASK = 4294901760;
pub const SPI_GETFONTSMOOTHING = 74;
pub const __INT_FAST8_MAX__ = 127;
pub const MOD_IGNORE_ALL_MODIFIER = 1024;
pub const CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG = 4;
pub const CB_GETCURSEL = 327;
pub const VERTSIZE = 6;
pub const MDMSPKR_ON = 2;
pub const VARIANT_ALPHABOOL = 2;
pub const ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND = @as(c_long, 13009);
pub const NIF_TIP = 4;
pub const DD_DEFSCROLLDELAY = 50;
pub const TXFS_RM_STATE_STARTING = 1;
pub const SECURITY_CAPABILITY_VIDEOS_LIBRARY = @as(c_long, 5);
pub const RPC_S_SYSTEM_HANDLE_TYPE_MISMATCH = @as(c_long, 1836);
pub const ExtractIconEx = ExtractIconExA;
pub const FACILITY_WINDOWS = 8;
pub const SCHED_E_SERVICE_NOT_LOCALSYSTEM = @as(c_long, 6200);
pub const SERVER_ACCESS_ENUMERATE = 2;
pub const TC_VA_ABLE = 16384;
pub const NCRYPT_ALLOW_SIGNING_FLAG = 2;
pub const PIDDSI_MANAGER = 14;
pub const IMAGE_SCN_SCALE_INDEX = 1;
pub const TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CERT = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 4) else LPCSTR(4);
pub const ERROR_IPSEC_MM_FILTER_EXISTS = @as(c_long, 13006);
pub const SECURITY_AUTHENTICATION_AUTHORITY_RID_COUNT = @as(c_long, 1);
pub const DC_BINNAMES = 12;
pub const BS_CHECKBOX = @as(c_long, 2);
pub const ENOMSG = 122;
pub const SO_CONNOPT = 28673;
pub const IMAGE_REL_MIPS_JMPADDR16 = 16;
pub const WVR_ALIGNLEFT = 32;
pub const BCRYPT_HMAC_SHA256_ALG_HANDLE = if (@typeId(@typeOf(177)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 177) else if (@typeId(@typeOf(177)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 177) else BCRYPT_ALG_HANDLE(177);
pub const ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK = @as(c_long, 5927);
pub const RpcNsGroupMbrRemove = RpcNsGroupMbrRemoveA;
pub const SCERR_NOCARDNAME = 16384;
pub const OUT_CHARACTER_PRECIS = 2;
pub const BCRYPT_3DES_CBC_ALG_HANDLE = if (@typeId(@typeOf(321)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 321) else if (@typeId(@typeOf(321)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 321) else BCRYPT_ALG_HANDLE(321);
pub const CERT_SELECT_HAS_PRIVATE_KEY = 8;
pub const MOUSEEVENTF_MOVE_NOCOALESCE = 8192;
pub const RegOpenKey = RegOpenKeyA;
pub const EMR_CHORD = 46;
pub const RTL_CORRELATION_VECTOR_V2_PREFIX_LENGTH = 22;
pub const CRYPT_PROCESS_ISOLATE = 65536;
pub const NCRYPT_PCP_SIGNATURE_KEY = 1;
pub const REG_OPTION_BACKUP_RESTORE = @as(c_long, 4);
pub const InterlockedCompareExchange128 = _InterlockedCompareExchange128;
pub const DMMEDIA_GLOSSY = 3;
pub const CERT_ROOT_PROGRAM_CHAIN_POLICIES_PROP_ID = 105;
pub const _PROPSHEETPAGEW_V4 = _PROPSHEETPAGEW;
pub const _CRT_HAS_CXX17 = 0;
pub const EVENT_SYSTEM_SCROLLINGEND = 19;
pub const __elem_readableTo = size;
pub const DMPAPER_PENV_7 = 102;
pub const RESOURCETYPE_PRINT = 2;
pub const SUBLANG_BASHKIR_RUSSIA = 1;
pub const COPY_FILE_IGNORE_SOURCE_ENCRYPTION = 8388608;
pub const ERROR_IPSEC_IKE_POLICY_CHANGE = @as(c_long, 13849);
pub const NCRYPTBUFFER_ECC_CURVE_NAME = 60;
pub const ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER = @as(c_long, 8584);
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_BUTTON = 210;
pub const CreateProcess = CreateProcessA;
pub const CC_ROUNDRECT = 256;
pub const ERROR_DS_MUST_BE_RUN_ON_DST_DC = @as(c_long, 8558);
pub const CTMF_INCLUDE_LPAC = @as(c_ulong, 2);
pub const ERROR_EFS_ALG_BLOB_TOO_BIG = @as(c_long, 6013);
pub const MFT_SEPARATOR = MF_SEPARATOR;
pub const ERROR_PATCH_REMOVAL_DISALLOWED = @as(c_long, 1649);
pub const IMAGE_COMDAT_SELECT_NEWEST = 7;
pub const THREAD_SUSPEND_RESUME = 2;
pub const INPLACE_S_FIRST = @as(c_long, 262560);
pub const ERROR_SUCCESS_REBOOT_INITIATED = @as(c_long, 1641);
pub const PF_ARM_NEON_INSTRUCTIONS_AVAILABLE = 19;
pub const MUI_USE_SEARCH_ALL_LANGUAGES = 64;
pub const PP_DISMISS_PIN_UI_SEC = 49;
pub const SHTDN_REASON_MAJOR_LEGACY_API = 458752;
pub const LANG_INDONESIAN = 33;
pub const szOID_TELETEXT_TERMINAL_IDENTIFIER = "2.5.4.22";
pub const PKCS_RSA_PRIVATE_KEY = if (@typeId(@typeOf(43)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 43) else if (@typeId(@typeOf(43)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 43) else LPCSTR(43);
pub const Uri_ENCODING_HOST_IS_IDN = 4;
pub const GetPrivateProfileSectionNames = GetPrivateProfileSectionNamesA;
pub const GETEXTENTTABLE = 257;
pub const FORM_USER = 0;
pub const JOYSTICKID2 = 1;
pub const ERROR_DS_SYNTAX_MISMATCH = @as(c_long, 8384);
pub const RPC_X_NULL_REF_POINTER = @as(c_long, 1780);
pub const WT_EXECUTEINLONGTHREAD = 16;
pub const ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME = @as(c_long, 5905);
pub const BS_NOTIFY = @as(c_long, 16384);
pub const SHTDN_REASON_MINOR_SECURITY = 19;
pub const CERT_TRUST_AUTO_UPDATE_CA_REVOCATION = 16;
pub const ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE = @as(c_long, 6020);
pub const SCARD_ATR_LENGTH = 33;
pub const NCRYPT_EXPORTED_ISOLATED_KEY_HEADER_V0 = 0;
pub const CONNDLG_USE_MRU = 4;
pub const PRODUCT_HOME_PREMIUM_E = 68;
pub const DEVICEFAMILYINFOENUM_DESKTOP = 3;
pub const LANG_DANISH = 6;
pub const REQUEST_OPLOCK_INPUT_FLAG_ACK = 2;
pub const ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC = @as(c_long, 8604);
pub const INPLACE_E_LAST = @as(c_long, 2147746223);
pub const DISPLAYCONFIG_PATH_DESKTOP_IMAGE_IDX_INVALID = 65535;
pub const szOID_POLICY_CONSTRAINTS = "2.5.29.36";
pub const WIZ_CXDLG = 276;
pub const EV_RXCHAR = 1;
pub const ISC_SHOWUIALLCANDIDATEWINDOW = 15;
pub const RPC_C_HTTP_AUTHN_SCHEME_NTLM = 2;
pub const DMPAPER_A_PLUS = 57;
pub const szOID_EMBEDDED_NT_CRYPTO = "1.3.6.1.4.1.311.10.3.8";
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_LEARNING_RATE = 0.001000;
pub const szOID_ANSI_X942_DH = "1.2.840.10046.2.1";
pub const CMSG_SIGNER_HASH_ALGORITHM_PARAM = 8;
pub const LOCALE_IFIRSTWEEKOFYEAR = 4109;
pub const InterlockedExchange16 = _InterlockedExchange16;
pub const X3_BTYPE_QP_SIZE_X = 9;
pub const VerifyVersionInfo = VerifyVersionInfoA;
pub const CERT_SELECT_BY_ISSUER_ATTR = 7;
pub const WINAPI_FAMILY_PHONE_APP = 3;
pub const STGM_NOSCRATCH = @as(c_long, 1048576);
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_FQBN = 4;
pub const SD_GLOBAL_CHANGE_TYPE_MACHINE_SID = 1;
pub const INVALID_FILE_SIZE = if (@typeId(@typeOf(4294967295)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 4294967295) else if (@typeId(@typeOf(4294967295)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 4294967295) else DWORD(4294967295);
pub const LC_POLYMARKER = 8;
pub const SERVICE_CONTROL_TRIGGEREVENT = 32;
pub const ERROR_CANTOPEN = @as(c_long, 1011);
pub const RPC_C_HTTP_FLAG_USE_FIRST_AUTH_SCHEME = 2;
pub const FF_DONTCARE = 0 << 4;
pub const LLKHF_LOWER_IL_INJECTED = 2;
pub const ERROR_DS_CANT_RETRIEVE_ATTS = @as(c_long, 8481);
pub const PF_NX_ENABLED = 12;
pub const PROCESS_CREATION_MITIGATION_POLICY2_MODULE_TAMPERING_PROTECTION_MASK = if (@typeId(@typeOf(i64 << 12)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 12) else if (@typeId(@typeOf(i64 << 12)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 12) else @as(c_uint, 3)(i64 << 12);
pub const OPENCARDNAME_W = OPENCARDNAMEW;
pub const VK_ICO_HELP = 227;
pub const ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION = 6;
pub const WIM_DATA = MM_WIM_DATA;
pub const PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_NO_LOW_LABEL_ALWAYS_OFF = if (@typeId(@typeOf(i64 << 56)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 2), i64 << 56) else if (@typeId(@typeOf(i64 << 56)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 2), i64 << 56) else @as(c_uint, 2)(i64 << 56);
pub const PF_ARM_EXTERNAL_CACHE_AVAILABLE = 26;
pub const NCRYPT_KEY_DERIVATION_OPERATION = BCRYPT_KEY_DERIVATION_OPERATION;
pub const NUM_DISCHARGE_POLICIES = 4;
pub const READ_THREAD_PROFILING_FLAG_HARDWARE_COUNTERS = 2;
pub const WS_GROUP = @as(c_long, 131072);
pub const CTLCOLOR_EDIT = 1;
pub const ACCESS_ALLOWED_OBJECT_ACE_TYPE = 5;
pub const PAN_SERIF_BONE = 8;
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_PUBKEY = 1;
pub const EM_SETWORDBREAKPROC = 208;
pub const SUBLANG_CHINESE_SIMPLIFIED = 2;
pub const BCRYPT_ECDSA_PRIVATE_GENERIC_MAGIC = 1447314245;
pub const COMPLEXREGION = 3;
pub const NULL_BRUSH = 5;
pub const MB_USERICON = @as(c_long, 128);
pub const __INT8_MAX__ = 127;
pub const SETLINEJOIN = 22;
pub const ERROR_SYNCHRONIZATION_REQUIRED = @as(c_long, 569);
pub const CERT_STORE_PROV_FILENAME = CERT_STORE_PROV_FILENAME_W;
pub const IMAGE_DLLCHARACTERISTICS_GUARD_CF = 16384;
pub const szOID_ROOT_PROGRAM_FLAGS = "1.3.6.1.4.1.311.60.1.1";
pub const DIAGNOSTIC_REASON_NOT_SPECIFIED = 2147483648;
pub const LOCALE_SISO3166CTRYNAME = 90;
pub const FALSE = 0;
pub const DMPAPER_ENV_B6 = 35;
pub const EVENT_SYSTEM_MENUPOPUPEND = 7;
pub const MCI_OPEN_ELEMENT = @as(c_long, 512);
pub const ERROR_INVALID_TIME = @as(c_long, 1901);
pub const ERROR_PROCESS_IN_JOB = @as(c_long, 760);
pub const ERROR_INTERNAL_DB_CORRUPTION = @as(c_long, 1358);
pub const USN_REASON_FILE_CREATE = 256;
pub const CONNECT_DEFERRED = 1024;
pub const ERROR_HOST_DOWN = @as(c_long, 1256);
pub const szOID_EV_RDN_COUNTRY = "1.3.6.1.4.1.311.60.2.1.3";
pub const CERT_SELECT_MAX_PARA = 500;
pub const TAPE_SPACE_SEQUENTIAL_SMKS = @as(c_long, 9);
pub const __pic__ = 2;
pub const APPCOMMAND_MEDIA_CHANNEL_DOWN = 52;
pub const __LDBL_DENORM_MIN__ = 0.000000;
pub const HELP_INDEX = @as(c_long, 3);
pub const MIXERCONTROL_CT_CLASS_CUSTOM = @as(c_long, 0);
pub const ERROR_STORAGE_RESERVE_NOT_EMPTY = @as(c_long, 419);
pub const DMPAPER_PENV_6 = 101;
pub const TC_IA_ABLE = 1024;
pub const NRC_GOODRET = 0;
pub const CP_REGION = 2;
pub const NTDDI_VISTASP4 = NTDDI_WIN6SP4;
pub const KF_ALTDOWN = 8192;
pub const ERROR_BIDI_STATUS_OK = 0;
pub const frm1 = 1076;
pub const TAPE_ERASE_LONG = @as(c_long, 1);
pub const WM_SETFONT = 48;
pub const URLPOLICY_QUERY = 1;
pub const WN_BAD_LEVEL = ERROR_INVALID_LEVEL;
pub const FILE_MAP_EXECUTE = SECTION_MAP_EXECUTE_EXPLICIT;
pub const PRINTER_ATTRIBUTE_DIRECT = 2;
pub const __ATOMIC_ACQUIRE = 2;
pub const ERROR_COMPRESSION_DISABLED = @as(c_long, 769);
pub const CMSG_MAIL_LIST_RECIPIENT = 3;
pub const MUTZ_ENFORCERESTRICTED = 256;
pub const CBF_FAIL_EXECUTES = 32768;
pub const HTOBJECT = 19;
pub const TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN = 2;
pub const stc9 = 1096;
pub const PORT_STATUS_TYPE_INFO = 3;
pub const JOB_CONTROL_RELEASE = 9;
pub const WM_HSCROLLCLIPBOARD = 782;
pub const HS_FDIAGONAL = 2;
pub const ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE = @as(c_long, 781);
pub const szOID_CMC_RESPONSE_INFO = "1.3.6.1.5.5.7.7.19";
pub const FILE_DEVICE_8042_PORT = 39;
pub const __x86_64 = 1;
pub const R2_MASKPENNOT = 5;
pub const ERROR_CLUSCFG_ALREADY_COMMITTED = @as(c_long, 5901);
pub const ACCESS_FILTER_SECURITY_INFORMATION = @as(c_long, 256);
pub const STORAGE_OFFLOAD_TOKEN_ID_LENGTH = 504;
pub const IN_CLASSA_NSHIFT = 24;
pub const KEY_WOW64_RES = 768;
pub const ERROR_APPEXEC_INVALID_HOST_GENERATION = @as(c_long, 3062);
pub const ERROR_PACKAGE_MOVE_BLOCKED_BY_STREAMING = @as(c_long, 15636);
pub const szOID_CT_PKI_RESPONSE = "1.3.6.1.5.5.7.12.3";
pub const META_BITBLT = 2338;
pub const VarCyFromInt = VarCyFromI4;
pub const SPI_SETKEYBOARDDELAY = 23;
pub const CRYPT_OID_INFO_OID_KEY_FLAGS_MASK = 4294901760;
pub const PEN_FLAG_ERASER = 4;
pub const BF_BOTTOM = 8;
pub const CAL_GREGORIAN_XLIT_ENGLISH = 11;
pub const PARTITION_FAT32_XINT13 = 12;
pub const FILE_DEVICE_UCM = 87;
pub const ERROR_IPSEC_IKE_POLICY_MATCH = @as(c_long, 13868);
pub const FILE_INITIATE_REPAIR_HINT1_RECURSIVELY_CORRUPTED = 256;
pub const CB_SETITEMHEIGHT = 339;
pub const BCRYPT_BLOCK_PADDING = 1;
pub const ERROR_INVALID_IMPORT_OF_NON_DLL = @as(c_long, 1276);
pub const szOID_NETSCAPE_CA_REVOCATION_URL = "2.16.840.1.113730.1.4";
pub const FILE_PREFETCH_TYPE_FOR_DIRENUM = 2;
pub const PERF_NUMBER_DECIMAL = 65536;
pub const VK_LEFT = 37;
pub const __SGX__ = 1;
pub const HANGUL_CHARSET = 129;
pub const ERROR_SXS_XML_E_MULTIPLEROOTS = @as(c_long, 14054);
pub const ERROR_OBJECT_IN_LIST = @as(c_long, 5011);
pub const DT_CHARSTREAM = 4;
pub const DNS_ERROR_SOA_DELETE_INVALID = @as(c_long, 9618);
pub const POWER_PLATFORM_ROLE_V1 = 1;
pub const CERT_LOGOTYPE_GRAY_SCALE_IMAGE_INFO_CHOICE = 1;
pub const ERROR_INSTALL_PACKAGE_NOT_FOUND = @as(c_long, 15601);
pub const NO_PRIORITY = 0;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN = @as(c_long, 372);
pub const SetWindowLongPtr = SetWindowLongPtrA;
pub const URLACTION_ALLOW_RENDER_LEGACY_DXTFILTERS = 9995;
pub const BACKUP_REPARSE_DATA = 8;
pub const ERROR_IS_JOIN_TARGET = @as(c_long, 133);
pub const GC_PAN_WITH_SINGLE_FINGER_VERTICALLY = 2;
pub const ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION = @as(c_long, 6850);
pub const EVENT_SYSTEM_SWITCHEND = 21;
pub const SPI_GETMOUSEKEYS = 54;
pub const URLPOLICY_CREDENTIALS_SILENT_LOGON_OK = 0;
pub const DISPLAY_DEVICE_DISCONNECT = 33554432;
pub const FACILITY_SHELL = 39;
pub const ERROR_WRONG_TARGET_NAME = @as(c_long, 1396);
pub const CRYPT_GET_URL_FROM_PROPERTY = 1;
pub const __clang_minor__ = 0;
pub const CreateEnhMetaFile = CreateEnhMetaFileA;
pub const URLACTION_SCRIPT_RUN = 5120;
pub const ERROR_CAPAUTHZ_NOT_PROVISIONED = @as(c_long, 452);
pub const QUOTA_LIMITS_HARDWS_MIN_ENABLE = 1;
pub const SSWF_WINDOW = 2;
pub const NCRYPT_UI_FINGERPRINT_PROTECTION_FLAG = 4;
pub const RPC_C_VERS_EXACT = 3;
pub const SCARD_STATE_IGNORE = 1;
pub const RegRestoreKey = RegRestoreKeyA;
pub const WS_MINIMIZEBOX = @as(c_long, 131072);
pub const szOID_KP_SMART_DISPLAY = "1.3.6.1.4.1.311.10.3.15";
pub const OLE_E_FIRST = if (@typeId(@typeOf(@as(c_long, 2147745792))) == @import("builtin").TypeId.Pointer) @ptrCast(HRESULT, @as(c_long, 2147745792)) else if (@typeId(@typeOf(@as(c_long, 2147745792))) == @import("builtin").TypeId.Int) @intToPtr(HRESULT, @as(c_long, 2147745792)) else HRESULT(@as(c_long, 2147745792));
pub const CTRY_UAE = 971;
pub const IME_CAND_UNKNOWN = 0;
pub const IME_SMODE_NONE = 0;
pub const WNetGetUniversalName = WNetGetUniversalNameA;
pub const ERROR_DS_SUBREF_MUST_HAVE_PARENT = @as(c_long, 8356);
pub const IS_TEXT_UNICODE_ASCII16 = 1;
pub const __deref_opt_out_bcount_nz_opt = size;
pub const SUBLANG_FRENCH_BELGIAN = 2;
pub const VER_SUITE_SECURITY_APPLIANCE = 4096;
pub const ERROR_COMMITMENT_MINIMUM = @as(c_long, 635);
pub const MCI_OPEN_SHAREABLE = @as(c_long, 256);
pub const POWERBUTTON_ACTION_INDEX_HIBERNATE = 2;
pub const SYSTEM_AUDIT_OBJECT_ACE_TYPE = 7;
pub const KP_BLOCKLEN = 8;
pub const MA_NOACTIVATE = 3;
pub const ALG_TYPE_ECDH = 7 << 9;
pub const SB_THUMBPOSITION = 4;
pub const PRINTER_DRIVER_CATEGORY_CLOUD = 8192;
pub const ERROR_TRANSACTION_FREEZE_IN_PROGRESS = @as(c_long, 6840);
pub const IMAGE_DIRECTORY_ENTRY_RESOURCE = 2;
pub const MAXIMUM_PROC_PER_GROUP = 64;
pub const WDT_INPROC64_CALL = 1349805143;
pub const MCI_SET_TIME_FORMAT = @as(c_long, 1024);
pub const MEM_RESET = 524288;
pub const CF_SHOWHELP = @as(c_long, 4);
pub const S_SERDLN = -6;
pub const ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER = @as(c_long, 8578);
pub const WM_CAPTURECHANGED = 533;
pub const DMPAPER_PENV_5 = 100;
pub const SE_ERR_ACCESSDENIED = 5;
pub const CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY = 2147483648;
pub const NTDDI_WS08 = NTDDI_WIN6SP1;
pub const __RETURN_POLICY_VOID = _FunctionCall;
pub const frm2 = 1077;
pub const SPI_SETPENARBITRATIONTYPE = 8225;
pub const CERT_SMART_CARD_ROOT_INFO_PROP_ID = 76;
pub const HP_HASHVAL = 2;
pub const CREATE_ALWAYS = 2;
pub const __acquires_shared_lock = lock;
pub const DEVICE_DATA_SET_LB_PROVISIONING_STATE_VERSION_V1 = DEVICE_DSM_ALLOCATION_OUTPUT_V1;
pub const WINSPOOLAPI = DECLSPEC_IMPORT;
pub const VarR4FromInt = VarR4FromI4;
pub const ERROR_MRM_MISSING_DEFAULT_LANGUAGE = @as(c_long, 15160);
pub const EM_LIMITTEXT = 197;
pub const EVENT_OBJECT_DEFACTIONCHANGE = 32785;
pub const CONNECT_PROMPT = 16;
pub const __INT_LEAST64_FMTi__ = "lli";
pub const SPI_GETSTICKYKEYS = 58;
pub const ERROR_TM_VOLATILE = @as(c_long, 6828);
pub const ABM_WINDOWPOSCHANGED = 9;
pub const ERROR_DS_REFERRAL_LIMIT_EXCEEDED = @as(c_long, 8260);
pub const RpcServerUseProtseqEx = RpcServerUseProtseqExA;
pub const FACILITY_WINML = 2192;
pub const stc8 = 1095;
pub const szOID_RSA_SSA_PSS = "1.2.840.113549.1.1.10";
pub const WNNC_NET_NDFS = 4456448;
pub const szOID_LOCAL_MACHINE_KEYSET = "1.3.6.1.4.1.311.17.2";
pub const __FLT16_MANT_DIG__ = 11;
pub const VAR_CALENDAR_HIJRI = if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 8) else if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 8) else DWORD(8);
pub const TXFS_SAVEPOINT_SET = 1;
pub const MIDI_MAPPER = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(UINT, -1) else UINT(-1);
pub const OBJ_PEN = 1;
pub const SO_SNDLOWAT = 4099;
pub const s_addr = S_un.S_addr;
pub const FAST_FAIL_CRYPTO_LIBRARY = 22;
pub const szOID_CMC_SENDER_NONCE = "1.3.6.1.5.5.7.7.6";
pub const PAN_PROP_OLD_STYLE = 2;
pub const CERT_NAME_STR_SEMICOLON_FLAG = 1073741824;
pub const ODA_FOCUS = 4;
pub const PC_INTERIORS = 128;
pub const PP_CHANGE_PASSWORD = 7;
pub const WVR_ALIGNRIGHT = 128;
pub const APPCMD_FILTERINITS = @as(c_long, 32);
pub const LONG_MAX = @as(c_long, 2147483647);
pub const MH_CREATE = 1;
pub const VP_MODE_TV_PLAYBACK = 2;
pub const IGIMII_SMODE = 2;
pub const ERROR_MRM_FILEPATH_TOO_LONG = @as(c_long, 15121);
pub const IMAGE_SYM_TYPE_INT = 4;
pub const IMAGE_REL_CEE_SECREL = 5;
pub const IMM_ERROR_NODATA = -1;
pub const PPM_FIRMWARE_TSS = 2048;
pub const ERROR_DOMAIN_CONTROLLER_NOT_FOUND = @as(c_long, 1908);
pub const ERROR_INVALID_MONITOR_HANDLE = @as(c_long, 1461);
pub const PROCESS_CREATION_MITIGATION_POLICY2_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY_ALWAYS_ON = if (@typeId(@typeOf(i64 << 20)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << 20) else if (@typeId(@typeOf(i64 << 20)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << 20) else @as(c_uint, 1)(i64 << 20);
pub const MCI_OVLY_WINDOW_ENABLE_STRETCH = @as(c_long, 1048576);
pub const IGP_CONVERSION = 8;
pub const DC_MANUFACTURER = 23;
pub const LB_GETITEMHEIGHT = 417;
pub const URLACTION_ALLOW_CROSSDOMAIN_DROP_WITHIN_WINDOW = 9992;
pub const MCI_OPEN = 2051;
pub const PME_FAILFAST_ON_COMMIT_FAIL_DISABLE = 0;
pub const __UINT32_FMTx__ = "x";
pub const NI_CLOSECANDIDATE = 17;
pub const ERROR_SECUREBOOT_FILE_REPLACED = @as(c_long, 4426);
pub const TT_OPENTYPE_FONTTYPE = 131072;
pub const _WIN32_WINNT_WINTHRESHOLD = 2560;
pub const PDERR_NODEFAULTPRN = 4104;
pub const MIM_APPLYTOSUBMENUS = 2147483648;
pub const CERT_CHAIN_AUTO_CURRENT_USER = 1;
pub const SetWindowsHookEx = SetWindowsHookExA;
pub const HCBT_QS = 2;
pub const LOCALE_SNATIVELANGUAGENAME = 4;
pub const AddForm = AddFormA;
pub const POWER_PLATFORM_ROLE_V2 = 2;
pub const DFCS_SCROLLLEFT = 2;
pub const ERROR_FILE_NOT_ENCRYPTED = @as(c_long, 6007);
pub const DISPLAY_DEVICE_ATTACHED_TO_DESKTOP = 1;
pub const MCI_SEQ_FILE = 16386;
pub const UIS_SET = 1;
pub const ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_LOAD_UNLOAD_PRI_FILE = @as(c_long, 15142);
pub const SECURITY_NFS_ID_BASE_RID = @as(c_long, 88);
pub const CHANGER_STORAGE_TRANSPORT = 32768;
pub const CRYPT_DECODE_ALLOC_FLAG = 32768;
pub const CB_SETTOPINDEX = 348;
pub const ERROR_NO_MORE_FILES = @as(c_long, 18);
pub const ERROR_OBJECT_ALREADY_EXISTS = @as(c_long, 5010);
pub const CTRY_PHILIPPINES = 63;
pub const SPI_SETANIMATION = 73;
pub const CERT_AUTH_ROOT_SHA256_HASH_PROP_ID = 98;
pub const SM_CXPADDEDBORDER = 92;
pub const SUBLANG_ARABIC_EGYPT = 3;
pub const POINTER_MOD_CTRL = 8;
pub const LANG_ASSAMESE = 77;
pub const CERT_NAME_STR_ENABLE_T61_UNICODE_FLAG = 131072;
pub const ERROR_INVALID_FILTER_PROC = @as(c_long, 1427);
pub const MB_COMPOSITE = 2;
pub const ERROR_SERVICE_SPECIFIC_ERROR = @as(c_long, 1066);
pub const LANG_LOWER_SORBIAN = 46;
pub const IMAGE_SYM_CLASS_TYPE_DEFINITION = 13;
pub const VOS_OS216_PM16 = @as(c_long, 131074);
pub const SCREEN_FONTTYPE = 8192;
pub const DEPRECATED = x;
pub const COM_RIGHTS_ACTIVATE_LOCAL = 8;
pub const IOC_VOID = 536870912;
pub const MCI_SEQ_STATUS_PORT = @as(c_long, 16387);
pub const TIME_CALLBACK_FUNCTION = 0;
pub const szOID_ENROLL_SCEP_CLIENT_REQUEST = "1.3.6.1.4.1.311.21.37";
pub const CERT_SELECT_HAS_KEY_FOR_KEY_EXCHANGE = 32;
pub const DM_COLOR = @as(c_long, 2048);
pub const PRPC_HTTP_TRANSPORT_CREDENTIALS = PRPC_HTTP_TRANSPORT_CREDENTIALS_A;
pub const AF_VOICEVIEW = 18;
pub const PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_DEFER = 0 << 8;
pub const ERROR_BOOT_ALREADY_ACCEPTED = @as(c_long, 1076);
pub const DRV_LOAD = 1;
pub const DEVICEFAMILYDEVICEFORM_LARGESCREEN = 10;
pub const OPEN_ALWAYS = 4;
pub const ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY = @as(c_long, 217);
pub const ICM_OFF = 1;
pub const VarBoolFromUint = VarBoolFromUI4;
pub const IMAGE_ENCLAVE_POLICY_DEBUGGABLE = 1;
pub const CERT_TRUST_SSL_RECONNECT_OCSP = 1048576;
pub const DMPAPER_PENV_4 = 99;
pub const __in_ecount_nz_opt = size;
pub const GetFileVersionInfoEx = GetFileVersionInfoExA;
pub const RRF_RT_REG_NONE = 1;
pub const GW_HWNDLAST = 1;
pub const frm3 = 1078;
pub const LOCALE_STIME = 30;
pub const DS_NOIDLEMSG = @as(c_long, 256);
pub const WNNC_NET_APPLETALK = 1245184;
pub const SKF_LSHIFTLATCHED = 16777216;
pub const ACCESS_REASON_DATA_MASK = 65535;
pub const MULTIFILEOPENORD = 1537;
pub const SPI_SETFONTSMOOTHINGTYPE = 8203;
pub const ERROR_LOGON_SESSION_COLLISION = @as(c_long, 1366);
pub const IMAGE_REL_AM_FUNCINFO = 4;
pub const SPI_SETMOUSETRAILS = 93;
pub const DlgDirSelectComboBoxEx = DlgDirSelectComboBoxExA;
pub const szOID_DELTA_CRL_INDICATOR = "2.5.29.27";
pub const FMFD_DEFAULT = 0;
pub const FS_LATIN2 = @as(c_long, 2);
pub const ERROR_ENLISTMENT_NOT_FOUND = @as(c_long, 6717);
pub const DNS_ERROR_ZONESCOPE_ALREADY_EXISTS = @as(c_long, 9951);
pub const ERROR_TRANSACTION_PROPAGATION_FAILED = @as(c_long, 6711);
pub const __requires_lock_held = lock;
pub const CAL_SSHORTESTDAYNAME4 = 52;
pub const CMC_FAIL_BAD_MESSAGE_CHECK = 1;
pub const HIGH_SURROGATE_START = 55296;
pub const CREATE_THREAD_DEBUG_EVENT = 2;
pub const EWX_BOOTOPTIONS = 16777216;
pub const CTRY_ICELAND = 354;
pub const ERROR_DS_UNKNOWN_OPERATION = @as(c_long, 8365);
pub const ERROR_SXS_XML_E_UNCLOSEDCOMMENT = @as(c_long, 14063);
pub const PIDDSI_CATEGORY = 2;
pub const WM_NCRBUTTONDOWN = 164;
pub const LB_MSGMAX = 435;
pub const JOYSTICKID1 = 0;
pub const NINF_KEY = 1;
pub const ERROR_INVALID_MEMBER = @as(c_long, 1388);
pub const ERROR_DS_FOREST_VERSION_TOO_HIGH = @as(c_long, 8563);
pub const VERTRES = 10;
pub const WGL_SWAP_MAIN_PLANE = 1;
pub const szOID_PKCS_7_SIGNEDANDENVELOPED = "1.2.840.113549.1.7.4";
pub const KP_INFO = 18;
pub const _Requires_lock_held_ = lock;
pub const _CONTROL = 32;
pub const XSTATE_AVX512_ZMM_H = 6;
pub const VARIANT_USE_NLS = 128;
pub const DT_METAFILE = 5;
pub const VFT2_UNKNOWN = @as(c_long, 0);
pub const LR_COLOR = 2;
pub const DOMAIN_GROUP_RID_ENTERPRISE_READONLY_DOMAIN_CONTROLLERS = @as(c_long, 498);
pub const DNS_ERROR_RRL_LEAK_RATE_LESSTHAN_TC_RATE = @as(c_long, 9917);
pub const DEREGISTERED = 5;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_DENY_DEFRAG_SET = 2;
pub const THREAD_PRIORITY_NORMAL = 0;
pub const SECURITY_CCG_ID_BASE_RID = @as(c_long, 95);
pub const ERROR_TRANSACTION_MUST_WRITETHROUGH = @as(c_long, 6729);
pub const GetClassLongPtr = GetClassLongPtrA;
pub const FILE_PROVIDER_FLAG_COMPRESS_ON_WRITE = 1;
pub const szOID_RSA_RC4 = "1.2.840.113549.3.4";
pub const ERROR_CTX_GRAPHICS_INVALID = @as(c_long, 7035);
pub const USN_REASON_RENAME_NEW_NAME = 8192;
pub const EMR_POLYDRAW16 = 92;
pub const LOCALE_ITIMEMARKPOSN = 4101;
pub const WNNC_NET_PROTSTOR = 2162688;
pub const DNS_ERROR_RECORD_TIMED_OUT = @as(c_long, 9705);
pub const MNS_DRAGDROP = 536870912;
pub const ERROR_MRM_INVALID_PRICONFIG = @as(c_long, 15111);
pub const CERT_SELECT_BY_KEY_USAGE = 2;
pub const CRYPT_KEEP_TIME_VALID = 128;
pub const JOY_RETURNCENTERED = @as(c_long, 1024);
pub const PF_ISO = AF_ISO;
pub const ERROR_MAPPED_ALIGNMENT = @as(c_long, 1132);
pub const ENFILE = 23;
pub const VarCyFromUint = VarCyFromUI4;
pub const ERROR_SERVER_SID_MISMATCH = @as(c_long, 628);
pub const VTA_RIGHT = TA_TOP;
pub const FILE_CREATE_PIPE_INSTANCE = 4;
pub const QUOTA_LIMITS_USE_DEFAULT_LIMITS = 16;
pub const FILE_FLAG_WRITE_THROUGH = 2147483648;
pub const MCI_SET_AUDIO_LEFT = @as(c_long, 1);
pub const LANG_OCCITAN = 130;
pub const GR_USEROBJECTS = 1;
pub const PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_RESERVED = 3 << 16;
pub const WSAEPROTONOSUPPORT = @as(c_long, 10043);
pub const CRYPT_STRING_BASE64 = 1;
pub const HIGH_SURROGATE_END = 56319;
pub const ERROR_MRM_TOO_MANY_RESOURCES = @as(c_long, 15140);
pub const MDM_V110_SPEED_14DOT4K = 6;
pub const UPDP_CHECK_DRIVERSTORE = 4;
pub const ERROR_RECEIVE_PARTIAL_EXPEDITED = @as(c_long, 709);
pub const CERT_MD5_HASH_PROP_ID = 4;
pub const CMC_FAIL_BAD_ALG = 0;
pub const FILEOKSTRING = FILEOKSTRINGA;
pub const DT_BOTTOM = 8;
pub const szOID_REASON_CODE_HOLD = "2.5.29.23";
pub const ERROR_STATE_READ_COMPOSITE_SETTING_FAILED = @as(c_long, 15811);
pub const MEMORY_PRIORITY_NORMAL = 5;
pub const FILE_DEVICE_BEEP = 1;
pub const LOW_SURROGATE_START = 56320;
pub const __FLT_HAS_QUIET_NAN__ = 1;
pub const MB_TYPEMASK = @as(c_long, 15);
pub const EVENT_OBJECT_HELPCHANGE = 32784;
pub const SC_MOUSEMENU = 61584;
pub const BN_UNHILITE = 3;
pub const szOID_CT_PKI_DATA = "1.3.6.1.5.5.7.12.2";
pub const DLGC_BUTTON = 8192;
pub const ERROR_INVALID_PACKAGE_SID_LENGTH = @as(c_long, 4253);
pub const PRODUCT_WEB_SERVER = 17;
pub const IMAGE_REL_IA64_SECTION = 11;
pub const SE_SIGNING_LEVEL_WINDOWS_TCB = 14;
pub const MCI_FORMAT_HMS = 1;
pub const EVENT_OBJECT_HOSTEDOBJECTSINVALIDATED = 32800;
pub const GetConsoleAliasExes = GetConsoleAliasExesA;
pub const SMART_EXTENDED_SELFTEST_OFFLINE = 2;
pub const PRINTER_ENUM_REMOTE = 16;
pub const PFD_DRAW_TO_BITMAP = 8;
pub const PBT_APMPOWERSTATUSCHANGE = 10;
pub const MCI_DEVTYPE_FIRST_USER = 4096;
pub const PeekConsoleInput = PeekConsoleInputA;
pub const SECURITY_LOCAL_SERVICE_RID = @as(c_long, 19);
pub const FEATURESETTING_OUTPUT = 1;
pub const PST_RS422 = if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 3) else if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 3) else DWORD(3);
pub const WINAPI_FAMILY_GAMES = 6;
pub const CTRY_UKRAINE = 380;
pub const PP_SIGNATURE_KEYSIZE = 13;
pub const TC_PUBLIC_DATA_TYPE_ATAGP = "ATAGPLogPages";
pub const CERT_TRUST_IS_NOT_TIME_VALID = 1;
pub const SEF_AVOID_PRIVILEGE_CHECK = 8;
pub const CTL_FIND_SHA1_HASH = 1;
pub const CB_DIR = 325;
pub const PAN_WEIGHT_DEMI = 7;
pub const SEARCH_PRI_NO_SEQ = 5;
pub const PAN_WEIGHT_BOLD = 8;
pub const DS_SETFOREGROUND = @as(c_long, 512);
pub const CAL_SJAPANESEERAFIRSTYEAR = 61;
pub const JOB_STATUS_RESTART = 2048;
pub const CF_HDROP = 15;
pub const _ASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION = _ASSEMBLY_FILE_DETAILED_INFORMATION;
pub const CM_NONE = 0;
pub const ERROR_PROMOTION_ACTIVE = @as(c_long, 8221);
pub const AddPrinter = AddPrinterA;
pub const MCI_STOP = 2056;
pub const EVENT_SYSTEM_SWITCHER_CANCELLED = 39;
pub const CERT_FIND_OR_CTL_USAGE_FLAG = CERT_FIND_OR_ENHKEY_USAGE_FLAG;
pub const ERROR_PRODUCT_VERSION = @as(c_long, 1638);
pub const GCP_NUMERICSLATIN = @as(c_long, 67108864);
pub const PP_CONTAINER = 6;
pub const PAGESETUPDLGORDMOTIF = 1550;
pub const KP_SALT_EX = 10;
pub const MARK_HANDLE_SKIP_COHERENCY_SYNC_DISALLOW_WRITES = 16384;
pub const RPC_C_EP_MATCH_BY_BOTH = 3;
pub const ERROR_DS_DRA_CONNECTION_FAILED = @as(c_long, 8444);
pub const DUPLICATE_DEREG = 7;
pub const RRF_RT_REG_SZ = 2;
pub const ERROR_SECUREBOOT_POLICY_UPGRADE_MISMATCH = @as(c_long, 4432);
pub const BCRYPT_RSAPRIVATE_MAGIC = 843141970;
pub const ENOTRECOVERABLE = 127;
pub const CHANGER_REPORT_IEPORT_STATE = 2048;
pub const LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR = 256;
pub const szOID_STREET_ADDRESS = "2.5.4.9";
pub const FS_LATIN1 = @as(c_long, 1);
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_S = 31;
pub const ERROR_LOGON_FAILURE = @as(c_long, 1326);
pub const CAL_SSHORTESTDAYNAME5 = 53;
pub const FNERR_SUBCLASSFAILURE = 12289;
pub const S_SERDVNA = -1;
pub const SND_SYSTEM = @as(c_long, 2097152);
pub const STN_ENABLE = 2;
pub const ERROR_ACTIVE_CONNECTIONS = @as(c_long, 2402);
pub const AUX_MAPPER = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(UINT, -1) else UINT(-1);
pub const RPC_C_QOS_CAPABILITIES_ANY_AUTHORITY = 4;
pub const LABEL_SECURITY_INFORMATION = @as(c_long, 16);
pub const DC_ICON = 4;
pub const URLPOLICY_ALLOW = 0;
pub const GetMetaFile = GetMetaFileA;
pub const IMAGE_COMDAT_SELECT_SAME_SIZE = 3;
pub const REG_SECURE_CONNECTION = 1;
pub const SMTO_ERRORONEXIT = 32;
pub const InterlockedXorRelease = _InterlockedXor;
pub const AW_HOR_NEGATIVE = 2;
pub const MDM_BEARERMODE_GSM = 2;
pub const NRC_OPENERR = 63;
pub const CRYPTPROTECTMEMORY_SAME_PROCESS = 0;
pub const SPI_SETMENUSHOWDELAY = 107;
pub const X3_IMM39_1_SIZE_X = 23;
pub const SKF_RSHIFTLATCHED = 33554432;
pub const ERROR_PRINTER_NOT_FOUND = @as(c_long, 3012);
pub const DNS_ERROR_INVALID_SCOPE_OPERATION = @as(c_long, 9961);
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2 = @as(c_long, 8586);
pub const WS_EX_TOPMOST = @as(c_long, 8);
pub const MCI_SEEK = 2055;
pub const PSH_USEHICON = 2;
pub const MDM_PROTOCOLID_AUTO = 6;
pub const RpcBindingInqAuthClientEx = RpcBindingInqAuthClientExA;
pub const SCardStatus = SCardStatusA;
pub const GetClassInfo = GetClassInfoA;
pub const MCI_UNFREEZE = 2117;
pub const EMR_SETARCDIRECTION = 57;
pub const LANG_ITALIAN = 16;
pub const DRVCNF_OK = 1;
pub const CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG = 8;
pub const ERROR_RESILIENCY_FILE_CORRUPT = @as(c_long, 15625);
pub const TAPE_DRIVE_REPORT_SMKS = 524288;
pub const PKCS_7_ASN_ENCODING = 65536;
pub const IOInetProtocol = IInternetProtocol;
pub const ERROR_SERVICE_NOT_IN_EXE = @as(c_long, 1083);
pub const IMAGE_SCN_CNT_UNINITIALIZED_DATA = 128;
pub const CTRY_CROATIA = 385;
pub const GDIPLUS_TS_QUERYVER = 4122;
pub const ERROR_PROCESS_ABORTED = @as(c_long, 1067);
pub const SUBLANG_ENGLISH_SOUTH_AFRICA = 7;
pub const ERROR_DS_EXISTS_IN_AUX_CLS = @as(c_long, 8393);
pub const BANDINFO = 24;
pub const CE_OOP = 4096;
pub const SUBLANG_INUKTITUT_CANADA_LATIN = 2;
pub const GetDllDirectory = GetDllDirectoryA;
pub const DefDlgProc = DefDlgProcA;
pub const PRPC_BINDING_HANDLE_SECURITY_V1 = PRPC_BINDING_HANDLE_SECURITY_V1_A;
pub const CMSG_CTRL_DEL_CERT = 11;
pub const VER_SUITE_SINGLEUSERTS = 256;
pub const WM_SPOOLERSTATUS = 42;
pub const ERROR_INVALID_LDT_SIZE = @as(c_long, 561);
pub const NCRYPT_NO_KEY_VALIDATION = BCRYPT_NO_KEY_VALIDATION;
pub const SO_RCVTIMEO = 4102;
pub const X509_UNICODE_ANY_STRING = X509_UNICODE_NAME_VALUE;
pub const CHANGER_SLOTS_USE_TRAYS = 2147483664;
pub const NUMPRS_INEXACT = 131072;
pub const VK_OEM_CLEAR = 254;
pub const WM_DWMSENDICONICLIVEPREVIEWBITMAP = 806;
pub const IMAGE_REL_ARM_BLX11 = 9;
pub const MCI_FORMAT_SMPTE_30DROP = 7;
pub const __ORDER_PDP_ENDIAN__ = 3412;
pub const ERROR_NO_TOKEN = @as(c_long, 1008);
pub const OBJID_TITLEBAR = if (@typeId(@typeOf(4294967294)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG, 4294967294) else if (@typeId(@typeOf(4294967294)) == @import("builtin").TypeId.Int) @intToPtr(LONG, 4294967294) else LONG(4294967294);
pub const CERT_CHAIN_AUTO_LOG_FLUSH_FLAG = 8;
pub const VK_MBUTTON = 4;
pub const MS_DEF_DSS_DH_PROV_A = "Microsoft Base DSS and Diffie-Hellman Cryptographic Provider";
pub const CONSOLE_CARET_SELECTION = 1;
pub const TAPE_DRIVE_SEQUENTIAL_SMKS = 2149580800;
pub const POLYFILL_LAST = 2;
pub const DM_PANNINGHEIGHT = @as(c_long, 268435456);
pub const ERROR_DS_DRA_BAD_NC = @as(c_long, 8440);
pub const TXFS_TRANSACTION_STATE_NONE = 0;
pub const szOID_CRL_DIST_POINTS = "2.5.29.31";
pub const FACILITY_DEPLOYMENT_SERVICES_MULTICAST_CLIENT = 290;
pub const ERROR_GROUP_NOT_AVAILABLE = @as(c_long, 5012);
pub const IMAGE_REL_IA64_GPREL32 = 28;
pub const _Pre1_impl_ = p1;
pub const STATUS_LONGJUMP = if (@typeId(@typeOf(@as(c_long, 2147483686))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 2147483686)) else if (@typeId(@typeOf(@as(c_long, 2147483686))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 2147483686)) else DWORD(@as(c_long, 2147483686));
pub const DCBA_FACEUPCENTER = 1;
pub const RI_MOUSE_MIDDLE_BUTTON_UP = 32;
pub const AddPrinterDriverEx = AddPrinterDriverExA;
pub const ERROR_EVT_UNRESOLVED_VALUE_INSERT = @as(c_long, 15029);
pub const VP_TV_STANDARD_SECAM_K = 4096;
pub const STATUS_FLOAT_INEXACT_RESULT = if (@typeId(@typeOf(@as(c_long, 3221225615))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225615)) else if (@typeId(@typeOf(@as(c_long, 3221225615))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225615)) else DWORD(@as(c_long, 3221225615));
pub const WM_QUERYOPEN = 19;
pub const IMAGE_FILE_MACHINE_SH5 = 424;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_RF_EPILOGUE = 2;
pub const ERROR_SYSTEM_INTEGRITY_POLICY_VIOLATION = @as(c_long, 4551);
pub const XSTATE_COMPACTION_ENABLE = 63;
pub const EMR_CREATEPEN = 38;
pub const ICM_QUERYMATCH = 7;
pub const VK_SPACE = 32;
pub const MAXLOGICALLOGNAMESIZE = 256;
pub const CMSG_ENCRYPT_PARAM = 26;
pub const AC_SRC_OVER = 0;
pub const TXFS_TRANSACTION_STATE_NOTACTIVE = 3;
pub const FILE_DEVICE_MULTI_UNC_PROVIDER = 16;
pub const PDERR_NODEVICES = 4103;
pub const PST_RS423 = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 4) else DWORD(4);
pub const IMAGE_DEBUG_TYPE_MPX = 15;
pub const PRIVATEKEYBLOB = 7;
pub const FILE_LAYOUT_NAME_ENTRY_PRIMARY = 1;
pub const OF_PROMPT = 8192;
pub const CERT_SELECT_TRUSTED_ROOT = 2;
pub const ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY = @as(c_long, 14089);
pub const IME_CMODE_NATIVESYMBOL = 128;
pub const OpenBackupEventLog = OpenBackupEventLogA;
pub const EVENT_SYSTEM_FOREGROUND = 3;
pub const ERROR_DS_NO_MORE_RIDS = @as(c_long, 8209);
pub const SEARCH_ALL_NO_SEQ = 4;
pub const APPCLASS_MONITOR = @as(c_long, 1);
pub const FILE_VER_GET_NEUTRAL = 2;
pub const CRYPT_FORMAT_SEMICOLON = CRYPT_FORMAT_RDN_SEMICOLON;
pub const BST_CHECKED = 1;
pub const PAN_LETT_NORMAL_WEIGHTED = 3;
pub const szOID_INHIBIT_ANY_POLICY = "2.5.29.54";
pub const SM_SHOWSOUNDS = 70;
pub const DATA_E_LAST = @as(c_long, 2147746111);
pub const ERROR_NO_TASK_QUEUE = @as(c_long, 427);
pub const InterlockedOr64Release = _InterlockedOr64;
pub const ELEMENT_STATUS_FULL = 1;
pub const UriBuilder_USE_ORIGINAL_FLAGS = 1;
pub const szOID_NIST_sha384 = "2.16.840.1.101.3.4.2.2";
pub const FRS_ERR_INTERNAL_API = @as(c_long, 8004);
pub const VarUintFromDisp = VarUI4FromDisp;
pub const GROUP_NAME = 128;
pub const ERROR_LOGIN_TIME_RESTRICTION = @as(c_long, 1239);
pub const FAST_FAIL_MRDATA_MODIFIED = 19;
pub const TAPE_DRIVE_VARIABLE_BLOCK = 2048;
pub const ERROR_INVALID_DRIVE_OBJECT = @as(c_long, 4321);
pub const CB_SETLOCALE = 345;
pub const CFSTR_MIME_X_JAVASCRIPT = if (@typeId(@typeOf("application/x-javascript")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "application/x-javascript") else if (@typeId(@typeOf("application/x-javascript")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "application/x-javascript") else TEXT("application/x-javascript");
pub const ERANGE = 34;
pub const CreateSemaphore = CreateSemaphoreA;
pub const FRERR_BUFFERLENGTHZERO = 16385;
pub const CAL_SSHORTESTDAYNAME6 = 54;
pub const STATUS_REG_NAT_CONSUMPTION = if (@typeId(@typeOf(@as(c_long, 3221226185))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221226185)) else if (@typeId(@typeOf(@as(c_long, 3221226185))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221226185)) else DWORD(@as(c_long, 3221226185));
pub const ERROR_IMAGE_AT_DIFFERENT_BASE = @as(c_long, 807);
pub const POINTER_MESSAGE_FLAG_THIRDBUTTON = 64;
pub const PSCB_PRECREATE = 2;
pub const FILE_PREFETCH_TYPE_FOR_CREATE = 1;
pub const __LDBL_HAS_INFINITY__ = 1;
pub const Uri_CREATE_CANONICALIZE_ABSOLUTE = 131072;
pub const ERROR_EVT_INVALID_CHANNEL_PATH = @as(c_long, 15000);
pub const MFCOMMENT = 15;
pub const ERROR_DS_DRA_RPC_CANCELLED = @as(c_long, 8455);
pub const LOCALE_SENGLISHCOUNTRYNAME = 4098;
pub const PIDDSI_LINECOUNT = 5;
pub const IMAGE_REL_MIPS_LITERAL = 7;
pub const SCARD_PROVIDER_CSP = 2;
pub const MCI_TRACK = @as(c_long, 16);
pub const ERROR_DAX_MAPPING_EXISTS = @as(c_long, 361);
pub const SECURITY_CAPABILITY_MUSIC_LIBRARY = @as(c_long, 6);
pub const CMSG_CTRL_DEL_ATTR_CERT = 15;
pub const STORAGE_DEVICE_MAX_OPERATIONAL_STATUS = 16;
pub const TRANSACTION_NOTIFY_COMMIT_REQUEST = 67108864;
pub const IP_DROP_MEMBERSHIP = 6;
pub const PID_BEHAVIOR = 2147483651;
pub const ERROR_UNDEFINED_CHARACTER = @as(c_long, 583);
pub const GL_ID_UNKNOWN = 0;
pub const STDOLE2_MAJORVERNUM = 2;
pub const SUBLANG_HAWAIIAN_US = 1;
pub const ERROR_DS_DRA_NAME_COLLISION = @as(c_long, 8458);
pub const ExtractAssociatedIcon = ExtractAssociatedIconA;
pub const FACILITY_COMPLUS = 17;
pub const FILE_DEVICE_TAPE = 31;
pub const WT_EXECUTEDELETEWAIT = 8;
pub const ERROR_INVALID_WINDOW_STYLE = @as(c_long, 2002);
pub const TRANSACTIONMANAGER_RENAME = 8;
pub const PRODUCT_STORAGE_EXPRESS_SERVER_CORE = 43;
pub const ERROR_DS_NAME_VALUE_TOO_LONG = @as(c_long, 8349);
pub const EFAULT = 14;
pub const CERT_SHA256_HASH_PROP_ID = 107;
pub const RPC_QUERY_CLIENT_ID = 128;
pub const PRINTER_ERROR_OUTOFTONER = 4;
pub const CM_GAMMA_RAMP = 2;
pub const ERROR_UNHANDLED_ERROR = 4294967295;
pub const ERROR_TRANSLATION_COMPLETE = @as(c_long, 757);
pub const ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT = @as(c_long, 8606);
pub const SERVICE_STOP_REASON_FLAG_MAX = 2147483648;
pub const ERROR_TOKEN_ALREADY_IN_USE = @as(c_long, 1375);
pub const CAL_SABBREVMONTHNAME11 = 44;
pub const MF_CALLBACKS = 134217728;
pub const LANG_PUNJABI = 70;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = 0;
pub const DNS_FILTEROFF = 8;
pub const ERROR_INSTALL_POLICY_FAILURE = @as(c_long, 15615);
pub const OFFLINE_STATUS_REMOTE = 2;
pub const ERROR_MRM_RESOURCE_TYPE_MISMATCH = @as(c_long, 15117);
pub const PST_RS449 = if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 5) else if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 5) else DWORD(5);
pub const ERROR_DIR_NOT_EMPTY = @as(c_long, 145);
pub const ERROR_DS_NO_CHAINING = @as(c_long, 8327);
pub const CryptSetProvider = CryptSetProviderA;
pub const WVR_VALIDRECTS = 1024;
pub const ERROR_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED = @as(c_long, 4573);
pub const ERROR_CTX_SECURITY_LAYER_ERROR = @as(c_long, 7068);
pub const PS_GEOMETRIC = 65536;
pub const ENCAPSULATED_POSTSCRIPT = 4116;
pub const CERT_RETRIEVE_ISSUER_LOGO = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 1) else LPCSTR(1);
pub const NEXTBAND = 3;
pub const CMC_FAIL_INTERNAL_CA_ERROR = 11;
pub const DMPAPER_FOLIO = 14;
pub const SERVICE_ACTIVE = 1;
pub const DNS_ERROR_NBSTAT_INIT_FAILED = @as(c_long, 9617);
pub const SS_EDITCONTROL = @as(c_long, 8192);
pub const CTRY_RUSSIA = 7;
pub const LWA_COLORKEY = 1;
pub const RIDEV_DEVNOTIFY = 8192;
pub const ERROR_RECEIVE_EXPEDITED = @as(c_long, 708);
pub const OpenEvent = OpenEventA;
pub const MS_NBF = "MNBF";
pub const ERROR_CLUSTER_UPGRADE_IN_PROGRESS = @as(c_long, 5976);
pub const WM_UNDO = 772;
pub const GetServiceKeyName = GetServiceKeyNameA;
pub const KP_RB = 17;
pub const CallNamedPipe = CallNamedPipeA;
pub const IMAGE_FILE_MACHINE_SH4 = 422;
pub const BAUD_150 = if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 8) else if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 8) else DWORD(8);
pub const WNNC_NET_FOXBAT = 2818048;
pub const CERT_BACKED_UP_PROP_ID = 69;
pub const DEVICE_DSM_FLAG_TRIM_BYPASS_RZAT = 1073741824;
pub const FileEncryptionStatus = FileEncryptionStatusA;
pub const HTSIZEFIRST = HTLEFT;
pub const CM_SERVICE_NETWORK_BOOT_LOAD = 1;
pub const MMIO_DEFAULTBUFFER = 8192;
pub const URLMON_OPTION_USERAGENT_REFRESH = 268435458;
pub const ERROR_REPARSE_OBJECT = @as(c_long, 755);
pub const KP_MODE = 4;
pub const szOID_WINDOWS_RT_SIGNER = "1.3.6.1.4.1.311.10.3.21";
pub const CHANGER_STORAGE_DRIVE = 4096;
pub const ERROR_DEV_SIDELOAD_LIMIT_EXCEEDED = @as(c_long, 15633);
pub const URLPOLICY_CHANNEL_SOFTDIST_PROHIBIT = 65536;
pub const X509_ECC_SIGNATURE = if (@typeId(@typeOf(47)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 47) else if (@typeId(@typeOf(47)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 47) else LPCSTR(47);
pub const SUBLANG_SAMI_LULE_NORWAY = 4;
pub const TF_DISCONNECT = 1;
pub const ERROR_MESSAGE_SYNC_ONLY = @as(c_long, 1159);
pub const ImmGetRegisterWordStyle = ImmGetRegisterWordStyleA;
pub const DEVICEFAMILYINFOENUM_HOLOGRAPHIC = 10;
pub const DI_ROPS_READ_DESTINATION = 2;
pub const ERROR_INSUFFICIENT_POWER = @as(c_long, 639);
pub const DMPAPER_PENV_9 = 104;
pub const LCMAP_LINGUISTIC_CASING = 16777216;
pub const CHANGER_CARTRIDGE_MAGAZINE = 256;
pub const ENOTDIR = 20;
pub const IMAGE_REL_ALPHA_REFLONGNB = 16;
pub const SP_STOPBITS = if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 8) else if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 8) else DWORD(8);
pub const ERROR_NOT_ALLOWED_ON_SYSTEM_FILE = @as(c_long, 313);
pub const SHGFI_LARGEICON = 0;
pub const S_SERDFQ = -13;
pub const CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS = 536870912;
pub const STORAGE_DEVICE_FLAGS_PAGE_83_DEVICEGUID = 4;
pub const WM_DWMCOMPOSITIONCHANGED = 798;
pub const ERROR_INVALID_EXCEPTION_HANDLER = @as(c_long, 310);
pub const CAL_SSHORTESTDAYNAME7 = 55;
pub const CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE = 8;
pub const SECURITY_CAPABILITY_APPOINTMENTS = @as(c_long, 11);
pub const FILE_NOTIFY_CHANGE_CREATION = 64;
pub const RpcNsProfileEltAdd = RpcNsProfileEltAddA;
pub const RPC_C_AUTHN_LEVEL_NONE = 1;
pub const ERROR_AMBIGUOUS_SYSTEM_DEVICE = @as(c_long, 15250);
pub const USN_SOURCE_AUXILIARY_DATA = 2;
pub const USHRT_MAX = 65535;
pub const WN_OPEN_FILES = ERROR_OPEN_FILES;
pub const WT_EXECUTEINPERSISTENTIOTHREAD = 64;
pub const VARIANT_NOUSEROVERRIDE = 4;
pub const ERROR_TRANSACTION_NOT_ENLISTED = @as(c_long, 6855);
pub const ERROR_OPLOCK_BREAK_IN_PROGRESS = @as(c_long, 742);
pub const ImmEnumRegisterWord = ImmEnumRegisterWordA;
pub const CHANGER_TO_TRANSPORT = 1;
pub const SERVICE_ACCEPT_PARAMCHANGE = 8;
pub const DMPAPER_FANFOLD_LGL_GERMAN = 41;
pub const SUBLANG_BASQUE_BASQUE = 1;
pub const CERT_OCSP_MUST_STAPLE_PROP_ID = 121;
pub const PrintDlg = PrintDlgA;
pub const SND_ALIAS = @as(c_long, 65536);
pub const ERROR_SECUREBOOT_POLICY_VIOLATION = @as(c_long, 4421);
pub const RPC_S_BUFFER_TOO_SMALL = ERROR_INSUFFICIENT_BUFFER;
pub const ERROR_CLEANER_CARTRIDGE_SPENT = @as(c_long, 4333);
pub const MUI_VERIFY_FILE_EXISTS = 4;
pub const JOB_NOTIFY_FIELD_POSITION = 15;
pub const USER_MARSHAL_FC_DOUBLE = 12;
pub const PERF_OBJECT_TIMER = 2097152;
pub const IMAGE_SYM_CLASS_BLOCK = 100;
pub const EVENT_SYSTEM_MENUPOPUPSTART = 6;
pub const EOTHER = 131;
pub const SKF_RALTLOCKED = 2097152;
pub const CSTR_LESS_THAN = 1;
pub const CAL_SABBREVMONTHNAME10 = 43;
pub const IMAGE_SCN_MEM_NOT_CACHED = 67108864;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_BOOLEAN = 6;
pub const KP_HIGHEST_VERSION = 41;
pub const KDF_PARTYVINFO = 10;
pub const PRODUCT_STANDARD_NANO_SERVER = 144;
pub const SPI_GETSNAPSIZING = 142;
pub const CRYPT_MESSAGE_ENCAPSULATED_CONTENT_OUT_FLAG = 2;
pub const WAVE_FORMAT_1S08 = 2;
pub const LANG_MONGOLIAN = 80;
pub const VP_TV_STANDARD_NTSC_433 = 65536;
pub const ERROR_DS_ATT_NOT_DEF_FOR_CLASS = @as(c_long, 8317);
pub const __analysis_hint = hint;
pub const ImmConfigureIME = ImmConfigureIMEA;
pub const SUBLANG_UI_CUSTOM_DEFAULT = 5;
pub const GCS_RESULTREADCLAUSE = 1024;
pub const CryptRetrieveObjectByUrl = CryptRetrieveObjectByUrlA;
pub const CERT_QUERY_CONTENT_PKCS10 = 11;
pub const IMAGE_FILE_MACHINE_AMD64 = 34404;
pub const EMR_SETVIEWPORTEXTEX = 11;
pub const WS_EX_TOOLWINDOW = @as(c_long, 128);
pub const SECURITY_NT_NON_UNIQUE = @as(c_long, 21);
pub const PDC_MODE_CENTERED = 128;
pub const KP_RA = 16;
pub const SERVICE_STOP_REASON_MINOR_MEMOTYLIMIT = 24;
pub const IMAGE_FILE_MACHINE_SH3 = 418;
pub const CRYPT_ACCUMULATIVE_TIMEOUT = 2048;
pub const SM_CXSCREEN = 0;
pub const TRANSACTION_MANAGER_MAXIMUM_OPTION = 63;
pub const ERROR_DUPLICATE_SERVICE_NAME = @as(c_long, 1078);
pub const MM_DRVM_DATA = 978;
pub const SOUND_SYSTEM_BEEP = 3;
pub const CDN_FIRST = if (@typeId(@typeOf(-@as(c_uint, 601))) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), -@as(c_uint, 601)) else if (@typeId(@typeOf(-@as(c_uint, 601))) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), -@as(c_uint, 601)) else @as(c_uint, 0)(-@as(c_uint, 601));
pub const STORAGE_TEMPERATURE_VALUE_NOT_REPORTED = 32768;
pub const APPCOMMAND_VOLUME_MUTE = 8;
pub const ERROR_NOT_SUPPORTED = @as(c_long, 50);
pub const CERT_NAME_STR_ENABLE_PUNYCODE_FLAG = 2097152;
pub const __DBL_MAX__ = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878;
pub const ERROR_CLUSTER_FAULT_DOMAIN_PARENT_NOT_FOUND = @as(c_long, 5994);
pub const ERROR_SXS_CORRUPT_ACTIVATION_STACK = @as(c_long, 14082);
pub const PSM_SETHEADERSUBTITLE = PSM_SETHEADERSUBTITLEA;
pub const _Always_impl_ = annos;
pub const WM_SHOWWINDOW = 24;
pub const stc16 = 1103;
pub const MIN_PRIORITY = 1;
pub const URL_OID_CERTIFICATE_OCSP = if (@typeId(@typeOf(9)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 9) else if (@typeId(@typeOf(9)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 9) else LPCSTR(9);
pub const _USE_ATTRIBUTES_FOR_SAL = 0;
pub const WSAEMFILE = @as(c_long, 10024);
pub const ERROR_IPSEC_IKE_NO_PEER_CERT = @as(c_long, 13847);
pub const CopyFileEx = CopyFileExA;
pub const ERROR_DS_DUP_RDN = @as(c_long, 8378);
pub const FADF_RECORD = 32;
pub const URLACTION_ALLOW_CSS_EXPRESSIONS = 9997;
pub const OFN_PATHMUSTEXIST = 2048;
pub const GCL_REVERSE_LENGTH = 3;
pub const GlobalAddAtomEx = GlobalAddAtomExA;
pub const ERROR_STATE_GET_VERSION_FAILED = @as(c_long, 15801);
pub const PAGE_EXECUTE_WRITECOPY = 128;
pub const szOID_KP_CSP_SIGNATURE = "1.3.6.1.4.1.311.10.3.16";
pub const CERT_FILE_STORE_COMMIT_ENABLE_FLAG = 65536;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NONCE = @as(c_long, 13839);
pub const CRYPT_IMPL_UNKNOWN = 4;
pub const KEYEVENTF_EXTENDEDKEY = 1;
pub const IDH_HELP = 28445;
pub const PCF_PARITY_CHECK = if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 8) else if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 8) else DWORD(8);
pub const DMPAPER_PENV_8 = 103;
pub const NTDDI_WS03 = 84017152;
pub const SCS_DOS_BINARY = 1;
pub const ERROR_LOCK_FAILED = @as(c_long, 167);
pub const CHANGER_CLEANER_ACCESS_NOT_VALID = 262144;
pub const TAPE_REWIND = @as(c_long, 0);
pub const APPCOMMAND_TREBLE_DOWN = 22;
pub const CRYPT_FORMAT_CRLF = CRYPT_FORMAT_RDN_CRLF;
pub const POINTER_FLAG_PRIMARY = 8192;
pub const IMFS_UNCHECKED = MFS_UNCHECKED;
pub const IsCharAlpha = IsCharAlphaA;
pub const CERT_STORE_PROV_FILENAME_W = if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 8) else if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 8) else LPCSTR(8);
pub const IMAGE_SYM_TYPE_SHORT = 3;
pub const CERT_HCRYPTPROV_TRANSFER_PROP_ID = 100;
pub const XSTATE_MASK_LEGACY_FLOATING_POINT = if (@typeId(@typeOf(i64 << XSTATE_LEGACY_FLOATING_POINT)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << XSTATE_LEGACY_FLOATING_POINT) else if (@typeId(@typeOf(i64 << XSTATE_LEGACY_FLOATING_POINT)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << XSTATE_LEGACY_FLOATING_POINT) else @as(c_uint, 1)(i64 << XSTATE_LEGACY_FLOATING_POINT);
pub const _On_failure_impl_ = annos;
pub const PAGE_GRAPHICS_EXECUTE_READ = 32768;
pub const SNDMSG = SendMessage;
pub const FILE_SUPPORTS_SPARSE_VDL = 268435456;
pub const CTRY_KENYA = 254;
pub const szOID_PKIX_OCSP_NONCE = "1.3.6.1.5.5.7.48.1.2";
pub const PF_COMPARE64_EXCHANGE128 = 15;
pub const ERROR_DEPLOYMENT_OPTION_NOT_SUPPORTED = @as(c_long, 15645);
pub const CERT_STORE_ADD_NEW = 1;
pub const RpcNsBindingUnexport = RpcNsBindingUnexportA;
pub const szOID_ENROLL_SCEP_SERVER_STATE = "1.3.6.1.4.1.311.21.34";
pub const MCI_ANIM_INFO_TEXT = @as(c_long, 65536);
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_TXF_SYSTEM_FILE = 8;
pub const IO_REPARSE_TAG_STORAGE_SYNC = @as(c_long, 2147483678);
pub const EXCEPTION_POSSIBLE_DEADLOCK = STATUS_POSSIBLE_DEADLOCK;
pub const PP_UI_PROMPT = 21;
pub const WN_OUT_OF_MEMORY = ERROR_NOT_ENOUGH_MEMORY;
pub const SEE_MASK_WAITFORINPUTIDLE = 33554432;
pub const CWP_SKIPDISABLED = 2;
pub const PERFSTATE_POLICY_CHANGE_ROCKET = 2;
pub const EnumDesktops = EnumDesktopsA;
pub const WAVE_FORMAT_1M08 = 1;
pub const CERT_AUTO_ENROLL_RETRY_PROP_ID = 66;
pub const CRYPTPROTECT_PROMPT_RESERVED = 4;
pub const DOMAIN_USER_RID_MAX = @as(c_long, 999);
pub const IMR_CONFIRMRECONVERTSTRING = 5;
pub const CryptBinaryToString = CryptBinaryToStringA;
pub const ERROR_GPIO_OPERATION_DENIED = @as(c_long, 15325);
pub const WM_MEASUREITEM = 44;
pub const MM_MIM_ERROR = 965;
pub const RPC_NCA_FLAGS_IDEMPOTENT = 1;
pub const DEVICEDATA = 19;
pub const STN_DISABLE = 3;
pub const ENUMRESTYPEPROC = ENUMRESTYPEPROCA;
pub const LOCALE_SNAME = 92;
pub const POSTSCRIPT_DATA = 37;
pub const SendMessage = SendMessageA;
pub const IME_CMODE_FULLSHAPE = 8;
pub const ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET = @as(c_long, 8464);
pub const RPC_C_AUTHN_PKU2U = 31;
pub const szOID_RSA_RC2CBC = "1.2.840.113549.3.2";
pub const PROCESSOR_PERF_MINIMUM_ACTIVITY_WINDOW = 0;
pub const ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE = @as(c_long, 8626);
pub const GetCorePrinterDrivers = GetCorePrinterDriversA;
pub const FACILITY_MEDIASERVER = 13;
pub const GMDI_GOINTOPOPUPS = @as(c_long, 2);
pub const COLOR_HIGHLIGHTTEXT = 14;
pub const CAL_SABBREVMONTHNAME13 = 46;
pub const SETLINECAP = 21;
pub const szOID_APPLICATION_POLICY_CONSTRAINTS = "1.3.6.1.4.1.311.21.12";
pub const LPD_SHARE_DEPTH = 64;
pub const COLOR_GRADIENTINACTIVECAPTION = 28;
pub const OFFLINE_STATUS_LOCAL = 1;
pub const LB_SETSEL = 389;
pub const TRANSACTIONMANAGER_GENERIC_EXECUTE = STANDARD_RIGHTS_EXECUTE;
pub const FACILITY_FVE = 49;
pub const ACCESS_MAX_MS_V3_ACE_TYPE = 4;
pub const APPMODEL_ERROR_NO_MUTABLE_DIRECTORY = @as(c_long, 15707);
pub const CERT_ENROLLMENT_PROP_ID = 26;
pub const SetWindowsHook = SetWindowsHookA;
pub const PAN_SERIF_TRIANGLE = 10;
pub const TPM_LEFTBUTTON = @as(c_long, 0);
pub const NCRYPT_ALLOW_KEY_AGREEMENT_FLAG = 4;
pub const ERROR_CTX_NOT_CONSOLE = @as(c_long, 7038);
pub const MediumChangerClassGuid = GUID_DEVINTERFACE_MEDIUMCHANGER;
pub const VarR8FromInt = VarR8FromI4;
pub const PSINJECT_TRAILER = 18;
pub const DNS_ERROR_SETUP_BASE = 9850;
pub const DISPID_NEWENUM = -4;
pub const ERROR_CONTAINER_ASSIGNED = @as(c_long, 1504);
pub const ERROR_DEVICE_IN_MAINTENANCE = @as(c_long, 359);
pub const SEE_MASK_HMONITOR = 2097152;
pub const SPI_GETMENUSHOWDELAY = 106;
pub const CHANGER_DRIVE_CLEANING_REQUIRED = 65536;
pub const __inner_data_source = src_raw;
pub const USN_REASON_SECURITY_CHANGE = 2048;
pub const ERROR_SXS_XML_E_UNCLOSEDENDTAG = @as(c_long, 14061);
pub const WMSZ_RIGHT = 2;
pub const VP_TV_STANDARD_SECAM_H = 2048;
pub const SE_SACL_PROTECTED = 8192;
pub const AC_LINE_UNKNOWN = 255;
pub const ERROR_NOACCESS = @as(c_long, 998);
pub const QUERY_FILE_LAYOUT_INCLUDE_ONLY_FILES_WITH_SPECIFIC_ATTRIBUTES = 2048;
pub const VK_OEM_FJ_MASSHOU = 147;
pub const CRYPT_DEFAULT_CONTAINER_OPTIONAL = 128;
pub const SECURITY_COM_ID_BASE_RID = @as(c_long, 89);
pub const IMAGE_SCN_ALIGN_1BYTES = 1048576;
pub const STORAGE_INFO_OFFSET_UNKNOWN = 4294967295;
pub const WN_NO_ERROR = NO_ERROR;
pub const PROP_LG_CXDLG = 252;
pub const stc17 = 1104;
pub const PRODUCT_PRO_CHINA = 139;
pub const TAPE_LOCK = @as(c_long, 3);
pub const JOB_STATUS_PRINTED = 128;
pub const PRINTER_DRIVER_CATEGORY_SERVICE = 512;
pub const ERROR_DEVICE_FEATURE_NOT_SUPPORTED = @as(c_long, 316);
pub const S_WHITE1024 = 5;
pub const DMPAPER_PENV_2_ROTATED = 110;
pub const NCBCHAINSENDNA = 114;
pub const SWP_NOZORDER = 4;
pub const KEYEVENTF_KEYUP = 2;
pub const FIND_FROMEND = 8388608;
pub const __ANNOTATION = fun;
pub const HEAP_CREATE_ENABLE_EXECUTE = 262144;
pub const POINTER_MESSAGE_FLAG_PRIMARY = 8192;
pub const MM_WOM_OPEN = 955;
pub const WSAENETDOWN = @as(c_long, 10050);
pub const PPM_FIRMWARE_CST = 8;
pub const ERROR_EFS_SERVER_NOT_TRUSTED = @as(c_long, 6011);
pub const SHTDN_REASON_MAJOR_OTHER = 0;
pub const PIDMSI_PROJECT = @as(c_long, 6);
pub const VK_NUMLOCK = 144;
pub const ARW_TOPRIGHT = @as(c_long, 3);
pub const USER_MARSHAL_FC_HYPER = 11;
pub const APPCOMMAND_UNDO = 34;
pub const CRL_DIST_POINT_ERR_INDEX_SHIFT = 24;
pub const SERVICE_DISABLED = 4;
pub const NCRYPT_USE_PER_BOOT_KEY_FLAG = 262144;
pub const HC_NOREMOVE = 3;
pub const ARW_TOPLEFT = @as(c_long, 2);
pub const ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE = @as(c_long, 13904);
pub const MAXIMUM_WAIT_OBJECTS = 64;
pub const InterlockedExchangeNoFence64 = InterlockedExchange64;
pub const EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X = 24;
pub const PRINTER_STATUS_TONER_LOW = 131072;
pub const MINHALF_PTR = ~MAXHALF_PTR;
pub const IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = 1024;
pub const STATE_SYSTEM_INVISIBLE = 32768;
pub const WSATYPE_NOT_FOUND = @as(c_long, 10109);
pub const CAL_SSHORTESTDAYNAME1 = 49;
pub const PRODUCT_ENTERPRISE_SERVER = 10;
pub const DNS_ERROR_ZONESCOPE_FILE_WRITEBACK_FAILED = @as(c_long, 9957);
pub const SERVICE_LAUNCH_PROTECTED_ANTIMALWARE_LIGHT = 3;
pub const THREAD_SET_CONTEXT = 16;
pub const HTMAXBUTTON = 9;
pub const AT_KEYEXCHANGE = 1;
pub const ERROR_CLUSTER_GROUP_QUEUED = @as(c_long, 5959);
pub const URLACTION_SHELL_TOCTOU_RISK = 6162;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION = @as(c_long, 385);
pub const IGNORE = 0;
pub const InterlockedAndNoFence = _InterlockedAnd;
pub const SECURITY_DELEGATION = SecurityDelegation << 16;
pub const JOB_OBJECT_MSG_MINIMUM = 1;
pub const ERROR_ADDRESS_ALREADY_ASSOCIATED = @as(c_long, 1227);
pub const SHUTDOWN_SOFT_REBOOT = 2048;
pub const SCardLocateCardsByATR = SCardLocateCardsByATRA;
pub const RPC_C_PROTECT_LEVEL_CONNECT = RPC_C_AUTHN_LEVEL_CONNECT;
pub const TXFS_RM_FLAG_PREFER_CONSISTENCY = 65536;
pub const ERROR_OPERATION_ABORTED = @as(c_long, 995);
pub const InterlockedXor16 = _InterlockedXor16;
pub const ERROR_GDI_HANDLE_LEAK = @as(c_long, 373);
pub const RPC_C_PROTECT_LEVEL_DEFAULT = RPC_C_AUTHN_LEVEL_DEFAULT;
pub const MS_RING_ON = if (@typeId(@typeOf(64)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 64) else if (@typeId(@typeOf(64)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 64) else DWORD(64);
pub const IMAGE_REL_AM_ABSOLUTE = 0;
pub const ReadMxCsr = _mm_getcsr;
pub const CE_RXOVER = 1;
pub const SPI_GETCARETWIDTH = 8198;
pub const MEDIA_CURRENTLY_MOUNTED = 2147483648;
pub const WNetGetConnection = WNetGetConnectionA;
pub const IS_TEXT_UNICODE_NULL_BYTES = 4096;
pub const AF_LAT = 14;
pub const LGRPID_GEORGIAN = 16;
pub const szOID_X957_SHA1DSA = "1.2.840.10040.4.3";
pub const PERF_DETAIL_EXPERT = 300;
pub const DAX_ALLOC_ALIGNMENT_FLAG_FALLBACK_SPECIFIED = 2;
pub const SSGF_NONE = 0;
pub const NOTIFYICONDATA_V2_SIZE = NOTIFYICONDATAA_V2_SIZE;
pub const SM_CXFIXEDFRAME = SM_CXDLGFRAME;
pub const CERT_SIGNATURE_HASH_PROP_ID = 15;
pub const PRPC_ENDPOINT_TEMPLATE = PRPC_ENDPOINT_TEMPLATEA;
pub const JOB_NOTIFY_FIELD_MACHINE_NAME = 1;
pub const CERT_NAME_STR_COMMA_FLAG = 67108864;
pub const RegQueryValueEx = RegQueryValueExA;
pub const VK_HOME = 36;
pub const LBN_KILLFOCUS = 5;
pub const ERROR_WMI_ALREADY_ENABLED = @as(c_long, 4206);
pub const BDR_SUNKENINNER = 8;
pub const RPC_P_ADDR_FORMAT_TCP_IPV4 = 1;
pub const IMAGE_REL_ALPHA_GPDISP = 6;
pub const ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP = @as(c_long, 5928);
pub const DNS_ERROR_OPERATION_BASE = 9750;
pub const EMR_EXTCREATEPEN = 95;
pub const __UINT16_FMTX__ = "hX";
pub const SPIF_SENDWININICHANGE = 2;
pub const CAL_SABBREVMONTHNAME12 = 45;
pub const szOID_CMC_ADD_EXTENSIONS = "1.3.6.1.5.5.7.7.8";
pub const ESB_DISABLE_BOTH = 3;
pub const CERT_TRUST_IS_KEY_ROLLOVER = 128;
pub const PAGE_GRAPHICS_COHERENT = 131072;
pub const NCRYPT_RNG_OPERATION = BCRYPT_RNG_OPERATION;
pub const CERT_STORE_UPDATE_KEYID_FLAG = 1024;
pub const DBG_TERMINATE_PROCESS = if (@typeId(@typeOf(@as(c_long, 1073807364))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 1073807364)) else if (@typeId(@typeOf(@as(c_long, 1073807364))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 1073807364)) else DWORD(@as(c_long, 1073807364));
pub const IME_CMODE_JAPANESE = IME_CMODE_NATIVE;
pub const CERT_CHAIN_CROSS_CERT_DOWNLOAD_INTERVAL_HOURS_DEFAULT = if (@typeId(@typeOf(7)) == @import("builtin").TypeId.Pointer) @ptrCast([*c]24, 7) else if (@typeId(@typeOf(7)) == @import("builtin").TypeId.Int) @intToPtr([*c]24, 7) else ([*c]24)(7);
pub const PIDDSI_PARCOUNT = 6;
pub const ERROR_SXS_PROCESS_TERMINATION_REQUESTED = @as(c_long, 14087);
pub const NIIF_NONE = 0;
pub const __PRFCHW__ = 1;
pub const ERROR_DS_SOURCE_AUDITING_NOT_ENABLED = @as(c_long, 8552);
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = 0;
pub const szOID_ROOT_LIST_SIGNER = "1.3.6.1.4.1.311.10.3.9";
pub const PAGE_READONLY = 2;
pub const LGRPID_JAPANESE = 7;
pub const MF_RIGHTJUSTIFY = @as(c_long, 16384);
pub const R2_NOTMASKPEN = 8;
pub const IMAGE_REL_MIPS_JMPADDR = 3;
pub const REG_OPTION_VOLATILE = @as(c_long, 1);
pub const EMR_SETMETARGN = 28;
pub const DNS_ERROR_NOT_ENOUGH_SIGNING_KEY_DESCRIPTORS = @as(c_long, 9104);
pub const RDW_NOCHILDREN = 64;
pub const TCI_SRCLOCALE = 4096;
pub const ERROR_SXS_XML_E_UNCLOSEDDECL = @as(c_long, 14064);
pub const DATABITS_16X = if (@typeId(@typeOf(32)) == @import("builtin").TypeId.Pointer) @ptrCast(WORD, 32) else if (@typeId(@typeOf(32)) == @import("builtin").TypeId.Int) @intToPtr(WORD, 32) else WORD(32);
pub const SYSTEM_MANDATORY_LABEL_ACE_TYPE = 17;
pub const IMAGE_REL_AMD64_ADDR64 = 1;
pub const CERT_STRONG_SIGN_OID_INFO_CHOICE = 2;
pub const MUTZ_ISFILE = 2;
pub const __UINT_LEAST16_FMTo__ = "ho";
pub const LANG_ALBANIAN = 28;
pub const OLEOBJ_S_FIRST = @as(c_long, 262528);
pub const SM_CYMINSPACING = 48;
pub const SERVICE_INTERACTIVE_PROCESS = 256;
pub const ERROR_DS_NC_MUST_HAVE_NC_PARENT = @as(c_long, 8494);
pub const CERT_FORTEZZA_DATA_PROP_ID = 18;
pub const _Pre_satisfies_impl_ = expr;
pub const SORT_GERMAN_PHONE_BOOK = 1;
pub const LANG_GREENLANDIC = 111;
pub const GRADIENT_FILL_TRIANGLE = 2;
pub const IDN_ALLOW_UNASSIGNED = 1;
pub const IMAGE_FILE_LARGE_ADDRESS_AWARE = 32;
pub const SERVICE_STOP_REASON_MINOR_MAX = 25;
pub const stc14 = 1101;
pub const ERROR_IMAGE_MACHINE_TYPE_MISMATCH = @as(c_long, 706);
pub const OFN_NOVALIDATE = 256;
pub const PD_ENABLESETUPTEMPLATE = 32768;
pub const MIXER_OBJECTF_MIDIOUT = @as(c_long, 805306368);
pub const TAPE_SPACE_SETMARKS = @as(c_long, 8);
pub const LOCALE_IDIGITSUBSTITUTION = 4116;
pub const DISPLAY_DEVICE_ACTIVE = 1;
pub const __INT16_MAX__ = 32767;
pub const IMAGE_FILE_MACHINE_ALPHA = 388;
pub const PRINTER_DRIVER_DERIVED = 16;
pub const CMSG_KEY_AGREE_STATIC_KEY_CHOICE = 2;
pub const CRYPT_STRING_BASE64REQUESTHEADER = 3;
pub const ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION = @as(c_long, 13019);
pub const ODS_HOTLIGHT = 64;
pub const MIXERCONTROL_CT_SC_LIST_MULTIPLE = @as(c_long, 16777216);
pub const __SHRT_MAX__ = 32767;
pub const VK_GAMEPAD_DPAD_DOWN = 204;
pub const _DIGIT = 4;
pub const DISPLAY_DEVICE_REMOTE = 67108864;
pub const WC_SEPCHARS = 32;
pub const __drv_typeExpr = 3;
pub const CMC_STATUS_CONFIRM_REQUIRED = 5;
pub const ERROR_NO_SUCH_DOMAIN = @as(c_long, 1355);
pub const FAIL_FAST_GENERATE_EXCEPTION_ADDRESS = 1;
pub const LANG_SERBIAN = 26;
pub const LANGUAGEGROUP_ENUMPROC = LANGUAGEGROUP_ENUMPROCA;
pub const VIF_TEMPFILE = @as(c_long, 1);
pub const BCRYPT_ECDH_PRIVATE_P521_MAGIC = 910902085;
pub const LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = 4096;
pub const LPOINETPROTOCOLSINK = LPIINTERNETPROTOCOLSINK;
pub const ERROR_CLOUD_FILE_REQUEST_CANCELED = @as(c_long, 398);
pub const ENUM_S_LAST = @as(c_long, 262591);
pub const ERROR_ALREADY_THREAD = @as(c_long, 1281);
pub const ERROR_PACKAGES_REPUTATION_CHECK_FAILED = @as(c_long, 15643);
pub const NO_RECOVERY = WSANO_RECOVERY;
pub const ERROR_PASSWORD_MUST_CHANGE = @as(c_long, 1907);
pub const MCI_OPEN_ALIAS = @as(c_long, 1024);
pub const SPI_GETGESTUREVISUALIZATION = 8218;
pub const STORAGE_HW_FIRMWARE_REQUEST_FLAG_SWITCH_TO_EXISTING_FIRMWARE = 2147483648;
pub const LGRPID_INDIC = 15;
pub const TOUCHEVENTF_NOCOALESCE = 32;
pub const szOID_NETSCAPE_CA_POLICY_URL = "2.16.840.1.113730.1.8";
pub const SERVICE_CONTROL_NETBINDDISABLE = 10;
pub const CAL_SSHORTESTDAYNAME2 = 50;
pub const WH_SYSMSGFILTER = 6;
pub const STATUS_FLOAT_INVALID_OPERATION = if (@typeId(@typeOf(@as(c_long, 3221225616))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225616)) else if (@typeId(@typeOf(@as(c_long, 3221225616))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225616)) else DWORD(@as(c_long, 3221225616));
pub const RESOURCEUSAGE_CONNECTABLE = 1;
pub const ETO_OPAQUE = 2;
pub const ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND = @as(c_long, 13017);
pub const CTRY_NICARAGUA = 505;
pub const SUBLANG_MALAY_MALAYSIA = 1;
pub const NCRYPT_SILENT_FLAG = 64;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_WINDOWS_RID = @as(c_long, 4096);
pub const ERROR_CLOUD_FILE_NETWORK_UNAVAILABLE = @as(c_long, 388);
pub const FILE_DEVICE_FILE_SYSTEM = 9;
pub const PRF_NONCLIENT = @as(c_long, 2);
pub const __INT8_FMTd__ = "hhd";
pub const SPI_GETCARETTIMEOUT = 8226;
pub const CHECKSUM_TYPE_CRC64 = 2;
pub const SPI_SETTOGGLEKEYS = 53;
pub const MINLONGLONG = if (@typeId(@typeOf(~MAXLONGLONG)) == @import("builtin").TypeId.Pointer) @ptrCast(LONGLONG, ~MAXLONGLONG) else if (@typeId(@typeOf(~MAXLONGLONG)) == @import("builtin").TypeId.Int) @intToPtr(LONGLONG, ~MAXLONGLONG) else LONGLONG(~MAXLONGLONG);
pub const LPD_TYPE_COLORINDEX = 1;
pub const __STDC_WANT_SECURE_LIB__ = 1;
pub const WNNC_NET_AVID = 1703936;
pub const ERROR_REPARSE_ATTRIBUTE_CONFLICT = @as(c_long, 4391);
pub const DMBIN_FIRST = DMBIN_UPPER;
pub const ENABLE_VIRTUAL_TERMINAL_PROCESSING = 4;
pub const BCRYPT_AES_CBC_ALG_HANDLE = if (@typeId(@typeOf(417)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 417) else if (@typeId(@typeOf(417)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 417) else BCRYPT_ALG_HANDLE(417);
pub const PSD_NOWARNING = 128;
pub const FILE_SUPPORTS_REPARSE_POINTS = 128;
pub const VK_KANA = 21;
pub const DESKTOPHORZRES = 118;
pub const ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED = @as(c_long, 15206);
pub const PEERDIST_ERROR_NO_MORE = @as(c_long, 4053);
pub const ERROR_IPSEC_IKE_NEGOTIATION_PENDING = @as(c_long, 13803);
pub const VK_GAMEPAD_B = 196;
pub const szOID_AUTHORITY_KEY_IDENTIFIER = "2.5.29.1";
pub const PRODUCT_EMBEDDED_INDUSTRY_E = 91;
pub const PRODUCT_ENTERPRISE_SERVER_CORE_V = 41;
pub const ERROR_PRINTER_ALREADY_EXISTS = @as(c_long, 1802);
pub const RESTART_MAX_CMD_LINE = 1024;
pub const BS_FLAT = @as(c_long, 32768);
pub const EMR_ENDPATH = 60;
pub const DBG_CONTROL_BREAK = if (@typeId(@typeOf(@as(c_long, 1073807368))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 1073807368)) else if (@typeId(@typeOf(@as(c_long, 1073807368))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 1073807368)) else DWORD(@as(c_long, 1073807368));
pub const I_RpcNsBindingSetEntryName = I_RpcNsBindingSetEntryNameA;
pub const RPC_NCA_FLAGS_MAYBE = 4;
pub const MCI_CUT = 2129;
pub const PFD_SWAP_COPY = 1024;
pub const SZDDESYS_ITEM_RTNMSG = "ReturnMessage";
pub const ERROR_ORPHAN_NAME_EXHAUSTED = @as(c_long, 799);
pub const ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR = @as(c_long, 13804);
pub const WS_ACTIVECAPTION = 1;
pub const FILE_MAP_TARGETS_INVALID = 1073741824;
pub const FW_THIN = 100;
pub const R2_BLACK = 1;
pub const EnumResourceTypes = EnumResourceTypesA;
pub const WS_THICKFRAME = @as(c_long, 262144);
pub const RDW_VALIDATE = 8;
pub const BSF_FLUSHDISK = 4;
pub const ERROR_IPSEC_IKE_INVALID_AUTH_ALG = @as(c_long, 13874);
pub const HELP_HELPONHELP = @as(c_long, 4);
pub const URLACTION_ALLOW_STRUCTURED_STORAGE_SNIFFING = 9987;
pub const DC_COLLATE = 22;
pub const PROCESS_QUERY_INFORMATION = 1024;
pub const PAN_WEIGHT_NORD = 11;
pub const PDC_ORIENTATION_180 = 16;
pub const FLASHW_TIMER = 4;
pub const RPC_S_FP_OVERFLOW = @as(c_long, 1771);
pub const ERROR_CLOUD_FILE_NOT_SUPPORTED = @as(c_long, 379);
pub const WSANO_RECOVERY = @as(c_long, 11003);
pub const IMAGE_CURSOR = 2;
pub const SPI_SETMENURECT = 163;
pub const ERROR_INVALID_ENVIRONMENT = @as(c_long, 1805);
pub const szOID_RSA_contentType = "1.2.840.113549.1.9.3";
pub const ERROR_WMI_GUID_NOT_FOUND = @as(c_long, 4200);
pub const VK_OEM_7 = 222;
pub const DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE = @as(c_long, 9719);
pub const ERROR_INVALID_CAP = @as(c_long, 320);
pub const DEBUG_PROCESS = 1;
pub const MDM_PIAFS_OUTGOING = 1;
pub const PROCESS_CREATION_MITIGATION_POLICY2_MODULE_TAMPERING_PROTECTION_DEFER = if (@typeId(@typeOf(i64 << 12)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), i64 << 12) else if (@typeId(@typeOf(i64 << 12)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), i64 << 12) else @as(c_uint, 0)(i64 << 12);
pub const MSGF_MESSAGEBOX = 1;
pub const EXCEPTION_NONCONTINUABLE_EXCEPTION = STATUS_NONCONTINUABLE_EXCEPTION;
pub const CRYPT_ARCHIVABLE = 16384;
pub const PAN_FAMILY_SCRIPT = 3;
pub const WC_DISCARDNS = 16;
pub const APPCOMMAND_OPEN = 30;
pub const ConfigurePort = ConfigurePortA;
pub const ERROR_NO_RECOVERY_POLICY = @as(c_long, 6003);
pub const FS_TURKISH = @as(c_long, 16);
pub const CONSOLE_MOUSE_DOWN = 8;
pub const NETSCAPE_SSL_CA_CERT_TYPE = 4;
pub const MUI_FORMAT_INF_COMPAT = 2;
pub const PERF_SIZE_ZERO = 512;
pub const RPC_C_NS_SYNTAX_DEFAULT = 0;
pub const WNetConnectionDialog1 = WNetConnectionDialog1A;
pub const stc15 = 1102;
pub const MOUSE_HWHEELED = 8;
pub const ERROR_DS_OBJECT_CLASS_REQUIRED = @as(c_long, 8315);
pub const GCLP_HCURSOR = -12;
pub const CAP_ATA_ID_CMD = 1;
pub const PS_ENDCAP_FLAT = 512;
pub const ERROR_DS_SCHEMA_ALLOC_FAILED = @as(c_long, 8415);
pub const BCRYPT_DESX_CBC_ALG_HANDLE = if (@typeId(@typeOf(545)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 545) else if (@typeId(@typeOf(545)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 545) else BCRYPT_ALG_HANDLE(545);
pub const HC_SYSMODALOFF = 5;
pub const PRODUCT_CORE_N = 98;
pub const VK_CRSEL = 247;
pub const GetVolumePathName = GetVolumePathNameA;
pub const STORAGE_EVENT_DEVICE_OPERATION = 4;
pub const ShellExecute = ShellExecuteA;
pub const DNS_ERROR_FORWARDER_ALREADY_EXISTS = @as(c_long, 9619);
pub const JOB_NOTIFY_FIELD_NOTIFY_NAME = 4;
pub const IMAGE_REL_IA64_DIR32 = 4;
pub const VK_UP = 38;
pub const MM_JOY2MOVE = 929;
pub const SM_CXMIN = 28;
pub const ERROR_WRONG_COMPARTMENT = @as(c_long, 1468);
pub const PKCS_RSA_SSA_PSS_TRAILER_FIELD_BC = 1;
pub const EXCEPTION_INVALID_HANDLE = STATUS_INVALID_HANDLE;
pub const PROCESSOR_THROTTLE_AUTOMATIC = 2;
pub const TIMEFMT_ENUMPROC = TIMEFMT_ENUMPROCA;
pub const FF_DECORATIVE = 5 << 4;
pub const STORAGE_ADAPTER_SERIAL_NUMBER_V1_SIZE = if (@typeId(@typeOf(STORAGE_ADAPTER_SERIAL_NUMBER)) == @import("builtin").TypeId.Pointer) @ptrCast(sizeof, STORAGE_ADAPTER_SERIAL_NUMBER) else if (@typeId(@typeOf(STORAGE_ADAPTER_SERIAL_NUMBER)) == @import("builtin").TypeId.Int) @intToPtr(sizeof, STORAGE_ADAPTER_SERIAL_NUMBER) else sizeof(STORAGE_ADAPTER_SERIAL_NUMBER);
pub const CAL_SSHORTESTDAYNAME3 = 51;
pub const ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES = @as(c_long, 13932);
pub const DMPAPER_B_PLUS = 58;
pub const LogonUser = LogonUserA;
pub const EnumServicesStatus = EnumServicesStatusA;
pub const PROCESS_CREATION_MITIGATION_POLICY_CONTROL_FLOW_GUARD_ALWAYS_ON = if (@typeId(@typeOf(i64 << 40)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << 40) else if (@typeId(@typeOf(i64 << 40)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << 40) else @as(c_uint, 1)(i64 << 40);
pub const ERROR_INSTALL_USEREXIT = @as(c_long, 1602);
pub const ONE5STOPBITS = 1;
pub const ERROR_REQ_NOT_ACCEP = @as(c_long, 71);
pub const RpcServerUseProtseqEp = RpcServerUseProtseqEpA;
pub const METHOD_OUT_DIRECT = 2;
pub const CRYPTPROTECT_AUDIT = 16;
pub const MN_GETHMENU = 481;
pub const lstrcpy = lstrcpyA;
pub const MINLONG_PTR = ~MAXLONG_PTR;
pub const SIZEICONIC = SIZE_MINIMIZED;
pub const szOID_ECC_CURVE_BRAINPOOLP160R1 = "1.3.36.3.3.2.8.1.1.1";
pub const DNS_ERROR_DNSSEC_IS_DISABLED = @as(c_long, 9125);
pub const EMARCH_ENC_I17_IMM41c_INST_WORD_X = 2;
pub const ReadLongPtrNoFence = ReadNoFence64;
pub const DOMAIN_GROUP_RID_PROTECTED_USERS = @as(c_long, 525);
pub const szOID_RSA_SMIMEalg = "1.2.840.113549.1.9.16.3";
pub const PROCESS_CREATION_ALL_APPLICATION_PACKAGES_OPT_OUT = 1;
pub const JOYCAPS_POV4DIR = 32;
pub const IMAGE_REL_I386_SECREL = 11;
pub const SearchPath = SearchPathA;
pub const PLANES = 14;
pub const PPCAPS_BORDER_PRINT = 1;
pub const ACL_REVISION1 = 1;
pub const PRINTACTION_TESTPAGE = 4;
pub const CLIPBRD_E_FIRST = @as(c_long, 2147746256);
pub const LOAD_LIBRARY_OS_INTEGRITY_CONTINUITY = 32768;
pub const PC_RECTANGLE = 2;
pub const SBS_VERT = @as(c_long, 1);
pub const X3_D_WH_SIZE_X = 3;
pub const szOID_COUNTRY_NAME = "2.5.4.6";
pub const EFS_USE_RECOVERY_KEYS = 1;
pub const CMSG_HASHED_DATA_CMS_VERSION = CMSG_HASHED_DATA_V2;
pub const VK_GAMEPAD_A = 195;
pub const GET_FEATURE_FROM_THREAD = 1;
pub const RPC_P_ADDR_FORMAT_TCP_IPV6 = 2;
pub const SW_INVALIDATE = 2;
pub const szOID_RSA_extCertAttrs = "1.2.840.113549.1.9.9";
pub const CERT_CHAIN_ENABLE_TIMESTAMP_HYGIENE_FLAG = 268435456;
pub const szOID_USER_PASSWORD = "2.5.4.35";
pub const SCardListCards = SCardListCardsA;
pub const szOID_PIN_RULES_LOG_END_DATE_EXT = "1.3.6.1.4.1.311.10.3.35";
pub const DNS_ERROR_RCODE_NOTZONE = @as(c_long, 9010);
pub const JOB_OBJECT_LIMIT_JOB_READ_BYTES = 65536;
pub const PARAMFLAG_FHASCUSTDATA = 64;
pub const VK_F24 = 135;
pub const ERROR_CLOUD_FILE_AUTHENTICATION_FAILED = @as(c_long, 386);
pub const DNS_ERROR_FILE_WRITEBACK_FAILED = @as(c_long, 9654);
pub const GetTextExtentPoint32 = GetTextExtentPoint32A;
pub const ERROR_INSTALL_VOLUME_OFFLINE = @as(c_long, 15629);
pub const LOAD_LIBRARY_SAFE_CURRENT_DIRS = 8192;
pub const UnsignedMultiplyHigh = __umulh;
pub const MCI_INFO = 2058;
pub const ERROR_DS_COULDNT_CONTACT_FSMO = @as(c_long, 8367);
pub const MEM_EXTENDED_PARAMETER_TYPE_BITS = 8;
pub const GetCPInfoEx = GetCPInfoExA;
pub const ERROR_DS_MISSING_FOREST_TRUST = @as(c_long, 8649);
pub const PROCESSOR_ARCHITECTURE_UNKNOWN = 65535;
pub const ALG_CLASS_ALL = 7 << 13;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE = 2;
pub const CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL = 4;
pub const PRODUCT_PRO_SINGLE_LANGUAGE = 138;
pub const PKCS_CONTENT_INFO = if (@typeId(@typeOf(33)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 33) else if (@typeId(@typeOf(33)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 33) else LPCSTR(33);
pub const URLACTION_HTML_SUBMIT_FORMS_FROM = 5634;
pub const SC_ARRANGE = 61712;
pub const WM_VKEYTOITEM = 46;
pub const SYSTEM_PROCESS_TRUST_NOCONSTRAINT_MASK = 4294967295;
pub const ERROR_SXS_PROTECTION_CATALOG_NOT_VALID = @as(c_long, 14076);
pub const ERROR_ARITHMETIC_OVERFLOW = @as(c_long, 534);
pub const IPPORT_ECHO = 7;
pub const TRANSACTION_NOTIFY_ENLIST_MASK = 262144;
pub const VK_OEM_6 = 221;
pub const KDF_HASH_ALGORITHM = 0;
pub const SCHAR_MAX = 127;
pub const ERROR_OLD_WIN_VERSION = @as(c_long, 1150);
pub const PO_THROTTLE_CONSTANT = 1;
pub const VARIANT_TRUE = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(VARIANT_BOOL, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(VARIANT_BOOL, -1) else VARIANT_BOOL(-1);
pub const EMR_SETROP2 = 20;
pub const MDM_PROTOCOLID_V110 = 4;
pub const PROCESS_POWER_THROTTLING_EXECUTION_SPEED = 1;
pub const RPI_FLAG_SMB2_SHARECAP_SCALEOUT = 32;
pub const URL_OID_CERTIFICATE_ISSUER = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 1) else LPCSTR(1);
pub const __clang_version__ = "8.0.0 (tags/RELEASE_800/rc5)";
pub const MEMBERID_NIL = DISPID_UNKNOWN;
pub const PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALWAYS_OFF = if (@typeId(@typeOf(i64 << 44)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 2), i64 << 44) else if (@typeId(@typeOf(i64 << 44)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 2), i64 << 44) else @as(c_uint, 2)(i64 << 44);
pub const RIDEV_PAGEONLY = 32;
pub const ERROR_NOTIFICATION_GUID_ALREADY_DEFINED = @as(c_long, 309);
pub const DI_MEMORYMAP_WRITE = 1;
pub const CERT_CHAIN_AUTO_PINRULE_INFO = 5;
pub const stc12 = 1099;
pub const MCI_OVLY_STATUS_HWND = @as(c_long, 16385);
pub const GWL_WNDPROC = -4;
pub const OCSP_BASIC_GOOD_CERT_STATUS = 0;
pub const MUI_SKIP_STRING_CACHE = 8;
pub const GetCharWidth32 = GetCharWidth32A;
pub const WSAEDISCON = @as(c_long, 10101);
pub const CAL_GREGORIAN_US = 2;
pub const NCRYPTBUFFER_ATTESTATION_CLAIM_TYPE = 52;
pub const _WIN32_IE_IE60 = 1536;
pub const CRYPT_UPDATE_KEY = 8;
pub const PKCS7_SIGNER_INFO = if (@typeId(@typeOf(500)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 500) else if (@typeId(@typeOf(500)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 500) else LPCSTR(500);
pub const IACE_CHILDREN = 1;
pub const CLASSFACTORY_E_LAST = @as(c_long, 2147746079);
pub const DBG_EXCEPTION_HANDLED = if (@typeId(@typeOf(@as(c_long, 65537))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 65537)) else if (@typeId(@typeOf(@as(c_long, 65537))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 65537)) else DWORD(@as(c_long, 65537));
pub const RIDEV_EXINPUTSINK = 4096;
pub const IME_CHOTKEY_SHAPE_TOGGLE = 17;
pub const szKEY_CACHE_SECONDS = "PrivateKeyLifetimeSeconds";
pub const PIDDSI_HEADINGPAIR = 12;
pub const IMAGE_NT_OPTIONAL_HDR32_MAGIC = 267;
pub const PAN_WEIGHT_INDEX = 2;
pub const WM_SYSKEYDOWN = 260;
pub const SPI_GETDROPSHADOW = 4132;
pub const LGRPID_ARMENIAN = 17;
pub const NCRYPTBUFFER_TPM_SEAL_TICKET = 72;
pub const FILE_DEVICE_HOLOGRAPHIC = 91;
pub const VarIntFromDec = VarI4FromDec;
pub const OLEIVERB_OPEN = -@as(c_long, 2);
pub const STDMETHODCALLTYPE = __stdcall;
pub const VFT_FONT = @as(c_long, 4);
pub const CERT_LAST_RESERVED_PROP_ID = 32767;
pub const VER_PLATFORM_WIN32_NT = 2;
pub const EMR_DELETEOBJECT = 40;
pub const WNNC_NET_MSNET = 65536;
pub const __INT_FAST16_FMTi__ = "hi";
pub const FILE_DEVICE_DISK_FILE_SYSTEM = 8;
pub const FIND_FIRST_EX_ON_DISK_ENTRIES_ONLY = 4;
pub const ERROR_SXS_XML_E_BADPEREFINSUBSET = @as(c_long, 14059);
pub const MAX_VOLUME_TEMPLATE_SIZE = 40;
pub const HELP_SETINDEX = @as(c_long, 5);
pub const NCBFINDNAME = 120;
pub const ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE = @as(c_long, 2015);
pub const IP_DEFAULT_MULTICAST_TTL = 1;
pub const PRODUCT_ENTERPRISE_SERVER_IA64 = 15;
pub const PRODUCT_HOME_PREMIUM_N = 26;
pub const OFN_SHAREWARN = 0;
pub const PIPE_ACCESS_OUTBOUND = 2;
pub const FindFirstFileTransacted = FindFirstFileTransactedA;
pub const ERROR_DS_FOREST_VERSION_TOO_LOW = @as(c_long, 8565);
pub const STYLE_DESCRIPTION_SIZE = 32;
pub const PSWIZB_RESTORE = 1;
pub const VK_OEM_RESET = 233;
pub const __MOVBE__ = 1;
pub const PSD_ENABLEPAGEPAINTHOOK = 262144;
pub const ERROR_PATCH_TARGET_NOT_FOUND = @as(c_long, 1642);
pub const CMSG_OID_CNG_EXPORT_KEY_AGREE_FUNC = "CryptMsgDllCNGExportKeyAgree";
pub const szOID_ENROLL_EK_INFO = "1.3.6.1.4.1.311.21.23";
pub const IMAGE_REL_PPC_SECRELLO = 19;
pub const SMART_IDE_ERROR = 1;
pub const SO_OPENTYPE = 28680;
pub const BCRYPT_ECDSA_PRIVATE_P384_MAGIC = 877871941;
pub const IMAGE_REL_CEF_SECTION = 4;
pub const LANG_CHINESE_SIMPLIFIED = 4;
pub const VK_F23 = 134;
pub const __deref_inout_bcount_nz = size;
pub const NCRYPT_TPM_PSS_SALT_SIZE_HASHSIZE = 2;
pub const IACE_IGNORENOCONTEXT = 32;
pub const DNS_ERROR_RRL_INVALID_IPV6_PREFIX = @as(c_long, 9914);
pub const __SIZEOF_LONG__ = 4;
pub const LANG_ROMANIAN = 24;
pub const IMAGE_REL_SH_NOMODE = 32768;
pub const PF_HYLINK = AF_HYLINK;
pub const _IRQL_raises_ = irql;
pub const ERROR_SXS_ACTIVATION_CONTEXT_DISABLED = @as(c_long, 14006);
pub const DS_3DLOOK = @as(c_long, 4);
pub const IMAGE_REL_ARM_MOV32A = 16;
pub const TC_NORMAL = 0;
pub const IME_ITHOTKEY_RECONVERTSTRING = 515;
pub const ODS_FOCUS = 16;
pub const RPC_S_INVALID_NETWORK_OPTIONS = @as(c_long, 1724);
pub const STATE_SYSTEM_MIXED = 32;
pub const CERT_NAME_STR_DISABLE_IE4_UTF8_FLAG = 65536;
pub const SUBLANG_HEBREW_ISRAEL = 1;
pub const GM_LAST = 2;
pub const ERROR_DS_NAMING_MASTER_GC = @as(c_long, 8523);
pub const IME_ESC_SEQUENCE_TO_INTERNAL = 4097;
pub const COLOR_GRADIENTACTIVECAPTION = 27;
pub const READ_CONTROL = @as(c_long, 131072);
pub const FR_HIDEUPDOWN = 16384;
pub const MCI_GETDEVCAPS_HAS_VIDEO = @as(c_long, 3);
pub const TRANSACTION_NOTIFY_PREPARE_COMPLETE = 32;
pub const FILE_VOLUME_QUOTAS = 32;
pub const FindExecutable = FindExecutableA;
pub const SE_DACL_PRESENT = 4;
pub const CERT_CREATE_CONTEXT_NO_ENTRY_FLAG = 8;
pub const PROCESS_CREATION_MITIGATION_POLICY2_LOADER_INTEGRITY_CONTINUITY_ALWAYS_OFF = if (@typeId(@typeOf(i64 << 4)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 2), i64 << 4) else if (@typeId(@typeOf(i64 << 4)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 2), i64 << 4) else @as(c_uint, 2)(i64 << 4);
pub const VK_OEM_5 = 220;
pub const szOID_KEY_ATTRIBUTES = "2.5.29.2";
pub const ERROR_ABANDON_HIBERFILE = @as(c_long, 787);
pub const FR_ENABLETEMPLATE = 512;
pub const VP_TV_STANDARD_SECAM_L = 16384;
pub const ERROR_PIPE_CONNECTED = @as(c_long, 535);
pub const TCI_SRCCHARSET = 1;
pub const ENOTSOCK = 128;
pub const MIDI_CACHE_ALL = 1;
pub const PM_QS_PAINT = QS_PAINT << 16;
pub const IPPORT_NETSTAT = 15;
pub const EMBDHLP_CREATENOW = @as(c_long, 0);
pub const PF_ARM_64BIT_LOADSTORE_ATOMIC = 25;
pub const WriteULongPtrRaw = WriteULong64Raw;
pub const RpcStringFree = RpcStringFreeA;
pub const stc13 = 1100;
pub const ERROR_RESMON_ONLINE_FAILED = @as(c_long, 5018);
pub const AF_INET = 2;
pub const IMAGE_DEBUG_TYPE_OMAP_TO_SRC = 7;
pub const URLZONE_ESC_FLAG = 256;
pub const CF_NOSIMULATIONS = @as(c_long, 4096);
pub const MAX_HW_COUNTERS = 16;
pub const WNNC_NET_COGENT = 1114112;
pub const URLPOLICY_DONTCHECKDLGBOX = 256;
pub const CLAIM_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE = 2;
pub const MB_LEN_MAX = 5;
pub const LANG_CHINESE_TRADITIONAL = 31748;
pub const VerFindFile = VerFindFileA;
pub const DCX_CLIPCHILDREN = @as(c_long, 8);
pub const PRINTER_STATUS_OFFLINE = 128;
pub const PERF_QUERY_COSTLY = if (@typeId(@typeOf(2147483650)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG, 2147483650) else if (@typeId(@typeOf(2147483650)) == @import("builtin").TypeId.Int) @intToPtr(LONG, 2147483650) else LONG(2147483650);
pub const CRYPTPROTECT_PROMPT_STRONG = 8;
pub const NRC_NAMCONF = 25;
pub const SHTDN_REASON_MINOR_SERVICEPACK_UNINSTALL = 22;
pub const PROV_DSS_DH = 13;
pub const PRINTER_CHANGE_JOB = 65280;
pub const JOY_BUTTON28 = @as(c_long, 134217728);
pub const ERROR_DS_NAME_NOT_UNIQUE = @as(c_long, 8571);
pub const TAPE_LOGICAL_BLOCK = @as(c_long, 2);
pub const FRS_ERR_STARTING_SERVICE = @as(c_long, 8002);
pub const IMAGE_SUBSYSTEM_EFI_APPLICATION = 10;
pub const DNS_ERROR_POLICY_SCOPE_NOT_ALLOWED = @as(c_long, 9987);
pub const __RETURN_POLICY_SAME = _FunctionCall;
pub const NCBRECV = 21;
pub const ERROR_RESOURCE_NOT_AVAILABLE = @as(c_long, 5006);
pub const OFFLINE_STATUS_INCOMPLETE = 4;
pub const SUBLANG_OCCITAN_FRANCE = 1;
pub const CERT_FIND_KEY_SPEC = CERT_COMPARE_KEY_SPEC << CERT_COMPARE_SHIFT;
pub const CERT_STORE_SAVE_TO_FILENAME_A = 3;
pub const PROCESSOR_ARCHITECTURE_IA32_ON_ARM64 = 14;
pub const PROCESSOR_PERF_BOOST_MODE_MAX = PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE_AT_GUARANTEED;
pub const SPOOL_FILE_TEMPORARY = 2;
pub const PRINTER_ENUM_EXPAND = 16384;
pub const NOPARITY = 0;
pub const CFSTR_MIME_X_BITMAP = if (@typeId(@typeOf("image/x-xbitmap")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "image/x-xbitmap") else if (@typeId(@typeOf("image/x-xbitmap")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "image/x-xbitmap") else TEXT("image/x-xbitmap");
pub const JOB_CONTROL_RETAIN = 8;
pub const CHANGER_VOLUME_IDENTIFICATION = 1048576;
pub const PAN_MIDLINE_HIGH_SERIFED = 7;
pub const HSHELL_SYSMENU = 9;
pub const JOY_RETURNR = @as(c_long, 8);
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_STRING = 3;
pub const ERROR_SXS_PROTECTION_RECOVERY_FAILED = @as(c_long, 14074);
pub const CERT_RDN_T61_STRING = 5;
pub const ERROR_SERVICE_NEVER_STARTED = @as(c_long, 1077);
pub const MCI_OVLY_WINDOW_TEXT = @as(c_long, 524288);
pub const ACL_REVISION3 = 3;
pub const LoadMenu = LoadMenuA;
pub const ERROR_INVALID_BLOCK = @as(c_long, 9);
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_REUSED = 2;
pub const CM_SERVICE_VERIFIER_BOOT_LOAD = 64;
pub const SE_ERR_DDEFAIL = 29;
pub const _IRQL_always_function_min_ = irql;
pub const SHTDN_REASON_MINOR_SYSTEMRESTORE = 26;
pub const CLASSFACTORY_S_LAST = @as(c_long, 262431);
pub const ERROR_WOF_WIM_RESOURCE_TABLE_CORRUPT = @as(c_long, 4447);
pub const MCI_PUT = 2114;
pub const MNS_NOCHECK = 2147483648;
pub const LCMAP_BYTEREV = 2048;
pub const VarUI2FromUint = VarUI2FromUI4;
pub const BCRYPT_DSA_PRIVATE_MAGIC_V2 = 844517444;
pub const CERT_TRUST_HAS_NOT_SUPPORTED_NAME_CONSTRAINT = 4096;
pub const INT_MIN = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-2147483647, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-2147483647, -1) else (-2147483647)(-1);
pub const LANG_BOSNIAN = 26;
pub const PSH_PROPTITLE = 1;
pub const PROCESSOR_ARCHITECTURE_AMD64 = 9;
pub const RPC_S_INVALID_ARG = ERROR_INVALID_PARAMETER;
pub const NRC_DUPENV = 48;
pub const PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_ALLOW_STORE = if (@typeId(@typeOf(i64 << 44)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 44) else if (@typeId(@typeOf(i64 << 44)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 44) else @as(c_uint, 3)(i64 << 44);
pub const CreateDesktop = CreateDesktopA;
pub const ERROR_STATE_OPEN_CONTAINER_FAILED = @as(c_long, 15804);
pub const VK_F22 = 133;
pub const ERROR_DIRECT_ACCESS_HANDLE = @as(c_long, 130);
pub const LOCALE_ALLOW_NEUTRAL_NAMES = 134217728;
pub const X3_IMM39_2_SIGN_VAL_POS_X = 20;
pub const ERROR_NOT_SUPPORTED_ON_SBS = @as(c_long, 1254);
pub const MB_HELP = @as(c_long, 16384);
pub const LBS_OWNERDRAWFIXED = @as(c_long, 16);
pub const MUI_FILETYPE_LANGUAGE_NEUTRAL_MUI = 4;
pub const ERROR_IPSEC_IKE_QM_ACQUIRE_DROP = @as(c_long, 13810);
pub const VK_DELETE = 46;
pub const DRV_OPEN = 3;
pub const CERT_STORE_ADD_NEWER_INHERIT_PROPERTIES = 7;
pub const IDIGNORE = 5;
pub const FOREST_USER_RID_MAX = @as(c_long, 499);
pub const HCF_HIGHCONTRASTON = 1;
pub const RPC_S_TIMEOUT = ERROR_TIMEOUT;
pub const RGN_MAX = RGN_COPY;
pub const MDM_PROTOCOLID_X75 = 3;
pub const STREAM_CLEAR_ENCRYPTION = 4;
pub const MAP_FOLDDIGITS = 128;
pub const ERROR_CTX_ACCOUNT_RESTRICTION = @as(c_long, 7064);
pub const ERROR_DISK_REPAIR_REDIRECTED = @as(c_long, 792);
pub const RPC_X_WRONG_STUB_VERSION = @as(c_long, 1829);
pub const VK_OEM_4 = 219;
pub const CERT_COMPARE_EXISTING = 13;
pub const CERT_SIGN_HASH_CNG_ALG_PROP_ID = 89;
pub const SET_BACKGROUND_COLOR = 4103;
pub const SPACEPARITY = 4;
pub const VFT2_DRV_SOUND = @as(c_long, 9);
pub const SW_SHOWDEFAULT = 10;
pub const WOF_CURRENT_VERSION = 1;
pub const AnsiLower = CharLowerA;
pub const MCI_STATUS_READY = @as(c_long, 7);
pub const PKCS_SORTED_CTL = if (@typeId(@typeOf(49)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 49) else if (@typeId(@typeOf(49)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 49) else LPCSTR(49);
pub const ERROR_BAD_QUERY_SYNTAX = @as(c_long, 1615);
pub const HTCLOSE = 20;
pub const SMART_INVALID_IOCTL = 6;
pub const stc10 = 1097;
pub const SE_GROUP_ENABLED_BY_DEFAULT = @as(c_long, 2);
pub const SKF_HOTKEYACTIVE = 4;
pub const DMPAPER_ESHEET = 26;
pub const CERT_ACCESS_STATE_PROP_ID = 14;
pub const VAR_FOURDIGITYEARS = if (@typeId(@typeOf(64)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 64) else if (@typeId(@typeOf(64)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 64) else DWORD(64);
pub const SERVICE_TRIGGER_DATA_TYPE_STRING = 2;
pub const LOCALE_SSHORTTIME = 121;
pub const PF_RDRAND_INSTRUCTION_AVAILABLE = 28;
pub const _Writable_elements_impl_ = size;
pub const HTBOTTOM = 15;
pub const InterlockedIncrementAcquire = _InterlockedIncrement;
pub const LANG_MALTESE = 58;
pub const MAXULONG64 = if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(ULONG64, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(ULONG64, 0) else ULONG64(0))) == @import("builtin").TypeId.Pointer) @ptrCast(ULONG64, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(ULONG64, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(ULONG64, 0) else ULONG64(0)) else if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(ULONG64, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(ULONG64, 0) else ULONG64(0))) == @import("builtin").TypeId.Int) @intToPtr(ULONG64, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(ULONG64, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(ULONG64, 0) else ULONG64(0)) else ULONG64(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(ULONG64, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(ULONG64, 0) else ULONG64(0));
pub const GCP_DIACRITIC = 256;
pub const READ_ATTRIBUTES = 208;
pub const SPI_SETFILTERKEYS = 51;
pub const RPC_C_AUTHZ_NONE = 0;
pub const STATUS_ENCLAVE_VIOLATION = if (@typeId(@typeOf(@as(c_long, 3221226658))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221226658)) else if (@typeId(@typeOf(@as(c_long, 3221226658))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221226658)) else DWORD(@as(c_long, 3221226658));
pub const ACTIVATION_CONTEXT_SECTION_WINRT_ACTIVATABLE_CLASSES = 12;
pub const ERROR_LOG_READ_CONTEXT_INVALID = @as(c_long, 6606);
pub const ERROR_BAD_ACCESSOR_FLAGS = @as(c_long, 773);
pub const SECURITY_PROCESS_PROTECTION_LEVEL_AUTHENTICODE_RID = @as(c_long, 1024);
pub const JOY_BUTTON29 = @as(c_long, 268435456);
pub const MCI_STATUS_NUMBER_OF_TRACKS = @as(c_long, 3);
pub const CMSG_KEY_AGREE_ORIGINATOR_CERT = 1;
pub const PROCESS_SET_QUOTA = 256;
pub const MMIO_REMOVEPROC = 131072;
pub const MCI_OVLY_WINDOW_DEFAULT = @as(c_long, 0);
pub const POPENCARDNAMEA_EX = POPENCARDNAME_EXA;
pub const BST_PUSHED = 4;
pub const CRYPT_MACHINE_KEYSET = 32;
pub const GCS_RESULTREADSTR = 512;
pub const ILLUMINANT_D65 = 6;
pub const SUBLANG_SYRIAC_SYRIA = 1;
pub const ERROR_CONTENT_BLOCKED = @as(c_long, 1296);
pub const SO_DONTROUTE = 16;
pub const UPDFCACHE_ALL = if (@typeId(@typeOf(~UPDFCACHE_ONLYIFBLANK)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, ~UPDFCACHE_ONLYIFBLANK) else if (@typeId(@typeOf(~UPDFCACHE_ONLYIFBLANK)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, ~UPDFCACHE_ONLYIFBLANK) else DWORD(~UPDFCACHE_ONLYIFBLANK);
pub const WNNC_NET_FARALLON = 1179648;
pub const CMSG_INNER_CONTENT_TYPE_PARAM = 4;
pub const POINTER_FLAG_FIRSTBUTTON = 16;
pub const FILE_ATTRIBUTE_RECALL_ON_OPEN = 262144;
pub const DRV_REMOVE = 10;
pub const IMAGE_REL_CEF_ABSOLUTE = 0;
pub const ERROR_DS_OBJ_NOT_FOUND = @as(c_long, 8333);
pub const ENOLCK = 39;
pub const _User_always_and_needs_probe_on_ = mode;
pub const MCI_ANIM_WINDOW_DISABLE_STRETCH = @as(c_long, 2097152);
pub const DeletePrinterDriver = DeletePrinterDriverA;
pub const WN_BAD_USER = ERROR_BAD_USERNAME;
pub const CB_GETLBTEXT = 328;
pub const PBT_POWERSETTINGCHANGE = 32787;
pub const HTREDUCE = HTMINBUTTON;
pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE = @as(c_long, 14090);
pub const STGFMT_ANY = 4;
pub const ERROR_EVT_INVALID_QUERY = @as(c_long, 15001);
pub const AUXCAPS_CDAUDIO = 1;
pub const HEAP_CREATE_ENABLE_TRACING = 131072;
pub const __precond = expr;
pub const GPT_BASIC_DATA_ATTRIBUTE_HIDDEN = 4611686018427387904;
pub const PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_ALWAYS_OFF = 2 << 24;
pub const CONSOLE_NO_SELECTION = 0;
pub const MB_ICONMASK = @as(c_long, 240);
pub const ERROR_DS_INCOMPATIBLE_CONTROLS_USED = @as(c_long, 8574);
pub const ACL_REVISION2 = 2;
pub const TRANSACTION_NOTIFY_PREPARE = 2;
pub const NCRYPT_ECDH_P384_ALGORITHM = BCRYPT_ECDH_P384_ALGORITHM;
pub const VOS__WINDOWS32 = @as(c_long, 4);
pub const CAL_UMALQURA = 23;
pub const MCI_ANIM_PLAY_SLOW = @as(c_long, 524288);
pub const WH_MIN = -1;
pub const PKCS12_ALWAYS_CNG_KSP = 512;
pub const AF_DATAKIT = 9;
pub const NCBCANCEL = 53;
pub const EXPO_OFFLOAD_REG_VALUE = "ExpoOffload";
pub const SM_CYSMCAPTION = 51;
pub const SERIAL_IOC_MCR_OUT1 = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 4) else DWORD(4);
pub const MCI_SYSINFO = 2064;
pub const ERROR_CLUSTER_NETINTERFACE_NOT_FOUND = @as(c_long, 5047);
pub const DISPLAY_DEVICE_UNSAFE_MODES_ON = 524288;
pub const DEVICEDUMP_CAP_RESTRICTED_SECTION = 2;
pub const CRYPT_MM = 3;
pub const sz_CERT_STORE_PROV_FILENAME_W = "File";
pub const ERROR_EVT_QUERY_RESULT_STALE = @as(c_long, 15011);
pub const __drv_isCancelIRQL = _IRQL_is_cancel_;
pub const OemToAnsi = OemToCharA;
pub const PRODUCT_EMBEDDED_INDUSTRY_A = 86;
pub const SWP_NOOWNERZORDER = 512;
pub const LoadIcon = LoadIconA;
pub const ERROR_CORRUPT_LOG_DELETED_FULL = @as(c_long, 797);
pub const OF_EXIST = 16384;
pub const C2_ARABICNUMBER = 6;
pub const SUBLANG_SPANISH_PANAMA = 6;
pub const TRANSACTION_NOTIFY_REQUEST_OUTCOME = 536870912;
pub const STDAPICALLTYPE = __stdcall;
pub const VK_F21 = 132;
pub const CERT_STORE_PROV_READ_CTL_FUNC = 9;
pub const REG_FORCE_RESTORE = @as(c_long, 8);
pub const VarI4FromUint = VarI4FromUI4;
pub const OInetCombineUrl = CoInternetCombineUrl;
pub const URLACTION_HTML_ALLOW_INDEXEDDB = 5649;
pub const RPC_BINDING_HANDLE_SECURITY_V1 = RPC_BINDING_HANDLE_SECURITY_V1_A;
pub const SO_DISCDATA = 28674;
pub const CERT_ROOT_PROGRAM_FLAG_OU = 16;
pub const FOF_RENAMEONCOLLISION = 8;
pub const DeleteFileTransacted = DeleteFileTransactedA;
pub const CERT_CLOSE_STORE_FORCE_FLAG = 1;
pub const PROV_EC_ECNRA_FULL = 17;
pub const PSCARD_READERSTATE_A = PSCARD_READERSTATEA;
pub const APPCOMMAND_REDO = 35;
pub const ERROR_LOG_SECTOR_INVALID = @as(c_long, 6600);
pub const BS_CENTER = @as(c_long, 768);
pub const IMAGE_REL_PPC_ADDR24 = 3;
pub const MB_ERR_INVALID_CHARS = 8;
pub const ACCESS_DENIED_ACE_TYPE = 1;
pub const CAL_SENGLISHABBREVERANAME = 60;
pub const IMFT_SEPARATOR = 2;
pub const MIXERLINE_COMPONENTTYPE_SRC_FIRST = @as(c_long, 4096);
pub const ERROR_DS_OBJ_TOO_LARGE = @as(c_long, 8312);
pub const PORT_TYPE_NET_ATTACHED = 8;
pub const EVENT_OBJECT_DRAGCOMPLETE = 32803;
pub const SID_SInternetSecurityManager = IID_IInternetSecurityManager;
pub const HELP_MULTIKEY = @as(c_long, 513);
pub const VK_OEM_WSCTRL = 238;
pub const X509_KEYGEN_REQUEST_TO_BE_SIGNED = if (@typeId(@typeOf(21)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 21) else if (@typeId(@typeOf(21)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 21) else LPCSTR(21);
pub const EWX_HYBRID_SHUTDOWN = 4194304;
pub const HW_PROFILE_GUIDLEN = 39;
pub const CHANGER_VOLUME_UNDEFINE = 16777216;
pub const PRINTER_STATUS_ERROR = 2;
pub const PRINTACTION_OPEN = 0;
pub const VK_OEM_3 = 192;
pub const NCRYPT_ALLOW_PLAINTEXT_ARCHIVING_FLAG = 8;
pub const ERROR_FLOPPY_VOLUME = @as(c_long, 584);
pub const VP_TV_STANDARD_SECAM_B = 256;
pub const SERVICE_STOP_REASON_MAJOR_NONE = 393216;
pub const DNS_ERROR_DP_DOES_NOT_EXIST = @as(c_long, 9901);
pub const BCRYPT_CAPI_KDF_ALG_HANDLE = if (@typeId(@typeOf(801)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 801) else if (@typeId(@typeOf(801)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 801) else BCRYPT_ALG_HANDLE(801);
pub const LPOINETPROTOCOLROOT = LPIINTERNETPROTOCOLROOT;
pub const SEF_MACL_NO_WRITE_UP = 256;
pub const TIMERV_COALESCING_MAX = 2147483637;
pub const NIM_DELETE = 2;
pub const SHRT_MAX = 32767;
pub const IME_CMODE_CHARCODE = 32;
pub const SPI_SETPENSIDEMOVETHRESHOLD = 139;
pub const PRODUCT_EMBEDDED_E = 90;
pub const IME_CONFIG_GENERAL = 1;
pub const SETMITERLIMIT = 23;
pub const IO_REPARSE_TAG_WCI = @as(c_long, 2147483672);
pub const ERROR_DEPLOYMENT_BLOCKED_BY_PROFILE_POLICY = @as(c_long, 15651);
pub const stc11 = 1098;
pub const IMAGE_REL_THUMB_BRANCH20 = 18;
pub const URLACTION_FEATURE_MIME_SNIFFING = 8448;
pub const MEM_PRESERVE_PLACEHOLDER = 2;
pub const VER_SUITE_MULTIUSERTS = 131072;
pub const MSGF_NEXTWINDOW = 6;
pub const SUBLANG_MALTESE_MALTA = 1;
pub const WNNC_NET_DISTINCT = 2293760;
pub const GCLP_WNDPROC = -24;
pub const STARTF_TITLEISLINKNAME = 2048;
pub const LR_SHARED = 32768;
pub const SKF_RCTLLOCKED = 524288;
pub const APPCOMMAND_BROWSER_FAVORITES = 6;
pub const COLOR_INFOTEXT = 23;
pub const IMAGE_REL_IA64_LTOFF22 = 10;
pub const S_PERIOD1024 = 1;
pub const ERROR_SEM_TIMEOUT = @as(c_long, 121);
pub const CDERR_FINDRESFAILURE = 6;
pub const Uri_HAS_QUERY = 1 << Uri_PROPERTY_QUERY;
pub const LOCALE_INEGSIGNPOSN = 83;
pub const SUBLANG_ARABIC_BAHRAIN = 15;
pub const RPC_S_NO_ENTRY_NAME = @as(c_long, 1735);
pub const MIXERCONTROL_CT_UNITS_SIGNED = @as(c_long, 131072);
pub const OPLOCK_LEVEL_CACHE_READ = 1;
pub const ERROR_ABANDONED_WAIT_63 = @as(c_long, 736);
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE = 30;
pub const WAVECAPS_VOLUME = 4;
pub const szOID_CMC_GET_CERT = "1.3.6.1.5.5.7.7.15";
pub const MCI_OVLY_GETDEVCAPS_CAN_STRETCH = @as(c_long, 16385);
pub const CRYPT_EXPORT = 4;
pub const IPDFP_COPY_ALL_FILES = 1;
pub const CERT_LOGOTYPE_BITS_IMAGE_RESOLUTION_CHOICE = 1;
pub const BCRYPT_ECDSA_PUBLIC_P384_MAGIC = 861094725;
pub const CRYPT_STRING_BASE64X509CRLHEADER = 9;
pub const TAPE_FILEMARKS = @as(c_long, 1);
pub const CMSG_INDEFINITE_LENGTH = 4294967295;
pub const PRODUCT_ENTERPRISE_S_N_EVALUATION = 130;
pub const COLORMGMTCAPS = 121;
pub const CS_DROPSHADOW = 131072;
pub const DEVICE_DSM_PARAMETERS_V1 = 1;
pub const USN_SOURCE_CLIENT_REPLICATION_MANAGEMENT = 8;
pub const CERT_SHA1_HASH_PROP_ID = 3;
pub const ERROR_INVALID_HOOK_FILTER = @as(c_long, 1426);
pub const DMPAPER_JENV_YOU4 = 91;
pub const szOID_CRL_VIRTUAL_BASE = "1.3.6.1.4.1.311.21.3";
pub const SOUND_SYSTEM_RESTOREDOWN = 11;
pub const ERROR_CHECKOUT_REQUIRED = @as(c_long, 221);
pub const SPI_GETICONTITLEWRAP = 25;
pub const LGRPID_TURKIC = 6;
pub const IMAGE_REL_IA64_ABSOLUTE = 0;
pub const ERROR_EVT_INVALID_PUBLISHER_NAME = @as(c_long, 15004);
pub const MDM_SHIFT_AUTO_ML = 6;
pub const CORE_PARKING_POLICY_CHANGE_IDEAL = 0;
pub const FKF_AVAILABLE = 2;
pub const TC_PUBLIC_DEVICEDUMP_CONTENT_SMART = 1;
pub const MOD_SQSYNTH = 3;
pub const UnsignedMultiply128 = _umul128;
pub const ERROR_WMI_INSTANCE_NOT_FOUND = @as(c_long, 4201);
pub const WM_GETTEXT = 13;
pub const ASYNCH = 128;
pub const ERROR_PASSWORD_RESTRICTION = @as(c_long, 1325);
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_QUERY_TYPE = @as(c_long, 9995);
pub const FILE_DISPOSITION_FLAG_ON_CLOSE = 8;
pub const __GOT_SECURE_LIB__ = __STDC_SECURE_LIB__;
pub const ERROR_INVALID_PLUGPLAY_DEVICE_PATH = @as(c_long, 620);
pub const META_POLYPOLYGON = 1336;
pub const CRYPT_RETRIEVE_MAX_ERROR_CONTENT_LENGTH = 4096;
pub const FF_SWISS = 2 << 4;
pub const CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG = 2;
pub const LANG_KICHE = 134;
pub const IMAGE_REL_IA64_SREL22 = 18;
pub const ENABLE_WRAP_AT_EOL_OUTPUT = 2;
pub const ERROR_SXS_XML_E_UNCLOSEDSTARTTAG = @as(c_long, 14060);
pub const ERROR_INSTALL_RESOLVE_DEPENDENCY_FAILED = @as(c_long, 15603);
pub const MCI_ANIM_REALIZE_NORM = @as(c_long, 65536);
pub const CRYPT_SGCKEY = 8192;
pub const CERT_STORE_CTRL_COMMIT_CLEAR_FLAG = 2;
pub const DFCS_CAPTIONMIN = 1;
pub const TOUCHEVENTF_PRIMARY = 16;
pub const DEVICE_DSM_RANGE_ERROR_OUTPUT_V1 = 1;
pub const FINDMSGSTRING = FINDMSGSTRINGA;
pub const BS_TYPEMASK = @as(c_long, 15);
pub const TCI_SRCCODEPAGE = 2;
pub const APPCOMMAND_BASS_BOOST = 20;
pub const ERROR_VOLUME_NOT_SUPPORT_EFS = @as(c_long, 6014);
pub const __DBL_EPSILON__ = 0.000000;
pub const BSM_VXDS = 1;
pub const SetFileAttributesTransacted = SetFileAttributesTransactedA;
pub const VK_F20 = 131;
pub const HWND_BROADCAST = if (@typeId(@typeOf(65535)) == @import("builtin").TypeId.Pointer) @ptrCast(HWND, 65535) else if (@typeId(@typeOf(65535)) == @import("builtin").TypeId.Int) @intToPtr(HWND, 65535) else HWND(65535);
pub const ERROR_NOT_ALL_ASSIGNED = @as(c_long, 1300);
pub const EWX_FORCEIFHUNG = 16;
pub const __INT16_FMTi__ = "hi";
pub const InterlockedExchangePointerNoFence = _InterlockedExchangePointer;
pub const ERROR_INSTALL_VOLUME_CORRUPT = @as(c_long, 15630);
pub const URLACTION_HTML_ALLOW_CROSS_DOMAIN_CANVAS = 5645;
pub const DWL_DLGPROC = 4;
pub const IMAGE_ROM_OPTIONAL_HDR_MAGIC = 263;
pub const FMTID_NULL = GUID_NULL;
pub const DISPLAY_DEVICE_MODESPRUNED = 134217728;
pub const WM_CANCELJOURNAL = 75;
pub const BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG = 1073741824;
pub const WNNC_NET_TWINS = 2359296;
pub const ERROR_DEBUG_ATTACH_FAILED = @as(c_long, 590);
pub const SETCHARSET = 772;
pub const FRAME_TSS = 2;
pub const LGRPID_CENTRAL_EUROPE = 2;
pub const CERT_CHAIN_THREAD_STORE_SYNC = 2;
pub const TME_LEAVE = 2;
pub const ERROR_OPLOCK_HANDLE_CLOSED = @as(c_long, 803);
pub const PROCESSOR_ARCHITECTURE_ALPHA = 2;
pub const HANDLE_FLAG_PROTECT_FROM_CLOSE = 2;
pub const SUBLANG_FRENCH_LUXEMBOURG = 5;
pub const SM_CXSMICON = 49;
pub const FIND_RESOURCE_DIRECTORY_TYPES = 256;
pub const META_SETMAPMODE = 259;
pub const CERT_CHAIN_AUTO_PROCESS_INFO = 4;
pub const VK_OEM_2 = 191;
pub const POWER_ACTION_DIRECTED_DRIPS = 67108864;
pub const IMAGE_REL_ALPHA_REFLO = 11;
pub const USN_REASON_ENCRYPTION_CHANGE = 262144;
pub const BCRYPT_DH_PRIVATE_MAGIC = 1448101956;
pub const MCI_SPIN = 2060;
pub const RPCFLG_ASYNCHRONOUS = @as(c_ulong, 1073741824);
pub const ERROR_LOG_ARCHIVE_IN_PROGRESS = @as(c_long, 6633);
pub const PBTF_APMRESUMEFROMFAILURE = 1;
pub const ES_WANTRETURN = @as(c_long, 4096);
pub const ERROR_BAD_FUNCTION_TABLE = @as(c_long, 559);
pub const SHIL_SYSSMALL = 3;
pub const BCRYPT_3DES_112_ECB_ALG_HANDLE = if (@typeId(@typeOf(385)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 385) else if (@typeId(@typeOf(385)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 385) else BCRYPT_ALG_HANDLE(385);
pub const ERROR_NOT_QUORUM_CLASS = @as(c_long, 5025);
pub const RpcNsGroupMbrInqBegin = RpcNsGroupMbrInqBeginA;
pub const TAPE_DRIVE_ABSOLUTE_BLK = 2147487744;
pub const ERROR_SXS_XML_E_BADSTARTNAMECHAR = @as(c_long, 14032);
pub const SMART_WRITE_LOG = 214;
pub const ICM_ON = 2;
pub const ACTIVATION_CONTEXT_PATH_TYPE_ASSEMBLYREF = 4;
pub const SPI_SETBEEP = 2;
pub const CONSOLE_FULLSCREEN = 1;
pub const EV_BREAK = 64;
pub const ARW_DOWN = @as(c_long, 4);
pub const SERVICE_TRIGGER_TYPE_DEVICE_INTERFACE_ARRIVAL = 1;
pub const AW_VER_POSITIVE = 4;
pub const SEMAPHORE_MODIFY_STATE = 2;
pub const CERT_NON_REPUDIATION_KEY_USAGE = 64;
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG = @as(c_long, 8581);
pub const IOInetProtocolInfo = IInternetProtocolInfo;
pub const szOID_ECC_CURVE_SECP192R1 = szOID_ECC_CURVE_NISTP192;
pub const EV_EVENT1 = 2048;
pub const NCBTRACE = 121;
pub const InterlockedIncrementRelease16 = _InterlockedIncrement16;
pub const SERIAL_IOC_MCR_LOOP = if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 16) else if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 16) else DWORD(16);
pub const ERROR_LOG_DEDICATED = @as(c_long, 6631);
pub const EMR_EXTTEXTOUTA = 83;
pub const DNS_ERROR_RCODE_BADKEY = @as(c_long, 9017);
pub const ERROR_BUFFER_OVERFLOW = @as(c_long, 111);
pub const ERROR_DEPLOYMENT_FAILED_CONFLICTING_MUTABLE_PACKAGE_DIRECTORY = @as(c_long, 15652);
pub const COLOROKSTRINGA = "commdlg_ColorOK";
pub const PERF_NO_INSTANCES = -1;
pub const FILE_PROVIDER_COMPRESSION_XPRESS4K = 0;
pub const RESOURCE_CONNECTED = 1;
pub const DOMAIN_ALIAS_RID_MONITORING_USERS = @as(c_long, 558);
pub const SIZENORMAL = SIZE_RESTORED;
pub const IO_REPARSE_TAG_DFS = @as(c_long, 2147483658);
pub const EN_BEFORE_PASTE = 2048;
pub const PRODUCT_CLOUD = 178;
pub const DELETE = @as(c_long, 65536);
pub const MIM_MOREDATA = MM_MIM_MOREDATA;
pub const DEVICE_TYPE = DWORD;
pub const SM_CXMAXTRACK = 59;
pub const MUI_RESET_FILTERS = 1;
pub const MDM_FLOWCONTROL_HARD = 16;
pub const ERROR_STORAGE_RESERVE_DOES_NOT_EXIST = @as(c_long, 417);
pub const ERROR_SXS_XML_E_INTERNALERROR = @as(c_long, 14041);
pub const URLACTION_ALLOW_AUDIO_VIDEO_PLUGINS = 9988;
pub const RESOURCEMANAGER_COMPLETE_PROPAGATION = 64;
pub const VK_CAPITAL = 20;
pub const VER_NT_WORKSTATION = 1;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_X = 32;
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE_AT_GUARANTEED = 5;
pub const __STDC_SECURE_LIB__ = @as(c_long, 200411);
pub const EFS_COMPATIBILITY_VERSION_PFILE_PROTECTOR = 6;
pub const SUBLANG_BENGALI_BANGLADESH = 2;
pub const IMAGE_REL_ARM64_PAGEOFFSET_12L = 7;
pub const __POPCNT__ = 1;
pub const STGFMT_STORAGE = 0;
pub const IMFS_UNHILITE = MFS_UNHILITE;
pub const JOY_RETURNU = @as(c_long, 16);
pub const _RPC_BINDING_HANDLE_SECURITY_V1 = _RPC_BINDING_HANDLE_SECURITY_V1_A;
pub const PROCESS_CREATION_DESKTOP_APP_BREAKAWAY_ENABLE_PROCESS_TREE = 1;
pub const __UINT_LEAST32_FMTu__ = "u";
pub const URLACTION_FEATURE_FORCE_ADDR_AND_STATUS = 8452;
pub const DNS_ERROR_GENERAL_API_BASE = 9550;
pub const CERT_TRUST_HAS_WEAK_HYGIENE = 2097152;
pub const VER_SUITE_ENTERPRISE = 2;
pub const DEVICEFAMILYDEVICEFORM_NETWORKING = 23;
pub const ACL_REVISION4 = 4;
pub const WTS_CONSOLE_CONNECT = 1;
pub const CERT_SELECT_BY_TLS_SIGNATURES = 11;
pub const RegOpenKeyTransacted = RegOpenKeyTransactedA;
pub const PRINTDLGORD = 1538;
pub const CERT_INFO_VERSION_FLAG = 1;
pub const SWP_DEFERERASE = 8192;
pub const FAST_FAIL_INVALID_NEXT_THREAD = 30;
pub const SPI_SETTOOLTIPANIMATION = 4119;
pub const Uri_HAS_PATH_AND_QUERY = 1 << Uri_PROPERTY_PATH_AND_QUERY;
pub const TAPE_DRIVE_SET_PADDING = 2147484672;
pub const SPI_GETACTIVEWINDOWTRACKING = 4096;
pub const ERROR_RETRY = @as(c_long, 1237);
pub const PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_DEFER = 0 << 24;
pub const ERROR_DS_SAM_INIT_FAILURE_CONSOLE = @as(c_long, 8562);
pub const PRODUCT_BUSINESS_N = 16;
pub const MOVEFILE_WRITE_THROUGH = 8;
pub const CMC_OTHER_INFO_NO_CHOICE = 0;
pub const CERT_QUERY_CONTENT_CTL = 2;
pub const CREATE_SHARED_WOW_VDM = 4096;
pub const ALG_SID_SHA_512 = 14;
pub const RPC_BHO_DONTLINGER = 2;
pub const URLACTION_INPRIVATE_BLOCKING = 9984;
pub const URLACTION_SCRIPT_OVERRIDE_SAFETY = 5121;
pub const BCRYPT_TLS1_2_KDF_ALG_HANDLE = if (@typeId(@typeOf(881)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 881) else if (@typeId(@typeOf(881)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 881) else BCRYPT_ALG_HANDLE(881);
pub const VK_HELP = 47;
pub const SERVICE_CONTROL_STATUS_REASON_INFO = 1;
pub const PRODUCT_CORE_ARM = 97;
pub const RASTER_FONTTYPE = 1;
pub const CFSTR_MIME_TTML = if (@typeId(@typeOf("application/ttml+xml")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "application/ttml+xml") else if (@typeId(@typeOf("application/ttml+xml")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "application/ttml+xml") else TEXT("application/ttml+xml");
pub const ERROR_CLUSTER_RESOURCE_CONTAINS_UNSUPPORTED_DIFF_AREA_FOR_SHARED_VOLUMES = @as(c_long, 5969);
pub const GCS_COMPCLAUSE = 32;
pub const BCRYPT_ECDH_PUBLIC_P256_MAGIC = 827016005;
pub const ERROR_DS_NOT_ON_BACKLINK = @as(c_long, 8362);
pub const CREATE_BOUNDARY_DESCRIPTOR_ADD_APPCONTAINER_SID = 1;
pub const EMR_STROKEANDFILLPATH = 63;
pub const STORAGE_INFO_FLAGS_PARTITION_ALIGNED_ON_DEVICE = 2;
pub const IMAGE_REL_IA64_IMM22 = 2;
pub const SUBLANG_SPANISH_GUATEMALA = 4;
pub const SEC_RESERVE = 67108864;
pub const LANG_ARABIC = 1;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_EFS_ATTRIBUTE = 1024;
pub const WM_PSD_PAGESETUPDLG = WM_USER;
pub const GCP_ERROR = 32768;
pub const RpcMgmtInqServerPrincName = RpcMgmtInqServerPrincNameA;
pub const ERROR_CAPAUTHZ_SCCD_DEV_MODE_REQUIRED = @as(c_long, 459);
pub const VK_OEM_1 = 186;
pub const CWP_ALL = 0;
pub const ERROR_LOG_PINNED = @as(c_long, 6644);
pub const TIMESTAMP_FAILURE_SYSTEM_FAILURE = 25;
pub const ERROR_MEDIA_INCOMPATIBLE = @as(c_long, 4315);
pub const LANG_MANIPURI = 88;
pub const LMEM_ZEROINIT = 64;
pub const SOUND_SYSTEM_QUESTION = 5;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_MIN = 0.900000;
pub const EXCEPTION_BREAKPOINT = STATUS_BREAKPOINT;
pub const DC_PRINTRATE = 26;
pub const VK_OEM_COPY = 242;
pub const SUBLANG_UZBEK_LATIN = 1;
pub const PAGE_EXECUTE_READWRITE = 64;
pub const ERROR_LINUX_SUBSYSTEM_NOT_PRESENT = @as(c_long, 414);
pub const SM_CXEDGE = 45;
pub const DMPAPER_A4_EXTRA = 53;
pub const PID_DICTIONARY = 0;
pub const OLECREATE_LEAVERUNNING = 1;
pub const LOCALE_INEGNUMBER = 4112;
pub const PD_SELECTION = 1;
pub const ERROR_SXS_UNKNOWN_ENCODING = @as(c_long, 14013);
pub const InterlockedBitTestAndResetNoFence = _interlockedbittestandreset;
pub const CMSG_OID_CAPI1_EXPORT_KEY_AGREE_FUNC = CMSG_OID_EXPORT_KEY_AGREE_FUNC;
pub const PAN_LETT_OBLIQUE_BOXED = 11;
pub const EMR_COLORMATCHTOTARGETW = 121;
pub const MDM_HDLCPPP_ML_DEFAULT = 0;
pub const MIM_MENUDATA = 8;
pub const ERROR_NO_SUCH_USER = @as(c_long, 1317);
pub const FRS_ERR_INVALID_SERVICE_PARAMETER = @as(c_long, 8017);
pub const MapVirtualKeyEx = MapVirtualKeyExA;
pub const szOID_ECC_CURVE_P521 = "1.3.132.0.35";
pub const LPOPENCARDNAME_A = LPOPENCARDNAMEA;
pub const WS_ICONIC = WS_MINIMIZE;
pub const PROCESS_CREATION_MITIGATION_POLICY2_LOADER_INTEGRITY_CONTINUITY_ALWAYS_ON = if (@typeId(@typeOf(i64 << 4)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << 4) else if (@typeId(@typeOf(i64 << 4)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << 4) else @as(c_uint, 1)(i64 << 4);
pub const WRITE_DAC = @as(c_long, 262144);
pub const ERROR_ALLOTTED_SPACE_EXCEEDED = @as(c_long, 1344);
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_OBJID_FLAG = 32;
pub const MEM_UNMAP_WITH_TRANSIENT_BOOST = 1;
pub const DNS_STATUS_FQDN = @as(c_long, 9557);
pub const IMAGE_HOT_PATCH_BASE_OBLIGATORY = 1;
pub const WH_KEYBOARD_LL = 13;
pub const REG_NONE = @as(c_ulong, 0);
pub const ERROR_IPSEC_INVALID_PACKET = @as(c_long, 13914);
pub const InterlockedBitTestAndReset64Release = _interlockedbittestandreset64;
pub const JOY_BUTTON24 = @as(c_long, 8388608);
pub const PAGE_GRAPHICS_READONLY = 4096;
pub const ERROR_INCOMPATIBLE_SERVICE_SID_TYPE = @as(c_long, 1290);
pub const SEM_NOGPFAULTERRORBOX = 2;
pub const DOMAIN_ALIAS_RID_DCOM_USERS = @as(c_long, 562);
pub const SUBLANG_HAUSA_NIGERIA_LATIN = 1;
pub const szOID_PKCS_12_FRIENDLY_NAME_ATTR = "1.2.840.113549.1.9.20";
pub const ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN = @as(c_long, 13845);
pub const PRINTER_ATTRIBUTE_QUEUED = 1;
pub const QS_KEY = 1;
pub const MIXER_OBJECTF_WAVEIN = @as(c_long, 536870912);
pub const EVENT_OBJECT_NAMECHANGE = 32780;
pub const SERVICE_STOP_REASON_MAJOR_HARDWARE = 131072;
pub const RPC_X_ENUM_VALUE_OUT_OF_RANGE = @as(c_long, 1781);
pub const GetConsoleTitle = GetConsoleTitleA;
pub const LOGON32_PROVIDER_WINNT35 = 1;
pub const FILE_TYPE_DISK = 1;
pub const LOCALE_IDEFAULTEBCDICCODEPAGE = 4114;
pub const JOYCAPS_HASZ = 1;
pub const RpcNsEntryObjectInqBegin = RpcNsEntryObjectInqBeginA;
pub const KP_PUB_EX_VAL = 29;
pub const SET_REPAIR_ENABLED = 1;
pub const SUBLANG_POLISH_POLAND = 1;
pub const LLKHF_INJECTED = 16;
pub const CAP_SMART_CMD = 4;
pub const MAP_COMPOSITE = 64;
pub const MUI_THREAD_LANGUAGES = 64;
pub const KP_SALT = 2;
pub const ERROR_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT = @as(c_long, 358);
pub const POWERBUTTON_ACTION_INDEX_TURN_OFF_THE_DISPLAY = 4;
pub const UNRECOVERED_READS_VALID = 8;
pub const JOY_RETURNV = @as(c_long, 32);
pub const ARW_STARTMASK = @as(c_long, 3);
pub const SHGSI_ICONLOCATION = 0;
pub const HKL_NEXT = 1;
pub const CREATE_WAITABLE_TIMER_MANUAL_RESET = 1;
pub const SECTION_MAP_EXECUTE = 8;
pub const CF_FIXEDPITCHONLY = @as(c_long, 16384);
pub const DISP_CHANGE_RESTART = 1;
pub const MCI_ANIM_OPEN_WS = @as(c_long, 65536);
pub const FACILITY_P2P_INT = 98;
pub const DEVICE_DSM_ALLOCATION_OUTPUT_V1 = if (@typeId(@typeOf(DEVICE_DSM_ALLOCATION_OUTPUT)) == @import("builtin").TypeId.Pointer) @ptrCast(sizeof, DEVICE_DSM_ALLOCATION_OUTPUT) else if (@typeId(@typeOf(DEVICE_DSM_ALLOCATION_OUTPUT)) == @import("builtin").TypeId.Int) @intToPtr(sizeof, DEVICE_DSM_ALLOCATION_OUTPUT) else sizeof(DEVICE_DSM_ALLOCATION_OUTPUT);
pub const DNS_ERROR_UNEXPECTED_DATA_PROTECTION_ERROR = @as(c_long, 9109);
pub const MAXLONGLONG = 9223372036854775807;
pub const WSAEDESTADDRREQ = @as(c_long, 10039);
pub const MARSHAL_E_LAST = @as(c_long, 2147746095);
pub const RTL_CORRELATION_VECTOR_V2_LENGTH = 128;
pub const WM_NCLBUTTONDOWN = 161;
pub const JOB_OBJECT_UI_VALID_FLAGS = 255;
pub const SERIAL_IOC_MCR_OUT2 = if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 8) else if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 8) else DWORD(8);
pub const MAXIMUM_ATTR_STRING_LENGTH = 32;
pub const ERROR_DS_STRONG_AUTH_REQUIRED = @as(c_long, 8232);
pub const SPI_SETDOUBLECLICKTIME = 32;
pub const ERROR_IPSEC_INTEGRITY_CHECK_FAILED = @as(c_long, 13915);
pub const ERROR_IEPORT_FULL = @as(c_long, 4341);
pub const DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP = @as(c_long, 572);
pub const URLACTION_COOKIES_SESSION = 6659;
pub const MM_DRVM_CLOSE = 977;
pub const SRWLOCK_INIT = RTL_SRWLOCK_INIT;
pub const XST_POKESENT = 7;
pub const EVENTLOG_FORWARDS_READ = 4;
pub const VOS_OS216 = @as(c_long, 131072);
pub const EMR_HEADER = 1;
pub const EINVAL = 22;
pub const NLS_HIRAGANA = 262144;
pub const PRODUCT_DATACENTER_EVALUATION_SERVER_CORE = 159;
pub const DRV_USER = 16384;
pub const TPM_HORIZONTAL = @as(c_long, 0);
pub const CRYPT_OID_VERIFY_CTL_USAGE_FUNC = "CertDllVerifyCTLUsage";
pub const NCRYPT_PIN_CACHE_DISABLE_DPL_FLAG = 1;
pub const HBMMENU_POPUP_RESTORE = if (@typeId(@typeOf(9)) == @import("builtin").TypeId.Pointer) @ptrCast(HBITMAP, 9) else if (@typeId(@typeOf(9)) == @import("builtin").TypeId.Int) @intToPtr(HBITMAP, 9) else HBITMAP(9);
pub const __inner_this_data_source = src_raw;
pub const SB_THUMBTRACK = 5;
pub const SUBLANG_ARABIC_LEBANON = 12;
pub const GetConsoleAliases = GetConsoleAliasesA;
pub const EIMES_GETCOMPSTRATONCE = 1;
pub const SPI_SETPOWEROFFACTIVE = 86;
pub const PROCESS_CREATION_MITIGATION_POLICY2_RESTRICT_INDIRECT_BRANCH_PREDICTION_ALWAYS_OFF = if (@typeId(@typeOf(i64 << 16)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 2), i64 << 16) else if (@typeId(@typeOf(i64 << 16)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 2), i64 << 16) else @as(c_uint, 2)(i64 << 16);
pub const WT_EXECUTEINUITHREAD = 2;
pub const MM_HIMETRIC = 3;
pub const SPI_GETWHEELSCROLLLINES = 104;
pub const HTNOWHERE = 0;
pub const OpenWindowStation = OpenWindowStationA;
pub const DNS_ERROR_CANNOT_FIND_ROOT_HINTS = @as(c_long, 9564);
pub const SUBLANG_ITALIAN = 1;
pub const ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE = @as(c_long, 6805);
pub const NCRYPT_EXPORT_LEGACY_FLAG = 2048;
pub const UDIRTYUI = SHTDN_REASON_FLAG_DIRTY_UI;
pub const ERROR_UNWIND = @as(c_long, 542);
pub const GWL_EXSTYLE = -20;
pub const FORM_BUILTIN = 1;
pub const ERROR_APPEXEC_NO_DONOR = @as(c_long, 3065);
pub const SMART_INVALID_BUFFER = 4;
pub const DCBA_FACEDOWNCENTER = 257;
pub const WM_INPUT_DEVICE_CHANGE = 254;
pub const CERT_CHAIN_ENABLE_MD2_MD4_FLAG = 1;
pub const _MAX_FNAME = 256;
pub const ERROR_CLUSTER_UPGRADE_FIX_QUORUM_NOT_SUPPORTED = @as(c_long, 5974);
pub const MCI_DEVTYPE_CD_AUDIO = 516;
pub const SCARD_READERSTATE_A = SCARD_READERSTATEA;
pub const DISK_ATTRIBUTE_OFFLINE = 1;
pub const ERROR_BAD_PROVIDER = @as(c_long, 1204);
pub const ERROR_DEBUGGER_INACTIVE = @as(c_long, 1284);
pub const PF_VOICEVIEW = AF_VOICEVIEW;
pub const GCP_NUMERICOVERRIDE = @as(c_long, 16777216);
pub const ENUM_S_FIRST = @as(c_long, 262576);
pub const DCTT_SUBDEV = @as(c_long, 4);
pub const PAN_MIDLINE_STANDARD_POINTED = 3;
pub const IMAGE_DIRECTORY_ENTRY_BASERELOC = 5;
pub const VP_TV_STANDARD_SECAM_G = 1024;
pub const __PRAGMA_REDEFINE_EXTNAME = 1;
pub const VFT2_DRV_VERSIONED_PRINTER = @as(c_long, 12);
pub const DNS_ERROR_POLICY_DOES_NOT_EXIST = @as(c_long, 9972);
pub const STREAMS_INVALID_ID = 0;
pub const NCRYPT_CIPHER_OTHER_PADDING_FLAG = 2;
pub const FILE_ATTRIBUTE_NO_SCRUB_DATA = 131072;
pub const COLOR_MENUTEXT = 7;
pub const VER_MINORVERSION = 1;
pub const TREE_CONNECT_ATTRIBUTE_PRIVACY = 16384;
pub const RPC_S_INVALID_TAG = @as(c_long, 1733);
pub const MCI_GETDEVCAPS_ITEM = @as(c_long, 256);
pub const PFD_TYPE_RGBA = 0;
pub const InterlockedExchangeAddAcquire = _InterlockedExchangeAdd;
pub const DC_PERSONALITY = 25;
pub const __UINT_FAST64_FMTu__ = "llu";
pub const THREAD_TERMINATE = 1;
pub const szOID_CERTIFICATE_REVOCATION_LIST = "2.5.4.39";
pub const HIBERFILE_TYPE_REDUCED = 1;
pub const __INT_FAST16_TYPE__ = short;
pub const KF_UP = 32768;
pub const SPI_SETFOCUSBORDERWIDTH = 8207;
pub const DONT_RESOLVE_DLL_REFERENCES = 1;
pub const DEVICEFAMILYINFOENUM_8828080 = 14;
pub const CF_LOCALE = 16;
pub const WMSZ_LEFT = 1;
pub const CERT_CHAIN_AUTO_NETWORK_INFO = 6;
pub const ERROR_LOG_APPENDED_FLUSH_FAILED = @as(c_long, 6647);
pub const WNNC_NET_9P = 4718592;
pub const PRODUCT_CLUSTER_SERVER_V = 64;
pub const CERT_CHAIN_TIMESTAMP_TIME = 512;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE = @as(c_long, 15634);
pub const REG_OPTION_OPEN_LINK = @as(c_long, 8);
pub const OFN_HIDEREADONLY = 4;
pub const IN_CLASSC_NSHIFT = 8;
pub const ERROR_DS_CONFIG_PARAM_MISSING = @as(c_long, 8427);
pub const IMAGE_REL_ALPHA_SECREL = 15;
pub const EnumForms = EnumFormsA;
pub const ALG_SID_DSS_DMS = 2;
pub const MDM_HDLCPPP_SPEED_DEFAULT = 0;
pub const MEDIA_ERASEABLE = 1;
pub const REQUEST_OPLOCK_INPUT_FLAG_REQUEST = 1;
pub const PSH_WATERMARK = 32768;
pub const SECURITY_RESERVED_ID_BASE_RID = @as(c_long, 81);
pub const ERROR_ALREADY_EXISTS = @as(c_long, 183);
pub const CONDITION_VARIABLE_INIT = RTL_CONDITION_VARIABLE_INIT;
pub const WSAEBADF = @as(c_long, 10009);
pub const DCBA_FACEDOWNNONE = 256;
pub const FACILITY_OPC = 81;
pub const JOY_BUTTON25 = @as(c_long, 16777216);
pub const ES_READONLY = @as(c_long, 2048);
pub const STORAGE_OFFLOAD_MAX_TOKEN_LENGTH = 512;
pub const BCRYPT_SP80056A_CONCAT_ALG_HANDLE = if (@typeId(@typeOf(849)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 849) else if (@typeId(@typeOf(849)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 849) else BCRYPT_ALG_HANDLE(849);
pub const WM_GESTURENOTIFY = 282;
pub const MAXUINT64 = if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT64, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT64, 0) else UINT64(0))) == @import("builtin").TypeId.Pointer) @ptrCast(UINT64, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT64, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT64, 0) else UINT64(0)) else if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT64, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT64, 0) else UINT64(0))) == @import("builtin").TypeId.Int) @intToPtr(UINT64, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT64, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT64, 0) else UINT64(0)) else UINT64(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT64, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT64, 0) else UINT64(0));
pub const SERVICE_STOP_REASON_MAJOR_SOFTWARE = 262144;
pub const CERT_STORE_PROV_FILENAME_A = if (@typeId(@typeOf(7)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 7) else if (@typeId(@typeOf(7)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 7) else LPCSTR(7);
pub const PSN_WIZBACK = if (@typeId(@typeOf(-6)) == @import("builtin").TypeId.Pointer) @ptrCast(PSN_FIRST, -6) else if (@typeId(@typeOf(-6)) == @import("builtin").TypeId.Int) @intToPtr(PSN_FIRST, -6) else PSN_FIRST(-6);
pub const CF_SCALABLEONLY = @as(c_long, 131072);
pub const EEInfoNextRecordsMissing = 2;
pub const SO_UPDATE_ACCEPT_CONTEXT = 28683;
pub const PRINTER_ATTRIBUTE_HIDDEN = 32;
pub const PIDMSI_RATING = @as(c_long, 9);
pub const scr3 = 1170;
pub const MDM_DIAGNOSTICS = 2048;
pub const ERROR_LOG_CONTAINER_OPEN_FAILED = @as(c_long, 6641);
pub const DISPLAYCONFIG_TARGET_FORCED_AVAILABILITY_SYSTEM = 16;
pub const ERROR_SXS_ASSEMBLY_MISSING = @as(c_long, 14081);
pub const MIXER_OBJECTF_MIXER = @as(c_long, 0);
pub const EM_GETRECT = 178;
pub const GID_ROLLOVER = GID_PRESSANDTAP;
pub const PRODUCT_ENTERPRISE_S_N = 126;
pub const GetCharWidthFloat = GetCharWidthFloatA;
pub const TC_SF_X_YINDEP = 32;
pub const DLL_THREAD_DETACH = 3;
pub const InterlockedAddNoFence64 = _InlineInterlockedAdd64;
pub const CC_INTERIORS = 128;
pub const LOCALE_SCONSOLEFALLBACKNAME = 110;
pub const RPC_C_OPT_UNIQUE_BINDING = 11;
pub const PROV_RSA_FULL = 1;
pub const CBR_BLOCK = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(HDDEDATA, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(HDDEDATA, -1) else HDDEDATA(-1);
pub const VarIntFromDate = VarI4FromDate;
pub const SM_CXFULLSCREEN = 16;
pub const BI_BITFIELDS = @as(c_long, 3);
pub const SCardForgetReaderGroup = SCardForgetReaderGroupA;
pub const SSL_OBJECT_LOCATOR_PFX_FUNC = "SslObjectLocatorInitializePfx";
pub const WNNC_NET_3IN1 = 2555904;
pub const DEVICE_DSM_ALLOCATION_OUTPUT_V2 = if (@typeId(@typeOf(DEVICE_DSM_ALLOCATION_OUTPUT2)) == @import("builtin").TypeId.Pointer) @ptrCast(sizeof, DEVICE_DSM_ALLOCATION_OUTPUT2) else if (@typeId(@typeOf(DEVICE_DSM_ALLOCATION_OUTPUT2)) == @import("builtin").TypeId.Int) @intToPtr(sizeof, DEVICE_DSM_ALLOCATION_OUTPUT2) else sizeof(DEVICE_DSM_ALLOCATION_OUTPUT2);
pub const MCI_ANIM_STATUS_SPEED = @as(c_long, 16385);
pub const SET_FEATURE_ON_PROCESS = 2;
pub const ERROR_INVALID_MESSAGEDEST = @as(c_long, 1218);
pub const ERROR_INSTALL_NETWORK_FAILURE = @as(c_long, 15605);
pub const ENCLAVE_VBS_FLAG_DEBUG = 1;
pub const _SAL_VERSION_CHECK = _A;
pub const STGTY_REPEAT = @as(c_long, 256);
pub const CERT_CHAIN_DISABLE_ALL_EKU_WEAK_FLAG = 65536;
pub const szOID_ISSUED_CERT_HASH = "1.3.6.1.4.1.311.21.17";
pub const SET_FEATURE_ON_THREAD_LOCALMACHINE = 8;
pub const RPC_C_QOS_CAPABILITIES_LOCAL_MA_HINT = 16;
pub const FILE_DEVICE_VIRTUAL_DISK = 36;
pub const WM_MOUSEWHEEL = 522;
pub const SERVICE_ERROR_CRITICAL = 3;
pub const CERT_STORE_CREATE_NEW_FLAG = 8192;
pub const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_V0 = 0;
pub const __SSE4_2__ = 1;
pub const ERROR_CANNOT_MAKE = @as(c_long, 82);
pub const NULL_PEN = 8;
pub const EMR_POLYPOLYLINE16 = 90;
pub const SND_NOWAIT = @as(c_long, 8192);
pub const TWF_FINETOUCH = 1;
pub const BI_JPEG = @as(c_long, 4);
pub const URLACTION_LOOSE_XAML = 9218;
pub const UIS_CLEAR = 2;
pub const TRANSACTION_PROPAGATE = 32;
pub const FACILITY_SQLITE = 1967;
pub const SPI_SETMESSAGEDURATION = 8215;
pub const ERROR_NET_WRITE_FAULT = @as(c_long, 88);
pub const SECURITY_BUILTIN_DOMAIN_RID = @as(c_long, 32);
pub const SP_USERABORT = -3;
pub const RpcNsProfileEltInqNext = RpcNsProfileEltInqNextA;
pub const SKF_LSHIFTLOCKED = 65536;
pub const PROCESSOR_HITACHI_SH4 = 10005;
pub const FindResource = FindResourceA;
pub const szOID_PKIX_OCSP_BASIC_SIGNED_RESPONSE = "1.3.6.1.5.5.7.48.1.1";
pub const ERROR_DEVICE_ALREADY_ATTACHED = @as(c_long, 548);
pub const SPI_SETTHREADLOCALINPUTSETTINGS = 4175;
pub const GESTUREVISUALIZATION_RIGHTTAP = 16;
pub const QS_SENDMESSAGE = 64;
pub const ERROR_INVALID_FORM_NAME = @as(c_long, 1902);
pub const LANG_ICELANDIC = 15;
pub const szOID_CMC_ADD_ATTRIBUTES = "1.3.6.1.4.1.311.10.10.1";
pub const CERT_CHAIN_HAS_MOTW = 16384;
pub const SERVICE_NO_CHANGE = 4294967295;
pub const ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND = @as(c_long, 3016);
pub const ERROR_IS_JOIN_PATH = @as(c_long, 147);
pub const HSHELL_WINDOWREPLACED = 13;
pub const STORAGE_HW_FIRMWARE_REQUEST_FLAG_CONTROLLER = 1;
pub const LOGON32_LOGON_SERVICE = 5;
pub const CERT_COMPARE_CERT_ID = 16;
pub const TXFS_START_RM_FLAG_PRESERVE_CHANGES = 2048;
pub const RPC_C_OPT_SESSION_ID = 6;
pub const ERROR_PATCH_REMOVAL_UNSUPPORTED = @as(c_long, 1646);
pub const IMAGE_OS2_SIGNATURE = 17742;
pub const PARTITION_UNIX = 99;
pub const PDC_REMOVAL = 2;
pub const ODS_CHECKED = 8;
pub const ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN = @as(c_long, 14095);
pub const SS_REALSIZEIMAGE = @as(c_long, 2048);
pub const SM_CYMENUCHECK = 72;
pub const DNS_ERROR_CNAME_LOOP = @as(c_long, 9707);
pub const MCI_WAVE_OUTPUT = @as(c_long, 8388608);
pub const PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_ALWAYS_ON = 1 << 28;
pub const WAIT_FAILED = if (@typeId(@typeOf(4294967295)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 4294967295) else if (@typeId(@typeOf(4294967295)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 4294967295) else DWORD(4294967295);
pub const SETRGBSTRING = SETRGBSTRINGA;
pub const PRINTER_ACCESS_MANAGE_LIMITED = 64;
pub const MAPVK_VK_TO_VSC_EX = 4;
pub const CERT_RDN_TELETEX_STRING = 5;
pub const Uri_DISPLAY_NO_PUNYCODE = 8;
pub const AC_LINE_BACKUP_POWER = 2;
pub const SYSTEM_SCOPED_POLICY_ID_ACE_TYPE = 19;
pub const PD_RETURNDC = 256;
pub const APPCOMMAND_CLOSE = 31;
pub const CRYPT_NOHASHOID = 1;
pub const BCRYPT_ECDSA_PUBLIC_GENERIC_MAGIC = 1346650949;
pub const NCRYPT_3DES_112_ALGORITHM = BCRYPT_3DES_112_ALGORITHM;
pub const PASSIVE_LEVEL = 0;
pub const ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL = @as(c_long, 15009);
pub const COLOR_INACTIVEBORDER = 11;
pub const RI_MOUSE_RIGHT_BUTTON_UP = 8;
pub const ERROR_ARBITRATION_UNHANDLED = @as(c_long, 723);
pub const DST_BITMAP = 4;
pub const TAPE_DRIVE_SET_BLOCK_SIZE = 2147483664;
pub const szOID_INFOSEC_mosaicTokenProtection = "2.16.840.1.101.2.1.1.8";
pub const TIME_SMPTE = 8;
pub const DROPEFFECT_NONE = 0;
pub const NTDDI_WIN8 = 100794368;
pub const PRODUCT_EMBEDDED_A = 88;
pub const RpcServerUseProtseq = RpcServerUseProtseqA;
pub const szOID_CERTSRV_CROSSCA_VERSION = "1.3.6.1.4.1.311.21.22";
pub const CTL_FIND_MD5_HASH = 2;
pub const IMAGE_REL_THUMB_BRANCH24 = 20;
pub const ERROR_INVALID_MEDIA_POOL = @as(c_long, 4302);
pub const SEC_E_NOT_SUPPORTED = SEC_E_UNSUPPORTED_FUNCTION;
pub const EV_EVENT2 = 4096;
pub const Uri_HAS_EXTENSION = 1 << Uri_PROPERTY_EXTENSION;
pub const SHGFI_ICON = 256;
pub const Uri_ENCODING_HOST_IS_PERCENT_ENCODED_CP = 16;
pub const X3_I_INST_WORD_X = 3;
pub const ERROR_RESIDENT_FILE_NOT_SUPPORTED = @as(c_long, 334);
pub const ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS = @as(c_long, 8549);
pub const ERROR_BLOCK_TOO_MANY_REFERENCES = @as(c_long, 347);
pub const KEYEVENTF_SCANCODE = 8;
pub const PERF_COUNTER_QUEUELEN = 327680;
pub const CRYPT_FORMAT_RDN_REVERSE = 2048;
pub const CTL_FIND_ANY = 0;
pub const SERVICE_NOTIFY_PAUSE_PENDING = 32;
pub const DMLERR_BUSY = 16385;
pub const WM_DESTROYCLIPBOARD = 775;
pub const TIMERV_DEFAULT_COALESCING = 0;
pub const X509_SUBJECT_INFO_ACCESS = X509_AUTHORITY_INFO_ACCESS;
pub const SKF_TWOKEYSOFF = 256;
pub const JOY_BUTTON26 = @as(c_long, 33554432);
pub const APPCOMMAND_MEDIA_REWIND = 50;
pub const __SIZEOF_INT128__ = 16;
pub const ERROR_DS_REPL_LIFETIME_EXCEEDED = @as(c_long, 8614);
pub const EOPNOTSUPP = 130;
pub const MS_SCARD_PROV_A = "Microsoft Base Smart Card Crypto Provider";
pub const IsCharLower = IsCharLowerA;
pub const EVENT_S_LAST = @as(c_long, 262687);
pub const DMBIN_MANUAL = 4;
pub const RESOURCE_ENUM_MUI_SYSTEM = 4;
pub const WriteLongPtrRelease = WriteRelease64;
pub const ALG_SID_SCHANNEL_MAC_KEY = 3;
pub const SUBLANG_CROATIAN_CROATIA = 1;
pub const SORT_GEORGIAN_TRADITIONAL = 0;
pub const ERROR_DS_CROSS_DOM_MOVE_ERROR = @as(c_long, 8216);
pub const DNS_ERROR_UNEXPECTED_CNG_ERROR = @as(c_long, 9110);
pub const EN_ALIGN_LTR_EC = 1792;
pub const IMAGE_REL_ARM64_SECREL_HIGH12A = 10;
pub const VK_OEM_ENLW = 244;
pub const scr2 = 1169;
pub const CERT_CHAIN_FIND_BY_ISSUER_LOCAL_MACHINE_FLAG = 8;
pub const RPC_C_OPT_ASYNC_BLOCK = 15;
pub const ALG_SID_TLS1PRF = 10;
pub const PSBTN_CANCEL = 5;
pub const LANG_HINDI = 57;
pub const ERROR_PATH_BUSY = @as(c_long, 148);
pub const WS_OVERLAPPED = @as(c_long, 0);
pub const ERROR_TRANSFORM_NOT_SUPPORTED = @as(c_long, 2004);
pub const RpcBindingInqAuthInfo = RpcBindingInqAuthInfoA;
pub const MM_MOM_CLOSE = 968;
pub const JOY_RETURNX = @as(c_long, 1);
pub const DCTT_DOWNLOAD = @as(c_long, 2);
pub const ERROR_UNHANDLED_EXCEPTION = @as(c_long, 574);
pub const InitiateShutdown = InitiateShutdownA;
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG = 1;
pub const ERROR_CTX_SHADOW_INVALID = @as(c_long, 7050);
pub const JOB_OBJECT_UILIMIT_DISPLAYSETTINGS = 16;
pub const CREATE_IGNORE_SYSTEM_DEFAULT = 2147483648;
pub const EM_POSFROMCHAR = 214;
pub const FILE_DEVICE_PARALLEL_PORT = 22;
pub const VP_TV_STANDARD_SECAM_L1 = 524288;
pub const ERROR_CTX_WINSTATION_BUSY = @as(c_long, 7024);
pub const IMAGE_ENHMETAFILE = 3;
pub const GRADIENT_FILL_OP_FLAG = 255;
pub const VER_CONDITION_MASK = 7;
pub const DMDO_180 = 2;
pub const LANG_KANNADA = 75;
pub const __STDC_UTF_32__ = 1;
pub const MININT32 = if (@typeId(@typeOf(~MAXINT32)) == @import("builtin").TypeId.Pointer) @ptrCast(INT32, ~MAXINT32) else if (@typeId(@typeOf(~MAXINT32)) == @import("builtin").TypeId.Int) @intToPtr(INT32, ~MAXINT32) else INT32(~MAXINT32);
pub const TAPE_FORMAT = @as(c_long, 5);
pub const HS_BDIAGONAL = 3;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PEP = 4;
pub const ERROR_DIFFERENT_SERVICE_ACCOUNT = @as(c_long, 1079);
pub const RpcNsProfileDelete = RpcNsProfileDeleteA;
pub const __SIZEOF_DOUBLE__ = 8;
pub const WNNC_NET_SMB = 131072;
pub const szOID_RSA_data = "1.2.840.113549.1.7.1";
pub const PFD_SUPPORT_COMPOSITION = 32768;
pub const PRODUCT_EMBEDDED_INDUSTRY_EVAL = 105;
pub const WM_CREATE = 1;
pub const STATUS_IN_PAGE_ERROR = if (@typeId(@typeOf(@as(c_long, 3221225478))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225478)) else if (@typeId(@typeOf(@as(c_long, 3221225478))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225478)) else DWORD(@as(c_long, 3221225478));
pub const CBR_256000 = 256000;
pub const LZERROR_BADOUTHANDLE = -2;
pub const PAN_MIDLINE_HIGH_TRIMMED = 5;
pub const PIDSI_LASTSAVE_DTM = @as(c_long, 13);
pub const STATUS_INVALID_DISPOSITION = if (@typeId(@typeOf(@as(c_long, 3221225510))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225510)) else if (@typeId(@typeOf(@as(c_long, 3221225510))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225510)) else DWORD(@as(c_long, 3221225510));
pub const CERT_CHAIN_FIND_BY_ISSUER_CACHE_ONLY_FLAG = 32768;
pub const FROM_LEFT_3RD_BUTTON_PRESSED = 8;
pub const STATUS_SXS_EARLY_DEACTIVATION = if (@typeId(@typeOf(@as(c_long, 3222601743))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3222601743)) else if (@typeId(@typeOf(@as(c_long, 3222601743))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3222601743)) else DWORD(@as(c_long, 3222601743));
pub const FAST_FAIL_SET_CONTEXT_DENIED = 48;
pub const STATUS_PENDING = if (@typeId(@typeOf(@as(c_long, 259))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 259)) else if (@typeId(@typeOf(@as(c_long, 259))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 259)) else DWORD(@as(c_long, 259));
pub const ERROR_SXS_XML_E_UNCLOSEDCDATA = @as(c_long, 14065);
pub const FILE_DEVICE_DATALINK = 5;
pub const PAGE_TARGETS_INVALID = 1073741824;
pub const ERROR_CLUSTER_DATABASE_UPDATE_CONDITION_FAILED = @as(c_long, 5986);
pub const InterlockedOrRelease = _InterlockedOr;
pub const FACILITY_ACS = 20;
pub const ERROR_PAGE_FAULT_PAGING_FILE = @as(c_long, 751);
pub const wglUseFontBitmaps = wglUseFontBitmapsA;
pub const OemToAnsiBuff = OemToCharBuffA;
pub const OPENCARDNAME_A = OPENCARDNAMEA;
pub const DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP = @as(c_long, 9612);
pub const TRANSACTION_NOTIFY_PROMOTE_NEW = 268435456;
pub const ENODATA = 120;
pub const SET_CLIP_BOX = 4108;
pub const PROCESS_CREATION_MITIGATION_POLICY2_SPECULATIVE_STORE_BYPASS_DISABLE_DEFER = if (@typeId(@typeOf(i64 << 24)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), i64 << 24) else if (@typeId(@typeOf(i64 << 24)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), i64 << 24) else @as(c_uint, 0)(i64 << 24);
pub const APPCOMMAND_NEW = 29;
pub const HTBOTTOMRIGHT = 17;
pub const szOID_PKIX_KP_CLIENT_AUTH = "1.3.6.1.5.5.7.3.2";
pub const szOID_PIN_RULES_CTL = "1.3.6.1.4.1.311.10.3.32";
pub const PRODUCT_PRO_WORKSTATION_N = 162;
pub const ERROR_EXE_MACHINE_TYPE_MISMATCH = @as(c_long, 216);
pub const IMAGE_REL_PPC_ADDR32 = 2;
pub const DDD_REMOVE_DEFINITION = 2;
pub const ERROR_CTX_SERVICE_NAME_COLLISION = @as(c_long, 7006);
pub const BCRYPT_BUFFERS_LOCKED_FLAG = 64;
pub const BI_PNG = @as(c_long, 5);
pub const REGDB_S_LAST = @as(c_long, 262495);
pub const ERROR_INVALID_SECURITY_DESCR = @as(c_long, 1338);
pub const ELEMENT_STATUS_NOT_BUS = 32768;
pub const SB_PAGEDOWN = 3;
pub const NTDDI_WIN7 = 100728832;
pub const WSA_QOS_EPROVSPECBUF = @as(c_long, 11018);
pub const INFINITE = 4294967295;
pub const CTRY_CHILE = 56;
pub const VK_MEDIA_STOP = 178;
pub const RPC_X_NO_MEMORY = RPC_S_OUT_OF_MEMORY;
pub const BDR_RAISEDINNER = 4;
pub const szOIDVerisign_MessageType = "2.16.840.1.113733.1.9.2";
pub const CFERR_CHOOSEFONTCODES = 8192;
pub const EN_UPDATE = 1024;
pub const ERROR_NO_SITENAME = @as(c_long, 1919);
pub const WM_DEVMODECHANGE = 27;
pub const JOB_CONTROL_CANCEL = 3;
pub const ERROR_ATOMIC_LOCKS_NOT_SUPPORTED = @as(c_long, 174);
pub const DMBIN_UPPER = 1;
pub const REG_EXPAND_SZ = @as(c_ulong, 2);
pub const FACILITY_DEPLOYMENT_SERVICES_TFTP = 264;
pub const NCRYPT_PIN_CACHE_PIN_BYTE_LENGTH = 90;
pub const __UINTPTR_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const MF_GRAYED = @as(c_long, 1);
pub const VER_OR = 7;
pub const __UINT_LEAST8_FMTu__ = "hhu";
pub const WM_NCMOUSELEAVE = 674;
pub const NCRYPT_ALLOW_SILENT_KEY_ACCESS = 1;
pub const IMAGE_NT_OPTIONAL_HDR64_MAGIC = 523;
pub const ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = @as(c_long, 1807);
pub const RDW_ERASE = 4;
pub const JOY_BUTTON27 = @as(c_long, 67108864);
pub const CMSG_SIGNER_AUTH_ATTR_PARAM = 9;
pub const ERROR_DS_INCOMPATIBLE_VERSION = @as(c_long, 8567);
pub const URLACTION_LOWRIGHTS = 9472;
pub const SCardGetReaderIcon = SCardGetReaderIconA;
pub const _WIN32_IE_IE55 = 1360;
pub const ERROR_NOT_JOINED = @as(c_long, 136);
pub const SCRUB_DATA_INPUT_FLAG_SKIP_DATA = 16;
pub const SCardForgetCardType = SCardForgetCardTypeA;
pub const ERROR_ILLEGAL_CHARACTER = @as(c_long, 582);
pub const _WIN32_IE_IE401 = 1025;
pub const EXIT_THREAD_DEBUG_EVENT = 4;
pub const ERROR_COMPRESSED_FILE_NOT_SUPPORTED = @as(c_long, 335);
pub const WB_RIGHT = 1;
pub const WNNC_NET_INTERGRAPH = 1310720;
pub const scr1 = 1168;
pub const WTS_SESSION_LOGOFF = 6;
pub const SM_CYVIRTUALSCREEN = 79;
pub const BAUD_300 = if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 16) else if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 16) else DWORD(16);
pub const LCMAP_LOWERCASE = 256;
pub const DBG_EXCEPTION_NOT_HANDLED = if (@typeId(@typeOf(@as(c_long, 2147549185))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 2147549185)) else if (@typeId(@typeOf(@as(c_long, 2147549185))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 2147549185)) else DWORD(@as(c_long, 2147549185));
pub const EMR_GLSBOUNDEDRECORD = 103;
pub const NUMA_NO_PREFERRED_NODE = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, -1) else DWORD(-1);
pub const JOY_RETURNY = @as(c_long, 2);
pub const OCSP_MALFORMED_REQUEST_RESPONSE = 1;
pub const GS_8BIT_INDICES = 1;
pub const SE_ERR_PNF = 3;
pub const EM_GETIMESTATUS = 217;
pub const ERROR_LOCK_VIOLATION = @as(c_long, 33);
pub const SM_CXBORDER = 5;
pub const JOB_OBJECT_MSG_JOB_CYCLE_TIME_LIMIT = 12;
pub const WM_XBUTTONUP = 524;
pub const RpcMgmtEpEltInqNext = RpcMgmtEpEltInqNextA;
pub const BM_SETDONTCLICK = 248;
pub const SIID_INVALID = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(SHSTOCKICONID, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(SHSTOCKICONID, -1) else SHSTOCKICONID(-1);
pub const ERROR_INVALID_SID = @as(c_long, 1337);
pub const ERROR_APPX_INTEGRITY_FAILURE_CLR_NGEN = @as(c_long, 15624);
pub const JOY_POVLEFT = 27000;
pub const ERROR_MORE_DATA = @as(c_long, 234);
pub const MCI_SEQ_STATUS_TEMPO = @as(c_long, 16386);
pub const __failure = x;
pub const ERROR_WRONG_DISK = @as(c_long, 34);
pub const CRITICAL_ACE_FLAG = 32;
pub const NLS_IME_CONVERSION = 8388608;
pub const CONSOLE_MOUSE_SELECTION = 4;
pub const Uri_ENCODING_QUERY_AND_FRAGMENT_IS_PERCENT_ENCODED_UTF8 = 32;
pub const RTS_CONTROL_DISABLE = 0;
pub const STATUS_PRIVILEGED_INSTRUCTION = if (@typeId(@typeOf(@as(c_long, 3221225622))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225622)) else if (@typeId(@typeOf(@as(c_long, 3221225622))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225622)) else DWORD(@as(c_long, 3221225622));
pub const MF_MOUSESELECT = @as(c_long, 32768);
pub const GDICOMMENT_UNICODE_END = 128;
pub const CTLCOLOR_SCROLLBAR = 5;
pub const PROCESSOR_AMD_X8664 = 8664;
pub const PRODUCT_EMBEDDED_INDUSTRY_E_EVAL = 106;
pub const SCARD_POWERED = 4;
pub const PAN_SERIF_EXAGGERATED = 9;
pub const BACKUP_INVALID = 0;
pub const FAR = far;
pub const szOID_QC_STATEMENTS_EXT = "1.3.6.1.5.5.7.1.3";
pub const SCARD_READER_SEL_AUTH_PACKAGE = if (@typeId(@typeOf(-629)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, -629) else if (@typeId(@typeOf(-629)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, -629) else DWORD(-629);
pub const ERROR_RESOURCE_DATA_NOT_FOUND = @as(c_long, 1812);
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP = @as(c_long, 5894);
pub const CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG = 1;
pub const ERROR_UNABLE_TO_INVENTORY_SLOT = @as(c_long, 4326);
pub const RELATIVE = 2;
pub const CHINESEBIG5_CHARSET = 136;
pub const BN_KILLFOCUS = 7;
pub const RPC_BHT_OBJECT_UUID_VALID = 1;
pub const HWND_DESKTOP = if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(HWND, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(HWND, 0) else HWND(0);
pub const C1_CNTRL = 32;
pub const ERROR_CORE_RESOURCE = @as(c_long, 5026);
pub const SUBLANG_ASSAMESE_INDIA = 1;
pub const TXFS_RM_STATE_SHUTTING_DOWN = 3;
pub const SERVICES_ACTIVE_DATABASE = SERVICES_ACTIVE_DATABASEA;
pub const ERROR_TRANSACTION_INTEGRITY_VIOLATED = @as(c_long, 6726);
pub const BCRYPT_HMAC_SHA384_ALG_HANDLE = if (@typeId(@typeOf(193)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 193) else if (@typeId(@typeOf(193)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 193) else BCRYPT_ALG_HANDLE(193);
pub const FILE_INITIATE_REPAIR_HINT1_UNABLE_TO_REPAIR = 64;
pub const CRYPT_STRING_BASE64URI = 13;
pub const WSAENOTEMPTY = @as(c_long, 10066);
pub const PKCS12_PBKDF2_ID_HMAC_SHA256 = "1.2.840.113549.2.9";
pub const ERROR_DS_SINGLE_USER_MODE_FAILED = @as(c_long, 8590);
pub const IME_CMODE_KATAKANA = 2;
pub const CERT_TRUST_NO_ISSUANCE_CHAIN_POLICY = 33554432;
pub const SPI_GETMOUSE = 3;
pub const OLEIVERB_INPLACEACTIVATE = -@as(c_long, 5);
pub const POWER_REQUEST_CONTEXT_SIMPLE_STRING = DIAGNOSTIC_REASON_SIMPLE_STRING;
pub const PSINJECT_PLATECOLOR = 104;
pub const RPC_C_AUTHN_CLOUD_AP = 36;
pub const PS_ENDCAP_ROUND = 0;
pub const SUBLANG_ENGLISH_PHILIPPINES = 13;
pub const __file_parser = typ;
pub const sz_CERT_STORE_PROV_PKCS12 = "PKCS12";
pub const LAYOUT_BITMAPORIENTATIONPRESERVED = 8;
pub const DLGC_WANTALLKEYS = 4;
pub const VP_TV_STANDARD_SECAM_D = 512;
pub const IPPROTO_ND = 77;
pub const TextOut = TextOutA;
pub const SET_REPAIR_VALID_MASK = 25;
pub const MM_TEXT = 1;
pub const DISPATCH_PROPERTYPUTREF = 8;
pub const ERROR_DS_NO_DELETED_NAME = @as(c_long, 8355);
pub const PROTECTED_DACL_SECURITY_INFORMATION = @as(c_long, 2147483648);
pub const __UINT_LEAST32_MAX__ = @as(c_uint, 4294967295);
pub const NTDDI_WIN6 = 100663296;
pub const auxGetDevCaps = auxGetDevCapsA;
pub const CONNDLG_CONN_POINT = 2;
pub const szOID_INFOSEC_sdnsConfidentiality = "2.16.840.1.101.2.1.1.3";
pub const WINABLEAPI = DECLSPEC_IMPORT;
pub const LPSCARD_READERSTATE_W = LPSCARD_READERSTATEW;
pub const ALG_SID_DSS_ANY = 0;
pub const PIDDSI_LINKSDIRTY = 16;
pub const szOID_PKCS_5_PBES2 = "1.2.840.113549.1.5.13";
pub const SUBLANG_SAMI_NORTHERN_FINLAND = 3;
pub const DI_IMAGE = 2;
pub const EMR_FILLPATH = 62;
pub const RpcEpRegisterNoReplace = RpcEpRegisterNoReplaceA;
pub const RegEnumValue = RegEnumValueA;
pub const VarUI1FromUint = VarUI1FromUI4;
pub const WSAENOBUFS = @as(c_long, 10055);
pub const CBN_DBLCLK = 2;
pub const szOID_INFOSEC_SuiteASignature = "2.16.840.1.101.2.1.1.13";
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING = 16;
pub const __INTPTR_MAX__ = @as(c_longlong, 9223372036854775807);
pub const DCB_ENABLE = 4;
pub const RUNDLGORD = 1545;
pub const DC_BINADJUST = 19;
pub const CERT_NAME_SIMPLE_DISPLAY_TYPE = 4;
pub const LANG_WELSH = 82;
pub const JOY_BUTTON20 = @as(c_long, 524288);
pub const ERROR_DS_NCNAME_MISSING_CR_REF = @as(c_long, 8412);
pub const LZERROR_BADINHANDLE = -1;
pub const URLACTION_INFODELIVERY_CURR_MAX = 7430;
pub const CERT_STORE_PROV_SERIALIZED = if (@typeId(@typeOf(6)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 6) else if (@typeId(@typeOf(6)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 6) else LPCSTR(6);
pub const _MAX_DIR = 256;
pub const RC_SCALING = 4;
pub const szOID_AUTHORITY_KEY_IDENTIFIER2 = "2.5.29.35";
pub const TXFS_START_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN = 128;
pub const STRETCH_DELETESCANS = COLORONCOLOR;
pub const KDF_HKDF_SALT = 19;
pub const LANG_VIETNAMESE = 42;
pub const VIF_BUFFTOOSMALL = @as(c_long, 262144);
pub const VOS_NT_WINDOWS32 = @as(c_long, 262148);
pub const CONTEXT_S_LAST = @as(c_long, 319535);
pub const SDC_TOPOLOGY_CLONE = 2;
pub const GetConsoleAlias = GetConsoleAliasA;
pub const SUBLANG_FAEROESE_FAROE_ISLANDS = 1;
pub const SKF_RALTLATCHED = 536870912;
pub const URLACTION_SCRIPT_MIN = 5120;
pub const MDM_AUTO_SPEED_DEFAULT = 0;
pub const MF_UNCHECKED = @as(c_long, 0);
pub const __ATOMIC_SEQ_CST = 5;
pub const VarI1FromInt = VarI1FromI4;
pub const FILE_SUPPORTS_HARD_LINKS = 4194304;
pub const LC_NONE = 0;
pub const JOY_RETURNZ = @as(c_long, 4);
pub const __SIZEOF_LONG_LONG__ = 8;
pub const ERROR_INVALID_NAME = @as(c_long, 123);
pub const CERT_ROOT_PROGRAM_FLAG_ADDRESS = 8;
pub const SO_TYPE = 4104;
pub const PP_KEYX_KEYSIZE_INC = 35;
pub const IMAGE_ARCHIVE_PAD = "\n";
pub const FILEOPENORD = 1536;
pub const POWER_CONNECTIVITY_IN_STANDBY_DISABLED = 0;
pub const PROC_THREAD_ATTRIBUTE_ADDITIVE = 262144;
pub const SCARD_S_SUCCESS = NO_ERROR;
pub const RPC_C_AUTHN_DIGEST = 21;
pub const CC_CIRCLES = 1;
pub const HELP_SETCONTENTS = @as(c_long, 5);
pub const FILE_TYPE_PIPE = 3;
pub const DC_TEXT = 8;
pub const CCHILDREN_SCROLLBAR = 5;
pub const THREAD_PRIORITY_IDLE = THREAD_BASE_PRIORITY_IDLE;
pub const MARK_HANDLE_NOT_TXF_SYSTEM_LOG = 8;
pub const ReadULongPtrAcquire = ReadULong64Acquire;
pub const TRANSACTION_NOTIFY_RECOVER = 256;
pub const ERROR_EXE_MARKED_INVALID = @as(c_long, 192);
pub const ES_LOWERCASE = @as(c_long, 16);
pub const ERROR_SXS_ASSEMBLY_NOT_FOUND = @as(c_long, 14003);
pub const SPI_GETAUDIODESCRIPTION = 116;
pub const MM_MIXM_CONTROL_CHANGE = 977;
pub const MDM_HDLCPPP_SPEED_56K = 2;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = 0;
pub const CRYPT_OID_INFO_OID_GROUP_BIT_LEN_MASK = 268369920;
pub const PROV_RSA_SCHANNEL = 12;
pub const DMDUP_HORIZONTAL = 3;
pub const ASSERT_PRIMARY = 8;
pub const PRINTER_CHANGE_FAILED_CONNECTION_PRINTER = 8;
pub const CryptSignHash = CryptSignHashA;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = 1;
pub const OBJID_CLIENT = if (@typeId(@typeOf(4294967292)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG, 4294967292) else if (@typeId(@typeOf(4294967292)) == @import("builtin").TypeId.Int) @intToPtr(LONG, 4294967292) else LONG(4294967292);
pub const ERROR_SXS_XML_E_MISSINGQUOTE = @as(c_long, 14030);
pub const CF_OWNERDISPLAY = 128;
pub const PDCAP_WARM_EJECT_SUPPORTED = 256;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_USE_HW_TIMESTAMP = 1;
pub const LBSELCHSTRING = LBSELCHSTRINGA;
pub const ERROR_INSTALL_OPEN_PACKAGE_FAILED = @as(c_long, 15600);
pub const BCRYPT_PBKDF2_ALG_HANDLE = if (@typeId(@typeOf(817)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 817) else if (@typeId(@typeOf(817)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 817) else BCRYPT_ALG_HANDLE(817);
pub const SE_SIGNING_LEVEL_MICROSOFT = 8;
pub const SPI_GETHIGHCONTRAST = 66;
pub const URLACTION_HTML_USERDATA_SAVE = 5638;
pub const TA_TOP = 0;
pub const ERROR_DISK_OPERATION_FAILED = @as(c_long, 1127);
pub const TAPE_DRIVE_CLEAN_REQUESTS = 33554432;
pub const IME_ESC_AUTOMATA = 4105;
pub const pascal = __stdcall;
pub const CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG = 1;
pub const DLL_THREAD_ATTACH = 2;
pub const MS_ENH_RSA_AES_PROV_XP_A = "Microsoft Enhanced RSA and AES Cryptographic Provider (Prototype)";
pub const CHANGER_LOCK_UNLOCK = 128;
pub const WSAESOCKTNOSUPPORT = @as(c_long, 10044);
pub const RPC_PROTSEQ_TCP = 1;
pub const MIXERR_BASE = 1024;
pub const MM_JOY1BUTTONDOWN = 949;
pub const PARTITION_BSP = 43;
pub const SUBLANG_SPANISH_PERU = 10;
pub const CERT_CHAIN_ENABLE_WEAK_SETTINGS_FLAG = 2147483648;
pub const _SEC_WINNT_AUTH_IDENTITY = _SEC_WINNT_AUTH_IDENTITY_A;
pub const TIME_VALID_OID_GET_OBJECT_FUNC = "TimeValidDllGetObject";
pub const FILE_REGION_USAGE_HUGE_PAGE_ALIGNMENT = 16;
pub const SERVICE_STOP_REASON_MAJOR_MIN = 0;
pub const ERROR_REPARSE = @as(c_long, 741);
pub const ERROR_CASE_DIFFERING_NAMES_IN_DIR = @as(c_long, 424);
pub const TA_BASELINE = 24;
pub const CERT_SCEP_SERVER_CERTS_PROP_ID = 108;
pub const __UINT_LEAST32_FMTx__ = "x";
pub const ERROR_DBG_COMMAND_EXCEPTION = @as(c_long, 697);
pub const ERROR_DEVICE_ENUMERATION_ERROR = @as(c_long, 648);
pub const stc18 = 1105;
pub const HSHELL_APPCOMMAND = 12;
pub const ALTERNATE = 1;
pub const EN_VSCROLL = 1538;
pub const PS_JOIN_ROUND = 0;
pub const HCBT_CREATEWND = 3;
pub const PARAMFLAG_FHASDEFAULT = 32;
pub const META_CREATEPENINDIRECT = 762;
pub const NCRYPT_ALLOW_PLAINTEXT_EXPORT_FLAG = 2;
pub const MOM_CLOSE = MM_MOM_CLOSE;
pub const DSS_HIDEPREFIX = 512;
pub const VENDOR_ID_LENGTH = 8;
pub const CREATE_UNICODE_ENVIRONMENT = 1024;
pub const ILLUMINANT_MAX_INDEX = ILLUMINANT_F2;
pub const ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE = @as(c_long, 14092);
pub const EMR_COLORCORRECTPALETTE = 111;
pub const NCRYPT_CIPHER_BLOCK_PADDING_FLAG = 1;
pub const RPC_S_GRP_ELT_NOT_REMOVED = @as(c_long, 1929);
pub const PPM_FIRMWARE_PSD = 512;
pub const ERROR_SXS_WRONG_SECTION_TYPE = @as(c_long, 14009);
pub const __INT_LEAST16_FMTi__ = "hi";
pub const PSEC_WINNT_AUTH_IDENTITY = PSEC_WINNT_AUTH_IDENTITY_A;
pub const CERT_ACCESS_STATE_SHARED_USER_FLAG = 16;
pub const ERROR_CHILD_NOT_COMPLETE = @as(c_long, 129);
pub const ERROR_INVALID_SEGDPL = @as(c_long, 198);
pub const AnsiPrev = CharPrevA;
pub const JOY_BUTTON21 = @as(c_long, 1048576);
pub const GL_LEVEL_ERROR = 2;
pub const TXFS_TRANSACTED_VERSION_NONTRANSACTED = 4294967294;
pub const IMAGE_ORDINAL_FLAG32 = 2147483648;
pub const szOID_NIST_AES192_WRAP = "2.16.840.1.101.3.4.1.25";
pub const RPC_S_OUT_OF_MEMORY = ERROR_OUTOFMEMORY;
pub const StartDocPrinter = StartDocPrinterA;
pub const EM_SETSEL = 177;
pub const HS_DIAGCROSS = 5;
pub const MIXERCONTROL_CT_CLASS_SLIDER = @as(c_long, 1073741824);
pub const SERIAL_IOC_FCR_DMA_MODE = if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 8) else if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 8) else DWORD(8);
pub const _WIN32_IE_WINME = _WIN32_IE_IE55;
pub const CRYPT_FORMAT_STR_MULTI_LINE = 1;
pub const WHDR_ENDLOOP = 8;
pub const MCI_DEVTYPE_ANIMATION = 519;
pub const CERT_DEFAULT_OID_PUBLIC_KEY_SIGN = szOID_RSA_RSA;
pub const SECURITY_SERVICE_ID_BASE_RID = @as(c_long, 80);
pub const WM_INITMENUPOPUP = 279;
pub const scr7 = 1174;
pub const VarUintFromInt = VarUI4FromI4;
pub const SCS_CAP_SETRECONVERTSTRING = 4;
pub const RPC_C_NS_DEFAULT_EXP_AGE = -1;
pub const ERROR_IO_INCOMPLETE = @as(c_long, 996);
pub const CTRY_NETHERLANDS = 31;
pub const CERT_ALT_NAME_URL = 7;
pub const __LDBL_MAX_EXP__ = 1024;
pub const PROV_SPYRUS_LYNKS = 20;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER = 56;
pub const FILE_ATTRIBUTE_DIRECTORY = 16;
pub const CRYPT_FORMAT_X509 = 2;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE = 57;
pub const WM_IME_COMPOSITION = 271;
pub const szOID_OIWSEC_mdc2RSA = "1.3.14.3.2.14";
pub const KP_SERVER_RANDOM = 22;
pub const IS_TEXT_UNICODE_REVERSE_STATISTICS = 32;
pub const NRC_TOOMANY = 34;
pub const DNS_ERROR_NAME_DOES_NOT_EXIST = @as(c_long, 9714);
pub const MMIOERR_BASE = 256;
pub const SCARD_ATTR_DEVICE_FRIENDLY_NAME = SCARD_ATTR_DEVICE_FRIENDLY_NAME_A;
pub const CHANGER_MOVE_RETRACTS_IEPORT = 2147484672;
pub const TLS_OUT_OF_INDEXES = if (@typeId(@typeOf(4294967295)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 4294967295) else if (@typeId(@typeOf(4294967295)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 4294967295) else DWORD(4294967295);
pub const ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION = @as(c_long, 15202);
pub const PRINTER_NOTIFY_FIELD_PRINTER_NAME = 1;
pub const LANG_GERMAN = 7;
pub const SERVICE_ENUMERATE_DEPENDENTS = 8;
pub const NO_ADDRESS = WSANO_ADDRESS;
pub const LANG_SERBIAN_NEUTRAL = 31770;
pub const IMAGE_HOT_PATCH_NO_CALL_TARGET = 409600;
pub const REGISTERING = 0;
pub const IMAGE_SYM_CLASS_FAR_EXTERNAL = 68;
pub const JOB_OBJECT_LIMIT_RATE_CONTROL = 262144;
pub const BCRYPT_3DES_CFB_ALG_HANDLE = if (@typeId(@typeOf(353)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 353) else if (@typeId(@typeOf(353)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 353) else BCRYPT_ALG_HANDLE(353);
pub const MIIM_DATA = 32;
pub const PST_FAX = if (@typeId(@typeOf(33)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 33) else if (@typeId(@typeOf(33)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 33) else DWORD(33);
pub const __UINT_FAST16_FMTX__ = "hX";
pub const mixerGetLineInfo = mixerGetLineInfoA;
pub const DISK_LOGGING_DUMP = 2;
pub const SUBLANG_LUXEMBOURGISH_LUXEMBOURG = 1;
pub const POLICY_SHOWREASONUI_ALWAYS = 1;
pub const LOCALE_SENGLISHLANGUAGENAME = 4097;
pub const ERROR_RELOC_CHAIN_XEEDS_SEGLIM = @as(c_long, 201);
pub const STORAGE_PRIORITY_HINT_SUPPORTED = 1;
pub const PRINTER_DRIVER_CATEGORY_FILE = 128;
pub const ERROR_THREAD_ALREADY_IN_TASK = @as(c_long, 1552);
pub const ObjectOpenAuditAlarm = ObjectOpenAuditAlarmA;
pub const ERROR_CANT_ACCESS_DOMAIN_INFO = @as(c_long, 1351);
pub const szOID_RDN_TCG_PLATFORM_MANUFACTURER = "2.23.133.2.4";
pub const SM_CXMINTRACK = 34;
pub const LANG_UPPER_SORBIAN = 46;
pub const LZERROR_WRITE = -4;
pub const mmioOpen = mmioOpenA;
pub const PRINTER_NOTIFY_FIELD_START_TIME = 16;
pub const STATUS_INVALID_CRUNTIME_PARAMETER = if (@typeId(@typeOf(@as(c_long, 3221226519))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221226519)) else if (@typeId(@typeOf(@as(c_long, 3221226519))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221226519)) else DWORD(@as(c_long, 3221226519));
pub const FD_CONNECT = 16;
pub const PROCESSOR_ARCHITECTURE_NEUTRAL = 11;
pub const ERROR_DS_CANT_CACHE_CLASS = @as(c_long, 8402);
pub const IMAGE_SYM_TYPE_BYTE = 12;
pub const PRINTER_NOTIFY_OPTIONS_REFRESH = 1;
pub const GWL_ID = -12;
pub const __inner_assume_bound = i;
pub const PRINTER_ATTRIBUTE_SHARED = 8;
pub const VK_MEDIA_PLAY_PAUSE = 179;
pub const PRODUCT_INDUSTRY_HANDHELD = 118;
pub const SCARD_AUDIT_CHV_SUCCESS = 1;
pub const WS_POPUP = @as(c_long, 2147483648);
pub const WNNC_NET_MANGOSOFT = 1835008;
pub const KL_NAMELENGTH = 9;
pub const PI_DOCFILECLSIDLOOKUP = PI_CLSIDLOOKUP;
pub const VK_NAVIGATION_ACCEPT = 142;
pub const CADV_LATEACK = 65535;
pub const VER_SUITE_BLADE = 1024;
pub const stc19 = 1106;
pub const SHTDN_REASON_MAJOR_APPLICATION = 262144;
pub const COPY_FILE_ALLOW_DECRYPTED_DESTINATION = 8;
pub const CDERR_MEMALLOCFAILURE = 9;
pub const ALG_SID_EXAMPLE = 80;
pub const RpcNsGroupDelete = RpcNsGroupDeleteA;
pub const __INT64_FMTi__ = "lli";
pub const MS_DEF_PROV_A = "Microsoft Base Cryptographic Provider v1.0";
pub const SPI_GETFOCUSBORDERWIDTH = 8206;
pub const BS_MONOPATTERN = 9;
pub const INITIAL_FPCSR = 639;
pub const RPC_S_BINDING_HAS_NO_AUTH = @as(c_long, 1746);
pub const LPOPENCARDNAMEW_EX = LPOPENCARDNAME_EXW;
pub const GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY = 1152921504606846976;
pub const USER_MARSHAL_FC_ULONG = 9;
pub const MIIM_TYPE = 16;
pub const SHIL_SMALL = 1;
pub const ERROR_SXS_THREAD_QUERIES_DISABLED = @as(c_long, 14010);
pub const _WIN32_IE_WIN98SE = _WIN32_IE_IE50;
pub const DISP_CHANGE_SUCCESSFUL = 0;
pub const RpcBindingCreate = RpcBindingCreateA;
pub const PWR_SUSPENDRESUME = 2;
pub const ERROR_INVALID_KERNEL_INFO_VERSION = @as(c_long, 340);
pub const __UINT_LEAST64_FMTX__ = "llX";
pub const ERROR_IPSEC_IKE_NO_CERT = @as(c_long, 13806);
pub const MCI_ANIM_PLAY_REVERSE = @as(c_long, 131072);
pub const JOY_BUTTON22 = @as(c_long, 2097152);
pub const PSBTN_FINISH = 2;
pub const CERT_ALT_NAME_DNS_NAME = 3;
pub const ERROR_CLUSTER_NOT_INSTALLED = @as(c_long, 5932);
pub const DOMAIN_ALIAS_RID_HYPER_V_ADMINS = @as(c_long, 578);
pub const _WIN32_IE_IE50 = 1280;
pub const RPC_C_AUTHN_DCE_PUBLIC = 2;
pub const RPC_C_OPT_CALL_TIMEOUT = 12;
pub const ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT = @as(c_long, 1651);
pub const ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED = @as(c_long, 3005);
pub const ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE = @as(c_long, 5030);
pub const SM_CXHTHUMB = 10;
pub const ERROR_IPSEC_IKE_INVALID_MM_FOR_QM = @as(c_long, 13894);
pub const DCOMSCM_RESOLVE_DISALLOW_UNSECURE_CALL = 8;
pub const EVENTLOG_SUCCESS = 0;
pub const LANG_SANSKRIT = 79;
pub const PAN_STRAIGHT_ARMS_HORZ = 2;
pub const CBM_INIT = @as(c_long, 4);
pub const CMSG_USE_SIGNER_INDEX_FLAG = 4;
pub const scr6 = 1173;
pub const SHTDN_REASON_FLAG_DIRTY_UI = 134217728;
pub const __UINT8_FMTX__ = "hhX";
pub const SECURITY_STATIC_TRACKING = FALSE;
pub const CMSG_MAIL_LIST_HANDLE_KEY_CHOICE = 1;
pub const SW_HIDE = 0;
pub const WriteOnceDiskClassGuid = GUID_DEVINTERFACE_WRITEONCEDISK;
pub const RPC_S_OK = ERROR_SUCCESS;
pub const ERROR_DS_ILLEGAL_MOD_OPERATION = @as(c_long, 8311);
pub const szOID_INTERNATIONAL_ISDN_NUMBER = "2.5.4.25";
pub const szOID_RSA_SMIMEalgESDH = "1.2.840.113549.1.9.16.3.5";
pub const SYSTEM_AUDIT_ACE_TYPE = 2;
pub const ERROR_OPERATION_NOT_ALLOWED_FROM_SYSTEM_COMPONENT = @as(c_long, 15145);
pub const X3_OPCODE_INST_WORD_POS_X = 28;
pub const RESTART_NO_PATCH = 4;
pub const ERROR_DS_VERSION_CHECK_FAILURE = @as(c_long, 643);
pub const DNS_ERROR_SECONDARY_DATA = @as(c_long, 9712);
pub const QUERY_FILE_LAYOUT_RESTART = 1;
pub const GCS_CURSORPOS = 128;
pub const PSD_INTHOUSANDTHSOFINCHES = 4;
pub const IMAGE_SCN_MEM_16BIT = 131072;
pub const MB_CANCELTRYCONTINUE = @as(c_long, 6);
pub const _PROPSHEETPAGEA_V4 = _PROPSHEETPAGEA;
pub const CBS_SORT = @as(c_long, 256);
pub const SetFileSecurity = SetFileSecurityA;
pub const VK_MODECHANGE = 31;
pub const CERT_CHAIN_DISABLE_AIA = 8192;
pub const _WIN32_IE_WINBLUE = _WIN32_IE_IE100;
pub const szOID_CERT_POLICIES = "2.5.29.32";
pub const IOInetBindInfo = IInternetBindInfo;
pub const MFT_MENUBARBREAK = MF_MENUBARBREAK;
pub const ERROR_TOO_MANY_SECRETS = @as(c_long, 1381);
pub const POLICY_SHOWREASONUI_NEVER = 0;
pub const ERROR_SAM_INIT_FAILURE = @as(c_long, 8541);
pub const PAGE_GRAPHICS_EXECUTE_READWRITE = 65536;
pub const ERROR_DLL_MIGHT_BE_INCOMPATIBLE = @as(c_long, 687);
pub const ERROR_INVALID_ACL = @as(c_long, 1336);
pub const TXFS_RM_FLAG_PREFER_AVAILABILITY = 131072;
pub const IMAGE_SYM_CLASS_STRUCT_TAG = 10;
pub const PENVISUALIZATION_OFF = 0;
pub const AD_COUNTERCLOCKWISE = 1;
pub const PC_PATHS = 512;
pub const TOUCH_HIT_TESTING_PROXIMITY_FARTHEST = 4095;
pub const CERT_DSS_R_LEN = 20;
pub const SBM_SETRANGE = 226;
pub const MAX_TOUCH_COUNT = 256;
pub const BITSPIXEL = 12;
pub const POINTER_FLAG_THIRDBUTTON = 64;
pub const PS_JOIN_BEVEL = 4096;
pub const BAUD_38400 = if (@typeId(@typeOf(16384)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 16384) else if (@typeId(@typeOf(16384)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 16384) else DWORD(16384);
pub const MDM_SHIFT_V110_SPEED = 0;
pub const InterlockedDecrementAcquire16 = _InterlockedDecrement16;
pub const CORE_PARKING_POLICY_CHANGE_MULTISTEP = 3;
pub const COPY_FILE_REQUEST_COMPRESSED_TRAFFIC = 16777216;
pub const CERT_NAME_RDN_TYPE = 2;
pub const PAN_SERIF_OBTUSE_SANS = 12;
pub const IMAGE_FILE_MACHINE_AM33 = 467;
pub const ASPECT_FILTERING = 1;
pub const IMAGE_DIRECTORY_ENTRY_IAT = 12;
pub const CMSG_CERT_COUNT_PARAM = 11;
pub const GCP_NEUTRALOVERRIDE = @as(c_long, 33554432);
pub const BuildCommDCB = BuildCommDCBA;
pub const TC_SA_INTEGER = 128;
pub const EEInfoGCFRS = 12;
pub const FACILITY_PLA = 48;
pub const TPM_VCENTERALIGN = @as(c_long, 16);
pub const NTDDI_WIN6SP1 = 100663552;
pub const MCI_STEP = 2062;
pub const MM_MIM_MOREDATA = 972;
pub const szOID_RSA_DES_EDE3_CBC = "1.2.840.113549.3.7";
pub const ERROR_GROUPSET_NOT_AVAILABLE = @as(c_long, 5991);
pub const REG_CREATED_NEW_KEY = @as(c_long, 1);
pub const _LOWER = 2;
pub const LOCALE_SPERMILLE = 119;
pub const CERT_TRUST_IS_REVOKED = 4;
pub const ERROR_CONTEXT_EXPIRED = @as(c_long, 1931);
pub const ACCESS_MAX_MS_OBJECT_ACE_TYPE = 8;
pub const CALLBACK_STREAM_SWITCH = 1;
pub const BF_ADJUST = 8192;
pub const PAN_LETT_OBLIQUE_FLATTENED = 12;
pub const CSOUND_SYSTEM = 16;
pub const InterlockedBitTestAndReset64Acquire = _interlockedbittestandreset64;
pub const ZeroMemory = RtlZeroMemory;
pub const SetDefaultPrinter = SetDefaultPrinterA;
pub const RPC_BUFFER_NONOTIFY = 65536;
pub const URLACTION_SHELL_SECURE_DRAGSOURCE = 6157;
pub const STGM_SHARE_EXCLUSIVE = @as(c_long, 16);
pub const ERROR_MRM_AUTOMERGE_ENABLED = @as(c_long, 15139);
pub const Uri_ENCODING_USER_INFO_AND_PATH_IS_CP = 2;
pub const PAN_FAMILY_DECORATIVE = 4;
pub const NCRYPT_PROTECT_TO_LOCAL_SYSTEM = 32768;
pub const IMAGE_REL_AMD64_IMPORT_BR = 18;
pub const VK_RSHIFT = 161;
pub const DOMAIN_USER_RID_ADMIN = @as(c_long, 500);
pub const LMEM_NOCOMPACT = 16;
pub const MCI_WAIT = @as(c_long, 2);
pub const CRYPT_MODE_CBCI = 6;
pub const CERT_CHAIN_DISABLE_FILE_HASH_WEAK_FLAG = 4096;
pub const IMAGE_SYM_CLASS_ARGUMENT = 9;
pub const ERROR_INVALID_SPI_VALUE = @as(c_long, 1439);
pub const PCF_SETXCHAR = if (@typeId(@typeOf(32)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 32) else if (@typeId(@typeOf(32)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 32) else DWORD(32);
pub const IME_REGWORD_STYLE_USER_LAST = 4294967295;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_USER_LOG_OFF = @as(c_long, 15641);
pub const ERROR_WMI_GUID_DISCONNECTED = @as(c_long, 4207);
pub const JOY_CAL_READRONLY = @as(c_long, 33554432);
pub const SPI_SETHANDEDNESS = 8229;
pub const RC_OP_DX_OUTPUT = 16384;
pub const ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION = @as(c_long, 5912);
pub const GetConsoleCommandHistory = GetConsoleCommandHistoryA;
pub const PFD_GENERIC_ACCELERATED = 4096;
pub const VK_MEDIA_NEXT_TRACK = 176;
pub const CERT_COMPARE_HASH = CERT_COMPARE_SHA1_HASH;
pub const PAGE_GRAPHICS_EXECUTE = 16384;
pub const MDM_MASK_AUTO_ML = 3 << 6;
pub const _Analysis_assume_lock_released_ = lock;
pub const __REQUIRED_RPCNDR_H_VERSION__ = 500;
pub const MOUSE_MOVED = 1;
pub const DMPAPER_11X17 = 17;
pub const RI_MOUSE_BUTTON_5_DOWN = 256;
pub const ERROR_CANT_DISABLE_MANDATORY = @as(c_long, 1310);
pub const PSINJECT_BEGINSETUP = 16;
pub const DMPAPER_B6_JIS = 88;
pub const APPCOMMAND_MEDIA_PREVIOUSTRACK = 12;
pub const FAST_FAIL_ADMINLESS_ACCESS_DENIED = 55;
pub const SERVICE_TRIGGER_DATA_TYPE_LEVEL = 3;
pub const JOY_BUTTON23 = @as(c_long, 4194304);
pub const SECURITY_MANDATORY_HIGH_RID = @as(c_long, 12288);
pub const PROCESS_CREATION_CHILD_PROCESS_RESTRICTED = 1;
pub const CBF_FAIL_CONNECTIONS = 8192;
pub const DEVICE_DSM_NOTIFY_FLAG_END = 2;
pub const CERT_CHAIN_POLICY_IGNORE_CTL_SIGNER_REV_UNKNOWN_FLAG = 512;
pub const RGN_OR = 2;
pub const VarIntFromCy = VarI4FromCy;
pub const ERROR_REM_NOT_LIST = @as(c_long, 51);
pub const ERROR_UNABLE_TO_UNLOAD_MEDIA = @as(c_long, 1109);
pub const ERROR_CLIENT_SERVER_PARAMETERS_INVALID = @as(c_long, 597);
pub const ERROR_DS_DRA_OUT_OF_MEM = @as(c_long, 8446);
pub const CREATE_DEFAULT_ERROR_MODE = 67108864;
pub const MIXERCONTROL_CONTROLF_DISABLED = @as(c_long, 2147483648);
pub const RESOURCEDISPLAYTYPE_FILE = 4;
pub const LB_GETLOCALE = 422;
pub const scr5 = 1172;
pub const SERVER_NOTIFY_FIELD_PRINT_DRIVER_ISOLATION_GROUP = 0;
pub const ERROR_SXS_XML_E_MULTIPLE_COLONS = @as(c_long, 14046);
pub const CreateDirectoryTransacted = CreateDirectoryTransactedA;
pub const CRYPT_NO_AUTH_RETRIEVAL = 131072;
pub const SECURITY_CREATOR_OWNER_RIGHTS_RID = @as(c_long, 4);
pub const ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC = @as(c_long, 8487);
pub const PSINJECT_ENDDEFAULTS = 13;
pub const AnsiUpper = CharUpperA;
pub const CMSG_MAIL_LIST_ENCRYPT_FREE_OBJID_FLAG = 2;
pub const WM_NCXBUTTONDBLCLK = 173;
pub const META_SETMAPPERFLAGS = 561;
pub const szOID_USER_CERTIFICATE = "2.5.4.36";
pub const ERROR_PNP_IRQ_TRANSLATION_FAILED = @as(c_long, 673);
pub const SC_PREVWINDOW = 61520;
pub const X3_P_SIZE_X = 4;
pub const SM_TABLETPC = 86;
pub const PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_ALWAYS_OFF = if (@typeId(@typeOf(i64 << 48)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 2), i64 << 48) else if (@typeId(@typeOf(i64 << 48)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 2), i64 << 48) else @as(c_uint, 2)(i64 << 48);
pub const RPC_IF_ALLOW_UNKNOWN_AUTHORITY = 4;
pub const BCRYPT_MD5_ALG_HANDLE = if (@typeId(@typeOf(33)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 33) else if (@typeId(@typeOf(33)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 33) else BCRYPT_ALG_HANDLE(33);
pub const IS_TEXT_UNICODE_UNICODE_MASK = 15;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP = 4;
pub const REGDB_E_LAST = @as(c_long, 2147746143);
pub const ERROR_INSTALL_UI_FAILURE = @as(c_long, 1621);
pub const PM_REMOVE = 1;
pub const ERROR_VIRUS_INFECTED = @as(c_long, 225);
pub const ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS = @as(c_long, 5913);
pub const ERROR_VSM_DMA_PROTECTION_NOT_IN_USE = @as(c_long, 4561);
pub const TOKEN_MANDATORY_POLICY_NO_WRITE_UP = 1;
pub const CRYPT_OID_FORMAT_OBJECT_FUNC = "CryptDllFormatObject";
pub const ERROR_SXS_ASSEMBLY_NOT_LOCKED = @as(c_long, 14097);
pub const CLASSFACTORY_E_FIRST = @as(c_long, 2147746064);
pub const TOKEN_DUPLICATE = 2;
pub const VER_SUITE_WH_SERVER = 32768;
pub const COPY_FILE_REQUEST_SECURITY_PRIVILEGES = 8192;
pub const ERROR_NO_YIELD_PERFORMED = @as(c_long, 721);
pub const ModifyMenu = ModifyMenuA;
pub const ERROR_DS_BUSY = @as(c_long, 8206);
pub const ERROR_CAPAUTHZ_SCCD_NO_AUTH_ENTITY = @as(c_long, 457);
pub const SB_RIGHT = 7;
pub const SP_NOTREPORTED = 16384;
pub const RPC_C_OPT_MAX_OPTIONS = 17;
pub const PROV_EC_ECDSA_FULL = 16;
pub const CERT_PROT_ROOT_ONLY_LM_GPT_FLAG = 8;
pub const ATTACH_PARENT_PROCESS = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, -1) else DWORD(-1);
pub const EFS_PFILE_SUBVER_APPX = 3;
pub const RTL_CONDITION_VARIABLE_LOCKMODE_SHARED = 1;
pub const FLI_GLYPHS = @as(c_long, 262144);
pub const BSF_POSTMESSAGE = 16;
pub const MF_MENUBARBREAK = @as(c_long, 32);
pub const AF_CCITT = 10;
pub const PRINTER_CHANGE_ADD_FORM = 65536;
pub const OBJID_QUERYCLASSNAMEIDX = if (@typeId(@typeOf(4294967284)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG, 4294967284) else if (@typeId(@typeOf(4294967284)) == @import("builtin").TypeId.Int) @intToPtr(LONG, 4294967284) else LONG(4294967284);
pub const SB_CONST_ALPHA = 1;
pub const MAX_STR_BLOCKREASON = 256;
pub const ERROR_IPSEC_IKE_QM_LIMIT = @as(c_long, 13884);
pub const PP_ENUMALGS_EX = 22;
pub const ECANCELED = 105;
pub const THREAD_DIRECT_IMPERSONATION = 512;
pub const ERROR_NETWORK_BUSY = @as(c_long, 54);
pub const WNNC_NET_9TILES = 589824;
pub const CERT_STORE_PROV_PHYSICAL_W = if (@typeId(@typeOf(14)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 14) else if (@typeId(@typeOf(14)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 14) else LPCSTR(14);
pub const X509_PUBLIC_KEY_INFO = if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 8) else if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 8) else LPCSTR(8);
pub const POWER_PLATFORM_ROLE_VERSION = POWER_PLATFORM_ROLE_V2;
pub const PSCARD_READERSTATE_W = PSCARD_READERSTATEW;
pub const ERROR_IPSEC_MM_AUTH_NOT_FOUND = @as(c_long, 13011);
pub const ImmGetIMEFileName = ImmGetIMEFileNameA;
pub const EMARCH_ENC_I17_SIGN_SIZE_X = 1;
pub const VER_BUILDNUMBER = 4;
pub const TAPE_DRIVE_LOGICAL_BLK = 2147500032;
pub const IMAGE_REL_AM_SECREL = 7;
pub const BACKUP_SECURITY_DATA = 3;
pub const BF_MONO = 32768;
pub const SE_GROUP_ENABLED = @as(c_long, 4);
pub const CF_METAFILEPICT = 3;
pub const NTDDI_WIN6SP2 = 100663808;
pub const ATTR_TARGET_NOTCONVERTED = 3;
pub const ERROR_DS_CANT_MOVE_APP_QUERY_GROUP = @as(c_long, 8609);
pub const SHTDN_REASON_MINOR_SERVICEPACK = 16;
pub const CMSG_OID_CAPI1_IMPORT_KEY_AGREE_FUNC = CMSG_OID_IMPORT_KEY_AGREE_FUNC;
pub const SC_GROUP_IDENTIFIER = SC_GROUP_IDENTIFIERA;
pub const VK_MENU = 18;
pub const szOID_RSA_HASH = "1.2.840.113549.2";
pub const SHAREVISTRINGA = "commdlg_ShareViolation";
pub const PIDMSI_SUPPLIER = @as(c_long, 3);
pub const CERT_TRUST_HAS_EXACT_MATCH_ISSUER = 1;
pub const WAVE_FORMAT_96M16 = 262144;
pub const WM_DWMWINDOWMAXIMIZEDCHANGE = 801;
pub const JOB_OBJECT_POST_AT_END_OF_JOB = 1;
pub const DI_READ_SPOOL_JOB = 3;
pub const ERROR_ENCRYPTION_FAILED = @as(c_long, 6000);
pub const ERROR_POPUP_ALREADY_ACTIVE = @as(c_long, 1446);
pub const ERROR_GROUP_NOT_FOUND = @as(c_long, 5013);
pub const MCI_VD_PLAY_FAST = @as(c_long, 131072);
pub const KP_RP = 23;
pub const TIMERR_NOERROR = 0;
pub const DDE_FPOKRESERVED = ~DDE_FRELEASE;
pub const GF_BEGIN = 1;
pub const TAPE_SPACE_SEQUENTIAL_FMKS = @as(c_long, 7);
pub const GetICMProfile = GetICMProfileA;
pub const CE_DNS = 2048;
pub const EMR_SETPIXELV = 15;
pub const DEVICEFAMILYDEVICEFORM_TOY = 27;
pub const StorageIdTypeNAA = StorageIdTypeFCPHName;
pub const ERROR_IPSEC_IKE_SRVQUERYCRED = @as(c_long, 13856);
pub const HELPMSGSTRING = HELPMSGSTRINGA;
pub const WM_NCDESTROY = 130;
pub const SERVICE_TRIGGER_TYPE_CUSTOM_SYSTEM_STATE_CHANGE = 7;
pub const ZERO_PADDING = 3;
pub const ERROR_NO_USER_KEYS = @as(c_long, 6006);
pub const SYSTEM_ALARM_OBJECT_ACE_TYPE = 8;
pub const GetNamedPipeClientComputerName = GetNamedPipeClientComputerNameA;
pub const PKCS12_PBKDF2_ID_HMAC_SHA384 = "1.2.840.113549.2.10";
pub const ERROR_UNABLE_TO_LOAD_MEDIUM = @as(c_long, 4324);
pub const SS_ETCHEDHORZ = @as(c_long, 16);
pub const BCRYPT_SP800108_CTR_HMAC_ALG_HANDLE = if (@typeId(@typeOf(833)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 833) else if (@typeId(@typeOf(833)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 833) else BCRYPT_ALG_HANDLE(833);
pub const IMAGE_SCN_ALIGN_4BYTES = 3145728;
pub const Uri_ENCODING_HOST_IS_PERCENT_ENCODED_UTF8 = 8;
pub const FILE_VER_GET_PREFETCHED = 4;
pub const CERT_OCSP_CACHE_PREFIX_PROP_ID = 75;
pub const PPM_FIRMWARE_CSD = 16;
pub const __LITTLE_ENDIAN__ = 1;
pub const ERROR_DS_CANT_ADD_ATT_VALUES = @as(c_long, 8320);
pub const CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG = 1;
pub const SW_RESTORE = 9;
pub const CTRY_SERBIA = 381;
pub const WS_EX_LEFTSCROLLBAR = @as(c_long, 16384);
pub const CHANGER_TO_DRIVE = 8;
pub const PRINTER_CHANGE_DELETE_JOB = 1024;
pub const PF_FLOATING_POINT_PRECISION_ERRATA = 0;
pub const NCRYPTBUFFER_PKCS_KEY_NAME = 45;
pub const CALLBACK_NULL = @as(c_long, 0);
pub const SUBLANG_NORWEGIAN_NYNORSK = 2;
pub const SCARD_RESET_CARD = 1;
pub const ERROR_WINDOW_NOT_DIALOG = @as(c_long, 1420);
pub const TC_OP_CHARACTER = 1;
pub const PAN_CONTRAST_NONE = 2;
pub const szOID_RSA_signEnvData = "1.2.840.113549.1.7.4";
pub const TAPE_DRIVE_RESERVED_BIT = 2147483648;
pub const ERROR_DS_LOCAL_ERROR = @as(c_long, 8251);
pub const MM_MOM_DONE = 969;
pub const VK_OEM_AUTO = 243;
pub const scr4 = 1171;
pub const TRANSACTION_MAXIMUM_OPTION = 1;
pub const JOYCAPS_HASR = 2;
pub const CreateMutex = CreateMutexA;
pub const _RPC_SECURITY_QOS_V5 = _RPC_SECURITY_QOS_V5_A;
pub const CERT_INFO_EXTENSION_FLAG = 11;
pub const SBM_SETPOS = 224;
pub const IDANI_OPEN = 1;
pub const LB_INSERTSTRING = 385;
pub const POWER_USER_NOTIFY_FORCED_SHUTDOWN = 32;
pub const CB_ADDSTRING = 323;
pub const WSAEADDRNOTAVAIL = @as(c_long, 10049);
pub const IE_OPEN = -2;
pub const IMN_OPENCANDIDATE = 5;
pub const SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_RID_COUNT = @as(c_long, 6);
pub const WM_NULL = 0;
pub const RPC_C_AUTHN_GSS_NEGOTIATE = 9;
pub const CRYPT_VERIFY_CERT_SIGN_ISSUER_CHAIN = 3;
pub const PARAMFLAG_FIN = 1;
pub const LOGON32_PROVIDER_WINNT40 = 2;
pub const POWERBUTTON_ACTION_INDEX_NOTHING = 0;
pub const MEM_RESET_UNDO = 16777216;
pub const GetCalendarInfo = GetCalendarInfoA;
pub const RPCFLG_LOCAL_CALL = @as(c_ulong, 268435456);
pub const MMIO_COMPAT = 0;
pub const ERROR_INVALID_VARIANT = @as(c_long, 604);
pub const ERROR_SPECIAL_GROUP = @as(c_long, 1372);
pub const DNS_ERROR_POLICY_INVALID_NAME = @as(c_long, 9982);
pub const szOID_INFOSEC_mosaicIntegrity = "2.16.840.1.101.2.1.1.6";
pub const PRODUCT_STANDARD_EVALUATION_SERVER_CORE = 160;
pub const CRYPT_ACQUIRE_PREFER_NCRYPT_KEY_FLAG = 131072;
pub const ALG_SID_RSA_ANY = 0;
pub const SPI_SETDRAGFROMMAXIMIZE = 141;
pub const ERROR_DS_VALUE_KEY_NOT_UNIQUE = @as(c_long, 8650);
pub const LANG_YORUBA = 106;
pub const SUBLANG_DIVEHI_MALDIVES = 1;
pub const JOB_OBJECT_UILIMIT_WRITECLIPBOARD = 4;
pub const MF_MASK = 4278190080;
pub const ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION = @as(c_long, 6853);
pub const NCRYPTBUFFER_PKCS_OID = 40;
pub const ODA_SELECT = 2;
pub const RotateRight8 = _rotr8;
pub const CALERT_SYSTEM = 6;
pub const __INT_FAST8_FMTd__ = "hhd";
pub const InterlockedCompareExchangeNoFence = _InterlockedCompareExchange;
pub const PROV_DSS = 3;
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED = 16;
pub const ERROR_INVALID_STAGED_SIGNATURE = @as(c_long, 15620);
pub const EMR_RESIZEPALETTE = 51;
pub const szOID_KP_KERNEL_MODE_TRUSTED_BOOT_SIGNING = "1.3.6.1.4.1.311.61.4.1";
pub const CRL_REASON_SUPERSEDED = 4;
pub const MB_PRECOMPOSED = 1;
pub const szOID_ENROLL_EKVERIFYKEY = "1.3.6.1.4.1.311.21.30";
pub const SECURITY_CAPABILITY_BASE_RID = @as(c_long, 3);
pub const PRINTER_FONTTYPE = 16384;
pub const ERROR_DS_SECURITY_CHECKING_ERROR = @as(c_long, 8413);
pub const PERF_COUNTER_HISTOGRAM_TYPE = 2147483648;
pub const TIMER_QUERY_STATE = 1;
pub const AF_FIREFOX = 19;
pub const ERROR_BAD_DRIVER_LEVEL = @as(c_long, 119);
pub const DI_DEFAULTSIZE = 8;
pub const ERROR_PWD_TOO_RECENT = @as(c_long, 616);
pub const CONSOLE_FULLSCREEN_MODE = 1;
pub const PROCESSOR_HITACHI_SH3 = 10003;
pub const ERROR_VIRUS_DELETED = @as(c_long, 226);
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_IN_USE = 16777216;
pub const GetOutlineTextMetrics = GetOutlineTextMetricsA;
pub const DT_EXPANDTABS = 64;
pub const PROCESS_QUERY_LIMITED_INFORMATION = 4096;
pub const IMAGE_REL_IA64_IMMGPREL64 = 26;
pub const IMAGE_REL_ARM_BRANCH24T = 20;
pub const PC_EXPLICIT = 2;
pub const SetProp = SetPropA;
pub const IME_JHOTKEY_CLOSE_OPEN = 48;
pub const ERROR_SXS_EARLY_DEACTIVATION = @as(c_long, 14084);
pub const ERROR_DEPENDENCY_NOT_FOUND = @as(c_long, 5002);
pub const ERROR_NOT_A_CLOUD_SYNC_ROOT = @as(c_long, 405);
pub const WM_USERCHANGED = 84;
pub const ERROR_SETMARK_DETECTED = @as(c_long, 1103);
pub const RPC_C_AUTHN_DPA = 17;
pub const NTDDI_WIN6SP3 = 100664064;
pub const IDLFLAG_FLCID = PARAMFLAG_FLCID;
pub const LPTx = 128;
pub const ERROR_CLUSTER_CANT_DESERIALIZE_DATA = @as(c_long, 5923);
pub const CFS_POINT = 2;
pub const ERROR_SXS_XML_E_BADXMLDECL = @as(c_long, 14056);
pub const APPCOMMAND_BROWSER_BACKWARD = 1;
pub const GetProp = GetPropA;
pub const RPC_S_NO_PRINC_NAME = @as(c_long, 1822);
pub const ERROR_LOG_CONTAINER_STATE_INVALID = @as(c_long, 6642);
pub const GetServiceDisplayName = GetServiceDisplayNameA;
pub const CaptureStackBackTrace = RtlCaptureStackBackTrace;
pub const szOID_OIWSEC_dsaSHA1 = "1.3.14.3.2.27";
pub const VK_OEM_8 = 223;
pub const IE_BYTESIZE = -11;
pub const WM_SYNCPAINT = 136;
pub const TRANSACTION_MANAGER_COMMIT_LOWEST = 8;
pub const SM_MIDEASTENABLED = 74;
pub const ABN_WINDOWARRANGE = 3;
pub const __FLT_HAS_INFINITY__ = 1;
pub const MCI_FORMAT_TMSF = 10;
pub const MS_ENH_DSS_DH_PROV_A = "Microsoft Enhanced DSS and Diffie-Hellman Cryptographic Provider";
pub const FKF_INDICATOR = 32;
pub const SS_PATHELLIPSIS = @as(c_long, 32768);
pub const POINTER_FLAG_HASTRANSFORM = 4194304;
pub const MM_MIM_DATA = 963;
pub const GetFirmwareEnvironmentVariable = GetFirmwareEnvironmentVariableA;
pub const MCI_NOTIFY_SUPERSEDED = 2;
pub const SBS_LEFTALIGN = @as(c_long, 2);
pub const RpcNsBindingExportPnP = RpcNsBindingExportPnPA;
pub const ERROR_IPSEC_CLEAR_TEXT_DROP = @as(c_long, 13916);
pub const MSGFLTINFO_ALREADYDISALLOWED_FORWND = 2;
pub const SPI_SETICONMETRICS = 46;
pub const CRYPT_ALL_FUNCTIONS = 1;
pub const PKCS_UTC_TIME = if (@typeId(@typeOf(17)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 17) else if (@typeId(@typeOf(17)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 17) else LPCSTR(17);
pub const EMR_REALIZEPALETTE = 52;
pub const szOID_ECDSA_SPECIFIED = "1.2.840.10045.4.3";
pub const TRANSACTIONMANAGER_CREATE_RM = 16;
pub const USN_REASON_BASIC_INFO_CHANGE = 32768;
pub const BCRYPT_ECC_FULLKEY_BLOB_V1 = 1;
pub const SCS_SETRECONVERTSTRING = 65536;
pub const SPI_GETFONTSMOOTHINGCONTRAST = 8204;
pub const szOID_NETSCAPE_REVOCATION_URL = "2.16.840.1.113730.1.3";
pub const SERVICE_STOP_REASON_MAJOR_MAX = 458752;
pub const APPCMD_CLIENTONLY = @as(c_long, 16);
pub const EXCEPTION_EXECUTE_HANDLER = 1;
pub const THREAD_POWER_THROTTLING_VALID_FLAGS = THREAD_POWER_THROTTLING_EXECUTION_SPEED;
pub const SERVICE_WIN32_OWN_PROCESS = 16;
pub const PC_WIDE = 16;
pub const HCCE_LOCAL_MACHINE = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(HCERTCHAINENGINE, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(HCERTCHAINENGINE, 1) else HCERTCHAINENGINE(1);
pub const HEAP_TAG_SHIFT = 18;
pub const NIIF_LARGE_ICON = 32;
pub const IDRETRY = 4;
pub const FAST_FAIL_ENCLAVE_CALL_FAILURE = 53;
pub const EV_ERR = 128;
pub const CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG = 4;
pub const SCS_PIF_BINARY = 3;
pub const FILE_CS_FLAG_CASE_SENSITIVE_DIR = 1;
pub const MICROSOFT_WINBASE_H_DEFINE_INTERLOCKED_CPLUSPLUS_OVERLOADS = 0;
pub const TMPF_DEVICE = 8;
pub const CF_UNICODETEXT = 13;
pub const CB_LIMITTEXT = 321;
pub const VOLUME_IS_DIRTY = 1;
pub const MARK_HANDLE_CLOUD_SYNC = 2048;
pub const ERROR_SERVICE_DEPENDENCY_DELETED = @as(c_long, 1075);
pub const LANGGROUPLOCALE_ENUMPROC = LANGGROUPLOCALE_ENUMPROCA;
pub const FIND_FROMSTART = 4194304;
pub const CRYPT_IMPL_MIXED = 3;
pub const CERT_TRUST_IS_SELF_SIGNED = 8;
pub const CreateWindow = CreateWindowA;
pub const SYSTEM_ALARM_CALLBACK_ACE_TYPE = 14;
pub const CRYPT_FLAG_SIGNING = 32;
pub const LANG_LAO = 84;
pub const ERROR_CREATE_FAILED = @as(c_long, 1631);
pub const ERROR_INDIGENOUS_TYPE = @as(c_long, 4338);
pub const ERROR_IPSEC_IKE_PROCESS_ERR_TRANS = @as(c_long, 13832);
pub const ERROR_LOG_CONTAINER_WRITE_FAILED = @as(c_long, 6640);
pub const ERROR_SXS_SECTION_NOT_FOUND = @as(c_long, 14000);
pub const EVENT_SYSTEM_SWITCHER_APPDROPPED = 38;
pub const CFSTR_MIME_PNG = if (@typeId(@typeOf("image/png")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "image/png") else if (@typeId(@typeOf("image/png")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "image/png") else TEXT("image/png");
pub const _RPC_SECURITY_QOS_V4 = _RPC_SECURITY_QOS_V4_A;
pub const IMAGE_REL_EBC_REL32 = 2;
pub const szOID_OIWSEC_desCFB = "1.3.14.3.2.9";
pub const PARTITION_OS2BOOTMGR = 10;
pub const REG_LATEST_FORMAT = 2;
pub const FACILITY_WEB = 885;
pub const STARTF_USECOUNTCHARS = 8;
pub const BATTERY_FLAG_CRITICAL = 4;
pub const WM_SETHOTKEY = 50;
pub const JOB_OBJECT_MSG_END_OF_JOB_TIME = 1;
pub const SHTDN_REASON_MINOR_MAINTENANCE = 1;
pub const WM_NCMBUTTONDOWN = 167;
pub const DISPATCH_LEVEL = 2;
pub const DNS_ERROR_CLIENT_SUBNET_IS_ACCESSED = @as(c_long, 9975);
pub const GIDC_ARRIVAL = 1;
pub const CreateDialogIndirect = CreateDialogIndirectA;
pub const CAL_SLONGDATE = 6;
pub const GL_ID_INPUTSYMBOL = 39;
pub const S_SERDVL = -9;
pub const NRC_INCOMP = 6;
pub const PSINJECT_PSADOBE = 2;
pub const SPI_SETAUDIODESCRIPTION = 117;
pub const SPI_SETFOCUSBORDERHEIGHT = 8209;
pub const CRYPT_ENCODE_DECODE_NONE = 0;
pub const szOID_DH_SINGLE_PASS_STDDH_SHA384_KDF = "1.3.132.1.11.2";
pub const __BMI2__ = 1;
pub const VIEW_S_FIRST = @as(c_long, 262464);
pub const JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO = 4;
pub const NCBRESET = 50;
pub const ERROR_LOGON_SESSION_EXISTS = @as(c_long, 1363);
pub const STARTF_USEPOSITION = 4;
pub const NUMBRUSHES = 16;
pub const PSD_MINMARGINS = 1;
pub const INIT_ONCE_STATIC_INIT = RTL_RUN_ONCE_INIT;
pub const CERT_SELECT_DISALLOW_SELFSIGNED = 4;
pub const _WIN32_IE_WIN7 = _WIN32_IE_IE80;
pub const HEAP_GROWABLE = 2;
pub const SZDDE_ITEM_ITEMLIST = "TopicItemList";
pub const VER_SUITE_BACKOFFICE = 4;
pub const MCI_UPDATE = 2132;
pub const DSS_DISABLED = 32;
pub const INET_E_DEFAULT_ACTION = INET_E_USE_DEFAULT_PROTOCOLHANDLER;
pub const SCardIntroduceCardType = SCardIntroduceCardTypeA;
pub const szOID_APPLICATION_POLICY_MAPPINGS = "1.3.6.1.4.1.311.21.11";
pub const DNS_ERROR_PACKET_FMT_BASE = 9500;
pub const SUBLANG_VIETNAMESE_VIETNAM = 1;
pub const PP_DELETEKEY = 24;
pub const CFSTR_MIME_TTAF = if (@typeId(@typeOf("application/ttaf+xml")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "application/ttaf+xml") else if (@typeId(@typeOf("application/ttaf+xml")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "application/ttaf+xml") else TEXT("application/ttaf+xml");
pub const CS_DBLCLKS = 8;
pub const ENABLE_AUTO_POSITION = 256;
pub const URLMON_OPTION_URL_ENCODING = 268435460;
pub const STATUS_ABANDONED_WAIT_0 = if (@typeId(@typeOf(@as(c_long, 128))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 128)) else if (@typeId(@typeOf(@as(c_long, 128))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 128)) else DWORD(@as(c_long, 128));
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES = 4;
pub const PRSPEC_LPWSTR = 0;
pub const LINGUISTIC_IGNORECASE = 16;
pub const WSASYS_STATUS_LEN = 128;
pub const LOCALE_IPOSSIGNPOSN = 82;
pub const ERROR_IPSEC_IKE_NO_MM_POLICY = @as(c_long, 13850);
pub const NTDDI_WIN6SP4 = 100664320;
pub const LOCALE_ICOUNTRY = LOCALE_IDIALINGCODE;
pub const IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16;
pub const REG_PROCESS_APPKEY = 1;
pub const IMAGE_REL_CEE_ADDR32NB = 3;
pub const EVENT_SYSTEM_DIALOGSTART = 16;
pub const ES_OEMCONVERT = @as(c_long, 1024);
pub const __inner_adt_type_props = typ;
pub const RPC_S_WRONG_KIND_OF_BINDING = @as(c_long, 1701);
pub const __CLFLUSHOPT__ = 1;
pub const PORT_STATUS_OUTPUT_BIN_FULL = 4;
pub const DISPLAYCONFIG_PATH_TARGET_MODE_IDX_INVALID = 65535;
pub const RPC_C_AUTHN_NONE = 0;
pub const ERROR_CANT_WAIT = @as(c_long, 554);
pub const ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME = @as(c_long, 14022);
pub const TOKEN_EXECUTE = STANDARD_RIGHTS_EXECUTE;
pub const PF_UNIX = AF_UNIX;
pub const Uri_ENCODING_QUERY_AND_FRAGMENT_IS_CP = 64;
pub const NUMPRS_TRAILING_PLUS = 8;
pub const PSD_MARGINS = 2;
pub const ERROR_WAIT_63 = @as(c_long, 734);
pub const ERROR_SXS_XML_E_INVALID_STANDALONE = @as(c_long, 14070);
pub const WGL_FONT_POLYGONS = 1;
pub const CERT_STORE_SAVE_TO_FILE = 1;
pub const GCL_CBCLSEXTRA = -20;
pub const MS_ENH_RSA_AES_PROV_XP = MS_ENH_RSA_AES_PROV_XP_A;
pub const WH_MSGFILTER = -1;
pub const WAVE_MAPPED_DEFAULT_COMMUNICATION_DEVICE = 16;
pub const VK_GAMEPAD_LEFT_SHOULDER = 200;
pub const CLAIM_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY = 4;
pub const EALREADY = 103;
pub const ERROR_NOTHING_TO_TERMINATE = @as(c_long, 758);
pub const REALTIME_PRIORITY_CLASS = 256;
pub const RPC_C_AUTHN_LEVEL_PKT = 4;
pub const SE_SIGNING_LEVEL_CUSTOM_7 = 13;
pub const ERROR_SECUREBOOT_POLICY_UNKNOWN = @as(c_long, 4428);
pub const QDI_GETDIBITS = 2;
pub const DNS_ERROR_SCOPE_DOES_NOT_EXIST = @as(c_long, 9959);
pub const CRYPT_STRING_HEXADDR = 10;
pub const TPM_RETURNCMD = @as(c_long, 256);
pub const IME_CAND_STROKE = 5;
pub const TIMESTAMP_VERSION = 1;
pub const ERROR_PRI_MERGE_ADD_FILE_FAILED = @as(c_long, 15151);
pub const URLPOLICY_LOG_ON_DISALLOW = 128;
pub const FILE_INITIATE_REPAIR_HINT1_PREVIOUS_PARENT_STILL_VALID = 549755813888;
pub const CMSG_SIGNED = 2;
pub const FILE_ATTRIBUTE_UNPINNED = 1048576;
pub const CFSTR_MIME_QUICKTIME = if (@typeId(@typeOf("video/quicktime")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "video/quicktime") else if (@typeId(@typeOf("video/quicktime")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "video/quicktime") else TEXT("video/quicktime");
pub const ERROR_NO_UNICODE_TRANSLATION = @as(c_long, 1113);
pub const CRYPT_REGISTER_FIRST_INDEX = 0;
pub const EMR_SETMAPPERFLAGS = 16;
pub const CERT_STORE_PROV_MEMORY = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 2) else LPCSTR(2);
pub const SHGNLI_NOLOCNAME = 16;
pub const LANG_CORSICAN = 131;
pub const ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD = @as(c_long, 8376);
pub const NCRYPTBUFFER_KEY_PROPERTY_FLAGS = 50;
pub const IMAGE_FILE_MACHINE_ALPHA64 = 644;
pub const LLONG_MIN = if (@typeId(@typeOf(-@as(c_longlong, 1))) == @import("builtin").TypeId.Pointer) @ptrCast(-__LONG_LONG_MAX__, -@as(c_longlong, 1)) else if (@typeId(@typeOf(-@as(c_longlong, 1))) == @import("builtin").TypeId.Int) @intToPtr(-__LONG_LONG_MAX__, -@as(c_longlong, 1)) else (-__LONG_LONG_MAX__)(-@as(c_longlong, 1));
pub const URLACTION_MIN = 4096;
pub const SOFTDIST_FLAG_USAGE_EMAIL = 1;
pub const ERROR_DISK_CORRUPT = @as(c_long, 1393);
pub const CTRL_SHUTDOWN_EVENT = 6;
pub const TIME_VALID_OID_FLUSH_CTL = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 1) else LPCSTR(1);
pub const CS_HREDRAW = 2;
pub const BCRYPT_AES_GMAC_ALG_HANDLE = if (@typeId(@typeOf(273)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 273) else if (@typeId(@typeOf(273)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 273) else BCRYPT_ALG_HANDLE(273);
pub const SCARD_READER_TYPE_USB = 32;
pub const CERT_STORE_SAVE_TO_FILENAME = CERT_STORE_SAVE_TO_FILENAME_W;
pub const MDM_V110_SPEED_1DOT2K = 1;
pub const IMAGE_REL_ALPHA_PAIR = 12;
pub const DNS_ERROR_ZONESCOPE_DOES_NOT_EXIST = @as(c_long, 9952);
pub const RPC_X_BYTE_COUNT_TOO_SMALL = @as(c_long, 1782);
pub const HTTOP = 12;
pub const GDICOMMENT_MULTIFORMATS = 1073741828;
pub const PSN_APPLY = if (@typeId(@typeOf(-2)) == @import("builtin").TypeId.Pointer) @ptrCast(PSN_FIRST, -2) else if (@typeId(@typeOf(-2)) == @import("builtin").TypeId.Int) @intToPtr(PSN_FIRST, -2) else PSN_FIRST(-2);
pub const CERT_STORE_SAVE_TO_FILENAME_W = 4;
pub const PSPCB_ADDREF = 0;
pub const RID_HEADER = 268435461;
pub const MDM_BEARERMODE_ISDN = 1;
pub const ERROR_NOT_SUPPORTED_IN_APPCONTAINER = @as(c_long, 4252);
pub const URLACTION_ACTIVEX_CURR_MAX = 4620;
pub const HWND_TOP = if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(HWND, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(HWND, 0) else HWND(0);
pub const CERT_SCEP_ENCRYPT_HASH_CNG_ALG_PROP_ID = 114;
pub const ERROR_RESOURCE_LANG_NOT_FOUND = @as(c_long, 1815);
pub const CERT_CLOSE_STORE_CHECK_FLAG = 2;
pub const OpenMutex = OpenMutexA;
pub const __requires_lock_not_held = lock;
pub const MAX_SID_SIZE = 256;
pub const MILCORE_TS_QUERYVER_RESULT_FALSE = 0;
pub const _RPC_SECURITY_QOS_V3 = _RPC_SECURITY_QOS_V3_A;
pub const szOID_VERISIGN_PRIVATE_6_9 = "2.16.840.1.113733.1.6.9";
pub const OLEIVERB_HIDE = -@as(c_long, 3);
pub const CS_BYTEALIGNCLIENT = 4096;
pub const ERROR_DS_CANT_FIND_DSA_OBJ = @as(c_long, 8419);
pub const __UINT_LEAST64_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const META_SETDIBTODEV = 3379;
pub const PM_NOREMOVE = 0;
pub const CMSG_OID_CAPI1_IMPORT_KEY_TRANS_FUNC = CMSG_OID_IMPORT_KEY_TRANS_FUNC;
pub const ERROR_QUORUM_RESOURCE_ONLINE_FAILED = @as(c_long, 5027);
pub const SERVICES_FAILED_DATABASE = SERVICES_FAILED_DATABASEA;
pub const CBF_SKIP_CONNECT_CONFIRMS = 262144;
pub const SCARD_CLASS_VENDOR_INFO = 1;
pub const VK_F12 = 123;
pub const MCI_REALIZE = 2112;
pub const BF_MIDDLE = 2048;
pub const JOB_OBJECT_MSG_EXIT_PROCESS = 7;
pub const BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK = 7;
pub const PROPSHEETPAGE_V1 = PROPSHEETPAGEA_V1;
pub const SPI_GETDRAGFROMMAXIMIZE = 140;
pub const szOID_ECC_CURVE_BRAINPOOLP320T1 = "1.3.36.3.3.2.8.1.1.10";
pub const NCRYPT_ALTERNATE_KEY_STORAGE_LOCATION_PROPERTY = NCRYPT_PCP_ALTERNATE_KEY_STORAGE_LOCATION_PROPERTY;
pub const CreateHardLinkTransacted = CreateHardLinkTransactedA;
pub const MNS_NOTIFYBYPOS = 134217728;
pub const FILE_DEVICE_DEVAPI = 71;
pub const ERROR_FILE_IDENTITY_NOT_PERSISTENT = @as(c_long, 6823);
pub const LOGON32_PROVIDER_VIRTUAL = 4;
pub const CRYPT_OID_ENCODE_OBJECT_EX_FUNC = "CryptDllEncodeObjectEx";
pub const CERT_SYSTEM_STORE_LOCATION_SHIFT = 16;
pub const CB_GETCOUNT = 326;
pub const OInetCombineUrlEx = CoInternetCombineUrlEx;
pub const WS_EX_LTRREADING = @as(c_long, 0);
pub const NIM_SETFOCUS = 3;
pub const BS_LEFTTEXT = @as(c_long, 32);
pub const CERT_FIND_HASH_STR = CERT_COMPARE_HASH_STR << CERT_COMPARE_SHIFT;
pub const SETKERNTRACK = 770;
pub const InterlockedAddRelease = _InlineInterlockedAdd;
pub const SCARD_SHARE_SHARED = 2;
pub const GESTUREVISUALIZATION_DOUBLETAP = 2;
pub const SPI_SETDOUBLECLKWIDTH = 29;
pub const TIME_FORCE24HOURFORMAT = 8;
pub const _WIN32_IE_WIN6 = _WIN32_IE_IE70;
pub const SEARCH_ALT_NO_SEQ = 6;
pub const PO_THROTTLE_DEGRADE = 2;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_X_DEVKIT = 33;
pub const HSHELL_LANGUAGE = 8;
pub const IMAGE_SCN_MEM_NOT_PAGED = 134217728;
pub const WS_OVERLAPPEDWINDOW = (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX);
pub const WS_TILEDWINDOW = WS_OVERLAPPEDWINDOW;
pub const PROCESSOR_HITACHI_SH3E = 10004;
pub const ERROR_CTX_INVALID_PD = @as(c_long, 7002);
pub const MCI_DEVTYPE_OTHER = 521;
pub const RDH_RECTANGLES = 1;
pub const InterlockedIncrementAcquire64 = _InterlockedIncrement64;
pub const WM_SYSCOLORCHANGE = 21;
pub const IOCTL_VOLUME_BASE = 86;
pub const IPPORT_TELNET = 23;
pub const DT_INTERNAL = 4096;
pub const EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X = 13;
pub const IMAGE_HOT_PATCH_BASE_CAN_ROLL_BACK = 2;
pub const ERROR_EVT_FILTER_UNSUPPORTEDOP = @as(c_long, 15020);
pub const EMR_PAINTRGN = 74;
pub const MAX_LEADBYTES = 12;
pub const FOF_NOCOPYSECURITYATTRIBS = 2048;
pub const DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP = @as(c_long, 571);
pub const szOID_FACSIMILE_TELEPHONE_NUMBER = "2.5.4.23";
pub const STATUS_ACCESS_VIOLATION = if (@typeId(@typeOf(@as(c_long, 3221225477))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225477)) else if (@typeId(@typeOf(@as(c_long, 3221225477))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225477)) else DWORD(@as(c_long, 3221225477));
pub const PAN_LETT_NORMAL_OFF_CENTER = 7;
pub const PCF_RTSCTS = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 2) else DWORD(2);
pub const ERROR_WINDOW_NOT_COMBOBOX = @as(c_long, 1423);
pub const BCRYPT_SHA512_ALG_HANDLE = if (@typeId(@typeOf(97)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 97) else if (@typeId(@typeOf(97)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 97) else BCRYPT_ALG_HANDLE(97);
pub const PSWIZF_SETCOLOR = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(UINT, -1) else UINT(-1);
pub const FILE_STORAGE_TIER_FLAG_READ_CACHE = 4194304;
pub const CMSG_BARE_CONTENT_FLAG = 1;
pub const SERVICE_ACCEPT_NETBINDCHANGE = 16;
pub const SPI_GETLISTBOXSMOOTHSCROLLING = 4102;
pub const szOID_WHQL_CRYPTO = "1.3.6.1.4.1.311.10.3.5";
pub const HEAP_PSEUDO_TAG_FLAG = 32768;
pub const midl_user_allocate = MIDL_user_allocate;
pub const SYSTEM_MANDATORY_LABEL_NO_WRITE_UP = 1;
pub const ERROR_FOUND_OUT_OF_SCOPE = @as(c_long, 601);
pub const ERROR_INSTALL_SUSPEND = @as(c_long, 1604);
pub const VFF_BUFFTOOSMALL = 4;
pub const LEFT_ALT_PRESSED = 2;
pub const MCI_VD_STEP_FRAMES = @as(c_long, 65536);
pub const GET_MODULE_HANDLE_EX_FLAG_PIN = 1;
pub const DMICMMETHOD_SYSTEM = 2;
pub const SYNCHRONIZATION_BARRIER_FLAGS_SPIN_ONLY = 1;
pub const IMAGE_REL_CEE_TOKEN = 6;
pub const UNALIGNED = __unaligned;
pub const MCI_SYSINFO_QUANTITY = @as(c_long, 256);
pub const EMR_TRANSPARENTBLT = 116;
pub const CAL_SERASTRING = 4;
pub const NCRYPT_SCHANNEL_INTERFACE = 65538;
pub const SE_SIGNING_LEVEL_CUSTOM_6 = 15;
pub const ERROR_ADAP_HDW_ERR = @as(c_long, 57);
pub const MAX_TOUCH_PREDICTION_FILTER_TAPS = 3;
pub const VIFF_DONTDELETEOLD = 2;
pub const __UINTMAX_FMTu__ = "llu";
pub const APPCOMMAND_BROWSER_SEARCH = 5;
pub const CONFIRMSAFETYACTION_LOADOBJECT = 1;
pub const ERROR_DS_CLASS_MUST_BE_CONCRETE = @as(c_long, 8359);
pub const SEE_MASK_NO_CONSOLE = 32768;
pub const JOY_RETURNPOVCTS = @as(c_long, 512);
pub const LANG_TATAR = 68;
pub const BS_PATTERN8X8 = 7;
pub const Uri_HAS_FRAGMENT = 1 << Uri_PROPERTY_FRAGMENT;
pub const S_QUEUEEMPTY = 0;
pub const CERT_STRONG_SIGN_ENABLE_OCSP_CHECK = 2;
pub const FAST_FAIL_INVALID_IAT = 49;
pub const MWT_MIN = MWT_IDENTITY;
pub const IMAGE_REL_ALPHA_GPREL32 = 3;
pub const WM_CTLCOLORLISTBOX = 308;
pub const ERROR_TAG_NOT_FOUND = @as(c_long, 2012);
pub const BCRYPT_SUPPORTED_PAD_PKCS1_ENC = 2;
pub const CRYPTNET_URL_CACHE_RESPONSE_HTTP = 1;
pub const MM_JOY2BUTTONDOWN = 950;
pub const TAPE_DRIVE_LOCK_UNLOCK = 2147483652;
pub const FILE_SUPPORTS_OBJECT_IDS = 65536;
pub const OBJID_ALERT = if (@typeId(@typeOf(4294967286)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG, 4294967286) else if (@typeId(@typeOf(4294967286)) == @import("builtin").TypeId.Int) @intToPtr(LONG, 4294967286) else LONG(4294967286);
pub const SCS_OS216_BINARY = 5;
pub const CERT_VERIFY_UPDATED_CTL_FLAG = 1;
pub const GL_ID_TYPINGERROR = 33;
pub const DMBIN_LOWER = 2;
pub const MF_HILITE = @as(c_long, 128);
pub const GET_FEATURE_FROM_THREAD_INTERNET = 64;
pub const GMEM_DDESHARE = 8192;
pub const SC_MINIMIZE = 61472;
pub const GetRawInputDeviceInfo = GetRawInputDeviceInfoA;
pub const MOVEFILE_COPY_ALLOWED = 2;
pub const DEVICEFAMILYINFOENUM_WINDOWS_PHONE_8X = 2;
pub const DMDITHER_COARSE = 2;
pub const PIDSI_LASTPRINTED = @as(c_long, 11);
pub const _RPC_SECURITY_QOS_V2 = _RPC_SECURITY_QOS_V2_A;
pub const EVENT_SYSTEM_ALERT = 2;
pub const CC_CHORD = 4;
pub const SEEK_END = 2;
pub const rad13 = 1068;
pub const SetFileAttributes = SetFileAttributesA;
pub const PD_COLLATE = 16;
pub const GetDefaultCommConfig = GetDefaultCommConfigA;
pub const ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION = @as(c_long, 6720);
pub const VK_F13 = 124;
pub const PROCESSOR_PERF_BOOST_MODE_DISABLED = 0;
pub const PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_MASK = 3 << 20;
pub const XSTATE_ALIGN_BIT = 1;
pub const OFN_FILEMUSTEXIST = 4096;
pub const RPC_C_OPT_DONT_LINGER = 13;
pub const KDF_GENERIC_PARAMETER = 17;
pub const AF_MAX = 22;
pub const APPMODEL_ERROR_NO_APPLICATION = @as(c_long, 15703);
pub const KDF_SUPPPUBINFO = 11;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PCCV1 = 2;
pub const RDW_ALLCHILDREN = 128;
pub const C1_DIGIT = 4;
pub const VIF_WRITEPROT = @as(c_long, 64);
pub const SERVICE_STOP_REASON_MINOR_SECURITY = 16;
pub const ERROR_PATCH_PACKAGE_OPEN_FAILED = @as(c_long, 1635);
pub const PROCESS_SUSPEND_RESUME = 2048;
pub const Uri_HAS_PATH = 1 << Uri_PROPERTY_PATH;
pub const ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY = @as(c_long, 762);
pub const SPI_SETFOREGROUNDLOCKTIMEOUT = 8193;
pub const CAL_KOREA = 5;
pub const SORT_DIGITSASNUMBERS = 8;
pub const GetVersionEx = GetVersionExA;
pub const ERROR_DS_COMPARE_TRUE = @as(c_long, 8230);
pub const FKF_CONFIRMHOTKEY = 8;
pub const SE_SECURITY_DESCRIPTOR_VALID_FLAGS = 7;
pub const SCHANNEL_ENC_KEY = 1;
pub const IMPLTYPEFLAG_FDEFAULT = 1;
pub const STGOPTIONS_VERSION = 2;
pub const ERROR_DS_UNABLE_TO_SURRENDER_ROLES = @as(c_long, 8435);
pub const STATUS_DLL_INIT_FAILED = if (@typeId(@typeOf(@as(c_long, 3221225794))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225794)) else if (@typeId(@typeOf(@as(c_long, 3221225794))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225794)) else DWORD(@as(c_long, 3221225794));
pub const DNS_ERROR_KEYMASTER_REQUIRED = @as(c_long, 9101);
pub const ALTNUMPAD_BIT = 67108864;
pub const PERF_TYPE_NUMBER = 0;
pub const ERROR_SINGLETON_RESOURCE_INSTALLED_IN_ACTIVE_USER = @as(c_long, 15653);
pub const ERROR_NO_PHYSICALLY_ALIGNED_FREE_SPACE_FOUND = @as(c_long, 408);
pub const ERROR_HIBERNATION_FAILURE = @as(c_long, 656);
pub const SHTDN_REASON_VALID_BIT_MASK = 3238002687;
pub const NCRYPT_ECDH_P256_ALGORITHM = BCRYPT_ECDH_P256_ALGORITHM;
pub const IP_MULTICAST_LOOP = 4;
pub const szOID_ECC_CURVE_BRAINPOOLP512R1 = "1.3.36.3.3.2.8.1.1.13";
pub const WININETINFO_OPTION_LOCK_HANDLE = 65534;
pub const ERROR_CLOUD_FILE_IN_USE = @as(c_long, 391);
pub const CM_CMYK_COLOR = 4;
pub const RPC_TYPE_DISCONNECT_EVENT_CONTEXT_HANDLE = @as(c_ulong, 2147483648);
pub const CERT_QUERY_OBJECT_FILE = 1;
pub const CERT_FIND_PUBLIC_KEY = CERT_COMPARE_PUBLIC_KEY << CERT_COMPARE_SHIFT;
pub const SCARD_SHARE_EXCLUSIVE = 1;
pub const EM_GETPASSWORDCHAR = 210;
pub const __clang_major__ = 8;
pub const IMAGE_SYM_CLASS_UNDEFINED_STATIC = 14;
pub const MEM_EXTENDED_PARAMETER_GRAPHICS = 1;
pub const CERT_COMPARE_SHA1_HASH = 1;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_NON_INTEGRITY_DATA = 4;
pub const SND_MEMORY = 4;
pub const ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT = @as(c_long, 5088);
pub const NID_EXTERNAL_PEN = 8;
pub const szOID_PKCS_12_pbeWithSHA1And128BitRC4 = "1.2.840.113549.1.12.1.1";
pub const ERROR_CLUSTER_POISONED = @as(c_long, 5907);
pub const SHTDN_REASON_MINOR_SECURITYFIX = 18;
pub const WIM_OPEN = MM_WIM_OPEN;
pub const ERROR_SYSTEM_PROCESS_TERMINATED = @as(c_long, 591);
pub const CONVERT10_E_LAST = @as(c_long, 2147746255);
pub const MAP_PRECOMPOSED = 32;
pub const RTL_CORRELATION_VECTOR_V1_PREFIX_LENGTH = 16;
pub const META_CREATEPATTERNBRUSH = 505;
pub const AW_VER_NEGATIVE = 8;
pub const SERVICE_STOP_REASON_MINOR_OTHERDRIVER = 12;
pub const ERROR_IS_SUBST_PATH = @as(c_long, 146);
pub const CAL_SYEARMONTH = 47;
pub const TAPE_DRIVE_REVERSE_POSITION = 2151677952;
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY_ID = 8;
pub const SE_SIGNING_LEVEL_CUSTOM_5 = 10;
pub const _CRT_INTERNAL_COMBASE_SYMBOL_PREFIX = "";
pub const LOCALE_INEGSEPBYSPACE = 87;
pub const MIXERLINE_TARGETTYPE_MIDIIN = 4;
pub const EMR_DELETECOLORSPACE = 101;
pub const SB_PAGERIGHT = 3;
pub const BCRYPT_ECDSA_PRIVATE_P521_MAGIC = 911426373;
pub const ERROR_UNKNOWN_PROPERTY = @as(c_long, 1608);
pub const LOCALE_IREADINGLAYOUT = 112;
pub const PAN_SERIF_ROUNDED = 15;
pub const SAVE_CTM = 4101;
pub const PKCS12_EXPORT_RESERVED_MASK = 4294901760;
pub const SERVICE_TRIGGER_ACTION_SERVICE_STOP = 2;
pub const SPI_GETTOUCHPREDICTIONPARAMETERS = 156;
pub const OFN_NOTESTFILECREATE = 65536;
pub const COLOR_BTNFACE = 15;
pub const ALG_SID_MAC = 5;
pub const _Acquires_exclusive_lock_ = lock;
pub const STORAGE_PROTOCOL_SPECIFIC_NVME_NVM_COMMAND = 2;
pub const PC_TRAPEZOID = 4;
pub const VIEW_E_LAST = @as(c_long, 2147746127);
pub const FIND_FIRST_EX_CASE_SENSITIVE = 1;
pub const STORAGE_OFFLOAD_TOKEN_TYPE_ZERO_DATA = 4294901761;
pub const ERROR_MUI_INVALID_FILE = @as(c_long, 15101);
pub const FACILITY_XBOX = 2339;
pub const CAL_SABBREVDAYNAME2 = 15;
pub const MIXERLINE_COMPONENTTYPE_DST_FIRST = @as(c_long, 0);
pub const ERROR_DRIVERS_LEAKING_LOCKED_PAGES = @as(c_long, 729);
pub const CRYPT_FIND_USER_KEYSET_FLAG = 1;
pub const OPERATION_END_DISCARD = 1;
pub const ERROR_INVALID_ORDINAL = @as(c_long, 182);
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_ROOT = 4;
pub const NCRYPTBUFFER_ECC_PARAMETERS = 61;
pub const QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE = 8;
pub const GetMonitorInfo = GetMonitorInfoA;
pub const HELP_CONTEXT = @as(c_long, 1);
pub const HSHELL_ACTIVATESHELLWINDOW = 3;
pub const CSV_INVALID_DEVICE_NUMBER = 4294967295;
pub const SE_PRIVILEGE_REMOVED = @as(c_long, 4);
pub const scr8 = 1175;
pub const RPC_BUFFER_PARTIAL = 8192;
pub const JOYCAPS_HASV = 8;
pub const CLIPBRD_S_LAST = @as(c_long, 262623);
pub const CF_SCREENFONTS = 1;
pub const RPC_IF_SEC_CACHE_PER_PROC = 128;
pub const AF_OSI = AF_ISO;
pub const WINSTORAGEAPI = DECLSPEC_IMPORT;
pub const IMAGE_REL_ARM64_PAGEOFFSET_12A = 6;
pub const rad12 = 1067;
pub const CERT_SYSTEM_STORE_CURRENT_USER_ID = 1;
pub const WM_ENDSESSION = 22;
pub const VK_F10 = 121;
pub const PC_NONE = 0;
pub const CLIENTSITE_E_FIRST = @as(c_long, 2147746192);
pub const SORT_STRINGSORT = 4096;
pub const ICM_ADDPROFILE = 1;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL = 60;
pub const ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS = @as(c_long, 8555);
pub const IMAGE_SCN_MEM_SHARED = 268435456;
pub const SO_SYNCHRONOUS_NONALERT = 32;
pub const SERVICE_STOP_REASON_MAJOR_OTHER = 65536;
pub const PROPSHEETPAGE_V3 = PROPSHEETPAGEA_V3;
pub const SM_SHUTTINGDOWN = 8192;
pub const RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO = 16777216;
pub const MCI_ANIM_GETDEVCAPS_PALETTES = @as(c_long, 16390);
pub const SPI_SETMOUSESPEED = 113;
pub const MDM_X75_DATA_T_70 = 3;
pub const DEVICEDUMP_MAX_IDSTRING = 32;
pub const FILE_NOTIFY_CHANGE_SECURITY = 256;
pub const XST_ADVACKRCVD = 13;
pub const CERT_CHAIN_DISABLE_MOTW_CODE_SIGNING_WEAK_FLAG = 8388608;
pub const RPC_SYSTEM_HANDLE_FREE_UNRETRIEVED = 1;
pub const ERROR_INVALID_TASK_NAME = @as(c_long, 1550);
pub const __releases_lock = lock;
pub const SCHEME_OID_RETRIEVE_ENCODED_OBJECT_FUNC = "SchemeDllRetrieveEncodedObject";
pub const GMEM_LOWER = GMEM_NOT_BANKED;
pub const DEVICE_STORAGE_NO_ERRORS = 1;
pub const CMSG_VERIFY_SIGNER_PUBKEY = 1;
pub const szOID_CMC_GET_CRL = "1.3.6.1.5.5.7.7.16";
pub const KP_KEYVAL = 30;
pub const FMFD_IGNOREMIMETEXTPLAIN = 4;
pub const MF_CONV = 1073741824;
pub const PAN_XHEIGHT_CONSTANT_LARGE = 4;
pub const ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH = @as(c_long, 8540);
pub const EMR_SETBKMODE = 18;
pub const SS_RIGHTJUST = @as(c_long, 1024);
pub const FACILITY_WINCODEC_DWRITE_DWM = 2200;
pub const DI_NORMAL = 3;
pub const FILE_INITIATE_REPAIR_HINT1_MULTIPLE_FILE_NAME_ATTRIBUTES = 4398046511104;
pub const VarUintFromI8 = VarUI4FromI8;
pub const ERROR_CORRUPT_SYSTEM_FILE = @as(c_long, 634);
pub const ERROR_INVALID_EXE_SIGNATURE = @as(c_long, 191);
pub const VIF_CANNOTCREATE = @as(c_long, 2048);
pub const SERVICE_CONFIG_DESCRIPTION = 1;
pub const COM_RIGHTS_EXECUTE_REMOTE = 4;
pub const CRYPT_ECC_PRIVATE_KEY_INFO_v1 = 1;
pub const CMSG_DATA = 1;
pub const MNGO_NOERROR = 1;
pub const PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_NO_REMOTE_MASK = if (@typeId(@typeOf(i64 << 52)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 52) else if (@typeId(@typeOf(i64 << 52)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 52) else @as(c_uint, 3)(i64 << 52);
pub const BLACKONWHITE = 1;
pub const ERROR_DS_SEC_DESC_INVALID = @as(c_long, 8354);
pub const ERROR_CLOUD_FILE_INSUFFICIENT_RESOURCES = @as(c_long, 387);
pub const PROCESS_CREATE_PROCESS = 128;
pub const MMIO_DENYWRITE = 32;
pub const OBJ_PAL = 5;
pub const FACILITY_PIDGENX = 2561;
pub const TAPE_UNLOCK = @as(c_long, 4);
pub const ERROR_LOG_POLICY_CONFLICT = @as(c_long, 6622);
pub const DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT = @as(c_long, 9710);
pub const FILE_DEVICE_CD_ROM_FILE_SYSTEM = 3;
pub const ctlFirst = 1024;
pub const szOIDVerisign_TransactionID = "2.16.840.1.113733.1.9.7";
pub const C1_BLANK = 64;
pub const PS_DASH = 1;
pub const PROCESS_CREATION_MITIGATION_POLICY2_STRICT_CONTROL_FLOW_GUARD_RESERVED = if (@typeId(@typeOf(i64 << 8)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 8) else if (@typeId(@typeOf(i64 << 8)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 8) else @as(c_uint, 3)(i64 << 8);
pub const _MM_HINT_T2 = 3;
pub const SERVICE_CONTROL_STOP = 1;
pub const CRL_REASON_SUPERSEDED_FLAG = 8;
pub const SE_SIGNING_LEVEL_CUSTOM_4 = 9;
pub const SCardSetCardTypeProviderName = SCardSetCardTypeProviderNameA;
pub const TPM_RIGHTALIGN = @as(c_long, 8);
pub const META_OFFSETWINDOWORG = 527;
pub const COPYFILE_SIS_FLAGS = 3;
pub const SMART_INVALID_FLAG = 2;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_IS_BASE_RECORD = 524288;
pub const STORAGE_OFFLOAD_READ_RANGE_TRUNCATED = 1;
pub const CAL_SRELATIVELONGDATE = 58;
pub const PEN_FLAG_BARREL = 1;
pub const LB_SELECTSTRING = 396;
pub const ERROR_NET_OPEN_FAILED = @as(c_long, 570);
pub const ERROR_EVT_FILTER_INVTEST = @as(c_long, 15017);
pub const LCS_GM_GRAPHICS = @as(c_long, 2);
pub const _Releases_shared_lock_ = lock;
pub const INIT_ONCE_CTX_RESERVED_BITS = RTL_RUN_ONCE_CTX_RESERVED_BITS;
pub const WSAHOST_NOT_FOUND = @as(c_long, 11001);
pub const FILE_EXECUTE = 32;
pub const SUBLANG_ARABIC_JORDAN = 11;
pub const CRYPT_KEK = 1024;
pub const InterlockedExchangeAcquire = _InterlockedExchange;
pub const FMFD_URLASFILENAME = 1;
pub const __inner_assume_validated = p;
pub const szOID_OIWSEC_dsaCommSHA1 = "1.3.14.3.2.28";
pub const ERROR_CONNECTION_COUNT_LIMIT = @as(c_long, 1238);
pub const CBF_SKIP_DISCONNECTS = 2097152;
pub const CE_MODE = 32768;
pub const _Releases_exclusive_lock_ = lock;
pub const ERROR_DS_DRA_SHUTDOWN = @as(c_long, 8463);
pub const STATE_SYSTEM_ANIMATED = 16384;
pub const CAL_SABBREVDAYNAME3 = 16;
pub const POWER_ACTION_CRITICAL = 2147483648;
pub const WTS_REMOTE_CONNECT = 3;
pub const CM_SERVICE_SD_DISK_BOOT_LOAD = 8;
pub const ERROR_SETCOUNT_ON_BAD_LB = @as(c_long, 1433);
pub const ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE = 8;
pub const GL_ID_READINGCONFLICT = 35;
pub const SUBLANG_ARABIC_SAUDI_ARABIA = 1;
pub const ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST = @as(c_long, 8634);
pub const IME_ESC_GETHELPFILENAME = 4107;
pub const SERVICE_ACCEPT_SHUTDOWN = 4;
pub const COPY_FILE_FAIL_IF_EXISTS = 1;
pub const SPI_GETSCREENSAVERRUNNING = 114;
pub const JOB_OBJECT_IMPERSONATE = 32;
pub const CTRY_GREECE = 30;
pub const CMSG_ATTR_CERT_COUNT_PARAM = 31;
pub const ERROR_REDIR_PAUSED = @as(c_long, 72);
pub const PD_RESULT_CANCEL = 0;
pub const IMAGE_SUBSYSTEM_UNKNOWN = 0;
pub const JOY_BUTTON32 = @as(c_long, 2147483648);
pub const ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND = @as(c_long, 15002);
pub const JOYCAPS_HASU = 4;
pub const GetClipboardFormatName = GetClipboardFormatNameA;
pub const ERROR_DS_SCHEMA_NOT_LOADED = @as(c_long, 8414);
pub const DEVICEFAMILYDEVICEFORM_PHONE = 1;
pub const DC_PAPERSIZE = 3;
pub const rad11 = 1066;
pub const LB_GETSEL = 391;
pub const SECURITY_AUTHENTICATION_KEY_TRUST_RID = @as(c_long, 4);
pub const PAGE_GUARD = 256;
pub const VK_F11 = 122;
pub const ALG_SID_CYLINK_MEK = 12;
pub const JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED = 2;
pub const PROPSHEETPAGE_V2 = PROPSHEETPAGEA_V2;
pub const WM_MENUCOMMAND = 294;
pub const ERROR_DS_NO_REF_DOMAIN = @as(c_long, 8575);
pub const JOHAB_CHARSET = 130;
pub const ERROR_DS_PARAM_ERROR = @as(c_long, 8255);
pub const PERF_DETAIL_WIZARD = 400;
pub const ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE = @as(c_long, 14042);
pub const FACILITY_WSB_ONLINE = 133;
pub const __INTPTR_WIDTH__ = 64;
pub const CDERR_NOHINSTANCE = 4;
pub const ERROR_DBG_CONTINUE = @as(c_long, 767);
pub const SendNotifyMessage = SendNotifyMessageA;
pub const BitScanReverse64 = _BitScanReverse64;
pub const EXCEPTION_FLT_OVERFLOW = STATUS_FLOAT_OVERFLOW;
pub const IMAGE_REL_AMD64_REL32 = 4;
pub const PROCESS_CREATION_MITIGATION_POLICY2_RESTRICT_INDIRECT_BRANCH_PREDICTION_DEFER = if (@typeId(@typeOf(i64 << 16)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), i64 << 16) else if (@typeId(@typeOf(i64 << 16)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), i64 << 16) else @as(c_uint, 0)(i64 << 16);
pub const MNC_EXECUTE = 2;
pub const ERROR_SERVICE_MARKED_FOR_DELETE = @as(c_long, 1072);
pub const SC_HOTKEY = 61776;
pub const POWER_ACTION_UI_ALLOWED = 2;
pub const TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_CREATED = 1;
pub const SC_TASKLIST = 61744;
pub const REG_FULL_RESOURCE_DESCRIPTOR = @as(c_ulong, 9);
pub const DISPLAY_DEVICE_REMOVABLE = 32;
pub const CREDENTIAL_OID_PASSWORD_CREDENTIALS = CREDENTIAL_OID_PASSWORD_CREDENTIALS_A;
pub const __FLT16_HAS_INFINITY__ = 1;
pub const DS_FIXEDSYS = @as(c_long, 8);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = 1;
pub const TRANSACTION_NOTIFY_TM_ONLINE = 33554432;
pub const CERT_TIMESTAMP_HASH_USE_TYPE = 2;
pub const SPI_GETDESKWALLPAPER = 115;
pub const IOInetThreadSwitch = IInternetThreadSwitch;
pub const IMAGE_ICON = 1;
pub const XST_INIT2 = 4;
pub const ERROR_SXS_XML_E_INVALIDENCODING = @as(c_long, 14067);
pub const CTRY_PUERTO_RICO = 1;
pub const MCI_GETDEVCAPS_CAN_RECORD = @as(c_long, 1);
pub const DMPAPER_LEGAL_EXTRA = 51;
pub const ERROR_SEEK_ON_DEVICE = @as(c_long, 132);
pub const WM_WINDOWPOSCHANGING = 70;
pub const IMAGE_REL_AMD64_CFG_BR = 20;
pub const ERROR_CHILD_WINDOW_MENU = @as(c_long, 1436);
pub const SUBLANG_BENGALI_INDIA = 1;
pub const FILE_ACTION_REMOVED = 2;
pub const ERROR_DATABASE_BACKUP_CORRUPT = @as(c_long, 5087);
pub const RESOURCEDISPLAYTYPE_SHAREADMIN = 8;
pub const C2_BLOCKSEPARATOR = 8;
pub const TECHNOLOGY = 2;
pub const EMR_RESERVED_105 = 105;
pub const NDR_CUSTOM_OR_DEFAULT_ALLOCATOR = @as(c_ulong, 268435456);
pub const RPC_S_PROXY_ACCESS_DENIED = @as(c_long, 1729);
pub const ScrollConsoleScreenBuffer = ScrollConsoleScreenBufferA;
pub const __UINTMAX_MAX__ = @as(c_ulonglong, 18446744073709551615);
pub const SUBLANG_ARABIC_ALGERIA = 5;
pub const FROM_LEFT_1ST_BUTTON_PRESSED = 1;
pub const MEMORY_ALLOCATION_ALIGNMENT = 16;
pub const X509_BASIC_CONSTRAINTS2 = if (@typeId(@typeOf(15)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 15) else if (@typeId(@typeOf(15)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 15) else LPCSTR(15);
pub const VFT2_DRV_INSTALLABLE = @as(c_long, 8);
pub const CRYPT_SUCCEED = TRUE;
pub const RPC_C_NOTIFY_ON_SEND_COMPLETE = 1;
pub const DOMAIN_ALIAS_RID_RDS_MANAGEMENT_SERVERS = @as(c_long, 577);
pub const INPUTLANGCHANGE_SYSCHARSET = 1;
pub const NLS_KATAKANA = 131072;
pub const LOCALE_SABBREVDAYNAME2 = 50;
pub const AddPrintProvidor = AddPrintProvidorA;
pub const ERROR_DS_BAD_INSTANCE_TYPE = @as(c_long, 8313);
pub const SKF_LALTLATCHED = 268435456;
pub const DNS_ERROR_INVALID_DATAFILE_NAME = @as(c_long, 9652);
pub const ERROR_SYSTEM_IMAGE_BAD_SIGNATURE = @as(c_long, 637);
pub const EM_FMTLINES = 200;
pub const DC_MEDIATYPES = 35;
pub const EVENT_OBJECT_CLOAKED = 32791;
pub const PRINTER_CHANGE_ALL = 2138570751;
pub const szOID_PKCS_12_pbeWithSHA1And128BitRC2 = "1.2.840.113549.1.12.1.5";
pub const FACILITY_USERMODE_FILTER_MANAGER = 31;
pub const ERROR_IPSEC_MM_AUTH_IN_USE = @as(c_long, 13012);
pub const PDC_ORIGIN = 1024;
pub const SERVICE_QUERY_CONFIG = 1;
pub const _MM_HINT_T1 = 2;
pub const ERROR_OPEN_FAILED = @as(c_long, 110);
pub const CHANGER_EXCHANGE_MEDIA = 32;
pub const OCSP_BASIC_RESPONSE = if (@typeId(@typeOf(69)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 69) else if (@typeId(@typeOf(69)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 69) else LPCSTR(69);
pub const BCRYPT_RSAPUBLIC_MAGIC = 826364754;
pub const STD_OUTPUT_HANDLE = if (@typeId(@typeOf(-11)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, -11) else if (@typeId(@typeOf(-11)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, -11) else DWORD(-11);
pub const X3_OPCODE_SIZE_X = 4;
pub const __INT_FAST32_FMTi__ = "i";
pub const ERROR_HOTKEY_ALREADY_REGISTERED = @as(c_long, 1409);
pub const SE_SIGNING_LEVEL_CUSTOM_3 = 7;
pub const SECURITY_APPPOOL_ID_BASE_RID = @as(c_long, 82);
pub const PAN_XHEIGHT_CONSTANT_SMALL = 2;
pub const WS_MAXIMIZE = @as(c_long, 16777216);
pub const ERROR_INVALID_LABEL = @as(c_long, 1299);
pub const CreateDialogIndirectParam = CreateDialogIndirectParamA;
pub const SPI_GETTOOLTIPANIMATION = 4118;
pub const LPSCARD_READERSTATE_A = LPSCARD_READERSTATEA;
pub const VP_CP_CMD_ACTIVATE = 1;
pub const SPI_SETDOCKMOVING = 145;
pub const CE_FRAME = 8;
pub const CERT_CHAIN_POLICY_MICROSOFT_ROOT = if (@typeId(@typeOf(7)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 7) else if (@typeId(@typeOf(7)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 7) else LPCSTR(7);
pub const szOID_RSA_SMIMEalgCMS3DESwrap = "1.2.840.113549.1.9.16.3.6";
pub const GetClassLong = GetClassLongA;
pub const JOB_STATUS_ERROR = 2;
pub const szOID_PKCS_7_ENVELOPED = "1.2.840.113549.1.7.3";
pub const CC_ENABLETEMPLATE = 32;
pub const SCM_MAX_SYMLINK_LEN_IN_CHARS = 256;
pub const ERROR_INVALID_ICON_HANDLE = @as(c_long, 1414);
pub const CRYPT_STRING_RESERVED200 = 512;
pub const __inner_control_entrypoint = category;
pub const PP_SESSION_KEYSIZE = 20;
pub const __ATOMIC_RELEASE = 3;
pub const RPI_SMB2_FLAG_SERVERCAP_DIRECTORY_LEASING = 32;
pub const DMPAPER_A4_PLUS = 60;
pub const ERROR_PAGE_FAULT_DEMAND_ZERO = @as(c_long, 748);
pub const WM_NEXTMENU = 531;
pub const SUBLANG_SPANISH_COSTA_RICA = 5;
pub const URLACTION_CROSS_DOMAIN_DATA = 5126;
pub const __SSE2_MATH__ = 1;
pub const PROCESSOR_DUTY_CYCLING_ENABLED = 1;
pub const DBG_REPLY_LATER = if (@typeId(@typeOf(@as(c_long, 1073807361))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 1073807361)) else if (@typeId(@typeOf(@as(c_long, 1073807361))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 1073807361)) else DWORD(@as(c_long, 1073807361));
pub const DRV_ENABLE = 2;
pub const PEERDIST_ERROR_VERSION_UNSUPPORTED = @as(c_long, 4062);
pub const XSTATE_MASK_GSSE = if (@typeId(@typeOf(i64 << XSTATE_GSSE)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << XSTATE_GSSE) else if (@typeId(@typeOf(i64 << XSTATE_GSSE)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << XSTATE_GSSE) else @as(c_uint, 1)(i64 << XSTATE_GSSE);
pub const CertAddEncodedCertificateToSystemStore = CertAddEncodedCertificateToSystemStoreA;
pub const PRODUCT_HOME_PREMIUM = 3;
pub const PSP_USEHICON = 2;
pub const SM_CYVTHUMB = 9;
pub const MARK_HANDLE_FILTER_METADATA = 512;
pub const MKF_MOUSEKEYSON = 1;
pub const X509_AUTHORITY_KEY_ID2 = if (@typeId(@typeOf(31)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 31) else if (@typeId(@typeOf(31)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 31) else LPCSTR(31);
pub const TXFS_RM_FLAG_PRESERVE_CHANGES = 8192;
pub const ua_lstrcmp = lstrcmpA;
pub const JOY_BUTTON31 = @as(c_long, 1073741824);
pub const FS_FILE_ENCRYPTION = FILE_SUPPORTS_ENCRYPTION;
pub const SYSTEM_AUDIT_CALLBACK_ACE_TYPE = 13;
pub const ERROR_APP_DATA_REBOOT_REQUIRED = @as(c_long, 4404);
pub const PSP_HASHELP = 32;
pub const EM_GETLIMITTEXT = 213;
pub const rad10 = 1065;
pub const EWX_REBOOT = 2;
pub const VK_F16 = 127;
pub const NCRYPT_PBKDF2_ALGORITHM = BCRYPT_PBKDF2_ALGORITHM;
pub const WM_EXITSIZEMOVE = 562;
pub const OCSP_BASIC_REVOKED_CERT_STATUS = 1;
pub const PRODUCT_EMBEDDED_INDUSTRY_A_E = 92;
pub const MB_ICONASTERISK = @as(c_long, 64);
pub const PRODUCT_IOTOS = 185;
pub const RIDEV_INPUTSINK = 256;
pub const ERROR_IPSEC_IKE_UNSUPPORTED_ID = @as(c_long, 13869);
pub const ERROR_CANNOT_OPEN_PROFILE = @as(c_long, 1205);
pub const ERROR_SPECIAL_USER = @as(c_long, 1373);
pub const TOKEN_ADJUST_DEFAULT = 128;
pub const URLACTION_ALLOW_XHR_EVALUATION = 8962;
pub const ERROR_SUCCESS_REBOOT_REQUIRED = @as(c_long, 3010);
pub const LogonUserEx = LogonUserExA;
pub const FAST_FAIL_INVALID_REFERENCE_COUNT = 14;
pub const LB_DELETESTRING = 386;
pub const IPPORT_DAYTIME = 13;
pub const CB_GETDROPPEDWIDTH = 351;
pub const LOCALE_IPAPERSIZE = 4106;
pub const RpcNetworkInqProtseqs = RpcNetworkInqProtseqsA;
pub const DMLERR_DLL_NOT_INITIALIZED = 16387;
pub const RC_STRETCHBLT = 2048;
pub const ERROR_UNMAPPED_SUBSTITUTION_STRING = @as(c_long, 14096);
pub const SELECTDIB = 41;
pub const TPM_LEFTALIGN = @as(c_long, 0);
pub const DMPAPER_B6_JIS_ROTATED = 89;
pub const DOMAIN_GROUP_RID_USERS = @as(c_long, 513);
pub const ERROR_INSTALL_OUT_OF_DISK_SPACE = @as(c_long, 15604);
pub const FILE_DISPOSITION_FLAG_DO_NOT_DELETE = 0;
pub const IME_ESC_GET_EUDC_DICTIONARY = 4099;
pub const SECURITY_CAPABILITY_PRIVATE_NETWORK_CLIENT_SERVER = @as(c_long, 3);
pub const CF_ENABLETEMPLATE = @as(c_long, 16);
pub const ERROR_DS_CROSS_REF_BUSY = @as(c_long, 8602);
pub const ERROR_CLUSTER_NODE_ALREADY_MEMBER = @as(c_long, 5065);
pub const ERROR_CLUSTER_RESOURCE_TYPE_BUSY = @as(c_long, 5909);
pub const VOS__PM32 = @as(c_long, 3);
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = 1;
pub const PF_SECOND_LEVEL_ADDRESS_TRANSLATION = 20;
pub const PDERR_GETDEVMODEFAIL = 4101;
pub const DISP_CHANGE_FAILED = -1;
pub const HEAP_ZERO_MEMORY = 8;
pub const __drv_acquiresExclusiveResource = kind;
pub const FLUSH_FLAGS_FILE_DATA_ONLY = 1;
pub const MAXPROPPAGES = 100;
pub const TC_RESERVED = 32768;
pub const XST_INIT1 = 3;
pub const META_SCALEWINDOWEXT = 1040;
pub const ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE = 12;
pub const SSL_HPKP_PKP_RO_HEADER_INDEX = 1;
pub const HiddenVolumeClassGuid = GUID_DEVINTERFACE_HIDDEN_VOLUME;
pub const ERROR_IPSEC_IKE_CRL_FAILED = @as(c_long, 13817);
pub const PME_CURRENT_VERSION = 1;
pub const REGDB_S_FIRST = @as(c_long, 262480);
pub const GCP_KASHIDA = 1024;
pub const EMR_RESERVED_106 = 106;
pub const InterlockedBitTestAndSet64NoFence = _interlockedbittestandset64;
pub const DIB_RGB_COLORS = 0;
pub const MCI_WAVE_STATUS_BITSPERSAMPLE = @as(c_long, 16390);
pub const CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY = 2;
pub const _USE_DECLSPECS_FOR_SAL = 0;
pub const FILE_SEQUENTIAL_WRITE_ONCE = 1048576;
pub const SOFTDIST_FLAG_USAGE_AUTOINSTALL = 4;
pub const LOCALE_SABBREVDAYNAME3 = 51;
pub const GET_TAPE_MEDIA_INFORMATION = 0;
pub const CERT_CHAIN_ENABLE_MOTW_TIMESTAMP_HYGIENE_FLAG = 536870912;
pub const PKCS_7_NDR_ENCODING = 131072;
pub const szOID_CERT_EXTENSIONS = "1.3.6.1.4.1.311.2.1.14";
pub const WM_RBUTTONDBLCLK = 518;
pub const WM_NOTIFY = 78;
pub const CTRY_KYRGYZSTAN = 996;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS = 24;
pub const _MM_HINT_T0 = 1;
pub const SUBLANG_RUSSIAN_RUSSIA = 1;
pub const NONANTIALIASED_QUALITY = 3;
pub const NETSCAPE_SIGN_CA_CERT_TYPE = 1;
pub const SE_SIGNING_LEVEL_CUSTOM_2 = 5;
pub const RRF_ZEROONFAILURE = 536870912;
pub const BitTestAndSet64 = _bittestandset64;
pub const WM_MOUSEACTIVATE = 33;
pub const GWL_HINSTANCE = -6;
pub const Multiply128 = _mul128;
pub const GCL_HMODULE = -16;
pub const ico4 = 1087;
pub const ERROR_CLUSTER_TOO_MANY_NODES = @as(c_long, 5935);
pub const PCF_SPECIALCHARS = if (@typeId(@typeOf(256)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 256) else if (@typeId(@typeOf(256)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 256) else DWORD(256);
pub const CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID = 262144;
pub const PARTITION_ENTRY_UNUSED = 0;
pub const IMAGE_SYM_CLASS_REGISTER = 4;
pub const SPI_SETUIEFFECTS = 4159;
pub const SPI_SETDRAGFULLWINDOWS = 37;
pub const SERVICE_STOP_REASON_MINOR_RECONFIG = 5;
pub const IME_CMODE_FIXED = 2048;
pub const VK_MULTIPLY = 106;
pub const RDW_NOFRAME = 2048;
pub const WM_PAINTCLIPBOARD = 777;
pub const SC_DLG_MINIMAL_UI = 1;
pub const SUBLANG_CHINESE_MACAU = 5;
pub const PartitionClassGuid = GUID_DEVINTERFACE_PARTITION;
pub const SPI_GETPOWEROFFACTIVE = 84;
pub const MAXIMUM_XSTATE_FEATURES = 64;
pub const ERROR_RM_DISCONNECTED = @as(c_long, 6819);
pub const __analysis_assume_lock_acquired = lock;
pub const IMAGE_REL_I386_SEG12 = 9;
pub const CAL_SABBREVDAYNAME1 = 14;
pub const ERROR_IPSEC_IKE_MM_LIMIT = @as(c_long, 13882);
pub const TRANSACTION_NOTIFY_ROLLBACK_COMPLETE = 128;
pub const PAN_MIDLINE_STANDARD_TRIMMED = 2;
pub const LANG_AMHARIC = 94;
pub const VRL_CLASS_CONSISTENCY = VRL_PREDEFINED_CLASS_BEGIN << 0;
pub const WM_IME_SELECT = 645;
pub const NRC_CANCEL = 38;
pub const PRINTRATEUNIT_PPM = 1;
pub const CRYPT_VERIFYCONTEXT = 4026531840;
pub const MHDR_DONE = 1;
pub const ERROR_BAD_NET_RESP = @as(c_long, 58);
pub const PRODUCT_STANDARD_SERVER_V = 36;
pub const OInetCompareUrl = CoInternetCompareUrl;
pub const ERROR_CLUSTER_OLD_VERSION = @as(c_long, 5904);
pub const TPM_RIGHTBUTTON = @as(c_long, 2);
pub const PRODUCT_STORAGE_WORKGROUP_EVALUATION_SERVER = 95;
pub const MOD_MAPPER = 5;
pub const IO_REPARSE_TAG_CLOUD_MASK = @as(c_long, 61440);
pub const CB_MSGMAX = 357;
pub const DRVCNF_RESTART = 2;
pub const JOY_BUTTON30 = @as(c_long, 536870912);
pub const PIDMSI_PRODUCTION = @as(c_long, 10);
pub const DNS_ERROR_RRL_INVALID_WINDOW_SIZE = @as(c_long, 9912);
pub const PF_IMPLINK = AF_IMPLINK;
pub const SCARD_T1_MAX_IFS = 254;
pub const SUBLANG_CORSICAN_FRANCE = 1;
pub const ERROR_RXACT_COMMIT_FAILURE = @as(c_long, 1370);
pub const MCI_DELETE = 2134;
pub const OF_WRITE = 1;
pub const BF_DIAGONAL = 16;
pub const VK_F17 = 128;
pub const STATE_SYSTEM_ALERT_HIGH = 268435456;
pub const DISPLAYCONFIG_TARGET_IS_HMD = 32;
pub const EMR_POLYBEZIER16 = 85;
pub const WNetGetLastError = WNetGetLastErrorA;
pub const SPI_SETSNAPSIZING = 143;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRIAL_AUTOMATION = 19;
pub const ENUM_E_LAST = @as(c_long, 2147746239);
pub const ERROR_CLOUD_FILE_METADATA_CORRUPT = @as(c_long, 363);
pub const PROPSHEETPAGE_V4 = PROPSHEETPAGEA_V4;
pub const PRINTER_NOTIFY_FIELD_PRINT_PROCESSOR = 9;
pub const ImmSetCompositionString = ImmSetCompositionStringA;
pub const SYSTEM_CACHE_ALIGNMENT_SIZE = 64;
pub const IMAGE_REL_PPC_ABSOLUTE = 0;
pub const GGO_GRAY8_BITMAP = 6;
pub const ERROR_DS_ROOT_REQUIRES_CLASS_TOP = @as(c_long, 8432);
pub const HTLEFT = 10;
pub const OFN_READONLY = 1;
pub const lstrlen = lstrlenA;
pub const MAXERRORLENGTH = 256;
pub const WS_EX_TRANSPARENT = @as(c_long, 32);
pub const PP_ENUMEX_SIGNING_PROT = 40;
pub const FNOINVERT = 2;
pub const ERROR_STATE_STRUCTURED_RESET_FAILED = @as(c_long, 15803);
pub const PROCESS_SET_INFORMATION = 512;
pub const MIXER_SETCONTROLDETAILSF_VALUE = @as(c_long, 0);
pub const LOCALE_NEUTRALDATA = 16;
pub const MDM_HDLCPPP_ML_NONE = 1;
pub const WSAELOOP = @as(c_long, 10062);
pub const CHANGER_CLEANER_AUTODISMOUNT = 2147483652;
pub const ERROR_CLOUD_FILE_PROVIDER_NOT_RUNNING = @as(c_long, 362);
pub const ERROR_VOLUME_MOUNTED = @as(c_long, 743);
pub const MF_APPEND = @as(c_long, 256);
pub const GET_MOUSEORKEY_LPARAM = GET_DEVICE_LPARAM;
pub const XSTATE_LWP = 62;
pub const IGIMII_TOOLS = 8;
pub const szOID_CMC_DECRYPTED_POP = "1.3.6.1.5.5.7.7.10";
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND = @as(c_long, 5045);
pub const FIEF_FLAG_SKIP_INSTALLED_VERSION_CHECK = 4;
pub const ERROR_BAD_STACK = @as(c_long, 543);
pub const DF_ALLOWOTHERACCOUNTHOOK = @as(c_long, 1);
pub const FILE_RENAME_FLAG_REPLACE_IF_EXISTS = 1;
pub const EMR_RESERVED_107 = 107;
pub const ERROR_STRICT_CFG_VIOLATION = @as(c_long, 1657);
pub const VAR_FORMAT_NOSUBSTITUTE = if (@typeId(@typeOf(32)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 32) else if (@typeId(@typeOf(32)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 32) else DWORD(32);
pub const MAX_ACL_REVISION = ACL_REVISION4;
pub const SetComputerNameEx = SetComputerNameExA;
pub const AddFontResourceEx = AddFontResourceExA;
pub const _Acquires_nonreentrant_lock_ = lock;
pub const C3_DIACRITIC = 2;
pub const SSF_AVAILABLE = 2;
pub const ERROR_EDP_POLICY_DENIES_OPERATION = @as(c_long, 356);
pub const EVENT_CONSOLE_UPDATE_SIMPLE = 16387;
pub const LOAD_LIBRARY_AS_IMAGE_RESOURCE = 32;
pub const NCRYPT_PIN_CACHE_APPLICATION_TICKET_BYTE_LENGTH = 90;
pub const MS_STRONG_PROV_A = "Microsoft Strong Cryptographic Provider";
pub const IMAGE_REL_AM_ADDR32 = 1;
pub const MIXER_SETCONTROLDETAILSF_QUERYMASK = @as(c_long, 15);
pub const FindFirstChangeNotification = FindFirstChangeNotificationA;
pub const BAUD_2400 = if (@typeId(@typeOf(256)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 256) else if (@typeId(@typeOf(256)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 256) else DWORD(256);
pub const PRINTER_ERROR_JAM = 2;
pub const BCRYPT_RC2_CBC_ALG_HANDLE = if (@typeId(@typeOf(593)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 593) else if (@typeId(@typeOf(593)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 593) else BCRYPT_ALG_HANDLE(593);
pub const USN_REASON_INTEGRITY_CHANGE = 8388608;
pub const RPC_C_IMP_LEVEL_DELEGATE = 4;
pub const MWT_LEFTMULTIPLY = 2;
pub const SERVICE_STOP_REASON_FLAG_PLANNED = 1073741824;
pub const FORMAT_MESSAGE_MAX_WIDTH_MASK = 255;
pub const ERROR_DS_COUNTING_AB_INDICES_FAILED = @as(c_long, 8428);
pub const RPI_FLAG_SMB2_SHARECAP_DFS = 8;
pub const MS_DEF_RSA_SIG_PROV_A = "Microsoft RSA Signature Cryptographic Provider";
pub const ERROR_NODE_NOT_AVAILABLE = @as(c_long, 5036);
pub const VTBIT_CY = 1 << VT_CY;
pub const LANG_POLISH = 21;
pub const WM_IME_NOTIFY = 642;
pub const CRYPT_USER_PROTECTED_STRONG = 1048576;
pub const SE_SIGNING_LEVEL_CUSTOM_1 = 3;
pub const IMAGE_HOT_PATCH_REL32 = 245760;
pub const EMR_STROKEPATH = 64;
pub const WM_DEVICECHANGE = 537;
pub const __POINTER_WIDTH__ = 64;
pub const ctlLast = 1279;
pub const IMAGE_REL_IA64_IMM64 = 3;
pub const ERROR_MRM_NO_CURRENT_VIEW_ON_THREAD = @as(c_long, 15143);
pub const NCBNAMSZ = 16;
pub const ERROR_LOG_SECTOR_REMAPPED = @as(c_long, 6602);
pub const ALG_SID_IDEA = 5;
pub const IMAGE_REL_ARM64_TOKEN = 12;
pub const SCARD_POWER_DOWN = 0;
pub const DNS_ERROR_RCODE_REFUSED = @as(c_long, 9005);
pub const ERROR_SXS_CANT_GEN_ACTCTX = @as(c_long, 14001);
pub const SETDTR = 5;
pub const ERROR_DOMAIN_TRUST_INCONSISTENT = @as(c_long, 1810);
pub const BCRYPT_HASH_INTERFACE_MAJORVERSION_2 = 2;
pub const DNS_ERROR_DS_ZONE_ALREADY_EXISTS = @as(c_long, 9718);
pub const CERT_COMPARE_KEY_SPEC = 9;
pub const szOID_OIWDIR_SIGN = "1.3.14.7.2.3";
pub const ERROR_DS_COULDNT_UPDATE_SPNS = @as(c_long, 8525);
pub const PRINTER_DRIVER_SANDBOX_ENABLED = 4;
pub const ERROR_SECUREBOOT_NOT_ENABLED = @as(c_long, 4425);
pub const LCS_GM_BUSINESS = @as(c_long, 1);
pub const MEM_EXTENDED_PARAMETER_NUMA_NODE_MANDATORY = MINLONG64;
pub const IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY = 1;
pub const PCASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION = PCASSEMBLY_FILE_DETAILED_INFORMATION;
pub const RPC_CONTEXT_HANDLE_FLAGS = @as(c_ulong, 805306368);
pub const SUBLANG_INUKTITUT_CANADA = 1;
pub const CAL_SABBREVDAYNAME6 = 19;
pub const ERROR_IPSEC_DOSP_NOT_INSTALLED = @as(c_long, 13931);
pub const MCI_BREAK_KEY = @as(c_long, 256);
pub const GET_FEATURE_FROM_THREAD_TRUSTED = 32;
pub const ACCESS_REASON_TYPE_MASK = 16711680;
pub const PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_MASK = if (@typeId(@typeOf(i64 << 36)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 36) else if (@typeId(@typeOf(i64 << 36)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 36) else @as(c_uint, 3)(i64 << 36);
pub const EIDRM = 111;
pub const COPYFILE_SIS_LINK = 1;
pub const RPC_S_NO_PROTSEQS = @as(c_long, 1719);
pub const MB_ICONQUESTION = @as(c_long, 32);
pub const X509_CERT_REQUEST_TO_BE_SIGNED = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 4) else LPCSTR(4);
pub const POINTER_MESSAGE_FLAG_CANCELED = 32768;
pub const PIDSI_EDITTIME = @as(c_long, 10);
pub const LOCALE_INEUTRAL = 113;
pub const URLACTION_HTML_SUBMIT_FORMS = 5633;
pub const SUBLANG_INDONESIAN_INDONESIA = 1;
pub const CMSG_CMS_RECIPIENT_INDEX_PARAM = 34;
pub const FILE_ROOT_DIR = 3;
pub const CERT_CHAIN_POLICY_BASIC_CONSTRAINTS = if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 5) else if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 5) else LPCSTR(5);
pub const MMIO_PARSE = 256;
pub const SPI_GETWORKAREA = 48;
pub const MCI_FORMAT_SMPTE_25 = 5;
pub const SHTDN_REASON_MINOR_HARDWARE_DRIVER = 13;
pub const SERVICE_CONFIG_FAILURE_ACTIONS = 2;
pub const rad16 = 1071;
pub const KP_EFFECTIVE_KEYLEN = 19;
pub const ERROR_SMARTCARD_SUBSYSTEM_FAILURE = @as(c_long, 1264);
pub const VK_F14 = 125;
pub const MCI_ANIM_UPDATE_HDC = @as(c_long, 131072);
pub const NCBSEND = 20;
pub const LPOINETSESSION = LPIINTERNETSESSION;
pub const CMSG_ENCRYPTED_DIGEST = 27;
pub const ERROR_RESOURCE_PROPERTY_UNCHANGEABLE = @as(c_long, 5089);
pub const PS_DASHDOTDOT = 4;
pub const ERROR_CLUSTER_NETINTERFACE_EXISTS = @as(c_long, 5046);
pub const PSN_RESET = if (@typeId(@typeOf(-3)) == @import("builtin").TypeId.Pointer) @ptrCast(PSN_FIRST, -3) else if (@typeId(@typeOf(-3)) == @import("builtin").TypeId.Int) @intToPtr(PSN_FIRST, -3) else PSN_FIRST(-3);
pub const DMBIN_TRACTOR = 8;
pub const PP_ROOT_CERTSTORE = 46;
pub const CRYPT_MESSAGE_KEYID_SIGNER_FLAG = 4;
pub const ERROR_DS_DST_DOMAIN_NOT_NATIVE = @as(c_long, 8496);
pub const SE_GROUP_MANDATORY = @as(c_long, 1);
pub const NCRYPT_INITIALIZATION_VECTOR = BCRYPT_INITIALIZATION_VECTOR;
pub const CDERR_GENERALCODES = 0;
pub const CRYPT_LAST_ALG_OID_GROUP_ID = CRYPT_SIGN_ALG_OID_GROUP_ID;
pub const FACILITY_USERMODE_SPACES = 231;
pub const BCRYPT_ECDSA_PRIVATE_P256_MAGIC = 844317509;
pub const PRINTACTION_DOCUMENTDEFAULTS = 6;
pub const NUMPRS_LEADING_WHITE = 1;
pub const HORZRES = 8;
pub const STATE_SYSTEM_CHECKED = 16;
pub const WM_SETTEXT = 12;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_MASK = 4278190080;
pub const GID_PAN = 4;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = 1;
pub const STORATTRIBUTE_NONE = 0;
pub const NCRYPT_PUBLIC_LENGTH_PROPERTY = BCRYPT_PUBLIC_KEY_LENGTH;
pub const szOID_DISALLOWED_HASH = szOID_CERT_SIGNATURE_HASH_PROP_ID;
pub const ERROR_DS_MISSING_REQUIRED_ATT = @as(c_long, 8316);
pub const CRYPT_IMPL_SOFTWARE = 2;
pub const waveInGetDevCaps = waveInGetDevCapsA;
pub const __INTMAX_WIDTH__ = 64;
pub const UCSCHAR_INVALID_CHARACTER = 4294967295;
pub const ERROR_NOT_ENOUGH_SERVER_MEMORY = @as(c_long, 1130);
pub const CharPrev = CharPrevA;
pub const GCP_JUSTIFYIN = @as(c_long, 2097152);
pub const KEY_NOTIFY = 16;
pub const CERT_SUBJECT_INFO_ACCESS_PROP_ID = 80;
pub const TXFS_RM_FLAG_LOG_GROWTH_INCREMENT_PERCENT = 32;
pub const ERROR_NO_MORE_SEARCH_HANDLES = @as(c_long, 113);
pub const VarUintFromI4 = VarUI4FromI4;
pub const DEVICEFAMILYDEVICEFORM_MAX = 33;
pub const NCRYPT_ALLOW_EXPORT_FLAG = 1;
pub const WAVE_FORMAT_48M08 = 4096;
pub const szOID_OIWSEC_sha = "1.3.14.3.2.18";
pub const EMR_RESERVED_108 = 108;
pub const MDM_MASK_HDLCPPP_AUTH = 7 << 3;
pub const CE_IOE = 1024;
pub const MCI_ANIM_WHERE_DESTINATION = @as(c_long, 262144);
pub const CERT_QUERY_CONTENT_SERIALIZED_STORE = 4;
pub const WIM_PROVIDER_HASH_SIZE = 20;
pub const ERROR_SECUREBOOT_POLICY_NOT_SIGNED = @as(c_long, 4424);
pub const ERROR_RESOURCE_NOT_ONLINE = @as(c_long, 5004);
pub const PORT_STATUS_TYPE_WARNING = 2;
pub const NCRYPTBUFFER_EMPTY = 0;
pub const FADF_AUTO = 1;
pub const GetCharWidth = GetCharWidthA;
pub const PRINTRATEUNIT_IPM = 4;
pub const LOCALE_SABBREVDAYNAME1 = 49;
pub const MDITILE_HORIZONTAL = 1;
pub const CMSG_ENVELOPED_DATA_CMS_VERSION = CMSG_ENVELOPED_DATA_V2;
pub const X3_BTYPE_QP_INST_VAL_POS_X = 0;
pub const PERSISTENT_VOLUME_STATE_LOCAL_METADATA_NO_SEEK_PENALTY = 8;
pub const SEF_DACL_AUTO_INHERIT = 1;
pub const DISPLAYCONFIG_PATH_SUPPORT_VIRTUAL_MODE = 8;
pub const WNNC_NET_BWNFS = 1048576;
pub const WM_QUERYUISTATE = 297;
pub const SERKF_SERIALKEYSON = 1;
pub const PRINTER_ERROR_SEVERE = 536870912;
pub const WHEEL_PAGESCROLL = UINT_MAX;
pub const CopyAcceleratorTable = CopyAcceleratorTableA;
pub const PD_USEDEVMODECOPIES = 262144;
pub const EnumResourceNames = EnumResourceNamesA;
pub const PRINTER_DRIVER_SOFT_RESET_REQUIRED = 1024;
pub const IME_HOTKEY_PRIVATE_LAST = 543;
pub const ENOENT = 2;
pub const SPI_SETBORDER = 6;
pub const SPI_GETLOWPOWERTIMEOUT = 79;
pub const ERROR_LOG_RECORDS_RESERVED_INVALID = @as(c_long, 6625);
pub const CONTAINER_INHERIT_ACE = 2;
pub const UNPROTECTED_DACL_SECURITY_INFORMATION = @as(c_long, 536870912);
pub const ico2 = 1085;
pub const PRINTER_STATUS_INITIALIZING = 32768;
pub const _NLSCMPERROR = _CRT_INT_MAX;
pub const CERT_REGISTRY_STORE_EXTERNAL_FLAG = 1048576;
pub const SPI_SETMINIMIZEDMETRICS = 44;
pub const __LDBL_MIN_EXP__ = -1021;
pub const ImmGetGuideLine = ImmGetGuideLineA;
pub const HWND_MESSAGE = if (@typeId(@typeOf(-3)) == @import("builtin").TypeId.Pointer) @ptrCast(HWND, -3) else if (@typeId(@typeOf(-3)) == @import("builtin").TypeId.Int) @intToPtr(HWND, -3) else HWND(-3);
pub const LANG_HUNGARIAN = 14;
pub const ERROR_CAPAUTHZ_SCCD_PARSE_ERROR = @as(c_long, 458);
pub const IMN_CHANGECANDIDATE = 3;
pub const SSTF_BORDER = 2;
pub const PRODUCT_ENTERPRISE_EVALUATION = 72;
pub const VFT2_DRV_INPUTMETHOD = @as(c_long, 11);
pub const STORAGE_PROTOCOL_STATUS_SUCCESS = 1;
pub const DNS_ERROR_CLIENT_SUBNET_DOES_NOT_EXIST = @as(c_long, 9976);
pub const CERT_UNICODE_RDN_ERR_INDEX_MASK = 1023;
pub const ERROR_DS_DRA_BAD_DN = @as(c_long, 8439);
pub const DLGC_HASSETSEL = 8;
pub const CERT_RDN_PRINTABLE_STRING = 4;
pub const POWER_ACTION_HIBERBOOT = 8;
pub const szOID_RSAES_OAEP = "1.2.840.113549.1.1.7";
pub const ERROR_DS_DRA_SOURCE_DISABLED = @as(c_long, 8456);
pub const LZERROR_BADVALUE = -7;
pub const IME_HOTKEY_PRIVATE_FIRST = 512;
pub const CAL_SABBREVDAYNAME7 = 20;
pub const TXFS_TRANSACTED_VERSION_UNCOMMITTED = 4294967295;
pub const ERROR_DS_INCORRECT_ROLE_OWNER = @as(c_long, 8210);
pub const NETPROPERTY_PERSISTENT = 1;
pub const FONTMAPPER_MAX = 10;
pub const PIDMSI_EDITOR = @as(c_long, 2);
pub const ERROR_INVALID_LB_MESSAGE = @as(c_long, 1432);
pub const ERROR_SXS_XML_E_UNEXPECTEDEOF = @as(c_long, 14058);
pub const SCARD_COLD_RESET = 1;
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_ENABLED = 1;
pub const VK_GAMEPAD_DPAD_UP = 203;
pub const PP_ENUMALGS = 1;
pub const ODS_DEFAULT = 32;
pub const __INT_LEAST16_MAX__ = 32767;
pub const ERROR_STORAGE_RESERVE_ID_INVALID = @as(c_long, 416);
pub const EFS_METADATA_ADD_USER = 1;
pub const EM_SETHANDLE = 188;
pub const MIDISTRM_ERROR = -2;
pub const WAVE_FORMAT_QUERY = 1;
pub const szOID_RSA_counterSign = "1.2.840.113549.1.9.6";
pub const CERT_REQUEST_ORIGINATOR_PROP_ID = 71;
pub const MCI_FORMAT_SMPTE_24 = 4;
pub const CERT_CHAIN_MAX_SSL_TIME_UPDATED_EVENT_COUNT_DISABLE = 4294967295;
pub const EMARCH_ENC_I17_IC_INST_WORD_X = 3;
pub const ERROR_LOG_RESTART_INVALID = @as(c_long, 6607);
pub const LSFW_UNLOCK = 2;
pub const DEVICEFAMILYDEVICEFORM_BANKING = 14;
pub const MCI_LOAD = 2128;
pub const rad15 = 1070;
pub const CERT_CHAIN_POLICY_IGNORE_CTL_NOT_TIME_VALID_FLAG = 2;
pub const VK_F15 = 126;
pub const SPI_ICONVERTICALSPACING = 24;
pub const __OBJC_BOOL_IS_BOOL = 0;
pub const SUBLANG_MOHAWK_MOHAWK = 1;
pub const MCI_SYSINFO_OPEN = @as(c_long, 512);
pub const FACILITY_WEBSERVICES = 61;
pub const ERROR_INVALID_SHARENAME = @as(c_long, 1215);
pub const ERROR_CANT_ACCESS_FILE = @as(c_long, 1920);
pub const PRODUCT_EMBEDDED_INDUSTRY = 89;
pub const ODT_MENU = 1;
pub const ReportEvent = ReportEventA;
pub const SMART_ERROR_NO_MEM = 7;
pub const SERVICE_STOP_REASON_MAJOR_MIN_CUSTOM = 4194304;
pub const JOB_NOTIFY_FIELD_UNTIL_TIME = 18;
pub const VK_GAMEPAD_DPAD_LEFT = 205;
pub const UMS_VERSION = RTL_UMS_VERSION;
pub const ERROR_DS_OBJECT_RESULTS_TOO_LARGE = @as(c_long, 8248);
pub const IMAGE_REL_AMD64_REL32_5 = 9;
pub const CTRY_SYRIA = 963;
pub const CRYPT_SERVER = 1024;
pub const LUA_TOKEN = 4;
pub const LOCALE_SLOCALIZEDLANGUAGENAME = 111;
pub const CRYPT_STRING_BINARY = 2;
pub const _WIN32_IE_LONGHORN = _WIN32_IE_IE70;
pub const CTRY_SPAIN = 34;
pub const TC_PUBLIC_DEVICEDUMP_CONTENT_GPLOG = 2;
pub const CERT_NCRYPT_KEY_SPEC = 4294967295;
pub const STRING_LANGPAIR = 4;
pub const SPI_SETICONTITLELOGFONT = 34;
pub const _M_X64 = 100;
pub const STORAGE_PROTOCOL_STATUS_NO_DEVICE = 4;
pub const SERVICE_TRIGGER_DATA_TYPE_BINARY = 1;
pub const IOCTL_SCM_LOGICAL_DEVICE_FUNCTION_BASE = 768;
pub const CERT_STRONG_SIGN_ENABLE_CRL_CHECK = 1;
pub const ERROR_RM_METADATA_CORRUPT = @as(c_long, 6802);
pub const ERROR_MACHINE_LOCKED = @as(c_long, 1271);
pub const EMR_RESERVED_109 = 109;
pub const CERT_DESCRIPTION_PROP_ID = 13;
pub const szOID_PKCS_5_PBKDF2 = "1.2.840.113549.1.5.12";
pub const DATA_S_LAST = @as(c_long, 262463);
pub const SPI_SETICONS = 88;
pub const CERT_TRUST_HAS_WEAK_SIGNATURE = 1048576;
pub const SM_CYMENUSIZE = 55;
pub const MCI_ALL_DEVICE_ID = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(MCIDEVICEID, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(MCIDEVICEID, -1) else MCIDEVICEID(-1);
pub const CERT_FIRST_RESERVED_PROP_ID = 128;
pub const MARSHAL_S_LAST = @as(c_long, 262447);
pub const CERT_RDN_GRAPHIC_STRING = 8;
pub const IMC_SETSTATUSWINDOWPOS = 16;
pub const CopyFile = CopyFileA;
pub const EXCEPTION_SINGLE_STEP = STATUS_SINGLE_STEP;
pub const HTHSCROLL = 6;
pub const LOAD_LIBRARY_SEARCH_SYSTEM32 = 2048;
pub const E_DRAW = VIEW_E_DRAW;
pub const LOCALE_SABBREVDAYNAME6 = 54;
pub const RI_MOUSE_BUTTON_2_UP = RI_MOUSE_RIGHT_BUTTON_UP;
pub const MB_ABORTRETRYIGNORE = @as(c_long, 2);
pub const PRINTER_ENUM_NAME = 8;
pub const ECONNREFUSED = 107;
pub const PFD_SUPPORT_GDI = 16;
pub const wglUseFontOutlines = wglUseFontOutlinesA;
pub const MIXERCONTROL_CONTROLF_UNIFORM = @as(c_long, 1);
pub const KDF_USE_SECRET_AS_HMAC_KEY_FLAG = 1;
pub const PAN_XHEIGHT_CONSTANT_STD = 3;
pub const SECURITY_ANONYMOUS = SecurityAnonymous << 16;
pub const CTRY_LITHUANIA = 370;
pub const ERROR_CLUSTER_MAX_NODES_IN_CLUSTER = @as(c_long, 5934);
pub const C3_VOWELMARK = 4;
pub const SOMAXCONN = 5;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_REUSED = 33554432;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT = @as(c_long, 370);
pub const MCI_ANIM_STEP_REVERSE = @as(c_long, 65536);
pub const CTL_V1 = 0;
pub const szOID_PKCS_12_PbeIds = "1.2.840.113549.1.12.1";
pub const MCI_VD_GETDEVCAPS_NORMAL_RATE = @as(c_long, 16389);
pub const URLACTION_HTML_MAX = 6143;
pub const APPCOMMAND_CUT = 37;
pub const WSA_QOS_RESERVED_PETYPE = @as(c_long, 11031);
pub const ERROR_TOO_MANY_LINKS = @as(c_long, 1142);
pub const SYSTEM_PROCESS_TRUST_LABEL_VALID_MASK = 16777215;
pub const __XSAVEC__ = 1;
pub const PIDSI_CREATE_DTM = @as(c_long, 12);
pub const __UINT_FAST16_MAX__ = 65535;
pub const ico3 = 1086;
pub const FACILITY_DEVICE_UPDATE_AGENT = 135;
pub const WN_DEVICE_ALREADY_REMEMBERED = ERROR_DEVICE_ALREADY_REMEMBERED;
pub const EMR_ANGLEARC = 41;
pub const NCRYPT_DES_ALGORITHM = BCRYPT_DES_ALGORITHM;
pub const POWER_FORCE_TRIGGER_RESET = 2147483648;
pub const LPCPROPSHEETPAGE_LATEST = LPCPROPSHEETPAGEA_LATEST;
pub const PERSISTENT_VOLUME_STATE_NO_WRITE_AUTO_TIERING = 128;
pub const ICON_SMALL = 0;
pub const SPOOL_FILE_PERSISTENT = 1;
pub const MS_ENH_DSS_DH_PROV = MS_ENH_DSS_DH_PROV_A;
pub const szOID_INFOSEC_sdnsKeyManagement = "2.16.840.1.101.2.1.1.9";
pub const CERT_STORE_PROV_NO_PERSIST_FLAG = 4;
pub const HCBT_MOVESIZE = 0;
pub const CAL_SABBREVDAYNAME4 = 17;
pub const URLACTION_HTML_MIN = 5632;
pub const APPCOMMAND_VOLUME_DOWN = 9;
pub const MAX_PATH = 260;
pub const CRYPT_NEXT = 2;
pub const TF_REUSE_SOCKET = 2;
pub const ERROR_DS_DRA_MAIL_PROBLEM = @as(c_long, 8447);
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_VCN = 8589934592;
pub const __CLANG_ATOMIC_INT_LOCK_FREE = 2;
pub const PF_FIREFOX = AF_FIREFOX;
pub const CM_DEVICE_ICM = 1;
pub const PERF_DATA_VERSION = 1;
pub const EVENTLOG_WARNING_TYPE = 2;
pub const WSA_QOS_TRAFFIC_CTRL_ERROR = @as(c_long, 11014);
pub const ERROR_EC_CIRCULAR_FORWARDING = @as(c_long, 15082);
pub const CMSG_SIGNER_INFO_CMS_VERSION = CMSG_SIGNER_INFO_V3;
pub const PRINTER_ATTRIBUTE_ENABLE_BIDI = 2048;
pub const DISK_ATTRIBUTE_READ_ONLY = 2;
pub const ENUM_E_FIRST = @as(c_long, 2147746224);
pub const PAN_SERIF_COVE = 2;
pub const STOPBITS_10 = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(WORD, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(WORD, 1) else WORD(1);
pub const EMR_CREATECOLORSPACEW = 122;
pub const DOMAIN_ALIAS_RID_GUESTS = @as(c_long, 546);
pub const CreateMailslot = CreateMailslotA;
pub const ERROR_INCORRECT_ADDRESS = @as(c_long, 1241);
pub const GetClassName = GetClassNameA;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_IMPORT_CONTROL_TRANSFER = 3;
pub const SUBLANG_GALICIAN_GALICIAN = 1;
pub const rad14 = 1069;
pub const ERROR_MEMBERS_PRIMARY_GROUP = @as(c_long, 1374);
pub const IMAGE_ENCLAVE_IMPORT_MATCH_IMAGE_ID = 4;
pub const SUBLANG_ESTONIAN_ESTONIA = 1;
pub const PKCS_CONTENT_INFO_SEQUENCE_OF_ANY = if (@typeId(@typeOf(23)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 23) else if (@typeId(@typeOf(23)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 23) else LPCSTR(23);
pub const VER_NT_SERVER = 3;
pub const ERROR_CALLBACK_SUPPLIED_INVALID_DATA = @as(c_long, 1273);
pub const NCRYPTBUFFER_PROTECTION_DESCRIPTOR_STRING = 3;
pub const TIMESTAMP_DONT_HASH_DATA = 1;
pub const PARTITION_SPACES_DATA = 215;
pub const MOUSEEVENTF_LEFTUP = 4;
pub const szOID_KP_CA_EXCHANGE = "1.3.6.1.4.1.311.21.5";
pub const ETO_CLIPPED = 4;
pub const CERT_QUERY_CONTENT_SERIALIZED_CERT = 5;
pub const SCARD_WARM_RESET = 2;
pub const RPC_C_HTTP_FLAG_ENABLE_CERT_REVOCATION_CHECK = 16;
pub const LOCALE_ICALENDARTYPE = 4105;
pub const BALTIC_CHARSET = 186;
pub const PAN_PROPORTION_INDEX = 3;
pub const NUMPRS_LEADING_MINUS = 16;
pub const ERROR_LOG_SPACE_RESERVED_INVALID = @as(c_long, 6626);
pub const edt13 = 1164;
pub const GMEM_NOT_BANKED = 4096;
pub const ERROR_DPL_NOT_SUPPORTED_FOR_USER = @as(c_long, 423);
pub const PSP_DEFAULT = 0;
pub const WN_CANNOT_OPEN_PROFILE = ERROR_CANNOT_OPEN_PROFILE;
pub const POINTER_FLAG_DOWN = 65536;
pub const DMPAPER_TABLOID = 3;
pub const VK_END = 35;
pub const CRYPT_OID_VERIFY_REVOCATION_FUNC = "CertDllVerifyRevocation";
pub const IME_THOTKEY_SYMBOL_TOGGLE = 114;
pub const PD_PRINTTOFILE = 32;
pub const __FLT16_MAX_10_EXP__ = 4;
pub const VK_GAMEPAD_Y = 198;
pub const CAL_ICALINTVALUE = 1;
pub const SWP_NOACTIVATE = 16;
pub const PF_MAX = AF_MAX;
pub const IMAGE_REL_AMD64_REL32_4 = 8;
pub const PROCESS_CREATION_MITIGATION_POLICY2_STRICT_CONTROL_FLOW_GUARD_MASK = if (@typeId(@typeOf(i64 << 8)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 8) else if (@typeId(@typeOf(i64 << 8)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 8) else @as(c_uint, 3)(i64 << 8);
pub const LSFW_LOCK = 1;
pub const szOIDVerisign_SenderNonce = "2.16.840.1.113733.1.9.5";
pub const GDI_OBJ_LAST = OBJ_COLORSPACE;
pub const CERT_BIOMETRIC_OID_DATA_CHOICE = 2;
pub const szOID_NETSCAPE_CERT_TYPE = "2.16.840.1.113730.1.1";
pub const CRYPT_KEYID_MACHINE_FLAG = 32;
pub const CERT_BIOMETRIC_PREDEFINED_DATA_CHOICE = 1;
pub const _WIN32_WINNT_VISTA = 1536;
pub const SPI_SETKEYBOARDCUES = 4107;
pub const CERT_PHYSICAL_STORE_REMOTE_OPEN_DISABLE_FLAG = 4;
pub const SHUFFLE_FILE_FLAG_SKIP_INITIALIZING_NEW_CLUSTERS = 1;
pub const IMN_CLOSECANDIDATE = 4;
pub const szOID_CRL_SELF_CDP = "1.3.6.1.4.1.311.21.14";
pub const R2_WHITE = 16;
pub const BSF_NOTIMEOUTIFNOTHUNG = 64;
pub const FILE_NOTIFY_CHANGE_LAST_ACCESS = 32;
pub const ERROR_IPSEC_IKE_INVALID_COOKIE = @as(c_long, 13846);
pub const WM_POWER = 72;
pub const CTRY_LUXEMBOURG = 352;
pub const IDENTIFY_BUFFER_SIZE = 512;
pub const ua_lstrlen = lstrlenA;
pub const URLACTION_COOKIES_THIRD_PARTY = 6661;
pub const RPC_C_EP_MATCH_BY_OBJ = 2;
pub const OF_READWRITE = 2;
pub const TAPE_FIXED_PARTITIONS = @as(c_long, 0);
pub const LOCALE_SABBREVDAYNAME7 = 55;
pub const InterlockedAnd = _InterlockedAnd;
pub const IMAGE_REL_SH3_SECTION = 14;
pub const ERROR_DS_INVALID_NAME_FOR_SPN = @as(c_long, 8554);
pub const MOVEFILE_FAIL_IF_NOT_TRACKABLE = 32;
pub const DNS_ERROR_POLICY_INVALID_WEIGHT = @as(c_long, 9981);
pub const Uri_CREATE_NO_PRE_PROCESS_HTML_URI = 4096;
pub const FACILITY_AAF = 18;
pub const PROP_LG_CYDLG = 218;
pub const MB_DEFAULT_DESKTOP_ONLY = @as(c_long, 131072);
pub const AdvancedDocumentProperties = AdvancedDocumentPropertiesA;
pub const MSG_PEEK = 2;
pub const GDICOMMENT_IDENTIFIER = 1128875079;
pub const UPDFCACHE_ONSAVECACHE = 2;
pub const ERROR_DS_SAM_INIT_FAILURE = @as(c_long, 8504);
pub const CTRY_ITALY = 39;
pub const ACCESS_DS_OBJECT_TYPE_NAME_A = "Directory Service Object";
pub const LBS_NODATA = @as(c_long, 8192);
pub const MEM_MAPPED = 262144;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR = @as(c_long, 13842);
pub const CHECKSUM_TYPE_CRC32 = 1;
pub const ALG_SID_ECMQV = 1;
pub const CMSG_CONTENTS_OCTETS_FLAG = 16;
pub const EnumCalendarInfoEx = EnumCalendarInfoExA;
pub const SUBLANG_SPANISH_HONDURAS = 18;
pub const QueryServiceLockStatus = QueryServiceLockStatusA;
pub const FILE_MAP_ALL_ACCESS = SECTION_ALL_ACCESS;
pub const WNNC_NET_LANTASTIC = 655360;
pub const DMPAPER_P16K_ROTATED = 106;
pub const PF_PPC_MOVEMEM_64BIT_OK = 4;
pub const WM_DRAWCLIPBOARD = 776;
pub const HSHELL_WINDOWDESTROYED = 2;
pub const IMAGE_SCN_ALIGN_32BYTES = 6291456;
pub const NIM_MODIFY = 1;
pub const IMAGE_SYM_CLASS_WEAK_EXTERNAL = 105;
pub const MNS_AUTODISMISS = 268435456;
pub const CommDlg_OpenSave_GetSpec = CommDlg_OpenSave_GetSpecA;
pub const __SPECSTRINGS_STRICT_LEVEL = 1;
pub const CopyMetaFile = CopyMetaFileA;
pub const IO_REPARSE_TAG_AF_UNIX = @as(c_long, 2147483683);
pub const SCARD_ATTR_DEVICE_SYSTEM_NAME = SCARD_ATTR_DEVICE_SYSTEM_NAME_A;
pub const szOID_INFOSEC_mosaicSignature = "2.16.840.1.101.2.1.1.2";
pub const FR_NOWRAPAROUND = 524288;
pub const FOF_NO_CONNECTED_ELEMENTS = 8192;
pub const TT_ENABLED = 2;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_INDIR_CONTROL_TRANSFER = 4;
pub const CAL_SABBREVDAYNAME5 = 18;
pub const ERROR_DBG_REPLY_LATER = @as(c_long, 689);
pub const LB_CTLCODE = @as(c_long, 0);
pub const KDF_CONTEXT = 14;
pub const RI_MOUSE_BUTTON_3_DOWN = RI_MOUSE_MIDDLE_BUTTON_DOWN;
pub const STANDARD_RIGHTS_EXECUTE = READ_CONTROL;
pub const DC_EMF_COMPLIANT = 20;
pub const VK_OEM_FJ_TOUROKU = 148;
pub const DC_MODEL = 24;
pub const ERROR_DS_NOT_INSTALLED = @as(c_long, 8200);
pub const ERROR_SXS_XML_E_BADCHARINSTRING = @as(c_long, 14034);
pub const IDHOT_SNAPDESKTOP = -2;
pub const PROCESS_CREATION_MITIGATION_POLICY2_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY_DEFER = if (@typeId(@typeOf(i64 << 20)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), i64 << 20) else if (@typeId(@typeOf(i64 << 20)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), i64 << 20) else @as(c_uint, 0)(i64 << 20);
pub const CERT_CHAIN_POLICY_IGNORE_INVALID_NAME_FLAG = 64;
pub const ERROR_DS_AUTH_UNKNOWN = @as(c_long, 8234);
pub const PRINTER_STATUS_POWER_SAVE = 16777216;
pub const FILE_DEVICE_SMB = 46;
pub const SUBLANG_SPANISH_CHILE = 13;
pub const SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE = 15;
pub const OemToChar = OemToCharA;
pub const CERT_TRUST_PUB_CHECK_PUBLISHER_REV_FLAG = 256;
pub const XACT_E_FIRST = 2147799040;
pub const SB_LEFT = 6;
pub const CryptVerifySignature = CryptVerifySignatureA;
pub const InterlockedExchangePointerAcquire = _InterlockedExchangePointer;
pub const GENERIC_ALL = @as(c_long, 268435456);
pub const X509_UNICODE_NAME = if (@typeId(@typeOf(20)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 20) else if (@typeId(@typeOf(20)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 20) else LPCSTR(20);
pub const ERROR_MEDIA_OFFLINE = @as(c_long, 4304);
pub const InterlockedAnd64Release = _InterlockedAnd64;
pub const TOUCH_HIT_TESTING_CLIENT = 1;
pub const MCI_OVLY_WINDOW_HWND = @as(c_long, 65536);
pub const CERT_RDN_UTF8_STRING = 13;
pub const szOID_PKCS_12_pbeWithSHA1And2KeyTripleDES = "1.2.840.113549.1.12.1.4";
pub const CTRL_LOGOFF_EVENT = 5;
pub const ERROR_MUI_FILE_NOT_FOUND = @as(c_long, 15100);
pub const BCRYPT_SHA1_ALG_HANDLE = if (@typeId(@typeOf(49)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 49) else if (@typeId(@typeOf(49)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 49) else BCRYPT_ALG_HANDLE(49);
pub const ERROR_DS_IS_LEAF = @as(c_long, 8243);
pub const MFS_HILITE = MF_HILITE;
pub const ERROR_DS_NO_PARENT_OBJECT = @as(c_long, 8329);
pub const RC_FLOODFILL = 4096;
pub const ERROR_LOG_BLOCK_VERSION = @as(c_long, 6608);
pub const LANG_INVARIANT = 127;
pub const LANG_LATVIAN = 38;
pub const BCRYPT_ECDSA_PUBLIC_P521_MAGIC = 894649157;
pub const DNS_ERROR_RCODE_NO_ERROR = NO_ERROR;
pub const TXFS_LOGGING_MODE_SIMPLE = 1;
pub const DM_DISPLAYFREQUENCY = @as(c_long, 4194304);
pub const PKCS12_ENCRYPT_CERTIFICATES = 512;
pub const STREAM_LAYOUT_ENTRY_PINNED = 2;
pub const FACILITY_DISPATCH = 2;
pub const DFCS_SCROLLRIGHT = 3;
pub const edt12 = 1163;
pub const DispatchMessage = DispatchMessageA;
pub const MFS_GRAYED = @as(c_long, 3);
pub const IMAGE_REL_SH3_ABSOLUTE = 0;
pub const ENABLE_DISABLE_AUTO_OFFLINE = 219;
pub const SPI_SETKEYBOARDPREF = 69;
pub const LANG_TURKISH = 31;
pub const ERROR_REPARSE_TAG_INVALID = @as(c_long, 4393);
pub const VK_GAMEPAD_X = 197;
pub const DOMAIN_ALIAS_RID_CRYPTO_OPERATORS = @as(c_long, 569);
pub const SW_SHOW = 5;
pub const EMARCH_ENC_I17_IC_SIZE_X = 1;
pub const NCRYPTBUFFER_SSL_CLEAR_KEY = 23;
pub const IN_CLASSA_MAX = 128;
pub const PRINTER_CHANGE_DELETE_PRINT_PROCESSOR = 67108864;
pub const FAST_FAIL_PAYLOAD_RESTRICTION_VIOLATION = 51;
pub const WVR_VREDRAW = 512;
pub const SPI_GETMOUSESPEED = 112;
pub const RpcNsProfileEltInqBegin = RpcNsProfileEltInqBeginA;
pub const FILE_INITIATE_REPAIR_HINT1_REPAIRED = 1024;
pub const SELECT_CAP_CONVERSION = 1;
pub const VarUintFromI1 = VarUI4FromI1;
pub const WA_ACTIVE = 1;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PSTATES = 1;
pub const SUBLANG_UIGHUR_PRC = 1;
pub const ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME = @as(c_long, 305);
pub const SERVICE_TRIGGER_TYPE_AGGREGATE = 30;
pub const RPC_X_WRONG_PIPE_ORDER = @as(c_long, 1831);
pub const RTL_CORRELATION_VECTOR_STRING_LENGTH = 129;
pub const CRYPT_ARCHIVE = 256;
pub const GMMP_USE_DISPLAY_POINTS = 1;
pub const SCARD_CLASS_MECHANICAL = 6;
pub const DNS_ERROR_DEFAULT_SCOPE = @as(c_long, 9960);
pub const PARTITION_XINT13 = 14;
pub const RRF_RT_REG_DWORD = 16;
pub const MIXERCONTROL_CONTROLF_MULTIPLE = @as(c_long, 2);
pub const LOCALE_SABBREVDAYNAME4 = 52;
pub const SHGFI_SYSICONINDEX = 16384;
pub const __FLT_MIN_10_EXP__ = -37;
pub const ETO_REVERSE_INDEX_MAP = 65536;
pub const VTDATEGRE_MAX = 2958465;
pub const SS_GRAYRECT = @as(c_long, 5);
pub const ERROR_SERIAL_NO_DEVICE = @as(c_long, 1118);
pub const ERROR_TRANSACTIONAL_CONFLICT = @as(c_long, 6800);
pub const SetCurrentDirectory = SetCurrentDirectoryA;
pub const GetStringTypeEx = GetStringTypeExA;
pub const DFCS_SCROLLSIZEGRIPRIGHT = 16;
pub const mixerGetControlDetails = mixerGetControlDetailsA;
pub const DATABITS_16 = if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Pointer) @ptrCast(WORD, 16) else if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Int) @intToPtr(WORD, 16) else WORD(16);
pub const __class_code_content = typ;
pub const APIPRIVATE = __stdcall;
pub const NCRYPTBUFFER_CLAIM_IDBINDING_NONCE = 48;
pub const PolyTextOut = PolyTextOutA;
pub const GESTUREVISUALIZATION_TAP = 1;
pub const IMAGE_REL_SH3_SIZEOF_SECTION = 13;
pub const MMIO_GLOBALPROC = 268435456;
pub const MH_KEEP = 2;
pub const PROGRESS_STOP = 2;
pub const __deref_inout_ecount_nz_opt = size;
pub const PROC_IDLE_BUCKET_COUNT_EX = 16;
pub const WINSTA_ENUMDESKTOPS = @as(c_long, 1);
pub const HOVER_DEFAULT = 4294967295;
pub const SE_GROUP_LOGON_ID = @as(c_long, 3221225472);
pub const FILE_TRAVERSE = 32;
pub const _WIN32_IE_IE40 = 1024;
pub const PERSISTENT_VOLUME_STATE_VOLUME_SCRUB_DISABLED = 2;
pub const CRYPT_FIND_SILENT_KEYSET_FLAG = 64;
pub const szOID_RDN_TCG_PLATFORM_VERSION = "2.23.133.2.6";
pub const szOID_ECC_CURVE_WTLS12 = szOID_ECC_CURVE_NISTP224;
pub const DMPAPER_B5_TRANSVERSE = 62;
pub const CBR_57600 = 57600;
pub const ico1 = 1084;
pub const ERROR_INSTALL_WRONG_PROCESSOR_ARCHITECTURE = @as(c_long, 15632);
pub const NCRYPT_PIN_CACHE_CLEAR_FOR_CALLING_PROCESS_OPTION = 1;
pub const CERT_COMPARE_ISSUER_OF = 12;
pub const GETSETPAPERMETRICS = 35;
pub const __deref_inout_ecount_nz = size;
pub const PRINTER_ENUM_CATEGORY_ALL = 33554432;
pub const XCLASS_MASK = 64512;
pub const TRANSACTION_NOTIFY_PREPREPARE_COMPLETE = 16;
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT = 8;
pub const ChangeDisplaySettings = ChangeDisplaySettingsA;
pub const CP_OEMCP = 1;
pub const ERROR_DS_CANT_MOVE_DELETED_OBJECT = @as(c_long, 8489);
pub const MSGFLT_ADD = 1;
pub const OFN_NOCHANGEDIR = 8;
pub const PPM_FIRMWARE_PSS = 64;
pub const GMEM_ZEROINIT = 64;
pub const ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED = @as(c_long, 14016);
pub const WSF_VISIBLE = @as(c_long, 1);
pub const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_V0 = 0;
pub const ERROR_SXS_XML_E_MISSINGEQUALS = @as(c_long, 14073);
pub const S_ASYNCHRONOUS = MK_S_ASYNCHRONOUS;
pub const CRYPT_GET_URL_FROM_EXTENSION = 2;
pub const ERROR_NONE_MAPPED = @as(c_long, 1332);
pub const WN_NOT_CONTAINER = ERROR_NOT_CONTAINER;
pub const POLYGONALCAPS = 32;
pub const CERT_AUTH_ROOT_AUTO_UPDATE_DISABLE_UNTRUSTED_ROOT_LOGGING_FLAG = 1;
pub const WNNC_NET_LANSTEP = 524288;
pub const ERROR_CLUSTER_FAULT_DOMAIN_S2D_CONNECTIVITY_LOSS = @as(c_long, 5997);
pub const FR_REPLACEALL = 32;
pub const FACILITY_DEPLOYMENT_SERVICES_PXE = 263;
pub const GESTUREVISUALIZATION_ON = 31;
pub const ERROR_CTX_SHADOW_NOT_RUNNING = @as(c_long, 7057);
pub const ERROR_DS_NAME_ERROR_DOMAIN_ONLY = @as(c_long, 8473);
pub const CONTAINER_ROOT_INFO_FLAG_BIND_ROOT = 32;
pub const STDMETHODVCALLTYPE = __cdecl;
pub const ERROR_DRIVER_PROCESS_TERMINATED = @as(c_long, 1291);
pub const VK_PACKET = 231;
pub const IOInetProtocolSink = IInternetProtocolSink;
pub const FACILITY_BACKGROUNDCOPY = 32;
pub const FO_RENAME = 4;
pub const CERT_STORE_MAXIMUM_ALLOWED_FLAG = 4096;
pub const CMSG_OID_CNG_GEN_CONTENT_ENCRYPT_KEY_FUNC = "CryptMsgDllCNGGenContentEncryptKey";
pub const DEVICEFAMILYINFOENUM_SERVER_NANO = 13;
pub const IPPORT_WHOIS = 43;
pub const LB_SETCOUNT = 423;
pub const ETO_NUMERICSLOCAL = 1024;
pub const BACKUP_PROPERTY_DATA = 6;
pub const RIM_TYPEMAX = 2;
pub const ERROR_SXS_IDENTITY_PARSE_ERROR = @as(c_long, 14093);
pub const UOI_USER_SID = 4;
pub const SPIF_UPDATEINIFILE = 1;
pub const DFCS_SCROLLCOMBOBOX = 5;
pub const CERT_SCEP_FLAGS_PROP_ID = 115;
pub const BCRYPT_MD2_ALG_HANDLE = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 1) else BCRYPT_ALG_HANDLE(1);
pub const SD_GLOBAL_CHANGE_TYPE_QUERY_STATS = 1 << 16;
pub const PBT_APMSTANDBY = 5;
pub const CERT_STORE_PROV_LDAP = CERT_STORE_PROV_LDAP_W;
pub const DNS_ERROR_SUBNET_DOES_NOT_EXIST = @as(c_long, 9978);
pub const RotateLeft32 = _rotl;
pub const FACILITY_UMI = 22;
pub const CF_DIBV5 = 17;
pub const PID_FIRST_NAME_DEFAULT = 4095;
pub const VK_F18 = 129;
pub const FAST_FAIL_INVALID_CALL_IN_DLL_CALLOUT = 23;
pub const RPI_SMB2_FLAG_SERVERCAP_DFS = 1;
pub const __MMX__ = 1;
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_BASE = 32;
pub const _WIN32_IE_IE90 = 2304;
pub const META_CREATEPALETTE = 247;
pub const TC_CR_90 = 8;
pub const MAXUINT = if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT, 0) else UINT(0))) == @import("builtin").TypeId.Pointer) @ptrCast(UINT, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT, 0) else UINT(0)) else if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT, 0) else UINT(0))) == @import("builtin").TypeId.Int) @intToPtr(UINT, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT, 0) else UINT(0)) else UINT(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT, 0) else UINT(0));
pub const JOY_CAL_READXYONLY = @as(c_long, 131072);
pub const FW_SEMIBOLD = 600;
pub const KP_PRECOMP_SHA = 25;
pub const FAST_FAIL_UNEXPECTED_HEAP_EXCEPTION = 35;
pub const SUBLANG_TELUGU_INDIA = 1;
pub const EM_GETHANDLE = 189;
pub const EADDRNOTAVAIL = 101;
pub const COLOR_3DHIGHLIGHT = COLOR_BTNHIGHLIGHT;
pub const NCRYPT_IMPL_VIRTUAL_ISOLATION_FLAG = 32;
pub const IN_CLASSB_NET = 4294901760;
pub const PSN_SETACTIVE = if (@typeId(@typeOf(-0)) == @import("builtin").TypeId.Pointer) @ptrCast(PSN_FIRST, -0) else if (@typeId(@typeOf(-0)) == @import("builtin").TypeId.Int) @intToPtr(PSN_FIRST, -0) else PSN_FIRST(-0);
pub const LOCALE_SISO639LANGNAME2 = 103;
pub const edt11 = 1162;
pub const ERROR_ACCOUNT_EXPIRED = @as(c_long, 1793);
pub const SPI_GETBORDER = 5;
pub const szOID_KP_KEY_RECOVERY = "1.3.6.1.4.1.311.10.3.11";
pub const TAPE_LOAD = @as(c_long, 0);
pub const ARW_BOTTOMLEFT = @as(c_long, 0);
pub const GlobalFindAtom = GlobalFindAtomA;
pub const _WIN32_IE_WIN8 = _WIN32_IE_IE100;
pub const ERROR_CLUSTER_GROUP_BUSY = @as(c_long, 5944);
pub const FILE_DEVICE_WAVE_OUT = 38;
pub const CMSG_VERIFY_COUNTER_SIGN_ENABLE_STRONG_FLAG = 1;
pub const ERROR_BADSTARTPOSITION = @as(c_long, 778);
pub const TRANSPORT_TYPE_CN = 1;
pub const HCBT_KEYSKIPPED = 7;
pub const MCI_ANIM_GETDEVCAPS_NORMAL_RATE = @as(c_long, 16388);
pub const DCBA_FACEUPNONE = 0;
pub const ERROR_CLUSTER_DISK_NOT_CONNECTED = @as(c_long, 5963);
pub const SERVICE_CONTROL_PARAMCHANGE = 6;
pub const ERROR_OPEN_FILES = @as(c_long, 2401);
pub const DOMAIN_ALIAS_RID_REPLICATOR = @as(c_long, 552);
pub const GetMessage = GetMessageA;
pub const CS_INSERTCHAR = 8192;
pub const CTRY_JORDAN = 962;
pub const _Function_ignore_lock_checking_ = lock;
pub const ERROR_DS_REMOTE_CROSSREF_OP_FAILED = @as(c_long, 8601);
pub const PROV_EC_ECNRA_SIG = 15;
pub const ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT = @as(c_long, 6811);
pub const PERF_QUERY_OBJECTS = if (@typeId(@typeOf(2147483648)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG, 2147483648) else if (@typeId(@typeOf(2147483648)) == @import("builtin").TypeId.Int) @intToPtr(LONG, 2147483648) else LONG(2147483648);
pub const DM_ICMINTENT = @as(c_long, 16777216);
pub const SEE_MASK_NOASYNC = 256;
pub const LR_DEFAULTCOLOR = 0;
pub const VIF_CANNOTREADSRC = @as(c_long, 65536);
pub const PROCESS_DUP_HANDLE = 64;
pub const BCRYPT_SUPPORTED_PAD_PKCS1_SIG = 4;
pub const PSINJECT_COMMENTS = 11;
pub const GetEnvironmentVariable = GetEnvironmentVariableA;
pub const CRYPT_MODE_CBC = 1;
pub const ERROR_CAPAUTHZ_DB_CORRUPTED = @as(c_long, 455);
pub const szOID_PIN_RULES_SIGNER = "1.3.6.1.4.1.311.10.3.31";
pub const APPCOMMAND_MEDIA_FAST_FORWARD = 49;
pub const DT_DISPFILE = 6;
pub const EXT_DEVICE_CAPS = 4099;
pub const PF_INET = AF_INET;
pub const TIMESTAMP_FAILURE_BAD_REQUEST = 2;
pub const DEVICEFAMILYDEVICEFORM_GAMING = 17;
pub const WSA_QOS_ESDMODEOBJ = @as(c_long, 11029);
pub const TPM_NONOTIFY = @as(c_long, 128);
pub const JOB_CONTROL_SENT_TO_PRINTER = 6;
pub const AF_IMPLINK = 3;
pub const __DBL_DIG__ = 15;
pub const szOID_PKCS_12_LOCAL_KEY_ID = "1.2.840.113549.1.9.21";
pub const MESSAGE_RESOURCE_UNICODE = 1;
pub const LOCALE_SABBREVDAYNAME5 = 53;
pub const URLACTION_CREDENTIALS_USE = 6656;
pub const ERROR_ALREADY_FIBER = @as(c_long, 1280);
pub const ENABLEDUPLEX = 28;
pub const ERROR_LOG_BLOCK_INVALID = @as(c_long, 6609);
pub const CERT_CHAIN_ENABLE_ONLY_WEAK_LOGGING_FLAG = 8;
pub const FILE_DEVICE_MIDI_OUT = 14;
pub const LMEM_MODIFY = 128;
pub const EISCONN = 113;
pub const RPCFLG_NON_NDR = @as(c_ulong, 2147483648);
pub const URLACTION_HTML_ALLOW_WINDOW_CLOSE = 5646;
pub const __VERSION__ = "4.2.1 Compatible Clang 8.0.0 (tags/RELEASE_800/rc5)";
pub const WM_SYSCOMMAND = 274;
pub const SE_RM_CONTROL_VALID = 16384;
pub const FORMAT_MESSAGE_IGNORE_INSERTS = 512;
pub const SSF_INDICATOR = 4;
pub const SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH = 4;
pub const SUBLANG_TIGRIGNA_ERITREA = 2;
pub const NIF_MESSAGE = 1;
pub const TIME_CALLBACK_EVENT_SET = 16;
pub const ERROR_INSTALL_LANGUAGE_UNSUPPORTED = @as(c_long, 1623);
pub const ERROR_INVALID_ACCOUNT_NAME = @as(c_long, 1315);
pub const CLIENTSITE_S_FIRST = @as(c_long, 262544);
pub const CMSG_OID_CNG_IMPORT_KEY_AGREE_FUNC = "CryptMsgDllCNGImportKeyAgree";
pub const szOID_ECC_CURVE_BRAINPOOLP384R1 = "1.3.36.3.3.2.8.1.1.11";
pub const REQUEST_OPLOCK_INPUT_FLAG_COMPLETE_ACK_ON_CLOSE = 4;
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_COUNT_MIN = 2;
pub const CERT_ID_ISSUER_SERIAL_NUMBER = 1;
pub const CERT_SEND_AS_TRUSTED_ISSUER_PROP_ID = 102;
pub const UISF_HIDEFOCUS = 1;
pub const CheckNameLegalDOS8Dot3 = CheckNameLegalDOS8Dot3A;
pub const SECURITY_DASHOST_ID_RID_COUNT = @as(c_long, 6);
pub const SPI_GETWINARRANGING = 130;
pub const PSPCB_RELEASE = 1;
pub const TIME_ZONE_ID_INVALID = if (@typeId(@typeOf(4294967295)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 4294967295) else if (@typeId(@typeOf(4294967295)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 4294967295) else DWORD(4294967295);
pub const JOB_NOTIFY_FIELD_STATUS = 10;
pub const ERROR_DS_LOW_ADLDS_FFL = @as(c_long, 8643);
pub const ERROR_DEVICE_ALREADY_REMEMBERED = @as(c_long, 1202);
pub const EMR_EXTTEXTOUTW = 84;
pub const PERF_DELTA_COUNTER = 4194304;
pub const BN_DOUBLECLICKED = 5;
pub const BAUD_57600 = if (@typeId(@typeOf(262144)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 262144) else if (@typeId(@typeOf(262144)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 262144) else DWORD(262144);
pub const SM_SWAPBUTTON = 23;
pub const PERF_MULTI_COUNTER = 33554432;
pub const MDM_MASK_BEARERMODE = 61440;
pub const TRUNCATE_EXISTING = 5;
pub const URLOpenPullStream = URLOpenPullStreamA;
pub const PERF_PRECISION_TIMESTAMP = PERF_LARGE_RAW_BASE;
pub const CRYPT_OCSP_ONLY_RETRIEVAL = 16777216;
pub const szOID_ECC_CURVE_BRAINPOOLP320R1 = "1.3.36.3.3.2.8.1.1.9";
pub const FILE_INITIATE_REPAIR_HINT1_SYSTEM_FILE = 16;
pub const SUBLANG_KAZAK_KAZAKHSTAN = 1;
pub const PROV_INTEL_SEC = 22;
pub const MF_HSZ_INFO = 16777216;
pub const WINSTA_WRITEATTRIBUTES = @as(c_long, 16);
pub const HELP_QUIT = @as(c_long, 2);
pub const PRODUCT_PPI_PRO = 119;
pub const WAVE_FORMAT_PCM = 1;
pub const ODDPARITY = 1;
pub const SET_SCREEN_ANGLE = 4105;
pub const SCardListCardTypes = SCardListCards;
pub const JOB_NOTIFY_FIELD_PRIORITY = 14;
pub const MOUSEWHEEL_ROUTING_FOCUS = 0;
pub const ERROR_BAD_CLUSTERS = @as(c_long, 6849);
pub const META_ARC = 2071;
pub const WNNC_NET_LOCUS = 393216;
pub const ERROR_LIBRARY_FULL = @as(c_long, 4322);
pub const RpcEpRegister = RpcEpRegisterA;
pub const InterlockedCompareExchange = _InterlockedCompareExchange;
pub const ERROR_CLOUD_FILE_ALREADY_CONNECTED = @as(c_long, 378);
pub const UISF_HIDEACCEL = 2;
pub const PARTITION_FAT_12 = 1;
pub const SUBLANG_NEPALI_INDIA = 2;
pub const TCP_BSDURGENT = 28672;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE = 63;
pub const XST_UNADVSENT = 12;
pub const CC_RGBINIT = 1;
pub const STOPBITS_15 = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(WORD, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(WORD, 2) else WORD(2);
pub const PD_EXCLUSIONFLAGS = 16777216;
pub const SND_ASYNC = 1;
pub const LANG_FULAH = 103;
pub const APPCOMMAND_MEDIA_NEXTTRACK = 11;
pub const WNNC_NET_SHIVA = 3342336;
pub const TT_PRIM_QSPLINE = 2;
pub const MEM_4MB_PAGES = 2147483648;
pub const ERROR_INSTALL_SERVICE_SAFEBOOT = @as(c_long, 1652);
pub const APPCOMMAND_BROWSER_FORWARD = 2;
pub const IME_ITHOTKEY_PREVIOUS_COMPOSITION = 513;
pub const PSH_NOCONTEXTHELP = 33554432;
pub const PSD_INHUNDREDTHSOFMILLIMETERS = 8;
pub const IGIMII_CONFIGURE = 4;
pub const PFD_OVERLAY_PLANE = 1;
pub const VK_F19 = 130;
pub const SUBLANG_ENGLISH_ZIMBABWE = 12;
pub const IME_CMODE_NATIVE = 1;
pub const ERROR_IPSEC_IKE_MM_ACQUIRE_DROP = @as(c_long, 13809);
pub const EXCEPTION_GUARD_PAGE = STATUS_GUARD_PAGE_VIOLATION;
pub const PRODUCT_PROFESSIONAL_EMBEDDED = 58;
pub const URLACTION_HTML_JAVA_RUN = 5637;
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_PARENT = 8388608;
pub const ERROR_INVALID_FORM_SIZE = @as(c_long, 1903);
pub const CTRY_GEORGIA = 995;
pub const PORT_STATUS_POWER_SAVE = 12;
pub const SERVICE_CONFIG_PRESHUTDOWN_INFO = 7;
pub const SERVICE_STOP_REASON_MINOR_MAINTENANCE = 2;
pub const TC_PUBLIC_DEVICEDUMP_CONTENT_GPLOG_MAX = 16;
pub const edt10 = 1161;
pub const DC_PRINTRATEUNIT = 27;
pub const PRINTER_STATUS_SERVER_OFFLINE = 33554432;
pub const ERROR_CONTROL_ID_NOT_FOUND = @as(c_long, 1421);
pub const CTRY_TRINIDAD_Y_TOBAGO = 1;
pub const SKF_LALTLOCKED = 1048576;
pub const ERROR_EVT_MALFORMED_XML_TEXT = @as(c_long, 15008);
pub const ERROR_WMI_SERVER_UNAVAILABLE = @as(c_long, 4208);
pub const CDS_FULLSCREEN = 4;
pub const VARCMP_EQ = 1;
pub const CTRY_GUATEMALA = 502;
pub const CREATE_FOR_IMPORT = 1;
pub const CERT_SET_PROPERTY_IGNORE_PERSIST_ERROR_FLAG = 2147483648;
pub const PRINTER_DRIVER_PACKAGE_AWARE = 1;
pub const IME_REGWORD_STYLE_EUDC = 1;
pub const NCBDGRECVBC = 35;
pub const IMAGE_REL_AMD64_REL32_1 = 5;
pub const X509_CROSS_CERT_DIST_POINTS = if (@typeId(@typeOf(58)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 58) else if (@typeId(@typeOf(58)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 58) else LPCSTR(58);
pub const GUI_INMENUMODE = 4;
pub const DOMAIN_USER_RID_DEFAULT_ACCOUNT = @as(c_long, 503);
pub const BCRYPT_HMAC_MD2_ALG_HANDLE = if (@typeId(@typeOf(289)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 289) else if (@typeId(@typeOf(289)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 289) else BCRYPT_ALG_HANDLE(289);
pub const BM_GETSTATE = 242;
pub const ERROR_SXS_DUPLICATE_ASSEMBLY_NAME = @as(c_long, 14027);
pub const DMPAPER_CSHEET = 24;
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MISMATCH_WARNING = 2;
pub const SM_DIGITIZER = 94;
pub const CreateDialogParam = CreateDialogParamA;
pub const ERROR_CANNOT_IMPERSONATE = @as(c_long, 1368);
pub const SPI_SETTOOLTIPFADE = 4121;
pub const ERROR_UNEXPECTED_MM_CREATE_ERR = @as(c_long, 556);
pub const WM_DROPFILES = 563;
pub const ERROR_CLUSTER_NO_QUORUM = @as(c_long, 5925);
pub const PRINTER_ATTRIBUTE_PER_USER = 4194304;
pub const ISC_SHOWUIALL = 3221225487;
pub const CHANGER_VOLUME_SEARCH = 2097152;
pub const SERVICES_ACTIVE_DATABASEA = "ServicesActive";
pub const CRYPT_FLAG_SSL3 = 4;
pub const SUBLANG_VALENCIAN_VALENCIA = 2;
pub const GCL_REVERSECONVERSION = 2;
pub const WSAEPROCLIM = @as(c_long, 10067);
pub const VarBstrFromInt = VarBstrFromI4;
pub const MB_ICONINFORMATION = MB_ICONASTERISK;
pub const __UINT_LEAST64_FMTu__ = "llu";
pub const __INT_FAST64_FMTd__ = "lld";
pub const SERVICE_CONTROL_NETBINDENABLE = 9;
pub const SCARD_STATE_UNPOWERED = 1024;
pub const SECURITY_MANDATORY_PROTECTED_PROCESS_RID = @as(c_long, 20480);
pub const X3_BTYPE_QP_INST_WORD_X = 2;
pub const __UINT_LEAST8_FMTx__ = "hhx";
pub const RI_MOUSE_LEFT_BUTTON_DOWN = 1;
pub const cmb14 = 1149;
pub const DC_FIELDS = 1;
pub const STORAGE_ATTRIBUTE_DYNAMIC_PERSISTENCE = 4;
pub const GetSystemDirectory = GetSystemDirectoryA;
pub const FILE_FLAG_OPEN_NO_RECALL = 1048576;
pub const TT_PRIM_LINE = 1;
pub const PFD_NEED_SYSTEM_PALETTE = 256;
pub const FILE_DEVICE_MASS_STORAGE = 45;
pub const WSAENAMETOOLONG = @as(c_long, 10063);
pub const CERT_FIND_ISSUER_OF = CERT_COMPARE_ISSUER_OF << CERT_COMPARE_SHIFT;
pub const ERROR_LOG_CONTAINER_READ_FAILED = @as(c_long, 6639);
pub const ERROR_PACKAGED_SERVICE_REQUIRES_ADMIN_PRIVILEGES = @as(c_long, 15656);
pub const SKF_AUDIBLEFEEDBACK = 64;
pub const ERROR_IPSEC_IKE_ERROR = @as(c_long, 13816);
pub const edt8 = 1159;
pub const OLDFONTENUMPROC = OLDFONTENUMPROCA;
pub const ERROR_USER_APC = @as(c_long, 737);
pub const ERROR_IPSEC_MM_POLICY_PENDING_DELETION = @as(c_long, 13021);
pub const sys_errlist = _sys_errlist;
pub const CMSG_HASH_ALGORITHM_PARAM = 20;
pub const IID_IOInetProtocolSinkStackable = IID_IInternetProtocolSinkStackable;
pub const InterlockedBitTestAndSet64Release = _interlockedbittestandset64;
pub const MDM_X75_DATA_128K = 2;
pub const SC_NEXTWINDOW = 61504;
pub const RPC_C_AUTHZ_NAME = 1;
pub const CRL_FIND_ISSUED_FOR = 3;
pub const ACCESS_DENIED_CALLBACK_ACE_TYPE = 10;
pub const ERROR_NO_EFS = @as(c_long, 6004);
pub const SUBLANG_LAO_LAO = 1;
pub const PRINTER_STATUS_DRIVER_UPDATE_NEEDED = 67108864;
pub const SHGetNewLinkInfo = SHGetNewLinkInfoA;
pub const GetSystemWindowsDirectory = GetSystemWindowsDirectoryA;
pub const ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER = @as(c_long, 8519);
pub const LPOPENCARDNAME_W = LPOPENCARDNAMEW;
pub const GET_FEATURE_FROM_THREAD_LOCALMACHINE = 8;
pub const CreateMDIWindow = CreateMDIWindowA;
pub const RDW_INTERNALPAINT = 2;
pub const ERROR_PORT_UNREACHABLE = @as(c_long, 1234);
pub const WNetGetUser = WNetGetUserA;
pub const DlgDirListComboBox = DlgDirListComboBoxA;
pub const GetPrinterDriverDirectory = GetPrinterDriverDirectoryA;
pub const ERROR_DS_CANT_FIND_NC_IN_CACHE = @as(c_long, 8421);
pub const CERT_STORE_CTL_CONTEXT = 3;
pub const ERROR_CONNECTION_REFUSED = @as(c_long, 1225);
pub const ERROR_VOLSNAP_PREPARE_HIBERNATE = @as(c_long, 655);
pub const ERROR_TS_INCOMPATIBLE_SESSIONS = @as(c_long, 7069);
pub const ERROR_APP_DATA_EXPIRED = @as(c_long, 4401);
pub const DC_NUP = 33;
pub const SPI_GETDISABLEOVERLAPPEDCONTENT = 4160;
pub const FillConsoleOutputCharacter = FillConsoleOutputCharacterA;
pub const PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_PREFER_SYSTEM32_ALWAYS_OFF = if (@typeId(@typeOf(i64 << 60)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 2), i64 << 60) else if (@typeId(@typeOf(i64 << 60)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 2), i64 << 60) else @as(c_uint, 2)(i64 << 60);
pub const ERROR_USER_MAPPED_FILE = @as(c_long, 1224);
pub const ERROR_DS_INVALID_LDAP_DISPLAY_NAME = @as(c_long, 8479);
pub const WIN31_CLASS = NULL;
pub const GetPrivateProfileStruct = GetPrivateProfileStructA;
pub const SS_RIGHT = @as(c_long, 2);
pub const URLACTION_COOKIES_SESSION_THIRD_PARTY = 6662;
pub const MKF_INDICATOR = 32;
pub const FACILITY_DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT = 272;
pub const TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CERT = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 4) else LPCSTR(4);
pub const MDM_HDLCPPP_AUTH_MSCHAP = 4;
pub const SND_SYNC = 0;
pub const PDCAP_WAKE_FROM_D1_SUPPORTED = 32;
pub const UOI_TIMERPROC_EXCEPTION_SUPPRESSION = 7;
pub const VOS__WINDOWS16 = @as(c_long, 1);
pub const FILE_SUPPORTS_EXTENDED_ATTRIBUTES = 8388608;
pub const RPC_INTERFACE_HAS_PIPES = 1;
pub const CTRY_CANADA = 2;
pub const TRANSACTION_MANAGER_COMMIT_DEFAULT = 0;
pub const PARITY_SPACE = if (@typeId(@typeOf(4096)) == @import("builtin").TypeId.Pointer) @ptrCast(WORD, 4096) else if (@typeId(@typeOf(4096)) == @import("builtin").TypeId.Int) @intToPtr(WORD, 4096) else WORD(4096);
pub const ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION = 4;
pub const POWERBUTTON_ACTION_VALUE_NOTHING = 0;
pub const ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES = 9;
pub const __LDBL_MIN_10_EXP__ = -307;
pub const RPC_C_RPCHTTP_USE_LOAD_BALANCE = 8;
pub const szOID_NETSCAPE = "2.16.840.1.113730";
pub const ERROR_CLUSTER_NODE_ALREADY_DOWN = @as(c_long, 5062);
pub const PBT_APMQUERYSTANDBY = 1;
pub const ACCESS_MAX_MS_V4_ACE_TYPE = 8;
pub const EFS_EFS_SUBVER_EFS_CERT = 1;
pub const ERROR_DS_DOMAIN_VERSION_TOO_LOW = @as(c_long, 8566);
pub const ERROR_SMB_GUEST_LOGON_BLOCKED = @as(c_long, 1272);
pub const InterlockedDecrementNoFence = _InterlockedDecrement;
pub const TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY = 16;
pub const CALLBACK_TASK = @as(c_long, 131072);
pub const LCMAP_SIMPLIFIED_CHINESE = 33554432;
pub const szOID_OIWSEC_desCBC = "1.3.14.3.2.7";
pub const DIAGNOSTIC_REASON_DETAILED_STRING = 2;
pub const MMIOM_USER = 32768;
pub const CONSOLE_FULLSCREEN_HARDWARE = 2;
pub const TOUCHEVENTF_PALM = 128;
pub const DLGC_WANTTAB = 2;
pub const LPCPROPSHEETPAGE_V4 = LPCPROPSHEETPAGEA_V4;
pub const __clang__ = 1;
pub const VOS_DOS_WINDOWS16 = @as(c_long, 65537);
pub const IMAGE_REL_IA64_UREL32 = 20;
pub const LANG_CHINESE = 4;
pub const FAST_FAIL_INVALID_ARG = 5;
pub const FACILITY_XAML = 43;
pub const SHTDN_REASON_MINOR_DC_PROMOTION = 33;
pub const ALG_TYPE_ANY = 0;
pub const XSTATE_MPX_BNDREGS = 3;
pub const FACILITY_VISUALCPP = 109;
pub const ERROR_MESSAGE_EXCEEDS_MAX_SIZE = @as(c_long, 4336);
pub const OUT_STROKE_PRECIS = 3;
pub const LookupAccountNameLocal = LookupAccountNameLocalA;
pub const DNS_ERROR_RCODE_BADTIME = @as(c_long, 9018);
pub const MM_ANISOTROPIC = 8;
pub const VarUintFromI2 = VarUI4FromI2;
pub const CRYPT_OVERRIDE = 65536;
pub const FACILITY_WINDOWS_CE = 24;
pub const CRYPT_FLAG_SSL2 = 2;
pub const szOID_EV_WHQL_CRYPTO = "1.3.6.1.4.1.311.10.3.39";
pub const STORAGE_ATTRIBUTE_BYTE_ADDRESSABLE_IO = 1;
pub const WNNC_NET_LIFENET = 917504;
pub const GetFileSecurity = GetFileSecurityA;
pub const IMAGE_SYM_TYPE_UNION = 9;
pub const DecryptFile = DecryptFileA;
pub const ERROR_WIP_ENCRYPTION_FAILED = @as(c_long, 6023);
pub const EM_GETLINECOUNT = 186;
pub const szOID_CMC_DATA_RETURN = "1.3.6.1.5.5.7.7.4";
pub const WS_TABSTOP = @as(c_long, 65536);
pub const IMAGE_ARCHIVE_START = "!<arch>\n";
pub const PAN_STROKEVARIATION_INDEX = 5;
pub const DT_TOP = 0;
pub const __FINITE_MATH_ONLY__ = 0;
pub const IMAGE_REL_BASED_ABSOLUTE = 0;
pub const RPC_X_SS_CONTEXT_MISMATCH = ERROR_INVALID_HANDLE;
pub const ERROR_COULD_NOT_RESIZE_LOG = @as(c_long, 6629);
pub const SECURITY_PACKAGE_DIGEST_RID = @as(c_long, 21);
pub const TXFS_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE = 64;
pub const TAPE_PSEUDO_LOGICAL_POSITION = @as(c_long, 2);
pub const PRINTER_CHANGE_ADD_PORT = 1048576;
pub const JOB_OBJECT_LIMIT_JOB_TIME = 4;
pub const CERT_ALT_NAME_EDI_PARTY_NAME = 6;
pub const WSASERVICE_NOT_FOUND = @as(c_long, 10108);
pub const PIDSI_TEMPLATE = @as(c_long, 7);
pub const cmb15 = 1150;
pub const RPC_C_AUTHN_WINNT = 10;
pub const WM_SIZECLIPBOARD = 779;
pub const JOB_CONTROL_RESUME = 2;
pub const ERROR_ACCESS_AUDIT_BY_POLICY = @as(c_long, 785);
pub const InterlockedCompareExchangePointerAcquire = _InterlockedCompareExchangePointer;
pub const PPCAPS_LEFT_THEN_DOWN = 1 << 2;
pub const RPC_S_TYPE_ALREADY_REGISTERED = @as(c_long, 1712);
pub const CTRY_ARMENIA = 374;
pub const FMFD_SERVERMIME = 8;
pub const edt9 = 1160;
pub const MIXER_GETLINEINFOF_DESTINATION = @as(c_long, 0);
pub const SS_LEFTNOWORDWRAP = @as(c_long, 12);
pub const ERROR_PAGEFILE_QUOTA_EXCEEDED = @as(c_long, 567);
pub const ECHILD = 10;
pub const NCRYPT_MAX_KEY_NAME_LENGTH = 512;
pub const LOCALE_NAME_MAX_LENGTH = 85;
pub const WNNC_NET_STAC = 2752512;
pub const CTLCOLOR_DLG = 4;
pub const SPI_GETKEYBOARDSPEED = 10;
pub const ERROR_SXS_MULTIPLE_DEACTIVATION = @as(c_long, 14086);
pub const _IRQL_requires_max_ = irql;
pub const IMAGE_SYM_CLASS_BIT_FIELD = 18;
pub const ERROR_PASSWORD_CHANGE_REQUIRED = @as(c_long, 1938);
pub const ERROR_NO_MORE_MATCHES = @as(c_long, 626);
pub const FD_READ = 1;
pub const VarUintFromDec = VarUI4FromDec;
pub const MDM_MASK_AUTO_SPEED = 7;
pub const X3_OPCODE_SIGN_VAL_POS_X = 0;
pub const _Analysis_assume_nullterminated_ = x;
pub const RPC_C_HTTP_AUTHN_SCHEME_CERT = 65536;
pub const RUSSIAN_CHARSET = 204;
pub const ERROR_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE = @as(c_long, 365);
pub const SORT_KOREAN_KSC = 0;
pub const SPI_SETSCREENSAVETIMEOUT = 15;
pub const ENXIO = 6;
pub const COLOR_WINDOWTEXT = 8;
pub const GCPCLASS_LATINNUMERICSEPARATOR = 7;
pub const CMSG_CERT_PARAM = 12;
pub const LOCKFILE_EXCLUSIVE_LOCK = 2;
pub const SUBLANG_CATALAN_CATALAN = 1;
pub const ERROR_NOT_GUI_PROCESS = @as(c_long, 1471);
pub const ISMEX_CALLBACK = 4;
pub const RPC_C_AUTHN_LIVEXP_SSP = 35;
pub const STGM_CREATE = @as(c_long, 4096);
pub const DM_POSITION = @as(c_long, 32);
pub const WM_MBUTTONDBLCLK = 521;
pub const CRYPT_OID_OPEN_SYSTEM_STORE_PROV_FUNC = "CertDllOpenSystemStoreProv";
pub const ERROR_STATE_DELETE_SETTING_FAILED = @as(c_long, 15809);
pub const SIMPLEREGION = 2;
pub const CERT_ALT_NAME_OTHER_NAME = 1;
pub const FACILITY_WEP = 2049;
pub const CONNDLG_PERSIST = 16;
pub const SM_SLOWMACHINE = 73;
pub const URLACTION_SHELL_FILE_DOWNLOAD = 6147;
pub const RESOURCETYPE_UNKNOWN = 4294967295;
pub const PRINTER_ENUM_LOCAL = 2;
pub const MMIO_EXCLUSIVE = 16;
pub const SEC_PARTITION_OWNER_HANDLE = 262144;
pub const MHDR_INQUEUE = 4;
pub const CC_ENABLEHOOK = 16;
pub const FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192;
pub const RegDeleteKeyValue = RegDeleteKeyValueA;
pub const ERROR_NOT_DOS_DISK = @as(c_long, 26);
pub const X509_MULTI_BYTE_UINT = if (@typeId(@typeOf(38)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 38) else if (@typeId(@typeOf(38)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 38) else LPCSTR(38);
pub const PF_OSI = AF_OSI;
pub const RECOVERED_WRITES_VALID = 1;
pub const RPC_QUERY_SERVER_PRINCIPAL_NAME = 2;
pub const URLACTION_BEHAVIOR_RUN = 8192;
pub const IMAGE_SYM_CLASS_NULL = 0;
pub const URLACTION_HTML_SUBFRAME_NAVIGATE = 5639;
pub const edt16 = 1167;
pub const ERROR_SYSTEM_INTEGRITY_TOO_MANY_POLICIES = @as(c_long, 4554);
pub const ISMEX_REPLIED = 8;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_SAMPLETIME = 8;
pub const CRYPTPROTECT_PROMPT_ON_PROTECT = 2;
pub const PROTECTED_SACL_SECURITY_INFORMATION = @as(c_long, 1073741824);
pub const CRYPT_EXT_OR_ATTR_OID_GROUP_ID = 6;
pub const EXCEPTION_UNWINDING = 2;
pub const TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT = 512;
pub const ERROR = 0;
pub const SO_SNDBUF = 4097;
pub const RPC_S_GRP_ELT_NOT_ADDED = @as(c_long, 1928);
pub const WM_IME_SETCONTEXT = 641;
pub const IMAGE_REL_AMD64_REL32_3 = 7;
pub const PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_DEFER = if (@typeId(@typeOf(i64 << 32)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), i64 << 32) else if (@typeId(@typeOf(i64 << 32)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), i64 << 32) else @as(c_uint, 0)(i64 << 32);
pub const MDM_AUTO_ML_NONE = 1;
pub const SPI_SETLOWPOWERTIMEOUT = 81;
pub const LPD_DOUBLEBUFFER = 1;
pub const CERT_RDN_FORCE_UTF8_UNICODE_FLAG = 268435456;
pub const CMSG_UNPROTECTED_ATTR_PARAM = 37;
pub const STARTF_USESTDHANDLES = 256;
pub const szOID_NIST_AES256_CBC = "2.16.840.1.101.3.4.1.42";
pub const CFSTR_MIME_JPEG = if (@typeId(@typeOf("image/jpeg")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "image/jpeg") else if (@typeId(@typeOf("image/jpeg")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "image/jpeg") else TEXT("image/jpeg");
pub const UuidToString = UuidToStringA;
pub const CERT_COMPARE_PUBLIC_KEY = 6;
pub const WM_CTLCOLORBTN = 309;
pub const ERROR_DEVICE_NOT_AVAILABLE = @as(c_long, 4319);
pub const MOD_WIN = 8;
pub const MCI_WAVE_SET_AVGBYTESPERSEC = @as(c_long, 524288);
pub const PRODUCT_NANO_SERVER = 109;
pub const ERROR_RECOVERY_FILE_CORRUPT = @as(c_long, 15619);
pub const QUERY_FILE_LAYOUT_INCLUDE_EXTRA_INFO = 16;
pub const N_BTSHFT = 4;
pub const GC_PAN_WITH_SINGLE_FINGER_HORIZONTALLY = 4;
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT = 2;
pub const CRYPTPROTECT_NO_RECOVERY = 32;
pub const ERROR_NO_LOGON_SERVERS = @as(c_long, 1311);
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SA = @as(c_long, 13830);
pub const DIAGNOSTIC_REASON_VERSION = 0;
pub const _WIN32_IE_WINTHRESHOLD = _WIN32_IE_IE110;
pub const ERROR_DEVICE_UNREACHABLE = @as(c_long, 321);
pub const ERROR_INVALID_DOMAIN_ROLE = @as(c_long, 1354);
pub const ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION = @as(c_long, 1459);
pub const WM_COMPAREITEM = 57;
pub const CERT_CHAIN_ENABLE_PEER_TRUST = 1024;
pub const ERROR_IPSEC_IKE_INVALID_PAYLOAD = @as(c_long, 13843);
pub const ULONG_MAX = @as(c_ulong, 4294967295);
pub const szOID_CMC_IDENTITY_PROOF = "1.3.6.1.5.5.7.7.3";
pub const IMAGE_SYM_CLASS_MEMBER_OF_STRUCT = 8;
pub const EMR_FRAMERGN = 72;
pub const GetTextFace = GetTextFaceA;
pub const cmb16 = 1151;
pub const MCI_SEQ_STATUS_OFFSET = @as(c_long, 16393);
pub const CRYPT_VERIFY_CERT_SIGN_DISABLE_MD2_MD4_FLAG = 1;
pub const SUBLANG_FRENCH_SWISS = 4;
pub const NTDDI_WIN10_TH2 = 167772161;
pub const FRS_ERR_SYSVOL_POPULATE = @as(c_long, 8013);
pub const ERROR_PNP_TRANSLATION_FAILED = @as(c_long, 672);
pub const MM_WIM_DATA = 960;
pub const CRYPT_RC2_40BIT_VERSION = 160;
pub const CERT_ALT_NAME_REGISTERED_ID = 9;
pub const BM_CLICK = 245;
pub const LBS_MULTIPLESEL = @as(c_long, 8);
pub const ERROR_DS_NO_SERVER_OBJECT = @as(c_long, 8622);
pub const LOCALE_IMONLZERO = 39;
pub const SERVICE_FILE_SYSTEM_DRIVER = 2;
pub const CERT_CHAIN_POLICY_ALLOW_TESTROOT_FLAG = 32768;
pub const CMSG_ENCRYPTED = 6;
pub const EBADF = 9;
pub const EVENT_SYSTEM_SOUND = 1;
pub const TPM_VERPOSANIMATION = @as(c_long, 4096);
pub const InterlockedAndAcquire = _InterlockedAnd;
pub const LTGRAY_BRUSH = 1;
pub const szOID_POSTAL_ADDRESS = "2.5.4.16";
pub const mciSendCommand = mciSendCommandA;
pub const DMPAPER_PENV_1_ROTATED = 109;
pub const ERROR_DS_REFERRAL = @as(c_long, 8235);
pub const CreateDesktopEx = CreateDesktopExA;
pub const WHDR_INQUEUE = 16;
pub const CRYPT_MATCH_ANY_ENCODING_TYPE = 4294967295;
pub const VkKeyScan = VkKeyScanA;
pub const PSWIZB_SHOW = 0;
pub const ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH = @as(c_long, 5895);
pub const REG_RESOURCE_LIST = @as(c_ulong, 8);
pub const FILE_READ_ONLY_VOLUME = 524288;
pub const SECURITY_AUTHENTICATED_USER_RID = @as(c_long, 11);
pub const InterlockedOr16 = _InterlockedOr16;
pub const VP_CP_TYPE_APS_TRIGGER = 1;
pub const ERROR_IPSEC_IKE_RPC_DELETE = @as(c_long, 13877);
pub const CTRY_NEW_ZEALAND = 64;
pub const SS_NOPREFIX = @as(c_long, 128);
pub const CWP_SKIPINVISIBLE = 1;
pub const ERROR_CLUSTER_NOT_SHARED_VOLUME = @as(c_long, 5945);
pub const NCBCHAINSEND = 23;
pub const DNS_REQUEST_PENDING = @as(c_long, 9506);
pub const SM_XVIRTUALSCREEN = 76;
pub const WIM_PROVIDER_EXTERNAL_FLAG_SUSPENDED = 2;
pub const BACKGROUND_BLUE = 16;
pub const ERROR_IPSEC_IKE_SA_DELETED = @as(c_long, 13807);
pub const GetStartupInfo = GetStartupInfoA;
pub const SOUND_SYSTEM_INFORMATION = 7;
pub const HSHELL_ACCESSIBILITYSTATE = 11;
pub const XTYP_MASK = 240;
pub const DLGC_DEFPUSHBUTTON = 16;
pub const RPC_S_DO_NOT_DISTURB = @as(c_long, 1834);
pub const szOID_PKIX_NO_SIGNATURE = "1.3.6.1.5.5.7.6.2";
pub const SECURITY_WRITE_RESTRICTED_CODE_RID = @as(c_long, 33);
pub const IID_IOInetProtocolRoot = IID_IInternetProtocolRoot;
pub const VOLUME_UPGRADE_SCHEDULED = 2;
pub const RegSetKeyValue = RegSetKeyValueA;
pub const IOInetSession = IInternetSession;
pub const __INTMAX_FMTi__ = "lli";
pub const TMPF_VECTOR = 2;
pub const CharLower = CharLowerA;
pub const MCI_OVLY_GETDEVCAPS_MAX_WINDOWS = @as(c_long, 16387);
pub const DM_TTOPTION = @as(c_long, 16384);
pub const edt15 = 1166;
pub const FILE_FLAG_NO_BUFFERING = 536870912;
pub const SERVICE_STOP_REASON_MINOR_HUNG = 6;
pub const FILE_SPECIAL_ACCESS = FILE_ANY_ACCESS;
pub const WN_MORE_DATA = ERROR_MORE_DATA;
pub const CRYPT_FLAG_TLS1 = 8;
pub const DMPAPER_A4_TRANSVERSE = 55;
pub const AUXCAPS_VOLUME = 1;
pub const FACILITY_DIRECT3D12 = 2174;
pub const SE_ERR_NOASSOC = 31;
pub const IMAGE_REL_AMD64_REL32_2 = 6;
pub const PF_IPX = AF_IPX;
pub const PS_ALTERNATE = 8;
pub const GGO_GLYPH_INDEX = 128;
pub const FD_CLOSE = 32;
pub const PIDDI_THUMBNAIL = @as(c_long, 2);
pub const TC_UA_ABLE = 2048;
pub const RPC_C_VERS_ALL = 1;
pub const DEFAULT_CHARSET = 1;
pub const IPPROTO_IDP = 22;
pub const CTRY_ECUADOR = 593;
pub const szOID_SEE_ALSO = "2.5.4.34";
pub const szOID_PKIX_KP_IPSEC_END_SYSTEM = "1.3.6.1.5.5.7.3.5";
pub const PARAMFLAG_FOUT = 2;
pub const IID_IOInetSession = IID_IInternetSession;
pub const ERROR_DS_NO_CHAINED_EVAL = @as(c_long, 8328);
pub const CRL_REASON_CESSATION_OF_OPERATION = 5;
pub const SYSPAL_STATIC = 1;
pub const MIIM_SUBMENU = 4;
pub const WAVE_INVALIDFORMAT = 0;
pub const STGM_SIMPLE = @as(c_long, 134217728);
pub const __UINT8_MAX__ = 255;
pub const ERROR_NO_MEDIA_IN_DRIVE = @as(c_long, 1112);
pub const ERROR_IPSEC_IKE_DOS_COOKIE_SENT = @as(c_long, 13890);
pub const CRL_FIND_ANY = 0;
pub const IMAGE_SCN_TYPE_NO_PAD = 8;
pub const NRC_CMDCAN = 11;
pub const SUBLANG_ZULU_SOUTH_AFRICA = 1;
pub const IOCPARM_MASK = 127;
pub const WSAENOTCONN = @as(c_long, 10057);
pub const CDERR_LOADRESFAILURE = 7;
pub const SE_SACL_DEFAULTED = 32;
pub const URLACTION_ACTIVEX_NO_WEBOC_SCRIPT = 4614;
pub const IMAGE_WEAK_EXTERN_SEARCH_LIBRARY = 2;
pub const META_SETTEXTALIGN = 302;
pub const GW_OWNER = 4;
pub const CERT_STORE_PROV_SHARED_USER_FLAG = 64;
pub const LANG_LUXEMBOURGISH = 110;
pub const RRF_RT_REG_BINARY = 8;
pub const OFN_LONGNAMES = 2097152;
pub const LANG_UZBEK = 67;
pub const SERVICE_ADAPTER = 4;
pub const ERROR_BUFFER_ALL_ZEROS = @as(c_long, 754);
pub const URLACTION_ACTIVEX_OVERRIDE_DOMAINLIST = 4619;
pub const MCI_VD_PLAY_SLOW = @as(c_long, 1048576);
pub const TURKISH_CHARSET = 162;
pub const MCI_RECORD_OVERWRITE = @as(c_long, 512);
pub const MF_POSTMSGS = 67108864;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_INDEX = 268435456;
pub const LPCPROPSHEETPAGE = LPCPROPSHEETPAGEA;
pub const SPI_GETPOWEROFFTIMEOUT = 80;
pub const _GrouP_impl_ = annos;
pub const USN_REASON_OBJECT_ID_CHANGE = 524288;
pub const szOID_ROOT_PROGRAM_AUTO_UPDATE_CA_REVOCATION = "1.3.6.1.4.1.311.60.3.1";
pub const THREAD_BASE_PRIORITY_IDLE = -15;
pub const ERROR_NO_PAGEFILE = @as(c_long, 578);
pub const ERROR_ENVVAR_NOT_FOUND = @as(c_long, 203);
pub const RPC_S_OUT_OF_RESOURCES = @as(c_long, 1721);
pub const ERROR_HOOK_NEEDS_HMOD = @as(c_long, 1428);
pub const VK_HANGUL = 21;
pub const PWR_CRITICALRESUME = 3;
pub const DCX_WINDOW = @as(c_long, 1);
pub const ERROR_IPSEC_IKE_PROCESS_ERR_DELETE = @as(c_long, 13841);
pub const ERROR_CTX_LICENSE_EXPIRED = @as(c_long, 7056);
pub const CHAR_MIN = SCHAR_MIN;
pub const ERROR_SERVICE_CANNOT_ACCEPT_CTRL = @as(c_long, 1061);
pub const ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT = @as(c_long, 5903);
pub const WM_AFXFIRST = 864;
pub const PRODUCT_SMALLBUSINESS_SERVER = 9;
pub const PAN_BENT_ARMS_DOUBLE_SERIF = 11;
pub const JOB_POSITION_UNSPECIFIED = 0;
pub const szOID_OIWSEC_desECB = "1.3.14.3.2.6";
pub const FILE_UNICODE_ON_DISK = 4;
pub const LB_GETTEXT = 393;
pub const ERROR_IPSEC_AUTH_FIREWALL_DROP = @as(c_long, 13917);
pub const IMAGE_REL_IA64_SECREL22 = 12;
pub const META_ELLIPSE = 1048;
pub const WM_DDE_FIRST = 992;
pub const MUTEX_MODIFY_STATE = MUTANT_QUERY_STATE;
pub const szOID_IUM_SIGNING = "1.3.6.1.4.1.311.10.3.37";
pub const VFT2_FONT_TRUETYPE = @as(c_long, 3);
pub const RPC_S_NO_INTERFACES = @as(c_long, 1817);
pub const META_INTERSECTCLIPRECT = 1046;
pub const CERT_SELECT_IGNORE_AUTOSELECT = 256;
pub const CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE = 524288;
pub const REPLACEFILE_IGNORE_ACL_ERRORS = 4;
pub const EMR_CREATEPALETTE = 49;
pub const URLACTION_SHELL_EXECUTE_LOWRISK = 6152;
pub const WriteConsoleInput = WriteConsoleInputA;
pub const PARTITION_FAT_16 = 4;
pub const CONTEXT_OID_CAPI2_ANY = if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 5) else if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 5) else LPCSTR(5);
pub const CRYPT_DECRYPT_RSA_NO_PADDING_CHECK = 32;
pub const GetMenuItemInfo = GetMenuItemInfoA;
pub const CSV_NAMESPACE_INFO_V1 = if (@typeId(@typeOf(CSV_NAMESPACE_INFO)) == @import("builtin").TypeId.Pointer) @ptrCast(sizeof, CSV_NAMESPACE_INFO) else if (@typeId(@typeOf(CSV_NAMESPACE_INFO)) == @import("builtin").TypeId.Int) @intToPtr(sizeof, CSV_NAMESPACE_INFO) else sizeof(CSV_NAMESPACE_INFO);
pub const VALID_NTFT = 192;
pub const TOUCHINPUTMASKF_TIMEFROMSYSTEM = 1;
pub const FILE_DEVICE_CONTROLLER = 4;
pub const PROCESS_CREATION_MITIGATION_POLICY2_RESTRICT_INDIRECT_BRANCH_PREDICTION_MASK = if (@typeId(@typeOf(i64 << 16)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 16) else if (@typeId(@typeOf(i64 << 16)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 16) else @as(c_uint, 3)(i64 << 16);
pub const FACILITY_WER = 27;
pub const KLF_ACTIVATE = 1;
pub const PAN_MIDLINE_INDEX = 8;
pub const LC_WIDE = 16;
pub const RIDEV_NOLEGACY = 48;
pub const ENUMRESLANGPROC = ENUMRESLANGPROCA;
pub const __INT_LEAST8_FMTi__ = "hhi";
pub const APPCOMMAND_BASS_UP = 21;
pub const ERROR_RWRAW_ENCRYPTED_FILE_NOT_ENCRYPTED = @as(c_long, 410);
pub const _Maybevalid_ = _Maybevalid_impl_;
pub const DNS_ERROR_CNAME_COLLISION = @as(c_long, 9709);
pub const CERT_NO_AUTO_EXPIRE_CHECK_PROP_ID = 77;
pub const szOID_SUR_NAME = "2.5.4.4";
pub const IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG = 17;
pub const FILE_STORAGE_TIER_FLAG_PARITY = 8388608;
pub const SHUTDOWN_MOBILE_UI = 4096;
pub const PRNSETUPDLGORD = 1539;
pub const FACILITY_POWERSHELL = 84;
pub const EXCEPTION_ACCESS_VIOLATION = STATUS_ACCESS_VIOLATION;
pub const szOID_PKIX_KP_CODE_SIGNING = "1.3.6.1.5.5.7.3.3";
pub const edt14 = 1165;
pub const CRYPT_OID_INFO_NAME_KEY = 2;
pub const LPSERVICE_MAIN_FUNCTION = LPSERVICE_MAIN_FUNCTIONA;
pub const __RDSEED__ = 1;
pub const WM_MENUCHAR = 288;
pub const MAX_REASON_DESC_LEN = 256;
pub const CTRY_SAUDI_ARABIA = 966;
pub const CRYPT_OID_PUBKEY_ENCRYPT_ONLY_FLAG = 1073741824;
pub const __FSGSBASE__ = 1;
pub const BSF_NOHANG = 8;
pub const IMAGE_GUARD_RF_INSTRUMENTED = 131072;
pub const NRC_NAMTFUL = 14;
pub const STORAGE_EVENT_DEVICE_STATUS = 2;
pub const FILE_DISPOSITION_FLAG_POSIX_SEMANTICS = 2;
pub const STORAGE_TIER_FLAG_SMR = 16777216;
pub const MIXERCONTROL_CT_CLASS_SWITCH = @as(c_long, 536870912);
pub const RPC_C_AUTHZ_DEFAULT = 4294967295;
pub const DD_DEFSCROLLINTERVAL = 50;
pub const __DBL_DECIMAL_DIG__ = 17;
pub const BN_DISABLE = 4;
pub const IME_PROP_COMPLETE_ON_UNSELECT = 1048576;
pub const JOY_POVRIGHT = 9000;
pub const SEE_MASK_ASYNCOK = 1048576;
pub const NRC_ILLNN = 19;
pub const CMSG_CTRL_ADD_ATTR_CERT = 14;
pub const PRINTER_ENUM_CATEGORY_3D = 67108864;
pub const __LONG_MAX__ = @as(c_long, 2147483647);
pub const ERROR_CLUSTER_DATABASE_SEQMISMATCH = @as(c_long, 5083);
pub const EMARCH_ENC_I17_SIGN_INST_WORD_POS_X = 27;
pub const InterlockedAnd64NoFence = _InterlockedAnd64;
pub const WM_NCXBUTTONUP = 172;
pub const DMPAPER_RESERVED_48 = 48;
pub const ERROR_DS_CANT_START = @as(c_long, 8531);
pub const PF_CHAOS = AF_CHAOS;
pub const TCI_SRCFONTSIG = 3;
pub const VIF_SRCOLD = @as(c_long, 4);
pub const GetCurrentHwProfile = GetCurrentHwProfileA;
pub const AUTHTYPE_SERVER = 2;
pub const ERROR_CLUSTER_NODE_SHUTTING_DOWN = @as(c_long, 5073);
pub const JOB_OBJECT_UILIMIT_EXITWINDOWS = 128;
pub const __deref_out_ecount_nz_opt = size;
pub const TAPE_DRIVE_ERASE_BOP_ONLY = 64;
pub const FILE_DEVICE_EHSTOR = 70;
pub const EEXIST = 17;
pub const ERROR_INVALID_TASK_INDEX = @as(c_long, 1551);
pub const WM_MOVE = 3;
pub const WM_COMMNOTIFY = 68;
pub const PSINJECT_ENDPROLOG = 15;
pub const FAST_FAIL_INVALID_BUFFER_ACCESS = 28;
pub const cmb10 = 1145;
pub const ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED = @as(c_long, 5077);
pub const DEVICEFAMILYINFOENUM_WINDOWS_CORE = 16;
pub const __requires_exclusive_lock_held = lock;
pub const PIPE_READMODE_MESSAGE = 2;
pub const CRYPT_STRING_ANY = 7;
pub const IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT = 16384;
pub const SHUTDOWN_NOREBOOT = 16;
pub const CONTAINER_ROOT_INFO_FLAG_BIND_EXCEPTION_ROOT = 128;
pub const CRYPT_DECODE_ENABLE_UTF8PERCENT_FLAG = 67108864;
pub const DialogBoxParam = DialogBoxParamA;
pub const JOB_OBJECT_SECURITY_FILTER_TOKENS = 8;
pub const ERROR_INVALID_LIBRARY = @as(c_long, 4301);
pub const GB2312_CHARSET = 134;
pub const TT_POLYGON_TYPE = 24;
pub const ERROR_INVALID_MINALLOCSIZE = @as(c_long, 195);
pub const InstallPrinterDriverFromPackage = InstallPrinterDriverFromPackageA;
pub const EMR_SETWINDOWORGEX = 10;
pub const NRC_NOCALL = 20;
pub const IMAGE_REL_PPC_GPREL = 21;
pub const ERROR_SXS_FILE_HASH_MISSING = @as(c_long, 14110);
pub const PID_MODIFY_TIME = 2147483649;
pub const WN_NO_MORE_DEVICES = ERROR_NO_MORE_DEVICES;
pub const TRANSACTIONMANAGER_SET_INFORMATION = 2;
pub const CO_E_LAST = @as(c_long, 2147746303);
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_LCN = 4294967296;
pub const PAN_SERIF_OBTUSE_COVE = 3;
pub const PP_CONTEXT_INFO = 11;
pub const GL_LEVEL_INFORMATION = 4;
pub const NRC_DUPNAME = 13;
pub const LCID_SUPPORTED = 2;
pub const IMAGE_COMDAT_SELECT_NODUPLICATES = 1;
pub const InterlockedDecrement16 = _InterlockedDecrement16;
pub const CHANGER_STATUS_NON_VOLATILE = 16;
pub const SP_DATABITS = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 4) else DWORD(4);
pub const RESOURCEUSAGE_SIBLING = 8;
pub const MUTZ_REQUIRESAVEDFILECHECK = 1024;
pub const WSAECONNREFUSED = @as(c_long, 10061);
pub const ALG_SID_HMAC = 9;
pub const SERVICE_CONTROL_LOWRESOURCES = 96;
pub const _CRT_BUILD_DESKTOP_APP = 1;
pub const PF_SSE3_INSTRUCTIONS_AVAILABLE = 13;
pub const I_RpcBindingInqDynamicEndpoint = I_RpcBindingInqDynamicEndpointA;
pub const R2_XORPEN = 7;
pub const IMAGE_FILE_MACHINE_SH3DSP = 419;
pub const IMAGE_SYM_TYPE_MOE = 11;
pub const SUBLANG_SPANISH_VENEZUELA = 8;
pub const FILE_STORAGE_TIER_DESCRIPTION_LENGTH = 512;
pub const CERT_ROOT_PROGRAM_CERT_POLICIES_PROP_ID = 83;
pub const FILE_DEVICE_GPIO = 72;
pub const MMIO_FINDRIFF = 32;
pub const szOID_RSA_RC5_CBCPad = "1.2.840.113549.3.9";
pub const ERROR_PRI_MERGE_INVALID_FILE_NAME = @as(c_long, 15158);
pub const SND_ALIAS_START = 0;
pub const IMAGE_SYM_TYPE_STRUCT = 8;
pub const SC_RESTORE = 61728;
pub const PIDMSI_SOURCE = @as(c_long, 4);
pub const SSWF_TITLE = 1;
pub const APPCMD_MASK = @as(c_long, 4080);
pub const SUBLANG_FRENCH_MONACO = 6;
pub const FAST_FAIL_CERTIFICATION_FAILURE = 20;
pub const CTRY_UNITED_KINGDOM = 44;
pub const REG_WHOLE_HIVE_VOLATILE = @as(c_long, 1);
pub const RRF_WOW64_MASK = 196608;
pub const MCI_ANIM_WINDOW_TEXT = @as(c_long, 524288);
pub const _ARGMAX = 100;
pub const STORAGE_PROTOCOL_COMMAND_LENGTH_NVME = 64;
pub const TIMESTAMP_STATUS_GRANTED = 0;
pub const PROCESS_HEAP_UNCOMMITTED_RANGE = 2;
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_OCSP_BASIC_SIGNED_RESPONSE = 4;
pub const DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS = @as(c_long, 555);
pub const SETABORTPROC = 9;
pub const ERROR_RESOURCE_ONLINE = @as(c_long, 5019);
pub const SUBLANG_SWEDISH_FINLAND = 2;
pub const SYSPAL_NOSTATIC = 2;
pub const IMAGE_REL_SH3_PCREL12_WORD = 11;
pub const IMAGE_SCN_MEM_PRELOAD = 524288;
pub const ERROR_DS_SRC_NAME_MISMATCH = @as(c_long, 8484);
pub const __CRTDECL = __CLRCALL_PURE_OR_CDECL;
pub const CERT_STORE_DELETE_FLAG = 16;
pub const USAGE_MATCH_TYPE_AND = 0;
pub const TIMESTAMP_STATUS_GRANTED_WITH_MODS = 1;
pub const STDOLE_MAJORVERNUM = 1;
pub const FS_PERSISTENT_ACLS = FILE_PERSISTENT_ACLS;
pub const DMPAPER_B4_JIS_ROTATED = 79;
pub const CB_GETITEMDATA = 336;
pub const FACILITY_DIRECT3D10 = 2169;
pub const MEMORY_PRIORITY_LOW = 2;
pub const DEVICEFAMILYDEVICEFORM_KIOSK = 20;
pub const IME_CAND_RADICAL = 4;
pub const VS_FILE_INFO = RT_VERSION;
pub const RPC_C_PARM_MAX_PACKET_LENGTH = 1;
pub const AF_APPLETALK = 16;
pub const FILE_DEVICE_NETWORK_FILE_SYSTEM = 20;
pub const UPDP_UPLOAD_ALWAYS = 2;
pub const CERT_CREATE_CONTEXT_NOCOPY_FLAG = 1;
pub const CONNDLG_HIDE_BOX = 8;
pub const SND_APPLICATION = 128;
pub const APPCOMMAND_MICROPHONE_VOLUME_MUTE = 24;
pub const SID_SInternetHostSecurityManager = IID_IInternetHostSecurityManager;
pub const ERROR_SXS_XML_E_MISSINGSEMICOLON = @as(c_long, 14039);
pub const PIDSI_TITLE = @as(c_long, 2);
pub const SUBLANG_TURKISH_TURKEY = 1;
pub const ERROR_CLOUD_FILE_PROPERTY_LOCK_CONFLICT = @as(c_long, 397);
pub const DM_YRESOLUTION = @as(c_long, 8192);
pub const IMAGE_FILE_MACHINE_R10000 = 360;
pub const DMPAPER_B5_JIS_ROTATED = 80;
pub const IMAGE_REL_ARM64_BRANCH26 = 3;
pub const NRC_SABORT = 24;
pub const FAST_FAIL_RANGE_CHECK_FAILURE = 8;
pub const IMAGE_REL_PPC_SECREL = 11;
pub const ImmGetCompositionFont = ImmGetCompositionFontA;
pub const IO_REPARSE_TAG_RESERVED_RANGE = IO_REPARSE_TAG_RESERVED_TWO;
pub const CERT_NAME_STR_CRLF_FLAG = 134217728;
pub const DMPAPER_RESERVED_49 = 49;
pub const CFSTR_MIME_POSTSCRIPT = if (@typeId(@typeOf("application/postscript")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "application/postscript") else if (@typeId(@typeOf("application/postscript")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "application/postscript") else TEXT("application/postscript");
pub const TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY_FLAG_DELETED = 2;
pub const ERROR_CLIPBOARD_NOT_OPEN = @as(c_long, 1418);
pub const HEAP_CREATE_SEGMENT_HEAP = 256;
pub const MCI_STATUS_START = @as(c_long, 512);
pub const DRV_FREE = 6;
pub const SUBLANG_SINDHI_INDIA = 1;
pub const IMAGE_REL_SH3_DIRECT4_LONG = 8;
pub const CERT_QUERY_FORMAT_BINARY = 1;
pub const ERROR_DS_INIT_FAILURE = @as(c_long, 8532);
pub const ERROR_HOOK_NOT_INSTALLED = @as(c_long, 1431);
pub const DMPAPER_LEGAL = 5;
pub const __elem_writableTo = size;
pub const MIXER_SETCONTROLDETAILSF_CUSTOM = @as(c_long, 1);
pub const ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION = @as(c_long, 13020);
pub const IME_KHOTKEY_SHAPE_TOGGLE = 80;
pub const MF_STRING = @as(c_long, 0);
pub const PRODUCT_STORAGE_STANDARD_SERVER_CORE = 44;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_NONE_RID = @as(c_long, 0);
pub const cmb11 = 1146;
pub const WNetGetProviderName = WNetGetProviderNameA;
pub const EMR_POLYBEZIERTO = 5;
pub const LOGON32_LOGON_NEW_CREDENTIALS = 9;
pub const ERROR_ALREADY_RUNNING_LKG = @as(c_long, 1074);
pub const NCBDGSENDBC = 34;
pub const TIMERV_COALESCING_MIN = 1;
pub const WINEVENT_SKIPOWNTHREAD = 1;
pub const DNS_ERROR_NODE_IS_DNAME = @as(c_long, 9720);
pub const VER_GREATER = 2;
pub const SCARD_READER_TYPE_PARALELL = 2;
pub const URLACTION_FEATURE_MIN = 8448;
pub const MCI_OVLY_WHERE_SOURCE = @as(c_long, 131072);
pub const ERROR_INVALID_HOOK_HANDLE = @as(c_long, 1404);
pub const CBR_600 = 600;
pub const CRL_REASON_UNUSED_FLAG = 128;
pub const ERROR_EVT_FILTER_ALREADYSCOPED = @as(c_long, 15014);
pub const PAN_BENT_ARMS_VERT = 9;
pub const MFS_DISABLED = MFS_GRAYED;
pub const DISPID_CONSTRUCTOR = -6;
pub const PROCESSOR_PPC_604 = 604;
pub const WM_CLIPBOARDUPDATE = 797;
pub const BitScanForward = _BitScanForward;
pub const AUXCAPS_AUXIN = 2;
pub const IP_MULTICAST_IF = 2;
pub const PPM_IDLE_IMPLEMENTATION_LPISTATES = 4;
pub const SYSTEM_FONT = 13;
pub const SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA = 1;
pub const RGN_MIN = RGN_AND;
pub const OF_REOPEN = 32768;
pub const IOCTL_SCMBUS_DEVICE_FUNCTION_BASE = 0;
pub const SERVICE_STOP_REASON_MINOR_UPGRADE = 4;
pub const ERROR_SXS_DUPLICATE_PROGID = @as(c_long, 14026);
pub const ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY = @as(c_long, 13821);
pub const MIXER_GETLINEINFOF_SOURCE = @as(c_long, 1);
pub const CREATE_NEW_CONSOLE = 16;
pub const SETRTS = 3;
pub const SPI_GETSCREENSAVETIMEOUT = 14;
pub const szOID_PKCS_12_pbeWithSHA1And3KeyTripleDES = "1.2.840.113549.1.12.1.3";
pub const VarUintFromR8 = VarUI4FromR8;
pub const POWER_ACTION_LOCK_CONSOLE = 536870912;
pub const ERROR_SET_POWER_STATE_VETOED = @as(c_long, 1140);
pub const LOCALE_SPOSITIVESIGN = 80;
pub const STARTF_USEFILLATTRIBUTE = 16;
pub const ERROR_IS_JOINED = @as(c_long, 134);
pub const szOID_CMC_LRA_POP_WITNESS = "1.3.6.1.5.5.7.7.11";
pub const DOMAIN_GROUP_RID_AUTHORIZATION_DATA_CONTAINS_CLAIMS = @as(c_long, 497);
pub const FACILITY_METADIRECTORY = 35;
pub const ERROR_INVALID_WINDOW_HANDLE = @as(c_long, 1400);
pub const EVENT_SYSTEM_SWITCHER_APPOVERTARGET = 37;
pub const ERROR_SEGMENT_NOTIFICATION = @as(c_long, 702);
pub const SOL_SOCKET = 65535;
pub const SERVICE_USER_SERVICE = 64;
pub const ERROR_PNP_BAD_MPS_TABLE = @as(c_long, 671);
pub const MCI_SEEK_TO_START = @as(c_long, 256);
pub const URL_OID_CERTIFICATE_ONLY_OCSP = if (@typeId(@typeOf(13)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 13) else if (@typeId(@typeOf(13)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 13) else LPCSTR(13);
pub const STGFMT_DOCFILE = 5;
pub const RC_BITMAP64 = 8;
pub const PD_PRINTSETUP = 64;
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_CERT_COUNT_DEFAULT = 10;
pub const FO_COPY = 2;
pub const SECURITY_IDENTIFICATION = SecurityIdentification << 16;
pub const CDN_SELCHANGE = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(CDN_FIRST, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(CDN_FIRST, -1) else CDN_FIRST(-1);
pub const ERROR_DS_INVALID_ROLE_OWNER = @as(c_long, 8366);
pub const LB_GETLISTBOXINFO = 434;
pub const SPI_SETMINIMUMHITRADIUS = 8213;
pub const CLEARTYPE_NATURAL_QUALITY = 6;
pub const SM_CYICONSPACING = 39;
pub const CERT_KEY_ENCIPHERMENT_KEY_USAGE = 32;
pub const ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA = @as(c_long, 8306);
pub const FW_BOLD = 700;
pub const SIZE_MINIMIZED = 1;
pub const ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE = @as(c_long, 6017);
pub const CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE = 1;
pub const ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE = 2;
pub const SP_PARITY_CHECK = if (@typeId(@typeOf(32)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 32) else if (@typeId(@typeOf(32)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 32) else DWORD(32);
pub const META_OFFSETVIEWPORTORG = 529;
pub const FLUSH_FLAGS_FILE_DATA_SYNC_ONLY = 4;
pub const CERT_STORE_SIGNATURE_FLAG = 1;
pub const FACILITY_DIRECT3D11 = 2172;
pub const WN_NOT_VALIDATED = ERROR_NO_LOGON_SERVERS;
pub const LPCPROPSHEETPAGE_V1 = LPCPROPSHEETPAGEA_V1;
pub const IMAGE_REL_M32R_REFHALF = 8;
pub const GetWindowLongPtr = GetWindowLongPtrA;
pub const BroadcastSystemMessage = BroadcastSystemMessageA;
pub const EC_USEFONTINFO = 65535;
pub const DNS_ERROR_INVALID_DATA = ERROR_INVALID_DATA;
pub const InterlockedCompareExchangeRelease16 = _InterlockedCompareExchange16;
pub const CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG = 4;
pub const MCI_OVLY_PUT_SOURCE = @as(c_long, 131072);
pub const ERROR_PNP_RESTART_ENUMERATION = @as(c_long, 636);
pub const XTYPF_ACKREQ = 8;
pub const RPC_SYSTEM_HANDLE_FREE_RETRIEVED = 2;
pub const WIZ_BODYCX = 184;
pub const META_TEXTOUT = 1313;
pub const GESTUREVISUALIZATION_OFF = 0;
pub const NCRYPT_SHA384_ALGORITHM = BCRYPT_SHA384_ALGORITHM;
pub const ERROR_NO_PROMOTION_ACTIVE = @as(c_long, 8222);
pub const SHInvokePrinterCommand = SHInvokePrinterCommandA;
pub const szOID_PKIX_OCSP = "1.3.6.1.5.5.7.48.1";
pub const FILE_INITIATE_REPAIR_HINT1_REPAIR_DISABLED = 128;
pub const MARK_HANDLE_TXF_SYSTEM_LOG = 4;
pub const X509_PKIX_POLICY_QUALIFIER_USERNOTICE = if (@typeId(@typeOf(46)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 46) else if (@typeId(@typeOf(46)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 46) else LPCSTR(46);
pub const WM_CHAR = 258;
pub const MCI_SYSINFO_INSTALLNAME = @as(c_long, 2048);
pub const BCRYPT_ECDH_P521_ALG_HANDLE = if (@typeId(@typeOf(705)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 705) else if (@typeId(@typeOf(705)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 705) else BCRYPT_ALG_HANDLE(705);
pub const ERROR_DS_TIMELIMIT_EXCEEDED = @as(c_long, 8226);
pub const LGRPID_CYRILLIC = 5;
pub const URLACTION_ACTIVEX_SCRIPTLET_RUN = 4617;
pub const RegConnectRegistryEx = RegConnectRegistryExA;
pub const SECURITY_UMFD_BASE_RID = @as(c_long, 96);
pub const LimitEmsPages = dw;
pub const LANG_MAPUDUNGUN = 122;
pub const SECURITY_BATCH_RID = @as(c_long, 3);
pub const CLEARTYPE_QUALITY = 5;
pub const CRYPT_STICKY_CACHE_RETRIEVAL = 4096;
pub const ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE = @as(c_long, 5890);
pub const BS_AUTO3STATE = @as(c_long, 6);
pub const FILE_DEVICE_NULL = 21;
pub const MCI_INFO_FILE = @as(c_long, 512);
pub const MDM_AUTO_ML_2 = 2;
pub const szOID_ECC_CURVE_EC192WAPI = "1.2.156.11235.1.1.2.1";
pub const FILE_DEVICE_DFS = 6;
pub const ENABLE_PROCESSED_OUTPUT = 1;
pub const CAL_JAPAN = 3;
pub const URLMON_OPTION_USE_BINDSTRINGCREDS = 268435464;
pub const WH_MAX = 14;
pub const SHIFTJIS_CHARSET = 128;
pub const LANG_NEUTRAL = 0;
pub const szOID_ENROLL_CAXCHGCERT_HASH = "1.3.6.1.4.1.311.21.27";
pub const SPI_SETPENVISUALIZATION = 8223;
pub const PROCESS_SET_LIMITED_INFORMATION = 8192;
pub const cmb12 = 1147;
pub const LMEM_NODISCARD = 32;
pub const SEM_FAILCRITICALERRORS = 1;
pub const _SPACE = 8;
pub const X3_IMM39_1_SIGN_VAL_POS_X = 36;
pub const IMAGE_SYM_CLASS_EXTERNAL = 2;
pub const CONTAINER_VOLUME_STATE_HOSTING_CONTAINER = 1;
pub const ERROR_INVALID_TARGET_HANDLE = @as(c_long, 114);
pub const FW_DEMIBOLD = FW_SEMIBOLD;
pub const WINAPI_FAMILY_SERVER = 5;
pub const TIMESTAMP_FAILURE_BAD_ALG = 0;
pub const LANG_CZECH = 5;
pub const MWT_IDENTITY = 1;
pub const szOID_RSA_SHA256RSA = "1.2.840.113549.1.1.11";
pub const WNNC_NET_EXTENDNET = 2686976;
pub const SERVICE_CONFIG_PREFERRED_NODE = 9;
pub const NCRYPT_CLAIM_WEB_AUTH_SUBJECT_ONLY = 258;
pub const ERROR_FILE_PROTECTED_UNDER_DPL = @as(c_long, 406);
pub const STORAGE_ADAPTER_SERIAL_NUMBER_V1_MAX_LENGTH = 128;
pub const FACILITY_USERMODE_HNS = 59;
pub const CMSG_CMS_SIGNER_INFO_PARAM = 39;
pub const IS_TEXT_UNICODE_CONTROLS = 4;
pub const __declare_lock_level = level;
pub const ERROR_HOTKEY_NOT_REGISTERED = @as(c_long, 1419);
pub const ERROR_COMMITMENT_LIMIT = @as(c_long, 1455);
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_WARNING = 1;
pub const SHUTDOWN_RESTARTAPPS = 128;
pub const SC_MANAGER_CREATE_SERVICE = 2;
pub const FILE_READ_ONLY = 8;
pub const ERROR_WX86_ERROR = @as(c_long, 540);
pub const PEERDIST_ERROR_SERVICE_UNAVAILABLE = @as(c_long, 4065);
pub const __WINT_MAX__ = 65535;
pub const EnumResourceLanguagesEx = EnumResourceLanguagesExA;
pub const ShellAbout = ShellAboutA;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_APP_RID = @as(c_long, 2048);
pub const VOS__BASE = @as(c_long, 0);
pub const CERT_KEY_CLASSIFICATION_PROP_ID = 120;
pub const HBMMENU_MBAR_CLOSE = if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Pointer) @ptrCast(HBITMAP, 5) else if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Int) @intToPtr(HBITMAP, 5) else HBITMAP(5);
pub const SECURITY_WMIHOST_ID_BASE_RID = @as(c_long, 86);
pub const OF_VERIFY = 1024;
pub const MoveMemory = RtlMoveMemory;
pub const __acquires_lock = lock;
pub const TXFS_RM_STATE_ACTIVE = 2;
pub const CF_INACTIVEFONTS = @as(c_long, 33554432);
pub const BCRYPT_AUTH_MODE_IN_PROGRESS_FLAG = 2;
pub const ERROR_DS_DRA_MISSING_KRBTGT_SECRET = @as(c_long, 8633);
pub const ES_AWAYMODE_REQUIRED = if (@typeId(@typeOf(64)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 64) else if (@typeId(@typeOf(64)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 64) else DWORD(64);
pub const FKF_HOTKEYSOUND = 16;
pub const IMAGE_HOT_PATCH_CHUNK_TYPE = 1032192;
pub const ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER = @as(c_long, 8516);
pub const HIST_NO_OF_BUCKETS = 24;
pub const InterlockedCompareExchangeNoFence64 = InterlockedCompareExchange64;
pub const GET_FEATURE_FROM_REGISTRY = 4;
pub const __INT_LEAST32_MAX__ = 2147483647;
pub const SCARD_UNPOWER_CARD = 2;
pub const TC_GP_TRAP = 2;
pub const SCardLocateCards = SCardLocateCardsA;
pub const ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION = @as(c_long, 6810);
pub const ReplaceText = ReplaceTextA;
pub const LBS_EXTENDEDSEL = @as(c_long, 2048);
pub const SECURITY_CAPABILITY_INTERNET_CLIENT_SERVER = @as(c_long, 2);
pub const Uri_CREATE_NO_DECODE_EXTRA_INFO = 128;
pub const X509_DSS_SIGNATURE = if (@typeId(@typeOf(40)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 40) else if (@typeId(@typeOf(40)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 40) else LPCSTR(40);
pub const CRYPT_FIRST = 1;
pub const SERVICE_STOP_REASON_MINOR_SERVICEPACK = 13;
pub const PRODUCT_CONNECTED_CAR = 117;
pub const ERROR_EC_CREDSTORE_FULL = @as(c_long, 15083);
pub const ERROR_BAD_THREADID_ADDR = @as(c_long, 159);
pub const REG_DWORD = @as(c_ulong, 4);
pub const PROTECTION_LEVEL_WINDOWS_LIGHT = 2;
pub const RPC_S_NO_BINDINGS = @as(c_long, 1718);
pub const IMAGE_GUARD_FLAG_FID_SUPPRESSED = 1;
pub const DOF_PROGMAN = 1;
pub const LPCPROPSHEETPAGE_V2 = LPCPROPSHEETPAGEA_V2;
pub const DM_NUP = @as(c_long, 64);
pub const SERVICE_DYNAMIC_INFORMATION_LEVEL_START_REASON = 1;
pub const CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC = 12;
pub const NCRYPT_KDF_KEY_BLOB_MAGIC = 826688587;
pub const IMAGE_REL_ALPHA_MATCH = 13;
pub const DMPAPER_JENV_YOU4_ROTATED = 92;
pub const DDUMP_FLAG_DATA_READ_FROM_DEVICE = 1;
pub const PARTITION_MAIN_OS = 40;
pub const SPI_GETWAITTOKILLTIMEOUT = 122;
pub const DUPLICATE = 6;
pub const CERT_CHAIN_ONLY_ADDITIONAL_AND_AUTH_ROOT = 32768;
pub const ABM_NEW = 0;
pub const LOCALE_USE_CP_ACP = 1073741824;
pub const IMAGE_REL_M32R_PCREL16 = 6;
pub const LANG_BASQUE = 45;
pub const SECURITY_SERVICE_ID_RID_COUNT = @as(c_long, 6);
pub const ERROR_SERVICE_DISABLED = @as(c_long, 1058);
pub const ERROR_TOO_MANY_SESS = @as(c_long, 69);
pub const ERROR_RMODE_APP = @as(c_long, 1153);
pub const EXCEPTION_FLT_INVALID_OPERATION = STATUS_FLOAT_INVALID_OPERATION;
pub const ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED = @as(c_long, 13930);
pub const FACILITY_USERMODE_COMMONLOG = 26;
pub const INT_MAX = 2147483647;
pub const LBS_COMBOBOX = @as(c_long, 32768);
pub const TAPE_DRIVE_END_OF_DATA = 2147549184;
pub const PROCESS_CREATION_MITIGATION_POLICY_CONTROL_FLOW_GUARD_MASK = if (@typeId(@typeOf(i64 << 40)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 40) else if (@typeId(@typeOf(i64 << 40)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 40) else @as(c_uint, 3)(i64 << 40);
pub const GCLP_HMODULE = -16;
pub const PEN_MASK_ROTATION = 2;
pub const MAXIMUM_ENCRYPTION_VALUE = 4;
pub const SM_CXMENUCHECK = 71;
pub const MA_ACTIVATE = 1;
pub const SPI_GETHANDEDNESS = 8228;
pub const RES_CURSOR = 2;
pub const ERROR_TIMER_RESUME_IGNORED = @as(c_long, 722);
pub const RRF_SUBKEY_WOW6432KEY = 131072;
pub const EXCEPTION_IN_PAGE_ERROR = STATUS_IN_PAGE_ERROR;
pub const CERT_NAME_STR_ENABLE_UTF8_UNICODE_FLAG = 262144;
pub const UPDFCACHE_IFBLANK = 16;
pub const MCI_CD_OFFSET = 1088;
pub const RPC_C_OPT_SECURITY_CALLBACK = 10;
pub const EMR_SCALEWINDOWEXTEX = 32;
pub const CERT_FIND_OR_ENHKEY_USAGE_FLAG = 16;
pub const PAN_LETT_NORMAL_BOXED = 4;
pub const ERROR_INSTALL_INVALID_RELATED_SET_UPDATE = @as(c_long, 15639);
pub const CB_GETHORIZONTALEXTENT = 349;
pub const PRODUCT_STARTER_E = 66;
pub const cmb13 = 1148;
pub const DeletePrinterDataEx = DeletePrinterDataExA;
pub const IMAGE_REL_I386_DIR32 = 6;
pub const BAUD_14400 = if (@typeId(@typeOf(4096)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 4096) else if (@typeId(@typeOf(4096)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 4096) else DWORD(4096);
pub const ERROR_INVALID_SIGNAL_NUMBER = @as(c_long, 209);
pub const RPC_S_COMM_FAILURE = @as(c_long, 1820);
pub const SECURITY_DIALUP_RID = @as(c_long, 1);
pub const IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER = 11;
pub const S_WHITE512 = 4;
pub const SUBLANG_IRISH_IRELAND = 2;
pub const _SAL_VERSION = 20;
pub const JOB_OBJECT_CPU_RATE_CONTROL_ENABLE = 1;
pub const szOID_KP_TPM_AIK_CERTIFICATE = "2.23.133.8.3";
pub const ICM_DONE_OUTSIDEDC = 4;
pub const CS_NOCLOSE = 512;
pub const BCRYPT_ECDH_PUBLIC_P521_MAGIC = 894124869;
pub const CERT_FIND_SUBJECT_CERT = CERT_COMPARE_SUBJECT_CERT << CERT_COMPARE_SHIFT;
pub const ERROR_MUI_INVALID_LOCALE_NAME = @as(c_long, 15103);
pub const ERROR_DS_INVALID_SEARCH_FLAG_TUPLE = @as(c_long, 8627);
pub const NULLREGION = 1;
pub const EVENT_CONSOLE_LAYOUT = 16389;
pub const RPC_EEINFO_VERSION = 1;
pub const EXCEPTION_CONTINUE_EXECUTION = -1;
pub const DDE_FACK = 32768;
pub const MAX_PROFILE_LEN = 80;
pub const FILE_DEVICE_SERENUM = 55;
pub const NMPWAIT_NOWAIT = 1;
pub const CRYPT_OBJECT_LOCATOR_RELEASE_SYSTEM_SHUTDOWN = 1;
pub const FRS_ERR_CHILD_TO_PARENT_COMM = @as(c_long, 8011);
pub const EnumICMProfiles = EnumICMProfilesA;
pub const CBF_FAIL_REQUESTS = 131072;
pub const NTM_BOLD = @as(c_long, 32);
pub const CFSTR_MIME_APP_XML = if (@typeId(@typeOf("application/xml")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "application/xml") else if (@typeId(@typeOf("application/xml")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "application/xml") else TEXT("application/xml");
pub const X509_KEY_ATTRIBUTES = if (@typeId(@typeOf(10)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 10) else if (@typeId(@typeOf(10)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 10) else LPCSTR(10);
pub const TAPE_QUERY_DRIVE_PARAMETERS = @as(c_long, 0);
pub const CRYPT_DATA_KEY = 2048;
pub const DNS_ERROR_RRL_INVALID_LEAK_RATE = @as(c_long, 9916);
pub const ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED = @as(c_long, 7061);
pub const ERROR_REDIRECTOR_HAS_OPEN_HANDLES = @as(c_long, 1794);
pub const ERROR_DS_NO_NTDSA_OBJECT = @as(c_long, 8623);
pub const PARTITION_SPACES = 231;
pub const RTS_CONTROL_TOGGLE = 3;
pub const PAN_BENT_ARMS_WEDGE = 8;
pub const CERT_DEFAULT_OID_PUBLIC_KEY_XCHG = szOID_RSA_RSA;
pub const USN_REASON_NAMED_DATA_OVERWRITE = 16;
pub const ACCESS_REASON_STAGING_MASK = 2147483648;
pub const RTL_CRITICAL_SECTION_DEBUG_FLAG_STATIC_INIT = 1;
pub const DNS_ERROR_DS_UNAVAILABLE = @as(c_long, 9717);
pub const JOB_NOTIFY_FIELD_BYTES_PRINTED = 23;
pub const RDW_UPDATENOW = 256;
pub const IMAGE_ORDINAL_FLAG = IMAGE_ORDINAL_FLAG64;
pub const OUT_DEFAULT_PRECIS = 0;
pub const CLIP_EMBEDDED = 8 << 4;
pub const X3_P_INST_WORD_X = 3;
pub const ALG_SID_ANY = 0;
pub const FILE_CURRENT = 1;
pub const ERROR_CTX_SHADOW_DISABLED = @as(c_long, 7051);
pub const FindResourceEx = FindResourceExA;
pub const SCARD_PROTOCOL_UNDEFINED = 0;
pub const szOID_DSALG_HASH = "2.5.8.2";
pub const PSN_QUERYINITIALFOCUS = if (@typeId(@typeOf(-13)) == @import("builtin").TypeId.Pointer) @ptrCast(PSN_FIRST, -13) else if (@typeId(@typeOf(-13)) == @import("builtin").TypeId.Int) @intToPtr(PSN_FIRST, -13) else PSN_FIRST(-13);
pub const SUBLANG_ENGLISH_CARIBBEAN = 9;
pub const IMAGE_REL_CEE_ABSOLUTE = 0;
pub const DMCOLOR_MONOCHROME = 1;
pub const C3_IDEOGRAPH = 256;
pub const PROC_THREAD_ATTRIBUTE_INPUT = 131072;
pub const CRYPT_MODE_CBCOFM = 9;
pub const CRYPT_FIND_MACHINE_KEYSET_FLAG = 2;
pub const REVOCATION_OID_CRL_REVOCATION = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 1) else LPCSTR(1);
pub const ERROR_FT_WRITE_FAILURE = @as(c_long, 338);
pub const PSBTN_HELP = 6;
pub const MCI_WAVE_INPUT = @as(c_long, 4194304);
pub const __MPX__ = 1;
pub const MAXIMUM_SMARTCARD_READERS = 10;
pub const ERROR_DS_HAVE_PRIMARY_MEMBERS = @as(c_long, 8521);
pub const MCI_INFO_NAME = @as(c_long, 4096);
pub const EXCEPTION_STACK_OVERFLOW = STATUS_STACK_OVERFLOW;
pub const szOID_ORGANIZATION_NAME = "2.5.4.10";
pub const EWX_ARSO = 67108864;
pub const LPCPROPSHEETPAGE_V3 = LPCPROPSHEETPAGEA_V3;
pub const SHUTDOWN_SKIP_SVC_PRESHUTDOWN = 256;
pub const ERROR_HOST_NODE_NOT_RESOURCE_OWNER = @as(c_long, 5015);
pub const __UINT32_MAX__ = @as(c_uint, 4294967295);
pub const TIMESTAMP_STATUS_REJECTED = 2;
pub const PDERR_INITFAILURE = 4102;
pub const IMAGE_REL_ARM64_SECTION = 13;
pub const SECURITY_USERMANAGER_ID_RID_COUNT = @as(c_long, 6);
pub const PROCESS_HEAP_REGION = 1;
pub const PROCESS_CREATION_DESKTOP_APP_BREAKAWAY_DISABLE_PROCESS_TREE = 2;
pub const SHTDN_REASON_MAJOR_SYSTEM = 327680;
pub const DC_PRINTERMEM = 28;
pub const SERVICE_STOP_REASON_MINOR_WMI = 18;
pub const SPI_GETMENUDROPALIGNMENT = 27;
pub const CONTEXT_AMD64 = @as(c_long, 1048576);
pub const IDTIMEOUT = 32000;
pub const SEE_MASK_FLAG_NO_UI = 1024;
pub const ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS = @as(c_long, 8493);
pub const CC_FULLOPEN = 2;
pub const ERROR_DOMAIN_CTRLR_CONFIG_ERROR = @as(c_long, 581);
pub const MCI_ANIM_GETDEVCAPS_SLOW_RATE = @as(c_long, 16387);
pub const PERF_TEXT_ASCII = 65536;
pub const THREAD_BASE_PRIORITY_MAX = 2;
pub const PRODUCT_DATACENTER_SERVER = 8;
pub const WOM_DONE = MM_WOM_DONE;
pub const ERROR_STATE_COMPOSITE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED = @as(c_long, 15815);
pub const CERT_STORE_PROV_FIND_CTL_FUNC = 20;
pub const ENOBUFS = 119;
pub const LOCALE_ALL = 0;
pub const WS_SIZEBOX = WS_THICKFRAME;
pub const VK_NONAME = 252;
pub const ERROR_DUPLICATE_PRIVILEGES = @as(c_long, 311);
pub const ERROR_GROUPSET_CANT_PROVIDE = @as(c_long, 5993);
pub const RPC_S_NAME_SERVICE_UNAVAILABLE = @as(c_long, 1762);
pub const NCBLISTEN = 17;
pub const CERT_SELECT_BY_PROV_NAME = 4;
pub const IMPLINK_LOWEXPER = 156;
pub const STATE_SYSTEM_ALERT_MEDIUM = 134217728;
pub const SUBLANG_SPANISH_EL_SALVADOR = 17;
pub const DMICMMETHOD_DEVICE = 4;
pub const szOID_ENROLL_ATTESTATION_STATEMENT = "1.3.6.1.4.1.311.21.24";
pub const DMLERR_POSTMSG_FAILED = 16396;
pub const CMSG_CTRL_DEL_CRL = 13;
pub const XSTATE_LEGACY_FLOATING_POINT = 0;
pub const LANG_SLOVENIAN = 36;
pub const SDC_TOPOLOGY_INTERNAL = 1;
pub const CERT_TRUST_IS_OFFLINE_REVOCATION = 16777216;
pub const MCI_DEVTYPE_OVERLAY = 515;
pub const ERROR_APP_DATA_LIMIT_EXCEEDED = @as(c_long, 4403);
pub const ERROR_FILE_METADATA_OPTIMIZATION_IN_PROGRESS = @as(c_long, 809);
pub const SHGSI_LINKOVERLAY = SHGFI_LINKOVERLAY;
pub const JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT = 9;
pub const JOY_BUTTON6 = @as(c_long, 32);
pub const CRL_REASON_KEY_COMPROMISE = 1;
pub const IMAGE_POLICY_METADATA_VERSION = 1;
pub const PAN_PROP_CONDENSED = 6;
pub const ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER = @as(c_long, 8559);
pub const CTRY_BELGIUM = 32;
pub const DNS_ERROR_RCODE_NOT_IMPLEMENTED = @as(c_long, 9004);
pub const ERROR_DRIVE_MEDIA_MISMATCH = @as(c_long, 4303);
pub const PROCESSOR_ARM720 = 1824;
pub const SE_ERR_DDETIMEOUT = 28;
pub const ERROR_ALREADY_ASSIGNED = @as(c_long, 85);
pub const SO_BROADCAST = 32;
pub const ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED = @as(c_long, 788);
pub const IMAGE_REL_ALPHA_BRADDR = 7;
pub const SW_NORMAL = 1;
pub const SSTF_NONE = 0;
pub const CAPSLOCK_ON = 128;
pub const ERROR_SXS_VERSION_CONFLICT = @as(c_long, 14008);
pub const OFN_ENABLESIZING = 8388608;
pub const VER_NT_DOMAIN_CONTROLLER = 2;
pub const NCRYPT_VSM_KEY_ATTESTATION_STATEMENT_V0 = 0;
pub const STATUS_FLOAT_STACK_CHECK = if (@typeId(@typeOf(@as(c_long, 3221225618))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225618)) else if (@typeId(@typeOf(@as(c_long, 3221225618))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225618)) else DWORD(@as(c_long, 3221225618));
pub const PRODUCT_DATACENTER_EVALUATION_SERVER = 80;
pub const VK_NAVIGATION_UP = 138;
pub const X509_AUTHORITY_INFO_ACCESS = if (@typeId(@typeOf(32)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 32) else if (@typeId(@typeOf(32)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 32) else LPCSTR(32);
pub const CERT_TRUST_HAS_NOT_DEFINED_NAME_CONSTRAINT = 8192;
pub const PO_THROTTLE_MAXIMUM = 4;
pub const DESKTOP_SWITCHDESKTOP = @as(c_long, 256);
pub const LookupAccountSid = LookupAccountSidA;
pub const QDC_DATABASE_CURRENT = 4;
pub const PROCESSOR_ARCHITECTURE_ARM = 5;
pub const GET_SYSTEM_WOW64_DIRECTORY_NAME_T_A = GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A;
pub const WH_MAXHOOK = WH_MAX;
pub const GET_SYSTEM_WOW64_DIRECTORY_NAME_W_A = "GetSystemWow64DirectoryW";
pub const EM_EMPTYUNDOBUFFER = 205;
pub const CRYPT_TYPE2_FORMAT = 2;
pub const IMN_SETCOMPOSITIONWINDOW = 11;
pub const ERROR_DEPENDENCY_TREE_TOO_COMPLEX = @as(c_long, 5929);
pub const PRODUCT_ONECOREUPDATEOS = 182;
pub const FACILITY_DXGI_DDI = 2171;
pub const THREAD_MODE_BACKGROUND_END = 131072;
pub const MM_MIXM_LINE_CHANGE = 976;
pub const PERSISTENT_VOLUME_STATE_CONTAINS_BACKING_WIM = 32;
pub const RPC_C_HTTP_AUTHN_TARGET_SERVER = 1;
pub const szOID_BIOMETRIC_SIGNING = "1.3.6.1.4.1.311.10.3.41";
pub const SM_CXVSCROLL = 2;
pub const DEVICEFAMILYDEVICEFORM_PUCK = 9;
pub const SND_PURGE = 64;
pub const CERT_STORE_PROV_GET_CRL_PROPERTY_FUNC = 19;
pub const CRYPT_OID_UNREGISTER_SYSTEM_STORE_FUNC = "CertDllUnregisterSystemStore";
pub const CERT_STORE_NO_CRYPT_RELEASE_FLAG = 1;
pub const InterlockedExchangeAddNoFence64 = _InterlockedExchangeAdd64;
pub const SPI_GETHUNGAPPTIMEOUT = 120;
pub const DMICM_SATURATE = 1;
pub const CC_ENABLETEMPLATEHANDLE = 64;
pub const ERROR_CLUSTER_NODE_EXISTS = @as(c_long, 5040);
pub const CERT_TRUST_PUB_ALLOW_TRUST_MASK = 3;
pub const CHANGER_VOLUME_ASSERT = 4194304;
pub const BCRYPT_SHA256_ALG_HANDLE = if (@typeId(@typeOf(65)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 65) else if (@typeId(@typeOf(65)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 65) else BCRYPT_ALG_HANDLE(65);
pub const CONSOLE_CARET_VISIBLE = 2;
pub const ERROR_DS_CANT_DELETE = @as(c_long, 8398);
pub const DEVICEFAMILYDEVICEFORM_DESKTOP = 3;
pub const ERROR_CLUSTER_NETWORK_ALREADY_ONLINE = @as(c_long, 5063);
pub const RC_BIGFONT = 1024;
pub const szOID_OIWSEC_md5RSA = "1.3.14.3.2.3";
pub const SUBLANG_ICELANDIC_ICELAND = 1;
pub const SERIAL_IOC_FCR_RCVR_TRIGGER_MSB = if (@typeId(@typeOf(128)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 128) else if (@typeId(@typeOf(128)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 128) else DWORD(128);
pub const _REPORT_ERRMODE = 3;
pub const MKF_RIGHTBUTTONDOWN = 33554432;
pub const CFS_RECT = 1;
pub const CRYPT_ECC_CMS_SHARED_INFO_SUPPPUBINFO_BYTE_LENGTH = 4;
pub const IMAGE_SCN_ALIGN_8BYTES = 4194304;
pub const USER_MARSHAL_FC_LONG = 8;
pub const PARTITION_EXTENDED = 5;
pub const WARNING_IPSEC_MM_POLICY_PRUNED = @as(c_long, 13024);
pub const ERROR_PACKAGE_STAGING_ONHOLD = @as(c_long, 15638);
pub const FR_WHOLEWORD = 2;
pub const InterlockedAnd16 = _InterlockedAnd16;
pub const ERROR_HANDLE_REVOKED = @as(c_long, 811);
pub const PAN_LETT_OBLIQUE_SQUARE = 15;
pub const IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE = 64;
pub const TME_HOVER = 1;
pub const SEC_IMAGE = 16777216;
pub const PROCESS_CREATION_MITIGATION_POLICY2_SPECULATIVE_STORE_BYPASS_DISABLE_ALWAYS_ON = if (@typeId(@typeOf(i64 << 24)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << 24) else if (@typeId(@typeOf(i64 << 24)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << 24) else @as(c_uint, 1)(i64 << 24);
pub const cPRIV_KEY_CACHE_PURGE_INTERVAL_SECONDS_DEFAULT = 86400;
pub const LCID_ALTERNATE_SORTS = 4;
pub const SCARD_STATE_PRESENT = 32;
pub const CRM_PROTOCOL_MAXIMUM_OPTION = 3;
pub const CERT_CHAIN_POLICY_SSL_F12_ROOT_PROGRAM_CATEGORY = 2;
pub const COLOROKSTRING = COLOROKSTRINGA;
pub const ERROR_VDM_DISALLOWED = @as(c_long, 1286);
pub const ERROR_DEVICE_IN_USE = @as(c_long, 2404);
pub const CallMsgFilter = CallMsgFilterA;
pub const IPPROTO_IGMP = 2;
pub const ERROR_SERVICE_START_HANG = @as(c_long, 1070);
pub const __CONSTANT_CFSTRINGS__ = 1;
pub const STATUS_ORDINAL_NOT_FOUND = if (@typeId(@typeOf(@as(c_long, 3221225784))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225784)) else if (@typeId(@typeOf(@as(c_long, 3221225784))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225784)) else DWORD(@as(c_long, 3221225784));
pub const IMAGE_ORDINAL_FLAG64 = 9223372036854775808;
pub const ERROR_PRINT_CANCELLED = @as(c_long, 63);
pub const CERT_STORE_PROV_SMART_CARD_W = if (@typeId(@typeOf(15)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 15) else if (@typeId(@typeOf(15)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 15) else LPCSTR(15);
pub const IMAGE_FILE_BYTES_REVERSED_HI = 32768;
pub const MCI_GETDEVCAPS_CAN_PLAY = @as(c_long, 8);
pub const CERT_SELECT_BY_ISSUER_NAME = 9;
pub const FO_DELETE = 3;
pub const ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT = @as(c_long, 2109);
pub const TARGET_IS_NT51_OR_LATER = 1;
pub const CMSG_RECIPIENT_INDEX_PARAM = 18;
pub const IDLFLAG_FOUT = PARAMFLAG_FOUT;
pub const URLACTION_DOWNLOAD_SIGNED_ACTIVEX = 4097;
pub const APPCOMMAND_SAVE = 32;
pub const ERROR_EXCEPTION_IN_RESOURCE_CALL = @as(c_long, 5930);
pub const PAN_STROKE_RAPID_VERT = 6;
pub const MS_ENHANCED_PROV = MS_ENHANCED_PROV_A;
pub const SERVICE_STOP_REASON_MINOR_UNSTABLE = 7;
pub const JOY_BUTTON7 = @as(c_long, 64);
pub const MCI_WAVE_SET_ANYINPUT = @as(c_long, 67108864);
pub const FW_REGULAR = FW_NORMAL;
pub const CERT_CHAIN_POLICY_SSL = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 4) else LPCSTR(4);
pub const RPC_S_NOT_CANCELLED = @as(c_long, 1826);
pub const edt1 = 1152;
pub const NCRYPT_PERSIST_FLAG = 2147483648;
pub const IMAGE_FILE_BYTES_REVERSED_LO = 128;
pub const EVENT_SYSTEM_CAPTUREEND = 9;
pub const CTRY_IRAN = 981;
pub const RI_MOUSE_BUTTON_1_UP = RI_MOUSE_LEFT_BUTTON_UP;
pub const SKF_HOTKEYSOUND = 16;
pub const ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE = @as(c_long, 5064);
pub const CRYPTNET_URL_CACHE_PRE_FETCH_BLOB = 1;
pub const PROPSET_BEHAVIOR_CASE_SENSITIVE = 1;
pub const CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC = 4;
pub const ERROR_CTX_MODEM_RESPONSE_TIMEOUT = @as(c_long, 7012);
pub const GCPGLYPH_LINKBEFORE = 32768;
pub const PD_RETURNIC = 512;
pub const ERROR_EXTENDED_ERROR = @as(c_long, 1208);
pub const PS_NULL = 5;
pub const __UINT_LEAST8_MAX__ = 255;
pub const WINSTA_ACCESSGLOBALATOMS = @as(c_long, 32);
pub const LOGON_NETCREDENTIALS_ONLY = 2;
pub const szOID_SITE_PIN_RULES_INDEX_ATTR = "1.3.6.1.4.1.311.10.4.2";
pub const SECURITY_WINDOW_MANAGER_BASE_RID = @as(c_long, 90);
pub const szOID_ENROLL_AIK_INFO = "1.3.6.1.4.1.311.21.39";
pub const ALG_TYPE_THIRDPARTY = 8 << 9;
pub const FNERR_BUFFERTOOSMALL = 12291;
pub const SECURITY_IE_STATE_RED = 1;
pub const WAVE_FORMAT_96S16 = 524288;
pub const PRINTER_CONNECTION_NO_UI = 64;
pub const WM_PAINT = 15;
pub const ERROR_CANCEL_VIOLATION = @as(c_long, 173);
pub const WNetEnumResource = WNetEnumResourceA;
pub const ERROR_MEMORY_HARDWARE = @as(c_long, 779);
pub const ERROR_DS_DIFFERENT_REPL_EPOCHS = @as(c_long, 8593);
pub const MDMSPKRFLAG_DIAL = 2;
pub const PKCS12_PROTECT_TO_DOMAIN_SIDS = 32;
pub const __PTRDIFF_MAX__ = @as(c_longlong, 9223372036854775807);
pub const GENERIC_READ = @as(c_long, 2147483648);
pub const ERROR_EDP_DPL_POLICY_CANT_BE_SATISFIED = @as(c_long, 357);
pub const ImmEscape = ImmEscapeA;
pub const VarUintFromR4 = VarUI4FromR4;
pub const WM_TOUCHHITTESTING = 589;
pub const IMAGE_VXD_SIGNATURE = 17740;
pub const IOInet = IInternet;
pub const CFSTR_MIME_BASICAUDIO = if (@typeId(@typeOf("audio/basi")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "audio/basi") else if (@typeId(@typeOf("audio/basi")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "audio/basi") else TEXT("audio/basi");
pub const LOCALE_IDIALINGCODE = 5;
pub const ERROR_DS_DUP_LDAP_DISPLAY_NAME = @as(c_long, 8382);
pub const CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY_ID = 7;
pub const CERT_VERIFY_TRUSTED_SIGNERS_FLAG = 2;
pub const REGISTERWORDENUMPROC = REGISTERWORDENUMPROCA;
pub const IID_IOInetBindInfoEx = IID_IInternetBindInfoEx;
pub const IO_REPARSE_TAG_WIM = @as(c_long, 2147483656);
pub const MF_ENABLED = @as(c_long, 0);
pub const BS_TOP = @as(c_long, 1024);
pub const BS_AUTORADIOBUTTON = @as(c_long, 9);
pub const SHTDN_REASON_FLAG_DIRTY_PROBLEM_ID_REQUIRED = 33554432;
pub const DRV_POWER = 15;
pub const PPCAPS_DONT_SEND_EXTRA_PAGES_FOR_DUPLEX = 1 << 1;
pub const ISMEX_NOSEND = 0;
pub const CFSTR_MIME_PJPEG = if (@typeId(@typeOf("image/pjpeg")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "image/pjpeg") else if (@typeId(@typeOf("image/pjpeg")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "image/pjpeg") else TEXT("image/pjpeg");
pub const DNS_ERROR_NOT_ALLOWED_ON_RODC = @as(c_long, 9569);
pub const szOID_ECC_CURVE_P256 = "1.2.840.10045.3.1.7";
pub const EMR_ARC = 45;
pub const CFSTR_MIME_SVG_XML = if (@typeId(@typeOf("image/svg+xml")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "image/svg+xml") else if (@typeId(@typeOf("image/svg+xml")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "image/svg+xml") else TEXT("image/svg+xml");
pub const PIDSI_WORDCOUNT = @as(c_long, 15);
pub const WHITE_BRUSH = 0;
pub const SUBLANG_FINNISH_FINLAND = 1;
pub const PSWIZBF_ELEVATIONREQUIRED = 1;
pub const PST_TCPIP_TELNET = if (@typeId(@typeOf(258)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 258) else if (@typeId(@typeOf(258)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 258) else DWORD(258);
pub const CRL_DIST_POINT_ISSUER_RDN_NAME = 2;
pub const IME_ITHOTKEY_RESEND_RESULTSTR = 512;
pub const CRYPT_X942_COUNTER_BYTE_LENGTH = 4;
pub const XcvData = XcvDataW;
pub const WINAPI_INLINE = WINAPI;
pub const ERROR_DS_RIDMGR_DISABLED = @as(c_long, 8263);
pub const LPD_TYPE_RGBA = 0;
pub const SUBLANG_ENGLISH_JAMAICA = 8;
pub const SM_CYMAXIMIZED = 62;
pub const LANG_TURKMEN = 66;
pub const GetNamedPipeHandleState = GetNamedPipeHandleStateA;
pub const DPD_DELETE_UNUSED_FILES = 1;
pub const CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID = 2;
pub const TAPE_RETURN_ENV_INFO = @as(c_long, 1);
pub const szOID_OEM_WHQL_CRYPTO = "1.3.6.1.4.1.311.10.3.7";
pub const SERVICE_TRIGGER_TYPE_DOMAIN_JOIN = 3;
pub const ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS = @as(c_long, 8637);
pub const BitScanReverse = _BitScanReverse;
pub const VARCMP_GT = 2;
pub const ERROR_FILE_CORRUPT = @as(c_long, 1392);
pub const SECTION_MAP_WRITE = 2;
pub const VK_KANJI = 25;
pub const KEY_QUERY_VALUE = 1;
pub const SECURITY_WINRM_ID_BASE_RID = @as(c_long, 94);
pub const ERROR_LOG_BLOCKS_EXHAUSTED = @as(c_long, 6605);
pub const RegisterServiceCtrlHandlerEx = RegisterServiceCtrlHandlerExA;
pub const EMR_POLYBEZIER = 2;
pub const REG_START_JOURNAL = @as(c_long, 64);
pub const PAGE_READWRITE = 4;
pub const ERROR_CLUSTER_RESOURCE_NOT_MONITORED = @as(c_long, 5981);
pub const MMIO_FINDPROC = 262144;
pub const MCI_VD_ESCAPE_STRING = @as(c_long, 256);
pub const OFN_SHOWHELP = 16;
pub const CAL_TAIWAN = 4;
pub const LOCALE_SSCRIPTS = 108;
pub const CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG = 16;
pub const REG_BOOT_HIVE = @as(c_long, 1024);
pub const ERROR_LOG_GROWTH_FAILED = @as(c_long, 6833);
pub const IMAGE_SUBSYSTEM_WINDOWS_CUI = 3;
pub const PrivateExtractIcons = PrivateExtractIconsA;
pub const WNNC_NET_HOB_NFS = 3276800;
pub const SUBLANG_ARABIC_TUNISIA = 7;
pub const MOUSE_MOVE_ABSOLUTE = 1;
pub const CERT_CA_DISABLE_CRL_PROP_ID = 82;
pub const ERROR_STATE_DELETE_CONTAINER_FAILED = @as(c_long, 15806);
pub const RPC_X_SS_CONTEXT_DAMAGED = @as(c_long, 1777);
pub const ERROR_SXS_MANIFEST_TOO_BIG = @as(c_long, 14105);
pub const STREAM_CONTAINS_SECURITY = 2;
pub const DNS_ERROR_KSP_DOES_NOT_SUPPORT_PROTECTION = @as(c_long, 9108);
pub const CRYPT_MODE_CTS = 5;
pub const URLACTION_COOKIES = 6658;
pub const DISPLAY_DEVICE_TS_COMPATIBLE = 2097152;
pub const ERROR_DS_UNICODEPWD_NOT_IN_QUOTES = @as(c_long, 8556);
pub const GMEM_DISCARDED = 16384;
pub const SERVICE_TRIGGER_TYPE_NETWORK_ENDPOINT = 6;
pub const RC_PALETTE = 256;
pub const URLOpenStream = URLOpenStreamA;
pub const szOID_KP_KERNEL_MODE_CODE_SIGNING = "1.3.6.1.4.1.311.61.1.1";
pub const CF_GDIOBJLAST = 1023;
pub const LBS_WANTKEYBOARDINPUT = @as(c_long, 1024);
pub const ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX = @as(c_long, 8377);
pub const MOD_WAVETABLE = 6;
pub const PEERDIST_ERROR_MISSING_DATA = @as(c_long, 4052);
pub const ERROR_CLUSTER_NO_SECURITY_CONTEXT = @as(c_long, 5059);
pub const JOB_OBJECT_LIMIT_VALID_FLAGS = 524287;
pub const ERROR_PRIVILEGE_NOT_HELD = @as(c_long, 1314);
pub const ERROR_FT_READ_FAILURE = @as(c_long, 415);
pub const ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD = @as(c_long, 13889);
pub const VK_NAVIGATION_LEFT = 140;
pub const SRB_TYPE_STORAGE_REQUEST_BLOCK = 1;
pub const JOY_BUTTON4 = 8;
pub const GL_ID_NOCONVERT = 32;
pub const CAP_ATAPI_ID_CMD = 2;
pub const RI_MOUSE_BUTTON_5_UP = 512;
pub const SORT_JAPANESE_XJIS = 0;
pub const GET_FEATURE_FROM_THREAD_INTRANET = 16;
pub const WSA_QOS_EFLOWDESC = @as(c_long, 11026);
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_CLIENT_SUBNET = @as(c_long, 9990);
pub const STATE_SYSTEM_HOTTRACKED = 128;
pub const QUERY_FILE_LAYOUT_INCLUDE_FULL_PATH_IN_NAMES = 64;
pub const edt2 = 1153;
pub const FindWindow = FindWindowA;
pub const PAN_CONTRAST_VERY_HIGH = 9;
pub const ReadConsoleOutputCharacter = ReadConsoleOutputCharacterA;
pub const WM_PASTE = 770;
pub const SSF_SOUNDSENTRYON = 1;
pub const __RPC_API = __stdcall;
pub const PFD_NEED_PALETTE = 128;
pub const EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X = 4;
pub const TIME_KILL_SYNCHRONOUS = 256;
pub const szOID_PKIX_KP_IPSEC_TUNNEL = "1.3.6.1.5.5.7.3.6";
pub const X3_TMPLT_SIZE_X = 4;
pub const IMAGE_REL_PPC_NEG = 256;
pub const SERVICE_INTERROGATE = 128;
pub const __INT_MAX__ = 2147483647;
pub const RPC_C_STATS_PKTS_OUT = 3;
pub const PST_SCANNER = if (@typeId(@typeOf(34)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 34) else if (@typeId(@typeOf(34)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 34) else DWORD(34);
pub const ALG_SID_RIPEMD160 = 7;
pub const APPCOMMAND_MICROPHONE_VOLUME_UP = 26;
pub const DM_SCALE = @as(c_long, 16);
pub const WM_HANDHELDLAST = 863;
pub const WM_NCHITTEST = 132;
pub const MS_RLSD_ON = if (@typeId(@typeOf(128)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 128) else if (@typeId(@typeOf(128)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 128) else DWORD(128);
pub const PROCESSOR_PPC_601 = 601;
pub const BCRYPT_SUPPORTED_PAD_ROUTER = 1;
pub const RPC_C_AUTHN_LEVEL_CALL = 3;
pub const MCI_BREAK_HWND = @as(c_long, 512);
pub const USER_TIMER_MAXIMUM = 2147483647;
pub const InterlockedOrAffinity = InterlockedOr64;
pub const InterlockedAnd64 = _InterlockedAnd64;
pub const WINPERF_LOG_NONE = 0;
pub const PF_RDWRFSGSBASE_AVAILABLE = 22;
pub const USN_SOURCE_DATA_MANAGEMENT = 1;
pub const EFS_TRACKED_OFFSET_HEADER_FLAG = 1;
pub const __XSAVES__ = 1;
pub const SCARD_READER_TYPE_PCMCIA = 64;
pub const ERROR_PRINT_MONITOR_ALREADY_INSTALLED = @as(c_long, 3006);
pub const ERROR_INVALID_PIXEL_FORMAT = @as(c_long, 2000);
pub const ELEMENT_STATUS_ACCESS = 8;
pub const ERROR_SYSTEM_INTEGRITY_INVALID_POLICY = @as(c_long, 4552);
pub const PlaySound = PlaySoundA;
pub const PERF_TIMER_TICK = 0;
pub const HCF_HOTKEYACTIVE = 4;
pub const ERROR_RING2_STACK_IN_USE = @as(c_long, 207);
pub const FILE_ACTION_RENAMED_NEW_NAME = 5;
pub const MFT_MENUBREAK = MF_MENUBREAK;
pub const APPCOMMAND_TREBLE_UP = 23;
pub const HELP_CONTEXTPOPUP = @as(c_long, 8);
pub const MF_LINKS = 536870912;
pub const POPENCARDNAME_W = POPENCARDNAMEW;
pub const ERROR_SXS_XML_E_XMLDECLSYNTAX = @as(c_long, 14035);
pub const PAN_CONTRAST_MEDIUM_LOW = 5;
pub const COPY_FILE_DONT_REQUEST_DEST_WRITE_DAC = 33554432;
pub const ERROR_DUP_DOMAINNAME = @as(c_long, 1221);
pub const CRYPT_FLAG_IPSEC = 16;
pub const szOID_PKCS_12 = "1.2.840.113549.1.12";
pub const GetCharABCWidthsFloat = GetCharABCWidthsFloatA;
pub const CERT_KEY_PROV_HANDLE_PROP_ID = 1;
pub const ATAPI_ID_CMD = 161;
pub const JOY_CAL_READZONLY = @as(c_long, 16777216);
pub const ERROR_SXS_XML_E_BADCHARDATA = @as(c_long, 14036);
pub const ERROR_MEMBER_IN_GROUP = @as(c_long, 1320);
pub const PRINTER_CONTROL_PURGE = 3;
pub const CERT_FIRST_USER_PROP_ID = 32768;
pub const LANG_URDU = 32;
pub const PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_PREFER_SYSTEM32_ALWAYS_ON = if (@typeId(@typeOf(i64 << 60)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << 60) else if (@typeId(@typeOf(i64 << 60)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << 60) else @as(c_uint, 1)(i64 << 60);
pub const OSVERSION_MASK = 4294901760;
pub const GC_PAN_WITH_GUTTER = 8;
pub const ERROR_DS_MASTERDSA_REQUIRED = @as(c_long, 8314);
pub const StoragePortClassGuid = GUID_DEVINTERFACE_STORAGEPORT;
pub const POINTER_MESSAGE_FLAG_NEW = 1;
pub const REG_MULTI_SZ = @as(c_ulong, 7);
pub const MIXERLINE_LINEF_SOURCE = @as(c_long, 2147483648);
pub const SE_GROUP_OWNER = @as(c_long, 8);
pub const ERROR_SMB1_NOT_AVAILABLE = @as(c_long, 384);
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILERANGE = @as(c_long, 412);
pub const DEVICEFAMILYINFOENUM_XBOXSRA = 11;
pub const IMAGE_REL_CEF_ADDR64 = 2;
pub const __INT_LEAST16_TYPE__ = short;
pub const VK_BACK = 8;
pub const RPC_HTTP_TRANSPORT_CREDENTIALS = RPC_HTTP_TRANSPORT_CREDENTIALS_A;
pub const NIIF_ERROR = 3;
pub const SUBLANG_WOLOF_SENEGAL = 1;
pub const SLE_MINORERROR = 2;
pub const CERT_KEYGEN_REQUEST_V1 = 0;
pub const APD_COPY_NEW_FILES = 8;
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_PARA_FLAG = 8;
pub const STATE_SYSTEM_COLLAPSED = 1024;
pub const SE_SACL_AUTO_INHERIT_REQ = 512;
pub const SOCKET_ERROR = -1;
pub const GL_ID_INPUTRADICAL = 37;
pub const NIS_HIDDEN = 1;
pub const ERROR_FAIL_SHUTDOWN = @as(c_long, 351);
pub const SUBLANG_TAMAZIGHT_ALGERIA_LATIN = 2;
pub const SND_NOSTOP = 16;
pub const MIXERCONTROL_CT_CLASS_MASK = @as(c_long, 4026531840);
pub const SS_ETCHEDFRAME = @as(c_long, 18);
pub const SM_CYMIN = 29;
pub const ERROR_CRM_PROTOCOL_NOT_FOUND = @as(c_long, 6712);
pub const CERT_SET_KEY_CONTEXT_PROP_ID = 1;
pub const EVENT_MAX = 2147483647;
pub const SO_SYNCHRONOUS_ALERT = 16;
pub const PC_POLYPOLYGON = 256;
pub const PIDDSI_MMCLIPCOUNT = 10;
pub const CD_LBSELSUB = 1;
pub const POWER_LEVEL_USER_NOTIFY_EXEC = 4;
pub const MM_TWIPS = 6;
pub const SCARD_STATE_UNAWARE = 0;
pub const ERROR_BAD_FILE_TYPE = @as(c_long, 222);
pub const CRYPT_RDN_ATTR_OID_GROUP_ID = 5;
pub const PRINTER_NOTIFY_FIELD_AVERAGE_PPM = 21;
pub const CTRY_PANAMA = 507;
pub const CERT_OCSP_RESPONSE_PROP_ID = 70;
pub const CERT_RDN_UNICODE_STRING = 12;
pub const SEC_E_OK = if (@typeId(@typeOf(@as(c_long, 0))) == @import("builtin").TypeId.Pointer) @ptrCast(HRESULT, @as(c_long, 0)) else if (@typeId(@typeOf(@as(c_long, 0))) == @import("builtin").TypeId.Int) @intToPtr(HRESULT, @as(c_long, 0)) else HRESULT(@as(c_long, 0));
pub const SPI_SETKEYBOARDSPEED = 11;
pub const PROCESSOR_ARCHITECTURE_IA64 = 6;
pub const ERROR_DS_AUX_CLS_TEST_FAIL = @as(c_long, 8389);
pub const WINEFS_SETUSERKEY_SET_CAPABILITIES = 1;
pub const TIMERR_BASE = 96;
pub const PKCS_CTL = if (@typeId(@typeOf(37)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 37) else if (@typeId(@typeOf(37)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 37) else LPCSTR(37);
pub const IMAGE_SCN_ALIGN_64BYTES = 7340032;
pub const DNS_ERROR_NODE_CREATION_FAILED = @as(c_long, 9703);
pub const APPCOMMAND_DELETE = 53;
pub const PROCESSOR_ARCHITECTURE_MSIL = 8;
pub const IO_COMPLETION_MODIFY_STATE = 2;
pub const ERROR_XMLDSIG_ERROR = @as(c_long, 1466);
pub const FACILITY_STORAGE = 3;
pub const CMSG_OID_CNG_IMPORT_CONTENT_ENCRYPT_KEY_FUNC = "CryptMsgDllCNGImportContentEncryptKey";
pub const PF_DECnet = AF_DECnet;
pub const PROCESS_CREATION_MITIGATION_POLICY_PROHIBIT_DYNAMIC_CODE_ALWAYS_ON = if (@typeId(@typeOf(i64 << 36)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << 36) else if (@typeId(@typeOf(i64 << 36)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << 36) else @as(c_uint, 1)(i64 << 36);
pub const JOY_BUTTON5 = @as(c_long, 16);
pub const NI_CHANGECANDIDATELIST = 19;
pub const CTRY_SLOVENIA = 386;
pub const IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT = 65536;
pub const SECURITY_IE_STATE_GREEN = 0;
pub const szOID_RSA_encryptedData = "1.2.840.113549.1.7.6";
pub const RPI_SMB2_FLAG_SERVERCAP_MULTICHANNEL = 8;
pub const RRF_RT_REG_MULTI_SZ = 32;
pub const PP_SMARTCARD_READER_ICON = 47;
pub const VK_NAVIGATION_RIGHT = 141;
pub const edt3 = 1154;
pub const NETSCAPE_SSL_CLIENT_AUTH_CERT_TYPE = 128;
pub const MOUSEWHEEL_ROUTING_HYBRID = 1;
pub const __GNUC_VA_LIST = 1;
pub const ERROR_DRIVER_BLOCKED = @as(c_long, 1275);
pub const CERT_ROOT_PROGRAM_FLAG_LSC = 64;
pub const PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_ALWAYS_OFF = 2 << 20;
pub const ERROR_EVT_QUERY_RESULT_INVALID_POSITION = @as(c_long, 15012);
pub const PROCESS_CREATION_MITIGATION_POLICY2_STRICT_CONTROL_FLOW_GUARD_ALWAYS_ON = if (@typeId(@typeOf(i64 << 8)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << 8) else if (@typeId(@typeOf(i64 << 8)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << 8) else @as(c_uint, 1)(i64 << 8);
pub const WIM_PROVIDER_CURRENT_VERSION = 1;
pub const LANG_TAMAZIGHT = 95;
pub const ERROR_EXTERNAL_SYSKEY_NOT_SUPPORTED = @as(c_long, 399);
pub const WM_INITDIALOG = 272;
pub const ERROR_NO_SUCH_MEMBER = @as(c_long, 1387);
pub const IO_REPARSE_TAG_DEDUP = @as(c_long, 2147483667);
pub const FACILITY_PARSE = 113;
pub const SCOPE_SECURITY_INFORMATION = @as(c_long, 64);
pub const IMAGE_DLLCHARACTERISTICS_NX_COMPAT = 256;
pub const STATE_SYSTEM_SELFVOICING = 524288;
pub const ERROR_INVALID_IMAGE_HASH = @as(c_long, 577);
pub const EnumPropsEx = EnumPropsExA;
pub const MAX_TRANSACTION_DESCRIPTION_LENGTH = 64;
pub const LoadKeyboardLayout = LoadKeyboardLayoutA;
pub const GETPAIRKERNTABLE = 258;
pub const IMAGE_REL_MIPS_REFWORDNB = 34;
pub const WDA_NONE = 0;
pub const STORAGE_ATTRIBUTE_VOLATILE = 8;
pub const WNNC_NET_AVID1 = 3801088;
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED_TO_TARGET_PROCESS = 4;
pub const ERROR_DS_DRA_REPL_PENDING = @as(c_long, 8477);
pub const PP_ENUMELECTROOTS = 26;
pub const UAS_EXACTLEGACY = 4096;
pub const szOID_ECC_CURVE_X962P256V1 = szOID_ECC_CURVE_P256;
pub const SUBLANG_MAPUDUNGUN_CHILE = 1;
pub const WN_ACCESS_DENIED = ERROR_ACCESS_DENIED;
pub const INITIAL_MXCSR = 8064;
pub const PRODUCT_CORE = 101;
pub const __SIZEOF_SHORT__ = 2;
pub const HEAP_TAIL_CHECKING_ENABLED = 32;
pub const PRODUCT_DATACENTER_NANO_SERVER = 143;
pub const CERT_STORE_PROV_SYSTEM_REGISTRY = CERT_STORE_PROV_SYSTEM_REGISTRY_W;
pub const DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED = 82;
pub const PSBTN_MAX = 6;
pub const STDAPIVCALLTYPE = __cdecl;
pub const DEVICEFAMILYINFOENUM_XBOXERA = 12;
pub const PAN_SERIF_PERP_SANS = 13;
pub const MAXDWORD = 4294967295;
pub const VS_FF_PRIVATEBUILD = @as(c_long, 8);
pub const PSINJECT_PAGENUMBER = 100;
pub const InterlockedIncrement16 = _InterlockedIncrement16;
pub const ERROR_REMOVE_FAILED = @as(c_long, 15610);
pub const CRYPT_ENCODE_ENABLE_UTF8PERCENT_FLAG = 262144;
pub const FILE_ATTRIBUTE_EA = 262144;
pub const RESOURCEMANAGER_RECOVER = 4;
pub const EWX_LOGOFF = 0;
pub const SECURITY_NETWORK_SERVICE_RID = @as(c_long, 20);
pub const DSS_PREFIXONLY = 1024;
pub const ERROR_LOG_CORRUPTION_DETECTED = @as(c_long, 6817);
pub const SPI_SETMOUSEVANISH = 4129;
pub const RPC_CALL_ATTRIBUTES_VERSION = 3;
pub const EVENTLOG_PAIRED_EVENT_INACTIVE = 16;
pub const WRITE_NV_MEMORY_FLAG_NO_DRAIN = 256;
pub const RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN = 33554432;
pub const AW_HIDE = 65536;
pub const EVENT_OBJECT_IME_SHOW = 32807;
pub const szOID_HPKP_DOMAIN_NAME_CTL = "1.3.6.1.4.1.311.10.3.60";
pub const SERVICE_START = 16;
pub const VarUI1FromInt = VarUI1FromI4;
pub const CERT_STORE_PROV_LDAP_W = if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 16) else if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 16) else LPCSTR(16);
pub const CONNDLG_RO_PATH = 1;
pub const GetLogColorSpace = GetLogColorSpaceA;
pub const CERT_STORE_CTRL_CANCEL_NOTIFY = 5;
pub const ERROR_ADDRESS_NOT_ASSOCIATED = @as(c_long, 1228);
pub const OUT_RASTER_PRECIS = 6;
pub const SERVICE_CONFIG_REQUIRED_PRIVILEGES_INFO = 6;
pub const ERROR_SXS_FILE_HASH_MISMATCH = @as(c_long, 14028);
pub const XSTATE_MASK_USER_VISIBLE_SUPERVISOR = XSTATE_MASK_CET_U;
pub const DMPAPER_NOTE = 18;
pub const XTYPF_NOBLOCK = 2;
pub const URLACTION_ACTIVEX_OVERRIDE_REPURPOSEDETECTION = 4615;
pub const _Deref_ret1_impl_ = p1;
pub const BACKUP_OBJECT_ID = 7;
pub const CERT_CHAIN_AUTO_LOG_CREATE_FLAG = 2;
pub const ERROR_CTX_NO_OUTBUF = @as(c_long, 7008);
pub const szOID_RDN_DUMMY_SIGNER = "1.3.6.1.4.1.311.21.9";
pub const PRODUCT_HOME_SERVER = 19;
pub const MDM_HDLCPPP_ML_2 = 2;
pub const CRYPT_FORMAT_RDN_UNQUOTE = 1024;
pub const __code_model_small_ = 1;
pub const SECURITY_VIRTUALACCOUNT_ID_RID_COUNT = @as(c_long, 6);
pub const DSS_RIGHT = 32768;
pub const CMSG_SIGNED_AND_ENVELOPED = 4;
pub const WM_QUEUESYNC = 35;
pub const GGL_LEVEL = 1;
pub const NCRYPT_SIGNATURE_LENGTH_PROPERTY = BCRYPT_SIGNATURE_LENGTH;
pub const __inout_ecount_nz_opt = size;
pub const ERROR_LOG_START_OF_LOG = @as(c_long, 6618);
pub const ABM_QUERYPOS = 2;
pub const SHSetUnreadMailCount = SHSetUnreadMailCountA;
pub const BCRYPT_HMAC_MD4_ALG_HANDLE = if (@typeId(@typeOf(305)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 305) else if (@typeId(@typeOf(305)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 305) else BCRYPT_ALG_HANDLE(305);
pub const ERROR_FILE_NOT_FOUND = @as(c_long, 2);
pub const CRYPT_FORMAT_SIMPLE = 1;
pub const OBJ_REGION = 8;
pub const DDE_FDEFERUPD = 16384;
pub const ERROR_CAPAUTHZ_CHANGE_TYPE = @as(c_long, 451);
pub const STATUS_INTERRUPTED = if (@typeId(@typeOf(@as(c_long, 3221226773))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221226773)) else if (@typeId(@typeOf(@as(c_long, 3221226773))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221226773)) else DWORD(@as(c_long, 3221226773));
pub const CONTAINER_ROOT_INFO_FLAG_BIND_TARGET_ROOT = 64;
pub const ERROR_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING = @as(c_long, 4433);
pub const DRIVER_USERMODE = 2;
pub const IMAGE_HOT_PATCH_ABSOLUTE = 180224;
pub const BINDF_NOCOPYDATA = BINDF_PULLDATA;
pub const __INT_FAST32_TYPE__ = int;
pub const IMAGE_REL_I386_REL16 = 2;
pub const DrawText = DrawTextA;
pub const PSPROTOCOL_BINARY = 3;
pub const JOB_OBJECT_LIMIT_NET_RATE_CONTROL = 1048576;
pub const SYSTEM_MANDATORY_LABEL_NO_READ_UP = 2;
pub const PAN_LETT_NORMAL_FLATTENED = 5;
pub const FILE_NOTIFY_CHANGE_DIR_NAME = 2;
pub const WAVE_FORMAT_48M16 = 16384;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_HASH = @as(c_long, 13837);
pub const IMAGE_ARCHIVE_LINKER_MEMBER = "/               ";
pub const VK_CONTROL = 17;
pub const ERROR_SEVERITY_INFORMATIONAL = 1073741824;
pub const SD_GLOBAL_CHANGE_TYPE_ENUM_SDS = 2 << 16;
pub const X942_OTHER_INFO = if (@typeId(@typeOf(52)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 52) else if (@typeId(@typeOf(52)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 52) else LPCSTR(52);
pub const ERROR_SHUTDOWN_IN_PROGRESS = @as(c_long, 1115);
pub const ERROR_RANGE_LIST_CONFLICT = @as(c_long, 627);
pub const FIND_RESOURCE_DIRECTORY_NAMES = 512;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT = 30;
pub const JOY_BUTTON2 = 2;
pub const ERROR_NOT_SUBSTED = @as(c_long, 137);
pub const COMMON_LVB_GRID_HORIZONTAL = 1024;
pub const CBR_9600 = 9600;
pub const edt4 = 1155;
pub const CTRY_JAPAN = 81;
pub const MAXGETHOSTSTRUCT = 1024;
pub const NEWFRAME = 1;
pub const ERROR_CLUSTERLOG_CORRUPT = @as(c_long, 5029);
pub const RI_MOUSE_HWHEEL = 2048;
pub const ReadLongPtrAcquire = ReadAcquire64;
pub const IMAGE_REL_ARM_SECTION = 14;
pub const ERROR_CLUSTER_MEMBERSHIP_HALT = @as(c_long, 5892);
pub const ERROR_EAS_DIDNT_FIT = @as(c_long, 275);
pub const SEF_AI_USE_EXTRA_PARAMS = 2048;
pub const szOID_CERT_STRONG_KEY_OS_CURRENT = szOID_CERT_STRONG_KEY_OS_1;
pub const STORAGE_PROTOCOL_SPECIFIC_NVME_ADMIN_COMMAND = 1;
pub const PROCESSOR_PPC_603 = 603;
pub const RPCRTAPI = DECLSPEC_IMPORT;
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_FS_SYSTEM_FILE = 4;
pub const NCRYPT_PROTECTED_KEY_BLOB_MAGIC = 1263817296;
pub const ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE = 11;
pub const VarUintFromStr = VarUI4FromStr;
pub const MCI_NOTIFY_ABORTED = 4;
pub const RemoveProp = RemovePropA;
pub const FALT = 16;
pub const ERROR_LUIDS_EXHAUSTED = @as(c_long, 1334);
pub const szOID_RDN_TPM_MANUFACTURER = "2.23.133.2.1";
pub const SUBLANG_ENGLISH_INDIA = 16;
pub const FAST_FAIL_CONTROL_INVALID_RETURN_ADDRESS = 57;
pub const WNNC_NET_KNOWARE = 3080192;
pub const NCRYPT_USE_VIRTUAL_ISOLATION_FLAG = 131072;
pub const PS_DOT = 2;
pub const szOID_EV_RDN_STATE_OR_PROVINCE = "1.3.6.1.4.1.311.60.2.1.2";
pub const VK_GAMEPAD_LEFT_TRIGGER = 201;
pub const PageSetupDlg = PageSetupDlgA;
pub const LANG_FINNISH = 11;
pub const CERT_CHAIN_DISABLE_OPT_IN_SERVER_AUTH_WEAK_FLAG = 262144;
pub const PID_ILLEGAL = 4294967295;
pub const SE_OWNER_DEFAULTED = 1;
pub const ERROR_DS_COMPARE_FALSE = @as(c_long, 8229);
pub const CDERR_NOHOOK = 11;
pub const szOID_OIWSEC_dhCommMod = "1.3.14.3.2.16";
pub const MM_WOM_DONE = 957;
pub const DeleteMonitor = DeleteMonitorA;
pub const STATUS_ASSERTION_FAILURE = if (@typeId(@typeOf(@as(c_long, 3221226528))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221226528)) else if (@typeId(@typeOf(@as(c_long, 3221226528))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221226528)) else DWORD(@as(c_long, 3221226528));
pub const CERT_SERIALIZABLE_KEY_CONTEXT_PROP_ID = 117;
pub const szOID_PKCS_10 = "1.2.840.113549.1.10";
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN = 6;
pub const CERT_TRUST_HAS_NOT_PERMITTED_NAME_CONSTRAINT = 16384;
pub const UNW_FLAG_EHANDLER = 1;
pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE = @as(c_long, 13908);
pub const SetVolumeMountPoint = SetVolumeMountPointA;
pub const WAVE_FORMAT_2S08 = 32;
pub const PDCAP_D3_SUPPORTED = 8;
pub const PROV_RSA_SIG = 2;
pub const FILE_DEVICE_NAMED_PIPE = 17;
pub const IDCONTINUE = 11;
pub const BM_GETCHECK = 240;
pub const POINTER_MESSAGE_FLAG_FOURTHBUTTON = 128;
pub const IMAGE_SYM_TYPE_FLOAT = 6;
pub const MCI_VD_GETDEVCAPS_SLOW_RATE = @as(c_long, 16388);
pub const SAVE_ATTRIBUTE_VALUES = 211;
pub const READ_THRESHOLD_BUFFER_SIZE = 512;
pub const NETINFO_PRINTERRED = 8;
pub const CDERR_REGISTERMSGFAIL = 12;
pub const SYMBOL_CHARSET = 2;
pub const STATUS_STACK_BUFFER_OVERRUN = if (@typeId(@typeOf(@as(c_long, 3221226505))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221226505)) else if (@typeId(@typeOf(@as(c_long, 3221226505))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221226505)) else DWORD(@as(c_long, 3221226505));
pub const STRETCH_ORSCANS = WHITEONBLACK;
pub const PBT_APMQUERYSUSPEND = 0;
pub const CB_FINDSTRINGEXACT = 344;
pub const EVENT_OBJECT_LIVEREGIONCHANGED = 32793;
pub const FKF_HOTKEYACTIVE = 4;
pub const PD_USELARGETEMPLATE = 268435456;
pub const IMAGE_REL_AM_REL32_1 = 5;
pub const VOLUME_NAME_GUID = 1;
pub const DialogBoxIndirectParam = DialogBoxIndirectParamA;
pub const ERROR_CANNOT_ABORT_TRANSACTIONS = @as(c_long, 6848);
pub const CERT_CHAIN_FIND_BY_ISSUER_COMPARE_KEY_FLAG = 1;
pub const CERT_ID_SHA1_HASH = 3;
pub const EXTENDED_STARTUPINFO_PRESENT = 524288;
pub const DC_ACTIVE = 1;
pub const URL_OID_CTL_ISSUER = if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 3) else if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 3) else LPCSTR(3);
pub const IMAGE_REL_CEF_SECREL = 5;
pub const ODS_INACTIVE = 128;
pub const X3_IMM39_1_INST_WORD_POS_X = 0;
pub const BCRYPT_DESX_CFB_ALG_HANDLE = if (@typeId(@typeOf(577)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 577) else if (@typeId(@typeOf(577)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 577) else BCRYPT_ALG_HANDLE(577);
pub const STGM_READWRITE = @as(c_long, 2);
pub const LANG_SAKHA = 133;
pub const WM_ERASEBKGND = 20;
pub const MARSHAL_S_FIRST = @as(c_long, 262432);
pub const ALG_TYPE_DH = 5 << 9;
pub const KEYBOARD_OVERRUN_MAKE_CODE = 255;
pub const SHOW_OPENNOACTIVATE = 4;
pub const GCPCLASS_HEBREW = 2;
pub const IMAGE_FILE_MACHINE_POWERPC = 496;
pub const PROCESS_CREATION_DESKTOP_APP_BREAKAWAY_OVERRIDE = 4;
pub const GL_ID_INPUTREADING = 36;
pub const GID_BEGIN = 1;
pub const ERROR_LAST_ADMIN = @as(c_long, 1322);
pub const STATE_SYSTEM_TRAVERSED = 8388608;
pub const BCRYPT_RC2_CFB_ALG_HANDLE = if (@typeId(@typeOf(625)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 625) else if (@typeId(@typeOf(625)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 625) else BCRYPT_ALG_HANDLE(625);
pub const LANG_TIBETAN = 81;
pub const OpenSCManager = OpenSCManagerA;
pub const VS_FFI_SIGNATURE = @as(c_long, 4277077181);
pub const WriteConsoleOutput = WriteConsoleOutputA;
pub const FR_HIDEMATCHCASE = 32768;
pub const ERROR_TOO_MANY_MODULES = @as(c_long, 214);
pub const DNS_ERROR_RCODE_NOTAUTH = @as(c_long, 9009);
pub const LOCALE_IINTLCURRDIGITS = 26;
pub const BCRYPT_CIPHER_INTERFACE = 1;
pub const NCRYPT_AES_ALGORITHM_GROUP = NCRYPT_AES_ALGORITHM;
pub const RECOVERED_READS_VALID = 4;
pub const PAN_PROP_MONOSPACED = 9;
pub const SECTION_MAP_EXECUTE_EXPLICIT = 32;
pub const FILE_TYPE_NOTIFICATION_FLAG_USAGE_END = 2;
pub const IE_HARDWARE = -10;
pub const PERF_COUNTER_VALUE = 0;
pub const CERT_STORE_PROV_FREE_FIND_CTL_FUNC = 21;
pub const JOY_BUTTON3 = 4;
pub const LOCALE_UNASSIGNED_LCID = LOCALE_CUSTOM_UNSPECIFIED;
pub const SCRUB_DATA_INPUT_FLAG_RESUME = 1;
pub const PP_ADMIN_PIN = 31;
pub const ERROR_RUNLEVEL_SWITCH_AGENT_TIMEOUT = @as(c_long, 15403);
pub const CONSOLE_REAL_INPUT_HANDLE = if (@typeId(@typeOf(-3)) == @import("builtin").TypeId.Pointer) @ptrCast(LongToHandle, -3) else if (@typeId(@typeOf(-3)) == @import("builtin").TypeId.Int) @intToPtr(LongToHandle, -3) else LongToHandle(-3);
pub const ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER = @as(c_long, 8517);
pub const SUBLANG_ARABIC_QATAR = 16;
pub const IMAGE_BITMAP = 0;
pub const SUBLANG_SAMI_SOUTHERN_SWEDEN = 7;
pub const edt5 = 1156;
pub const TOKEN_QUERY_SOURCE = 16;
pub const DMDO_DEFAULT = 0;
pub const SE_ERR_ASSOCINCOMPLETE = 27;
pub const MKF_HOTKEYACTIVE = 4;
pub const RPC_S_INVALID_RPC_PROTSEQ = @as(c_long, 1704);
pub const IMAGE_SYM_CLASS_REGISTER_PARAM = 17;
pub const QueryFullProcessImageName = QueryFullProcessImageNameA;
pub const ABE_BOTTOM = 3;
pub const JOB_OBJECT_LIMIT_SUBSET_AFFINITY = 16384;
pub const MIXERCONTROL_CT_UNITS_PERCENT = @as(c_long, 327680);
pub const ERROR_CTX_MODEM_INF_NOT_FOUND = @as(c_long, 7009);
pub const FILE_RENAME_FLAG_SUPPRESS_PIN_STATE_INHERITANCE = 4;
pub const ELEMENT_STATUS_EXCEPT = 4;
pub const OBJECT_INHERIT_ACE = 1;
pub const ERROR_IPSEC_IKE_GETSPIFAIL = @as(c_long, 13857);
pub const STREAM_NORMAL_ATTRIBUTE = 0;
pub const SUBLANG_DARI_AFGHANISTAN = 1;
pub const WH_MOUSE = 7;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT = 59;
pub const PD_PAGENUMS = 2;
pub const FAST_FAIL_INVALID_IMAGE_BASE = 24;
pub const SOUND_SYSTEM_WARNING = 6;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM = 55;
pub const IMAGE_SCN_MEM_READ = 1073741824;
pub const ERROR_DS_DSA_MUST_BE_INT_MASTER = @as(c_long, 8342);
pub const VK_DECIMAL = 110;
pub const VerLanguageName = VerLanguageNameA;
pub const CERT_ARCHIVED_KEY_HASH_PROP_ID = 65;
pub const ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS = @as(c_long, 5053);
pub const TRY_AGAIN = WSATRY_AGAIN;
pub const TRANSACTION_NOTIFY_RECOVER_QUERY = 2048;
pub const PROCESS_CREATION_MITIGATION_POLICY_CONTROL_FLOW_GUARD_DEFER = if (@typeId(@typeOf(i64 << 40)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), i64 << 40) else if (@typeId(@typeOf(i64 << 40)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), i64 << 40) else @as(c_uint, 0)(i64 << 40);
pub const PURGE_TXABORT = 1;
pub const szOID_OWNER = "2.5.4.32";
pub const RpcNsGroupMbrAdd = RpcNsGroupMbrAddA;
pub const ERROR_INVALID_SERVICE_LOCK = @as(c_long, 1071);
pub const PSINJECT_BOUNDINGBOX = 9;
pub const SPI_SETMENUUNDERLINES = SPI_SETKEYBOARDCUES;
pub const VK_HANJA = 25;
pub const szOID_OIWDIR_HASH = "1.3.14.7.2.2";
pub const CERT_CASE_INSENSITIVE_IS_RDN_ATTRS_FLAG = 2;
pub const CERT_FIND_ISSUER_STR = CERT_FIND_ISSUER_STR_W;
pub const RpcBindingSetAuthInfoEx = RpcBindingSetAuthInfoExA;
pub const GCP_USEKERNING = 8;
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_RID_COUNT = 9;
pub const IMAGE_FILE_MACHINE_TRICORE = 1312;
pub const ARW_HIDE = @as(c_long, 8);
pub const ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION = @as(c_long, 8492);
pub const SM_CXMINIMIZED = 57;
pub const SM_CYSIZEFRAME = SM_CYFRAME;
pub const FAST_FAIL_INVALID_FILE_OPERATION = 42;
pub const SCS_POSIX_BINARY = 4;
pub const VOLUME_SESSION_OPEN = 4;
pub const SE_GROUP_DEFAULTED = 2;
pub const VOS_OS232_PM32 = @as(c_long, 196611);
pub const _WIN32_WINNT_LONGHORN = 1536;
pub const ERROR_IPSEC_IKE_NO_PUBLIC_KEY = @as(c_long, 13828);
pub const _WIN32_IE_IE60SP2 = 1539;
pub const TA_UPDATECP = 1;
pub const EFS_DROP_ALTERNATE_STREAMS = 16;
pub const GCP_GLYPHSHAPE = 16;
pub const DMBIN_ONLYONE = 1;
pub const IMAGE_DIRECTORY_ENTRY_EXPORT = 0;
pub const REG_HIVE_NO_RM = @as(c_long, 256);
pub const NCRYPT_TPM_PSS_SALT_SIZE_MAXIMUM = 1;
pub const ERROR_INVALID_DLL = @as(c_long, 1154);
pub const LC_INTERIORS = 128;
pub const SBS_BOTTOMALIGN = @as(c_long, 4);
pub const NCRYPT_CLAIM_AUTHORITY_AND_SUBJECT = 3;
pub const GL_ID_NODICTIONARY = 16;
pub const R2_MASKNOTPEN = 3;
pub const ERROR_CLOUD_FILE_CONNECTED_PROVIDER_ONLY = @as(c_long, 382);
pub const ERROR_OPLOCK_NOT_GRANTED = @as(c_long, 300);
pub const SCardGetReaderDeviceInstanceId = SCardGetReaderDeviceInstanceIdA;
pub const SPI_SETGRADIENTCAPTIONS = 4105;
pub const szOID_RSA_signingTime = "1.2.840.113549.1.9.5";
pub const LBS_NOINTEGRALHEIGHT = @as(c_long, 256);
pub const DC_ORIENTATION = 17;
pub const InterlockedExchangeAdd8 = _InterlockedExchangeAdd8;
pub const DSPRINT_PENDING = 2147483648;
pub const IME_CAND_CODE = 2;
pub const NCRYPT_SP80056A_CONCAT_ALGORITHM = BCRYPT_SP80056A_CONCAT_ALGORITHM;
pub const CHANGER_BAR_CODE_SCANNER_INSTALLED = 1;
pub const CB_GETEXTENDEDUI = 342;
pub const ERROR_INCORRECT_SIZE = @as(c_long, 1462);
pub const CFSTR_MIME_PDF = if (@typeId(@typeOf("application/pdf")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "application/pdf") else if (@typeId(@typeOf("application/pdf")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "application/pdf") else TEXT("application/pdf");
pub const ERROR_DS_DRA_INTERNAL_ERROR = @as(c_long, 8442);
pub const MA_NOACTIVATEANDEAT = 4;
pub const ELEMENT_STATUS_EXENAB = 16;
pub const GA_ROOT = 2;
pub const ERROR_LOG_FULL_HANDLER_IN_PROGRESS = @as(c_long, 6638);
pub const TIMESTAMP_STATUS_REVOCATION_WARNING = 4;
pub const SORT_INVARIANT_MATH = 1;
pub const MessageBoxIndirect = MessageBoxIndirectA;
pub const CDERR_NOTEMPLATE = 3;
pub const CERT_SUBJECT_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = 85;
pub const EnumPrintProcessors = EnumPrintProcessorsA;
pub const FILE_LAYOUT_NAME_ENTRY_DOS = 2;
pub const ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING = @as(c_long, 304);
pub const ERROR_DRIVER_FAILED_SLEEP = @as(c_long, 633);
pub const ERROR_PACKAGE_REPOSITORY_CORRUPTED = @as(c_long, 15614);
pub const WSAENOPROTOOPT = @as(c_long, 10042);
pub const ERROR_UNWIND_CONSOLIDATE = @as(c_long, 684);
pub const ERROR_WMI_READ_ONLY = @as(c_long, 4213);
pub const MUI_MERGE_SYSTEM_FALLBACK = 16;
pub const CERT_STORE_PROV_FILE = if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 3) else if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 3) else LPCSTR(3);
pub const MEM_PHYSICAL = 4194304;
pub const DceErrorInqText = DceErrorInqTextA;
pub const ERROR_TOO_MANY_SEMAPHORES = @as(c_long, 100);
pub const WSANOTINITIALISED = @as(c_long, 10093);
pub const FACILITY_PIX = 2748;
pub const ERROR_BUS_RESET = @as(c_long, 1111);
pub const PROCESSOR_INTEL_486 = 486;
pub const SHTDN_REASON_MAJOR_HARDWARE = 65536;
pub const WTS_SESSION_UNLOCK = 8;
pub const CERT_QUERY_CONTENT_PKCS7_UNSIGNED = 9;
pub const ERROR_DIRECTORY_NOT_RM = @as(c_long, 6803);
pub const MM_STREAM_OPEN = 980;
pub const CRYPT_MODE_CFB = 4;
pub const DOMAIN_GROUP_RID_ENTERPRISE_KEY_ADMINS = @as(c_long, 527);
pub const NRC_NOWILD = 21;
pub const PKCS12_NO_PERSIST_KEY = 32768;
pub const CMSG_OID_CNG_EXPORT_KEY_TRANS_FUNC = "CryptMsgDllCNGExportKeyTrans";
pub const CERT_COMPARE_SHIFT = 16;
pub const OInetCombineIUri = CoInternetCombineIUri;
pub const START_PAGE_GENERAL = 4294967295;
pub const IMAGE_REL_SH3_DIRECT8_WORD = 4;
pub const C2_EUROPESEPARATOR = 4;
pub const edt6 = 1157;
pub const ERROR_FILE_OFFLINE = @as(c_long, 4350);
pub const CRYPT_GET_INSTALLED_OID_FUNC_FLAG = 1;
pub const _Analysis_assume_lock_acquired_ = lock;
pub const C1_XDIGIT = 128;
pub const POWER_DISCONNECTED_STANDBY_MODE_AGGRESSIVE = 1;
pub const NORM_LINGUISTIC_CASING = 134217728;
pub const Uri_HAS_AUTHORITY = 1 << Uri_PROPERTY_AUTHORITY;
pub const __UINT_FAST16_FMTu__ = "hu";
pub const ERROR_INVALID_KEYBOARD_HANDLE = @as(c_long, 1457);
pub const UpdateResource = UpdateResourceA;
pub const WM_QUERYNEWPALETTE = 783;
pub const MCI_GETDEVCAPS_HAS_AUDIO = @as(c_long, 2);
pub const FILE_SET_ENCRYPTION = 1;
pub const GetPrinter = GetPrinterA;
pub const CONNECT_LOCALDRIVE = 256;
pub const DEVICE_DATA_SET_LBP_STATE_PARAMETERS_VERSION_V1 = DEVICE_DSM_PARAMETERS_V1;
pub const CONTEXT_EXCEPTION_REPORTING = @as(c_long, 2147483648);
pub const ERROR_INVALID_SHOWWIN_COMMAND = @as(c_long, 1449);
pub const DNS_STATUS_DOTTED_NAME = @as(c_long, 9558);
pub const REFS_SMR_VOLUME_GC_PARAMETERS_VERSION_V1 = 1;
pub const CERT_CREATE_SELFSIGN_NO_KEY_INFO = 2;
pub const POWER_DISCONNECTED_STANDBY_MODE_NORMAL = 0;
pub const PRINTER_NOTIFY_FIELD_TOTAL_PAGES = 22;
pub const SECURITY_AUTHENTICATION_SERVICE_ASSERTED_RID = @as(c_long, 2);
pub const SO_CONNOPTLEN = 28677;
pub const ERROR_PACKAGE_NOT_SUPPORTED_ON_FILESYSTEM = @as(c_long, 15635);
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_BASE_RECORD = 134217728;
pub const SERVICE_CONTROL_POWEREVENT = 13;
pub const IMAGE_REL_IA64_DIR32NB = 16;
pub const EXPENTRY = CALLBACK;
pub const NRC_NORESOURCES = 56;
pub const XST_CONNECTED = 2;
pub const SORTED_CTL_EXT_FLAGS_OFFSET = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast([*c]0, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr([*c]0, 4) else ([*c]0)(4);
pub const RegCreateKeyEx = RegCreateKeyExA;
pub const RPC_C_HTTP_AUTHN_SCHEME_DIGEST = 8;
pub const _WIN32_IE_WIN10 = _WIN32_IE_IE110;
pub const TIMESTAMP_STATUS_WAITING = 3;
pub const MDM_HDLCPPP_AUTH_PAP = 2;
pub const PT_BEZIERTO = 4;
pub const ACTIVATIONCONTEXTINFOCLASS = ACTIVATION_CONTEXT_INFO_CLASS;
pub const BuildCommDCBAndTimeouts = BuildCommDCBAndTimeoutsA;
pub const SHGFI_LINKOVERLAY = 32768;
pub const RRF_SUBKEY_WOW6464KEY = 65536;
pub const USER_CALL_IS_ASYNC = 256;
pub const FILE_FLAG_BACKUP_SEMANTICS = 33554432;
pub const __crt_typefix = ctype;
pub const DMPAPER_B5 = 13;
pub const SEF_SACL_AUTO_INHERIT = 2;
pub const DNS_ERROR_NSEC_INCOMPATIBLE_WITH_NSEC3_RSA_SHA1 = @as(c_long, 9130);
pub const ERROR_INVALID_REPARSE_DATA = @as(c_long, 4392);
pub const LANG_SINHALESE = 91;
pub const S_LEGATO = 1;
pub const ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED = @as(c_long, 8204);
pub const MIIM_ID = 2;
pub const ERROR_DS_SEMANTIC_ATT_TEST = @as(c_long, 8383);
pub const LANG_MALAY = 62;
pub const CS_E_FIRST = @as(c_long, 2147746148);
pub const LOCALE_IFIRSTDAYOFWEEK = 4108;
pub const SECURITY_CRED_TYPE_BASE_RID = @as(c_long, 65);
pub const szOID_LICENSE_SERVER = "1.3.6.1.4.1.311.10.6.2";
pub const ERROR_APPEXEC_UNEXPECTED_PROCESS_REGISTRATION = @as(c_long, 3063);
pub const GMEM_VALID_FLAGS = 32626;
pub const IME_SMODE_SINGLECONVERT = 2;
pub const TRANSACTION_NOTIFY_COMMIT_COMPLETE = 64;
pub const CRYPT_DECRYPT = 2;
pub const ERROR_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION = @as(c_long, 4429);
pub const IFX_RSA_KEYGEN_VUL_NOT_AFFECTED = 0;
pub const SO_USELOOPBACK = 64;
pub const RpcServerInterfaceGroupCreate = RpcServerInterfaceGroupCreateA;
pub const szOID_CMC_ID_POP_LINK_WITNESS = "1.3.6.1.5.5.7.7.23";
pub const PERF_TEXT_UNICODE = 0;
pub const ERROR_INVALID_AT_INTERRUPT_TIME = @as(c_long, 104);
pub const GW_HWNDFIRST = 0;
pub const NTDDI_WIN10 = 167772160;
pub const GWLP_USERDATA = -21;
pub const DBG_CONTINUE = if (@typeId(@typeOf(@as(c_long, 65538))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 65538)) else if (@typeId(@typeOf(@as(c_long, 65538))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 65538)) else DWORD(@as(c_long, 65538));
pub const __has_lock_level = level;
pub const KDF_TLS_PRF_PROTOCOL = 7;
pub const CBR_4800 = 4800;
pub const LOGON32_LOGON_UNLOCK = 7;
pub const CERT_ALT_NAME_DIRECTORY_NAME = 5;
pub const PROPSHEETPAGE_V2_SIZE = PROPSHEETPAGEA_V2_SIZE;
pub const LANG_PORTUGUESE = 22;
pub const WM_THEMECHANGED = 794;
pub const APPMODEL_ERROR_DYNAMIC_PROPERTY_INVALID = @as(c_long, 15705);
pub const __deref_opt_out_ecount_nz_opt = size;
pub const GCP_JUSTIFY = @as(c_long, 65536);
pub const REMOTE_PROTOCOL_INFO_FLAG_PERSISTENT_HANDLE = 4;
pub const POINTER_FLAG_CAPTURECHANGED = 2097152;
pub const DLGC_WANTARROWS = 1;
pub const SM_CYMINTRACK = 35;
pub const ALG_SID_PCT1_MASTER = 4;
pub const MNC_SELECT = 3;
pub const DNS_ERROR_NSEC3_NAME_COLLISION = @as(c_long, 9129);
pub const ua_tcscpy = strcpy;
pub const ERROR_SXS_XML_E_INVALIDATROOTLEVEL = @as(c_long, 14055);
pub const DFCS_SCROLLDOWN = 1;
pub const MCI_VD_GETDEVCAPS_CLV = @as(c_long, 65536);
pub const SPI_GETCURSORSHADOW = 4122;
pub const EXCEPTION_EXECUTE_FAULT = 8;
pub const ERROR_CPU_SET_INVALID = @as(c_long, 813);
pub const FACILITY_EAS = 85;
pub const META_STRETCHDIB = 3907;
pub const PENARBITRATIONTYPE_WIN8 = 1;
pub const CONTEXT_OID_CERTIFICATE = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 1) else LPCSTR(1);
pub const szOID_ENROLLMENT_CSP_PROVIDER = "1.3.6.1.4.1.311.13.2.2";
pub const DFCS_BUTTONRADIOIMAGE = 1;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAMS_WITH_NO_CLUSTERS_ALLOCATED = 32;
pub const ERROR_SEEK = @as(c_long, 25);
pub const URL_OID_CERTIFICATE_FRESHEST_CRL = if (@typeId(@typeOf(6)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 6) else if (@typeId(@typeOf(6)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 6) else LPCSTR(6);
pub const RPC_CALL_ATTRIBUTES_V2 = RPC_CALL_ATTRIBUTES_V2_A;
pub const JOY_BUTTON1 = 1;
pub const ALG_CLASS_KEY_EXCHANGE = 5 << 13;
pub const ERROR_LM_CROSS_ENCRYPTION_REQUIRED = @as(c_long, 1390);
pub const CRYPT_OID_OPEN_STORE_PROV_FUNC = "CertDllOpenStoreProv";
pub const LOCALE_RETURN_NUMBER = 536870912;
pub const WNFMT_CONNECTION = 32;
pub const OCSP_SIGNED_REQUEST = if (@typeId(@typeOf(65)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 65) else if (@typeId(@typeOf(65)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 65) else LPCSTR(65);
pub const EAGAIN = 11;
pub const edt7 = 1158;
pub const SCARD_T1_EPILOGUE_LENGTH = 2;
pub const URLACTION_SHELL_INSTALL_DTITEMS = 6144;
pub const PD_ENABLESETUPTEMPLATEHANDLE = 131072;
pub const ATTR_INPUT = 0;
pub const MDM_V110_SPEED_4DOT8K = 3;
pub const MIXER_GETLINECONTROLSF_ALL = @as(c_long, 0);
pub const InterlockedExchangeAcquire64 = InterlockedExchange64;
pub const APC_LEVEL = 1;
pub const DNS_ERROR_BAD_KEYMASTER = @as(c_long, 9122);
pub const MINSHORT = 32768;
pub const ERROR_BAD_UNIT = @as(c_long, 20);
pub const PROCESS_CREATION_MITIGATION_POLICY2_LOADER_INTEGRITY_CONTINUITY_DEFER = if (@typeId(@typeOf(i64 << 4)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), i64 << 4) else if (@typeId(@typeOf(i64 << 4)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), i64 << 4) else @as(c_uint, 0)(i64 << 4);
pub const ERROR_STATE_SETTING_NAME_SIZE_LIMIT_EXCEEDED = @as(c_long, 15817);
pub const FILE_DEVICE_DVD = 51;
pub const NCRYPT_KEY_ACCESS_POLICY_VERSION = 1;
pub const USN_REASON_INDEXABLE_CHANGE = 16384;
pub const PF_RDTSC_INSTRUCTION_AVAILABLE = 8;
pub const IMPLTYPEFLAG_FDEFAULTVTABLE = 8;
pub const MCI_NOTIFY_FAILURE = 8;
pub const CTRY_DENMARK = 45;
pub const PARTITION_MSFT_RECOVERY = 39;
pub const IMAGE_FILE_DEBUG_STRIPPED = 512;
pub const ERROR_NTLM_BLOCKED = @as(c_long, 1937);
pub const ERROR_MRM_DUPLICATE_ENTRY = @as(c_long, 15119);
pub const IP_DEFAULT_MULTICAST_LOOP = 1;
pub const BCRYPT_ECDH_PRIVATE_P384_MAGIC = 877347653;
pub const FACILITY_CMI = 54;
pub const SHGSI_SYSICONINDEX = SHGFI_SYSICONINDEX;
pub const ERROR_EVT_PUBLISHER_DISABLED = @as(c_long, 15037);
pub const ImmGetDescription = ImmGetDescriptionA;
pub const ERROR_DLL_INIT_FAILED_LOGOFF = @as(c_long, 624);
pub const ERROR_NON_ACCOUNT_SID = @as(c_long, 1257);
pub const MCI_BREAK_OFF = @as(c_long, 1024);
pub const IMAGE_HOT_PATCH_DYNAMIC_VALUE = 491520;
pub const PSNRET_MESSAGEHANDLED = 3;
pub const LOCK_UNLOCK_KEYPAD = 4;
pub const PRINTER_CHANGE_WRITE_JOB = 2048;
pub const __analysis_suppress_lock_checking = lock;
pub const ERROR_CRASH_DUMP = @as(c_long, 753);
pub const DM_SPECVERSION = 1025;
pub const MDM_V110_SPEED_12DOT0K = 5;
pub const NCRYPT_ALLOW_ALL_USAGES = 16777215;
pub const SPI_SETDROPSHADOW = 4133;
pub const SERVICE_CONTINUE_PENDING = 5;
pub const ERROR_DS_NOT_CLOSEST = @as(c_long, 8588);
pub const RESOURCE_ENUM_VALIDATE = 8;
pub const NCRYPT_SHA1_ALGORITHM = BCRYPT_SHA1_ALGORITHM;
pub const ST_BLOCKNEXT = 128;
pub const __RPC_USER = __stdcall;
pub const CERT_VERIFY_REV_CHAIN_FLAG = 1;
pub const szOID_OIWSEC_shaRSA = "1.3.14.3.2.15";
pub const PSH_HEADER = 524288;
pub const THREAD_POWER_THROTTLING_EXECUTION_SPEED = 1;
pub const DRV_CANCEL = DRVCNF_CANCEL;
pub const SC_SEPARATOR = 61455;
pub const FACILITY_UI = 42;
pub const ERROR_CHECKING_FILE_SYSTEM = @as(c_long, 712);
pub const CF_SYLK = 4;
pub const DNS_ERROR_STANDBY_KEY_NOT_PRESENT = @as(c_long, 9117);
pub const EVENT_OBJECT_SELECTIONADD = 32775;
pub const SOFTKEYBOARD_TYPE_T1 = 1;
pub const EMR_FLATTENPATH = 65;
pub const DMPAPER_B4 = 12;
pub const InterlockedBitTestAndReset64NoFence = _interlockedbittestandreset64;
pub const __clang_patchlevel__ = 0;
pub const ERROR_APPX_FILE_NOT_ENCRYPTED = @as(c_long, 409);
pub const IE_DEFAULT = -5;
pub const GGL_INDEX = 2;
pub const ETO_NUMERICSLATIN = 2048;
pub const SUBLANG_SERBIAN_CYRILLIC = 3;
pub const GetSaveFileName = GetSaveFileNameA;
pub const WT_EXECUTEINIOTHREAD = 1;
pub const ERROR_CTX_NO_FORCE_LOGOFF = @as(c_long, 7063);
pub const ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA = @as(c_long, 8465);
pub const DNS_ERROR_DP_ALREADY_ENLISTED = @as(c_long, 9904);
pub const SECURITY_NULL_RID = @as(c_long, 0);
pub const STATE_SYSTEM_ALERT_LOW = 67108864;
pub const ERROR_CAPAUTHZ_NO_POLICY = @as(c_long, 454);
pub const IMAGE_DIRECTORY_ENTRY_SECURITY = 4;
pub const WMSZ_TOPLEFT = 4;
pub const GL_ID_INPUTCODE = 38;
pub const CERT_TRUST_IS_UNTRUSTED_ROOT = 32;
pub const PROCESS_CREATION_MITIGATION_POLICY2_LOADER_INTEGRITY_CONTINUITY_AUDIT = if (@typeId(@typeOf(i64 << 4)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 4) else if (@typeId(@typeOf(i64 << 4)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 4) else @as(c_uint, 3)(i64 << 4);
pub const LANG_MOHAWK = 124;
pub const S_NORMAL = 0;
pub const SCARD_STATE_CHANGED = 2;
pub const SM_CYMINIMIZED = 58;
pub const CopyEnhMetaFile = CopyEnhMetaFileA;
pub const DST_PREFIXTEXT = 2;
pub const PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_MASK = 3 << 16;
pub const NCRYPTBUFFER_PKCS_ATTRS = 44;
pub const IME_CMODE_SYMBOL = 1024;
pub const PROCESSOR_ARCHITECTURE_SHX = 4;
pub const CERT_FIND_CTL_USAGE = CERT_FIND_ENHKEY_USAGE;
pub const TRANSACTION_MANAGER_VOLATILE = 1;
pub const IMAGE_REL_AM_REL32_2 = 6;
pub const ERROR_FAIL_RESTART = @as(c_long, 352);
pub const PRINTER_STATUS_DOOR_OPEN = 4194304;
pub const szOID_INFOSEC_mosaicKMandSig = "2.16.840.1.101.2.1.1.12";
pub const ERROR_CHILD_PROCESS_BLOCKED = @as(c_long, 367);
pub const szOID_POST_OFFICE_BOX = "2.5.4.18";
pub const WM_DPICHANGED_AFTERPARENT = 739;
pub const HCF_INDICATOR = 32;
pub const TAPE_CHECK_FOR_DRIVE_PROBLEM = @as(c_long, 2);
pub const DNS_INFO_NO_RECORDS = @as(c_long, 9501);
pub const SERVICE_MAIN_FUNCTION = SERVICE_MAIN_FUNCTIONA;
pub const _WIN32_IE_IE100 = 2560;
pub const ERROR_NOT_SAME_OBJECT = @as(c_long, 1656);
pub const LMEM_VALID_FLAGS = 3954;
pub const STATUS_THREAD_NOT_RUNNING = if (@typeId(@typeOf(@as(c_long, 3221226774))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221226774)) else if (@typeId(@typeOf(@as(c_long, 3221226774))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221226774)) else DWORD(@as(c_long, 3221226774));
pub const WAVE_FORMAT_4M16 = 1024;
pub const SYSTEM_FIXED_FONT = 16;
pub const FACILITY_CONFIGURATION = 33;
pub const ERROR_DS_ATT_SCHEMA_REQ_ID = @as(c_long, 8399);
pub const ERROR_RXACT_COMMIT_NECESSARY = @as(c_long, 678);
pub const TAPE_DRIVE_WRITE_PROTECT = 4096;
pub const PPM_FIRMWARE_ACPI1C2 = 1;
pub const szOID_INITIALS = "2.5.4.43";
pub const ERROR_NOT_OWNER = @as(c_long, 288);
pub const CF_DSPBITMAP = 130;
pub const CERT_COMPARE_ATTR = 3;
pub const SUBLANG_HUNGARIAN_HUNGARY = 1;
pub const SEF_DEFAULT_OWNER_FROM_PARENT = 32;
pub const SET_POLY_MODE = 4104;
pub const MMIO_DENYNONE = 64;
pub const OCSP_BASIC_BY_NAME_RESPONDER_ID = 1;
pub const SERVICE_RECOGNIZER_DRIVER = 8;
pub const MONO_FONT = 8;
pub const FADF_HAVEVARTYPE = 128;
pub const CLIP_DEFAULT_PRECIS = 0;
pub const ERROR_OBJECT_NO_LONGER_EXISTS = @as(c_long, 6807);
pub const HBMMENU_MBAR_RESTORE = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(HBITMAP, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(HBITMAP, 2) else HBITMAP(2);
pub const WriteProfileString = WriteProfileStringA;
pub const HTTRANSPARENT = -1;
pub const szOID_X957 = "1.2.840.10040";
pub const RPC_CALL_ATTRIBUTES_V3 = RPC_CALL_ATTRIBUTES_V3_A;
pub const _WIN32_IE_XPSP2 = _WIN32_IE_IE60SP2;
pub const SPI_SETPENDOCKTHRESHOLD = 129;
pub const ERROR_FULL_BACKUP = @as(c_long, 4004);
pub const DRV_RESTART = DRVCNF_RESTART;
pub const TIMESTAMP_NO_AUTH_RETRIEVAL = 131072;
pub const IME_ESC_MAX_KEY = 4101;
pub const DATA_E_FIRST = @as(c_long, 2147746096);
pub const URLACTION_INFODELIVERY_NO_ADDING_CHANNELS = 7424;
pub const ua_lstrcmpi = lstrcmpiA;
pub const CHECKJPEGFORMAT = 4119;
pub const DT_WORD_ELLIPSIS = 262144;
pub const THREAD_BASE_PRIORITY_MIN = -2;
pub const szOID_INFOSEC_sdnsTokenProtection = "2.16.840.1.101.2.1.1.7";
pub const TXFS_START_RM_FLAG_PREFER_AVAILABILITY = 8192;
pub const ERROR_CLUSTER_GUM_NOT_LOCKER = @as(c_long, 5085);
pub const CMSG_ENCRYPTED_FLAG = 1 << CMSG_ENCRYPTED;
pub const TIMESTAMP_STATUS_REVOKED = 5;
pub const MM_STREAM_DONE = 982;
pub const CTRY_IRAQ = 964;
pub const SE_SIGNING_LEVEL_ANTIMALWARE = SE_SIGNING_LEVEL_CUSTOM_3;
pub const PANOSE_COUNT = 10;
pub const EMARCH_ENC_I17_IMM41a_VAL_POS_X = 22;
pub const DNS_ERROR_RCODE = @as(c_long, 9504);
pub const SCARD_STATE_EXCLUSIVE = 128;
pub const DCX_NORESETATTRS = @as(c_long, 4);
pub const __DBL_HAS_INFINITY__ = 1;
pub const KP_PUB_EX_LEN = 28;
pub const PSINJECT_ENDSTREAM = 20;
pub const MCI_OVLY_STATUS_STRETCH = @as(c_long, 16386);
pub const __deref_out_ecount_nz = size;
pub const KP_OAEP_PARAMS = 36;
pub const IID_IOInetThreadSwitch = IID_IInternetThreadSwitch;
pub const DMLERR_ADVACKTIMEOUT = 16384;
pub const DATE_LTRREADING = 16;
pub const EMR_LINETO = 54;
pub const MFT_OWNERDRAW = MF_OWNERDRAW;
pub const PPM_FIRMWARE_PPC = 256;
pub const NCRYPT_MD4_ALGORITHM = BCRYPT_MD4_ALGORITHM;
pub const ALG_SID_SCHANNEL_MASTER_HASH = 2;
pub const VK_LSHIFT = 160;
pub const TOKEN_ADJUST_SESSIONID = 256;
pub const FILE_TYPE_NOTIFICATION_FLAG_USAGE_BEGIN = 1;
pub const ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET = @as(c_long, 14011);
pub const BCRYPT_RNG_USE_ENTROPY_IN_BUFFER = 1;
pub const BDR_SUNKENOUTER = 2;
pub const WSAECANCELLED = @as(c_long, 10103);
pub const CERT_SCARD_PIN_INFO_PROP_ID = 91;
pub const BACKGROUND_RED = 64;
pub const PERF_NO_UNIQUE_ID = -1;
pub const SM_CMETRICS = 97;
pub const SECURITY_MANDATORY_SYSTEM_RID = @as(c_long, 16384);
pub const GetPrivateProfileString = GetPrivateProfileStringA;
pub const VS_FF_DEBUG = @as(c_long, 1);
pub const GC_ZOOM = 1;
pub const ERROR_CANNOT_GRANT_REQUESTED_OPLOCK = @as(c_long, 801);
pub const WM_IME_ENDCOMPOSITION = 270;
pub const DI_APPBANDING = 1;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT_2 = @as(c_long, 1177);
pub const STATUS_ENTRYPOINT_NOT_FOUND = if (@typeId(@typeOf(@as(c_long, 3221225785))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225785)) else if (@typeId(@typeOf(@as(c_long, 3221225785))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225785)) else DWORD(@as(c_long, 3221225785));
pub const LCMAP_FULLWIDTH = 8388608;
pub const FILE_DISPOSITION_FLAG_IGNORE_READONLY_ATTRIBUTE = 16;
pub const IOCTL_DISK_BASE = FILE_DEVICE_DISK;
pub const SS_LEFT = @as(c_long, 0);
pub const ERROR_DS_OBJ_CLASS_NOT_SUBCLASS = @as(c_long, 8372);
pub const FILE_DEVICE_BATTERY = 41;
pub const ERROR_INVALID_BLOCK_LENGTH = @as(c_long, 1106);
pub const MCI_NOTIFY = @as(c_long, 1);
pub const EVENT_OBJECT_END = 33023;
pub const DISC_UPDATE_PROFILE = 1;
pub const _PUNCT = 16;
pub const RpcNsMgmtEntryCreate = RpcNsMgmtEntryCreateA;
pub const CTRY_ZIMBABWE = 263;
pub const szOID_PROTECTED_PROCESS_SIGNER = "1.3.6.1.4.1.311.10.3.24";
pub const _WIN32_IE_IE60SP1 = 1537;
pub const SCardForgetReader = SCardForgetReaderA;
pub const DMPAPER_15X11 = 46;
pub const ERROR_DS_CANT_RETRIEVE_SD = @as(c_long, 8526);
pub const MIXERLINE_LINEF_DISCONNECTED = @as(c_long, 32768);
pub const DNS_ERROR_POLICY_LOCKED = @as(c_long, 9980);
pub const szOID_DN_QUALIFIER = "2.5.4.46";
pub const ERROR_DIRECTORY = @as(c_long, 267);
pub const SERVICE_PAUSED = 7;
pub const EnumResourceTypesEx = EnumResourceTypesExA;
pub const CONTAINER_ROOT_INFO_VALID_FLAGS = 511;
pub const SKF_LWINLATCHED = 1073741824;
pub const SS_BITMAP = @as(c_long, 14);
pub const FORMAT_MESSAGE_FROM_SYSTEM = 4096;
pub const ERROR_INVALID_FLAG_NUMBER = @as(c_long, 186);
pub const PD_USEDEVMODECOPIESANDCOLLATE = 262144;
pub const DNS_ERROR_INVALID_ZONE_OPERATION = @as(c_long, 9603);
pub const VK_GAMEPAD_RIGHT_SHOULDER = 199;
pub const CLIP_DFA_DISABLE = 4 << 4;
pub const PSH_DEFAULT = 0;
pub const MM_MIM_OPEN = 961;
pub const CTRY_HONDURAS = 504;
pub const XCLASS_DATA = 8192;
pub const Uri_HAS_RAW_URI = 1 << Uri_PROPERTY_RAW_URI;
pub const SECURITY_INSTALLER_CAPABILITY_RID_COUNT = 10;
pub const RPC_C_STATS_PKTS_IN = 2;
pub const GCS_RESULTCLAUSE = 4096;
pub const MDM_SHIFT_V120_ML = 6;
pub const szOID_ECC_CURVE_NISTP192 = "1.2.840.10045.3.1.1";
pub const GetConsoleAliasExesLength = GetConsoleAliasExesLengthA;
pub const WNNC_NET_QUINCY = 3670016;
pub const ERROR_RXACT_COMMITTED = @as(c_long, 744);
pub const PPM_FIRMWARE_ACPI1C3 = 2;
pub const N_BTMASK = 15;
pub const ERROR_PROCESS_IS_PROTECTED = @as(c_long, 1293);
pub const VK_DOWN = 40;
pub const CHANGER_RESERVED_BIT = 2147483648;
pub const SECURITY_DESCRIPTOR_REVISION = 1;
pub const UploadPrinterDriverPackage = UploadPrinterDriverPackageA;
pub const WMSZ_BOTTOM = 6;
pub const STORAGE_EVENT_NOTIFICATION_VERSION_V1 = 1;
pub const HSHELL_WINDOWREPLACING = 14;
pub const CERT_STORE_ADD_NEWER = 6;
pub const ERROR_DS_EXISTS_IN_RDNATTID = @as(c_long, 8598);
pub const IMAGE_DEBUG_MISC_EXENAME = 1;
pub const WS_EX_NOPARENTNOTIFY = @as(c_long, 4);
pub const CMC_FAIL_BAD_CERT_ID = 4;
pub const DRAWPATTERNRECT = 25;
pub const MCI_STATUS_CURRENT_TRACK = @as(c_long, 8);
pub const ABM_SETAUTOHIDEBAR = 8;
pub const MDM_ANALOG_V34 = 2;
pub const RTL_RUN_ONCE_INIT_FAILED = @as(c_ulong, 4);
pub const IMAGE_REL_BASED_HIGH = 1;
pub const JOB_STATUS_PAPEROUT = 64;
pub const ERROR_TRANSPORT_FULL = @as(c_long, 4328);
pub const SWP_FRAMECHANGED = 32;
pub const JOB_STATUS_RETAINED = 8192;
pub const FSCTL_INTEGRITY_FLAG_CHECKSUM_ENFORCEMENT_OFF = 1;
pub const SECURITY_BUILTIN_APP_PACKAGE_RID_COUNT = @as(c_long, 2);
pub const NCRYPTBUFFER_SSL_SESSION_HASH = 25;
pub const BACKUP_LINK = 5;
pub const PO_THROTTLE_NONE = 0;
pub const RpcNsMgmtEntryDelete = RpcNsMgmtEntryDeleteA;
pub const AF_ISO = 7;
pub const CERT_SMART_CARD_READER_PROP_ID = 101;
pub const INVALID_SET_FILE_POINTER = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, -1) else DWORD(-1);
pub const SPI_SETWAITTOKILLTIMEOUT = 123;
pub const GetNumberFormat = GetNumberFormatA;
pub const ERROR_CLUSTER_RESOURCE_VETOED_CALL = @as(c_long, 5955);
pub const SB_VERT = 1;
pub const ANSI_VAR_FONT = 12;
pub const SCardGetReaderCapabilities = SCardGetAttrib;
pub const CERT_CHAIN_OPTION_ENABLE_SIA_URL_RETRIEVAL = 4;
pub const TPM_RECURSE = @as(c_long, 1);
pub const CALLBACK_TYPEMASK = @as(c_long, 458752);
pub const RPC_X_SS_CANNOT_GET_CALL_HANDLE = @as(c_long, 1779);
pub const SC_ICON = SC_MINIMIZE;
pub const TRUST_PROTECTED_FILTER_ACE_FLAG = 64;
pub const CBS_OWNERDRAWVARIABLE = @as(c_long, 32);
pub const CTLCOLOR_MAX = 7;
pub const DNS_ERROR_ROLLOVER_NOT_POKEABLE = @as(c_long, 9128);
pub const X509_ASN_ENCODING = 1;
pub const TAPE_DRIVE_EOT_WZ_SIZE = 8192;
pub const PEERDIST_ERROR_CONTENTINFO_VERSION_UNSUPPORTED = @as(c_long, 4050);
pub const _MSC_BUILD = 1;
pub const CREATE_FOR_DIR = 2;
pub const IMAGE_SUBSYSTEM_EFI_ROM = 13;
pub const URLPOLICY_NOTIFY_ON_DISALLOW = 32;
pub const ERROR_INSTALL_CANCEL = @as(c_long, 15608);
pub const SERVICE_NOTIFY_STATUS_CHANGE = SERVICE_NOTIFY_STATUS_CHANGE_2;
pub const PPM_FIRMWARE_TPC = 4096;
pub const SECURITY_USERMODEDRIVERHOST_ID_RID_COUNT = @as(c_long, 6);
pub const PERFORMANCE_DATA_VERSION = 1;
pub const AT_SIGNATURE = 2;
pub const WM_KEYDOWN = 256;
pub const MAX_PRIORITY = 99;
pub const MFT_RADIOCHECK = @as(c_long, 512);
pub const ERROR_SERVICES_FAILED_AUTOSTART = @as(c_long, 15405);
pub const ERROR_INVALID_UNWIND_TARGET = @as(c_long, 544);
pub const MCI_ANIM_PLAY_SCAN = @as(c_long, 1048576);
pub const PRF_CHECKVISIBLE = @as(c_long, 1);
pub const FILL_NV_MEMORY_FLAG_FLUSH = 1;
pub const CERT_CHAIN_ENABLE_CACHE_AUTO_UPDATE = 16;
pub const SORT_JAPANESE_RADICALSTROKE = 4;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAM_INFORMATION_FOR_DSC_ATTRIBUTE = 256;
pub const LANG_INUKTITUT = 93;
pub const ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS = @as(c_long, 5919);
pub const SECURITY_VIRTUALSERVER_ID_BASE_RID = @as(c_long, 83);
pub const IME_THOTKEY_IME_NONIME_TOGGLE = 112;
pub const WN_BAD_VALUE = ERROR_INVALID_PARAMETER;
pub const ERROR_NOLOGON_SERVER_TRUST_ACCOUNT = @as(c_long, 1809);
pub const URLACTION_NETWORK_MAX = 7167;
pub const MCI_WAVE_STATUS_FORMATTAG = @as(c_long, 16385);
pub const IMAGE_HOT_PATCH_CHUNK_INVERSE = 2147483648;
pub const NCRYPTBUFFER_TPM_SEAL_NO_DA_PROTECTION = 73;
pub const WT_EXECUTEINWAITTHREAD = 4;
pub const GC_PAN = 1;
pub const C3_ALPHA = 32768;
pub const GF_INERTIA = 2;
pub const SUBLANG_PORTUGUESE_BRAZILIAN = 1;
pub const WNNC_NET_DECORB = 2097152;
pub const OBJ_FONT = 6;
pub const IMAGE_DIRECTORY_ENTRY_DEBUG = 6;
pub const BAUD_7200 = if (@typeId(@typeOf(1024)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 1024) else if (@typeId(@typeOf(1024)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 1024) else DWORD(1024);
pub const CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL = 3;
pub const ERROR_HOST_UNREACHABLE = @as(c_long, 1232);
pub const QUERY_ACTCTX_FLAG_ACTCTX_IS_ADDRESS = 16;
pub const SHTDN_REASON_FLAG_MOBILE_UI_RESERVED = 268435456;
pub const ERROR_GPIO_CLIENT_INFORMATION_INVALID = @as(c_long, 15322);
pub const MCI_SEEK_TO_END = @as(c_long, 512);
pub const MSG_OOB = 1;
pub const ERROR_LOG_SECTOR_PARITY_INVALID = @as(c_long, 6601);
pub const __STDC_UTF_16__ = 1;
pub const ERROR_DEVICE_HARDWARE_ERROR = @as(c_long, 483);
pub const __UINTMAX_C_SUFFIX__ = ULL;
pub const VER_SUITE_COMMUNICATIONS = 8;
pub const _ACRTIMP_ALT = _ACRTIMP;
pub const SUBLANG_CHEROKEE_CHEROKEE = 1;
pub const DRV_CLOSE = 4;
pub const szOID_ECC_CURVE_BRAINPOOLP192R1 = "1.3.36.3.3.2.8.1.1.3";
pub const CMSG_ENVELOPE_ALGORITHM_PARAM = 15;
pub const PD_ENABLEPRINTTEMPLATEHANDLE = 65536;
pub const GetProfileInt = GetProfileIntA;
pub const MK_S_FIRST = @as(c_long, 262624);
pub const FOF_NOCONFIRMMKDIR = 512;
pub const VK_OEM_FJ_JISHO = 146;
pub const DMPAPER_ENV_PERSONAL = 38;
pub const HSHELL_WINDOWCREATED = 1;
pub const ERROR_BAD_ARGUMENTS = @as(c_long, 160);
pub const DM_POINTERHITTEST = 592;
pub const SB_PAGELEFT = 2;
pub const LB_GETSELITEMS = 401;
pub const SHIL_EXTRALARGE = 2;
pub const TRANSACTION_NOTIFY_PROMOTE = 134217728;
pub const ERROR_INVALID_CMM = @as(c_long, 2010);
pub const EnumTimeFormats = EnumTimeFormatsA;
pub const LOCALE_RETURN_GENITIVE_NAMES = 268435456;
pub const _SA_annotes0 = n;
pub const NCRYPT_ECC_CURVE_NAME_PROPERTY = BCRYPT_ECC_CURVE_NAME;
pub const ERROR_CLUSTER_NODE_IN_GRACE_PERIOD = @as(c_long, 5978);
pub const CERT_STORE_ADD_USE_EXISTING = 2;
pub const SERVICE_CONTROL_DEVICEEVENT = 11;
pub const APIENTRY = WINAPI;
pub const DISPLAYCONFIG_SOURCE_IN_USE = 1;
pub const WM_IME_REQUEST = 648;
pub const ERROR_CONVERT_TO_LARGE = @as(c_long, 600);
pub const STORAGE_PROTOCOL_STATUS_BUSY = 5;
pub const DNS_ERROR_NOT_ALLOWED_WITH_ZONESCOPES = @as(c_long, 9955);
pub const DISP_CHANGE_BADFLAGS = -4;
pub const ABM_GETSTATE = 4;
pub const X509_CHOICE_OF_TIME = if (@typeId(@typeOf(30)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 30) else if (@typeId(@typeOf(30)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 30) else LPCSTR(30);
pub const IMAGE_REL_M32R_SECREL32 = 13;
pub const FACILITY_EAP = 66;
pub const LANG_HAUSA = 104;
pub const SM_CONVERTIBLESLATEMODE = 8195;
pub const DMPAPER_LETTER_EXTRA = 50;
pub const PRODUCT_STARTER_N = 47;
pub const COLOR_INFOBK = 24;
pub const RPC_CALL_ATTRIBUTES_V1 = RPC_CALL_ATTRIBUTES_V1_A;
pub const MCI_STATUS = 2068;
pub const ERROR_TM_INITIALIZATION_FAILED = @as(c_long, 6706);
pub const OFN_CREATEPROMPT = 8192;
pub const FACILITY_URT = 19;
pub const URLPOLICY_JAVA_CUSTOM = 8388608;
pub const REG_OPTION_RESERVED = @as(c_long, 0);
pub const _Analysis_assume_lock_not_held_ = lock;
pub const CONTAINER_ROOT_INFO_FLAG_BIND_DO_NOT_MAP_NAME = 256;
pub const ERROR_DS_OPERATIONS_ERROR = @as(c_long, 8224);
pub const MAX_LOGICALDPIOVERRIDE = 2;
pub const IME_PROP_CANDLIST_START_FROM_1 = 262144;
pub const ERROR_EA_ACCESS_DENIED = @as(c_long, 994);
pub const NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS_CURRENT_VERSION = NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS_V0;
pub const LPOINETTHREADSWITCH = LPIINTERNETTHREADSWITCH;
pub const ERROR_NO_SIGNAL_SENT = @as(c_long, 205);
pub const InterlockedBitTestAndResetAcquire = _interlockedbittestandreset;
pub const FindWindowEx = FindWindowExA;
pub const VK_VOLUME_UP = 175;
pub const ERROR_EXTERNAL_BACKING_PROVIDER_UNKNOWN = @as(c_long, 343);
pub const RPC_S_UNKNOWN_PRINCIPAL = ERROR_NONE_MAPPED;
pub const VP_CP_CMD_DEACTIVATE = 2;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_ID = @as(c_long, 13834);
pub const WM_NOTIFYFORMAT = 85;
pub const szOIDVerisign_PkiStatus = "2.16.840.1.113733.1.9.3";
pub const CryptAcquireContext = CryptAcquireContextA;
pub const PRODUCT_DATACENTER_WS_SERVER_CORE = 147;
pub const PROCESS_CREATION_MITIGATION_POLICY_WIN32K_SYSTEM_CALL_DISABLE_RESERVED = 3 << 28;
pub const EMARCH_ENC_I17_IMM9D_INST_WORD_X = 3;
pub const WN_NOT_AUTHENTICATED = ERROR_NOT_AUTHENTICATED;
pub const WS_CHILDWINDOW = WS_CHILD;
pub const CMSG_ENVELOPED = 3;
pub const GCPCLASS_LOCALNUMBER = 4;
pub const _WIN32_IE = 2560;
pub const SERVICE_ERROR_NORMAL = 1;
pub const ARW_STARTRIGHT = @as(c_long, 1);
pub const SMTO_NOTIMEOUTIFNOTHUNG = 8;
pub const szOID_ATTR_TPM_SECURITY_ASSERTIONS = "2.23.133.2.18";
pub const WINDOW_BUFFER_SIZE_EVENT = 4;
pub const RPC_CONTEXT_HANDLE_DEFAULT_FLAGS = @as(c_ulong, 0);
pub const ERROR_PRI_MERGE_RESOURCE_PACKAGE_REQUIRED = @as(c_long, 15157);
pub const UNLOCK_ELEMENT = 1;
pub const SUBLANG_PERSIAN_IRAN = 1;
pub const ERROR_INSTALL_SERVICE_FAILURE = @as(c_long, 1601);
pub const GMEM_MODIFY = 128;
pub const ERROR_STATE_LOAD_STORE_FAILED = @as(c_long, 15800);
pub const PROCESS_CREATION_MITIGATION_POLICY_AUDIT_NONSYSTEM_FONTS = if (@typeId(@typeOf(i64 << 48)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 48) else if (@typeId(@typeOf(i64 << 48)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 48) else @as(c_uint, 3)(i64 << 48);
pub const IMAGE_SCN_LNK_OTHER = 256;
pub const ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED = @as(c_long, 1933);
pub const ERROR_CLOUD_FILE_VALIDATION_FAILED = @as(c_long, 383);
pub const ERROR_NOT_ENOUGH_MEMORY = @as(c_long, 8);
pub const InterlockedDecrementAcquire = _InterlockedDecrement;
pub const CONTAINER_ROOT_INFO_FLAG_SCRATCH_ROOT = 1;
pub const SCardIntroduceReaderGroup = SCardIntroduceReaderGroupA;
pub const TXFS_TRANSACTION_STATE_ACTIVE = 1;
pub const CRYPT_STRING_NOCRLF = 1073741824;
pub const DdeQueryString = DdeQueryStringA;
pub const IMAGE_REL_MIPS_SECREL = 11;
pub const VBS_BASIC_PAGE_THREAD_DESCRIPTOR = 4;
pub const X509_CERTIFICATE_TEMPLATE = if (@typeId(@typeOf(64)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 64) else if (@typeId(@typeOf(64)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 64) else LPCSTR(64);
pub const CERT_SET_KEY_PROV_HANDLE_PROP_ID = 1;
pub const DDE_FRELEASE = 8192;
pub const DEVICE_DSM_FLAG_PHYSICAL_ADDRESSES_OMIT_TOTAL_RANGES = 268435456;
pub const RRF_NOEXPAND = 268435456;
pub const SIF_RANGE = 1;
pub const DEVICEFAMILYINFOENUM_IOT_HEADLESS = 8;
pub const JOB_NOTIFY_FIELD_TOTAL_PAGES = 20;
pub const MDM_HDLCPPP_AUTH_NONE = 1;
pub const _WConst_return = _CONST_RETURN;
pub const SCARD_READER_TYPE_KEYBOARD = 4;
pub const PWR_FAIL = -1;
pub const EMR_GDICOMMENT = 70;
pub const ERROR_INSTALL_PACKAGE_DOWNGRADE = @as(c_long, 15622);
pub const ERROR_UNABLE_TO_INVENTORY_DRIVE = @as(c_long, 4325);
pub const ERROR_NEGATIVE_SEEK = @as(c_long, 131);
pub const GetDlgItemText = GetDlgItemTextA;
pub const SUBLANG_SERBIAN_SERBIA_CYRILLIC = 10;
pub const X509_ECC_PRIVATE_KEY = if (@typeId(@typeOf(82)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 82) else if (@typeId(@typeOf(82)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 82) else LPCSTR(82);
pub const ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND = @as(c_long, 5043);
pub const ERROR_PORT_MESSAGE_TOO_LONG = @as(c_long, 546);
pub const ABM_GETAUTOHIDEBAREX = 11;
pub const CTRY_TUNISIA = 216;
pub const CB_SETDROPPEDWIDTH = 352;
pub const ERROR_DS_HIGH_DSA_VERSION = @as(c_long, 8642);
pub const GetLocaleInfo = GetLocaleInfoA;
pub const InterlockedAddAcquire = _InlineInterlockedAdd;
pub const DFCS_BUTTONRADIOMASK = 2;
pub const RPC_C_DONT_FAIL = 4;
pub const CLIP_STROKE_PRECIS = 2;
pub const IMAGE_REL_MIPS_SECTION = 10;
pub const ETO_PDY = 8192;
pub const LANG_GALICIAN = 86;
pub const PROPSHEETHEADER_V1_SIZE = PROPSHEETHEADERA_V1_SIZE;
pub const FRS_ERR_PARENT_TO_CHILD_COMM = @as(c_long, 8012);
pub const NI_SELECTCANDIDATESTR = 18;
pub const __BIGGEST_ALIGNMENT__ = 16;
pub const CBR_56000 = 56000;
pub const ERROR_DS_DECODING_ERROR = @as(c_long, 8253);
pub const midiInGetDevCaps = midiInGetDevCapsA;
pub const DNS_WARNING_PTR_CREATE_FAILED = @as(c_long, 9715);
pub const TC_SO_ABLE = 4096;
pub const META_FLOODFILL = 1049;
pub const ERROR_DS_OFFSET_RANGE_ERROR = @as(c_long, 8262);
pub const VER_SUITE_COMPUTE_SERVER = 16384;
pub const IO_REPARSE_TAG_RESERVED_ONE = 1;
pub const CONTEXT_E_FIRST = @as(c_long, 2147803136);
pub const CAL_HIJRI = 6;
pub const CBN_EDITCHANGE = 5;
pub const PROCESS_CREATION_MITIGATION_POLICY_STRICT_HANDLE_CHECKS_MASK = 3 << 24;
pub const TARGET_IS_NT351_OR_WIN95_OR_LATER = 1;
pub const FAST_FAIL_GUARD_WRITE_CHECK_FAILURE = 11;
pub const VK_PAUSE = 19;
pub const MS_DEF_DSS_DH_PROV = MS_DEF_DSS_DH_PROV_A;
pub const COLOR_MENUHILIGHT = 29;
pub const CRYPT_RANDOM_QUERY_STRING_RETRIEVAL = 67108864;
pub const ERROR_SERVICE_NOTIFY_CLIENT_LAGGING = @as(c_long, 1294);
pub const ERROR_DS_DRA_OBJ_IS_REP_SOURCE = @as(c_long, 8450);
pub const CTL_CERT_SUBJECT_TYPE = 2;
pub const ERROR_CLOUD_FILE_INVALID_REQUEST = @as(c_long, 380);
pub const WDK_NTDDI_VERSION = NTDDI_WIN10_19H1;
pub const PROCESSOR_INTEL_386 = 386;
pub const MUTEX_ALL_ACCESS = MUTANT_ALL_ACCESS;
pub const MUI_QUERY_TYPE = 1;
pub const RPC_X_NO_MORE_ENTRIES = @as(c_long, 1772);
pub const SORTED_CTL_EXT_COUNT_OFFSET = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast([*c]1, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr([*c]1, 4) else ([*c]1)(4);
pub const ERROR_SPL_NO_ADDJOB = @as(c_long, 3004);
pub const LONG_MIN = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-@as(c_long, 2147483647), -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-@as(c_long, 2147483647), -1) else (-@as(c_long, 2147483647))(-1);
pub const SCARD_PROVIDER_KSP = 3;
pub const _WIN32_IE_XPSP1 = _WIN32_IE_IE60SP1;
pub const ENUMPAPERBINS = 31;
pub const CRL_V1 = 0;
pub const INIT_ONCE_CHECK_ONLY = RTL_RUN_ONCE_CHECK_ONLY;
pub const MAXUINT16 = if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT16, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT16, 0) else UINT16(0))) == @import("builtin").TypeId.Pointer) @ptrCast(UINT16, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT16, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT16, 0) else UINT16(0)) else if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT16, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT16, 0) else UINT16(0))) == @import("builtin").TypeId.Int) @intToPtr(UINT16, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT16, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT16, 0) else UINT16(0)) else UINT16(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT16, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(UINT16, 0) else UINT16(0));
pub const STATUS_HEAP_CORRUPTION = if (@typeId(@typeOf(@as(c_long, 3221226356))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221226356)) else if (@typeId(@typeOf(@as(c_long, 3221226356))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221226356)) else DWORD(@as(c_long, 3221226356));
pub const ERROR_INVALID_SERVICE_CONTROL = @as(c_long, 1052);
pub const ERROR_ALREADY_INITIALIZED = @as(c_long, 1247);
pub const SO_RCVLOWAT = 4100;
pub const ERROR_EVT_CHANNEL_NOT_FOUND = @as(c_long, 15007);
pub const CMC_STATUS_SUCCESS = 0;
pub const CRYPT_USERDATA = 1;
pub const CRL_REASON_CERTIFICATE_HOLD_FLAG = 2;
pub const ISMEX_NOTIFY = 2;
pub const CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST = 1;
pub const SUBLANG_GERMAN_AUSTRIAN = 3;
pub const SPI_SETWHEELSCROLLCHARS = 109;
pub const __deref_inout_bcount_nz_opt = size;
pub const DNS_ERROR_NO_VALID_TRUST_ANCHORS = @as(c_long, 9127);
pub const DESKTOP_ENUMERATE = @as(c_long, 64);
pub const CERT_COMPARE_NAME = 2;
pub const BCRYPT_TLS1_1_KDF_ALG_HANDLE = if (@typeId(@typeOf(865)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 865) else if (@typeId(@typeOf(865)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 865) else BCRYPT_ALG_HANDLE(865);
pub const POWERBUTTON_ACTION_INDEX_SHUTDOWN = 3;
pub const EXCEPTION_STACK_INVALID = 8;
pub const GCS_COMPATTR = 16;
pub const SETRGBSTRINGA = "commdlg_SetRGBColor";
pub const SPI_SETGRIDGRANULARITY = 19;
pub const PSINJECT_VMRESTORE = 201;
pub const HTSIZELAST = HTBOTTOMRIGHT;
pub const JOY_CAL_READALWAYS = @as(c_long, 65536);
pub const WM_NCPAINT = 133;
pub const IS_TEXT_UNICODE_REVERSE_MASK = 240;
pub const WM_COPYDATA = 74;
pub const _RPC_HTTP_TRANSPORT_CREDENTIALS_V2 = _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A;
pub const ERROR_CTX_LICENSE_NOT_AVAILABLE = @as(c_long, 7054);
pub const NCBASTAT = 51;
pub const ERROR_IPSEC_THROTTLE_DROP = @as(c_long, 13918);
pub const URLACTION_SHELL_ENHANCED_DRAGDROP_SECURITY = 6155;
pub const CreatePrivateNamespace = CreatePrivateNamespaceA;
pub const _WIN32_WINNT_WIN7 = 1537;
pub const VARIABLE_PITCH = 2;
pub const PIDSI_REVNUMBER = @as(c_long, 9);
pub const MOUSEEVENTF_HWHEEL = 4096;
pub const VK_JUNJA = 23;
pub const STATE_SYSTEM_INDETERMINATE = STATE_SYSTEM_MIXED;
pub const ERROR_FORMS_AUTH_REQUIRED = @as(c_long, 224);
pub const RpcStringBindingParse = RpcStringBindingParseA;
pub const PENARBITRATIONTYPE_FIS = 2;
pub const ECC_CMS_SHARED_INFO = if (@typeId(@typeOf(77)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 77) else if (@typeId(@typeOf(77)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 77) else LPCSTR(77);
pub const RPC_S_PROTOCOL_ERROR = @as(c_long, 1728);
pub const MIDIERR_BASE = 64;
pub const DNS_ERROR_INVALID_PROPERTY = @as(c_long, 9553);
pub const ERROR_DS_DATABASE_ERROR = @as(c_long, 8409);
pub const PORT_TYPE_REDIRECTED = 4;
pub const DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT_VERSION_V1 = DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT_V1;
pub const NCRYPT_IMPL_HARDWARE_RNG_FLAG = 16;
pub const OFS_MAXPATHNAME = 128;
pub const _CRT_INT_MAX = 2147483647;
pub const FILE_INITIATE_REPAIR_HINT1_FILE_RECORD_NOT_ORPHAN = 262144;
pub const ERROR_EVT_FILTER_OUT_OF_RANGE = @as(c_long, 15038);
pub const PKCS12_PBKDF2_ID_HMAC_SHA512 = "1.2.840.113549.2.11";
pub const PD_NOCURRENTPAGE = 8388608;
pub const IME_PROP_AT_CARET = 65536;
pub const EMR_ABORTPATH = 68;
pub const PERF_DISPLAY_SECONDS = 805306368;
pub const SMART_CMD = 176;
pub const ImmIsUIMessage = ImmIsUIMessageA;
pub const JOB_NOTIFY_FIELD_PRINTER_NAME = 0;
pub const PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_RESERVED = if (@typeId(@typeOf(i64 << 32)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 32) else if (@typeId(@typeOf(i64 << 32)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 32) else @as(c_uint, 3)(i64 << 32);
pub const PSINJECT_PAGESATEND = 3;
pub const SID_IBindHost = IID_IBindHost;
pub const WS_EX_LEFT = @as(c_long, 0);
pub const ALG_SID_DES = 1;
pub const PKCS12_IMPORT_RESERVED_MASK = 4294901760;
pub const ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY = @as(c_long, 8530);
pub const TAPE_UNLOAD = @as(c_long, 1);
pub const ERROR_PROFILE_NOT_FOUND = @as(c_long, 2016);
pub const szOID_INFOSEC = "2.16.840.1.101.2.1";
pub const ERROR_UNKNOWN_PRODUCT = @as(c_long, 1605);
pub const szOID_ISSUING_DIST_POINT = "2.5.29.28";
pub const ERROR_AUTHIP_FAILURE = @as(c_long, 1469);
pub const GETSETSCREENPARAMS = 3072;
pub const EVENT_OBJECT_UNCLOAKED = 32792;
pub const CERT_CHAIN_POLICY_IGNORE_END_REV_UNKNOWN_FLAG = 256;
pub const MM_WIM_CLOSE = 959;
pub const IMAGE_OS2_SIGNATURE_LE = 17740;
pub const LANG_FAEROESE = 56;
pub const DMPAPER_ENV_9 = 19;
pub const IMAGE_COMDAT_SELECT_ANY = 2;
pub const CERT_RETRIEVE_COMMUNITY_LOGO = if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 3) else if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 3) else LPCSTR(3);
pub const CERT_STORE_OPEN_EXISTING_FLAG = 16384;
pub const ATTR_CONVERTED = 2;
pub const CRYPT_KEYID_DELETE_FLAG = 16;
pub const SPI_SETWORKAREA = 47;
pub const IMAGE_REL_SH3_SECREL = 15;
pub const szOID_RSA_MD5RSA = "1.2.840.113549.1.1.4";
pub const ID_PSRESTARTWINDOWS = 2;
pub const OF_SHARE_COMPAT = 0;
pub const EVENTLOG_SEQUENTIAL_READ = 1;
pub const LOCALE_SKEYBOARDSTOINSTALL = 94;
pub const SEC_WINNT_AUTH_IDENTITY_UNICODE = 2;
pub const MCI_FROM = @as(c_long, 4);
pub const EMR_MOVETOEX = 27;
pub const MMIO_SHAREMODE = 112;
pub const ERROR_INCORRECT_ACCOUNT_TYPE = @as(c_long, 8646);
pub const MARK_HANDLE_NOT_REALTIME = 64;
pub const FACILITY_ITF = 4;
pub const WSA_IPSEC_NAME_POLICY_ERROR = @as(c_long, 11033);
pub const WriteMxCsr = _mm_setcsr;
pub const APPMODEL_ERROR_PACKAGE_IDENTITY_CORRUPT = @as(c_long, 15702);
pub const IID_IOInetProtocol = IID_IInternetProtocol;
pub const PF_PUP = AF_PUP;
pub const CF_ENABLETEMPLATEHANDLE = @as(c_long, 32);
pub const TKF_INDICATOR = 32;
pub const ERROR_NONCORE_GROUPS_FOUND = @as(c_long, 5937);
pub const MAPVK_VK_TO_CHAR = 2;
pub const SCARD_AUDIT_CHV_FAILURE = 0;
pub const CharLowerBuff = CharLowerBuffA;
pub const CBS_OWNERDRAWFIXED = @as(c_long, 16);
pub const ERROR_INVALID_RUNLEVEL_SETTING = @as(c_long, 15401);
pub const FILE_DEVICE_NFP = 81;
pub const ERROR_QUORUM_OWNER_ALIVE = @as(c_long, 5034);
pub const PIDSI_COMMENTS = @as(c_long, 6);
pub const ES_MULTILINE = @as(c_long, 4);
pub const ERROR_COLORSPACE_MISMATCH = @as(c_long, 2021);
pub const SW_SHOWNA = 8;
pub const TIME_ZONE_ID_DAYLIGHT = 2;
pub const IO_REPARSE_TAG_CLOUD_8 = @as(c_long, 2415951898);
pub const FILE_STORAGE_TIER_FLAG_SMR = 16777216;
pub const BCRYPT_MD4_ALG_HANDLE = if (@typeId(@typeOf(17)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 17) else if (@typeId(@typeOf(17)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 17) else BCRYPT_ALG_HANDLE(17);
pub const MUI_COMPLEX_SCRIPT_FILTER = 512;
pub const ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE = @as(c_long, 14019);
pub const ERROR_CLUSTER_NO_NET_ADAPTERS = @as(c_long, 5906);
pub const ERROR_TRANSACTION_ALREADY_COMMITTED = @as(c_long, 6705);
pub const KDF_SECRET_HANDLE = 6;
pub const CSV_MGMTLOCK_CHECK_VOLUME_REDIRECTED = 1;
pub const ERROR_DS_DRA_SECRETS_DENIED = @as(c_long, 8630);
pub const RPC_C_PROFILE_DEFAULT_ELT = 0;
pub const ERROR_DBG_RIPEXCEPTION = @as(c_long, 695);
pub const RPC_FW_IF_FLAG_DCOM = 1;
pub const MIXER_OBJECTF_AUX = @as(c_long, 1342177280);
pub const EXIT_FAILURE = 1;
pub const ATOM_FLAG_GLOBAL = 2;
pub const PSD_INWININIINTLMEASURE = 0;
pub const ERROR_EVT_MESSAGE_ID_NOT_FOUND = @as(c_long, 15028);
pub const SERVICE_STOP_REASON_MAJOR_APPLICATION = 327680;
pub const DS_NOFAILCREATE = @as(c_long, 16);
pub const CDERR_STRUCTSIZE = 1;
pub const C1_SPACE = 8;
pub const szOID_CRL_NEXT_PUBLISH = "1.3.6.1.4.1.311.21.4";
pub const URLACTION_SCRIPT_SAFE_ACTIVEX = 5125;
pub const CERT_CHAIN_REVOCATION_ACCUMULATIVE_TIMEOUT = 134217728;
pub const CFG_CALL_TARGET_PROCESSED = 2;
pub const ERROR_BEGINNING_OF_MEDIA = @as(c_long, 1102);
pub const USER_MARSHAL_FC_USMALL = 4;
pub const ERROR_INVALID_STACKSEG = @as(c_long, 189);
pub const CACHE_S_LAST = @as(c_long, 262527);
pub const LGRPID_GREEK = 4;
pub const ERROR_ENCLAVE_VIOLATION = @as(c_long, 815);
pub const JOB_NOTIFY_FIELD_USER_NAME = 3;
pub const CBF_SKIP_ALLNOTIFICATIONS = 3932160;
pub const INPUTLANGCHANGE_FORWARD = 2;
pub const MoveFileTransacted = MoveFileTransactedA;
pub const SECURITY_PROCESS_PROTECTION_TYPE_NONE_RID = @as(c_long, 0);
pub const CMSG_SIGNED_FLAG = 1 << CMSG_SIGNED;
pub const STATUS_INVALID_HANDLE = if (@typeId(@typeOf(@as(c_long, 3221225480))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225480)) else if (@typeId(@typeOf(@as(c_long, 3221225480))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225480)) else DWORD(@as(c_long, 3221225480));
pub const LANG_MAORI = 129;
pub const _RPC_HTTP_TRANSPORT_CREDENTIALS_V3 = _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A;
pub const BS_ICON = @as(c_long, 64);
pub const OR_INVALID_OID = @as(c_long, 1911);
pub const DROPEFFECT_MOVE = 2;
pub const IDH_NO_HELP = 28440;
pub const PROCESSOR_INTEL_IA64 = 2200;
pub const GetConsoleAliasesLength = GetConsoleAliasesLengthA;
pub const DNS_ERROR_DWORD_VALUE_TOO_LARGE = @as(c_long, 9567);
pub const _WIN32_WINNT_WIN6 = 1536;
pub const SCRUB_DATA_INPUT_FLAG_SCRUB_BY_OBJECT_ID = 32;
pub const ALG_TYPE_DSS = 1 << 9;
pub const CRYPT_VERIFY_CERT_SIGN_RETURN_STRONG_PROPERTIES_FLAG = 4;
pub const PDCAP_WAKE_FROM_D3_SUPPORTED = 128;
pub const DMLERR_INVALIDPARAMETER = 16390;
pub const TIME_SAMPLES = 2;
pub const ERROR_SXS_XML_E_INVALID_DECIMAL = @as(c_long, 14047);
pub const ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED = @as(c_long, 746);
pub const CMSG_KEY_AGREE_VERSION = CMSG_ENVELOPED_RECIPIENT_V3;
pub const IMAGE_REL_ARM_TOKEN = 5;
pub const NTAPI = __stdcall;
pub const USN_REASON_FILE_DELETE = 512;
pub const IS_TEXT_UNICODE_ODD_LENGTH = 512;
pub const LANG_TAJIK = 40;
pub const LOCALE_REPLACEMENT = 8;
pub const FILE_DEVICE_VMBUS = 62;
pub const WM_NCPOINTERDOWN = 578;
pub const iscsymf = __iscsymf;
pub const FACILITY_TPM_SERVICES = 40;
pub const LoadAccelerators = LoadAcceleratorsA;
pub const CERT_PIN_SHA256_HASH_PROP_ID = 124;
pub const PURGE_RXABORT = 2;
pub const ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED = @as(c_long, 8429);
pub const PS_OPENTYPE_FONTTYPE = 65536;
pub const szOID_RSA_SHA512RSA = "1.2.840.113549.1.1.13";
pub const CERT_FIND_SHA1_HASH = CERT_COMPARE_SHA1_HASH << CERT_COMPARE_SHIFT;
pub const HP_HMAC_INFO = 5;
pub const WOW64_MAXIMUM_SUPPORTED_EXTENSION = 512;
pub const REG_RESOURCE_REQUIREMENTS_LIST = @as(c_ulong, 10);
pub const MM_WIM_OPEN = 958;
pub const ERROR_DRIVE_LOCKED = @as(c_long, 108);
pub const TOKEN_MANDATORY_POLICY_OFF = 0;
pub const IMAGE_REL_M32R_ADDR32 = 1;
pub const ERROR_DISK_REPAIR_UNSUCCESSFUL = @as(c_long, 793);
pub const FW_LIGHT = 300;
pub const LOAD_LIBRARY_SEARCH_USER_DIRS = 1024;
pub const ERROR_SIGNAL_PENDING = @as(c_long, 162);
pub const USN_PAGE_SIZE = 4096;
pub const DATE_SHORTDATE = 1;
pub const NETINFO_DLL16 = 1;
pub const VFT2_DRV_SYSTEM = @as(c_long, 7);
pub const IMAGE_REL_MIPS_PAIR = 37;
pub const WC_NO_BEST_FIT_CHARS = 1024;
pub const Uri_CREATE_CANONICALIZE = 256;
pub const XSTATE_AVX512_ZMM = 7;
pub const WM_KILLFOCUS = 8;
pub const __x86_64__ = 1;
pub const COLORONCOLOR = 3;
pub const SHADEBLENDCAPS = 120;
pub const LOCALE_SSHORTESTDAYNAME4 = 99;
pub const META_CREATEBRUSHINDIRECT = 764;
pub const PAN_SERIF_FLARED = 14;
pub const GetGlyphOutline = GetGlyphOutlineA;
pub const CERT_TRUST_IS_FROM_EXCLUSIVE_TRUST_STORE = 8192;
pub const __ORDER_BIG_ENDIAN__ = 4321;
pub const DEVICE_DSM_FLAG_ENTIRE_DATA_SET_RANGE = 1;
pub const RPC_C_MGMT_INQ_IF_IDS = 0;
pub const FRS_ERR_INVALID_API_SEQUENCE = @as(c_long, 8001);
pub const ERROR_ILLEGAL_DLL_RELOCATION = @as(c_long, 623);
pub const HCF_HOTKEYAVAILABLE = 64;
pub const USER_MARSHAL_FC_SMALL = 3;
pub const CERT_COMPARE_CTL_USAGE = CERT_COMPARE_ENHKEY_USAGE;
pub const PRINTER_ATTRIBUTE_PUBLISHED = 8192;
pub const IGP_SETCOMPSTR = 20;
pub const PRINTER_DRIVER_CATEGORY_VIRTUAL = 256;
pub const CDERR_DIALOGFAILURE = 65535;
pub const NRC_NOSAPS = 55;
pub const ERROR_DIR_EFS_DISALLOWED = @as(c_long, 6010);
pub const DM_DISPLAYORIENTATION = @as(c_long, 128);
pub const EV_RX80FULL = 1024;
pub const LB_SETTOPINDEX = 407;
pub const PRINTER_CONTROL_SET_STATUS = 4;
pub const SUBLANG_SINHALESE_SRI_LANKA = 1;
pub const BS_PUSHLIKE = @as(c_long, 4096);
pub const IMAGE_FILE_LOCAL_SYMS_STRIPPED = 8;
pub const PKCS12_INCLUDE_EXTENDED_PROPERTIES = 16;
pub const RPI_SMB2_FLAG_SERVERCAP_LEASING = 2;
pub const CRYPT_DOMAIN = 2;
pub const NOTIFYICONDATA_V1_SIZE = NOTIFYICONDATAA_V1_SIZE;
pub const RPC_C_AUTHN_GSS_SCHANNEL = 14;
pub const DS_CENTERMOUSE = @as(c_long, 4096);
pub const FACILITY_DAF = 100;
pub const JOY_RETURNPOV = @as(c_long, 64);
pub const BI_RGB = @as(c_long, 0);
pub const NMPWAIT_WAIT_FOREVER = 4294967295;
pub const NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_CURRENT_VERSION = NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT_V0;
pub const TRANSACTION_NOTIFY_RM_DISCONNECTED = 16777216;
pub const _WIN32_IE_WIN2KSP1 = _WIN32_IE_IE501;
pub const WNFMT_INENUM = 16;
pub const MCI_ANIM_WINDOW_HWND = @as(c_long, 65536);
pub const ERROR_IPSEC_IKE_NO_PRIVATE_KEY = @as(c_long, 13820);
pub const CFSTR_MIME_X_MIXED_REPLACE = if (@typeId(@typeOf("multipart/x-mixed-replace")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "multipart/x-mixed-replace") else if (@typeId(@typeOf("multipart/x-mixed-replace")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "multipart/x-mixed-replace") else TEXT("multipart/x-mixed-replace");
pub const URLACTION_SHELL_SHARE = 6160;
pub const ERROR_HEURISTIC_DAMAGE_POSSIBLE = @as(c_long, 6731);
pub const GF_END = 4;
pub const VK_GAMEPAD_LEFT_THUMBSTICK_DOWN = 212;
pub const DMPAPER_JENV_KAKU3 = 72;
pub const PSNRET_NOERROR = 0;
pub const MM_MIM_CLOSE = 962;
pub const ERROR_DS_ALIAS_PROBLEM = @as(c_long, 8241);
pub const IO_REPARSE_TAG_CLOUD_9 = @as(c_long, 2415955994);
pub const RPC_S_GROUP_MEMBER_NOT_FOUND = @as(c_long, 1898);
pub const USN_REASON_CLOSE = 2147483648;
pub const LPOPENCARDNAMEA_EX = LPOPENCARDNAME_EXA;
pub const DCOMSCM_ACTIVATION_USE_ALL_AUTHNSERVICES = 1;
pub const URLPOLICY_LOG_ON_ALLOW = 64;
pub const WSAEISCONN = @as(c_long, 10056);
pub const NCRYPT_MAX_PROPERTY_DATA = 1048576;
pub const SORT_GEORGIAN_MODERN = 1;
pub const SPI_SETMOUSEWHEELROUTING = 8221;
pub const SZDDESYS_ITEM_FORMATS = "Formats";
pub const SIZEPALETTE = 104;
pub const DNS_ERROR_INVALID_NAME = ERROR_INVALID_NAME;
pub const RPC_S_INVALID_ASYNC_CALL = @as(c_long, 1915);
pub const SECURITY_LOCAL_ACCOUNT_AND_ADMIN_RID = @as(c_long, 114);
pub const ELOOP = 114;
pub const __inner_out_validated = typ_raw;
pub const CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM = 35;
pub const DMICMMETHOD_USER = 256;
pub const ERROR_IPSEC_SA_LIFETIME_EXPIRED = @as(c_long, 13911);
pub const ODS_DISABLED = 4;
pub const PRODUCT_HYPERV = 42;
pub const SP_OUTOFMEMORY = -5;
pub const ERROR_VSM_NOT_INITIALIZED = @as(c_long, 4560);
pub const UnregisterClass = UnregisterClassA;
pub const __function_ignore_lock_checking = lock;
pub const CRYPT_MODE_OFB = 3;
pub const CRYPT_RC2_128BIT_VERSION = 58;
pub const ERROR_PNP_QUERY_REMOVE_RELATED_DEVICE_TIMEOUT = @as(c_long, 481);
pub const MMIO_EXIST = 16384;
pub const PPM_FIRMWARE_PCCH = 16384;
pub const FACILITY_WEB_SOCKET = 886;
pub const SERVICE_STOP_REASON_MINOR_NETWORKCARD = 9;
pub const SECURITY_TASK_ID_BASE_RID = @as(c_long, 87);
pub const ERROR_DS_ATT_IS_NOT_ON_OBJ = @as(c_long, 8310);
pub const __SIZE_FMTX__ = "llX";
pub const PAN_LETT_NORMAL_CONTACT = 2;
pub const ERROR_INVALID_TRANSFORM = @as(c_long, 2020);
pub const FILE_WRITE_EA = 16;
pub const MF_USECHECKBITMAPS = @as(c_long, 512);
pub const ERROR_SEM_IS_SET = @as(c_long, 102);
pub const TRUETYPE_FONTTYPE = 4;
pub const FILE_STORAGE_TIER_FLAG_WRITE_BACK_CACHE = 2097152;
pub const IMAGE_SYM_TYPE_PCODE = 32768;
pub const VK_LAUNCH_APP1 = 182;
pub const ERROR_CAN_NOT_COMPLETE = @as(c_long, 1003);
pub const _Readable_bytes_impl_ = size;
pub const ERROR_DS_LINK_ID_NOT_AVAILABLE = @as(c_long, 8577);
pub const VP_TV_STANDARD_NTSC_M = 1;
pub const MMIOM_OPEN = 3;
pub const MIXERCONTROL_CT_SC_METER_POLLED = @as(c_long, 0);
pub const WTS_REMOTE_DISCONNECT = 4;
pub const ALG_SID_3DES_112 = 9;
pub const MCI_WAVE_SET_SAMPLESPERSEC = @as(c_long, 262144);
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_PCR_MASK = 80;
pub const ERROR_IPSEC_IKE_MM_DELAY_DROP = @as(c_long, 13814);
pub const GCPGLYPH_LINKAFTER = 16384;
pub const SCARD_STATE_ATRMATCH = 64;
pub const RPC_C_STATS_CALLS_OUT = 1;
pub const SPI_GETANIMATION = 72;
pub const MCI_DEVTYPE_VCR = 513;
pub const BCRYPT_DSA_PUBLIC_MAGIC_V2 = 843206724;
pub const MDM_MASK_V110_SPEED = 15;
pub const EPT_S_NOT_REGISTERED = @as(c_long, 1753);
pub const SCardGetDeviceTypeId = SCardGetDeviceTypeIdA;
pub const DNS_ERROR_DATAFILE_PARSING = @as(c_long, 9655);
pub const LOCALE_SOPENTYPELANGUAGETAG = 122;
pub const InterlockedDecrementNoFence16 = _InterlockedDecrement16;
pub const CERT_RDN_ENCODED_BLOB = 1;
pub const VK_OEM_FINISH = 241;
pub const IMAGE_GUARD_SECURITY_COOKIE_UNUSED = 2048;
pub const FILESYSTEM_STATISTICS_TYPE_FAT = 2;
pub const FillMemory = RtlFillMemory;
pub const ERROR_NO_QUOTAS_FOR_ACCOUNT = @as(c_long, 1302);
pub const ERROR_IPSEC_IKE_ATTRIB_FAIL = @as(c_long, 13802);
pub const DFC_MENU = 2;
pub const X3_IMM39_2_INST_WORD_X = 1;
pub const URLACTION_NETWORK_MIN = 6656;
pub const GWLP_HWNDPARENT = -8;
pub const WAVE_FORMAT_96M08 = 65536;
pub const ERROR_DS_NAME_ERROR_RESOLVING = @as(c_long, 8469);
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE_AT_GUARANTEED = 6;
pub const NCRYPTBUFFER_PKCS_ALG_ID = 43;
pub const STOPBITS_20 = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(WORD, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(WORD, 4) else WORD(4);
pub const LOCALE_SSHORTESTDAYNAME5 = 100;
pub const SET_PURGE_FAILURE_MODE_ENABLED = 1;
pub const ERROR_DS_EXISTING_AD_CHILD_NC = @as(c_long, 8613);
pub const PROCESS_HEAP_SEG_ALLOC = 8;
pub const ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE = @as(c_long, 8503);
pub const InterlockedIncrementAcquire16 = _InterlockedIncrement16;
pub const PRODUCT_DATACENTER_SERVER_CORE_V = 39;
pub const RpcBindingInqAuthInfoEx = RpcBindingInqAuthInfoExA;
pub const _MSC_FULL_VER = 192127702;
pub const SE_LEARNING_MODE_FLAG_PERMISSIVE = 1;
pub const PBT_APMQUERYSTANDBYFAILED = 3;
pub const ERROR_PATCH_PACKAGE_INVALID = @as(c_long, 1636);
pub const BCRYPT_AES_CFB_ALG_HANDLE = if (@typeId(@typeOf(449)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 449) else if (@typeId(@typeOf(449)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 449) else BCRYPT_ALG_HANDLE(449);
pub const X509_MULTI_BYTE_INTEGER = if (@typeId(@typeOf(28)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 28) else if (@typeId(@typeOf(28)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 28) else LPCSTR(28);
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE = @as(c_long, 369);
pub const TAPE_SHORT_FILEMARKS = @as(c_long, 2);
pub const InterlockedDecrement = _InterlockedDecrement;
pub const MWMO_ALERTABLE = 2;
pub const ERROR_STREAM_MINIVERSION_NOT_FOUND = @as(c_long, 6808);
pub const ERROR_ELEVATION_REQUIRED = @as(c_long, 740);
pub const I_RpcServerUnregisterEndpoint = I_RpcServerUnregisterEndpointA;
pub const _CRT_PACKING = 8;
pub const JOY_BUTTON8 = @as(c_long, 128);
pub const ERROR_INVALID_PORT_ATTRIBUTES = @as(c_long, 545);
pub const ERROR_OFFLOAD_WRITE_FILE_NOT_SUPPORTED = @as(c_long, 4443);
pub const BCRYPT_DSA_PARAMETERS_MAGIC = 1297109828;
pub const NUMPRS_TRAILING_WHITE = 2;
pub const MB_NOFOCUS = @as(c_long, 32768);
pub const CERT_TRUST_HAS_ISSUANCE_CHAIN_POLICY = 512;
pub const CRL_V2 = 1;
pub const DMPAPER_JENV_KAKU2 = 71;
pub const WN_WINDOWS_ERROR = ERROR_UNEXP_NET_ERR;
pub const __guarded_by = lock;
pub const DeviceDsmAction_None = @as(c_uint, 0);
pub const WM_GESTURE = 281;
pub const FACILITY_BCD = 57;
pub const THREAD_SET_INFORMATION = 32;
pub const ERROR_DS_NOT_SUPPORTED_SORT_ORDER = @as(c_long, 8570);
pub const VARIANT_CALENDAR_GREGORIAN = 64;
pub const CHANGER_DEVICE_REINITIALIZE_CAPABLE = 134217728;
pub const JOB_OBJECT_CPU_RATE_CONTROL_NOTIFY = 8;
pub const FILE_INITIATE_REPAIR_HINT1_POTENTIAL_CROSSLINK = 8192;
pub const CMSG_RECIPIENT_COUNT_PARAM = 17;
pub const RegConnectRegistry = RegConnectRegistryA;
pub const ERROR_CONTROL_C_EXIT = @as(c_long, 572);
pub const szOID_ENROLLMENT_NAME_VALUE_PAIR = "1.3.6.1.4.1.311.13.2.1";
pub const ERROR_DS_NO_REQUESTED_ATTS_FOUND = @as(c_long, 8308);
pub const IMAGE_GUARD_CFW_INSTRUMENTED = 512;
pub const ERROR_SXS_DUPLICATE_CLSID = @as(c_long, 14023);
pub const RpcNsBindingExport = RpcNsBindingExportA;
pub const midiInGetErrorText = midiInGetErrorTextA;
pub const ERROR_DS_NAME_ERROR_NOT_UNIQUE = @as(c_long, 8471);
pub const WSAEINVALIDPROCTABLE = @as(c_long, 10104);
pub const RPC_C_QOS_IDENTITY_DYNAMIC = 1;
pub const GetClassInfoEx = GetClassInfoExA;
pub const IMAGE_REL_EBC_ADDR32NB = 1;
pub const DSPRINT_REPUBLISH = 8;
pub const GetForm = GetFormA;
pub const VOID = void;
pub const CONSOLE_SELECTION_IN_PROGRESS = 1;
pub const URLACTION_SHELL_VERB = 6148;
pub const szOID_KP_EFS = "1.3.6.1.4.1.311.10.3.4";
pub const RegQueryMultipleValues = RegQueryMultipleValuesA;
pub const LANG_KONKANI = 87;
pub const POWER_DEVICE_IDLE_POLICY_CONSERVATIVE = 1;
pub const FACILITY_USERMODE_LICENSING = 234;
pub const DCBA_FACEDOWNRIGHT = 259;
pub const PAN_LETT_OBLIQUE_CONTACT = 9;
pub const CHANGER_SERIAL_NUMBER_VALID = 67108864;
pub const _Memory_origin_ = context;
pub const ERROR_TS_VIDEO_SUBSYSTEM_ERROR = @as(c_long, 7070);
pub const STGM_DELETEONRELEASE = @as(c_long, 67108864);
pub const ERROR_MARSHALL_OVERFLOW = @as(c_long, 603);
pub const PFD_DIRECT3D_ACCELERATED = 16384;
pub const _Acquires_lock_ = lock;
pub const DNS_ERROR_UNKNOWN_RECORD_TYPE = @as(c_long, 9704);
pub const DM_DUPLEX = @as(c_long, 4096);
pub const ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR = @as(c_long, 789);
pub const UNW_FLAG_NHANDLER = 0;
pub const REVISION_LENGTH = 4;
pub const NCRYPT_MAX_PROPERTY_NAME = 64;
pub const __SIZE_FMTx__ = "llx";
pub const WAVE_FORMAT_96S08 = 131072;
pub const waveInGetErrorText = waveInGetErrorTextA;
pub const ERROR_MCA_INVALID_CAPABILITIES_STRING = @as(c_long, 15200);
pub const TAPE_DRIVE_TAPE_REMAINING = 512;
pub const RpcProtseqVectorFree = RpcProtseqVectorFreeA;
pub const VK_LAUNCH_APP2 = 183;
pub const EM_SETIMESTATUS = 216;
pub const EM_ENABLEFEATURE = 218;
pub const EMR_EXTCREATEFONTINDIRECTW = 82;
pub const PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64 = 13;
pub const ERROR_FIRMWARE_UPDATED = @as(c_long, 728);
pub const DT_LEFT = 0;
pub const GCF_INCLUDE_ANCESTORS = 1;
pub const PDC_MAPPING_CHANGE = 256;
pub const _Guarded_by_ = lock;
pub const WNNC_NET_AURISTOR_FS = 4587520;
pub const ERROR_EVENT_PENDING = @as(c_long, 711);
pub const SC_GROUP_IDENTIFIERA = 43;
pub const JOY_CAL_READYONLY = @as(c_long, 2097152);
pub const CERT_COMPARE_SUBJECT_INFO_ACCESS = 19;
pub const INVALID_ATOM = if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(ATOM, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(ATOM, 0) else ATOM(0);
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = 1;
pub const LB_SETITEMDATA = 410;
pub const ERROR_SXS_MANIFEST_FORMAT_ERROR = @as(c_long, 14004);
pub const ERROR_LOG_CLIENT_NOT_REGISTERED = @as(c_long, 6637);
pub const HBMMENU_POPUP_MINIMIZE = if (@typeId(@typeOf(11)) == @import("builtin").TypeId.Pointer) @ptrCast(HBITMAP, 11) else if (@typeId(@typeOf(11)) == @import("builtin").TypeId.Int) @intToPtr(HBITMAP, 11) else HBITMAP(11);
pub const CRYPT_VERIFY_CONTEXT_SIGNATURE = 32;
pub const ERROR_NO_SECRETS = @as(c_long, 8620);
pub const ERROR_DS_SEC_DESC_TOO_SHORT = @as(c_long, 8353);
pub const HC_SKIP = 2;
pub const MIIM_STATE = 1;
pub const PERF_COUNTER_BASE = 196608;
pub const RSA_CSP_PUBLICKEYBLOB = if (@typeId(@typeOf(19)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 19) else if (@typeId(@typeOf(19)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 19) else LPCSTR(19);
pub const LB_GETCURSEL = 392;
pub const SUBLANG_SPANISH_MODERN = 3;
pub const EMR_WIDENPATH = 66;
pub const IID_IOInetProtocolInfo = IID_IInternetProtocolInfo;
pub const EFS_METADATA_GENERAL_OP = 8;
pub const szOID_ECC_CURVE_SECP384R1 = szOID_ECC_CURVE_P384;
pub const IDH_GENERIC_HELP_BUTTON = 28442;
pub const ALG_SID_RSA_ENTRUST = 3;
pub const FILE_INITIATE_REPAIR_HINT1_NAME_CONFLICT = 17179869184;
pub const PRODUCT_CORE_CONNECTED_COUNTRYSPECIFIC = 116;
pub const X509_ISSUING_DIST_POINT = if (@typeId(@typeOf(54)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 54) else if (@typeId(@typeOf(54)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 54) else LPCSTR(54);
pub const ERROR_OFFLOAD_READ_FILE_NOT_SUPPORTED = @as(c_long, 4442);
pub const LOCALE_SSHORTESTDAYNAME6 = 101;
pub const PROPSHEETPAGE_LATEST = PROPSHEETPAGEA_LATEST;
pub const TOUCH_MASK_CONTACTAREA = 1;
pub const NCRYPT_RC2_ALGORITHM_GROUP = NCRYPT_RC2_ALGORITHM;
pub const ERROR_BAD_REM_ADAP = @as(c_long, 60);
pub const URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY = 4609;
pub const PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_ON = 1 << 16;
pub const CERT_SYSTEM_STORE_UNPROTECTED_FLAG = 1073741824;
pub const CHANGER_CLEANER_OPS_NOT_SUPPORTED = 2147483712;
pub const EMARCH_ENC_I17_IMM41c_SIZE_X = 23;
pub const szOID_ENROLL_ATTESTATION_CHALLENGE = "1.3.6.1.4.1.311.21.28";
pub const szKEY_CACHE_ENABLED = "CachePrivateKeys";
pub const EMR_POLYBEZIERTO16 = 88;
pub const CMSG_AUTHENTICATED_ATTRIBUTES_FLAG = 8;
pub const VolumeClassGuid = GUID_DEVINTERFACE_VOLUME;
pub const REPLACEDLGORD = 1541;
pub const STREAM_EXTENT_ENTRY_AS_RETRIEVAL_POINTERS = 1;
pub const MIXERCONTROL_CT_UNITS_CUSTOM = @as(c_long, 0);
pub const NCRYPT_RSA_ALGORITHM = BCRYPT_RSA_ALGORITHM;
pub const DIALOPTION_QUIET = 128;
pub const CBS_DROPDOWN = @as(c_long, 2);
pub const szOID_KP_TPM_EK_CERTIFICATE = "2.23.133.8.1";
pub const STRICT = 1;
pub const DNS_ERROR_NOT_ALLOWED_ON_UNSIGNED_ZONE = @as(c_long, 9121);
pub const SC_CLOSE = 61536;
pub const PAN_LETT_NORMAL_SQUARE = 8;
pub const MB_ICONSTOP = MB_ICONHAND;
pub const S_SERDCC = -7;
pub const PF_SSE_DAZ_MODE_AVAILABLE = 11;
pub const ERROR_DATABASE_FULL = @as(c_long, 4314);
pub const GPT_BASIC_DATA_ATTRIBUTE_DAX = 288230376151711744;
pub const RPC_C_PROTSEQ_MAX_REQS_DEFAULT = 10;
pub const MARKPARITY = 3;
pub const _WIN32_IE_WIN2KSP3 = _WIN32_IE_IE501;
pub const __FLT16_MIN_10_EXP__ = -13;
pub const PIPE_CLIENT_END = 0;
pub const TMPF_TRUETYPE = 4;
pub const JOY_BUTTON9 = @as(c_long, 256);
pub const VIF_CANNOTRENAME = @as(c_long, 8192);
pub const FILE_FLAG_SESSION_AWARE = 8388608;
pub const SECURITY_MIN_NEVER_FILTERED = @as(c_long, 1000);
pub const TXFS_START_RM_FLAG_LOG_CONTAINER_SIZE = 4;
pub const ERROR_CTX_CLIENT_LICENSE_NOT_SET = @as(c_long, 7053);
pub const MSGF_USER = 4096;
pub const IMAGE_FILE_MACHINE_UNKNOWN = 0;
pub const NCRYPT_SIGNATURE_OPERATION = BCRYPT_SIGNATURE_OPERATION;
pub const RDW_NOINTERNALPAINT = 16;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_SOURCE = @as(c_long, 5958);
pub const ENABLE_QUICK_EDIT_MODE = 64;
pub const ERROR_PROCESS_MODE_ALREADY_BACKGROUND = @as(c_long, 402);
pub const CM_SERVICE_WINPE_BOOT_LOAD = 128;
pub const DEVICEDUMP_STRUCTURE_VERSION_V1 = 1;
pub const GetFullPathNameTransacted = GetFullPathNameTransactedA;
pub const IMR_RECONVERTSTRING = 4;
pub const MB_DEFMASK = @as(c_long, 3840);
pub const ILLUMINANT_TUNGSTEN = ILLUMINANT_A;
pub const QDI_STRETCHDIB = 8;
pub const FMFD_ENABLEMIMESNIFFING = 2;
pub const _Readable_elements_impl_ = size;
pub const MOUSEEVENTF_MIDDLEDOWN = 32;
pub const CERT_EXCLUDED_SUBTREE_BIT = @as(c_long, 2147483648);
pub const PBT_APMRESUMESUSPEND = 7;
pub const IMAGE_FILE_MACHINE_TARGET_HOST = 1;
pub const IMAGE_SYM_CLASS_MEMBER_OF_ENUM = 16;
pub const szOIDVerisign_RecipientNonce = "2.16.840.1.113733.1.9.6";
pub const HCF_CONFIRMHOTKEY = 8;
pub const VK_ICO_00 = 228;
pub const _Notvalid_ = _Notvalid_impl_;
pub const CERT_SERVER_OCSP_RESPONSE_ASYNC_FLAG = 1;
pub const COLOR_MENU = 4;
pub const PF_FLOATING_POINT_EMULATED = 1;
pub const VK_BROWSER_FAVORITES = 171;
pub const CERT_UNICODE_VALUE_ERR_INDEX_MASK = 65535;
pub const Uri_HAS_SCHEME_NAME = 1 << Uri_PROPERTY_SCHEME_NAME;
pub const szOID_DS_EMAIL_REPLICATION = "1.3.6.1.4.1.311.21.19";
pub const PF_CCITT = AF_CCITT;
pub const PKCS12_EXPORT_SILENT = 64;
pub const CERT_INFO_SUBJECT_UNIQUE_ID_FLAG = 10;
pub const WM_KEYFIRST = 256;
pub const __UINTPTR_FMTx__ = "llx";
pub const EROFS = 30;
pub const RotateLeft16 = _rotl16;
pub const ERROR_DS_DRA_REF_NOT_FOUND = @as(c_long, 8449);
pub const OpenEventLog = OpenEventLogA;
pub const ERROR_CTX_LICENSE_CLIENT_INVALID = @as(c_long, 7055);
pub const IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY = 128;
pub const ENOTTY = 25;
pub const szOID_PRESENTATION_ADDRESS = "2.5.4.29";
pub const VFT2_DRV_DISPLAY = @as(c_long, 4);
pub const VK_OEM_PA1 = 235;
pub const EMARCH_ENC_I17_IMM41c_VAL_POS_X = 40;
pub const CERT_AUTHORITY_INFO_ACCESS_PROP_ID = 68;
pub const __analysis_assert = e;
pub const LOGON_ZERO_PASSWORD_BUFFER = 2147483648;
pub const SPI_SETSCREENSAVESECURE = 119;
pub const CERT_STORE_NO_ISSUER_FLAG = 131072;
pub const CRYPT_OID_REGISTER_PHYSICAL_STORE_FUNC = "CertDllRegisterPhysicalStore";
pub const CRYPT_IMPL_HARDWARE = 1;
pub const FE_FONTSMOOTHINGCLEARTYPE = 2;
pub const __inexpressible_readableTo = size;
pub const WM_ENTERIDLE = 289;
pub const ERROR_PRI_MERGE_BUNDLE_PACKAGES_NOT_ALLOWED = @as(c_long, 15155);
pub const ALG_TYPE_BLOCK = 3 << 9;
pub const ERROR_EVT_FILTER_PARSEERR = @as(c_long, 15019);
pub const __UINT_FAST32_FMTo__ = "o";
pub const QS_POSTMESSAGE = 8;
pub const GW_CHILD = 5;
pub const FILE_STORAGE_TIER_NAME_LENGTH = 256;
pub const CERT_LOGOTYPE_DIRECT_INFO_CHOICE = 1;
pub const midiOutGetErrorText = midiOutGetErrorTextA;
pub const __out_ecount_nz_opt = size;
pub const NETSCAPE_SMIME_CA_CERT_TYPE = 2;
pub const GW_HWNDNEXT = 2;
pub const ERROR_PARTIAL_COPY = @as(c_long, 299);
pub const InterlockedIncrementRelease64 = _InterlockedIncrement64;
pub const PRF_CHILDREN = @as(c_long, 16);
pub const CF_BITMAP = 2;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_INTERFACE = @as(c_long, 9993);
pub const EndUpdateResource = EndUpdateResourceA;
pub const PRINTACTION_OPENNETPRN = 5;
pub const POINTER_FLAG_INCONTACT = 4;
pub const CERT_ACCESS_STATE_LM_SYSTEM_STORE_FLAG = 4;
pub const CBR_1200 = 1200;
pub const DMTT_BITMAP = 1;
pub const DCX_EXCLUDEUPDATE = @as(c_long, 256);
pub const URLOpenBlockingStream = URLOpenBlockingStreamA;
pub const SM_CXDLGFRAME = 7;
pub const DC_MEDIAREADY = 29;
pub const ChangeMenu = ChangeMenuA;
pub const PFD_DRAW_TO_WINDOW = 4;
pub const VK_GAMEPAD_DPAD_RIGHT = 206;
pub const IPPORT_RJE = 77;
pub const ERROR_DS_INVALID_GROUP_TYPE = @as(c_long, 8513);
pub const MOD_FMSYNTH = 4;
pub const LOCALE_SSHORTESTDAYNAME7 = 102;
pub const SC_MANAGER_MODIFY_BOOT_CONFIG = 32;
pub const ERROR_IPSEC_MM_FILTER_NOT_FOUND = @as(c_long, 13007);
pub const PERF_COUNTER_RATE = 65536;
pub const GetCharABCWidths = GetCharABCWidthsA;
pub const OLE_S_FIRST = if (@typeId(@typeOf(@as(c_long, 262144))) == @import("builtin").TypeId.Pointer) @ptrCast(HRESULT, @as(c_long, 262144)) else if (@typeId(@typeOf(@as(c_long, 262144))) == @import("builtin").TypeId.Int) @intToPtr(HRESULT, @as(c_long, 262144)) else HRESULT(@as(c_long, 262144));
pub const VK_PROCESSKEY = 229;
pub const IMAGE_REL_ALPHA_LITERAL = 4;
pub const ALG_CLASS_SIGNATURE = 1 << 13;
pub const BS_LEFT = @as(c_long, 256);
pub const BCRYPT_NO_KEY_VALIDATION = 8;
pub const DNS_ERROR_NOT_ALLOWED_ON_ZSK = @as(c_long, 9118);
pub const IMAGE_FILE_32BIT_MACHINE = 256;
pub const TAPE_QUERY_DEVICE_ERROR_DATA = @as(c_long, 4);
pub const MEM_PRIVATE = 131072;
pub const MF_REMOVE = @as(c_long, 4096);
pub const __failureDefault = x;
pub const WM_SETREDRAW = 11;
pub const IDN_USE_STD3_ASCII_RULES = 2;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_LABEL_ACE = 2;
pub const NI_SETCANDIDATE_PAGESTART = 22;
pub const WMSZ_TOP = 3;
pub const PERF_DETAIL_ADVANCED = 200;
pub const _WIN32_IE_WIN2KSP2 = _WIN32_IE_IE501;
pub const LANG_NORWEGIAN = 20;
pub const MB_SERVICE_NOTIFICATION = @as(c_long, 2097152);
pub const IMAGE_REL_SH3_DIRECT32 = 2;
pub const ELEMENT_STATUS_INVERT = 4194304;
pub const ERROR_DS_ENCODING_ERROR = @as(c_long, 8252);
pub const ERROR_BAD_COMMAND = @as(c_long, 22);
pub const IO_REPARSE_TAG_CLOUD_4 = @as(c_long, 2415935514);
pub const szOID_PREFERRED_DELIVERY_METHOD = "2.5.4.28";
pub const FILE_INITIATE_REPAIR_HINT1_ORPHAN = 34359738368;
pub const CRYPT_DECODE_TO_BE_SIGNED_FLAG = 2;
pub const PSM_SETFINISHTEXT = PSM_SETFINISHTEXTA;
pub const VTBIT_I8 = 1 << VT_I8;
pub const MS_STRONG_PROV = MS_STRONG_PROV_A;
pub const SECURITY_VALID_SQOS_FLAGS = 2031616;
pub const Uri_CREATE_NO_ENCODE_FORBIDDEN_CHARACTERS = 32768;
pub const CTRY_LIBYA = 218;
pub const EMARCH_ENC_I17_IMM41b_INST_WORD_X = 1;
pub const VarR4FromUint = VarR4FromUI4;
pub const STM_GETIMAGE = 371;
pub const APPCOMMAND_FIND = 28;
pub const SERVICE_PAUSE_PENDING = 6;
pub const DDE_FREQUESTED = 4096;
pub const SECURITY_RDV_GFX_BASE_RID = @as(c_long, 91);
pub const NCRYPT_PLATFORM_ATTEST_MAGIC = 1146110288;
pub const __FLT16_HAS_DENORM__ = 1;
pub const ERROR_GEN_FAILURE = @as(c_long, 31);
pub const USER_MARSHAL_FC_BYTE = 1;
pub const MMIOM_WRITE = MMIO_WRITE;
pub const PIDMSI_OWNER = @as(c_long, 8);
pub const ERROR_EVT_MAX_INSERTS_REACHED = @as(c_long, 15031);
pub const PROCESSOR_PERF_PERFORMANCE_PREFERENCE = 255;
pub const ERROR_HANDLES_CLOSED = @as(c_long, 676);
pub const CERT_SELECT_HAS_KEY_FOR_SIGNATURE = 16;
pub const szOID_NETSCAPE_CERT_EXTENSION = "2.16.840.1.113730.1";
pub const DNS_ERROR_RECORD_DOES_NOT_EXIST = @as(c_long, 9701);
pub const ACCESS_MAX_LEVEL = 4;
pub const MEM_EXTENDED_PARAMETER_ZERO_PAGES_OPTIONAL = 4;
pub const NIF_REALTIME = 64;
pub const MCI_LOAD_FILE = @as(c_long, 256);
pub const VK_OEM_PA2 = 236;
pub const POPENCARDNAME_A = POPENCARDNAMEA;
pub const PRODUCT_ENTERPRISEGN = 172;
pub const CDN_SHAREVIOLATION = if (@typeId(@typeOf(-3)) == @import("builtin").TypeId.Pointer) @ptrCast(CDN_FIRST, -3) else if (@typeId(@typeOf(-3)) == @import("builtin").TypeId.Int) @intToPtr(CDN_FIRST, -3) else CDN_FIRST(-3);
pub const SUBLANG_HINDI_INDIA = 1;
pub const CERT_TRUST_INVALID_POLICY_CONSTRAINTS = 512;
pub const MSGFLT_DISALLOW = 2;
pub const WSA_SECURE_HOST_NOT_FOUND = @as(c_long, 11032);
pub const SS_GRAYFRAME = @as(c_long, 8);
pub const SERVICE_STOP_REASON_MINOR_NETWORK_CONNECTIVITY = 17;
pub const MCI_VD_FORMAT_TRACK = 16385;
pub const PRINTER_ENUM_CONNECTIONS = 4;
pub const IME_CMODE_NOCONVERSION = 256;
pub const MB_ICONEXCLAMATION = @as(c_long, 48);
pub const IMAGE_REL_AMD64_CFG_BR_REX = 21;
pub const URLPOLICY_JAVA_MEDIUM = 131072;
pub const NRC_SNUMOUT = 8;
pub const WNFMT_MULTILINE = 1;
pub const RESOURCE_MANAGER_VOLATILE = 1;
pub const FILE_DEVICE_PRINTER = 24;
pub const MAX_DEFAULTCHAR = 2;
pub const HIBERFILE_TYPE_FULL = 2;
pub const SERVICE_CONTROL_PAUSE = 2;
pub const XSTATE_ALIGN_MASK = if (@typeId(@typeOf(i64 << XSTATE_ALIGN_BIT)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << XSTATE_ALIGN_BIT) else if (@typeId(@typeOf(i64 << XSTATE_ALIGN_BIT)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << XSTATE_ALIGN_BIT) else @as(c_uint, 1)(i64 << XSTATE_ALIGN_BIT);
pub const RI_KEY_BREAK = 1;
pub const CRYPTPROTECT_CRED_REGENERATE = 128;
pub const FACILITY_SSPI = 9;
pub const CE_OVERRUN = 2;
pub const PARTITION_PREP = 65;
pub const ERROR_PATCH_PACKAGE_UNSUPPORTED = @as(c_long, 1637);
pub const SM_NETWORK = 63;
pub const __FLT_RADIX__ = 2;
pub const VK_VOLUME_DOWN = 174;
pub const KLF_REPLACELANG = 16;
pub const SCARD_SPECIFIC = 6;
pub const WM_EXITMENULOOP = 530;
pub const SCARD_EJECT_CARD = 3;
pub const PC_POLYGON = 1;
pub const DPI_AWARENESS_CONTEXT_UNAWARE = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(DPI_AWARENESS_CONTEXT, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(DPI_AWARENESS_CONTEXT, -1) else DPI_AWARENESS_CONTEXT(-1);
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED = 2;
pub const CRYPT_DESTROYKEY = 4;
pub const WSANO_DATA = @as(c_long, 11004);
pub const VK_OEM_NEC_EQUAL = 146;
pub const NLS_ROMAN = 4194304;
pub const CRYPT_BLOB_VER3 = 128;
pub const MS_ENHANCED_PROV_A = "Microsoft Enhanced Cryptographic Provider v1.0";
pub const LOCALE_SNAN = 105;
pub const VIF_SHARINGVIOLATION = @as(c_long, 1024);
pub const STDOLE_LCID = 0;
pub const DMPAPER_ENV_C65 = 32;
pub const DFCS_FLAT = 16384;
pub const RPC_C_OPT_PRIVATE_DO_NOT_DISTURB = 2;
pub const szOID_CN_ECDSA_SHA256 = "1.2.156.11235.1.1.1";
pub const GetLogicalDriveStrings = GetLogicalDriveStringsA;
pub const IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_2 = 2;
pub const ERROR_CLUSTER_NODE_ISOLATED = @as(c_long, 5984);
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_ACCESS_FILTER_ACE = 4;
pub const STORAGE_COMPONENT_ROLE_TIERING = 2;
pub const CMSG_SIGNER_INFO_PARAM = 6;
pub const SECURITY_WINRM_ID_RID_COUNT = @as(c_long, 6);
pub const InterlockedExchangeNoFence = _InterlockedExchange;
pub const WN_NOT_INITIALIZING = ERROR_ALREADY_INITIALIZED;
pub const IPPROTO_PUP = 12;
pub const PAN_SERIF_OBTUSE_SQUARE_COVE = 5;
pub const MDMVOL_MEDIUM = 1;
pub const X3_BTYPE_QP_INST_WORD_POS_X = 23;
pub const WM_HELP = 83;
pub const DMPAPER_PENV_5_ROTATED = 113;
pub const szOID_LOCALITY_NAME = "2.5.4.7";
pub const UPDFCACHE_NORMALCACHE = 8;
pub const DMPAPER_JENV_CHOU3_ROTATED = 86;
pub const CRYPT_ENCODE_ENABLE_PUNYCODE_FLAG = 131072;
pub const VER_LESS = 4;
pub const ERROR_WAS_LOCKED = @as(c_long, 717);
pub const szOID_ROOT_PROGRAM_AUTO_UPDATE_END_REVOCATION = "1.3.6.1.4.1.311.60.3.2";
pub const PROPSHEETPAGE = PROPSHEETPAGEA;
pub const ERROR_DS_PARENT_IS_AN_ALIAS = @as(c_long, 8330);
pub const BF_FLAT = 16384;
pub const HCF_AVAILABLE = 2;
pub const GetUserName = GetUserNameA;
pub const PSINJECT_DOCNEEDEDRES = 5;
pub const IMAGE_REL_IA64_PCREL21F = 8;
pub const SPI_GETSERIALKEYS = 62;
pub const IO_REPARSE_TAG_CLOUD_5 = @as(c_long, 2415939610);
pub const MaxNumberOfEEInfoParams = 4;
pub const FACILITY_DXGI = 2170;
pub const SPI_SETSHOWSOUNDS = 57;
pub const PROCESS_CREATION_MITIGATION_POLICY_BOTTOM_UP_ASLR_ALWAYS_OFF = 2 << 16;
pub const ERROR_DELETING_EXISTING_APPLICATIONDATA_STORE_FAILED = @as(c_long, 15621);
pub const ERROR_DESTROY_OBJECT_OF_OTHER_THREAD = @as(c_long, 1435);
pub const PAN_STROKE_GRADUAL_HORZ = 5;
pub const ERROR_EAS_NOT_SUPPORTED = @as(c_long, 282);
pub const ERROR_NO_LOG_SPACE = @as(c_long, 1019);
pub const BF_SOFT = 4096;
pub const CMC_FAIL_POP_FAILED = 9;
pub const INVALID_FILE_ATTRIBUTES = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, -1) else DWORD(-1);
pub const CERT_COMPARE_PROPERTY = 5;
pub const VK_BROWSER_FORWARD = 167;
pub const MCI_WHERE = 2115;
pub const AW_SLIDE = 262144;
pub const OCSP_REQUEST_V1 = 0;
pub const ERROR_NO_WORK_DONE = @as(c_long, 235);
pub const PROTECTION_LEVEL_AUTHENTICODE = 7;
pub const MARK_HANDLE_ENABLE_CPU_CACHE = 268435456;
pub const CERT_RSA_PUBLIC_KEY_OBJID = szOID_RSA_RSA;
pub const DMPAPER_A4_ROTATED = 77;
pub const VAR_DATEVALUEONLY = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 2) else DWORD(2);
pub const TOUCH_MASK_NONE = 0;
pub const DISPLAYCONFIG_PATH_ACTIVE = 1;
pub const OCSP_UNAUTHORIZED_RESPONSE = 6;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE = 2;
pub const ERROR_DIR_NOT_ROOT = @as(c_long, 144);
pub const VK_F7 = 118;
pub const szOID_KP_FLIGHT_SIGNING = "1.3.6.1.4.1.311.10.3.27";
pub const CRYPT_KM = 2;
pub const STATE_SYSTEM_READONLY = 64;
pub const PRINTER_CHANGE_PRINT_PROCESSOR = 117440512;
pub const WM_UNINITMENUPOPUP = 293;
pub const MUTZ_RESERVED = 512;
pub const NCRYPTBUFFER_TPM_PLATFORM_CLAIM_NONCE = 81;
pub const RDW_NOERASE = 32;
pub const CRYPTPROTECT_CRED_SYNC = 8;
pub const IMAGE_SCN_ALIGN_2BYTES = 2097152;
pub const RPC_BHO_NONCAUSAL = 1;
pub const s_net = S_un.S_un_b.s_b1;
pub const ERROR_DISCARDED = @as(c_long, 157);
pub const VK_OEM_PA3 = 237;
pub const MCI_WAVE_SET_BLOCKALIGN = @as(c_long, 1048576);
pub const RESOURCEMANAGER_REGISTER_PROTOCOL = 32;
pub const ALERT_SYSTEM_ERROR = 3;
pub const PDERR_LOADDRVFAILURE = 4100;
pub const PrinterMessageBox = PrinterMessageBoxA;
pub const RPC_X_SS_HANDLES_MISMATCH = @as(c_long, 1778);
pub const RegReplaceKey = RegReplaceKeyA;
pub const StartDoc = StartDocA;
pub const EN_ERRSPACE = 1280;
pub const EVENT_E_LAST = @as(c_long, 2147746335);
pub const CTLCOLOR_STATIC = 6;
pub const VOS__PM16 = @as(c_long, 2);
pub const AccessCheckAndAuditAlarm = AccessCheckAndAuditAlarmA;
pub const CHAR_MAX = SCHAR_MAX;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE = 53;
pub const CONTAINER_ROOT_INFO_FLAG_LAYER_ROOT = 2;
pub const ERROR_NOT_A_REPARSE_POINT = @as(c_long, 4390);
pub const IMAGE_REL_BASED_HIGHLOW = 3;
pub const VP_CP_CMD_CHANGE = 4;
pub const ERROR_ALL_NODES_NOT_AVAILABLE = @as(c_long, 5037);
pub const __UINT_FAST32_FMTu__ = "u";
pub const ObjectCloseAuditAlarm = ObjectCloseAuditAlarmA;
pub const CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 33554432;
pub const CALLBACK_CHUNK_FINISHED = 0;
pub const MCI_STATUS_POSITION = @as(c_long, 2);
pub const CLRBREAK = 9;
pub const HTMINBUTTON = 8;
pub const DeleteForm = DeleteFormA;
pub const szOID_TELEPHONE_NUMBER = "2.5.4.20";
pub const CRYPT_OID_FIND_OID_INFO_FUNC = "CryptDllFindOIDInfo";
pub const ERROR_NO_EVENT_PAIR = @as(c_long, 580);
pub const SECURITY_MANDATORY_MAXIMUM_USER_RID = SECURITY_MANDATORY_SYSTEM_RID;
pub const SUBLANG_KONKANI_INDIA = 1;
pub const WNNC_NET_DCE = 1638400;
pub const MDMVOLFLAG_LOW = 1;
pub const HELP_SETPOPUP_POS = 13;
pub const CRYPT_OID_FIND_LOCALIZED_NAME_FUNC = "CryptDllFindLocalizedName";
pub const STATUS_FLOAT_DENORMAL_OPERAND = if (@typeId(@typeOf(@as(c_long, 3221225613))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221225613)) else if (@typeId(@typeOf(@as(c_long, 3221225613))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221225613)) else DWORD(@as(c_long, 3221225613));
pub const DMPAPER_10X11 = 45;
pub const POINTER_FLAG_SECONDBUTTON = 32;
pub const Uri_HAS_SCHEME = 1 << Uri_PROPERTY_SCHEME;
pub const szOID_DYNAMIC_CODE_GEN_SIGNER = "1.3.6.1.4.1.311.76.5.1";
pub const LOCALE_SSHORTESTDAYNAME1 = 96;
pub const LBN_SETFOCUS = 4;
pub const IS_TEXT_UNICODE_STATISTICS = 2;
pub const ERROR_SXS_XML_E_BADXMLCASE = @as(c_long, 14069);
pub const szOID_ECC_CURVE_SECP160K1 = "1.3.132.0.9";
pub const OF_DELETE = 512;
pub const DMPAPER_PENV_4_ROTATED = 112;
pub const s_lh = S_un.S_un_b.s_b3;
pub const LANG_MALAYALAM = 76;
pub const CreateDialog = CreateDialogA;
pub const __UINT64_C_SUFFIX__ = ULL;
pub const URL_OID_CERTIFICATE_OCSP_AND_CRL_DIST_POINT = if (@typeId(@typeOf(10)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 10) else if (@typeId(@typeOf(10)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 10) else LPCSTR(10);
pub const HDATA_APPOWNED = 1;
pub const EM_SETPASSWORDCHAR = 204;
pub const PAN_XHEIGHT_DUCKING_STD = 6;
pub const LANG_SYRIAC = 90;
pub const IDH_OK = 28443;
pub const CERT_DISALLOWED_CERT_CTL_FILENAME_A = "disallowedcert.stl";
pub const ERROR_CTX_TD_ERROR = @as(c_long, 7017);
pub const SCARD_READER_TYPE_NFC = 256;
pub const CERT_SELECT_MAX = if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Pointer) @ptrCast([*c]CERT_SELECT_LAST, 3) else if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Int) @intToPtr([*c]CERT_SELECT_LAST, 3) else ([*c]CERT_SELECT_LAST)(3);
pub const TOUCHEVENTF_UP = 4;
pub const ACCESS_REASON_EXDATA_MASK = 2130706432;
pub const ALG_SID_AGREED_KEY_ANY = 3;
pub const RPC_QUERY_IS_CLIENT_LOCAL = 32;
pub const CERT_CHAIN_POLICY_SSL_KEY_PIN_MITM_ERROR = -1;
pub const _WIN32_IE_WIN2KSP4 = _WIN32_IE_IE501;
pub const IMAGE_REL_M32R_PAIR = 11;
pub const LANG_YI = 120;
pub const WriteLongPtrRaw = WriteRaw64;
pub const ERROR_LOG_METADATA_INCONSISTENT = @as(c_long, 6614);
pub const ERROR_INVALID_OPERATION = @as(c_long, 4317);
pub const IMAGE_SCN_GPREL = 32768;
pub const mixerGetLineControls = mixerGetLineControlsA;
pub const IO_REPARSE_TAG_CLOUD_6 = @as(c_long, 2415943706);
pub const MCI_ANIM_PUT_DESTINATION = @as(c_long, 262144);
pub const FILE_ATTRIBUTE_INTEGRITY_STREAM = 32768;
pub const SPI_SETMOUSEHOVERWIDTH = 99;
pub const CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR = 9;
pub const TRANSACTIONMANAGER_RECOVER = 4;
pub const LB_GETTEXTLEN = 394;
pub const NCRYPTBUFFER_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = 54;
pub const REG_STANDARD_FORMAT = 1;
pub const ERROR_WMI_INVALID_REGINFO = @as(c_long, 4211);
pub const PD_HIDEPRINTTOFILE = 1048576;
pub const FILE_STORAGE_TIER_FLAG_NO_SEEK_PENALTY = 131072;
pub const ERROR_CLUSTER_INVALID_NODE_WEIGHT = @as(c_long, 5954);
pub const RPC_S_NOTHING_TO_EXPORT = @as(c_long, 1754);
pub const GWLP_ID = -12;
pub const PKCS12_EXPORT_PBES2_PARAMS = 128;
pub const MCI_WAVE_SET_CHANNELS = @as(c_long, 131072);
pub const POPENCARDNAMEW_EX = POPENCARDNAME_EXW;
pub const FreeEnvironmentStrings = FreeEnvironmentStringsA;
pub const FACILITY_STATEREPOSITORY = 103;
pub const MemoryFence = _mm_mfence;
pub const WN_NOT_LOGGED_ON = ERROR_NOT_LOGGED_ON;
pub const SUBLANG_BRETON_FRANCE = 1;
pub const InterlockedXor = _InterlockedXor;
pub const NIF_ICON = 2;
pub const RPC_S_INVALID_STRING_BINDING = @as(c_long, 1700);
pub const ERROR_DS_NAME_ERROR_TRUST_REFERRAL = @as(c_long, 8583);
pub const VK_F6 = 117;
pub const MMIOM_RENAME = 6;
pub const EXIT_SUCCESS = 0;
pub const PSH_USEPAGELANG = 2097152;
pub const IMAGE_REL_IA64_SREL32 = 19;
pub const _WIN32_WINNT_WIN8 = 1538;
pub const SERVICE_TRIGGER_TYPE_IP_ADDRESS_AVAILABILITY = 2;
pub const ERROR_DISK_NOT_CSV_CAPABLE = @as(c_long, 5964);
pub const ERROR_DS_RECALCSCHEMA_FAILED = @as(c_long, 8396);
pub const LB_GETCARETINDEX = 415;
pub const LOCALE_SNATIVECOUNTRYNAME = 8;
pub const SYSTEM_ACCESS_FILTER_ACE_TYPE = 21;
pub const IMAGE_REL_ALPHA_REFQ2 = 20;
pub const VOS_DOS = @as(c_long, 65536);
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_8 = 8;
pub const WNNC_NET_YAHOO = 2883584;
pub const CTRL_CLOSE_EVENT = 2;
pub const NCRYPT_3DES_ALGORITHM = BCRYPT_3DES_ALGORITHM;
pub const NUMPRS_NEG = 65536;
pub const DDL_HIDDEN = 2;
pub const SHUTDOWN_ARSO = 8192;
pub const SM_CXFRAME = 32;
pub const DD_DEFDRAGMINDIST = 2;
pub const ERROR_WINS_INTERNAL = @as(c_long, 4000);
pub const CONTEXT_OID_CREATE_OBJECT_CONTEXT_FUNC = "ContextDllCreateObjectContext";
pub const MDM_PIAFS_INCOMING = 0;
pub const WSAEDQUOT = @as(c_long, 10069);
pub const szOID_REGISTERED_ADDRESS = "2.5.4.26";
pub const VarIntFromUint = VarI4FromUI4;
pub const SERVICE_NOTIFY_RUNNING = 8;
pub const CTRY_ALGERIA = 213;
pub const WIZ_CYDLG = 140;
pub const TOUCH_MASK_ORIENTATION = 2;
pub const WM_APPCOMMAND = 793;
pub const szOID_ECC_CURVE_P384 = "1.3.132.0.34";
pub const __override = __inner_override;
pub const CRYPT_KEYID_SET_NEW_FLAG = 8192;
pub const BAUD_9600 = if (@typeId(@typeOf(2048)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 2048) else if (@typeId(@typeOf(2048)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 2048) else DWORD(2048);
pub const CdChangerClassGuid = GUID_DEVINTERFACE_CDCHANGER;
pub const InterlockedBitTestAndResetRelease = _interlockedbittestandreset;
pub const __AVX2__ = 1;
pub const URLACTION_FEATURE_SCRIPT_STATUS_BAR = 8451;
pub const IsLoggingEnabled = IsLoggingEnabledA;
pub const WriteSizeTNoFence = WriteULongPtrNoFence;
pub const CERT_FIND_PROPERTY = CERT_COMPARE_PROPERTY << CERT_COMPARE_SHIFT;
pub const PROP_SM_CYDLG = 188;
pub const PRINTER_CHANGE_SET_PRINTER_DRIVER = 536870912;
pub const BCRYPT_PAD_OAEP = 4;
pub const SCROLLLOCK_ON = 64;
pub const XCLASS_FLAGS = 16384;
pub const MAX_REASON_NAME_LEN = 64;
pub const SUBLANG_SERBIAN_MONTENEGRO_LATIN = 11;
pub const LOCALE_SSHORTESTDAYNAME2 = 97;
pub const PROCESSOR_ARM920 = 2336;
pub const LOCALE_SDECIMAL = 14;
pub const MDMVOLFLAG_HIGH = 4;
pub const MK_E_FIRST = @as(c_long, 2147746272);
pub const InterlockedAndAffinity = InterlockedAnd64;
pub const CACHE_S_FIRST = @as(c_long, 262512);
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP = 1;
pub const BCRYPT_XTS_AES_ALG_HANDLE = if (@typeId(@typeOf(897)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 897) else if (@typeId(@typeOf(897)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 897) else BCRYPT_ALG_HANDLE(897);
pub const CRYPT_PARAM_CANCEL_ASYNC_RETRIEVAL = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 2) else LPCSTR(2);
pub const PSH_USEPSTARTPAGE = 64;
pub const WINEVENT_INCONTEXT = 4;
pub const CHANGER_IEPORT_USER_CONTROL_CLOSE = 2147483904;
pub const ERROR_DS_OID_NOT_FOUND = @as(c_long, 8638);
pub const SHTDN_REASON_MINOR_DC_DEMOTION = 34;
pub const PFORCEINLINE = FORCEINLINE;
pub const PRINTER_CHANGE_ADD_PRINTER = 1;
pub const WINNORMALIZEAPI = DECLSPEC_IMPORT;
pub const CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL = 8192;
pub const ERROR_CORRUPT_LOG_CLEARED = @as(c_long, 798);
pub const NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_CURRENT_VERSION = NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES_V0;
pub const __RETURN_POLICY_DST = _FunctionCall;
pub const LB_INITSTORAGE = 424;
pub const szOID_ENROLL_SCEP_SERVER_MESSAGE = "1.3.6.1.4.1.311.21.38";
pub const SS_WHITERECT = @as(c_long, 6);
pub const IS_TEXT_UNICODE_NOT_ASCII_MASK = 61440;
pub const SUBLANG_PULAR_SENEGAL = 2;
pub const EFS_PFILE_SUBVER_RMS = 2;
pub const URLPOLICY_NOTIFY_ON_ALLOW = 16;
pub const TOUCHINPUTMASKF_CONTACTAREA = 4;
pub const LAYOUT_VBH = 4;
pub const SPI_SETLANGTOGGLE = 91;
pub const PARAMFLAG_FLCID = 4;
pub const LOCALE_IDEFAULTLANGUAGE = 9;
pub const ERROR_DS_CROSS_NC_DN_RENAME = @as(c_long, 8368);
pub const Shell_NotifyIcon = Shell_NotifyIconA;
pub const CRYPT_USER_PROTECTED = 2;
pub const __FLT_MAX_10_EXP__ = 38;
pub const EMR_SETPOLYFILLMODE = 19;
pub const DISABLE_SMART = 217;
pub const READ_THREAD_PROFILING_FLAG_DISPATCHING = 1;
pub const STM_GETICON = 369;
pub const IO_REPARSE_TAG_CLOUD_7 = @as(c_long, 2415947802);
pub const XSTATE_MASK_IPT = if (@typeId(@typeOf(i64 << XSTATE_IPT)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << XSTATE_IPT) else if (@typeId(@typeOf(i64 << XSTATE_IPT)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << XSTATE_IPT) else @as(c_uint, 1)(i64 << XSTATE_IPT);
pub const CRYPT_FAILED = FALSE;
pub const CERT_STORE_BASE_CRL_FLAG = 256;
pub const JOB_OBJECT_SET_ATTRIBUTES = 2;
pub const FILE_CACHE_MAX_HARD_ENABLE = 1;
pub const SET_FEATURE_ON_THREAD_INTRANET = 16;
pub const DT_TABSTOP = 128;
pub const SP_HANDSHAKING = if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 16) else if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 16) else DWORD(16);
pub const ERROR_MP_PROCESSOR_MISMATCH = @as(c_long, 725);
pub const ERROR_CONTROLLING_IEPORT = @as(c_long, 4329);
pub const ACTIVEOBJECT_STRONG = 0;
pub const ERROR_FILE_CHECKED_OUT = @as(c_long, 220);
pub const LOCALE_INEGSYMPRECEDES = 86;
pub const PAGE_WRITECOMBINE = 1024;
pub const GetWindowModuleFileName = GetWindowModuleFileNameA;
pub const _WIN32_IE_NT4 = _WIN32_IE_IE20;
pub const szOID_ENCLAVE_SIGNING = "1.3.6.1.4.1.311.10.3.42";
pub const PARSE_DECODE = PARSE_DECODE_IS_ESCAPE;
pub const MONITOR_DEFAULTTONEAREST = 2;
pub const DMLERR_FIRST = 16384;
pub const STREAMS_MAX_ID = MAXWORD;
pub const X3_OPCODE_INST_WORD_X = 3;
pub const ACCESS_PROPERTY_GUID = 2;
pub const ERROR_INVALID_USER_BUFFER = @as(c_long, 1784);
pub const X509_NAME_VALUE = if (@typeId(@typeOf(6)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 6) else if (@typeId(@typeOf(6)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 6) else LPCSTR(6);
pub const LCS_GM_ABS_COLORIMETRIC = @as(c_long, 8);
pub const IMAGE_HOT_PATCH_CHUNK_SOURCE_RVA = 32768;
pub const BCRYPT_EXTENDED_KEYSIZE = 128;
pub const FS_THAI = @as(c_long, 65536);
pub const PFD_MAIN_PLANE = 0;
pub const LB_SETHORIZONTALEXTENT = 404;
pub const VK_F5 = 116;
pub const ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE = @as(c_long, 6019);
pub const SUBLANG_FILIPINO_PHILIPPINES = 1;
pub const CFSTR_MIME_AVI = if (@typeId(@typeOf("video/avi")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "video/avi") else if (@typeId(@typeOf("video/avi")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "video/avi") else TEXT("video/avi");
pub const CONTAINER_ROOT_INFO_FLAG_VIRTUALIZATION_TARGET_ROOT = 8;
pub const __INT_FAST64_FMTi__ = "lli";
pub const ERROR_DS_DISALLOWED_NC_REDIRECT = @as(c_long, 8640);
pub const WNNC_NET_BMC = 1572864;
pub const IMAGE_REL_ALPHA_REFQ3 = 19;
pub const ERROR_DS_NON_BASE_SEARCH = @as(c_long, 8480);
pub const szOID_NIST_sha256 = "2.16.840.1.101.3.4.2.1";
pub const IMAGE_ENCLAVE_LONG_ID_LENGTH = ENCLAVE_LONG_ID_LENGTH;
pub const LGRPID_ARABIC = 13;
pub const CDS_VIDEOPARAMETERS = 32;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_9 = 9;
pub const AW_HOR_POSITIVE = 1;
pub const SM_CLEANBOOT = 67;
pub const URLACTION_FEATURE_CROSSDOMAIN_FOCUS_CHANGE = 8455;
pub const VAR_CALENDAR_THAI = if (@typeId(@typeOf(128)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 128) else if (@typeId(@typeOf(128)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 128) else DWORD(128);
pub const VK_GAMEPAD_RIGHT_THUMBSTICK_DOWN = 216;
pub const CTRY_ARGENTINA = 54;
pub const CMSG_OID_CAPI1_EXPORT_MAIL_LIST_FUNC = CMSG_OID_EXPORT_MAIL_LIST_FUNC;
pub const PRINTER_NOTIFY_FIELD_FRIENDLY_NAME = 27;
pub const HSHELL_MONITORCHANGED = 16;
pub const EM_UNDO = 199;
pub const __inner_blocksOn = resource;
pub const ERROR_MCA_EXCEPTION = @as(c_long, 784);
pub const ERROR_DS_DRA_EXTN_CONNECTION_FAILED = @as(c_long, 8466);
pub const FILE_PREFETCH_TYPE_FOR_CREATE_EX = 3;
pub const COMMON_LVB_LEADING_BYTE = 256;
pub const szOID_ISSUER_ALT_NAME = "2.5.29.8";
pub const CERT_STORE_REVOCATION_FLAG = 4;
pub const ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE = @as(c_long, 1297);
pub const _SAL_VERSION_SAL2 = _A;
pub const MCI_RECORD = 2063;
pub const PROCESS_CREATION_MITIGATION_POLICY_HIGH_ENTROPY_ASLR_DEFER = 0 << 20;
pub const NCRYPT_DH_ALGORITHM_GROUP = NCRYPT_DH_ALGORITHM;
pub const GetDiskFreeSpaceEx = GetDiskFreeSpaceExA;
pub const SM_CXMAXIMIZED = 61;
pub const IME_KHOTKEY_ENGLISH = 82;
pub const DRAGDROP_E_FIRST = @as(c_long, 2147746048);
pub const VK_OEM_FJ_LOYA = 149;
pub const SUBLANG_TAMIL_INDIA = 1;
pub const CMSG_MAX_LENGTH_FLAG = 32;
pub const PSH_WIZARD97 = 16777216;
pub const EMARCH_ENC_I17_IMM5C_INST_WORD_X = 3;
pub const NULL = if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast([*c]void, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr([*c]void, 0) else ([*c]void)(0);
pub const NTDDI_WIN10_19H1 = 167772167;
pub const ERROR_ALLOCATE_BUCKET = @as(c_long, 602);
pub const REG_LOAD_HIVE_OPEN_HANDLE = @as(c_long, 2048);
pub const DeletePrinterDriverPackage = DeletePrinterDriverPackageA;
pub const STOCK_LAST = 19;
pub const WH_JOURNALPLAYBACK = 1;
pub const PID_LOCALE = 2147483648;
pub const UNLOAD_DLL_DEBUG_EVENT = 7;
pub const WS_BORDER = @as(c_long, 8388608);
pub const WIZ_CXBMP = 80;
pub const MDM_MASK_HDLCPPP_SPEED = 7;
pub const XCLASS_NOTIFICATION = 32768;
pub const PROCESSOR_ARCHITECTURE_IA32_ON_WIN64 = 10;
pub const SE_ACCESS_CHECK_FLAG_NO_LEARNING_MODE_LOGGING = 8;
pub const WSAEINVALIDPROVIDER = @as(c_long, 10105);
pub const SCARD_CLASS_POWER_MGMT = 4;
pub const __deref_opt_inout_ecount_nz = size;
pub const LOCALE_SSHORTESTDAYNAME3 = 98;
pub const __DBL_HAS_QUIET_NAN__ = 1;
pub const RESOURCEDISPLAYTYPE_SERVER = 2;
pub const MK_LBUTTON = 1;
pub const RPC_C_VERS_MAJOR_ONLY = 4;
pub const ENCLAVE_TYPE_SGX2 = 2;
pub const PROCESSOR_PERF_BOOST_POLICY_MAX = 100;
pub const FLASHW_CAPTION = 1;
pub const PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON = 1 << 8;
pub const ERROR_IPSEC_IKE_DH_FAIL = @as(c_long, 13822);
pub const szOID_ENROLL_EKPUB_CHALLENGE = "1.3.6.1.4.1.311.21.26";
pub const IFX_RSA_KEYGEN_VUL_AFFECTED_LEVEL_1 = 1;
pub const PRODUCT_MULTIPOINT_STANDARD_SERVER = 76;
pub const ALG_SID_AES_128 = 14;
pub const SECURITY_BUILTIN_PACKAGE_ANY_PACKAGE = @as(c_long, 1);
pub const ERROR_IPSEC_DOSP_RECEIVED_MULTICAST = @as(c_long, 13926);
pub const ERROR_WORKING_SET_QUOTA = @as(c_long, 1453);
pub const DOMAIN_GROUP_RID_READONLY_CONTROLLERS = @as(c_long, 521);
pub const CFSTR_MIME_HTML = if (@typeId(@typeOf("text/html")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "text/html") else if (@typeId(@typeOf("text/html")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "text/html") else TEXT("text/html");
pub const CERT_STORE_PROV_PHYSICAL = CERT_STORE_PROV_PHYSICAL_W;
pub const ALERT_SYSTEM_WARNING = 2;
pub const CRYPT_OID_IMPORT_PUBLIC_KEY_INFO_FUNC = "CryptDllImportPublicKeyInfoEx";
pub const FR_WRAPAROUND = 1048576;
pub const szOID_DH_SINGLE_PASS_STDDH_SHA1_KDF = "1.3.133.16.840.63.0.2";
pub const SERVICE_STOP_REASON_MINOR_HARDWARE_DRIVER = 11;
pub const UNRECOVERED_WRITES_VALID = 2;
pub const LGRPID_TURKISH = 6;
pub const GET_SYSTEM_WOW64_DIRECTORY_NAME_A_A = "GetSystemWow64DirectoryA";
pub const SPI_SETMOUSECLICKLOCK = 4127;
pub const CRYPT_NO_SALT = 16;
pub const CERT_PROT_ROOT_INHIBIT_ADD_AT_INIT_FLAG = 2;
pub const OFN_NONETWORKBUTTON = 131072;
pub const CertNameToStr = CertNameToStrA;
pub const ERROR_ENCLAVE_FAILURE = @as(c_long, 349);
pub const DSPRINT_UPDATE = 2;
pub const RegDeleteKeyEx = RegDeleteKeyExA;
pub const CERT_KEY_IDENTIFIER_PROP_ID = 20;
pub const MEM_LARGE_PAGES = 536870912;
pub const NETSCAPE_SMIME_CERT_TYPE = 32;
pub const MAXIMUM_REPARSE_DATA_BUFFER_SIZE = if (@typeId(@typeOf(1024)) == @import("builtin").TypeId.Pointer) @ptrCast([*c]16, 1024) else if (@typeId(@typeOf(1024)) == @import("builtin").TypeId.Int) @intToPtr([*c]16, 1024) else ([*c]16)(1024);
pub const PF_ARM_V8_INSTRUCTIONS_AVAILABLE = 29;
pub const __INT_FAST64_MAX__ = @as(c_longlong, 9223372036854775807);
pub const szOID_CMC_QUERY_PENDING = "1.3.6.1.5.5.7.7.21";
pub const ERROR_DS_GOVERNSID_MISSING = @as(c_long, 8410);
pub const GMEM_INVALID_HANDLE = 32768;
pub const MK_RBUTTON = 2;
pub const WM_POINTERDEVICEOUTOFRANGE = 570;
pub const TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CRL = if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 5) else if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 5) else LPCSTR(5);
pub const FACILITY_DMSERVER = 256;
pub const STORE_ERROR_LICENSE_REVOKED = @as(c_long, 15864);
pub const IO_REPARSE_TAG_RESERVED_TWO = 2;
pub const MDM_ERROR_CONTROL = 2;
pub const LoadFence = _mm_lfence;
pub const ERROR_DS_ALIAS_POINTS_TO_ALIAS = @as(c_long, 8336);
pub const CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC = "CryptMsgDllImportEncryptKey";
pub const DFCS_BUTTON3STATE = 8;
pub const ERROR_INVALID_DOMAINNAME = @as(c_long, 1212);
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY = @as(c_long, 13840);
pub const STORATTRIBUTE_MANAGEMENT_STATE = 1;
pub const CERT_STORE_PROV_MSG = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 1) else LPCSTR(1);
pub const IMAGE_REL_PPC_BRTAKEN = 512;
pub const VK_NONCONVERT = 29;
pub const VK_F4 = 115;
pub const PRINTACTION_NETINSTALL = 2;
pub const APPLICATION_ERROR_MASK = 536870912;
pub const OF_CANCEL = 2048;
pub const STANDARD_RIGHTS_WRITE = READ_CONTROL;
pub const ERROR_CSCSHARE_OFFLINE = @as(c_long, 1262);
pub const ERROR_IPSEC_IKE_DH_FAILURE = @as(c_long, 13864);
pub const szOID_ECC_CURVE_BRAINPOOLP192T1 = "1.3.36.3.3.2.8.1.1.4";
pub const SRB_TYPE_SCSI_REQUEST_BLOCK = 0;
pub const FILE_ACTION_ADDED = 1;
pub const CP_WINANSI = 1004;
pub const SEARCH_ALTERNATE = 2;
pub const MARSHAL_E_FIRST = @as(c_long, 2147746080);
pub const Uri_CREATE_NOFRAG = 8;
pub const KP_KEYLEN = 9;
pub const EMBDHLP_DELAYCREATE = @as(c_long, 65536);
pub const MOVEFILE_REPLACE_EXISTING = 1;
pub const PAN_XHEIGHT_INDEX = 9;
pub const WC_COMPOSITECHECK = 512;
pub const CERT_COMPARE_NAME_STR_W = 8;
pub const DEVICE_NOTIFY_ALL_INTERFACE_CLASSES = 4;
pub const ENOSTR = 125;
pub const ERROR_NO_MORE_ITEMS = @as(c_long, 259);
pub const ERROR_PRI_MERGE_MULTIPLE_MAIN_PACKAGES_NOT_ALLOWED = @as(c_long, 15154);
pub const DOMAIN_ALIAS_RID_SYSTEM_OPS = @as(c_long, 549);
pub const IGIMII_HELP = 16;
pub const SBS_SIZEBOXTOPLEFTALIGN = @as(c_long, 2);
pub const ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE = @as(c_long, 7058);
pub const ERROR_INSTALL_TRANSFORM_REJECTED = @as(c_long, 1644);
pub const PERSISTENT_VOLUME_STATE_BACKED_BY_WIM = 64;
pub const EMR_EXTFLOODFILL = 53;
pub const CF_RIFF = 11;
pub const CERT_CA_OCSP_AUTHORITY_INFO_ACCESS_PROP_ID = 81;
pub const WVR_ALIGNTOP = 16;
pub const CMSG_KEY_TRANS_CMS_VERSION = CMSG_ENVELOPED_RECIPIENT_V2;
pub const CERT_FIND_CERT_ID = CERT_COMPARE_CERT_ID << CERT_COMPARE_SHIFT;
pub const SIZEFULLSCREEN = SIZE_MAXIMIZED;
pub const IMAGE_DEBUG_TYPE_MISC = 4;
pub const DMBIN_AUTO = 7;
pub const DEVICE_NOTIFY_SERVICE_HANDLE = 1;
pub const SE_SIGNING_LEVEL_DEVELOPER = SE_SIGNING_LEVEL_CUSTOM_1;
pub const ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE = @as(c_long, 14018);
pub const WM_AFXLAST = 895;
pub const WN_BAD_LOCALNAME = ERROR_BAD_DEVICE;
pub const GPT_SPACES_ATTRIBUTE_NO_METADATA = 9223372036854775808;
pub const TRANSACTION_COMMIT = 8;
pub const POWERBUTTON_ACTION_VALUE_HIBERNATE = 3;
pub const szOID_DOMAIN_COMPONENT = "0.9.2342.19200300.100.1.25";
pub const sz_CERT_STORE_PROV_SMART_CARD_W = "SmartCard";
pub const __deref_out_bcount_nz = size;
pub const InterlockedExchangePointer = _InterlockedExchangePointer;
pub const CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID = 1;
pub const FS_FILE_COMPRESSION = FILE_FILE_COMPRESSION;
pub const ERROR_NO_TRUST_SAM_ACCOUNT = @as(c_long, 1787);
pub const __UINTMAX_FMTX__ = "llX";
pub const CFSTR_MIME_MPEG = if (@typeId(@typeOf("video/mpeg")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "video/mpeg") else if (@typeId(@typeOf("video/mpeg")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "video/mpeg") else TEXT("video/mpeg");
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_MATERIAL_FLAG = 2;
pub const STATUS_BREAKPOINT = if (@typeId(@typeOf(@as(c_long, 2147483651))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 2147483651)) else if (@typeId(@typeOf(@as(c_long, 2147483651))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 2147483651)) else DWORD(@as(c_long, 2147483651));
pub const ERROR_MUTANT_LIMIT_EXCEEDED = @as(c_long, 587);
pub const WM_MDIACTIVATE = 546;
pub const SID_SInternetSecurityManagerEx = IID_IInternetSecurityManagerEx;
pub const BCRYPT_ASYMMETRIC_ENCRYPTION_INTERFACE = 3;
pub const ERROR_STATE_QUERY_SETTING_FAILED = @as(c_long, 15810);
pub const META_ROUNDRECT = 1564;
pub const PSM_SETHEADERTITLE = PSM_SETHEADERTITLEA;
pub const _MAX_DRIVE = 3;
pub const FACILITY_RPC = 1;
pub const ERROR_RXACT_STATE_CREATED = @as(c_long, 701);
pub const WriteULongPtrRelease = WriteULong64Release;
pub const MIN_ACL_REVISION = ACL_REVISION2;
pub const ENABLE_SMART = 216;
pub const SO_CONNDATALEN = 28676;
pub const ERROR_DS_NAME_REFERENCE_INVALID = @as(c_long, 8373);
pub const CreateBoundaryDescriptor = CreateBoundaryDescriptorA;
pub const CLIP_TO_PATH = 4097;
pub const REG_BINARY = @as(c_ulong, 3);
pub const LANG_TIGRIGNA = 115;
pub const ERROR_CLUSTER_UPGRADE_RESTART_REQUIRED = @as(c_long, 5975);
pub const URLACTION_ACTIVEX_OVERRIDE_OPTIN = 4616;
pub const URLACTION_AUTOMATIC_ACTIVEX_UI = 8705;
pub const SETBREAK = 8;
pub const Uri_CREATE_FILE_USE_DOS_PATH = 32;
pub const ISC_SHOWUIGUIDELINE = 1073741824;
pub const SECTION_QUERY = 1;
pub const LANG_SCOTTISH_GAELIC = 145;
pub const PAN_ANY = 0;
pub const KP_MODE_BITS = 5;
pub const POINTER_FLAG_NONE = 0;
pub const MCI_ANIM_STEP_FRAMES = @as(c_long, 131072);
pub const SECURITY_TRUSTED_INSTALLER_RID1 = 956008885;
pub const IMAGE_REL_IA64_PCREL21B = 6;
pub const IO_REPARSE_TAG_CLOUD_1 = @as(c_long, 2415923226);
pub const ERROR_DS_USER_BUFFER_TO_SMALL = @as(c_long, 8309);
pub const VK_SEPARATOR = 108;
pub const HIDE_WINDOW = 0;
pub const SECURITY_WORLD_RID = @as(c_long, 0);
pub const IDH_CANCEL = 28444;
pub const SHGFI_OVERLAYINDEX = 64;
pub const EN_MAXTEXT = 1281;
pub const WN_DEVICE_ERROR = ERROR_GEN_FAILURE;
pub const NCRYPT_PAD_PSS_FLAG = 8;
pub const PROV_FORTEZZA = 4;
pub const XSTATE_MASK_LWP = if (@typeId(@typeOf(i64 << XSTATE_LWP)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << XSTATE_LWP) else if (@typeId(@typeOf(i64 << XSTATE_LWP)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << XSTATE_LWP) else @as(c_uint, 1)(i64 << XSTATE_LWP);
pub const PRINTER_NOTIFY_FIELD_STATUS_STRING = 19;
pub const TAPE_DRIVE_FIXED = 1;
pub const SEC_WINNT_AUTH_IDENTITY = SEC_WINNT_AUTH_IDENTITY_A;
pub const CS_DISABLE = @as(c_long, 2);
pub const WNNC_NET_SUN_PC_NFS = 458752;
pub const NUMPENS = 18;
pub const GET_SYSTEM_WOW64_DIRECTORY_NAME_T_T = GET_SYSTEM_WOW64_DIRECTORY_NAME_A_T;
pub const PROVIDER_KEEPS_VALUE_LENGTH = 1;
pub const SECURITY_RESTRICTED_CODE_RID = @as(c_long, 12);
pub const TAPE_DRIVE_SET_REPORT_SMKS = 2147485696;
pub const FLUSH_FLAGS_NO_SYNC = 2;
pub const __SIZEOF_PTRDIFF_T__ = 8;
pub const VK_F3 = 114;
pub const CERT_NOT_BEFORE_FILETIME_PROP_ID = 126;
pub const IMAGE_REL_SH3_PCREL8_WORD = 9;
pub const MCI_GETDEVCAPS_CAN_EJECT = @as(c_long, 7);
pub const SCARD_STATE_EMPTY = 16;
pub const IMAGE_REL_ALPHA_LITUSE = 5;
pub const ES_LEFT = @as(c_long, 0);
pub const ERROR_NO_MATCH = @as(c_long, 1169);
pub const NCRYPTBUFFER_SSL_CLIENT_RANDOM = 20;
pub const szOID_KP_SMARTCARD_LOGON = "1.3.6.1.4.1.311.20.2.2";
pub const CERT_PHYSICAL_STORE_INSERT_COMPUTER_NAME_ENABLE_FLAG = 8;
pub const IMAGE_REL_ALPHA_REFQ1 = 21;
pub const szOID_ENROLL_EK_CA_KEYID = "1.3.6.1.4.1.311.21.43";
pub const MDM_COMPRESSION = 1;
pub const JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS = 32767;
pub const ERROR_SERVER_SHUTDOWN_IN_PROGRESS = @as(c_long, 1255);
pub const LOCALE_SDATE = 29;
pub const SUBLANG_KHMER_CAMBODIA = 1;
pub const X509_ALTERNATE_NAME = if (@typeId(@typeOf(12)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 12) else if (@typeId(@typeOf(12)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 12) else LPCSTR(12);
pub const DMPAPER_P32KBIG_ROTATED = 108;
pub const ERROR_COULD_NOT_INTERPRET = @as(c_long, 552);
pub const DLGC_STATIC = 256;
pub const JOB_OBJECT_UILIMIT_HANDLES = 1;
pub const TA_NOUPDATECP = 0;
pub const CERT_STORE_CTRL_AUTO_RESYNC = 4;
pub const ERROR_DESTINATION_ELEMENT_FULL = @as(c_long, 1161);
pub const EMR_PIXELFORMAT = 104;
pub const WINCFGMGR32API = DECLSPEC_IMPORT;
pub const ERROR_DS_ALIASED_OBJ_MISSING = @as(c_long, 8334);
pub const ERROR_CLUSTER_WATCHDOG_TERMINATING = @as(c_long, 5952);
pub const _WIN32_IE_IE110 = 2560;
pub const URLACTION_HTML_ALLOW_CROSS_DOMAIN_TEXTTRACK = 5648;
pub const STGFMT_NATIVE = 1;
pub const ERROR_DEVICE_REINITIALIZATION_NEEDED = @as(c_long, 1164);
pub const RESOURCE_MANAGER_COMMUNICATION = 2;
pub const FindActCtxSectionString = FindActCtxSectionStringA;
pub const IME_CMODE_EUDC = 512;
pub const EVENT_OBJECT_PARENTCHANGE = 32783;
pub const PSBTN_APPLYNOW = 4;
pub const IME_CONFIG_REGISTERWORD = 2;
pub const HIBERFILE_TYPE_MAX = 3;
pub const BSF_FORCEIFHUNG = 32;
pub const ERROR_IPSEC_QM_POLICY_IN_USE = @as(c_long, 13002);
pub const CERT_CHAIN_POLICY_BASE = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 1) else LPCSTR(1);
pub const TOUCH_HIT_TESTING_PROXIMITY_CLOSEST = 0;
pub const ERROR_DS_INVALID_DMD = @as(c_long, 8360);
pub const WritePrivateProfileSection = WritePrivateProfileSectionA;
pub const MCI_ANIM_OPEN_PARENT = @as(c_long, 131072);
pub const LB_GETCOUNT = 395;
pub const REQUEST_OPLOCK_OUTPUT_FLAG_MODES_PROVIDED = 2;
pub const DMPAPER_FIRST = DMPAPER_LETTER;
pub const SC_MANAGER_ENUMERATE_SERVICE = 4;
pub const IN_CLASSB_MAX = 65536;
pub const TAPE_DRIVE_WRITE_MARK_IMMED = 2415919104;
pub const FOREGROUND_RED = 4;
pub const EACCES = 13;
pub const WM_CUT = 768;
pub const ERROR_DS_RIDMGR_INIT_ERROR = @as(c_long, 8211);
pub const IOC_OUT = 1073741824;
pub const _WIN32_IE_NT4SP6 = _WIN32_IE_IE50;
pub const MEM_RELEASE = 32768;
pub const DrawTextEx = DrawTextExA;
pub const PRODUCT_IOTUAP = 123;
pub const SCM_REGION_SPA_UNKNOWN = MAXDWORD64;
pub const EVENT_E_FIRST = @as(c_long, 2147746304);
pub const DNS_ERROR_ZONE_IS_SHUTDOWN = @as(c_long, 9621);
pub const ERROR_LOG_STATE_INVALID = @as(c_long, 6643);
pub const NUMPRS_PARENS = 128;
pub const CERT_PVK_FILE_PROP_ID = 12;
pub const ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST = @as(c_long, 8535);
pub const DNS_ERROR_ZONE_BASE = 9600;
pub const RIGHTMOST_BUTTON_PRESSED = 2;
pub const GetAltTabInfo = GetAltTabInfoA;
pub const CMC_FAIL_BAD_IDENTITY = 7;
pub const INIT_ONCE_INIT_FAILED = RTL_RUN_ONCE_INIT_FAILED;
pub const CERT_CHAIN_MAX_AIA_URL_RETRIEVAL_BYTE_COUNT_DEFAULT = 100000;
pub const szOID_OIW = "1.3.14";
pub const MIM_ERROR = MM_MIM_ERROR;
pub const ENCLAVE_LONG_ID_LENGTH = 32;
pub const CTMF_INCLUDE_APPCONTAINER = @as(c_ulong, 1);
pub const CRYPT_LDAP_SIGN_RETRIEVAL = 65536;
pub const SIZE_MAXIMIZED = 2;
pub const ChooseFont = ChooseFontA;
pub const FILE_ZERO_DATA_INFORMATION_FLAG_PRESERVE_CACHED_DATA = 1;
pub const NUMPRS_DECIMAL = 256;
pub const ERROR_NO_SPOOL_SPACE = @as(c_long, 62);
pub const IMAGE_REL_AMD64_IMPORT_CALL = 19;
pub const ERROR_MEMBER_NOT_IN_GROUP = @as(c_long, 1321);
pub const PF_BAN = AF_BAN;
pub const QUERY_FILE_LAYOUT_INCLUDE_STREAMS = 4;
pub const HEAP_CREATE_HARDENED = 512;
pub const IMAGE_SYM_TYPE_UINT = 14;
pub const ES_CENTER = @as(c_long, 1);
pub const MB_SERVICE_NOTIFICATION_NT3X = @as(c_long, 262144);
pub const BCRYPT_KEY_DATA_BLOB_VERSION1 = 1;
pub const BCRYPT_ECDSA_P384_ALG_HANDLE = if (@typeId(@typeOf(753)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 753) else if (@typeId(@typeOf(753)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 753) else BCRYPT_ALG_HANDLE(753);
pub const ERROR_CONNECTION_UNAVAIL = @as(c_long, 1201);
pub const ERROR_CLUSTER_PARAMETER_MISMATCH = @as(c_long, 5897);
pub const SECURITY_AUTHENTICATION_KEY_PROPERTY_ATTESTATION_RID = @as(c_long, 6);
pub const SE_ERR_SHARE = 26;
pub const szOID_RSA_challengePwd = "1.2.840.113549.1.9.7";
pub const ERROR_PAGED_SYSTEM_RESOURCES = @as(c_long, 1452);
pub const BCRYPT_PUBLIC_KEY_FLAG = 1;
pub const SECURITY_TRUSTED_INSTALLER_RID2 = 3418522649;
pub const DMPAPER_LEDGER = 4;
pub const IMAGE_REL_IA64_PCREL21M = 7;
pub const IO_REPARSE_TAG_CLOUD_2 = @as(c_long, 2415927322);
pub const RPC_S_CALL_FAILED_DNE = @as(c_long, 1727);
pub const SDC_USE_SUPPLIED_DISPLAY_CONFIG = 32;
pub const RI_KEY_MAKE = 0;
pub const MMIO_GETTEMP = 131072;
pub const SUBLANG_BANGLA_INDIA = 1;
pub const DNS_ERROR_INVALID_KEY_SIZE = @as(c_long, 9106);
pub const EXCEPTION_MAXIMUM_PARAMETERS = 15;
pub const PROCESS_CREATION_MITIGATION_POLICY2_RESTRICT_INDIRECT_BRANCH_PREDICTION_ALWAYS_ON = if (@typeId(@typeOf(i64 << 16)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << 16) else if (@typeId(@typeOf(i64 << 16)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << 16) else @as(c_uint, 1)(i64 << 16);
pub const szOID_NIST_AES192_CBC = "2.16.840.1.101.3.4.1.22";
pub const VTBIT_I2 = 1 << VT_I2;
pub const ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL = @as(c_long, 13898);
pub const SBM_GETPOS = 225;
pub const FR_RAW = 131072;
pub const TPM_CENTERALIGN = @as(c_long, 4);
pub const LC_STYLED = 32;
pub const MS_CTS_ON = if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 16) else if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 16) else DWORD(16);
pub const EMR_MIN = 1;
pub const ERROR_MRM_RUNTIME_NO_DEFAULT_OR_NEUTRAL_RESOURCE = @as(c_long, 15110);
pub const SE_DACL_AUTO_INHERITED = 1024;
pub const PFD_TYPE_COLORINDEX = 1;
pub const IMAGE_REL_PPC_REL14 = 7;
pub const SE_DACL_DEFAULTED = 8;
pub const EnumPrinterDrivers = EnumPrinterDriversA;
pub const PostMessage = PostMessageA;
pub const ERROR_PLATFORM_MANIFEST_NOT_AUTHORIZED = @as(c_long, 4570);
pub const WM_SYSCHAR = 262;
pub const DBG_CONTROL_C = if (@typeId(@typeOf(@as(c_long, 1073807365))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 1073807365)) else if (@typeId(@typeOf(@as(c_long, 1073807365))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 1073807365)) else DWORD(@as(c_long, 1073807365));
pub const ABE_RIGHT = 2;
pub const TRANSACTION_ROLLBACK = 16;
pub const CF_ENHMETAFILE = 14;
pub const CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD = 2;
pub const ERROR_SXS_KEY_NOT_FOUND = @as(c_long, 14007);
pub const WM_POINTERCAPTURECHANGED = 588;
pub const NCBDELNAME = 49;
pub const HEAP_REALLOC_IN_PLACE_ONLY = 16;
pub const GET_SYSTEM_WOW64_DIRECTORY_NAME_T_W = GET_SYSTEM_WOW64_DIRECTORY_NAME_A_W;
pub const GetTextExtentPoint = GetTextExtentPointA;
pub const CFSTR_MIME_DDS = if (@typeId(@typeOf("image/vnd.ms-dds")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "image/vnd.ms-dds") else if (@typeId(@typeOf("image/vnd.ms-dds")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "image/vnd.ms-dds") else TEXT("image/vnd.ms-dds");
pub const DISPATCH_PROPERTYPUT = 4;
pub const ALG_TYPE_STREAM = 4 << 9;
pub const MDM_V110_SPEED_28DOT8K = 8;
pub const VK_F2 = 113;
pub const SWP_NOREPOSITION = SWP_NOOWNERZORDER;
pub const LANG_ESTONIAN = 37;
pub const REG_MUI_STRING_TRUNCATE = 1;
pub const APD_STRICT_UPGRADE = 1;
pub const THREAD_RESUME = 4096;
pub const ERROR_BUSY_DRIVE = @as(c_long, 142);
pub const RDW_FRAME = 1024;
pub const ODT_COMBOBOX = 3;
pub const CERT_KEY_SPEC_PROP_ID = 6;
pub const FACILITY_USERMODE_HYPERVISOR = 53;
pub const COLOR_SCROLLBAR = 0;
pub const IMAGE_SEPARATE_DEBUG_FLAGS_MASK = 32768;
pub const __UINT_FAST64_FMTx__ = "llx";
pub const ICON_SMALL2 = 2;
pub const ERROR_VRF_CFG_ENABLED = @as(c_long, 1183);
pub const ACCESS_ALLOWED_CALLBACK_ACE_TYPE = 9;
pub const ERROR_CTX_WINSTATION_NOT_FOUND = @as(c_long, 7022);
pub const SHTDN_REASON_MINOR_PROCESSOR = 8;
pub const TAPE_QUERY_IO_ERROR_DATA = @as(c_long, 3);
pub const ERROR_BAD_ENVIRONMENT = @as(c_long, 10);
pub const IPPORT_NAMESERVER = 42;
pub const ERROR_STATE_ENUMERATE_CONTAINER_FAILED = @as(c_long, 15813);
pub const ERROR_BAD_PATHNAME = @as(c_long, 161);
pub const DISP_CHANGE_NOTUPDATED = -3;
pub const IMAGE_REL_M32R_PCREL24 = 5;
pub const EMFILE = 24;
pub const szOID_RSA_SHA1RSA = "1.2.840.113549.1.1.5";
pub const RotateLeft8 = _rotl8;
pub const PSD_DISABLEPRINTER = 32;
pub const ERROR_DS_EPOCH_MISMATCH = @as(c_long, 8483);
pub const TPM_VERTICAL = @as(c_long, 64);
pub const szOID_ECC_CURVE_BRAINPOOLP224T1 = "1.3.36.3.3.2.8.1.1.6";
pub const CFSTR_MIME_X_PNG = if (@typeId(@typeOf("image/x-png")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "image/x-png") else if (@typeId(@typeOf("image/x-png")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "image/x-png") else TEXT("image/x-png");
pub const ERROR_NO_WRITABLE_DC_FOUND = @as(c_long, 8621);
pub const MCI_VD_STATUS_DISC_SIZE = @as(c_long, 16390);
pub const REG_OPTION_CREATE_LINK = @as(c_long, 2);
pub const LBN_SELCANCEL = 3;
pub const SMART_INVALID_COMMAND = 3;
pub const CERT_TRUST_IS_NOT_SIGNATURE_VALID = 8;
pub const SET_REPAIR_WARN_ABOUT_DATA_LOSS = 8;
pub const ERROR_SXS_XML_E_INVALID_HEXIDECIMAL = @as(c_long, 14048);
pub const FOF_MULTIDESTFILES = 1;
pub const DeviceDsmActionFlag_NonDestructive = 2147483648;
pub const OR_INVALID_OXID = @as(c_long, 1910);
pub const PS_JOIN_MASK = 61440;
pub const RpcNsBindingImportBegin = RpcNsBindingImportBeginA;
pub const rad8 = 1063;
pub const __has_lock_property = kind;
pub const DMPAPER_10X14 = 16;
pub const STRETCHBLT = 2048;
pub const IMFT_RADIOCHECK = 1;
pub const DATABITS_6 = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(WORD, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(WORD, 2) else WORD(2);
pub const SEM_NOALIGNMENTFAULTEXCEPT = 4;
pub const SCARD_READER_CONFISCATES = 4;
pub const OInetParseUrl = CoInternetParseUrl;
pub const MMIO_CREATE = 4096;
pub const WN_CONNECTION_CLOSED = ERROR_CONNECTION_UNAVAIL;
pub const DM_IN_PROMPT = DM_PROMPT;
pub const BCRYPT_AES_GCM_ALG_HANDLE = if (@typeId(@typeOf(481)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 481) else if (@typeId(@typeOf(481)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 481) else BCRYPT_ALG_HANDLE(481);
pub const GMDI_USEDISABLED = @as(c_long, 1);
pub const szOID_PKIX_KP_IPSEC_USER = "1.3.6.1.5.5.7.3.7";
pub const FACILITY_TPM_SOFTWARE = 41;
pub const ERROR_TOO_MANY_OPEN_FILES = @as(c_long, 4);
pub const CMSG_OID_CAPI1_EXPORT_KEY_TRANS_FUNC = CMSG_OID_EXPORT_KEY_TRANS_FUNC;
pub const IME_CAND_MEANING = 3;
pub const BCRYPT_RSAFULLPRIVATE_MAGIC = 859919186;
pub const DOF_SHELLDATA = 2;
pub const FAST_FAIL_LOADER_CONTINUITY_FAILURE = 45;
pub const BS_OWNERDRAW = @as(c_long, 11);
pub const IMAGE_DEBUG_TYPE_FIXUP = 6;
pub const FR_MATCHALEFHAMZA = 2147483648;
pub const CERT_UNICODE_ATTR_ERR_INDEX_SHIFT = 16;
pub const IMAGE_SCN_MEM_FARDATA = 32768;
pub const GetEnhMetaFile = GetEnhMetaFileA;
pub const CERT_ISOLATED_KEY_PROP_ID = 118;
pub const IMAGE_DLLCHARACTERISTICS_APPCONTAINER = 4096;
pub const WAVE_MAPPED = 4;
pub const WSATRY_AGAIN = @as(c_long, 11002);
pub const PRINTER_STATUS_PAGE_PUNT = 524288;
pub const POWER_ACTION_ACPI_USER_NOTIFY = 33554432;
pub const FILE_DEVICE_WAVE_IN = 37;
pub const _Valid_ = _Valid_impl_;
pub const LOGPIXELSX = 88;
pub const TAPE_ABSOLUTE_POSITION = @as(c_long, 0);
pub const FILE_PREFETCH_TYPE_FOR_DIRENUM_EX = 4;
pub const szOID_OIWSEC_md4RSA2 = "1.3.14.3.2.4";
pub const SECURITY_TRUSTED_INSTALLER_RID3 = 1831038044;
pub const MOM_OPEN = MM_MOM_OPEN;
pub const LOCKFILE_FAIL_IMMEDIATELY = 1;
pub const IO_REPARSE_TAG_CLOUD_3 = @as(c_long, 2415931418);
pub const PP_USER_CERTSTORE = 42;
pub const szOID_ENROLL_EKVERIFYCERT = "1.3.6.1.4.1.311.21.31";
pub const LOCALE_SDURATION = 93;
pub const ERROR_DS_INVALID_SEARCH_FLAG = @as(c_long, 8500);
pub const DOMAIN_GROUP_RID_ENTERPRISE_ADMINS = @as(c_long, 519);
pub const SS_BLACKRECT = @as(c_long, 4);
pub const APPCOMMAND_MEDIA_PAUSE = 47;
pub const SERIAL_LSRMST_MST = if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Pointer) @ptrCast(BYTE, 3) else if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Int) @intToPtr(BYTE, 3) else BYTE(3);
pub const IMAGE_GUARD_RF_STRICT = 524288;
pub const uuid_vector_t = UUID_VECTOR;
pub const CRYPT_OID_INFO_PUBKEY_ENCRYPT_KEY_FLAG = 1073741824;
pub const DC_PAPERS = 2;
pub const DESKTOP_CREATEMENU = @as(c_long, 4);
pub const RESOURCEUSAGE_CONTAINER = 2;
pub const IMAGE_RESOURCE_DATA_IS_DIRECTORY = 2147483648;
pub const MIXER_GETLINEINFOF_LINEID = @as(c_long, 2);
pub const KLF_SHIFTLOCK = 65536;
pub const CS_NOMOVECARET = 16384;
pub const DOMAIN_GROUP_RID_SCHEMA_ADMINS = @as(c_long, 518);
pub const ERROR_IP_ADDRESS_CONFLICT2 = @as(c_long, 612);
pub const szOID_KP_LIFETIME_SIGNING = "1.3.6.1.4.1.311.10.3.13";
pub const PID_CODEPAGE = 1;
pub const PBT_APMQUERYSUSPENDFAILED = 2;
pub const IMC_OPENSTATUSWINDOW = 34;
pub const __UINT64_FMTo__ = "llo";
pub const AD_CLOCKWISE = 2;
pub const SKF_RCTLLATCHED = 134217728;
pub const TOUCH_MASK_PRESSURE = 4;
pub const SDC_NO_OPTIMIZATION = 256;
pub const SCM_PD_MAX_OPERATIONAL_STATUS = 16;
pub const IO_REPARSE_TAG_PROJFS = @as(c_long, 2415919132);
pub const FILE_INITIATE_REPAIR_HINT1_ATTRIBUTE_NON_RESIDENT = 137438953472;
pub const szOID_ENROLLMENT_AGENT = "1.3.6.1.4.1.311.20.2.1";
pub const PROV_MS_EXCHANGE = 5;
pub const STATUS_WAIT_0 = if (@typeId(@typeOf(@as(c_long, 0))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 0)) else if (@typeId(@typeOf(@as(c_long, 0))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 0)) else DWORD(@as(c_long, 0));
pub const RIGHT_CTRL_PRESSED = 4;
pub const DIB_PAL_COLORS = 1;
pub const ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR = @as(c_long, 8595);
pub const PRINTER_STATUS_WARMING_UP = 65536;
pub const INPUT_MOUSE = 0;
pub const VK_F1 = 112;
pub const SUBLANG_SERBIAN_LATIN = 2;
pub const USN_REASON_HARD_LINK_CHANGE = 65536;
pub const STATE_SYSTEM_FLOATING = 4096;
pub const PRODUCT_STORAGE_EXPRESS_SERVER = 20;
pub const FACILITY_DPLAY = 21;
pub const DNS_ERROR_ZONESCOPE_IS_REFERENCED = @as(c_long, 9989);
pub const CPS_REVERT = 3;
pub const ERROR_CLUSTER_SPACE_DEGRADED = @as(c_long, 5987);
pub const RPC_S_UNKNOWN_AUTHN_LEVEL = @as(c_long, 1748);
pub const SECURITY_CAPABILITY_REMOVABLE_STORAGE = @as(c_long, 10);
pub const CLAIM_SECURITY_ATTRIBUTE_CUSTOM_FLAGS = 4294901760;
pub const szOID_AUTHORITY_INFO_ACCESS = "1.3.6.1.5.5.7.1.1";
pub const PAN_MIDLINE_STANDARD_SERIFED = 4;
pub const HISTORY_NO_DUP_FLAG = 1;
pub const FACILITY_DEBUGGERS = 176;
pub const WNNC_NET_VMWARE = 4128768;
pub const LANG_KYRGYZ = 64;
pub const COLOR_INACTIVECAPTION = 3;
pub const __UINT_FAST64_FMTX__ = "llX";
pub const FAST_FAIL_UNSAFE_REGISTRY_ACCESS = 9;
pub const DM_PANNINGWIDTH = @as(c_long, 134217728);
pub const ACCESS_DS_SOURCE_A = "DS";
pub const LR_COPYDELETEORG = 8;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_INCOMPATIBLE_NODES = @as(c_long, 5953);
pub const InterlockedDecrement64 = _InterlockedDecrement64;
pub const SEC_E_NO_SPM = SEC_E_INTERNAL_ERROR;
pub const WM_MENUGETOBJECT = 292;
pub const ACTCTX_FLAG_ASSEMBLY_DIRECTORY_VALID = 4;
pub const COLOR_BTNHIGHLIGHT = 20;
pub const CPS_COMPLETE = 1;
pub const S_PERIODVOICE = 3;
pub const SCM_PD_MEMORY_SIZE_UNKNOWN = MAXDWORD64;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_EXPO_SMOOTH_ALPHA = 0.990000;
pub const ERROR_NETLOGON_NOT_STARTED = @as(c_long, 1792);
pub const ERROR_EVT_FILTER_TOO_COMPLEX = @as(c_long, 15026);
pub const PAN_SERIFSTYLE_INDEX = 1;
pub const HEAP_NO_SERIALIZE = 1;
pub const GCPCLASS_LATIN = 1;
pub const WNNC_NET_VINES = 262144;
pub const NCRYPT_SP800108_CTR_HMAC_ALGORITHM = BCRYPT_SP800108_CTR_HMAC_ALGORITHM;
pub const ERROR_HIBERNATED = @as(c_long, 726);
pub const ERROR_FILE_INVALID = @as(c_long, 1006);
pub const META_DIBSTRETCHBLT = 2881;
pub const rad9 = 1064;
pub const _WIN32_IE_NT4SP4 = _WIN32_IE_IE401;
pub const SPI_SETMOUSEHOVERHEIGHT = 101;
pub const QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_HOST_VOLUMES = 1;
pub const PSN_QUERYCANCEL = if (@typeId(@typeOf(-9)) == @import("builtin").TypeId.Pointer) @ptrCast(PSN_FIRST, -9) else if (@typeId(@typeOf(-9)) == @import("builtin").TypeId.Int) @intToPtr(PSN_FIRST, -9) else PSN_FIRST(-9);
pub const ERROR_REG_NAT_CONSUMPTION = @as(c_long, 1261);
pub const szOID_PKIX_TIME_STAMPING = "1.3.6.1.5.5.7.48.3";
pub const MOD_SYNTH = 2;
pub const ERROR_APPCONTAINER_REQUIRED = @as(c_long, 4251);
pub const SERVICE_CONTROL_SHUTDOWN = 5;
pub const HBMMENU_MBAR_CLOSE_D = if (@typeId(@typeOf(6)) == @import("builtin").TypeId.Pointer) @ptrCast(HBITMAP, 6) else if (@typeId(@typeOf(6)) == @import("builtin").TypeId.Int) @intToPtr(HBITMAP, 6) else HBITMAP(6);
pub const MDMSPKR_OFF = 0;
pub const DACL_SECURITY_INFORMATION = @as(c_long, 4);
pub const TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CRL = if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 5) else if (@typeId(@typeOf(5)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 5) else LPCSTR(5);
pub const SE_SIGNING_LEVEL_AUTHENTICODE = 4;
pub const DATABITS_7 = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(WORD, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(WORD, 4) else WORD(4);
pub const PROCESS_CREATION_MITIGATION_POLICY_BLOCK_NON_MICROSOFT_BINARIES_DEFER = if (@typeId(@typeOf(i64 << 44)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), i64 << 44) else if (@typeId(@typeOf(i64 << 44)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), i64 << 44) else @as(c_uint, 0)(i64 << 44);
pub const PROCESSOR_ALPHA_21064 = 21064;
pub const MEVT_NOP = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(BYTE, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(BYTE, 2) else BYTE(2);
pub const InterlockedAddAcquire64 = _InlineInterlockedAdd64;
pub const BCRYPT_ECDSA_ALG_HANDLE = if (@typeId(@typeOf(241)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 241) else if (@typeId(@typeOf(241)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 241) else BCRYPT_ALG_HANDLE(241);
pub const PROP_MED_CXDLG = 227;
pub const IMAGE_REL_IA64_IMM14 = 1;
pub const ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE = @as(c_long, 5033);
pub const ERROR_INSTALL_PREREQUISITE_FAILED = @as(c_long, 15613);
pub const ERROR_INSTALL_REGISTRATION_FAILURE = @as(c_long, 15606);
pub const RPC_S_ACCESS_DENIED = ERROR_ACCESS_DENIED;
pub const SOFTDIST_ADSTATE_INSTALLED = 3;
pub const ERROR_DS_NONEXISTENT_MAY_HAVE = @as(c_long, 8387);
pub const CERT_DISALLOWED_FILETIME_PROP_ID = 104;
pub const ERROR_STATE_WRITE_COMPOSITE_SETTING_FAILED = @as(c_long, 15812);
pub const WNetGetResourceParent = WNetGetResourceParentA;
pub const ERROR_NOTIFY_CLEANUP = @as(c_long, 745);
pub const SOUND_SYSTEM_MINIMIZE = 9;
pub const IMN_OPENSTATUSWINDOW = 2;
pub const DMPAPER_A5_ROTATED = 78;
pub const ERROR_CLUSTER_QUORUMLOG_NOT_FOUND = @as(c_long, 5891);
pub const GetTempFileName = GetTempFileNameA;
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_LATENCY = 8;
pub const WINCOMMDLGAPI = DECLSPEC_IMPORT;
pub const CRITICAL_SECTION_NO_DEBUG_INFO = RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO;
pub const BAUD_1200 = if (@typeId(@typeOf(64)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 64) else if (@typeId(@typeOf(64)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 64) else DWORD(64);
pub const CERT_CHAIN_REVOCATION_CHECK_OCSP_CERT = 67108864;
pub const LOGPIXELSY = 90;
pub const ERROR_DS_ATT_SCHEMA_REQ_SYNTAX = @as(c_long, 8416);
pub const SECURITY_TRUSTED_INSTALLER_RID4 = 1853292631;
pub const MAX_COMPUTERNAME_LENGTH = 15;
pub const WINDING = 2;
pub const WMSZ_TOPRIGHT = 5;
pub const CERT_FIND_VALID_ENHKEY_USAGE_FLAG = 32;
pub const PRINTER_NOTIFY_FIELD_DATATYPE = 11;
pub const PST_NETWORK_BRIDGE = if (@typeId(@typeOf(256)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 256) else if (@typeId(@typeOf(256)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 256) else DWORD(256);
pub const POWERBUTTON_ACTION_VALUE_TURN_OFF_THE_DISPLAY = 8;
pub const CMSG_CTRL_VERIFY_HASH = 5;
pub const szOID_INFOSEC_SuiteATokenProtection = "2.16.840.1.101.2.1.1.16";
pub const SC_SCREENSAVE = 61760;
pub const LOCALE_ITLZERO = 37;
pub const IMAGE_REL_ALPHA_INLINE_REFLONG = 9;
pub const ERROR_CANNOT_ACCEPT_TRANSACTED_WORK = @as(c_long, 6847);
pub const szOID_CERT_POLICIES_95 = "2.5.29.3";
pub const IMAGE_REL_BASED_RESERVED = 6;
pub const SPI_GETCARETBROWSING = 4172;
pub const PEERDIST_ERROR_ALREADY_COMPLETED = @as(c_long, 4060);
pub const ERROR_IP_ADDRESS_CONFLICT1 = @as(c_long, 611);
pub const PSD_NONETWORKBUTTON = 2097152;
pub const PARTITION_LDM = 66;
pub const JOY_POVBACKWARD = 18000;
pub const SYSPAL_ERROR = 0;
pub const ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING = @as(c_long, 13900);
pub const ILLUMINANT_D50 = 4;
pub const LOCALE_SNATIVEDIGITS = 19;
pub const OLE_E_LAST = if (@typeId(@typeOf(@as(c_long, 2147746047))) == @import("builtin").TypeId.Pointer) @ptrCast(HRESULT, @as(c_long, 2147746047)) else if (@typeId(@typeOf(@as(c_long, 2147746047))) == @import("builtin").TypeId.Int) @intToPtr(HRESULT, @as(c_long, 2147746047)) else HRESULT(@as(c_long, 2147746047));
pub const ERROR_DS_NO_ATTRIBUTE_OR_VALUE = @as(c_long, 8202);
pub const MCI_TO = @as(c_long, 8);
pub const LOGON32_PROVIDER_WINNT50 = 3;
pub const SetDllDirectory = SetDllDirectoryA;
pub const ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY = @as(c_long, 786);
pub const CM_OUT_OF_GAMUT = 255;
pub const ERROR_DEPENDENT_SERVICES_RUNNING = @as(c_long, 1051);
pub const BS_HOLLOW = BS_NULL;
pub const CB_ERR = -1;
pub const BAUD_075 = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 1) else DWORD(1);
pub const ERROR_EMPTY = @as(c_long, 4306);
pub const OFN_ENABLEHOOK = 32;
pub const PPM_FIRMWARE_CPC = 262144;
pub const NI_FINALIZECONVERSIONRESULT = 20;
pub const SUBLANG_MAORI_NEW_ZEALAND = 1;
pub const TARGET_IS_NT100_OR_LATER = 1;
pub const JOB_NOTIFY_FIELD_TOTAL_BYTES = 22;
pub const ERROR_DS_MISSING_EXPECTED_ATT = @as(c_long, 8411);
pub const SPI_SETACTIVEWINDOWTRACKING = 4097;
pub const InsertMenu = InsertMenuA;
pub const VP_TV_STANDARD_PAL_I = 32;
pub const DMBIN_ENVELOPE = 5;
pub const GETTRACKKERNTABLE = 259;
pub const CERT_CREATE_SELFSIGN_NO_SIGN = 1;
pub const ACE_OBJECT_TYPE_PRESENT = 1;
pub const ERROR_LOG_METADATA_FLUSH_FAILED = @as(c_long, 6645);
pub const __UA_WCSLEN = ua_wcslen;
pub const NTM_ITALIC = @as(c_long, 1);
pub const CFS_EXCLUDE = 128;
pub const ERROR_CLUSTER_NODE_UNREACHABLE = @as(c_long, 5051);
pub const WSAECONNRESET = @as(c_long, 10054);
pub const CMSG_CTRL_DEL_SIGNER = 7;
pub const FRS_ERR_SERVICE_COMM = @as(c_long, 8006);
pub const ReadULongPtrNoFence = ReadULong64NoFence;
pub const CERT_STORE_NO_CRL_FLAG = 65536;
pub const CCHILDREN_TITLEBAR = 5;
pub const RPC_S_INVALID_NAME_SYNTAX = @as(c_long, 1736);
pub const JOB_CONTROL_PAUSE = 1;
pub const GPT_BASIC_DATA_ATTRIBUTE_SHADOW_COPY = 2305843009213693952;
pub const CERT_CTL_USAGE_PROP_ID = CERT_ENHKEY_USAGE_PROP_ID;
pub const RPC_S_OBJECT_NOT_FOUND = @as(c_long, 1710);
pub const TIME_VALID_OID_FLUSH_OBJECT_FUNC = "TimeValidDllFlushObject";
pub const IMAGE_REL_ALPHA_SECTION = 14;
pub const FVIRTKEY = TRUE;
pub const JOB_OBJECT_UILIMIT_DESKTOP = 64;
pub const SPI_LANGDRIVER = 12;
pub const EMR_RESERVED_110 = 110;
pub const BN_CLICKED = 0;
pub const PRODUCT_SB_SOLUTION_SERVER = 50;
pub const RPC_FLAGS_VALID_BIT = 32768;
pub const MIXER_OBJECTF_WAVEOUT = @as(c_long, 268435456);
pub const SUBLANG_ROMANSH_SWITZERLAND = 1;
pub const SERVICE_CONTROL_PRESHUTDOWN = 15;
pub const NCRYPTBUFFER_SSL_SERVER_RANDOM = 21;
pub const STKFORCEINLINE = FORCEINLINE;
pub const FLASHW_STOP = 0;
pub const RIM_TYPEHID = 2;
pub const PSINJECT_VMSAVE = 200;
pub const ERROR_DS_CANT_CACHE_ATT = @as(c_long, 8401);
pub const SUBLANG_GREEK_GREECE = 1;
pub const grp4 = 1075;
pub const IMAGE_SUBSYSTEM_POSIX_CUI = 7;
pub const ERROR_UNEXPECTED_OMID = @as(c_long, 4334);
pub const ERROR_SYSTEM_HIVE_TOO_LARGE = @as(c_long, 653);
pub const MAXPNAMELEN = 32;
pub const _WIN32_IE_NT4SP5 = _WIN32_IE_IE401;
pub const PROCESS_MODE_BACKGROUND_BEGIN = 1048576;
pub const IMAGE_REL_PPC_TOCREL16 = 8;
pub const SHIL_LAST = SHIL_JUMBO;
pub const WSAENETRESET = @as(c_long, 10052);
pub const VTBIT_DECIMAL = 1 << VT_DECIMAL;
pub const CERT_KEY_PROV_INFO_PROP_ID = 2;
pub const SERVICE_STOP_REASON_MAJOR_MAX_CUSTOM = 16711680;
pub const MHDR_PREPARED = 2;
pub const ABM_SETAUTOHIDEBAREX = 12;
pub const SHUTDOWN_INSTALL_UPDATES = 64;
pub const SERVICE_START_PENDING = 2;
pub const RPC_BUFFER_ASYNC = 32768;
pub const AddPrinterDriver = AddPrinterDriverA;
pub const WS_MINIMIZE = @as(c_long, 536870912);
pub const REG_NOTIFY_CHANGE_NAME = @as(c_long, 1);
pub const MDM_FORCED_EC = 4;
pub const InterlockedIncrementNoFence = _InterlockedIncrement;
pub const ERROR_IPSEC_IKE_INVALID_HASH_ALG = @as(c_long, 13871);
pub const ERROR_RESOURCEMANAGER_NOT_FOUND = @as(c_long, 6716);
pub const ERROR_RDP_PROTOCOL_ERROR = @as(c_long, 7065);
pub const LBS_SORT = @as(c_long, 2);
pub const CERT_STORE_BACKUP_RESTORE_FLAG = 2048;
pub const MUI_CALLBACK_ALL_FLAGS = MUI_CALLBACK_FLAG_UPGRADED_INSTALLATION;
pub const ERROR_EXCL_SEM_ALREADY_OWNED = @as(c_long, 101);
pub const WNNC_NET_SRT = 3604480;
pub const RPC_C_SECURITY_QOS_VERSION_1 = @as(c_long, 1);
pub const URLACTION_AUTHENTICATE_CLIENT = 6657;
pub const ERROR_INVALID_PROFILE = @as(c_long, 2011);
pub const ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN = @as(c_long, 8603);
pub const ERROR_SECONDARY_IC_PROVIDER_NOT_REGISTERED = @as(c_long, 15321);
pub const WSA_QOS_EUNKOWNPSOBJ = @as(c_long, 11024);
pub const WM_ACTIVATE = 6;
pub const WM_STYLECHANGED = 125;
pub const ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL = @as(c_long, 15022);
pub const szOID_INFOSEC_mosaicConfidentiality = "2.16.840.1.101.2.1.1.4";
pub const ERROR_CTX_WINSTATION_NAME_INVALID = @as(c_long, 7001);
pub const STN_CLICKED = 0;
pub const ERROR_GPIO_INVALID_REGISTRATION_PACKET = @as(c_long, 15324);
pub const TIME_NOTIMEMARKER = 4;
pub const RGN_XOR = 3;
pub const SEE_MASK_INVOKEIDLIST = 12;
pub const ERROR_PKINIT_FAILURE = @as(c_long, 1263);
pub const ACPI_PPM_SOFTWARE_ALL = 252;
pub const SO_CONNECT_TIME = 28684;
pub const SECURITY_TRUSTED_INSTALLER_RID5 = 2271478464;
pub const PASSEMBLY_DLL_REDIRECTION_DETAILED_INFORMATION = PASSEMBLY_FILE_DETAILED_INFORMATION;
pub const ERROR_REMOTE_STORAGE_NOT_ACTIVE = @as(c_long, 4351);
pub const CMSG_ENCODED_SIGNER = 28;
pub const TOKEN_SOURCE_LENGTH = 8;
pub const UNIVERSAL_NAME_INFO_LEVEL = 1;
pub const PROC_IDLE_BUCKET_COUNT = 6;
pub const SECURITY_TERMINAL_SERVER_RID = @as(c_long, 13);
pub const WOW64_CONTEXT_i486 = 65536;
pub const SECURITY_ENTERPRISE_CONTROLLERS_RID = @as(c_long, 9);
pub const PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_NO_LOW_LABEL_RESERVED = if (@typeId(@typeOf(i64 << 56)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 56) else if (@typeId(@typeOf(i64 << 56)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 56) else @as(c_uint, 3)(i64 << 56);
pub const ERROR_STATIC_INIT = @as(c_long, 4002);
pub const SetLocaleInfo = SetLocaleInfoA;
pub const SERVICE_CONTROL_SESSIONCHANGE = 14;
pub const __DBL_MAX_EXP__ = 1024;
pub const DMDISPLAYFLAGS_TEXTMODE = 4;
pub const TRANSPORT_TYPE_LPC = 4;
pub const FACILITY_MBN = 84;
pub const VTBIT_I1 = 1 << VT_I1;
pub const STORAGE_INFO_FLAGS_ALIGNED_DEVICE = 1;
pub const CERT_NOT_BEFORE_ENHKEY_USAGE_PROP_ID = 127;
pub const ERROR_INTERRUPT_STILL_CONNECTED = @as(c_long, 764);
pub const PCF_16BITMODE = if (@typeId(@typeOf(512)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 512) else if (@typeId(@typeOf(512)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 512) else DWORD(512);
pub const PT_CLOSEFIGURE = 1;
pub const PEERDIST_ERROR_SHUTDOWN_IN_PROGRESS = @as(c_long, 4056);
pub const SPVERSION_MASK = 65280;
pub const PROCESS_DEP_DISABLE_ATL_THUNK_EMULATION = 2;
pub const S_SERDTP = -8;
pub const ERROR_DS_NONSAFE_SCHEMA_CHANGE = @as(c_long, 8508);
pub const FAST_FAIL_STACK_COOKIE_CHECK_FAILURE = 2;
pub const USER_CALL_NEW_CORRELATION_DESC = 512;
pub const ERROR_WAIT_NO_CHILDREN = @as(c_long, 128);
pub const ERROR_INVALID_EA_HANDLE = @as(c_long, 278);
pub const AF_SNA = 11;
pub const PERSISTENT_VOLUME_STATE_NO_HEAT_GATHERING = 16;
pub const ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE = @as(c_long, 720);
pub const PROGRESS_QUIET = 3;
pub const IMAGE_FILE_UP_SYSTEM_ONLY = 16384;
pub const CERT_LDAP_STORE_OPENED_FLAG = 262144;
pub const SHUTDOWN_RESTART = 4;
pub const ERROR_DS_SENSITIVE_GROUP_VIOLATION = @as(c_long, 8505);
pub const ERROR_CURRENT_DOMAIN_NOT_ALLOWED = @as(c_long, 1399);
pub const PRINTER_NOTIFY_FIELD_LOCATION = 6;
pub const POINTER_64 = __ptr64;
pub const IMAGE_REL_I386_ABSOLUTE = 0;
pub const VP_TV_STANDARD_PAL_H = 16;
pub const ERROR_ENCRYPTION_DISABLED = @as(c_long, 430);
pub const SPI_GETICONMETRICS = 45;
pub const SDC_VALIDATE = 64;
pub const BCRYPT_3DES_112_CFB_ALG_HANDLE = if (@typeId(@typeOf(401)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 401) else if (@typeId(@typeOf(401)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 401) else BCRYPT_ALG_HANDLE(401);
pub const szOID_RSA_SMIMEalgCMSRC2wrap = "1.2.840.113549.1.9.16.3.7";
pub const SCARD_CLASS_PERF = 32766;
pub const C3_NONSPACING = 1;
pub const IMAGE_REL_CEE_SECTION = 4;
pub const WSA_QOS_ADMISSION_FAILURE = @as(c_long, 11010);
pub const DEVICE_FONTTYPE = 2;
pub const ENABLE_VIRTUAL_TERMINAL_INPUT = 512;
pub const FILE_DEVICE_CHANGER = 48;
pub const CREATE_NO_WINDOW = 134217728;
pub const PIPE_ACCESS_DUPLEX = 3;
pub const BCRYPT_ECDH_ALG_HANDLE = if (@typeId(@typeOf(657)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 657) else if (@typeId(@typeOf(657)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 657) else BCRYPT_ALG_HANDLE(657);
pub const DNS_ERROR_DATABASE_BASE = 9700;
pub const WGL_SWAP_UNDERLAY15 = 1073741824;
pub const PIDDSI_BYTECOUNT = 4;
pub const WN_BAD_DEV_TYPE = ERROR_BAD_DEV_TYPE;
pub const WM_NCMOUSEMOVE = 160;
pub const EMR_RESERVED_117 = 117;
pub const PDCAP_D1_SUPPORTED = 2;
pub const FIEF_FLAG_PEEK = 2;
pub const FRS_ERR_SYSVOL_DEMOTE = @as(c_long, 8016);
pub const KEY_CREATE_SUB_KEY = 4;
pub const VOS_DOS_WINDOWS32 = @as(c_long, 65540);
pub const SHGNLI_NOLNK = 8;
pub const RegCreateKey = RegCreateKeyA;
pub const CMSG_CTRL_ADD_CERT = 10;
pub const FILE_ATTRIBUTE_HIDDEN = 2;
pub const KP_CMS_DH_KEY_INFO = 38;
pub const PRINTER_DRIVER_CATEGORY_3D = 4096;
pub const MCI_SEQ_SET_OFFSET = @as(c_long, 16777216);
pub const SIZE_MAXHIDE = 4;
pub const LPD_SUPPORT_GDI = 16;
pub const CryptSetProviderEx = CryptSetProviderExA;
pub const SPI_SETMOUSEHOVERTIME = 103;
pub const RIDEV_APPKEYS = 1024;
pub const GlobalAddAtom = GlobalAddAtomA;
pub const PSH_USECALLBACK = 256;
pub const ERROR_APPEXEC_INVALID_HOST_STATE = @as(c_long, 3064);
pub const DISPLAYCONFIG_PATH_MODE_IDX_INVALID = 4294967295;
pub const ERROR_INSTALL_PACKAGE_OPEN_FAILED = @as(c_long, 1619);
pub const ERROR_DLL_MIGHT_BE_INSECURE = @as(c_long, 686);
pub const _WIN32_IE_NT4SP2 = _WIN32_IE_IE20;
pub const NORM_IGNORECASE = 1;
pub const RPC_C_EP_MATCH_BY_IF = 1;
pub const PRODUCT_ENTERPRISE_SERVER_V = 38;
pub const _Has_lock_level_ = level;
pub const SHTDN_REASON_MINOR_HOTFIX_UNINSTALL = 23;
pub const DATABITS_5 = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(WORD, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(WORD, 1) else WORD(1);
pub const SHEmptyRecycleBin = SHEmptyRecycleBinA;
pub const IOInetBindInfoEx = IInternetBindInfoEx;
pub const XACT_S_FIRST = 315392;
pub const VK_OEM_COMMA = 188;
pub const ERROR_MEMBER_NOT_IN_ALIAS = @as(c_long, 1377);
pub const RPC_C_OPT_OPTIMIZE_TIME = 16;
pub const PROCESSOR_DUTY_CYCLING_DISABLED = 0;
pub const SEC_NOCACHE = 268435456;
pub const BCRYPT_PAD_PKCS1_OPTIONAL_HASH_OID = 16;
pub const RESETDEV = 7;
pub const CMSG_SIGNED_DATA_PKCS_1_5_VERSION = CMSG_SIGNED_DATA_V1;
pub const CMSG_KEY_AGREE_RECIPIENT = 2;
pub const CreateFile = CreateFileA;
pub const ERROR_LOG_FULL = @as(c_long, 6628);
pub const dwFORCE_KEY_PROTECTION_DISABLED = 0;
pub const SCARD_READER_TYPE_IDE = 16;
pub const ERROR_NO_SITE_SETTINGS_OBJECT = @as(c_long, 8619);
pub const FR_NOMATCHCASE = 2048;
pub const WTS_SESSION_LOCK = 7;
pub const ERROR_TOO_MANY_LUIDS_REQUESTED = @as(c_long, 1333);
pub const SERVICE_NOTIFY_DELETE_PENDING = 512;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_MM = @as(c_long, 13811);
pub const SECURITY_AUTHENTICATION_KEY_PROPERTY_MFA_RID = @as(c_long, 5);
pub const CMSG_CTRL_MAIL_LIST_DECRYPT = 18;
pub const __INTMAX_FMTd__ = "lld";
pub const MEMORY_PRIORITY_MEDIUM = 3;
pub const WNNC_NET_RIVERFRONT1 = 1966080;
pub const RIDEV_EXMODEMASK = 240;
pub const NCRYPTBUFFER_VERSION = 0;
pub const GCL_HICON = -14;
pub const CO_S_LAST = @as(c_long, 262655);
pub const IMAGE_HOT_PATCH_CHUNK_SIZE = 4095;
pub const PROCESSOR_PPC_620 = 620;
pub const APPCOMMAND_BASS_DOWN = 19;
pub const WA_CLICKACTIVE = 2;
pub const DMPAPER_DSHEET = 25;
pub const MM_JOY2BUTTONUP = 952;
pub const IMAGE_FILE_MACHINE_I386 = 332;
pub const TIMESTAMP_FAILURE_INFO_NOT_AVAILABLE = 17;
pub const CTRY_KAZAKSTAN = 7;
pub const _Releases_lock_ = lock;
pub const UCHAR_MAX = 255;
pub const ALG_SID_KEA = 4;
pub const ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER = @as(c_long, 8538);
pub const USN_REASON_NAMED_DATA_EXTEND = 32;
pub const _User_on_ = expr;
pub const APPIDREGFLAGS_ISSUE_ACTIVATION_RPC_AT_IDENTIFY = 4;
pub const TC_SA_CONTIN = 256;
pub const PAN_FAMILYTYPE_INDEX = 0;
pub const NCRYPT_MACHINE_KEY_FLAG = 32;
pub const IMAGE_REL_IA64_DIR64 = 5;
pub const SHUTDOWN_GRACE_OVERRIDE = 32;
pub const ERROR_TOO_MANY_CMDS = @as(c_long, 56);
pub const ERROR_SYSTEM_DEVICE_NOT_FOUND = @as(c_long, 15299);
pub const FIND_ACTCTX_SECTION_KEY_RETURN_HACTCTX = 1;
pub const WM_MOUSEFIRST = 512;
pub const ERROR_BAD_DRIVER = @as(c_long, 2001);
pub const WM_POINTERUP = 583;
pub const RPC_S_NO_MORE_BINDINGS = @as(c_long, 1806);
pub const SS_SIMPLE = @as(c_long, 11);
pub const CRYPT_OID_REGPATH = "Software\\Microsoft\\Cryptography\\OID";
pub const DM_DEFAULTSOURCE = @as(c_long, 512);
pub const SID_HASH_SIZE = 32;
pub const WN_NO_MORE_ENTRIES = ERROR_NO_MORE_ITEMS;
pub const JOY_BUTTON4CHG = 2048;
pub const SW_OTHERZOOM = 2;
pub const SBM_GETSCROLLBARINFO = 235;
pub const CONNECT_REFCOUNT = 64;
pub const ObjectPrivilegeAuditAlarm = ObjectPrivilegeAuditAlarmA;
pub const SPI_SETNONCLIENTMETRICS = 42;
pub const WNNC_NET_RDR2SAMPLE = 2424832;
pub const RpcServerUseProtseqIf = RpcServerUseProtseqIfA;
pub const PM_NOYIELD = 2;
pub const __SIG_ATOMIC_MAX__ = 2147483647;
pub const DMNUP_SYSTEM = 1;
pub const EBADMSG = 104;
pub const LOCK_ELEMENT = 0;
pub const DM_COPIES = @as(c_long, 256);
pub const CBR_110 = 110;
pub const DMPAPER_P32KBIG = 95;
pub const DEVICE_DSM_FLAG_SCRUB_SKIP_IN_SYNC = 268435456;
pub const PROCESS_CREATE_THREAD = 2;
pub const IMAGE_FILE_MACHINE_MIPSFPU = 870;
pub const IMAGE_HOT_PATCH_CALL_TARGET = 278528;
pub const MMIOM_WRITEFLUSH = 5;
pub const CONNECT_CMD_SAVECRED = 4096;
pub const WGL_SWAP_UNDERLAY14 = 536870912;
pub const IME_CMODE_CHINESE = IME_CMODE_NATIVE;
pub const FD_WRITE = 2;
pub const SetConsoleTitle = SetConsoleTitleA;
pub const IMAGE_HOT_PATCH_FUNCTION = 114688;
pub const ERROR_NO_ADMIN_ACCESS_POINT = @as(c_long, 5090);
pub const ACTIVATION_CONTEXT_BASIC_INFORMATION_DEFINED = 1;
pub const MDM_TONE_DIAL = 256;
pub const META_DIBBITBLT = 2368;
pub const exception_code = _exception_code;
pub const ERROR_HWNDS_HAVE_DIFF_PARENT = @as(c_long, 1441);
pub const LMEM_MOVEABLE = 2;
pub const LookupPrivilegeName = LookupPrivilegeNameA;
pub const TOUCHEVENTF_MOVE = 1;
pub const CERT_LOGOTYPE_NO_IMAGE_RESOLUTION_CHOICE = 0;
pub const ERROR_CONNECTION_INVALID = @as(c_long, 1229);
pub const CAL_SDAYNAME2 = 8;
pub const PAGE_ENCLAVE_UNVALIDATED = 536870912;
pub const NRC_CANOCCR = 36;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64 = 2;
pub const ERROR_IPSEC_TRANSPORT_FILTER_EXISTS = @as(c_long, 13008);
pub const _WIN32_IE_NT4SP3 = _WIN32_IE_IE302;
pub const IMAGE_REL_PPC_TOCREL14 = 9;
pub const IMAGE_HOT_PATCH_CHUNK_TARGET_RVA = 16384;
pub const WINPERF_LOG_DEBUG = 2;
pub const ERROR_SCOPE_NOT_FOUND = @as(c_long, 318);
pub const ERROR_INVALID_LDT_OFFSET = @as(c_long, 563);
pub const ERROR_NOT_SAME_DEVICE = @as(c_long, 17);
pub const IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT = 11;
pub const KEY_WOW64_64KEY = 256;
pub const LANG_ROMANSH = 23;
pub const WNetAddConnection = WNetAddConnectionA;
pub const ERROR_OBJECT_NOT_EXTERNALLY_BACKED = @as(c_long, 342);
pub const LPD_SWAP_EXCHANGE = 512;
pub const PSINJECT_ENDPAGECOMMENTS = 107;
pub const NCRYPT_CIPHER_NO_PADDING_FLAG = 0;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT = @as(c_long, 1176);
pub const DMBIN_CASSETTE = 14;
pub const sz_CERT_STORE_PROV_MEMORY = "Memory";
pub const ERROR_LABEL_UNREADABLE = 1;
pub const IMAGE_SCN_CNT_INITIALIZED_DATA = 64;
pub const Uri_CREATE_NO_IE_SETTINGS = 16384;
pub const BKMODE_LAST = 2;
pub const RPC_C_SECURITY_QOS_VERSION_3 = @as(c_long, 3);
pub const LANG_RUSSIAN = 25;
pub const MCI_DEVTYPE_DAT = 517;
pub const MAC_CHARSET = 77;
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_DISABLED = 0;
pub const AddPrinterConnection2 = AddPrinterConnection2A;
pub const BN_PAINT = 1;
pub const GetMenuString = GetMenuStringA;
pub const MOUSEEVENTF_RIGHTDOWN = 8;
pub const SPI_SETDISABLEOVERLAPPEDCONTENT = 4161;
pub const SB_HORZ = 0;
pub const __PIC__ = 2;
pub const QueryDosDevice = QueryDosDeviceA;
pub const CFSTR_ENTERPRISE_ID = if (@typeId(@typeOf("EnterpriseDataProtectionId")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "EnterpriseDataProtectionId") else if (@typeId(@typeOf("EnterpriseDataProtectionId")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "EnterpriseDataProtectionId") else TEXT("EnterpriseDataProtectionId");
pub const JOB_OBJECT_MSG_JOB_MEMORY_LIMIT = 10;
pub const __REQUIRED_RPCSAL_H_VERSION__ = 100;
pub const ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE = @as(c_long, 690);
pub const TIMESTAMP_REQUEST = if (@typeId(@typeOf(78)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 78) else if (@typeId(@typeOf(78)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 78) else LPCSTR(78);
pub const PERFSTATE_POLICY_CHANGE_IDEAL_AGGRESSIVE = 3;
pub const QS_TOUCH = 2048;
pub const LGRPID_SIMPLIFIED_CHINESE = 10;
pub const SECURITY_USERMODEDRIVERHOST_ID_BASE_RID = @as(c_long, 84);
pub const SUBLANG_SPANISH_BOLIVIA = 16;
pub const CORE_PARKING_POLICY_CHANGE_SINGLE = 1;
pub const sz_CERT_STORE_PROV_SMART_CARD = sz_CERT_STORE_PROV_SMART_CARD_W;
pub const EDEADLK = 36;
pub const InterlockedXorAcquire = _InterlockedXor;
pub const CERT_INFO_SUBJECT_PUBLIC_KEY_INFO_FLAG = 8;
pub const ERROR_INVALID_ACCESS = @as(c_long, 12);
pub const OCSP_SUCCESSFUL_RESPONSE = 0;
pub const TOUCHEVENTF_INRANGE = 8;
pub const szOID_VERISIGN_BITSTRING_6_13 = "2.16.840.1.113733.1.6.13";
pub const SERVICE_STOPPED = 1;
pub const SE_SIGNING_LEVEL_UNSIGNED = 1;
pub const MCI_ANIM_GETDEVCAPS_CAN_REVERSE = @as(c_long, 16385);
pub const SUBLANG_TIGRINYA_ETHIOPIA = 1;
pub const FILE_SUPPORTS_INTEGRITY_STREAMS = 67108864;
pub const DialogBox = DialogBoxA;
pub const IME_ESC_RESERVED_LAST = 2047;
pub const SUBLANG_SPANISH_NICARAGUA = 19;
pub const MCI_FIRST = DRV_MCI_FIRST;
pub const QUERY_FILE_LAYOUT_INCLUDE_FILES_WITH_DSC_ATTRIBUTE = 4096;
pub const MB_RTLREADING = @as(c_long, 1048576);
pub const DMLERR_NO_CONV_ESTABLISHED = 16394;
pub const MEM_COMMIT = 4096;
pub const ERROR_IPSEC_IKE_PROCESS_ERR = @as(c_long, 13829);
pub const PORT_STATUS_OFFLINE = 1;
pub const BATTERY_FLAG_UNKNOWN = 255;
pub const HSHELL_WINDOWACTIVATED = 4;
pub const ERROR_MORE_WRITES = @as(c_long, 1120);
pub const VarIntFromUI1 = VarI4FromUI1;
pub const IMAGE_WEAK_EXTERN_ANTI_DEPENDENCY = 4;
pub const CONNECT_REQUIRE_INTEGRITY = 16384;
pub const ERROR_CLUSTER_IPADDR_IN_USE = @as(c_long, 5057);
pub const JOB_NOTIFY_FIELD_DOCUMENT = 13;
pub const MCI_VD_PLAY_REVERSE = @as(c_long, 65536);
pub const SUBLANG_SAMI_INARI_FINLAND = 9;
pub const IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED = 2;
pub const CFSTR_MIME_XBM = if (@typeId(@typeOf("image/xbm")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "image/xbm") else if (@typeId(@typeOf("image/xbm")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "image/xbm") else TEXT("image/xbm");
pub const ETO_IGNORELANGUAGE = 4096;
pub const INADDR_NONE = 4294967295;
pub const ERROR_IPSEC_IKE_INVALID_GROUP = @as(c_long, 13865);
pub const PEN_FLAG_NONE = 0;
pub const ERROR_SERVICE_DEPENDENCY_FAIL = @as(c_long, 1068);
pub const ERROR_IPSEC_MM_AUTH_PENDING_DELETION = @as(c_long, 13022);
pub const ELF_VERSION = 0;
pub const GetShortPathName = GetShortPathNameA;
pub const AF_NS = 6;
pub const FAST_FAIL_GUARD_JUMPTABLE = 37;
pub const WM_NCMBUTTONDBLCLK = 169;
pub const EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X = 18;
pub const ERROR_DS_CANT_MOD_OBJ_CLASS = @as(c_long, 8215);
pub const X3_TMPLT_SIGN_VAL_POS_X = 0;
pub const URLACTION_INFODELIVERY_NO_REMOVING_SUBSCRIPTIONS = 7429;
pub const SECTION_MAP_READ = 4;
pub const LBSELCHSTRINGA = "commdlg_LBSelChangedNotify";
pub const SERVICE_CONTROL_INTERROGATE = 4;
pub const MCI_STATUS_LENGTH = @as(c_long, 1);
pub const ERROR_THREAD_WAS_SUSPENDED = @as(c_long, 699);
pub const USN_REASON_REPARSE_POINT_CHANGE = 1048576;
pub const THREAD_PRIORITY_ABOVE_NORMAL = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(THREAD_PRIORITY_HIGHEST, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(THREAD_PRIORITY_HIGHEST, -1) else THREAD_PRIORITY_HIGHEST(-1);
pub const CCH_MAX_PROPSTG_NAME = 31;
pub const PS_SOLID = 0;
pub const DDL_POSTMSGS = 8192;
pub const BCRYPT_PAD_PSS = 8;
pub const GetTempPath = GetTempPathA;
pub const IMAGE_FILE_MACHINE_SH3E = 420;
pub const BCRYPT_HASH_OPERATION = 2;
pub const IMAGE_REL_AMD64_ADDR32 = 2;
pub const SERVICE_STOP_REASON_MINOR_MIN_CUSTOM = 256;
pub const PERF_SIZE_LARGE = 256;
pub const WNCON_FORNETCARD = 1;
pub const GCL_HBRBACKGROUND = -10;
pub const JOY_CAL_READXONLY = @as(c_long, 1048576);
pub const PERFSTATE_POLICY_CHANGE_IDEAL = 0;
pub const ERROR_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED = @as(c_long, 375);
pub const InterlockedBitTestAndSetAcquire = _interlockedbittestandset;
pub const __LDBL_HAS_QUIET_NAN__ = 1;
pub const CAL_SDAYNAME3 = 9;
pub const PROCESS_CREATION_MITIGATION_POLICY_IMAGE_LOAD_NO_REMOTE_ALWAYS_ON = if (@typeId(@typeOf(i64 << 52)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << 52) else if (@typeId(@typeOf(i64 << 52)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << 52) else @as(c_uint, 1)(i64 << 52);
pub const N_TMASK2 = 240;
pub const ERROR_ICM_NOT_ENABLED = @as(c_long, 2018);
pub const URLDownloadToFile = URLDownloadToFileA;
pub const SOCK_RAW = 3;
pub const ALG_SID_TLS1_MASTER = 6;
pub const MOUSE_WHEELED = 4;
pub const CERT_HCRYPTPROV_OR_NCRYPT_KEY_HANDLE_PROP_ID = 79;
pub const waveOutGetDevCaps = waveOutGetDevCapsA;
pub const STORAGE_ADAPTER_SERIAL_NUMBER_V1_VERSION = if (@typeId(@typeOf(STORAGE_ADAPTER_SERIAL_NUMBER)) == @import("builtin").TypeId.Pointer) @ptrCast(sizeof, STORAGE_ADAPTER_SERIAL_NUMBER) else if (@typeId(@typeOf(STORAGE_ADAPTER_SERIAL_NUMBER)) == @import("builtin").TypeId.Int) @intToPtr(sizeof, STORAGE_ADAPTER_SERIAL_NUMBER) else sizeof(STORAGE_ADAPTER_SERIAL_NUMBER);
pub const RPC_VAR_ENTRY = __cdecl;
pub const PIPE_ACCEPT_REMOTE_CLIENTS = 0;
pub const ESPIPE = 29;
pub const EVENT_UIA_EVENTID_START = 19968;
pub const PP_CERTCHAIN = 9;
pub const CMSG_SIGNER_UNAUTH_ATTR_PARAM = 10;
pub const CO_S_FIRST = @as(c_long, 262640);
pub const FINDMSGSTRINGA = "commdlg_FindReplace";
pub const ERROR_TIME_SENSITIVE_THREAD = @as(c_long, 422);
pub const WM_APP = 32768;
pub const CERT_CHAIN_POLICY_IGNORE_PEER_TRUST_FLAG = 4096;
pub const STATUS_FLOAT_MULTIPLE_FAULTS = if (@typeId(@typeOf(@as(c_long, 3221226164))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 3221226164)) else if (@typeId(@typeOf(@as(c_long, 3221226164))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 3221226164)) else DWORD(@as(c_long, 3221226164));
pub const CERT_FIND_SIGNATURE_HASH = CERT_COMPARE_SIGNATURE_HASH << CERT_COMPARE_SHIFT;
pub const PROCESSOR_THROTTLE_DISABLED = 0;
pub const RPC_HTTP_TRANSPORT_CREDENTIALS_V3 = RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A;
pub const CRYPT_ACQUIRE_ONLY_NCRYPT_KEY_FLAG = 262144;
pub const EVENT_SYSTEM_MENUEND = 5;
pub const ERROR_RECOVERY_FAILURE = @as(c_long, 1279);
pub const SB_TOP = 6;
pub const URLACTION_SHELL_EXECUTE_HIGHRISK = 6150;
pub const NCRYPTBUFFER_PKCS_SECRET = 46;
pub const RPC_C_SECURITY_QOS_VERSION_2 = @as(c_long, 2);
pub const ERROR_CARDBUS_NOT_SUPPORTED = @as(c_long, 724);
pub const LB_GETITEMRECT = 408;
pub const ERROR_INVALID_MENU_HANDLE = @as(c_long, 1401);
pub const PRINTER_STATUS_OUTPUT_BIN_FULL = 2048;
pub const ERROR_INVALID_LDT_DESCRIPTOR = @as(c_long, 564);
pub const LOCALE_IDEFAULTCOUNTRY = 10;
pub const CB_GETLBTEXTLEN = 329;
pub const MUTZ_IGNORE_ZONE_MAPPINGS = 16384;
pub const WSAEINTR = @as(c_long, 10004);
pub const SECURITY_CAPABILITY_CONTACTS = @as(c_long, 12);
pub const SPI_SETSELECTIONFADE = 4117;
pub const EVENT_SYSTEM_SCROLLINGSTART = 18;
pub const ERROR_DS_CLASS_NOT_DSA = @as(c_long, 8343);
pub const EVENT_OBJECT_SHOW = 32770;
pub const WS_HSCROLL = @as(c_long, 1048576);
pub const FACILITY_DEPLOYMENT_SERVICES_MANAGEMENT = 259;
pub const VFT_STATIC_LIB = @as(c_long, 7);
pub const NRC_PENDING = 255;
pub const SW_ERASE = 4;
pub const CRYPT_FIRST_ALG_OID_GROUP_ID = CRYPT_HASH_ALG_OID_GROUP_ID;
pub const VK_LWIN = 91;
pub const SPI_GETSHOWIMEUI = 110;
pub const SC_KEYMENU = 61696;
pub const VTBIT_I4 = 1 << VT_I4;
pub const ERROR_TRUST_FAILURE = @as(c_long, 1790);
pub const VK_SCROLL = 145;
pub const ERROR_CLOUD_FILE_PINNED = @as(c_long, 392);
pub const TIME_CALLBACK_EVENT_PULSE = 32;
pub const ERROR_DS_DRA_SOURCE_REINSTALLED = @as(c_long, 8459);
pub const EMR_SETBRUSHORGEX = 13;
pub const szOID_KP_MOBILE_DEVICE_SOFTWARE = "1.3.6.1.4.1.311.10.3.14";
pub const IMAGE_SYM_CLASS_LABEL = 6;
pub const CHECKSUM_TYPE_ECC = 3;
pub const CreateEventEx = CreateEventExA;
pub const TAPE_DRIVE_FORMAT = 2684354560;
pub const PSINJECT_EOF = 19;
pub const ObjectDeleteAuditAlarm = ObjectDeleteAuditAlarmA;
pub const _Ret1_impl_ = p1;
pub const SWP_NOSIZE = 1;
pub const DRIVE_CDROM = 5;
pub const PSH_NOMARGIN = 268435456;
pub const SHFileOperation = SHFileOperationA;
pub const JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS = 8;
pub const ERROR_CRC = @as(c_long, 23);
pub const ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY = @as(c_long, 218);
pub const ACCESS_PROPERTY_SET_GUID = 1;
pub const CBS_NOINTEGRALHEIGHT = @as(c_long, 1024);
pub const VP_TV_STANDARD_PAL_M = 64;
pub const OpenWaitableTimer = OpenWaitableTimerA;
pub const FILE_ANY_ACCESS = 0;
pub const WS_EX_CONTROLPARENT = @as(c_long, 65536);
pub const CS_SAVEBITS = 2048;
pub const IMAGE_SYM_DTYPE_FUNCTION = 2;
pub const WNNC_NET_ZENWORKS = 3997696;
pub const EV_RXFLAG = 2;
pub const IMAGE_REL_AMD64_ABSOLUTE = 0;
pub const CRYPT_EXCLUSIVE = 1;
pub const COLOR_APPWORKSPACE = 12;
pub const IMAGE_SIZEOF_SHORT_NAME = 8;
pub const IMAGE_SCN_MEM_PURGEABLE = 131072;
pub const ERROR_INTERNAL_DB_ERROR = @as(c_long, 1383);
pub const AddJob = AddJobA;
pub const OpenService = OpenServiceA;
pub const TXFS_RM_FLAG_LOG_NO_CONTAINER_COUNT_MIN = 256;
pub const PSWIZB_NEXT = 2;
pub const FACILITY_UTC = 1989;
pub const VIETNAMESE_CHARSET = 163;
pub const SPI_GETACTIVEWNDTRKTIMEOUT = 8194;
pub const PRINTER_ATTRIBUTE_RAW_ONLY = 4096;
pub const UCLEANUI = SHTDN_REASON_FLAG_CLEAN_UI;
pub const PRINTER_CHANGE_TIMEOUT = 2147483648;
pub const FILE_INITIATE_REPAIR_HINT1_STALE_INFORMATION = 16384;
pub const JOB_NOTIFY_FIELD_REMOTE_JOB_ID = 24;
pub const TAPE_DRIVE_SET_CMP_BOP_ONLY = 67108864;
pub const RI_MOUSE_MIDDLE_BUTTON_DOWN = 16;
pub const URLACTION_SHELL_MIN = 6144;
pub const SS_ETCHEDVERT = @as(c_long, 17);
pub const FKF_FILTERKEYSON = 1;
pub const REG_HIVE_EXACT_FILE_GROWTH = @as(c_long, 128);
pub const IMN_SETCANDIDATEPOS = 9;
pub const ERROR_HASH_NOT_SUPPORTED = @as(c_long, 15300);
pub const IMR_COMPOSITIONFONT = 3;
pub const PS_JOIN_MITER = 8192;
pub const AnsiToOemBuff = CharToOemBuffA;
pub const FILE_DEVICE_MAILSLOT = 12;
pub const IOCTL_SCM_PHYSICAL_DEVICE_FUNCTION_BASE = 1536;
pub const PPM_FIRMWARE_PTC = 1024;
pub const ERROR_CLUSTER_NULL_DATA = @as(c_long, 5920);
pub const RPC_S_UNKNOWN_MGR_TYPE = @as(c_long, 1716);
pub const ERROR_RECEIVE_PARTIAL = @as(c_long, 707);
pub const SERVICE_NOTIFY_STATUS_CHANGE_1 = 1;
pub const SS_CENTER = @as(c_long, 1);
pub const RPC_C_CANCEL_INFINITE_TIMEOUT = -1;
pub const _WIN32_IE_NT4SP1 = _WIN32_IE_IE20;
pub const GCL_MENUNAME = -8;
pub const ERROR_DLL_NOT_FOUND = @as(c_long, 1157);
pub const WM_GETHOTKEY = 51;
pub const STGM_TRANSACTED = @as(c_long, 65536);
pub const IMAGE_DEBUG_TYPE_FPO = 3;
pub const URLMON_OPTION_USERAGENT = 268435457;
pub const CERT_NONCOMPLIANT_ROOT_URL_PROP_ID = 123;
pub const NI_SETCANDIDATE_PAGESIZE = 23;
pub const IMAGE_ARCHIVE_LONGNAMES_MEMBER = "//              ";
pub const DATABITS_8 = if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Pointer) @ptrCast(WORD, 8) else if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Int) @intToPtr(WORD, 8) else WORD(8);
pub const NRC_ILLCMD = 3;
pub const REG_UNLOAD_LEGAL_FLAGS = REG_FORCE_UNLOAD;
pub const szOID_CRL_REASON_CODE = "2.5.29.21";
pub const SET_BOUNDS = 4109;
pub const CRYPT_STRING_HEXRAW = 12;
pub const C3_HIRAGANA = 32;
pub const ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4 = @as(c_long, 8572);
pub const OUT_OUTLINE_PRECIS = 8;
pub const IMAGE_SCN_ALIGN_16BYTES = 5242880;
pub const ENOTSUP = 129;
pub const ERROR_INTERNAL_ERROR = @as(c_long, 1359);
pub const DEFAULT_GUI_FONT = 17;
pub const BS_VCENTER = @as(c_long, 3072);
pub const __inout_bcount_nz = size;
pub const C1_DEFINED = 512;
pub const CREDENTIAL_OID_PASSWORD_CREDENTIALS_A = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 1) else LPCSTR(1);
pub const ERROR_UNABLE_TO_INVENTORY_TRANSPORT = @as(c_long, 4327);
pub const RPC_HTTP_TRANSPORT_CREDENTIALS_V2 = RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A;
pub const SCARD_T0_CMD_LENGTH = 5;
pub const SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE = 14;
pub const ERROR_BAD_DLL_ENTRYPOINT = @as(c_long, 609);
pub const DEVICE_NOTIFY_WINDOW_HANDLE = 0;
pub const FCONTROL = 8;
pub const BeginUpdateResource = BeginUpdateResourceA;
pub const PFD_SUPPORT_OPENGL = 32;
pub const EMR_ROUNDRECT = 44;
pub const ODS_COMBOBOXEDIT = 4096;
pub const DC_COLORDEVICE = 32;
pub const SUBLANG_DUTCH_BELGIAN = 2;
pub const RPC_C_SECURITY_QOS_VERSION_5 = @as(c_long, 5);
pub const ReplaceFile = ReplaceFileA;
pub const RC_DI_BITMAP = 128;
pub const CFSTR_MIME_TIFF = if (@typeId(@typeOf("image/tiff")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "image/tiff") else if (@typeId(@typeOf("image/tiff")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "image/tiff") else TEXT("image/tiff");
pub const WM_KEYLAST = 265;
pub const MCI_WAVE_STATUS_SAMPLESPERSEC = @as(c_long, 16387);
pub const SUBLANG_ODIA_INDIA = 1;
pub const NOP_FUNCTION = __noop;
pub const ERROR_IPSEC_IKE_INVALID_SIG = @as(c_long, 13875);
pub const WM_RBUTTONDOWN = 516;
pub const RTL_CRITICAL_SECTION_ALL_FLAG_BITS = 4278190080;
pub const ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE = @as(c_long, 15080);
pub const WNNC_NET_RIVERFRONT2 = 2031616;
pub const GlobalGetAtomName = GlobalGetAtomNameA;
pub const DOMAIN_GROUP_RID_CERT_ADMINS = @as(c_long, 517);
pub const LANG_ZULU = 53;
pub const WPF_ASYNCWINDOWPLACEMENT = 4;
pub const EXPORT_PRIVATE_KEYS = 4;
pub const MCI_SET_DOOR_CLOSED = @as(c_long, 512);
pub const ACPI_PPM_SOFTWARE_ANY = 253;
pub const UI_CAP_2700 = 1;
pub const MAXULONG32 = if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(ULONG32, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(ULONG32, 0) else ULONG32(0))) == @import("builtin").TypeId.Pointer) @ptrCast(ULONG32, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(ULONG32, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(ULONG32, 0) else ULONG32(0)) else if (@typeId(@typeOf(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(ULONG32, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(ULONG32, 0) else ULONG32(0))) == @import("builtin").TypeId.Int) @intToPtr(ULONG32, ~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(ULONG32, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(ULONG32, 0) else ULONG32(0)) else ULONG32(~if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(ULONG32, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(ULONG32, 0) else ULONG32(0));
pub const ERROR_MUI_FILE_NOT_LOADED = @as(c_long, 15105);
pub const WM_VSCROLLCLIPBOARD = 778;
pub const IMR_CANDIDATEWINDOW = 2;
pub const LOCALE_SPERCENT = 118;
pub const CERT_SYSTEM_STORE_MASK = 4294901760;
pub const ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER = @as(c_long, 6018);
pub const FINDDLGORD = 1540;
pub const RPC_C_AUTHN_DEFAULT = @as(c_long, 4294967295);
pub const BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO_VERSION = 1;
pub const COMPRESSION_ENGINE_MAXIMUM = 256;
pub const PRINTACTION_PROPERTIES = 1;
pub const DS_SYSMODAL = @as(c_long, 2);
pub const REG_HIVE_SINGLE_LOG = @as(c_long, 512);
pub const CONTEXT_OID_CTL = if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 3) else if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 3) else LPCSTR(3);
pub const SHTDN_REASON_MINOR_NONE = 255;
pub const ERROR_CLUSTER_CSV_INVALID_HANDLE = @as(c_long, 5989);
pub const ILLUMINANT_D55 = 5;
pub const WM_MDICASCADE = 551;
pub const szOID_NETSCAPE_CERT_SEQUENCE = "2.16.840.1.113730.2.5";
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_ATTRIBUTE_SYSTEM = 50331648;
pub const DEVICEFAMILYDEVICEFORM_NOTEBOOK = 4;
pub const WM_ENABLE = 10;
pub const EnumPrinterKey = EnumPrinterKeyA;
pub const SUBLANG_ARABIC_LIBYA = 4;
pub const EVENTLOG_AUDIT_SUCCESS = 8;
pub const CERT_SUBJECT_PUBLIC_KEY_MD5_HASH_PROP_ID = 25;
pub const LANG_TIGRINYA = 115;
pub const DOUBLE_CLICK = 2;
pub const SYSTEM_CPU_SET_INFORMATION_PARKED = 1;
pub const InterlockedExchangeAddRelease = _InterlockedExchangeAdd;
pub const DNS_ERROR_SECURE_BASE = 9800;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_NONE = 0;
pub const SMART_SHORT_SELFTEST_CAPTIVE = 129;
pub const PAN_FAMILY_PICTORIAL = 5;
pub const REASON_PLANNED_FLAG = SHTDN_REASON_FLAG_PLANNED;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_7 = 7;
pub const PSINJECT_PAGEORDER = 7;
pub const X942_DH_PARAMETERS = if (@typeId(@typeOf(50)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 50) else if (@typeId(@typeOf(50)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 50) else LPCSTR(50);
pub const CLIP_CHARACTER_PRECIS = 1;
pub const CMC_OTHER_INFO_PEND_CHOICE = 2;
pub const ERROR_END_OF_MEDIA = @as(c_long, 1100);
pub const WGL_SWAP_UNDERLAY11 = 67108864;
pub const OFN_NOREADONLYRETURN = 32768;
pub const RPC_BUFFER_EXTRA = 16384;
pub const REG_FORCE_UNLOAD = 1;
pub const SPI_GETMENUFADE = 4114;
pub const C3_FULLWIDTH = 128;
pub const CC_PREVENTFULLOPEN = 4;
pub const ALG_SID_DH_EPHEM = 2;
pub const LANG_BOSNIAN_NEUTRAL = 30746;
pub const MM_DRVM_OPEN = 976;
pub const SERVER_NOTIFY_TYPE = 2;
pub const CROSS_CERT_DIST_POINT_ERR_INDEX_MASK = 255;
pub const DNS_UNREGISTER = 2;
pub const ERROR_MRM_NO_CANDIDATE = @as(c_long, 15115);
pub const EDD_GET_DEVICE_INTERFACE_NAME = 1;
pub const NF_REQUERY = 4;
pub const CRYPT_DELETE_DEFAULT = 4;
pub const ERROR_IPSEC_IKE_NEG_STATUS_END = @as(c_long, 13897);
pub const SC_VSCROLL = 61552;
pub const grp1 = 1072;
pub const CAL_SDAYNAME1 = 7;
pub const ERROR_BIDI_ERROR_BASE = 13000;
pub const CdRomClassGuid = GUID_DEVINTERFACE_CDROM;
pub const GCPCLASS_LATINNUMBER = 5;
pub const DMBIN_ENVMANUAL = 6;
pub const PSP_USEHEADERTITLE = 4096;
pub const META_SETRELABS = 261;
pub const SM_MOUSEPRESENT = 19;
pub const TOKEN_ACCESS_PSEUDO_HANDLE = TOKEN_ACCESS_PSEUDO_HANDLE_WIN8;
pub const IMN_SETSENTENCEMODE = 7;
pub const FLUSHOUTPUT = 6;
pub const SEC_WINNT_AUTH_IDENTITY_ANSI = 1;
pub const CLIP_TT_ALWAYS = 2 << 4;
pub const ACCESS_MAX_MS_V2_ACE_TYPE = 3;
pub const ERROR_INVALID_FLAGS = @as(c_long, 1004);
pub const SetCalendarInfo = SetCalendarInfoA;
pub const ERROR_NO_SUCH_GROUP = @as(c_long, 1319);
pub const CAL_RETURN_GENITIVE_NAMES = LOCALE_RETURN_GENITIVE_NAMES;
pub const BS_DIBPATTERN = 5;
pub const MDMVOL_LOW = 0;
pub const SETXOFF = 1;
pub const ABN_FULLSCREENAPP = 2;
pub const szOID_ECC_CURVE_NISTP384 = szOID_ECC_CURVE_P384;
pub const IMAGE_SYM_CLASS_EXTERNAL_DEF = 5;
pub const _Write_guarded_by_ = lock;
pub const __releases_exclusive_lock = lock;
pub const CERT_BUNDLE_CRL = 1;
pub const GetLongPathName = GetLongPathNameA;
pub const PAN_PROP_EVEN_WIDTH = 4;
pub const szOID_RSA_digestedData = "1.2.840.113549.1.7.5";
pub const GPT_BASIC_DATA_ATTRIBUTE_SERVICE = 144115188075855872;
pub const DEVICEFAMILYDEVICEFORM_UNKNOWN = 0;
pub const SHGFI_EXETYPE = 8192;
pub const DT_EDITCONTROL = 8192;
pub const HBMMENU_POPUP_CLOSE = if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Pointer) @ptrCast(HBITMAP, 8) else if (@typeId(@typeOf(8)) == @import("builtin").TypeId.Int) @intToPtr(HBITMAP, 8) else HBITMAP(8);
pub const RPC_C_SECURITY_QOS_VERSION_4 = @as(c_long, 4);
pub const ERROR_MRM_UNSUPPORTED_PROFILE_TYPE = @as(c_long, 15136);
pub const HELP_FINDER = 11;
pub const SHGFI_DISPLAYNAME = 512;
pub const META_PIE = 2074;
pub const TIME_VALID_OID_FLUSH_CRL = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 2) else LPCSTR(2);
pub const FILE_INITIATE_REPAIR_HINT1_NOTHING_WRONG = 2048;
pub const CRYPTNET_URL_CACHE_PRE_FETCH_NONE = 0;
pub const InterlockedCompareExchange16 = _InterlockedCompareExchange16;
pub const ERROR_ABIOS_ERROR = @as(c_long, 538);
pub const KTM_MARSHAL_BLOB_VERSION_MINOR = 1;
pub const HFILE_ERROR = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(HFILE, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(HFILE, -1) else HFILE(-1);
pub const ERROR_PROFILING_NOT_STARTED = @as(c_long, 550);
pub const SCARD_PROTOCOL_T0 = 1;
pub const InterlockedBitTestAndSetNoFence = _interlockedbittestandset;
pub const CRYPTNET_URL_CACHE_PRE_FETCH_AUTOROOT_CAB = 5;
pub const ONESTOPBIT = 0;
pub const CAL_GREGORIAN_ME_FRENCH = 9;
pub const SE_PRIVILEGE_ENABLED = @as(c_long, 2);
pub const HTCAPTION = 2;
pub const GCLP_HBRBACKGROUND = -10;
pub const ERROR_VC_DISCONNECTED = @as(c_long, 240);
pub const ERROR_EXPIRED_HANDLE = @as(c_long, 6854);
pub const ERROR_HANDLE_DISK_FULL = @as(c_long, 39);
pub const NIIF_INFO = 1;
pub const NO_ERROR = @as(c_long, 0);
pub const CMC_ADD_EXTENSIONS = if (@typeId(@typeOf(62)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 62) else if (@typeId(@typeOf(62)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 62) else LPCSTR(62);
pub const SERVICE_STOP_REASON_MINOR_SOFTWARE_UPDATE_UNINSTALL = 20;
pub const ERROR_DS_CANT_REMOVE_CLASS_CACHE = @as(c_long, 8404);
pub const WAVE_FORMAT_2M16 = 64;
pub const CC_WIDE = 16;
pub const ERROR_PRINTER_NOT_SHAREABLE = @as(c_long, 3022);
pub const PUBLICKEYBLOB = 6;
pub const HELP_FORCEFILE = @as(c_long, 9);
pub const WHDR_DONE = 1;
pub const REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY = 2;
pub const SPI_GETTOGGLEKEYS = 52;
pub const DNS_ERROR_VIRTUALIZATION_INSTANCE_ALREADY_EXISTS = @as(c_long, 9921);
pub const ERROR_UNRECOGNIZED_MEDIA = @as(c_long, 1785);
pub const CRYPT_OID_USE_CURVE_NAME_FOR_ENCODE_FLAG = 536870912;
pub const LZOpenFile = LZOpenFileA;
pub const WT_EXECUTEDEFAULT = 0;
pub const FILE_DEVICE_SERIAL_PORT = 27;
pub const ReadSizeTNoFence = ReadULongPtrNoFence;
pub const FW_HEAVY = 900;
pub const CRYPT_OID_INFO_CNG_SIGN_KEY = 6;
pub const EWX_POWEROFF = 8;
pub const ERROR_SUCCESS = @as(c_long, 0);
pub const C1_LOWER = 2;
pub const IMAGE_SYM_CLASS_ENUM_TAG = 15;
pub const NCRYPT_ECDH_P521_ALGORITHM = BCRYPT_ECDH_P521_ALGORITHM;
pub const UOI_NAME = 2;
pub const ERROR_DELAY_LOAD_FAILED = @as(c_long, 1285);
pub const PRINTER_CHANGE_PORT = 7340032;
pub const LF_FACESIZE = 32;
pub const SERVICE_NOTIFY_CONTINUE_PENDING = 16;
pub const DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS = @as(c_long, 557);
pub const ALG_SID_AES_192 = 15;
pub const CFERR_MAXLESSTHANMIN = 8194;
pub const VarIntFromUI2 = VarI4FromUI2;
pub const szOID_INFOSEC_sdnsIntegrity = "2.16.840.1.101.2.1.1.5";
pub const QUOTA_LIMITS_HARDWS_MAX_ENABLE = 4;
pub const PROCESS_CREATION_MITIGATION_POLICY_EXTENSION_POINT_DISABLE_ALWAYS_ON = if (@typeId(@typeOf(i64 << 32)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 1), i64 << 32) else if (@typeId(@typeOf(i64 << 32)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 1), i64 << 32) else @as(c_uint, 1)(i64 << 32);
pub const PPM_FIRMWARE_PCT = 32;
pub const HELP_SETWINPOS = @as(c_long, 515);
pub const CERT_STORE_PROV_CONTROL_FUNC = 13;
pub const MOVEFILE_CREATE_HARDLINK = 16;
pub const SUBLANG_GREENLANDIC_GREENLAND = 1;
pub const TAPE_DRIVE_ABS_BLK_IMMED = 2147491840;
pub const CERT_CHAIN_AUTO_IMPERSONATED = 3;
pub const szOID_NETSCAPE_SSL_SERVER_NAME = "2.16.840.1.113730.1.12";
pub const CERT_COMPARE_NAME_STR_A = 7;
pub const BCRYPT_DSA_PARAMETERS_MAGIC_V2 = 843927620;
pub const C1_ALPHA = 256;
pub const NCRYPT_UI_APPCONTAINER_ACCESS_MEDIUM_FLAG = 8;
pub const NTSYSAPI = DECLSPEC_IMPORT;
pub const SMART_CYL_HI = 194;
pub const ERROR_PAGE_FAULT_GUARD_PAGE = @as(c_long, 750);
pub const WGL_SWAP_UNDERLAY10 = 33554432;
pub const ERROR_GLOBAL_ONLY_HOOK = @as(c_long, 1429);
pub const IOCTL_STORAGE_BC_VERSION = 1;
pub const TRANSPORT_TYPE_WMSG = 8;
pub const SPI_GETCLEARTYPE = 4168;
pub const ERROR_DATA_LOST_REPAIR = @as(c_long, 6843);
pub const GDICOMMENT_ENDGROUP = 3;
pub const _WIN32_WINNT_WS03 = 1282;
pub const FAST_FAIL_INVALID_SET_OF_CONTEXT = 13;
pub const PROCESS_CREATION_MITIGATION_POLICY_SEHOP_ENABLE = 4;
pub const IMC_GETCOMPOSITIONWINDOW = 11;
pub const MAXSHORT = 32767;
pub const POLICY_SHOWREASONUI_WORKSTATIONONLY = 2;
pub const ERROR_SERVICE_NOT_ACTIVE = @as(c_long, 1062);
pub const ERROR_INVALID_CATEGORY = @as(c_long, 117);
pub const TRANSACTION_NOTIFY_DELEGATE_COMMIT = 1024;
pub const CHECKSUM_TYPE_UNCHANGED = -1;
pub const PRODUCT_HUBOS = 180;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_PACKAGE = @as(c_long, 15649);
pub const SCEX2_ALT_NETBIOS_NAME = 1;
pub const PRODUCT_STORAGE_STANDARD_SERVER = 21;
pub const X509_POLICY_MAPPINGS = if (@typeId(@typeOf(56)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 56) else if (@typeId(@typeOf(56)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 56) else LPCSTR(56);
pub const IMAGE_REL_CEF_ADDR32NB = 3;
pub const PRODUCT_PROFESSIONAL_S = 127;
pub const IsValidDevmode = IsValidDevmodeA;
pub const STILL_ACTIVE = STATUS_PENDING;
pub const ERROR_TIMER_NOT_CANCELED = @as(c_long, 541);
pub const grp2 = 1073;
pub const CFSTR_MIME_TEXT = if (@typeId(@typeOf("text/plain")) == @import("builtin").TypeId.Pointer) @ptrCast(TEXT, "text/plain") else if (@typeId(@typeOf("text/plain")) == @import("builtin").TypeId.Int) @intToPtr(TEXT, "text/plain") else TEXT("text/plain");
pub const CAL_SDAYNAME6 = 12;
pub const SOFTKEYBOARD_TYPE_C1 = 2;
pub const __UINT_FAST8_FMTx__ = "hhx";
pub const N_TMASK1 = 192;
pub const DISPLAY_DEVICE_PRIMARY_DEVICE = 4;
pub const WINCRYPT32API = DECLSPEC_IMPORT;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN = 1;
pub const SECURITY_APP_PACKAGE_RID_COUNT = @as(c_long, 8);
pub const SUBLANG_ENGLISH_EIRE = 6;
pub const GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER = 9223372036854775808;
pub const CERT_SELECT_BY_ISSUER_DISPLAYNAME = 12;
pub const X3_EMPTY_SIZE_X = 2;
pub const KEY_EVENT = 1;
pub const IPPROTO_ICMP = 1;
pub const ERROR_CANNOT_COPY = @as(c_long, 266);
pub const SERIAL_IOC_MCR_RTS = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 2) else DWORD(2);
pub const PARAMFLAG_FOPT = 16;
pub const ERROR_INVALID_EVENTNAME = @as(c_long, 1211);
pub const ERROR_MRM_MAP_NOT_FOUND = @as(c_long, 15135);
pub const ERROR_SXS_XML_E_COMMENTSYNTAX = @as(c_long, 14031);
pub const ERROR_DS_DRA_OBJ_NC_MISMATCH = @as(c_long, 8545);
pub const MDM_SHIFT_PROTOCOLDATA = 20;
pub const SUBLANG_AZERI_CYRILLIC = 2;
pub const ERROR_DOWNGRADE_DETECTED = @as(c_long, 1265);
pub const CBN_KILLFOCUS = 4;
pub const EM_GETMODIFY = 184;
pub const MCI_ANIM_GETDEVCAPS_CAN_STRETCH = @as(c_long, 16391);
pub const XTYP_SHIFT = 4;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM = 25;
pub const EVENTLOG_AUDIT_FAILURE = 16;
pub const SHTDN_REASON_MINOR_SECURITYFIX_UNINSTALL = 24;
pub const MK_MBUTTON = 16;
pub const SHGFI_USEFILEATTRIBUTES = 16;
pub const NCRYPT_SIGNATURE_INTERFACE = BCRYPT_SIGNATURE_INTERFACE;
pub const DCX_VALIDATE = @as(c_long, 2097152);
pub const RIDI_DEVICEINFO = 536870923;
pub const ERROR_STORAGE_RESERVE_ALREADY_EXISTS = @as(c_long, 418);
pub const PRODUCT_PROFESSIONAL_STUDENT = 112;
pub const BCRYPT_HASH_REUSABLE_FLAG = 32;
pub const SCARD_PROTOCOL_T1 = 2;
pub const RESOURCEMANAGER_QUERY_INFORMATION = 1;
pub const MF_BITMAP = @as(c_long, 4);
pub const IMAGE_SCN_ALIGN_256BYTES = 9437184;
pub const PF_CHANNELS_ENABLED = 16;
pub const SP_OUTOFDISK = -4;
pub const PAN_LETTERFORM_INDEX = 7;
pub const FW_ISSUEID_UNKNOWN = 4294967295;
pub const NCRYPTBUFFER_SSL_KEY_ARG_DATA = 24;
pub const ERROR_PWD_HISTORY_CONFLICT = @as(c_long, 617);
pub const SC_MANAGER_QUERY_LOCK_STATUS = 16;
pub const InterlockedExchangeAddNoFence = _InterlockedExchangeAdd;
pub const NTM_TT_OPENTYPE = 262144;
pub const FILE_CACHE_MIN_HARD_DISABLE = 8;
pub const RPC_BUFFER_COMPLETE = 4096;
pub const THREAD_SET_THREAD_TOKEN = 128;
pub const DMRES_LOW = -2;
pub const POWER_ACTION_LIGHTEST_FIRST = 268435456;
pub const SBS_SIZEBOXBOTTOMRIGHTALIGN = @as(c_long, 4);
pub const PROPSHEETHEADER = PROPSHEETHEADERA;
pub const MIXERCONTROL_CT_SC_LIST_SINGLE = @as(c_long, 0);
pub const DNS_ERROR_DP_NOT_AVAILABLE = @as(c_long, 9905);
pub const ERROR_DS_INVALID_ATTRIBUTE_SYNTAX = @as(c_long, 8203);
pub const CMSG_KEY_TRANS_RECIPIENT = 1;
pub const THREAD_DYNAMIC_CODE_ALLOW = 1;
pub const C1_PUNCT = 16;
pub const SPI_GETFILTERKEYS = 50;
pub const szOID_MICROSOFT_PUBLISHER_SIGNER = "1.3.6.1.4.1.311.76.8.1";
pub const BS_GROUPBOX = @as(c_long, 7);
pub const WINAPI_FAMILY = WINAPI_FAMILY_DESKTOP_APP;
pub const FR_ENABLEHOOK = 256;
pub const OpenPrinter2 = OpenPrinter2A;
pub const VK_F9 = 120;
pub const WM_NCRBUTTONUP = 165;
pub const CTRY_BRUNEI_DARUSSALAM = 673;
pub const RPC_S_ASYNC_CALL_PENDING = ERROR_IO_PENDING;
pub const SE_SIGNING_LEVEL_ENTERPRISE = 2;
pub const __NO_MATH_INLINES = 1;
pub const IMAGE_REL_ARM_GPREL12 = 6;
pub const ERROR_SYMLINK_CLASS_DISABLED = @as(c_long, 1463);
pub const VP_TV_STANDARD_PAL_N = 128;
pub const RPC_S_CANT_CREATE_ENDPOINT = @as(c_long, 1720);
pub const szOID_ORGANIZATIONAL_UNIT_NAME = "2.5.4.11";
pub const __PTRDIFF_WIDTH__ = 64;
pub const DC_EXTRA = 9;
pub const CRL_REASON_AFFILIATION_CHANGED = 3;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_5 = 5;
pub const DMLERR_REENTRANCY = 16397;
pub const SHERB_NOCONFIRMATION = 1;
pub const SERVICE_START_REASON_DELAYEDAUTO = 16;
pub const REPLACEFILE_IGNORE_MERGE_ERRORS = 2;
pub const LOCALE_IDATE = 33;
pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME = @as(c_long, 14091);
pub const DLGC_UNDEFPUSHBUTTON = 32;
pub const ERROR_WMI_INVALID_MOF = @as(c_long, 4210);
pub const ERROR_VDM_HARD_ERROR = @as(c_long, 593);
pub const EWX_QUICKRESOLVE = 32;
pub const WGL_SWAP_UNDERLAY13 = 268435456;
pub const PSBTN_NEXT = 1;
pub const __FLT_DECIMAL_DIG__ = 9;
pub const TOUCH_FEEDBACK_INDIRECT = 2;
pub const MMIO_DIRTY = 268435456;
pub const CreateNamedPipe = CreateNamedPipeA;
pub const ERROR_REQUEST_ABORTED = @as(c_long, 1235);
pub const HBMMENU_SYSTEM = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(HBITMAP, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(HBITMAP, 1) else HBITMAP(1);
pub const MAP_EXPAND_LIGATURES = 8192;
pub const EMR_RESERVED_119 = 119;
pub const ERROR_CLUSTER_INVALID_INFRASTRUCTURE_FILESERVER_NAME = @as(c_long, 5998);
pub const TIME_PERIODIC = 1;
pub const WAVE_FORMAT_48S16 = 32768;
pub const ERROR_DS_DRS_EXTENSIONS_CHANGED = @as(c_long, 8594);
pub const SND_ALIAS_ID = @as(c_long, 1114112);
pub const sz_CERT_STORE_PROV_SYSTEM_REGISTRY_W = "SystemRegistry";
pub const IDC_MANAGE_LINK = 1592;
pub const ALG_TYPE_SECURECHANNEL = 6 << 9;
pub const TARGET_IS_NT40_OR_LATER = 1;
pub const szOID_QC_SSCD = "0.4.0.1862.1.4";
pub const MS_DEF_RSA_SIG_PROV = MS_DEF_RSA_SIG_PROV_A;
pub const CERT_NCRYPT_KEY_HANDLE_TRANSFER_PROP_ID = 99;
pub const __UINT_LEAST64_FMTo__ = "llo";
pub const RPC_S_ALREADY_LISTENING = @as(c_long, 1713);
pub const SET_FEATURE_IN_REGISTRY = 4;
pub const SUBLANG_SYS_DEFAULT = 2;
pub const grp3 = 1074;
pub const MIXER_OBJECTF_MIDIIN = @as(c_long, 1073741824);
pub const SERVICE_NOTIFY_STATUS_CHANGE_2 = 2;
pub const CAL_SDAYNAME7 = 13;
pub const LOGON_WITH_PROFILE = 1;
pub const rad1 = 1056;
pub const KDF_SALT = 15;
pub const BN_SETFOCUS = 6;
pub const __SIZEOF_WINT_T__ = 2;
pub const ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK = @as(c_long, 14050);
pub const __CLRCALL_OR_CDECL = __cdecl;
pub const RRF_RT_REG_QWORD = 64;
pub const RPC_C_PROTECT_LEVEL_CALL = RPC_C_AUTHN_LEVEL_CALL;
pub const TAPE_DRIVE_WRITE_SETMARKS = 2164260864;
pub const WNCON_NOTROUTED = 2;
pub const DNS_ERROR_SIGNING_KEY_NOT_ACCESSIBLE = @as(c_long, 9107);
pub const REQUEST_OPLOCK_OUTPUT_FLAG_ACK_REQUIRED = 1;
pub const _Acquires_shared_lock_ = lock;
pub const DNS_STATUS_SINGLE_PART_NAME = @as(c_long, 9559);
pub const DNS_ERROR_ALIAS_LOOP = @as(c_long, 9722);
pub const InterlockedIncrementNoFence64 = _InterlockedIncrement64;
pub const ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY = @as(c_long, 13879);
pub const SECURITY_EFFECTIVE_ONLY = 524288;
pub const VIF_ACCESSVIOLATION = @as(c_long, 512);
pub const FILE_CASE_SENSITIVE_SEARCH = 1;
pub const ERROR_CANT_CLEAR_ENCRYPTION_FLAG = @as(c_long, 432);
pub const EnumDependentServices = EnumDependentServicesA;
pub const VRL_CUSTOM_CLASS_BEGIN = 1 << 8;
pub const ExpungeConsoleCommandHistory = ExpungeConsoleCommandHistoryA;
pub const CERT_STORE_PROV_REG = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 4) else LPCSTR(4);
pub const ERROR_CHILD_MUST_BE_VOLATILE = @as(c_long, 1021);
pub const ERROR_PER_USER_TRUST_QUOTA_EXCEEDED = @as(c_long, 1932);
pub const CERT_CHAIN_DISABLE_TIMESTAMP_HASH_WEAK_FLAG = 16384;
pub const TARGET_IS_NT62_OR_LATER = 1;
pub const ERROR_INSTALL_INVALID_PACKAGE = @as(c_long, 15602);
pub const FILE_DEVICE_SCANNER = 25;
pub const KEY_CREATE_LINK = 32;
pub const MM_MAX_NUMAXES = 16;
pub const SCF_ISSECURE = 1;
pub const CBN_EDITUPDATE = 6;
pub const NI_COMPOSITIONSTR = 21;
pub const CERT_NAME_DISABLE_IE4_UTF8_FLAG = 65536;
pub const szOID_RSA_unstructAddr = "1.2.840.113549.1.9.8";
pub const MCI_WAVE_SET_ANYOUTPUT = @as(c_long, 134217728);
pub const PASCAL = __stdcall;
pub const ERROR_SYSTEM_SHUTDOWN = @as(c_long, 641);
pub const FAST_FAIL_CORRUPT_LIST_ENTRY = 3;
pub const PSM_SETTITLE = PSM_SETTITLEA;
pub const IDTRYAGAIN = 10;
pub const PRINTER_ERROR_OUTOFPAPER = 1;
pub const ENCLAVE_TYPE_SGX = 1;
pub const MEVT_F_SHORT = @as(c_long, 0);
pub const SM_PENWINDOWS = 41;
pub const BCRYPT_RSA_ALG_HANDLE = if (@typeId(@typeOf(225)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 225) else if (@typeId(@typeOf(225)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 225) else BCRYPT_ALG_HANDLE(225);
pub const SZDDESYS_ITEM_SYSITEMS = "SysItems";
pub const WM_NCACTIVATE = 134;
pub const PDCAP_D2_SUPPORTED = 4;
pub const DNS_ERROR_SCOPE_LOCKED = @as(c_long, 9962);
pub const THREAD_PRIORITY_ERROR_RETURN = MAXLONG;
pub const PRINTER_NOTIFY_CATEGORY_3D = 8192;
pub const APD_STRICT_DOWNGRADE = 2;
pub const ERROR_WMI_DP_FAILED = @as(c_long, 4209);
pub const _MSC_VER = 1921;
pub const LANG_PERSIAN = 41;
pub const AppendMenu = AppendMenuA;
pub const SERVICE_START_REASON_AUTO = 2;
pub const ERROR_SESSION_CREDENTIAL_CONFLICT = @as(c_long, 1219);
pub const C1_UPPER = 1;
pub const EXCEPTION_INT_OVERFLOW = STATUS_INTEGER_OVERFLOW;
pub const ERROR_BAD_SERVICE_ENTRYPOINT = @as(c_long, 610);
pub const IMFS_ENABLED = MFS_ENABLED;
pub const CERT_PROT_ROOT_PEER_USAGES_VALUE_NAME_A = "PeerUsages";
pub const VK_F8 = 119;
pub const ERROR_IPSEC_IKE_INVALID_POLICY = @as(c_long, 13861);
pub const NCRYPT_CLAIM_SUBJECT_ONLY = 2;
pub const SCARD_SCOPE_TERMINAL = 1;
pub const VarIntFromUI4 = VarI4FromUI4;
pub const ERROR_NOT_READ_FROM_COPY = @as(c_long, 337);
pub const szOID_DS = "2.5";
pub const PAGE_TARGETS_NO_UPDATE = 1073741824;
pub const ERROR_SXS_XML_E_INVALID_VERSION = @as(c_long, 14072);
pub const PENARBITRATIONTYPE_NONE = 0;
pub const OBJID_NATIVEOM = if (@typeId(@typeOf(4294967280)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG, 4294967280) else if (@typeId(@typeOf(4294967280)) == @import("builtin").TypeId.Int) @intToPtr(LONG, 4294967280) else LONG(4294967280);
pub const IME_CMODE_ROMAN = 16;
pub const WSAEWOULDBLOCK = @as(c_long, 10035);
pub const IP_TOS = 8;
pub const OBJID_CURSOR = if (@typeId(@typeOf(4294967287)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG, 4294967287) else if (@typeId(@typeOf(4294967287)) == @import("builtin").TypeId.Int) @intToPtr(LONG, 4294967287) else LONG(4294967287);
pub const AddMonitor = AddMonitorA;
pub const APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE = 43;
pub const MIXERCONTROL_CT_UNITS_BOOLEAN = @as(c_long, 65536);
pub const ERROR_SCREEN_ALREADY_LOCKED = @as(c_long, 1440);
pub const IMAGE_FILE_SYSTEM = 4096;
pub const MCI_WAVE_STATUS_BLOCKALIGN = @as(c_long, 16389);
pub const INADDR_LOOPBACK = 2130706433;
pub const ANTIALIASED_QUALITY = 4;
pub const WGL_SWAP_UNDERLAY12 = 134217728;
pub const WN_BAD_HANDLE = ERROR_INVALID_HANDLE;
pub const DrawState = DrawStateA;
pub const PROCESS_LEAP_SECOND_INFO_FLAG_ENABLE_SIXTY_SECOND = 1;
pub const FACILITY_GRAPHICS = 38;
pub const CP_WINUNICODE = 1200;
pub const SUBLANG_SERBIAN_CROATIA = 1;
pub const SE_GROUP_INTEGRITY = @as(c_long, 32);
pub const InterlockedXor64Acquire = _InterlockedXor64;
pub const UPDFCACHE_ONSTOPCACHE = 4;
pub const SUBLANG_SWEDISH = 1;
pub const AUDIT_ALLOW_NO_PRIVILEGE = 1;
pub const ERROR_FLOAT_MULTIPLE_TRAPS = @as(c_long, 631);
pub const GMEM_DISCARDABLE = 256;
pub const ERROR_INVALID_PATCH_XML = @as(c_long, 1650);
pub const WPF_SETMINPOSITION = 1;
pub const LB_SETCARETINDEX = 414;
pub const IID_NULL = GUID_NULL;
pub const CAL_SDAYNAME4 = 10;
pub const CERT_ARCHIVED_PROP_ID = 19;
pub const STGM_DIRECT_SWMR = @as(c_long, 4194304);
pub const rad2 = 1057;
pub const ENUM_ALL_CALENDARS = 4294967295;
pub const ERROR_NO_SHUTDOWN_IN_PROGRESS = @as(c_long, 1116);
pub const MOD_ON_KEYUP = 2048;
pub const MM_DRVM_ERROR = 979;
pub const PF_ECMA = AF_ECMA;
pub const MIXERCONTROL_CT_CLASS_TIME = @as(c_long, 1610612736);
pub const SERVICE_STOP = 32;
pub const PRODUCT_THINPC = 87;
pub const MCI_VD_STATUS_SIDE = @as(c_long, 16389);
pub const CRYPT_STRING_BASE64_ANY = 6;
pub const MCI_ANIM_GETDEVCAPS_FAST_RATE = @as(c_long, 16386);
pub const CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG = 1;
pub const CTRY_FAEROE_ISLANDS = 298;
pub const IDHELP = 9;
pub const URL_OID_CERTIFICATE_CRL_DIST_POINT_AND_OCSP = if (@typeId(@typeOf(11)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 11) else if (@typeId(@typeOf(11)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 11) else LPCSTR(11);
pub const ERROR_REGISTRY_HIVE_RECOVERED = @as(c_long, 685);
pub const SEARCH_ALL = 0;
pub const SW_PARENTCLOSING = 1;
pub const MCI_NOTIFY_SUCCESSFUL = 1;
pub const CBF_FAIL_ADVISES = 16384;
pub const VK_PRINT = 42;
pub const ROT_COMPARE_MAX = 2048;
pub const REPLACE_PRIMARY = 10;
pub const NCBADDGRNAME = 54;
pub const EPROTOTYPE = 136;
pub const ERROR_NO_BROWSER_SERVERS_FOUND = @as(c_long, 6118);
pub const IMR_COMPOSITIONWINDOW = 1;
pub const R2_MERGEPENNOT = 14;
pub const TAPE_ABSOLUTE_BLOCK = @as(c_long, 1);
pub const FILE_DEVICE_MT_COMPOSITE = 66;
pub const SHTDN_REASON_FLAG_USER_DEFINED = 1073741824;
pub const LOCALE_IPOSSYMPRECEDES = 84;
pub const __PCLMUL__ = 1;
pub const _Analysis_assume_section_locked_ = name;
pub const CRYPT_IMPL_REMOVABLE = 8;
pub const VOLUME_NAME_DOS = 0;
pub const PD_ALLPAGES = 0;
pub const PERF_DELTA_BASE = 8388608;
pub const ERROR_PRINTER_DELETED = @as(c_long, 1905);
pub const FILE_DEVICE_DFS_VOLUME = 54;
pub const SCARD_READER_TYPE_SCSI = 8;
pub const ERROR_INVALID_DOMAIN_STATE = @as(c_long, 1353);
pub const X509_QC_STATEMENTS_EXT = if (@typeId(@typeOf(42)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 42) else if (@typeId(@typeOf(42)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 42) else LPCSTR(42);
pub const GetFullPathName = GetFullPathNameA;
pub const LOCALE_SISO639LANGNAME = 89;
pub const ERROR_QUORUMLOG_OPEN_FAILED = @as(c_long, 5028);
pub const CONSOLE_APPLICATION_16BIT = 0;
pub const WINPATHCCHAPI = WINBASEAPI;
pub const __in_bcount_nz = size;
pub const PS_USERSTYLE = 7;
pub const MUI_CONSOLE_FILTER = 256;
pub const IMAGE_FILE_MACHINE_R4000 = 358;
pub const SPI_SETFONTSMOOTHINGORIENTATION = 8211;
pub const CF_DIB = 8;
pub const PROCESS_VM_WRITE = 32;
pub const PROCESS_DEP_ENABLE = 1;
pub const SE_GROUP_USE_FOR_DENY_ONLY = @as(c_long, 16);
pub const ERROR_BAD_TOKEN_TYPE = @as(c_long, 1349);
pub const PRODUCT_STANDARD_WS_SERVER_CORE = 148;
pub const CRYPT_ACQUIRE_SILENT_FLAG = 64;
pub const PP_SECURE_SIGNATURE_PIN = 48;
pub const SECURITY_CHILD_PACKAGE_RID_COUNT = @as(c_long, 12);
pub const CRYPT_STRING_HEXASCIIADDR = 11;
pub const GetFileAttributesEx = GetFileAttributesExA;
pub const SHGSI_ICON = SHGFI_ICON;
pub const POWER_PLATFORM_ROLE_VERSION_MAX = POWER_PLATFORM_ROLE_V2_MAX;
pub const RESTART_NO_HANG = 2;
pub const SHGSI_SELECTED = SHGFI_SELECTED;
pub const ERROR_DS_GCVERIFY_ERROR = @as(c_long, 8417);
pub const LOCALE_SNEGATIVESIGN = 81;
pub const SUBLANG_TSWANA_SOUTH_AFRICA = 1;
pub const szOID_OIWSEC_sha1RSASign = "1.3.14.3.2.29";
pub const RPC_C_QOS_CAPABILITIES_SCHANNEL_FULL_AUTH_IDENTITY = 32;
pub const BitTestAndReset = _bittestandreset;
pub const CALLBACK_THREAD = CALLBACK_TASK;
pub const szOID_ECC_CURVE_SECP521R1 = szOID_ECC_CURVE_P521;
pub const ERROR_PRINTQ_FULL = @as(c_long, 61);
pub const CS_DELETE_TRANSFORM = @as(c_long, 3);
pub const CRYPT_OID_DECODE_OBJECT_FUNC = "CryptDllDecodeObject";
pub const CBN_CLOSEUP = 8;
pub const SUBLANG_SAMI_LULE_SWEDEN = 5;
pub const WM_SIZE = 5;
pub const PRODUCT_CLOUDEN = 186;
pub const CRYPT_AIA_RETRIEVAL = 524288;
pub const DOF_EXECUTABLE = 32769;
pub const CERT_NAME_ATTR_TYPE = 3;
pub const WIM_BOOT_OS_WIM = 1;
pub const SHTDN_REASON_MINOR_DISK = 7;
pub const SPI_SETFONTSMOOTHING = 75;
pub const FILE_USER_DISALLOWED = 7;
pub const POSTSCRIPT_IDENTIFY = 4117;
pub const WM_CTLCOLORDLG = 310;
pub const IMAGE_SEPARATE_DEBUG_SIGNATURE = 18756;
pub const MMIO_FINDLIST = 64;
pub const ERROR_DS_SCHEMA_UPDATE_DISALLOWED = @as(c_long, 8509);
pub const ReadConsoleOutput = ReadConsoleOutputA;
pub const META_MOVETO = 532;
pub const CDS_UPDATEREGISTRY = 1;
pub const FW_ULTRABOLD = FW_EXTRABOLD;
pub const FILE_TYPE_CHAR = 2;
pub const URLACTION_ALLOW_ACTIVEX_FILTERING = 9986;
pub const DFCS_ADJUSTRECT = 8192;
pub const SCardListReadersWithDeviceInstanceId = SCardListReadersWithDeviceInstanceIdA;
pub const __FLT_HAS_DENORM__ = 1;
pub const RPC_C_AUTHN_LEVEL_PKT_INTEGRITY = 5;
pub const CRYPT_NOT_MODIFIED_RETRIEVAL = 4194304;
pub const ERROR_PNP_QUERY_REMOVE_UNRELATED_DEVICE_TIMEOUT = @as(c_long, 482);
pub const CDN_INCLUDEITEM = if (@typeId(@typeOf(-7)) == @import("builtin").TypeId.Pointer) @ptrCast(CDN_FIRST, -7) else if (@typeId(@typeOf(-7)) == @import("builtin").TypeId.Int) @intToPtr(CDN_FIRST, -7) else CDN_FIRST(-7);
pub const MCI_OVLY_WHERE_DESTINATION = @as(c_long, 262144);
pub const SPI_SETMENUDROPALIGNMENT = 28;
pub const PRODUCT_AZURE_NANO_SERVER = 169;
pub const STATUS_SINGLE_STEP = if (@typeId(@typeOf(@as(c_long, 2147483652))) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, @as(c_long, 2147483652)) else if (@typeId(@typeOf(@as(c_long, 2147483652))) == @import("builtin").TypeId.Int) @intToPtr(DWORD, @as(c_long, 2147483652)) else DWORD(@as(c_long, 2147483652));
pub const BDR_RAISEDOUTER = 1;
pub const SetClassLong = SetClassLongA;
pub const WNNC_NET_SERNET = 1900544;
pub const POLICY_AUDIT_SUBCATEGORY_COUNT = 59;
pub const ERROR_NO_USER_SESSION_KEY = @as(c_long, 1394);
pub const CERT_SYSTEM_STORE_USERS_ID = 6;
pub const FILE_DEVICE_NETWORK_BROWSER = 19;
pub const CERT_NAME_ISSUER_FLAG = 1;
pub const MIXERCONTROL_CT_CLASS_NUMBER = @as(c_long, 805306368);
pub const RotateRight64 = _rotr64;
pub const LPD_STEREO = 2;
pub const URLACTION_FEATURE_BLOCK_INPUT_PROMPTS = 8453;
pub const SORT_KOREAN_UNICODE = 1;
pub const DAX_ALLOC_ALIGNMENT_FLAG_MANDATORY = 1;
pub const VP_FLAGS_COPYPROTECT = 256;
pub const CONNECT_CRED_RESET = 8192;
pub const _OUT_TO_DEFAULT = 0;
pub const CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES = 5;
pub const LANG_UKRAINIAN = 34;
pub const ERROR_PROTOCOL_UNREACHABLE = @as(c_long, 1233);
pub const CMSG_KEY_TRANS_ENCRYPT_FREE_OBJID_FLAG = 2;
pub const SERVICE_STOP_REASON_MINOR_SERVICEPACK_UNINSTALL = 19;
pub const ERROR_IPSEC_DOSP_BLOCK = @as(c_long, 13925);
pub const CAL_SDAYNAME5 = 11;
pub const ARW_BOTTOMRIGHT = @as(c_long, 1);
pub const DEFINE_ENUM_FLAG_OPERATORS = ENUMTYPE;
pub const IMAGE_REL_MIPS_REFHALF = 1;
pub const DMPAPER_P32K_ROTATED = 107;
pub const rad3 = 1058;
pub const CTRY_EL_SALVADOR = 503;
pub const szOID_GIVEN_NAME = "2.5.4.42";
pub const cbNDRContext = 20;
pub const ERROR_SYSTEM_POWERSTATE_TRANSITION = @as(c_long, 782);
pub const SSWF_CUSTOM = 4;
pub const QUERY_ACTCTX_FLAG_NO_ADDREF = 2147483648;
pub const VarIntFromBool = VarI4FromBool;
pub const TIMESTAMP_FAILURE_TIME_NOT_AVAILABLE = 14;
pub const IMAGE_SCN_MEM_EXECUTE = 536870912;
pub const CERT_RDN_VISIBLE_STRING = 9;
pub const IDI_WARNING = IDI_EXCLAMATION;
pub const ST_ISSELF = 256;
pub const _OUT_TO_MSGBOX = 2;
pub const HC_ACTION = 0;
pub const InterlockedOr64Acquire = _InterlockedOr64;
pub const SPI_GETMOUSEHOVERTIME = 102;
pub const NCRYPT_MAX_ALG_ID_LENGTH = 512;
pub const ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED = @as(c_long, 6832);
pub const LANG_HEBREW = 13;
pub const szOID_KP_TIME_STAMP_SIGNING = "1.3.6.1.4.1.311.10.3.2";
pub const SELECT_CAP_SENTENCE = 2;
pub const small = char;
pub const ERROR_PRINTER_HAS_JOBS_QUEUED = @as(c_long, 3009);
pub const STM_SETIMAGE = 370;
pub const CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_ALG_FLAG = 4;
pub const ERROR_DS_CANT_ADD_SYSTEM_ONLY = @as(c_long, 8358);
pub const CRL_REASON_AFFILIATION_CHANGED_FLAG = 16;
pub const SHGetDiskFreeSpaceEx = SHGetDiskFreeSpaceExA;
pub const MCI_SAVE_FILE = @as(c_long, 256);
pub const KP_PIN_INFO = 44;
pub const VK_SLEEP = 95;
pub const szOID_INFOSEC_SuiteAIntegrity = "2.16.840.1.101.2.1.1.15";
pub const ERROR_TRANSACTIONMANAGER_NOT_FOUND = @as(c_long, 6718);
pub const PW_RENDERFULLCONTENT = 2;
pub const PDC_ORIENTATION_90 = 8;
pub const MIDIPROP_TEMPO = @as(c_long, 2);
pub const ERROR_INSTALL_DEREGISTRATION_FAILURE = @as(c_long, 15607);
pub const ERROR_DS_NAME_TOO_MANY_PARTS = @as(c_long, 8347);
pub const POINTER_FLAG_UP = 262144;
pub const Uri_HAS_PASSWORD = 1 << Uri_PROPERTY_PASSWORD;
pub const __inexpressible_writableTo = size;
pub const ERROR_BAD_MCFG_TABLE = @as(c_long, 791);
pub const PDERR_PRINTERNOTFOUND = 4107;
pub const UNICODE_STRING_MAX_BYTES = if (@typeId(@typeOf(65534)) == @import("builtin").TypeId.Pointer) @ptrCast(WORD, 65534) else if (@typeId(@typeOf(65534)) == @import("builtin").TypeId.Int) @intToPtr(WORD, 65534) else WORD(65534);
pub const SHUTDOWN_POWEROFF = 8;
pub const FILE_REGION_USAGE_VALID_NONCACHED_DATA = 2;
pub const TXFS_TRANSACTION_STATE_PREPARED = 2;
pub const ERROR_PORT_NOT_SET = @as(c_long, 642);
pub const IMAGE_NT_OPTIONAL_HDR_MAGIC = IMAGE_NT_OPTIONAL_HDR64_MAGIC;
pub const WM_SYSKEYUP = 261;
pub const WM_NEXTDLGCTL = 40;
pub const TIMER_MODIFY_STATE = 2;
pub const EMARCH_ENC_I17_IC_INST_WORD_POS_X = 12;
pub const IPPORT_DISCARD = 9;
pub const __LDBL_MAX__ = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878;
pub const CTRY_DOMINICAN_REPUBLIC = 1;
pub const HEAP_FREE_CHECKING_ENABLED = 64;
pub const ERROR_FILEMARK_DETECTED = @as(c_long, 1101);
pub const szOID_EV_RDN_LOCALE = "1.3.6.1.4.1.311.60.2.1.1";
pub const RPC_C_AUTHN_MSONLINE = 82;
pub const META_SETPIXEL = 1055;
pub const PRINTER_ENUM_NETWORK = 64;
pub const LANG_HAWAIIAN = 117;
pub const ERROR_UNKNOWN_REVISION = @as(c_long, 1305);
pub const SUBLANG_NEUTRAL = 0;
pub const PSBTN_BACK = 0;
pub const NCRYPT_PCP_STORAGE_KEY = 4;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_POLICY = @as(c_long, 15617);
pub const BELOW_NORMAL_PRIORITY_CLASS = 16384;
pub const MSG_PARTIAL = 32768;
pub const CERT_TRUST_HAS_ALLOW_WEAK_SIGNATURE = 131072;
pub const RPC_SECURITY_QOS_V2 = RPC_SECURITY_QOS_V2_A;
pub const IDNO = 7;
pub const CERT_CLR_DELETE_KEY_PROP_ID = 125;
pub const MCI_SEQ_SET_SLAVE = @as(c_long, 262144);
pub const DeletePrinterDriverEx = DeletePrinterDriverExA;
pub const SERVICE_START_REASON_RESTART_ON_FAILURE = 8;
pub const QS_PAINT = 32;
pub const FORMATDLGORD31 = 1543;
pub const CRYPT_KDF_OID_GROUP_ID = 10;
pub const szOID_CMC_IDENTIFICATION = "1.3.6.1.5.5.7.7.2";
pub const FILE_INITIATE_REPAIR_HINT1_INVALID_RUN_LENGTH = 131072;
pub const RemoveDirectory = RemoveDirectoryA;
pub const IsLFNDrive = IsLFNDriveA;
pub const JOB_OBJECT_LIMIT_ACTIVE_PROCESS = 8;
pub const WAVE_FORMAT_48S08 = 8192;
pub const GetFileVersionInfo = GetFileVersionInfoA;
pub const GDICOMMENT_WINDOWS_METAFILE = 2147483649;
pub const InterlockedCompareExchangeAcquire = _InterlockedCompareExchange;
pub const STARTF_UNTRUSTEDSOURCE = 32768;
pub const JOB_OBJECT_MSG_NEW_PROCESS = 6;
pub const CBN_SELENDOK = 9;
pub const ERROR_INTERMIXED_KERNEL_EA_OPERATION = @as(c_long, 324);
pub const WINPERF_LOG_VERBOSE = 3;
pub const SEEK_SET = 0;
pub const InterlockedXor8 = _InterlockedXor8;
pub const OFN_EX_NOPLACESBAR = 1;
pub const SHGSI_SHELLICONSIZE = SHGFI_SHELLICONSIZE;
pub const SORTED_CTL_EXT_HASHED_SUBJECT_IDENTIFIER_FLAG = 1;
pub const ERROR_IPSEC_IKE_SECLOADFAIL = @as(c_long, 13852);
pub const SERVICE_SYSTEM_START = 1;
pub const X3_IMM20_SIZE_X = 20;
pub const SDC_TOPOLOGY_EXTERNAL = 8;
pub const __FLT_MIN__ = 0.000000;
pub const OF_SHARE_DENY_NONE = 64;
pub const CRYPT_OID_INFO_PUBKEY_SIGN_KEY_FLAG = 2147483648;
pub const DNS_ERROR_ZONE_LOCKED_FOR_SIGNING = @as(c_long, 9622);
pub const MDM_V120_SPEED_64K = 1;
pub const TME_QUERY = 1073741824;
pub const szOID_NETSCAPE_COMMENT = "2.16.840.1.113730.1.13";
pub const SPI_SCREENSAVERRUNNING = SPI_SETSCREENSAVERRUNNING;
pub const NRC_NAMERR = 23;
pub const SHGFI_SMALLICON = 1;
pub const PEERDIST_ERROR_TRUST_FAILURE = @as(c_long, 4066);
pub const ERROR_DS_DUP_OID = @as(c_long, 8379);
pub const CERT_LAST_USER_PROP_ID = 65535;
pub const PF_COMPARE_EXCHANGE_DOUBLE = 2;
pub const NRC_CMDTMO = 5;
pub const SEE_MASK_NOCLOSEPROCESS = 64;
pub const CERT_TRUST_CTL_IS_NOT_TIME_VALID = 131072;
pub const MDM_MASK_PROTOCOLDATA = 267386880;
pub const rad4 = 1059;
pub const IMAGE_SYM_CLASS_STATIC = 3;
pub const WOM_CLOSE = MM_WOM_CLOSE;
pub const FILE_DEVICE_CRYPT_PROVIDER = 63;
pub const ERROR_LOG_INVALID_RANGE = @as(c_long, 6604);
pub const PSN_GETOBJECT = if (@typeId(@typeOf(-10)) == @import("builtin").TypeId.Pointer) @ptrCast(PSN_FIRST, -10) else if (@typeId(@typeOf(-10)) == @import("builtin").TypeId.Int) @intToPtr(PSN_FIRST, -10) else PSN_FIRST(-10);
pub const MKF_REPLACENUMBERS = 128;
pub const JOB_OBJECT_LIMIT_IO_RATE_CONTROL = 524288;
pub const SUBLANG_QUECHUA_BOLIVIA = 1;
pub const FACILITY_NT_BIT = 268435456;
pub const SERIAL_IOC_FCR_RCVR_RESET = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 2) else DWORD(2);
pub const STGM_PRIORITY = @as(c_long, 262144);
pub const SOCK_RDM = 4;
pub const EXTEND_IEPORT = 2;
pub const PS_TYPE_MASK = 983040;
pub const SUBLANG_SINDHI_AFGHANISTAN = 2;
pub const VER_SERVICEPACKMAJOR = 32;
pub const COLOR_3DDKSHADOW = 21;
pub const DISK_BINNING = 3;
pub const PP_KEYSET_TYPE = 27;
pub const MAX_JOYSTICKOEMVXDNAME = 260;
pub const POINTER_MESSAGE_FLAG_SECONDBUTTON = 32;
pub const SCARD_READER_TYPE_UICC = 512;
pub const CERT_STORE_PROV_WRITE_CTL_FUNC = 10;
pub const PSINJECT_BEGINDEFAULTS = 12;
pub const WN_DEVICE_IN_USE = ERROR_DEVICE_IN_USE;
pub const UNICODE_NULL = if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(WCHAR, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(WCHAR, 0) else WCHAR(0);
pub const CRYPT_IMPORT_KEY = 128;
pub const RPC_CONTEXT_HANDLE_DONT_SERIALIZE = @as(c_ulong, 536870912);
pub const ERROR_BAD_EXE_FORMAT = @as(c_long, 193);
pub const SPI_GETSPEECHRECOGNITION = 4170;
pub const ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR = @as(c_long, 5946);
pub const GetCharacterPlacement = GetCharacterPlacementA;
pub const SUBLANG_TATAR_RUSSIA = 1;
pub const REPORT_NO_PRIVATE_KEY = 1;
pub const KDF_ALGORITHMID = 8;
pub const ERROR_IPSEC_QM_POLICY_PENDING_DELETION = @as(c_long, 13023);
pub const CERT_STORE_CTRL_NOTIFY_CHANGE = 2;
pub const RpcNsMgmtEntryInqIfIds = RpcNsMgmtEntryInqIfIdsA;
pub const SBM_SETSCROLLINFO = 233;
pub const ERROR_SYSTEM_NEEDS_REMEDIATION = @as(c_long, 15623);
pub const FS_VIETNAMESE = @as(c_long, 256);
pub const ERROR_DS_CANT_DEL_MASTER_CROSSREF = @as(c_long, 8375);
pub const SKF_RWINLOCKED = 8388608;
pub const InterlockedBitTestAndSet64 = _interlockedbittestandset64;
pub const MFT_BITMAP = MF_BITMAP;
pub const CERT_VERIFY_REV_SERVER_OCSP_FLAG = 8;
pub const IOInetPriority = IInternetPriority;
pub const CMC_RESPONSE = if (@typeId(@typeOf(60)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 60) else if (@typeId(@typeOf(60)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 60) else LPCSTR(60);
pub const wsprintf = wsprintfA;
pub const ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED = @as(c_long, 5079);
pub const DNS_ERROR_NAME_NOT_IN_ZONE = @as(c_long, 9706);
pub const PORT_STATUS_WARMING_UP = 11;
pub const EVENT_OBJECT_VALUECHANGE = 32782;
pub const ERROR_LOG_TAIL_INVALID = @as(c_long, 6627);
pub const SPI_SETSCREENSAVERRUNNING = 97;
pub const METHOD_DIRECT_FROM_HARDWARE = METHOD_OUT_DIRECT;
pub const VarUintFromBool = VarUI4FromBool;
pub const IMN_SETCONVERSIONMODE = 6;
pub const QueryServiceConfig = QueryServiceConfigA;
pub const ICM_QUERY = 3;
pub const VarI8FromUint = VarI8FromUI4;
pub const szOID_RFC3161_counterSign = "1.3.6.1.4.1.311.3.3.1";
pub const CERT_STORE_PROV_SYSTEM_A = if (@typeId(@typeOf(9)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 9) else if (@typeId(@typeOf(9)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 9) else LPCSTR(9);
pub const RPC_S_MAX_CALLS_TOO_SMALL = @as(c_long, 1742);
pub const DT_RASDISPLAY = 1;
pub const DDE_FNOTPROCESSED = 0;
pub const ERROR_WAKE_SYSTEM = @as(c_long, 730);
pub const CLIENTSITE_S_LAST = @as(c_long, 262559);
pub const LC_WIDESTYLED = 64;
pub const POINTER_FLAG_FOURTHBUTTON = 128;
pub const RESOURCE_ENUM_LN = 1;
pub const RPC_SECURITY_QOS_V3 = RPC_SECURITY_QOS_V3_A;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SIG = @as(c_long, 13838);
pub const BCRYPT_DSA_PUBLIC_MAGIC = 1112560452;
pub const VTA_CENTER = TA_CENTER;
pub const USN_DELETE_FLAG_NOTIFY = 2;
pub const VP_TV_STANDARD_PAL_B = 4;
pub const MCI_DEVTYPE_DIGITAL_VIDEO = 520;
pub const FORMATDLGORD30 = 1544;
pub const PKCS_ATTRIBUTE = if (@typeId(@typeOf(22)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 22) else if (@typeId(@typeOf(22)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 22) else LPCSTR(22);
pub const DEVICE_DSM_FLAG_ALLOCATION_CONSOLIDATEABLE_ONLY = 1073741824;
pub const CM_SERVICE_USB_DISK_BOOT_LOAD = 4;
pub const DC_BUTTONS = 4096;
pub const MCI_OPEN_TYPE = @as(c_long, 8192);
pub const DNS_ERROR_NO_PACKET = @as(c_long, 9503);
pub const URL_OID_CTL_NEXT_UPDATE = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 4) else LPCSTR(4);
pub const LANG_BULGARIAN = 2;
pub const FNERR_INVALIDFILENAME = 12290;
pub const VOS_UNKNOWN = @as(c_long, 0);
pub const NCRYPT_PAD_OAEP_FLAG = 4;
pub const ERROR_BAD_RECOVERY_POLICY = @as(c_long, 6012);
pub const PORT_STATUS_DOOR_OPEN = 7;
pub const WNNC_NET_AS400 = 720896;
pub const IMAGE_REL_ARM64_PAGEBASE_REL21 = 4;
pub const IMAGE_SCN_ALIGN_512BYTES = 10485760;
pub const EVENT_SYSTEM_MINIMIZEEND = 23;
pub const _Pre_ = _Pre_impl_;
pub const IMAGE_SUBSYSTEM_OS2_CUI = 5;
pub const SW_MAXIMIZE = 3;
pub const NCRYPT_IMPL_SOFTWARE_FLAG = 2;
pub const RPCFLG_WINRT_REMOTE_ASYNC = @as(c_ulong, 32);
pub const SUBLANG_TAJIK_TAJIKISTAN = 1;
pub const PROCESS_CREATION_MITIGATION_POLICY_FORCE_RELOCATE_IMAGES_ALWAYS_ON_REQ_RELOCS = 3 << 8;
pub const SMTO_BLOCK = 1;
pub const FACILITY_STATE_MANAGEMENT = 34;
pub const CRYPT_NEWKEYSET = 8;
pub const SYMBOLIC_LINK_FLAG_DIRECTORY = 1;
pub const SERVICE_STOP_REASON_MINOR_OTHER = 1;
pub const THREAD_IMPERSONATE = 256;
pub const CF_USESTYLE = @as(c_long, 128);
pub const EVENT_OBJECT_SELECTION = 32774;
pub const MARK_HANDLE_NOT_READ_COPY = 256;
pub const CS_GLOBALCLASS = 16384;
pub const DNS_ERROR_ROLLOVER_IN_PROGRESS = @as(c_long, 9116);
pub const __INT_LEAST8_MAX__ = 127;
pub const ERROR_DS_CLIENT_LOOP = @as(c_long, 8259);
pub const CERT_SYSTEM_STORE_DEFER_READ_FLAG = 536870912;
pub const SPI_GETPENDOCKTHRESHOLD = 128;
pub const ImmSetCompositionFont = ImmSetCompositionFontA;
pub const rad5 = 1060;
pub const EnumServicesStatusEx = EnumServicesStatusExA;
pub const SPECIFIC_RIGHTS_ALL = @as(c_long, 65535);
pub const DEVICE_DSM_FLAG_REPAIR_OUTPUT_PARITY_EXTENT = 536870912;
pub const FILE_SUPPORTS_POSIX_UNLINK_RENAME = 1024;
pub const szOID_PKIX = "1.3.6.1.5.5.7";
pub const SIF_PAGE = 2;
pub const SUBLANG_ENGLISH_AUS = 3;
pub const RPC_C_PROTECT_LEVEL_PKT = RPC_C_AUTHN_LEVEL_PKT;
pub const EMR_POLYDRAW = 56;
pub const RPC_X_INVALID_BUFFER = ERROR_INVALID_USER_BUFFER;
pub const CRYPT_PRIORITY_BOTTOM = 4294967295;
pub const DESKTOP_CREATEWINDOW = @as(c_long, 2);
pub const _WIN32_IE_IE30 = 768;
pub const WM_DEADCHAR = 259;
pub const CTRY_BAHRAIN = 973;
pub const IO_REPARSE_TAG_WCI_1 = @as(c_long, 2415923224);
pub const EMARCH_ENC_I17_IC_VAL_POS_X = 21;
pub const SECURITY_PACKAGE_NTLM_RID = @as(c_long, 10);
pub const PSINJECT_BEGINPROLOG = 14;
pub const CERT_RDN_ANY_TYPE = 0;
pub const sz_CERT_STORE_PROV_SERIALIZED = "Serialized";
pub const ERROR_XML_PARSE_ERROR = @as(c_long, 1465);
pub const CERT_RDN_ENABLE_T61_UNICODE_FLAG = 2147483648;
pub const Uri_HAS_HOST_TYPE = 1 << Uri_PROPERTY_HOST_TYPE;
pub const PSINJECT_PAGES = 4;
pub const szOID_SGC_NETSCAPE = "2.16.840.1.113730.4.1";
pub const DISPID_EVALUATE = -5;
pub const FACILITY_ACCELERATOR = 1536;
pub const ERROR_CANT_EVICT_ACTIVE_NODE = @as(c_long, 5009);
pub const NCRYPT_PERSIST_ONLY_FLAG = 1073741824;
pub const SM_IMMENABLED = 82;
pub const CURSOR_SUPPRESSED = 2;
pub const XST_NULL = 0;
pub const RIDI_DEVICENAME = 536870919;
pub const StoreFence = _mm_sfence;
pub const GCP_CLASSIN = @as(c_long, 524288);
pub const SORTED_CTL_EXT_MAX_COLLISION_OFFSET = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast([*c]2, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr([*c]2, 4) else ([*c]2)(4);
pub const ERROR_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH = @as(c_long, 366);
pub const IME_ESC_PRIVATE_LAST = 4095;
pub const PROCESS_CREATION_MITIGATION_POLICY2_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY_RESERVED = if (@typeId(@typeOf(i64 << 20)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 20) else if (@typeId(@typeOf(i64 << 20)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 20) else @as(c_uint, 3)(i64 << 20);
pub const HC_SYSMODALON = 4;
pub const NCRYPT_ALLOW_KEY_IMPORT_FLAG = 8;
pub const MK_CONTROL = 8;
pub const SUBLANG_SPANISH_URUGUAY = 14;
pub const NCRYPT_ALLOW_ARCHIVING_FLAG = 4;
pub const CERT_KEY_CONTEXT_PROP_ID = 5;
pub const ERROR_DS_CANT_ON_RDN = @as(c_long, 8214);
pub const SET_TAPE_DRIVE_INFORMATION = 1;
pub const EN_SETFOCUS = 256;
pub const ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE = @as(c_long, 15023);
pub const ERROR_MEDIA_NOT_AVAILABLE = @as(c_long, 4318);
pub const __deref_out_bcount_nz_opt = size;
pub const EMR_POLYLINE = 4;
pub const X3_IMM39_2_SIZE_X = 16;
pub const TIMEOUT_ASYNC = 4294967295;
pub const TAPE_DRIVE_FILEMARKS = 2147745792;
pub const PENVISUALIZATION_TAP = 1;
pub const _WIN32_IE_WS03SP1 = _WIN32_IE_IE60SP2;
pub const LANG_ARMENIAN = 43;
pub const CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT = 1073741824;
pub const PAN_BENT_ARMS_HORZ = 7;
pub const _WIN32_IE_IE80 = 2048;
pub const FS_CHINESESIMP = @as(c_long, 262144);
pub const CERT_TRUST_REVOCATION_STATUS_UNKNOWN = 64;
pub const CERT_CHAIN_STRONG_SIGN_DISABLE_END_CHECK_FLAG = 1;
pub const CRYPT_OFFLINE_CHECK_RETRIEVAL = 16384;
pub const IME_SMODE_AUTOMATIC = 4;
pub const DT_PATH_ELLIPSIS = 16384;
pub const RESOURCETYPE_DISK = 1;
pub const STORAGE_CRYPTO_DESCRIPTOR_VERSION_1 = 1;
pub const SCM_PD_FIRMWARE_REVISION_LENGTH_BYTES = 32;
pub const ERROR_IOPL_NOT_ENABLED = @as(c_long, 197);
pub const ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING = @as(c_long, 13901);
pub const WH_CBT = 5;
pub const RPC_SECURITY_QOS_V4 = RPC_SECURITY_QOS_V4_A;
pub const QUERY_DEPENDENT_VOLUME_REQUEST_FLAG_GUEST_VOLUMES = 2;
pub const STORAGE_DEVICE_FLAGS_RANDOM_DEVICEGUID_REASON_NOHWID = 2;
pub const ERROR_SRC_SRV_DLL_LOAD_FAILED = @as(c_long, 428);
pub const ERROR_DS_DRA_OUT_SCHEDULE_WINDOW = @as(c_long, 8617);
pub const VarIntFromUI8 = VarI4FromUI8;
pub const WNNC_NET_LANMAN = WNNC_NET_SMB;
pub const DNS_ERROR_INVALID_INITIAL_ROLLOVER_OFFSET = @as(c_long, 9115);
pub const szOID_ECC_CURVE_BRAINPOOLP384T1 = "1.3.36.3.3.2.8.1.1.12";
pub const TOUCHPREDICTIONPARAMETERS_DEFAULT_RLS_LAMBDA_MAX = 0.999000;
pub const ERROR_SERVICE_DOES_NOT_EXIST = @as(c_long, 1060);
pub const DLGWINDOWEXTRA = 30;
pub const PAN_STROKE_RAPID_HORZ = 7;
pub const WT_EXECUTEINTIMERTHREAD = 32;
pub const IMAGE_REL_SHM_PCRELPT = 19;
pub const DOWNLOADHEADER = 4111;
pub const EMBDHLP_INPROC_HANDLER = @as(c_long, 0);
pub const IMAGE_REL_PPC_SECRELHI = 20;
pub const IMAGE_REL_AMD64_SSPAN32 = 16;
pub const ERROR_PNP_INVALID_ID = @as(c_long, 674);
pub const szOID_ECC_PUBLIC_KEY = "1.2.840.10045.2.1";
pub const ERROR_QUORUM_DISK_NOT_FOUND = @as(c_long, 5086);
pub const lstrcmpi = lstrcmpiA;
pub const IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = 32768;
pub const PSN_WIZNEXT = if (@typeId(@typeOf(-7)) == @import("builtin").TypeId.Pointer) @ptrCast(PSN_FIRST, -7) else if (@typeId(@typeOf(-7)) == @import("builtin").TypeId.Int) @intToPtr(PSN_FIRST, -7) else PSN_FIRST(-7);
pub const ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND = @as(c_long, 15033);
pub const CRYPT_STRING_ENCODEMASK = 255;
pub const PSTMSG = PostMessage;
pub const SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP = 4;
pub const ERROR_CTX_WINSTATIONS_DISABLED = @as(c_long, 7060);
pub const ERROR_DS_DRA_SCHEMA_INFO_SHIP = @as(c_long, 8542);
pub const LOCALE_IDEFAULTMACCODEPAGE = 4113;
pub const SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN = 4;
pub const ABM_GETAUTOHIDEBAR = 7;
pub const KP_PIN_ID = 43;
pub const GETSCALINGFACTOR = 14;
pub const EXCEPTION_PRIV_INSTRUCTION = STATUS_PRIVILEGED_INSTRUCTION;
pub const NCRYPT_PCP_HMACVERIFICATION_KEY = 16;
pub const IMEVER_0400 = 262144;
pub const CMC_FAIL_BAD_TIME = 3;
pub const IMAGE_SYM_TYPE_VOID = 1;
pub const SUBLANG_ENGLISH_CAN = 4;
pub const BN_UNPUSHED = BN_UNHILITE;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS_V = 35;
pub const NCRYPT_SECRET_AGREEMENT_INTERFACE = BCRYPT_SECRET_AGREEMENT_INTERFACE;
pub const ERROR_SHARING_PAUSED = @as(c_long, 70);
pub const ATF_ONOFFFEEDBACK = 2;
pub const MDM_V110_SPEED_2DOT4K = 2;
pub const PERFSTATE_POLICY_CHANGE_DECREASE_MAX = PERFSTATE_POLICY_CHANGE_ROCKET;
pub const MDM_V110_SPEED_19DOT2K = 7;
pub const WM_DPICHANGED_BEFOREPARENT = 738;
pub const WM_SETCURSOR = 32;
pub const FILE_INITIATE_REPAIR_HINT1_PARENT_FILE_RECORD_NOT_EXIST = 67108864;
pub const IME_PROP_UNICODE = 524288;
pub const LoadMenuIndirect = LoadMenuIndirectA;
pub const SOUND_SYSTEM_SHUTDOWN = 2;
pub const SPI_GETMOUSESONAR = 4124;
pub const __RPCSAL_H_VERSION__ = 100;
pub const rad6 = 1061;
pub const CERT_UNICODE_IS_RDN_ATTRS_FLAG = 1;
pub const RIM_INPUT = 0;
pub const ICM_SETDEFAULTPROFILE = 4;
pub const MIM_BACKGROUND = 2;
pub const ERROR_DRIVER_DATABASE_ERROR = @as(c_long, 652);
pub const WS_EX_COMPOSITED = @as(c_long, 33554432);
pub const CMSG_SIGNED_DATA_V1 = 1;
pub const SS_ELLIPSISMASK = @as(c_long, 49152);
pub const REG_PROCESS_PRIVATE = @as(c_long, 32);
pub const szOID_QC_EU_COMPLIANCE = "0.4.0.1862.1.1";
pub const VK_BROWSER_BACK = 166;
pub const ERROR_QUOTA_LIST_INCONSISTENT = @as(c_long, 621);
pub const CALINFO_ENUMPROC = CALINFO_ENUMPROCA;
pub const FACILITY_DEPLOYMENT_SERVICES_MULTICAST_SERVER = 289;
pub const SERVICE_CONTROL_NETBINDREMOVE = 8;
pub const CERT_SYSTEM_STORE_LOCAL_MACHINE_ENTERPRISE_ID = 9;
pub const C2_RIGHTTOLEFT = 2;
pub const IME_KHOTKEY_HANJACONVERT = 81;
pub const IMAGE_REL_AM_TOKEN = 9;
pub const PRINTER_NOTIFY_FIELD_TOTAL_BYTES = 24;
pub const CPS_CONVERT = 2;
pub const DNS_ERROR_RCODE_NXRRSET = @as(c_long, 9008);
pub const PIDSI_APPNAME = @as(c_long, 18);
pub const _MM_HINT_NTA = 0;
pub const TXFS_START_RM_FLAG_LOG_AUTO_SHRINK_PERCENTAGE = 32;
pub const SECURITY_PRINCIPAL_SELF_RID = @as(c_long, 10);
pub const RPC_X_BAD_STUB_DATA = @as(c_long, 1783);
pub const SE_SIGNING_LEVEL_STORE = 6;
pub const ERROR_DS_UNKNOWN_ERROR = @as(c_long, 8431);
pub const CMSG_CTRL_VERIFY_SIGNATURE = 1;
pub const SHTDN_REASON_FLAG_PLANNED = 2147483648;
pub const WAVE_FORMAT_2M08 = 16;
pub const C2_COMMONSEPARATOR = 7;
pub const ERROR_SIGNAL_REFUSED = @as(c_long, 156);
pub const ERROR_IPSEC_IKE_INVALID_HEADER = @as(c_long, 13824);
pub const FILE_INITIATE_REPAIR_HINT1_LCN_NOT_EXIST = 65536;
pub const IDLE_PRIORITY_CLASS = 64;
pub const POWER_CONNECTIVITY_IN_STANDBY_SYSTEM_MANAGED = 2;
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK = 4026531840;
pub const CERT_TRUST_IS_CYCLIC = 128;
pub const ILLUMINANT_C = 3;
pub const RPC_MGR_EPV = void;
pub const PST_PARALLELPORT = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 2) else DWORD(2);
pub const C3_LEXICAL = 1024;
pub const ERROR_RESOURCE_NAME_NOT_FOUND = @as(c_long, 1814);
pub const CBF_SKIP_REGISTRATIONS = 524288;
pub const SetClassLongPtr = SetClassLongPtrA;
pub const FAST_FAIL_GS_COOKIE_INIT = 6;
pub const METAFILE_DRIVER = 2049;
pub const ERROR_STATE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED = @as(c_long, 15816);
pub const STATE_SYSTEM_SELECTABLE = 2097152;
pub const MMIO_DELETE = 512;
pub const SPI_GETMOUSESIDEMOVETHRESHOLD = 136;
pub const CF_DIF = 5;
pub const MCI_INFO_MEDIA_IDENTITY = @as(c_long, 2048);
pub const ERROR_BAD_VALIDATION_CLASS = @as(c_long, 1348);
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE = 2;
pub const SERVICE_QUERY_STATUS = 4;
pub const PEERDIST_ERROR_NOT_LICENSED = @as(c_long, 4064);
pub const WinHelp = WinHelpA;
pub const DMBIN_LARGECAPACITY = 11;
pub const LoadString = LoadStringA;
pub const SHTDN_REASON_MINOR_INSTALLATION = 2;
pub const szOID_SEARCH_GUIDE = "2.5.4.14";
pub const ERROR_INVALID_CLEANER = @as(c_long, 4310);
pub const LBS_MULTICOLUMN = @as(c_long, 512);
pub const CONSOLE_REAL_OUTPUT_HANDLE = if (@typeId(@typeOf(-2)) == @import("builtin").TypeId.Pointer) @ptrCast(LongToHandle, -2) else if (@typeId(@typeOf(-2)) == @import("builtin").TypeId.Int) @intToPtr(LongToHandle, -2) else LongToHandle(-2);
pub const DMMEDIA_TRANSPARENCY = 2;
pub const RESOURCEMANAGER_ENLIST = 8;
pub const PRODUCT_EMBEDDED_EVAL = 107;
pub const ERROR_DS_CANT_MOVE_APP_BASIC_GROUP = @as(c_long, 8608);
pub const COLOR_CAPTIONTEXT = 9;
pub const CERT_SUBJECT_PUB_KEY_BIT_LENGTH_PROP_ID = 92;
pub const CERT_CHAIN_FIND_BY_ISSUER_NO_KEY_FLAG = 16384;
pub const EXCEPTION_FLT_UNDERFLOW = STATUS_FLOAT_UNDERFLOW;
pub const LANG_CROATIAN = 26;
pub const CRL_FIND_ISSUED_BY_DELTA_FLAG = 4;
pub const DISPLAY_DEVICE_ATTACHED = 2;
pub const SUBLANG_QUECHUA_ECUADOR = 2;
pub const DISABLE_MAX_PRIVILEGE = 1;
pub const IP_TTL = 7;
pub const URLACTION_DOWNLOAD_CURR_MAX = 4100;
pub const GUI_INMOVESIZE = 2;
pub const SERIAL_IOC_FCR_RES2 = if (@typeId(@typeOf(32)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 32) else if (@typeId(@typeOf(32)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 32) else DWORD(32);
pub const RPC_SECURITY_QOS_V5 = RPC_SECURITY_QOS_V5_A;
pub const ERROR_EVALUATION_EXPIRATION = @as(c_long, 622);
pub const PPM_FIRMWARE_PCCP = 32768;
pub const DM_COLLATE = @as(c_long, 32768);
pub const REG_DWORD_LITTLE_ENDIAN = @as(c_ulong, 4);
pub const ERROR_WAS_UNLOCKED = @as(c_long, 715);
pub const CTRY_DEFAULT = 0;
pub const ERROR_PACKAGE_ALREADY_EXISTS = @as(c_long, 15611);
pub const VP_TV_STANDARD_PAL_D = 8;
pub const EM_SETRECTNP = 180;
pub const szOID_INFOSEC_mosaicKMandUpdSig = "2.16.840.1.101.2.1.1.20";
pub const ENCRYPTED_DATA_INFO_SPARSE_FILE = 1;
pub const ERROR_INVALID_VERIFY_SWITCH = @as(c_long, 118);
pub const IPPORT_ROUTESERVER = 520;
pub const PROCESS_CREATION_MITIGATION_POLICY_FONT_DISABLE_MASK = if (@typeId(@typeOf(i64 << 48)) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 3), i64 << 48) else if (@typeId(@typeOf(i64 << 48)) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 3), i64 << 48) else @as(c_uint, 3)(i64 << 48);
pub const BS_HATCHED = 2;
pub const IMAGE_SUBSYSTEM_WINDOWS_GUI = 2;
pub const __UINT8_FMTx__ = "hhx";
pub const ERROR_RPL_NOT_ALLOWED = @as(c_long, 4006);
pub const InterlockedXor64Release = _InterlockedXor64;
pub const szOID_REQUIRE_CERT_CHAIN_POLICY = "1.3.6.1.4.1.311.21.15";
pub const WNNC_NET_PATHWORKS = 851968;
pub const FS_CASE_IS_PRESERVED = FILE_CASE_PRESERVED_NAMES;
pub const WM_GETMINMAXINFO = 36;
pub const SORT_CHINESE_PRC = 2;
pub const SHGetUnreadMailCount = SHGetUnreadMailCountA;
pub const EnumFonts = EnumFontsA;
pub const FILE_RETURNS_CLEANUP_RESULT_INFO = 512;
pub const FLS_OUT_OF_INDEXES = if (@typeId(@typeOf(4294967295)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 4294967295) else if (@typeId(@typeOf(4294967295)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 4294967295) else DWORD(4294967295);
pub const DSPRINT_UNPUBLISH = 4;
pub const QUERY_FILE_LAYOUT_SINGLE_INSTANCED = 1;
pub const RegisterClipboardFormat = RegisterClipboardFormatA;
pub const DNS_ERROR_ZONE_DOES_NOT_EXIST = @as(c_long, 9601);
pub const DOMAIN_ALIAS_RID_IUSERS = @as(c_long, 568);
pub const MF_POPUP = @as(c_long, 16);
pub const CMSG_CTRL_KEY_AGREE_DECRYPT = 17;
pub const SB_PREMULT_ALPHA = 4;
pub const MF_SEPARATOR = @as(c_long, 2048);
pub const VER_GREATER_EQUAL = 3;
pub const URLACTION_AUTOMATIC_DOWNLOAD_UI = 8704;
pub const LPOCNCONNPROC = LPOCNCONNPROCA;
pub const WM_DDE_INITIATE = WM_DDE_FIRST;
pub const MB_ICONERROR = MB_ICONHAND;
pub const IMAGE_REL_PPC_IFGLUE = 13;
pub const MCI_RESUME = 2133;
pub const ERROR_MEDIA_CHANGED = @as(c_long, 1110);
pub const ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT = @as(c_long, 14075);
pub const ERROR_NOT_REGISTRY_FILE = @as(c_long, 1017);
pub const SO_SNDTIMEO = 4101;
pub const WSAEINVAL = @as(c_long, 10022);
pub const ERROR_ACCESS_DISABLED_BY_POLICY = @as(c_long, 1260);
pub const rad7 = 1062;
pub const FIXED_PITCH = 1;
pub const ERROR_DS_NCNAME_MUST_BE_NC = @as(c_long, 8357);
pub const PRINTER_DRIVER_XPS = 2;
pub const URLACTION_BEHAVIOR_MIN = 8192;
pub const RegCreateKeyTransacted = RegCreateKeyTransactedA;
pub const ERROR_SYSTEM_TRACE = @as(c_long, 150);
pub const szOID_ATTR_TPM_SPECIFICATION = "2.23.133.2.16";
pub const LANG_AZERBAIJANI = 44;
pub const LOCALE_ICENTURY = 36;
pub const USN_DELETE_FLAG_DELETE = 1;
pub const CREATE_EVENT_MANUAL_RESET = 1;
pub const GL_ID_PRIVATE_FIRST = 32768;
pub const TRANSACTIONMANAGER_QUERY_INFORMATION = 1;
pub const SPI_SETDEFAULTINPUTLANG = 90;
pub const META_SELECTCLIPREGION = 300;
pub const PRINTER_NOTIFY_INFO_DISCARDED = 1;
pub const VOLUME_NAME_NONE = 4;
pub const PROTECTION_LEVEL_SAME = 4294967295;
pub const BCRYPT_ENABLE_INCOMPATIBLE_FIPS_CHECKS = 256;
pub const STREAM_LAYOUT_ENTRY_HAS_INFORMATION = 16;
pub const MARK_HANDLE_DISABLE_FILE_METADATA_OPTIMIZATION = 4096;
pub const EVENT_CONSOLE_UPDATE_REGION = 16386;
pub const WSAEACCES = @as(c_long, 10013);
pub const ERROR_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR = @as(c_long, 5990);
pub const DISABLE_NEWLINE_AUTO_RETURN = 8;
pub const RPC_SYSTEM_HANDLE_FREE_ALL = 3;
pub const __FXSR__ = 1;
pub const SEE_MASK_NOQUERYCLASSSTORE = 16777216;
pub const MCI_SEQ_SET_PORT = @as(c_long, 131072);
pub const PAN_STRAIGHT_ARMS_VERT = 4;
pub const VARIANT_NOVALUEPROP = 1;
pub const ILLUMINANT_B = 2;
pub const PROCESS_CREATION_MITIGATION_POLICY_HEAP_TERMINATE_ALWAYS_ON = 1 << 12;
pub const SCardSetReaderCapabilities = SCardSetAttrib;
pub const MKF_AVAILABLE = 2;
pub const USER_MARSHAL_FC_FLOAT = 10;
pub const OPENFILENAME_SIZE_VERSION_400 = OPENFILENAME_SIZE_VERSION_400A;
pub const PARTITION_PRE_INSTALLED = 42;
pub const JOY_CAL_READ3 = @as(c_long, 262144);
pub const CERT_HASH_PROP_ID = CERT_SHA1_HASH_PROP_ID;
pub const GMEM_NOTIFY = 16384;
pub const ERROR_NO_MORE_DEVICES = @as(c_long, 1248);
pub const QUOTA_LIMITS_HARDWS_MIN_DISABLE = 2;
pub const SM_CYDOUBLECLK = 37;
pub const CRYPT_ENCRYPT = 1;
pub const ERROR_PACKAGE_UPDATING = @as(c_long, 15616);
pub const URLPOLICY_CHANNEL_SOFTDIST_AUTOINSTALL = 196608;
pub const URLACTION_SHELL_RTF_OBJECTS_LOAD = 6154;
pub const CRYPT_OAEP = 64;
pub const SID_SInternetSecurityManagerEx2 = IID_IInternetSecurityManagerEx2;
pub const ENUMPAPERMETRICS = 34;
pub const ERROR_TRAY_MALFUNCTION = 16;
pub const SZDDESYS_TOPIC = "System";
pub const stc30 = 1117;
pub const ERROR_CAPAUTHZ_NOT_AUTHORIZED = @as(c_long, 453);
pub const ERROR_FAIL_REBOOT_INITIATED = @as(c_long, 3018);
pub const EMR_POLYGON = 3;
pub const IME_CHOTKEY_IME_NONIME_TOGGLE = 16;
pub const LANG_SAMI = 59;
pub const DefFrameProc = DefFrameProcA;
pub const LCMAP_SORTKEY = 1024;
pub const InterlockedCompareExchangeNoFence16 = _InterlockedCompareExchange16;
pub const CRYPT_STRING_HEX_ANY = 8;
pub const SHUTDOWN_FORCE_SELF = 2;
pub const StartServiceCtrlDispatcher = StartServiceCtrlDispatcherA;
pub const ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION = @as(c_long, 8533);
pub const VK_BROWSER_REFRESH = 168;
pub const SUBLANG_ARABIC_MOROCCO = 6;
pub const PRINTER_NOTIFY_FIELD_SEPFILE = 8;
pub const PAN_BENT_ARMS_SINGLE_SERIF = 10;
pub const CF_OEMTEXT = 7;
pub const RPC_C_MGMT_INQ_PRINC_NAME = 1;
pub const ImmGetCompositionString = ImmGetCompositionStringA;
pub const ERROR_CLUSTER_SINGLETON_RESOURCE = @as(c_long, 5940);
pub const VP_TV_STANDARD_PAL_G = 131072;
pub const CERT_NAME_STR_DISABLE_UTF8_DIR_STR_FLAG = 1048576;
pub const WSAEHOSTUNREACH = @as(c_long, 10065);
pub const HGDI_ERROR = if (@typeId(@typeOf(@as(c_long, 4294967295))) == @import("builtin").TypeId.Pointer) @ptrCast(LongToHandle, @as(c_long, 4294967295)) else if (@typeId(@typeOf(@as(c_long, 4294967295))) == @import("builtin").TypeId.Int) @intToPtr(LongToHandle, @as(c_long, 4294967295)) else LongToHandle(@as(c_long, 4294967295));
pub const WMSZ_BOTTOMLEFT = 7;
pub const EXPO_OFFLOAD_FUNC_NAME = "OffloadModExpo";
pub const TAPE_INITIATOR_PARTITIONS = @as(c_long, 2);
pub const ERROR_DS_NONEXISTENT_MUST_HAVE = @as(c_long, 8388);
pub const LBN_DBLCLK = 2;
pub const ERROR_SXS_XML_E_UNEXPECTED_STANDALONE = @as(c_long, 14071);
pub const RPC_X_INVALID_PIPE_OBJECT = @as(c_long, 1830);
pub const BACKUP_DATA = 1;
pub const STARTDOC = 10;
pub const PAN_STROKE_INSTANT_VERT = 8;
pub const LOCALE_INEGCURR = 28;
pub const ST_INLIST = 64;
pub const ERROR_TRANSACTIONMANAGER_NOT_ONLINE = @as(c_long, 6719);
pub const NCRYPT_IGNORE_DEVICE_STATE_FLAG = 4096;
pub const CERT_COMPARE_PUBKEY_MD5_HASH = 18;
pub const ODS_SELECTED = 1;
pub const SDC_ALLOW_PATH_ORDER_CHANGES = 8192;
pub const HTVSCROLL = 7;
pub const SM_CMONITORS = 80;
pub const SPI_GETDOCKMOVING = 144;
pub const szOID_OIWSEC_rsaXchg = "1.3.14.3.2.22";
pub const CMSG_OID_IMPORT_MAIL_LIST_FUNC = "CryptMsgDllImportMailList";
pub const OBJ_ENHMETAFILE = 13;
pub const X3_I_INST_WORD_POS_X = 27;
pub const __INT_LEAST32_FMTd__ = "d";
pub const __postcond = expr;
pub const HCBT_MINMAX = 1;
pub const SPI_SETFLATMENU = 4131;
pub const SHTDN_REASON_MINOR_WMI = 21;
pub const MK_ALT = 32;
pub const CRYPT_OID_CREATE_COM_OBJECT_FUNC = "CryptDllCreateCOMObject";
pub const PIDSI_PAGECOUNT = @as(c_long, 14);
pub const CERT_STORE_PROV_CLOSE_FUNC = 0;
pub const HCCE_CURRENT_USER = if (@typeId(@typeOf(NULL)) == @import("builtin").TypeId.Pointer) @ptrCast(HCERTCHAINENGINE, NULL) else if (@typeId(@typeOf(NULL)) == @import("builtin").TypeId.Int) @intToPtr(HCERTCHAINENGINE, NULL) else HCERTCHAINENGINE(NULL);
pub const CREATE_MUTEX_INITIAL_OWNER = 1;
pub const PD_ENABLEPRINTHOOK = 4096;
pub const X509_DSS_PARAMETERS = if (@typeId(@typeOf(39)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 39) else if (@typeId(@typeOf(39)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 39) else LPCSTR(39);
pub const CMSG_SIGNED_DATA_V3 = 3;
pub const EMARCH_ENC_I17_IMM9D_SIZE_X = 9;
pub const ERROR_DS_NAME_ERROR_NOT_FOUND = @as(c_long, 8470);
pub const URLACTION_ALLOW_CROSSDOMAIN_DROP_ACROSS_WINDOWS = 9993;
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER = 23;
pub const URLACTION_INFODELIVERY_NO_ADDING_SUBSCRIPTIONS = 7427;
pub const MF_END = @as(c_long, 128);
pub const SPI_SETPENWINDOWS = 49;
pub const ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED = @as(c_long, 5081);
pub const RESOURCEMANAGER_GET_NOTIFICATION = 16;
pub const GL_ID_CANNOTSAVE = 17;
pub const ERROR_RUNLEVEL_SWITCH_IN_PROGRESS = @as(c_long, 15404);
pub const BSM_APPLICATIONS = 8;
pub const FILE_ATTRIBUTE_ENCRYPTED = 16384;
pub const RPC_C_PROFILE_ALL_ELT = 1;
pub const CB_SELECTSTRING = 333;
pub const SPI_GETFOREGROUNDLOCKTIMEOUT = 8192;
pub const R2_NOTMERGEPEN = 2;
pub const S_ALLTHRESHOLD = 2;
pub const __FLT16_HAS_QUIET_NAN__ = 1;
pub const SM_CXMINSPACING = 47;
pub const ERROR_FAIL_I24 = @as(c_long, 83);
pub const FACILITY_RAS = 83;
pub const PROFILE_USER = 268435456;
pub const MS_DEF_RSA_SCHANNEL_PROV = MS_DEF_RSA_SCHANNEL_PROV_A;
pub const FAPPCOMMAND_MASK = 61440;
pub const BSF_LUID = 1024;
pub const PRODUCT_STARTER = 11;
pub const ATTR_INPUT_ERROR = 4;
pub const ERROR_CAPAUTHZ_SCCD_NO_CAPABILITY_MATCH = @as(c_long, 460);
pub const ERROR_TRANSACTION_SUPERIOR_EXISTS = @as(c_long, 6709);
pub const IMAGE_SYM_TYPE_LONG = 5;
pub const ALG_SID_SEAL = 2;
pub const ILLUMINANT_A = 1;
pub const FACILITY_SOS = 160;
pub const CRL_REASON_UNSPECIFIED = 0;
pub const ERROR_NON_MDICHILD_WINDOW = @as(c_long, 1445);
pub const szOID_KEY_USAGE = "2.5.29.15";
pub const TC_DEVICEDUMP_SUBSECTION_DESC_LENGTH = 16;
pub const NIIF_ICON_MASK = 15;
pub const ERROR_NODE_CANNOT_BE_CLUSTERED = @as(c_long, 5898);
pub const WM_KEYUP = 257;
pub const CERT_TRUST_SSL_TIME_VALID_OCSP = 524288;
pub const OFN_SHAREAWARE = 16384;
pub const stc31 = 1118;
pub const PSN_WIZFINISH = if (@typeId(@typeOf(-8)) == @import("builtin").TypeId.Pointer) @ptrCast(PSN_FIRST, -8) else if (@typeId(@typeOf(-8)) == @import("builtin").TypeId.Int) @intToPtr(PSN_FIRST, -8) else PSN_FIRST(-8);
pub const ERROR_IPSEC_DOSP_MAX_ENTRIES = @as(c_long, 13929);
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE = 2;
pub const APPCOMMAND_PRINT = 33;
pub const X3_P_INST_WORD_POS_X = 0;
pub const PKCS_TIME_REQUEST = if (@typeId(@typeOf(18)) == @import("builtin").TypeId.Pointer) @ptrCast(LPCSTR, 18) else if (@typeId(@typeOf(18)) == @import("builtin").TypeId.Int) @intToPtr(LPCSTR, 18) else LPCSTR(18);
pub const rct2 = 1081;
pub const SANDBOX_INERT = 2;
pub const ERROR_DS_DUP_LINK_ID = @as(c_long, 8468);
pub const EINTR = 4;
pub const VFT2_FONT_VECTOR = @as(c_long, 2);
pub const CRYPT_OID_INFO_OID_KEY = 1;
pub const PP_SYM_KEYSIZE = 19;
pub const TPM_TOPALIGN = @as(c_long, 0);
pub const MEVT_TEMPO = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(BYTE, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(BYTE, 1) else BYTE(1);
pub const CRYPT_SILENT = 64;
pub const ERROR_RESOURCE_NOT_FOUND = @as(c_long, 5007);
pub const ERROR_CLUSTER_SHARED_VOLUME_NOT_REDIRECTED = @as(c_long, 5967);
pub const POWER_LEVEL_USER_NOTIFY_TEXT = 1;
pub const ROTREGFLAGS_ALLOWANYCLIENT = 1;
pub const ERROR_CTX_MODEM_RESPONSE_VOICE = @as(c_long, 7016);
pub const JOB_OBJECT_UILIMIT_GLOBALATOMS = 32;
pub const BAUD_600 = if (@typeId(@typeOf(32)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 32) else if (@typeId(@typeOf(32)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 32) else DWORD(32);
pub const ERROR_DS_CANT_DEREF_ALIAS = @as(c_long, 8337);
pub const ERROR_DS_CANT_ADD_TO_GC = @as(c_long, 8550);
pub const WH_MINHOOK = WH_MIN;
pub const VTBIT_UI8 = 1 << VT_UI8;
pub const ERROR_UNABLE_TO_CLEAN = @as(c_long, 4311);
pub const PROCESSOR_PERF_MAXIMUM_ACTIVITY_WINDOW = 1270000000;
pub const FAST_FAIL_INVALID_LOCK_STATE = 36;
pub const WSA_QOS_EPOLICYOBJ = @as(c_long, 11025);
pub const EFS_METADATA_REMOVE_USER = 2;
pub const CreateColorSpace = CreateColorSpaceA;
pub const MS_ENH_RSA_AES_PROV_A = "Microsoft Enhanced RSA and AES Cryptographic Provider";
pub const TAPE_DRIVE_ERASE_IMMEDIATE = 128;
pub const TAPE_DRIVE_TAPE_CAPACITY = 256;
pub const IMAGE_GUARD_RETPOLINE_PRESENT = 1048576;
pub const CRYPT_ONLINE = 128;
pub const FAST_FAIL_INVALID_EXCEPTION_CHAIN = 21;
pub const PSWIZB_DISABLEDFINISH = 8;
pub const WNNC_NET_CSC = 2490368;
pub const CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG = 4;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_FAMILY_ID = 3;
pub const ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED = @as(c_long, 13928);
pub const DlgDirSelectEx = DlgDirSelectExA;
pub const ERROR_DS_DOMAIN_VERSION_TOO_HIGH = @as(c_long, 8564);
pub const MIXER_GETCONTROLDETAILSF_VALUE = @as(c_long, 0);
pub const SS_OWNERDRAW = @as(c_long, 13);
pub const CB_GETTOPINDEX = 347;
pub const ERROR_CANT_OPEN_ANONYMOUS = @as(c_long, 1347);
pub const PERF_TIMER_100NS = 1048576;
pub const URLACTION_FEATURE_DATA_BINDING = 8454;
pub const ENETRESET = 117;
pub const DEVICEDUMP_CAP_PRIVATE_SECTION = 1;
pub const VER_SUITENAME = 64;
pub const PSN_LAST = if (@typeId(@typeOf(-@as(c_uint, 299))) == @import("builtin").TypeId.Pointer) @ptrCast(@as(c_uint, 0), -@as(c_uint, 299)) else if (@typeId(@typeOf(-@as(c_uint, 299))) == @import("builtin").TypeId.Int) @intToPtr(@as(c_uint, 0), -@as(c_uint, 299)) else @as(c_uint, 0)(-@as(c_uint, 299));
pub const CERT_SUBJECT_DISABLE_CRL_PROP_ID = 86;
pub const APPIDREGFLAGS_AAA_NO_IMPLICIT_ACTIVATE_AS_IU = 2048;
pub const PM_QS_SENDMESSAGE = QS_SENDMESSAGE << 16;
pub const SMART_CYL_LOW = 79;
pub const CRYPT_DEFAULT_CONTEXT_AUTO_RELEASE_FLAG = 1;
pub const __callback = __inner_callback;
pub const RESOURCEDISPLAYTYPE_DIRECTORY = 9;
pub const MKF_RIGHTBUTTONSEL = 536870912;
pub const JOY_BUTTON15 = @as(c_long, 16384);
pub const QID_SYNC = 4294967295;
pub const DLGC_RADIOBUTTON = 64;
pub const FIND_RESOURCE_DIRECTORY_LANGUAGES = 1024;
pub const FS_JISJAPAN = @as(c_long, 131072);
pub const SM_SYSTEMDOCKED = 8196;
pub const szOID_OIWSEC_shaDSA = "1.3.14.3.2.13";
pub const EVENT_OBJECT_SELECTIONREMOVE = 32776;
pub const RTL_RUN_ONCE_CTX_RESERVED_BITS = 2;
pub const CTRY_MONGOLIA = 976;
pub const PEERDIST_ERROR_INVALID_CONFIGURATION = @as(c_long, 4063);
pub const PHYSICALOFFSETY = 113;
pub const SUBLANG_UKRAINIAN_UKRAINE = 1;
pub const CRYPT_X942_KEY_LENGTH_BYTE_LENGTH = 4;
pub const CW_USEDEFAULT = if (@typeId(@typeOf(2147483648)) == @import("builtin").TypeId.Pointer) @ptrCast(int, 2147483648) else if (@typeId(@typeOf(2147483648)) == @import("builtin").TypeId.Int) @intToPtr(int, 2147483648) else int(2147483648);
pub const X509_ANY_STRING = X509_NAME_VALUE;
pub const DISPLAY_DEVICE_MIRRORING_DRIVER = 8;
pub const IME_CMODE_HANGUL = IME_CMODE_NATIVE;
pub const WM_WININICHANGE = 26;
pub const szOID_ECC_CURVE_X962P239V1 = "1.2.840.10045.3.1.4";
pub const FILE_SYSTEM_NOT_SUPPORT = 6;
pub const MSGF_MAX = 8;
pub const MIM_LONGERROR = MM_MIM_LONGERROR;
pub const szOID_RDN_TCG_PLATFORM_MODEL = "2.23.133.2.5";
pub const DEVICE_DSM_RANGE_ERROR_INFO_VERSION_V1 = DEVICE_DSM_RANGE_ERROR_OUTPUT_V1;
pub const IMAGE_SYM_CLASS_MEMBER_OF_UNION = 11;
pub const FACILITY_DEPLOYMENT_SERVICES_DRIVER_PROVISIONING = 278;
pub const IMAGE_REL_ARM_ADDR32NB = 2;
pub const ERROR_LOST_MODE_LOGON_RESTRICTION = @as(c_long, 1939);
pub const JOB_OBJECT_LIMIT_PRIORITY_CLASS = 32;
pub const ERROR_DS_ATTRIBUTE_OWNED_BY_SAM = @as(c_long, 8346);
pub const ERROR_CANTSCROLLBACKWARDS = @as(c_long, 771);
pub const TKF_TOGGLEKEYSON = 1;
pub const PrintDlgEx = PrintDlgExA;
pub const WSAEPROTOTYPE = @as(c_long, 10041);
pub const SB_CTL = 2;
pub const EN_CHANGE = 768;
pub const SCardListReaderGroups = SCardListReaderGroupsA;
pub const SS_TYPEMASK = @as(c_long, 31);
pub const SPI_SETCARETBROWSING = 4173;
pub const LANG_PULAR = 103;
pub const __INT16_TYPE__ = short;
pub const CD_LBSELADD = 2;
pub const stc32 = 1119;
pub const SEE_MASK_CLASSNAME = 1;
pub const CERT_DIGITAL_SIGNATURE_KEY_USAGE = 128;
pub const CRYPT_VERIFY_CERT_SIGN_CHECK_WEAK_HASH_FLAG = 8;
pub const SB_BOTH = 3;
pub const IPPORT_SYSTAT = 11;
pub const MDM_PROTOCOLID_PIAFS = 9;
pub const GCPCLASS_PREBOUNDRTL = 64;
pub const SLE_ERROR = 1;
pub const FIND_ENDSWITH = 2097152;
pub const VK_RBUTTON = 2;
pub const LCMAP_TRADITIONAL_CHINESE = 67108864;
pub const JOB_NOTIFY_FIELD_DRIVER_NAME = 8;
pub const ERROR_PAGEFILE_QUOTA = @as(c_long, 1454);
pub const ERROR_NO_SUPPORTING_DRIVES = @as(c_long, 4339);
pub const ERROR_SYMLINK_NOT_SUPPORTED = @as(c_long, 1464);
pub const MINLONG64 = if (@typeId(@typeOf(~MAXLONG64)) == @import("builtin").TypeId.Pointer) @ptrCast(LONG64, ~MAXLONG64) else if (@typeId(@typeOf(~MAXLONG64)) == @import("builtin").TypeId.Int) @intToPtr(LONG64, ~MAXLONG64) else LONG64(~MAXLONG64);
pub const rct3 = 1082;
pub const MCI_STATUS_MODE = @as(c_long, 4);
pub const SHTDN_REASON_FLAG_CLEAN_UI = 67108864;
pub const NEWFILEOPENORD = 1547;
pub const VK_ICO_CLEAR = 230;
pub const COMPRESSION_ENGINE_STANDARD = 0;
pub const FR_SHOWHELP = 128;
pub const SERIAL_IOC_FCR_RES1 = if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 16) else if (@typeId(@typeOf(16)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 16) else DWORD(16);
pub const IME_HOTKEY_DSWITCH_FIRST = 256;
pub const MOUSEEVENTF_LEFTDOWN = 2;
pub const ERROR_POLICY_OBJECT_NOT_FOUND = @as(c_long, 8219);
pub const PF_XMMI64_INSTRUCTIONS_AVAILABLE = 10;
pub const GetKeyNameText = GetKeyNameTextA;
pub const PRIVATE_NAMESPACE_FLAG_DESTROY = 1;
pub const InterlockedDecrementRelease16 = _InterlockedDecrement16;
pub const SCardWriteCache = SCardWriteCacheA;
pub const LOCALE_SMONTHNAME2 = 57;
pub const IMAGE_DEBUG_TYPE_OMAP_FROM_SRC = 8;
pub const WM_POINTERROUTEDAWAY = 594;
pub const WM_POINTERROUTEDTO = 593;
pub const szOID_RENEWAL_CERTIFICATE = "1.3.6.1.4.1.311.13.1";
pub const CLRDTR = 6;
pub const BCRYPT_DES_CFB_ALG_HANDLE = if (@typeId(@typeOf(529)) == @import("builtin").TypeId.Pointer) @ptrCast(BCRYPT_ALG_HANDLE, 529) else if (@typeId(@typeOf(529)) == @import("builtin").TypeId.Int) @intToPtr(BCRYPT_ALG_HANDLE, 529) else BCRYPT_ALG_HANDLE(529);
pub const PSINJECT_DLFONT = 3722304989;
pub const EPT_S_CANT_PERFORM_OP = @as(c_long, 1752);
pub const ERROR_LOG_BLOCK_INCOMPLETE = @as(c_long, 6603);
pub const HELP_COMMAND = @as(c_long, 258);
pub const ERROR_EVT_MESSAGE_NOT_FOUND = @as(c_long, 15027);
pub const ERROR_SXS_XML_E_UNCLOSEDSTRING = @as(c_long, 14062);
pub const CERT_SCEP_RA_ENCRYPTION_CERT_PROP_ID = 110;
pub const WTS_SESSION_LOGON = 5;
pub const BACKUP_ALTERNATE_DATA = 4;
pub const SERVICE_CHANGE_CONFIG = 2;
pub const EM_CANUNDO = 198;
pub const OFN_SHARENOWARN = 1;
pub const ERROR_IPSEC_IKE_DECRYPT = @as(c_long, 13867);
pub const SCARD_STATE_UNAVAILABLE = 8;
pub const InterlockedBitTestAndSet = _interlockedbittestandset;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NATOA = @as(c_long, 13893);
pub const TELEMETRY_COMMAND_SIZE = 16;
pub const FACILITY_DIRECTMUSIC = 2168;
pub const MCI_SAVE = 2067;
pub const LookupAccountSidLocal = LookupAccountSidLocalA;
pub const ENDDOC = 11;
pub const EM_GETSEL = 176;
pub const GetModuleHandleEx = GetModuleHandleExA;
pub const NUMPRS_TRAILING_MINUS = 32;
pub const PROCESS_TERMINATE = 1;
pub const DCOMSCM_PING_DISALLOW_UNSECURE_CALL = 32;
pub const GMEM_NOCOMPACT = 16;
pub const RPC_S_UUID_NO_ADDRESS = @as(c_long, 1739);
pub const ERROR_STATE_CONTAINER_NAME_SIZE_LIMIT_EXCEEDED = @as(c_long, 15818);
pub const DNS_ERROR_RCODE_YXDOMAIN = @as(c_long, 9006);
pub const LOOKUP_STREAM_FROM_CLUSTER_ENTRY_FLAG_PAGE_FILE = 1;
pub const GA_ROOTOWNER = 3;
pub const PAN_STRAIGHT_ARMS_SINGLE_SERIF = 5;
pub const ERROR_NOT_SUPPORTED_WITH_BTT = @as(c_long, 429);
pub const CHANGER_POSITION_TO_ELEMENT = 1024;
pub const RESOURCE_GLOBALNET = 2;
pub const ERROR_SEM_OWNER_DIED = @as(c_long, 105);
pub const EVENT_SYSTEM_CONTEXTHELPSTART = 12;
pub const WHDR_BEGINLOOP = 4;
pub const PRINTER_CHANGE_DELETE_PRINTER_DRIVER = 1073741824;
pub const AF_UNKNOWN1 = 20;
pub const ERROR_STORAGE_TOPOLOGY_ID_MISMATCH = @as(c_long, 345);
pub const __UINTPTR_FMTo__ = "llo";
pub const szOID_INFOSEC_sdnsSignature = "2.16.840.1.101.2.1.1.1";
pub const WritePrivateProfileString = WritePrivateProfileStringA;
pub const ERROR_NOT_A_DAX_VOLUME = @as(c_long, 420);
pub const szOID_PKIX_KP_TIMESTAMP_SIGNING = "1.3.6.1.5.5.7.3.8";
pub const CRYPT_HASH_ALG_OID_GROUP_ID = 1;
pub const DI_NOMIRROR = 16;
pub const SERIAL_IOC_FCR_FIFO_ENABLE = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(DWORD, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(DWORD, 1) else DWORD(1);
pub const IME_THOTKEY_SHAPE_TOGGLE = 113;
pub const FD_ACCEPT = 8;
pub const WM_LBUTTONDOWN = 513;
pub const LANG_TAMIL = 73;
pub const SUBLANG_DANISH_DENMARK = 1;
pub const GETEXTENDEDTEXTMETRICS = 256;
pub const ACTIVATION_CONTEXT_SECTION_COMPATIBILITY_INFO = 11;
pub const SKF_INDICATOR = 32;
pub const SECURITY_DESCRIPTOR_REVISION1 = 1;
pub const WN_CONNECTED_OTHER_PASSWORD = ERROR_CONNECTED_OTHER_PASSWORD;
pub const CERT_STORE_PROV_GP_SYSTEM_STORE_FLAG = 32;
pub const VS_VERSION_INFO = 1;
pub const MM_JOY2ZMOVE = 931;
pub const DNS_ERROR_DATAFILE_BASE = 9650;
pub const MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH = 64;
pub const ERROR_FILENAME_EXCED_RANGE = @as(c_long, 206);
pub const DRIVERVERSION = 0;
pub const ILLUMINANT_NTSC = ILLUMINANT_C;
pub const SERVICE_SID_TYPE_UNRESTRICTED = 1;
pub const VER_AND = 6;
pub const NCRYPTBUFFER_TPM_SEAL_POLICYINFO = 71;
pub const ERROR_SXS_DUPLICATE_DLL_NAME = @as(c_long, 14021);
pub const JOY_BUTTON14 = @as(c_long, 8192);
pub const URLPOLICY_ACTIVEX_CHECK_LIST = 65536;
pub const DEVICEFAMILYDEVICEFORM_THIN_CLIENT = 26;
pub const CreatePropertySheetPage = CreatePropertySheetPageA;
pub const PROPSETFLAG_UNBUFFERED = 4;
pub const PWR_OK = 1;
pub const WSAEPFNOSUPPORT = @as(c_long, 10046);
pub const SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT = @as(c_long, 3);
pub const ERROR_POTENTIAL_FILE_FOUND = @as(c_long, 1180);
pub const PA_NOACTIVATE = MA_NOACTIVATE;
pub const MKF_LEFTBUTTONDOWN = 16777216;
pub const szOID_DSALG_RSA = "2.5.8.1.1";
pub const FILE_FLAG_SEQUENTIAL_SCAN = 134217728;
pub const TAPE_LONG_FILEMARKS = @as(c_long, 3);
pub const DNS_ERROR_MASK = 9000;
pub const DMORIENT_PORTRAIT = 1;
pub const WAVE_MAPPER = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(UINT, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(UINT, -1) else UINT(-1);
pub const PHYSICALOFFSETX = 112;
pub const ERROR_CURRENT_DIRECTORY = @as(c_long, 16);
pub const ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION = 7;
pub const FILE_DEVICE_TRANSPORT = 33;
pub const CRYPT_MESSAGE_SILENT_KEYSET_FLAG = 64;
pub const ERROR_CORRUPT_LOG_CORRUPTED = @as(c_long, 795);
pub const szOID_ECC_CURVE_X962P239V2 = "1.2.840.10045.3.1.5";
pub const ChooseColor = ChooseColorA;
pub const WSA_QOS_EPSFILTERSPEC = @as(c_long, 11028);
pub const SUBLANG_GERMAN_LUXEMBOURG = 4;
pub const CERT_SCEP_RA_SIGNATURE_CERT_PROP_ID = 109;
pub const IMFS_HILITE = MFS_HILITE;
pub const ATTR_TARGET_CONVERTED = 1;
pub const NID_INTEGRATED_TOUCH = 1;
pub const IMAGE_HOT_PATCH_CHUNK_RESERVED = 1072705536;
pub const MCI_OPEN_ELEMENT_ID = @as(c_long, 2048);
pub const MAX_UCSCHAR = 1114111;
pub const GetFileVersionInfoSizeEx = GetFileVersionInfoSizeExA;
pub const _EXCEPTION_DISPOSITION = enum__EXCEPTION_DISPOSITION;
pub const _EXCEPTION_RECORD = struct__EXCEPTION_RECORD;
pub const _M128A = struct__M128A;
pub const _XSAVE_FORMAT = struct__XSAVE_FORMAT;
pub const _CONTEXT = struct__CONTEXT;
pub const _UNWIND_HISTORY_TABLE_ENTRY = struct__UNWIND_HISTORY_TABLE_ENTRY;
pub const _UNWIND_HISTORY_TABLE = struct__UNWIND_HISTORY_TABLE;
pub const _DISPATCHER_CONTEXT = struct__DISPATCHER_CONTEXT;
pub const __crt_locale_data = struct___crt_locale_data;
pub const __crt_multibyte_data = struct___crt_multibyte_data;
pub const _PROCESSOR_NUMBER = struct__PROCESSOR_NUMBER;
pub const _GROUP_AFFINITY = struct__GROUP_AFFINITY;
pub const _FLOAT128 = struct__FLOAT128;
pub const _LARGE_INTEGER = union__LARGE_INTEGER;
pub const _ULARGE_INTEGER = union__ULARGE_INTEGER;
pub const _LUID = struct__LUID;
pub const _LIST_ENTRY = struct__LIST_ENTRY;
pub const _SINGLE_LIST_ENTRY = struct__SINGLE_LIST_ENTRY;
pub const _GUID = struct__GUID;
pub const _OBJECTID = struct__OBJECTID;
pub const _XSAVE_CET_U_FORMAT = struct__XSAVE_CET_U_FORMAT;
pub const _XSAVE_AREA_HEADER = struct__XSAVE_AREA_HEADER;
pub const _XSAVE_AREA = struct__XSAVE_AREA;
pub const _XSTATE_CONTEXT = struct__XSTATE_CONTEXT;
pub const _SCOPE_TABLE_AMD64 = struct__SCOPE_TABLE_AMD64;
pub const _EXCEPTION_POINTERS = struct__EXCEPTION_POINTERS;
pub const _KNONVOLATILE_CONTEXT_POINTERS = struct__KNONVOLATILE_CONTEXT_POINTERS;
pub const _SCOPE_TABLE_ARM = struct__SCOPE_TABLE_ARM;
pub const _SCOPE_TABLE_ARM64 = struct__SCOPE_TABLE_ARM64;
pub const _KNONVOLATILE_CONTEXT_POINTERS_ARM64 = struct__KNONVOLATILE_CONTEXT_POINTERS_ARM64;
pub const _LDT_ENTRY = struct__LDT_ENTRY;
pub const _WOW64_FLOATING_SAVE_AREA = struct__WOW64_FLOATING_SAVE_AREA;
pub const _WOW64_CONTEXT = struct__WOW64_CONTEXT;
pub const _WOW64_LDT_ENTRY = struct__WOW64_LDT_ENTRY;
pub const _WOW64_DESCRIPTOR_TABLE_ENTRY = struct__WOW64_DESCRIPTOR_TABLE_ENTRY;
pub const _EXCEPTION_RECORD32 = struct__EXCEPTION_RECORD32;
pub const _EXCEPTION_RECORD64 = struct__EXCEPTION_RECORD64;
pub const _GENERIC_MAPPING = struct__GENERIC_MAPPING;
pub const _LUID_AND_ATTRIBUTES = struct__LUID_AND_ATTRIBUTES;
pub const _SID_IDENTIFIER_AUTHORITY = struct__SID_IDENTIFIER_AUTHORITY;
pub const _SID = struct__SID;
pub const _SE_SID = union__SE_SID;
pub const _SID_NAME_USE = enum__SID_NAME_USE;
pub const _SID_AND_ATTRIBUTES = struct__SID_AND_ATTRIBUTES;
pub const _SID_AND_ATTRIBUTES_HASH = struct__SID_AND_ATTRIBUTES_HASH;
pub const _ACL = struct__ACL;
pub const _ACE_HEADER = struct__ACE_HEADER;
pub const _ACCESS_ALLOWED_ACE = struct__ACCESS_ALLOWED_ACE;
pub const _ACCESS_DENIED_ACE = struct__ACCESS_DENIED_ACE;
pub const _SYSTEM_AUDIT_ACE = struct__SYSTEM_AUDIT_ACE;
pub const _SYSTEM_ALARM_ACE = struct__SYSTEM_ALARM_ACE;
pub const _SYSTEM_RESOURCE_ATTRIBUTE_ACE = struct__SYSTEM_RESOURCE_ATTRIBUTE_ACE;
pub const _SYSTEM_SCOPED_POLICY_ID_ACE = struct__SYSTEM_SCOPED_POLICY_ID_ACE;
pub const _SYSTEM_MANDATORY_LABEL_ACE = struct__SYSTEM_MANDATORY_LABEL_ACE;
pub const _SYSTEM_PROCESS_TRUST_LABEL_ACE = struct__SYSTEM_PROCESS_TRUST_LABEL_ACE;
pub const _SYSTEM_ACCESS_FILTER_ACE = struct__SYSTEM_ACCESS_FILTER_ACE;
pub const _ACCESS_ALLOWED_OBJECT_ACE = struct__ACCESS_ALLOWED_OBJECT_ACE;
pub const _ACCESS_DENIED_OBJECT_ACE = struct__ACCESS_DENIED_OBJECT_ACE;
pub const _SYSTEM_AUDIT_OBJECT_ACE = struct__SYSTEM_AUDIT_OBJECT_ACE;
pub const _SYSTEM_ALARM_OBJECT_ACE = struct__SYSTEM_ALARM_OBJECT_ACE;
pub const _ACCESS_ALLOWED_CALLBACK_ACE = struct__ACCESS_ALLOWED_CALLBACK_ACE;
pub const _ACCESS_DENIED_CALLBACK_ACE = struct__ACCESS_DENIED_CALLBACK_ACE;
pub const _SYSTEM_AUDIT_CALLBACK_ACE = struct__SYSTEM_AUDIT_CALLBACK_ACE;
pub const _SYSTEM_ALARM_CALLBACK_ACE = struct__SYSTEM_ALARM_CALLBACK_ACE;
pub const _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE = struct__ACCESS_ALLOWED_CALLBACK_OBJECT_ACE;
pub const _ACCESS_DENIED_CALLBACK_OBJECT_ACE = struct__ACCESS_DENIED_CALLBACK_OBJECT_ACE;
pub const _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE = struct__SYSTEM_AUDIT_CALLBACK_OBJECT_ACE;
pub const _SYSTEM_ALARM_CALLBACK_OBJECT_ACE = struct__SYSTEM_ALARM_CALLBACK_OBJECT_ACE;
pub const _ACL_INFORMATION_CLASS = enum__ACL_INFORMATION_CLASS;
pub const _ACL_REVISION_INFORMATION = struct__ACL_REVISION_INFORMATION;
pub const _ACL_SIZE_INFORMATION = struct__ACL_SIZE_INFORMATION;
pub const _SECURITY_DESCRIPTOR_RELATIVE = struct__SECURITY_DESCRIPTOR_RELATIVE;
pub const _SECURITY_DESCRIPTOR = struct__SECURITY_DESCRIPTOR;
pub const _SECURITY_OBJECT_AI_PARAMS = struct__SECURITY_OBJECT_AI_PARAMS;
pub const _OBJECT_TYPE_LIST = struct__OBJECT_TYPE_LIST;
pub const _AUDIT_EVENT_TYPE = enum__AUDIT_EVENT_TYPE;
pub const _PRIVILEGE_SET = struct__PRIVILEGE_SET;
pub const _ACCESS_REASON_TYPE = enum__ACCESS_REASON_TYPE;
pub const _ACCESS_REASONS = struct__ACCESS_REASONS;
pub const _SE_SECURITY_DESCRIPTOR = struct__SE_SECURITY_DESCRIPTOR;
pub const _SE_ACCESS_REQUEST = struct__SE_ACCESS_REQUEST;
pub const _SE_ACCESS_REPLY = struct__SE_ACCESS_REPLY;
pub const _SECURITY_IMPERSONATION_LEVEL = enum__SECURITY_IMPERSONATION_LEVEL;
pub const _TOKEN_TYPE = enum__TOKEN_TYPE;
pub const _TOKEN_ELEVATION_TYPE = enum__TOKEN_ELEVATION_TYPE;
pub const _TOKEN_INFORMATION_CLASS = enum__TOKEN_INFORMATION_CLASS;
pub const _TOKEN_USER = struct__TOKEN_USER;
pub const _SE_TOKEN_USER = struct__SE_TOKEN_USER;
pub const _TOKEN_GROUPS = struct__TOKEN_GROUPS;
pub const _TOKEN_PRIVILEGES = struct__TOKEN_PRIVILEGES;
pub const _TOKEN_OWNER = struct__TOKEN_OWNER;
pub const _TOKEN_PRIMARY_GROUP = struct__TOKEN_PRIMARY_GROUP;
pub const _TOKEN_DEFAULT_DACL = struct__TOKEN_DEFAULT_DACL;
pub const _TOKEN_USER_CLAIMS = struct__TOKEN_USER_CLAIMS;
pub const _TOKEN_DEVICE_CLAIMS = struct__TOKEN_DEVICE_CLAIMS;
pub const _TOKEN_GROUPS_AND_PRIVILEGES = struct__TOKEN_GROUPS_AND_PRIVILEGES;
pub const _TOKEN_LINKED_TOKEN = struct__TOKEN_LINKED_TOKEN;
pub const _TOKEN_ELEVATION = struct__TOKEN_ELEVATION;
pub const _TOKEN_MANDATORY_LABEL = struct__TOKEN_MANDATORY_LABEL;
pub const _TOKEN_MANDATORY_POLICY = struct__TOKEN_MANDATORY_POLICY;
pub const _TOKEN_ACCESS_INFORMATION = struct__TOKEN_ACCESS_INFORMATION;
pub const _TOKEN_AUDIT_POLICY = struct__TOKEN_AUDIT_POLICY;
pub const _TOKEN_SOURCE = struct__TOKEN_SOURCE;
pub const _TOKEN_STATISTICS = struct__TOKEN_STATISTICS;
pub const _TOKEN_CONTROL = struct__TOKEN_CONTROL;
pub const _TOKEN_ORIGIN = struct__TOKEN_ORIGIN;
pub const _MANDATORY_LEVEL = enum__MANDATORY_LEVEL;
pub const _TOKEN_APPCONTAINER_INFORMATION = struct__TOKEN_APPCONTAINER_INFORMATION;
pub const _TOKEN_SID_INFORMATION = struct__TOKEN_SID_INFORMATION;
pub const _TOKEN_BNO_ISOLATION_INFORMATION = struct__TOKEN_BNO_ISOLATION_INFORMATION;
pub const _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = struct__CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
pub const _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = struct__CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
pub const _CLAIM_SECURITY_ATTRIBUTE_V1 = struct__CLAIM_SECURITY_ATTRIBUTE_V1;
pub const _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = struct__CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
pub const _CLAIM_SECURITY_ATTRIBUTES_INFORMATION = struct__CLAIM_SECURITY_ATTRIBUTES_INFORMATION;
pub const _SECURITY_QUALITY_OF_SERVICE = struct__SECURITY_QUALITY_OF_SERVICE;
pub const _SE_IMPERSONATION_STATE = struct__SE_IMPERSONATION_STATE;
pub const _SE_IMAGE_SIGNATURE_TYPE = enum__SE_IMAGE_SIGNATURE_TYPE;
pub const _SE_LEARNING_MODE_DATA_TYPE = enum__SE_LEARNING_MODE_DATA_TYPE;
pub const _SECURITY_CAPABILITIES = struct__SECURITY_CAPABILITIES;
pub const _JOB_SET_ARRAY = struct__JOB_SET_ARRAY;
pub const _EXCEPTION_REGISTRATION_RECORD = struct__EXCEPTION_REGISTRATION_RECORD;
pub const _NT_TIB = struct__NT_TIB;
pub const _NT_TIB32 = struct__NT_TIB32;
pub const _NT_TIB64 = struct__NT_TIB64;
pub const _UMS_CREATE_THREAD_ATTRIBUTES = struct__UMS_CREATE_THREAD_ATTRIBUTES;
pub const _WOW64_ARCHITECTURE_INFORMATION = struct__WOW64_ARCHITECTURE_INFORMATION;
pub const _QUOTA_LIMITS = struct__QUOTA_LIMITS;
pub const _RATE_QUOTA_LIMIT = union__RATE_QUOTA_LIMIT;
pub const _QUOTA_LIMITS_EX = struct__QUOTA_LIMITS_EX;
pub const _IO_COUNTERS = struct__IO_COUNTERS;
pub const _HARDWARE_COUNTER_TYPE = enum__HARDWARE_COUNTER_TYPE;
pub const _PROCESS_MITIGATION_POLICY = enum__PROCESS_MITIGATION_POLICY;
pub const _PROCESS_MITIGATION_ASLR_POLICY = struct__PROCESS_MITIGATION_ASLR_POLICY;
pub const _PROCESS_MITIGATION_DEP_POLICY = struct__PROCESS_MITIGATION_DEP_POLICY;
pub const _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY = struct__PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
pub const _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY = struct__PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
pub const _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY = struct__PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
pub const _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY = struct__PROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
pub const _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY = struct__PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
pub const _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = struct__PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
pub const _PROCESS_MITIGATION_FONT_DISABLE_POLICY = struct__PROCESS_MITIGATION_FONT_DISABLE_POLICY;
pub const _PROCESS_MITIGATION_IMAGE_LOAD_POLICY = struct__PROCESS_MITIGATION_IMAGE_LOAD_POLICY;
pub const _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY = struct__PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;
pub const _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY = struct__PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
pub const _PROCESS_MITIGATION_CHILD_PROCESS_POLICY = struct__PROCESS_MITIGATION_CHILD_PROCESS_POLICY;
pub const _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY = struct__PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY;
pub const _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION = struct__JOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
pub const _JOBOBJECT_BASIC_LIMIT_INFORMATION = struct__JOBOBJECT_BASIC_LIMIT_INFORMATION;
pub const _JOBOBJECT_EXTENDED_LIMIT_INFORMATION = struct__JOBOBJECT_EXTENDED_LIMIT_INFORMATION;
pub const _JOBOBJECT_BASIC_PROCESS_ID_LIST = struct__JOBOBJECT_BASIC_PROCESS_ID_LIST;
pub const _JOBOBJECT_BASIC_UI_RESTRICTIONS = struct__JOBOBJECT_BASIC_UI_RESTRICTIONS;
pub const _JOBOBJECT_SECURITY_LIMIT_INFORMATION = struct__JOBOBJECT_SECURITY_LIMIT_INFORMATION;
pub const _JOBOBJECT_END_OF_JOB_TIME_INFORMATION = struct__JOBOBJECT_END_OF_JOB_TIME_INFORMATION;
pub const _JOBOBJECT_ASSOCIATE_COMPLETION_PORT = struct__JOBOBJECT_ASSOCIATE_COMPLETION_PORT;
pub const _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = struct__JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
pub const _JOBOBJECT_JOBSET_INFORMATION = struct__JOBOBJECT_JOBSET_INFORMATION;
pub const _JOBOBJECT_RATE_CONTROL_TOLERANCE = enum__JOBOBJECT_RATE_CONTROL_TOLERANCE;
pub const _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = enum__JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL;
pub const _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = struct__JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;
pub const _JOBOBJECT_LIMIT_VIOLATION_INFORMATION = struct__JOBOBJECT_LIMIT_VIOLATION_INFORMATION;
pub const _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION = struct__JOBOBJECT_CPU_RATE_CONTROL_INFORMATION;
pub const _JOBOBJECT_IO_ATTRIBUTION_STATS = struct__JOBOBJECT_IO_ATTRIBUTION_STATS;
pub const _JOBOBJECT_IO_ATTRIBUTION_INFORMATION = struct__JOBOBJECT_IO_ATTRIBUTION_INFORMATION;
pub const _JOBOBJECTINFOCLASS = enum__JOBOBJECTINFOCLASS;
pub const _SILOOBJECT_BASIC_INFORMATION = struct__SILOOBJECT_BASIC_INFORMATION;
pub const _SERVERSILO_STATE = enum__SERVERSILO_STATE;
pub const _SERVERSILO_BASIC_INFORMATION = struct__SERVERSILO_BASIC_INFORMATION;
pub const _FIRMWARE_TYPE = enum__FIRMWARE_TYPE;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP = enum__LOGICAL_PROCESSOR_RELATIONSHIP;
pub const _PROCESSOR_CACHE_TYPE = enum__PROCESSOR_CACHE_TYPE;
pub const _CACHE_DESCRIPTOR = struct__CACHE_DESCRIPTOR;
pub const _SYSTEM_LOGICAL_PROCESSOR_INFORMATION = struct__SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
pub const _PROCESSOR_RELATIONSHIP = struct__PROCESSOR_RELATIONSHIP;
pub const _NUMA_NODE_RELATIONSHIP = struct__NUMA_NODE_RELATIONSHIP;
pub const _CACHE_RELATIONSHIP = struct__CACHE_RELATIONSHIP;
pub const _PROCESSOR_GROUP_INFO = struct__PROCESSOR_GROUP_INFO;
pub const _GROUP_RELATIONSHIP = struct__GROUP_RELATIONSHIP;
pub const _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = struct__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
pub const _CPU_SET_INFORMATION_TYPE = enum__CPU_SET_INFORMATION_TYPE;
pub const _SYSTEM_CPU_SET_INFORMATION = struct__SYSTEM_CPU_SET_INFORMATION;
pub const _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = struct__SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
pub const _XSTATE_FEATURE = struct__XSTATE_FEATURE;
pub const _XSTATE_CONFIGURATION = struct__XSTATE_CONFIGURATION;
pub const _MEMORY_BASIC_INFORMATION = struct__MEMORY_BASIC_INFORMATION;
pub const _MEMORY_BASIC_INFORMATION32 = struct__MEMORY_BASIC_INFORMATION32;
pub const _MEMORY_BASIC_INFORMATION64 = struct__MEMORY_BASIC_INFORMATION64;
pub const _CFG_CALL_TARGET_INFO = struct__CFG_CALL_TARGET_INFO;
pub const _MEM_ADDRESS_REQUIREMENTS = struct__MEM_ADDRESS_REQUIREMENTS;
pub const _ENCLAVE_CREATE_INFO_SGX = struct__ENCLAVE_CREATE_INFO_SGX;
pub const _ENCLAVE_INIT_INFO_SGX = struct__ENCLAVE_INIT_INFO_SGX;
pub const _ENCLAVE_CREATE_INFO_VBS = struct__ENCLAVE_CREATE_INFO_VBS;
pub const _ENCLAVE_CREATE_INFO_VBS_BASIC = struct__ENCLAVE_CREATE_INFO_VBS_BASIC;
pub const _ENCLAVE_LOAD_DATA_VBS_BASIC = struct__ENCLAVE_LOAD_DATA_VBS_BASIC;
pub const _ENCLAVE_INIT_INFO_VBS_BASIC = struct__ENCLAVE_INIT_INFO_VBS_BASIC;
pub const _ENCLAVE_INIT_INFO_VBS = struct__ENCLAVE_INIT_INFO_VBS;
pub const _FILE_ID_128 = struct__FILE_ID_128;
pub const _FILE_NOTIFY_INFORMATION = struct__FILE_NOTIFY_INFORMATION;
pub const _FILE_NOTIFY_EXTENDED_INFORMATION = struct__FILE_NOTIFY_EXTENDED_INFORMATION;
pub const _FILE_SEGMENT_ELEMENT = union__FILE_SEGMENT_ELEMENT;
pub const _REPARSE_GUID_DATA_BUFFER = struct__REPARSE_GUID_DATA_BUFFER;
pub const _SCRUB_DATA_INPUT = struct__SCRUB_DATA_INPUT;
pub const _SCRUB_PARITY_EXTENT = struct__SCRUB_PARITY_EXTENT;
pub const _SCRUB_PARITY_EXTENT_DATA = struct__SCRUB_PARITY_EXTENT_DATA;
pub const _SCRUB_DATA_OUTPUT = struct__SCRUB_DATA_OUTPUT;
pub const _SharedVirtualDiskSupportType = enum__SharedVirtualDiskSupportType;
pub const _SharedVirtualDiskHandleState = enum__SharedVirtualDiskHandleState;
pub const _SHARED_VIRTUAL_DISK_SUPPORT = struct__SHARED_VIRTUAL_DISK_SUPPORT;
pub const _REARRANGE_FILE_DATA = struct__REARRANGE_FILE_DATA;
pub const _REARRANGE_FILE_DATA32 = struct__REARRANGE_FILE_DATA32;
pub const _SHUFFLE_FILE_DATA = struct__SHUFFLE_FILE_DATA;
pub const _NETWORK_APP_INSTANCE_EA = struct__NETWORK_APP_INSTANCE_EA;
pub const _SYSTEM_POWER_STATE = enum__SYSTEM_POWER_STATE;
pub const _DEVICE_POWER_STATE = enum__DEVICE_POWER_STATE;
pub const _MONITOR_DISPLAY_STATE = enum__MONITOR_DISPLAY_STATE;
pub const _USER_ACTIVITY_PRESENCE = enum__USER_ACTIVITY_PRESENCE;
pub const _POWER_REQUEST_TYPE = enum__POWER_REQUEST_TYPE;
pub const CM_Power_Data_s = struct_CM_Power_Data_s;
pub const _POWER_USER_PRESENCE = struct__POWER_USER_PRESENCE;
pub const _POWER_SESSION_CONNECT = struct__POWER_SESSION_CONNECT;
pub const _POWER_SESSION_TIMEOUTS = struct__POWER_SESSION_TIMEOUTS;
pub const _POWER_SESSION_RIT_STATE = struct__POWER_SESSION_RIT_STATE;
pub const _POWER_SESSION_WINLOGON = struct__POWER_SESSION_WINLOGON;
pub const _POWER_IDLE_RESILIENCY = struct__POWER_IDLE_RESILIENCY;
pub const _POWER_MONITOR_REQUEST_TYPE = enum__POWER_MONITOR_REQUEST_TYPE;
pub const _POWER_MONITOR_INVOCATION = struct__POWER_MONITOR_INVOCATION;
pub const _RESUME_PERFORMANCE = struct__RESUME_PERFORMANCE;
pub const _APPLICATIONLAUNCH_SETTING_VALUE = struct__APPLICATIONLAUNCH_SETTING_VALUE;
pub const _POWER_PLATFORM_ROLE = enum__POWER_PLATFORM_ROLE;
pub const _POWER_PLATFORM_INFORMATION = struct__POWER_PLATFORM_INFORMATION;
pub const _SYSTEM_POWER_POLICY = struct__SYSTEM_POWER_POLICY;
pub const _PROCESSOR_POWER_POLICY_INFO = struct__PROCESSOR_POWER_POLICY_INFO;
pub const _PROCESSOR_POWER_POLICY = struct__PROCESSOR_POWER_POLICY;
pub const _ADMINISTRATOR_POWER_POLICY = struct__ADMINISTRATOR_POWER_POLICY;
pub const _HIBERFILE_BUCKET_SIZE = enum__HIBERFILE_BUCKET_SIZE;
pub const _HIBERFILE_BUCKET = struct__HIBERFILE_BUCKET;
pub const _IMAGE_DOS_HEADER = struct__IMAGE_DOS_HEADER;
pub const _IMAGE_OS2_HEADER = struct__IMAGE_OS2_HEADER;
pub const _IMAGE_VXD_HEADER = struct__IMAGE_VXD_HEADER;
pub const _IMAGE_FILE_HEADER = struct__IMAGE_FILE_HEADER;
pub const _IMAGE_DATA_DIRECTORY = struct__IMAGE_DATA_DIRECTORY;
pub const _IMAGE_OPTIONAL_HEADER = struct__IMAGE_OPTIONAL_HEADER;
pub const _IMAGE_ROM_OPTIONAL_HEADER = struct__IMAGE_ROM_OPTIONAL_HEADER;
pub const _IMAGE_OPTIONAL_HEADER64 = struct__IMAGE_OPTIONAL_HEADER64;
pub const _IMAGE_NT_HEADERS64 = struct__IMAGE_NT_HEADERS64;
pub const _IMAGE_NT_HEADERS = struct__IMAGE_NT_HEADERS;
pub const _IMAGE_ROM_HEADERS = struct__IMAGE_ROM_HEADERS;
pub const _IMAGE_SECTION_HEADER = struct__IMAGE_SECTION_HEADER;
pub const _IMAGE_SYMBOL = struct__IMAGE_SYMBOL;
pub const _IMAGE_SYMBOL_EX = struct__IMAGE_SYMBOL_EX;
pub const _IMAGE_AUX_SYMBOL = union__IMAGE_AUX_SYMBOL;
pub const _IMAGE_AUX_SYMBOL_EX = union__IMAGE_AUX_SYMBOL_EX;
pub const _IMAGE_RELOCATION = struct__IMAGE_RELOCATION;
pub const _IMAGE_LINENUMBER = struct__IMAGE_LINENUMBER;
pub const _IMAGE_BASE_RELOCATION = struct__IMAGE_BASE_RELOCATION;
pub const _IMAGE_ARCHIVE_MEMBER_HEADER = struct__IMAGE_ARCHIVE_MEMBER_HEADER;
pub const _IMAGE_EXPORT_DIRECTORY = struct__IMAGE_EXPORT_DIRECTORY;
pub const _IMAGE_IMPORT_BY_NAME = struct__IMAGE_IMPORT_BY_NAME;
pub const _IMAGE_THUNK_DATA64 = struct__IMAGE_THUNK_DATA64;
pub const _IMAGE_THUNK_DATA32 = struct__IMAGE_THUNK_DATA32;
pub const _IMAGE_TLS_DIRECTORY64 = struct__IMAGE_TLS_DIRECTORY64;
pub const _IMAGE_TLS_DIRECTORY32 = struct__IMAGE_TLS_DIRECTORY32;
pub const _IMAGE_IMPORT_DESCRIPTOR = struct__IMAGE_IMPORT_DESCRIPTOR;
pub const _IMAGE_BOUND_IMPORT_DESCRIPTOR = struct__IMAGE_BOUND_IMPORT_DESCRIPTOR;
pub const _IMAGE_BOUND_FORWARDER_REF = struct__IMAGE_BOUND_FORWARDER_REF;
pub const _IMAGE_DELAYLOAD_DESCRIPTOR = struct__IMAGE_DELAYLOAD_DESCRIPTOR;
pub const _IMAGE_RESOURCE_DIRECTORY = struct__IMAGE_RESOURCE_DIRECTORY;
pub const _IMAGE_RESOURCE_DIRECTORY_ENTRY = struct__IMAGE_RESOURCE_DIRECTORY_ENTRY;
pub const _IMAGE_RESOURCE_DIRECTORY_STRING = struct__IMAGE_RESOURCE_DIRECTORY_STRING;
pub const _IMAGE_RESOURCE_DIR_STRING_U = struct__IMAGE_RESOURCE_DIR_STRING_U;
pub const _IMAGE_RESOURCE_DATA_ENTRY = struct__IMAGE_RESOURCE_DATA_ENTRY;
pub const _IMAGE_LOAD_CONFIG_CODE_INTEGRITY = struct__IMAGE_LOAD_CONFIG_CODE_INTEGRITY;
pub const _IMAGE_DYNAMIC_RELOCATION_TABLE = struct__IMAGE_DYNAMIC_RELOCATION_TABLE;
pub const _IMAGE_DYNAMIC_RELOCATION32 = struct__IMAGE_DYNAMIC_RELOCATION32;
pub const _IMAGE_DYNAMIC_RELOCATION64 = struct__IMAGE_DYNAMIC_RELOCATION64;
pub const _IMAGE_DYNAMIC_RELOCATION32_V2 = struct__IMAGE_DYNAMIC_RELOCATION32_V2;
pub const _IMAGE_DYNAMIC_RELOCATION64_V2 = struct__IMAGE_DYNAMIC_RELOCATION64_V2;
pub const _IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER = struct__IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;
pub const _IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER = struct__IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;
pub const _IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION = struct__IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
pub const _IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION = struct__IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
pub const _IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION = struct__IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION;
pub const _IMAGE_LOAD_CONFIG_DIRECTORY32 = struct__IMAGE_LOAD_CONFIG_DIRECTORY32;
pub const _IMAGE_LOAD_CONFIG_DIRECTORY64 = struct__IMAGE_LOAD_CONFIG_DIRECTORY64;
pub const _IMAGE_HOT_PATCH_INFO = struct__IMAGE_HOT_PATCH_INFO;
pub const _IMAGE_HOT_PATCH_BASE = struct__IMAGE_HOT_PATCH_BASE;
pub const _IMAGE_HOT_PATCH_HASHES = struct__IMAGE_HOT_PATCH_HASHES;
pub const _IMAGE_CE_RUNTIME_FUNCTION_ENTRY = struct__IMAGE_CE_RUNTIME_FUNCTION_ENTRY;
pub const _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY = struct__IMAGE_ARM_RUNTIME_FUNCTION_ENTRY;
pub const _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = struct__IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
pub const _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = struct__IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;
pub const _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = struct__IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;
pub const _IMAGE_ENCLAVE_CONFIG32 = struct__IMAGE_ENCLAVE_CONFIG32;
pub const _IMAGE_ENCLAVE_CONFIG64 = struct__IMAGE_ENCLAVE_CONFIG64;
pub const _IMAGE_ENCLAVE_IMPORT = struct__IMAGE_ENCLAVE_IMPORT;
pub const _IMAGE_DEBUG_DIRECTORY = struct__IMAGE_DEBUG_DIRECTORY;
pub const _IMAGE_COFF_SYMBOLS_HEADER = struct__IMAGE_COFF_SYMBOLS_HEADER;
pub const _FPO_DATA = struct__FPO_DATA;
pub const _IMAGE_DEBUG_MISC = struct__IMAGE_DEBUG_MISC;
pub const _IMAGE_FUNCTION_ENTRY = struct__IMAGE_FUNCTION_ENTRY;
pub const _IMAGE_FUNCTION_ENTRY64 = struct__IMAGE_FUNCTION_ENTRY64;
pub const _IMAGE_SEPARATE_DEBUG_HEADER = struct__IMAGE_SEPARATE_DEBUG_HEADER;
pub const _NON_PAGED_DEBUG_INFO = struct__NON_PAGED_DEBUG_INFO;
pub const _ImageArchitectureHeader = struct__ImageArchitectureHeader;
pub const _ImageArchitectureEntry = struct__ImageArchitectureEntry;
pub const _SLIST_ENTRY = struct__SLIST_ENTRY;
pub const _SLIST_HEADER = union__SLIST_HEADER;
pub const _RTL_RUN_ONCE = union__RTL_RUN_ONCE;
pub const _RTL_BARRIER = struct__RTL_BARRIER;
pub const _MESSAGE_RESOURCE_ENTRY = struct__MESSAGE_RESOURCE_ENTRY;
pub const _MESSAGE_RESOURCE_BLOCK = struct__MESSAGE_RESOURCE_BLOCK;
pub const _MESSAGE_RESOURCE_DATA = struct__MESSAGE_RESOURCE_DATA;
pub const _OSVERSIONINFOA = struct__OSVERSIONINFOA;
pub const _OSVERSIONINFOW = struct__OSVERSIONINFOW;
pub const _OSVERSIONINFOEXA = struct__OSVERSIONINFOEXA;
pub const _OSVERSIONINFOEXW = struct__OSVERSIONINFOEXW;
pub const _RTL_UMS_THREAD_INFO_CLASS = enum__RTL_UMS_THREAD_INFO_CLASS;
pub const _RTL_UMS_SCHEDULER_REASON = enum__RTL_UMS_SCHEDULER_REASON;
pub const _OS_DEPLOYEMENT_STATE_VALUES = enum__OS_DEPLOYEMENT_STATE_VALUES;
pub const _NV_MEMORY_RANGE = struct__NV_MEMORY_RANGE;
pub const _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = struct__CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG;
pub const _IMAGE_POLICY_ENTRY_TYPE = enum__IMAGE_POLICY_ENTRY_TYPE;
pub const _IMAGE_POLICY_ID = enum__IMAGE_POLICY_ID;
pub const _IMAGE_POLICY_ENTRY = struct__IMAGE_POLICY_ENTRY;
pub const _IMAGE_POLICY_METADATA = struct__IMAGE_POLICY_METADATA;
pub const _RTL_CRITICAL_SECTION = struct__RTL_CRITICAL_SECTION;
pub const _RTL_CRITICAL_SECTION_DEBUG = struct__RTL_CRITICAL_SECTION_DEBUG;
pub const _RTL_SRWLOCK = struct__RTL_SRWLOCK;
pub const _RTL_CONDITION_VARIABLE = struct__RTL_CONDITION_VARIABLE;
pub const _HEAP_INFORMATION_CLASS = enum__HEAP_INFORMATION_CLASS;
pub const _HEAP_OPTIMIZE_RESOURCES_INFORMATION = struct__HEAP_OPTIMIZE_RESOURCES_INFORMATION;
pub const _ACTIVATION_CONTEXT_INFO_CLASS = enum__ACTIVATION_CONTEXT_INFO_CLASS;
pub const _ACTIVATION_CONTEXT_QUERY_INDEX = struct__ACTIVATION_CONTEXT_QUERY_INDEX;
pub const _ASSEMBLY_FILE_DETAILED_INFORMATION = struct__ASSEMBLY_FILE_DETAILED_INFORMATION;
pub const _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = struct__ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
pub const _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = struct__ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
pub const _COMPATIBILITY_CONTEXT_ELEMENT = struct__COMPATIBILITY_CONTEXT_ELEMENT;
pub const _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = struct__ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
pub const _SUPPORTED_OS_INFO = struct__SUPPORTED_OS_INFO;
pub const _MAXVERSIONTESTED_INFO = struct__MAXVERSIONTESTED_INFO;
pub const _ACTIVATION_CONTEXT_DETAILED_INFORMATION = struct__ACTIVATION_CONTEXT_DETAILED_INFORMATION;
pub const _HARDWARE_COUNTER_DATA = struct__HARDWARE_COUNTER_DATA;
pub const _PERFORMANCE_DATA = struct__PERFORMANCE_DATA;
pub const _EVENTLOGRECORD = struct__EVENTLOGRECORD;
pub const _EVENTSFORLOGFILE = struct__EVENTSFORLOGFILE;
pub const _PACKEDEVENTINFO = struct__PACKEDEVENTINFO;
pub const _CM_SERVICE_NODE_TYPE = enum__CM_SERVICE_NODE_TYPE;
pub const _CM_SERVICE_LOAD_TYPE = enum__CM_SERVICE_LOAD_TYPE;
pub const _CM_ERROR_CONTROL_TYPE = enum__CM_ERROR_CONTROL_TYPE;
pub const _TAPE_ERASE = struct__TAPE_ERASE;
pub const _TAPE_PREPARE = struct__TAPE_PREPARE;
pub const _TAPE_WRITE_MARKS = struct__TAPE_WRITE_MARKS;
pub const _TAPE_GET_POSITION = struct__TAPE_GET_POSITION;
pub const _TAPE_SET_POSITION = struct__TAPE_SET_POSITION;
pub const _TAPE_GET_DRIVE_PARAMETERS = struct__TAPE_GET_DRIVE_PARAMETERS;
pub const _TAPE_SET_DRIVE_PARAMETERS = struct__TAPE_SET_DRIVE_PARAMETERS;
pub const _TAPE_GET_MEDIA_PARAMETERS = struct__TAPE_GET_MEDIA_PARAMETERS;
pub const _TAPE_SET_MEDIA_PARAMETERS = struct__TAPE_SET_MEDIA_PARAMETERS;
pub const _TAPE_CREATE_PARTITION = struct__TAPE_CREATE_PARTITION;
pub const _TAPE_WMI_OPERATIONS = struct__TAPE_WMI_OPERATIONS;
pub const _TAPE_DRIVE_PROBLEM_TYPE = enum__TAPE_DRIVE_PROBLEM_TYPE;
pub const _TRANSACTION_NOTIFICATION = struct__TRANSACTION_NOTIFICATION;
pub const _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = struct__TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
pub const _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = struct__TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
pub const _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = struct__TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
pub const _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = struct__TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub const _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = struct__TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
pub const _KCRM_MARSHAL_HEADER = struct__KCRM_MARSHAL_HEADER;
pub const _KCRM_TRANSACTION_BLOB = struct__KCRM_TRANSACTION_BLOB;
pub const _KCRM_PROTOCOL_BLOB = struct__KCRM_PROTOCOL_BLOB;
pub const _TRANSACTION_OUTCOME = enum__TRANSACTION_OUTCOME;
pub const _TRANSACTION_STATE = enum__TRANSACTION_STATE;
pub const _TRANSACTION_BASIC_INFORMATION = struct__TRANSACTION_BASIC_INFORMATION;
pub const _TRANSACTIONMANAGER_BASIC_INFORMATION = struct__TRANSACTIONMANAGER_BASIC_INFORMATION;
pub const _TRANSACTIONMANAGER_LOG_INFORMATION = struct__TRANSACTIONMANAGER_LOG_INFORMATION;
pub const _TRANSACTIONMANAGER_LOGPATH_INFORMATION = struct__TRANSACTIONMANAGER_LOGPATH_INFORMATION;
pub const _TRANSACTIONMANAGER_RECOVERY_INFORMATION = struct__TRANSACTIONMANAGER_RECOVERY_INFORMATION;
pub const _TRANSACTIONMANAGER_OLDEST_INFORMATION = struct__TRANSACTIONMANAGER_OLDEST_INFORMATION;
pub const _TRANSACTION_PROPERTIES_INFORMATION = struct__TRANSACTION_PROPERTIES_INFORMATION;
pub const _TRANSACTION_BIND_INFORMATION = struct__TRANSACTION_BIND_INFORMATION;
pub const _TRANSACTION_ENLISTMENT_PAIR = struct__TRANSACTION_ENLISTMENT_PAIR;
pub const _TRANSACTION_ENLISTMENTS_INFORMATION = struct__TRANSACTION_ENLISTMENTS_INFORMATION;
pub const _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = struct__TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
pub const _RESOURCEMANAGER_BASIC_INFORMATION = struct__RESOURCEMANAGER_BASIC_INFORMATION;
pub const _RESOURCEMANAGER_COMPLETION_INFORMATION = struct__RESOURCEMANAGER_COMPLETION_INFORMATION;
pub const _TRANSACTION_INFORMATION_CLASS = enum__TRANSACTION_INFORMATION_CLASS;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS = enum__TRANSACTIONMANAGER_INFORMATION_CLASS;
pub const _RESOURCEMANAGER_INFORMATION_CLASS = enum__RESOURCEMANAGER_INFORMATION_CLASS;
pub const _ENLISTMENT_BASIC_INFORMATION = struct__ENLISTMENT_BASIC_INFORMATION;
pub const _ENLISTMENT_CRM_INFORMATION = struct__ENLISTMENT_CRM_INFORMATION;
pub const _ENLISTMENT_INFORMATION_CLASS = enum__ENLISTMENT_INFORMATION_CLASS;
pub const _TRANSACTION_LIST_ENTRY = struct__TRANSACTION_LIST_ENTRY;
pub const _TRANSACTION_LIST_INFORMATION = struct__TRANSACTION_LIST_INFORMATION;
pub const _KTMOBJECT_TYPE = enum__KTMOBJECT_TYPE;
pub const _KTMOBJECT_CURSOR = struct__KTMOBJECT_CURSOR;
pub const _TP_CALLBACK_INSTANCE = struct__TP_CALLBACK_INSTANCE;
pub const _TP_POOL = struct__TP_POOL;
pub const _TP_CALLBACK_PRIORITY = enum__TP_CALLBACK_PRIORITY;
pub const _TP_POOL_STACK_INFORMATION = struct__TP_POOL_STACK_INFORMATION;
pub const _TP_CLEANUP_GROUP = struct__TP_CLEANUP_GROUP;
pub const _ACTIVATION_CONTEXT = struct__ACTIVATION_CONTEXT;
pub const _TP_CALLBACK_ENVIRON_V3 = struct__TP_CALLBACK_ENVIRON_V3;
pub const _TP_WORK = struct__TP_WORK;
pub const _TP_TIMER = struct__TP_TIMER;
pub const _TP_WAIT = struct__TP_WAIT;
pub const _TP_IO = struct__TP_IO;
pub const _TEB = struct__TEB;
pub const HKEY__ = struct_HKEY__;
pub const HMETAFILE__ = struct_HMETAFILE__;
pub const HINSTANCE__ = struct_HINSTANCE__;
pub const HRGN__ = struct_HRGN__;
pub const HRSRC__ = struct_HRSRC__;
pub const HSPRITE__ = struct_HSPRITE__;
pub const HLSURF__ = struct_HLSURF__;
pub const HSTR__ = struct_HSTR__;
pub const HTASK__ = struct_HTASK__;
pub const HWINSTA__ = struct_HWINSTA__;
pub const HKL__ = struct_HKL__;
pub const _FILETIME = struct__FILETIME;
pub const HWND__ = struct_HWND__;
pub const HHOOK__ = struct_HHOOK__;
pub const HACCEL__ = struct_HACCEL__;
pub const HBITMAP__ = struct_HBITMAP__;
pub const HBRUSH__ = struct_HBRUSH__;
pub const HCOLORSPACE__ = struct_HCOLORSPACE__;
pub const HDC__ = struct_HDC__;
pub const HGLRC__ = struct_HGLRC__;
pub const HDESK__ = struct_HDESK__;
pub const HENHMETAFILE__ = struct_HENHMETAFILE__;
pub const HFONT__ = struct_HFONT__;
pub const HICON__ = struct_HICON__;
pub const HMENU__ = struct_HMENU__;
pub const HPALETTE__ = struct_HPALETTE__;
pub const HPEN__ = struct_HPEN__;
pub const HWINEVENTHOOK__ = struct_HWINEVENTHOOK__;
pub const HMONITOR__ = struct_HMONITOR__;
pub const HUMPD__ = struct_HUMPD__;
pub const tagRECT = struct_tagRECT;
pub const _RECTL = struct__RECTL;
pub const tagPOINT = struct_tagPOINT;
pub const _POINTL = struct__POINTL;
pub const tagSIZE = struct_tagSIZE;
pub const tagPOINTS = struct_tagPOINTS;
pub const DPI_AWARENESS_CONTEXT__ = struct_DPI_AWARENESS_CONTEXT__;
pub const _SECURITY_ATTRIBUTES = struct__SECURITY_ATTRIBUTES;
pub const _OVERLAPPED = struct__OVERLAPPED;
pub const _OVERLAPPED_ENTRY = struct__OVERLAPPED_ENTRY;
pub const _SYSTEMTIME = struct__SYSTEMTIME;
pub const _WIN32_FIND_DATAA = struct__WIN32_FIND_DATAA;
pub const _WIN32_FIND_DATAW = struct__WIN32_FIND_DATAW;
pub const _FINDEX_INFO_LEVELS = enum__FINDEX_INFO_LEVELS;
pub const _FINDEX_SEARCH_OPS = enum__FINDEX_SEARCH_OPS;
pub const _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS = enum__READ_DIRECTORY_NOTIFY_INFORMATION_CLASS;
pub const _GET_FILEEX_INFO_LEVELS = enum__GET_FILEEX_INFO_LEVELS;
pub const _FILE_INFO_BY_HANDLE_CLASS = enum__FILE_INFO_BY_HANDLE_CLASS;
pub const _PROCESS_HEAP_ENTRY = struct__PROCESS_HEAP_ENTRY;
pub const _REASON_CONTEXT = struct__REASON_CONTEXT;
pub const _EXCEPTION_DEBUG_INFO = struct__EXCEPTION_DEBUG_INFO;
pub const _CREATE_THREAD_DEBUG_INFO = struct__CREATE_THREAD_DEBUG_INFO;
pub const _CREATE_PROCESS_DEBUG_INFO = struct__CREATE_PROCESS_DEBUG_INFO;
pub const _EXIT_THREAD_DEBUG_INFO = struct__EXIT_THREAD_DEBUG_INFO;
pub const _EXIT_PROCESS_DEBUG_INFO = struct__EXIT_PROCESS_DEBUG_INFO;
pub const _LOAD_DLL_DEBUG_INFO = struct__LOAD_DLL_DEBUG_INFO;
pub const _UNLOAD_DLL_DEBUG_INFO = struct__UNLOAD_DLL_DEBUG_INFO;
pub const _OUTPUT_DEBUG_STRING_INFO = struct__OUTPUT_DEBUG_STRING_INFO;
pub const _RIP_INFO = struct__RIP_INFO;
pub const _DEBUG_EVENT = struct__DEBUG_EVENT;
pub const _WIN32_FILE_ATTRIBUTE_DATA = struct__WIN32_FILE_ATTRIBUTE_DATA;
pub const _BY_HANDLE_FILE_INFORMATION = struct__BY_HANDLE_FILE_INFORMATION;
pub const _CREATEFILE2_EXTENDED_PARAMETERS = struct__CREATEFILE2_EXTENDED_PARAMETERS;
pub const _STREAM_INFO_LEVELS = enum__STREAM_INFO_LEVELS;
pub const _WIN32_FIND_STREAM_DATA = struct__WIN32_FIND_STREAM_DATA;
pub const _HEAP_SUMMARY = struct__HEAP_SUMMARY;
pub const _PROCESS_INFORMATION = struct__PROCESS_INFORMATION;
pub const _STARTUPINFOA = struct__STARTUPINFOA;
pub const _STARTUPINFOW = struct__STARTUPINFOW;
pub const _PROC_THREAD_ATTRIBUTE_LIST = struct__PROC_THREAD_ATTRIBUTE_LIST;
pub const _THREAD_INFORMATION_CLASS = enum__THREAD_INFORMATION_CLASS;
pub const _MEMORY_PRIORITY_INFORMATION = struct__MEMORY_PRIORITY_INFORMATION;
pub const _THREAD_POWER_THROTTLING_STATE = struct__THREAD_POWER_THROTTLING_STATE;
pub const _PROCESS_INFORMATION_CLASS = enum__PROCESS_INFORMATION_CLASS;
pub const _APP_MEMORY_INFORMATION = struct__APP_MEMORY_INFORMATION;
pub const _PROCESS_MEMORY_EXHAUSTION_TYPE = enum__PROCESS_MEMORY_EXHAUSTION_TYPE;
pub const _PROCESS_MEMORY_EXHAUSTION_INFO = struct__PROCESS_MEMORY_EXHAUSTION_INFO;
pub const _PROCESS_POWER_THROTTLING_STATE = struct__PROCESS_POWER_THROTTLING_STATE;
pub const _PROCESS_LEAP_SECOND_INFO = struct__PROCESS_LEAP_SECOND_INFO;
pub const _SYSTEM_INFO = struct__SYSTEM_INFO;
pub const _MEMORYSTATUSEX = struct__MEMORYSTATUSEX;
pub const _COMPUTER_NAME_FORMAT = enum__COMPUTER_NAME_FORMAT;
pub const _MEMORY_RESOURCE_NOTIFICATION_TYPE = enum__MEMORY_RESOURCE_NOTIFICATION_TYPE;
pub const _WIN32_MEMORY_RANGE_ENTRY = struct__WIN32_MEMORY_RANGE_ENTRY;
pub const tagENUMUILANG = struct_tagENUMUILANG;
pub const _REDIRECTION_FUNCTION_DESCRIPTOR = struct__REDIRECTION_FUNCTION_DESCRIPTOR;
pub const _REDIRECTION_DESCRIPTOR = struct__REDIRECTION_DESCRIPTOR;
pub const _COMMPROP = struct__COMMPROP;
pub const _COMSTAT = struct__COMSTAT;
pub const _DCB = struct__DCB;
pub const _COMMTIMEOUTS = struct__COMMTIMEOUTS;
pub const _COMMCONFIG = struct__COMMCONFIG;
pub const _MEMORYSTATUS = struct__MEMORYSTATUS;
pub const _JIT_DEBUG_INFO = struct__JIT_DEBUG_INFO;
pub const _OFSTRUCT = struct__OFSTRUCT;
pub const _UMS_SCHEDULER_STARTUP_INFO = struct__UMS_SCHEDULER_STARTUP_INFO;
pub const _UMS_SYSTEM_THREAD_INFORMATION = struct__UMS_SYSTEM_THREAD_INFORMATION;
pub const _DEP_SYSTEM_POLICY_TYPE = enum__DEP_SYSTEM_POLICY_TYPE;
pub const _WIN32_STREAM_ID = struct__WIN32_STREAM_ID;
pub const _STARTUPINFOEXA = struct__STARTUPINFOEXA;
pub const _STARTUPINFOEXW = struct__STARTUPINFOEXW;
pub const _PROC_THREAD_ATTRIBUTE_NUM = enum__PROC_THREAD_ATTRIBUTE_NUM;
pub const _COPYFILE2_MESSAGE_TYPE = enum__COPYFILE2_MESSAGE_TYPE;
pub const _COPYFILE2_MESSAGE_ACTION = enum__COPYFILE2_MESSAGE_ACTION;
pub const _COPYFILE2_COPY_PHASE = enum__COPYFILE2_COPY_PHASE;
pub const _EVENTLOG_FULL_INFORMATION = struct__EVENTLOG_FULL_INFORMATION;
pub const _OPERATION_START_PARAMETERS = struct__OPERATION_START_PARAMETERS;
pub const _OPERATION_END_PARAMETERS = struct__OPERATION_END_PARAMETERS;
pub const tagHW_PROFILE_INFOA = struct_tagHW_PROFILE_INFOA;
pub const tagHW_PROFILE_INFOW = struct_tagHW_PROFILE_INFOW;
pub const _TIME_ZONE_INFORMATION = struct__TIME_ZONE_INFORMATION;
pub const _TIME_DYNAMIC_ZONE_INFORMATION = struct__TIME_DYNAMIC_ZONE_INFORMATION;
pub const _SYSTEM_POWER_STATUS = struct__SYSTEM_POWER_STATUS;
pub const tagACTCTXA = struct_tagACTCTXA;
pub const tagACTCTXW = struct_tagACTCTXW;
pub const tagACTCTX_SECTION_KEYED_DATA_2600 = struct_tagACTCTX_SECTION_KEYED_DATA_2600;
pub const tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = struct_tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
pub const tagACTCTX_SECTION_KEYED_DATA = struct_tagACTCTX_SECTION_KEYED_DATA;
pub const _ACTIVATION_CONTEXT_BASIC_INFORMATION = struct__ACTIVATION_CONTEXT_BASIC_INFORMATION;
pub const _FILE_BASIC_INFO = struct__FILE_BASIC_INFO;
pub const _FILE_STANDARD_INFO = struct__FILE_STANDARD_INFO;
pub const _FILE_NAME_INFO = struct__FILE_NAME_INFO;
pub const _FILE_CASE_SENSITIVE_INFO = struct__FILE_CASE_SENSITIVE_INFO;
pub const _FILE_RENAME_INFO = struct__FILE_RENAME_INFO;
pub const _FILE_ALLOCATION_INFO = struct__FILE_ALLOCATION_INFO;
pub const _FILE_END_OF_FILE_INFO = struct__FILE_END_OF_FILE_INFO;
pub const _FILE_STREAM_INFO = struct__FILE_STREAM_INFO;
pub const _FILE_COMPRESSION_INFO = struct__FILE_COMPRESSION_INFO;
pub const _FILE_ATTRIBUTE_TAG_INFO = struct__FILE_ATTRIBUTE_TAG_INFO;
pub const _FILE_DISPOSITION_INFO = struct__FILE_DISPOSITION_INFO;
pub const _FILE_DISPOSITION_INFO_EX = struct__FILE_DISPOSITION_INFO_EX;
pub const _FILE_ID_BOTH_DIR_INFO = struct__FILE_ID_BOTH_DIR_INFO;
pub const _FILE_FULL_DIR_INFO = struct__FILE_FULL_DIR_INFO;
pub const _PRIORITY_HINT = enum__PRIORITY_HINT;
pub const _FILE_IO_PRIORITY_HINT_INFO = struct__FILE_IO_PRIORITY_HINT_INFO;
pub const _FILE_ALIGNMENT_INFO = struct__FILE_ALIGNMENT_INFO;
pub const _FILE_STORAGE_INFO = struct__FILE_STORAGE_INFO;
pub const _FILE_ID_INFO = struct__FILE_ID_INFO;
pub const _FILE_ID_EXTD_DIR_INFO = struct__FILE_ID_EXTD_DIR_INFO;
pub const _FILE_REMOTE_PROTOCOL_INFO = struct__FILE_REMOTE_PROTOCOL_INFO;
pub const _FILE_ID_TYPE = enum__FILE_ID_TYPE;
pub const _DRAWPATRECT = struct__DRAWPATRECT;
pub const _PSINJECTDATA = struct__PSINJECTDATA;
pub const _PSFEATURE_OUTPUT = struct__PSFEATURE_OUTPUT;
pub const _PSFEATURE_CUSTPAPER = struct__PSFEATURE_CUSTPAPER;
pub const tagXFORM = struct_tagXFORM;
pub const tagBITMAP = struct_tagBITMAP;
pub const tagRGBTRIPLE = struct_tagRGBTRIPLE;
pub const tagRGBQUAD = struct_tagRGBQUAD;
pub const tagCIEXYZ = struct_tagCIEXYZ;
pub const tagICEXYZTRIPLE = struct_tagICEXYZTRIPLE;
pub const tagLOGCOLORSPACEA = struct_tagLOGCOLORSPACEA;
pub const tagLOGCOLORSPACEW = struct_tagLOGCOLORSPACEW;
pub const tagBITMAPCOREHEADER = struct_tagBITMAPCOREHEADER;
pub const tagBITMAPINFOHEADER = struct_tagBITMAPINFOHEADER;
pub const tagBITMAPINFO = struct_tagBITMAPINFO;
pub const tagBITMAPCOREINFO = struct_tagBITMAPCOREINFO;
pub const tagBITMAPFILEHEADER = struct_tagBITMAPFILEHEADER;
pub const tagFONTSIGNATURE = struct_tagFONTSIGNATURE;
pub const tagCHARSETINFO = struct_tagCHARSETINFO;
pub const tagLOCALESIGNATURE = struct_tagLOCALESIGNATURE;
pub const tagHANDLETABLE = struct_tagHANDLETABLE;
pub const tagMETARECORD = struct_tagMETARECORD;
pub const tagMETAFILEPICT = struct_tagMETAFILEPICT;
pub const tagMETAHEADER = struct_tagMETAHEADER;
pub const tagENHMETARECORD = struct_tagENHMETARECORD;
pub const tagENHMETAHEADER = struct_tagENHMETAHEADER;
pub const tagTEXTMETRICA = struct_tagTEXTMETRICA;
pub const tagTEXTMETRICW = struct_tagTEXTMETRICW;
pub const tagNEWTEXTMETRICA = struct_tagNEWTEXTMETRICA;
pub const tagNEWTEXTMETRICW = struct_tagNEWTEXTMETRICW;
pub const tagNEWTEXTMETRICEXA = struct_tagNEWTEXTMETRICEXA;
pub const tagNEWTEXTMETRICEXW = struct_tagNEWTEXTMETRICEXW;
pub const tagPELARRAY = struct_tagPELARRAY;
pub const tagLOGBRUSH = struct_tagLOGBRUSH;
pub const tagLOGBRUSH32 = struct_tagLOGBRUSH32;
pub const tagLOGPEN = struct_tagLOGPEN;
pub const tagEXTLOGPEN = struct_tagEXTLOGPEN;
pub const tagEXTLOGPEN32 = struct_tagEXTLOGPEN32;
pub const tagPALETTEENTRY = struct_tagPALETTEENTRY;
pub const tagLOGPALETTE = struct_tagLOGPALETTE;
pub const tagLOGFONTA = struct_tagLOGFONTA;
pub const tagLOGFONTW = struct_tagLOGFONTW;
pub const tagENUMLOGFONTA = struct_tagENUMLOGFONTA;
pub const tagENUMLOGFONTW = struct_tagENUMLOGFONTW;
pub const tagENUMLOGFONTEXA = struct_tagENUMLOGFONTEXA;
pub const tagENUMLOGFONTEXW = struct_tagENUMLOGFONTEXW;
pub const tagPANOSE = struct_tagPANOSE;
pub const tagEXTLOGFONTA = struct_tagEXTLOGFONTA;
pub const tagEXTLOGFONTW = struct_tagEXTLOGFONTW;
pub const _devicemodeA = struct__devicemodeA;
pub const _devicemodeW = struct__devicemodeW;
pub const _DISPLAY_DEVICEA = struct__DISPLAY_DEVICEA;
pub const _DISPLAY_DEVICEW = struct__DISPLAY_DEVICEW;
pub const _DISPLAYCONFIG_COLOR_ENCODING = enum__DISPLAYCONFIG_COLOR_ENCODING;
pub const _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO = struct__DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO;
pub const _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE = struct__DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE;
pub const _DISPLAYCONFIG_SDR_WHITE_LEVEL = struct__DISPLAYCONFIG_SDR_WHITE_LEVEL;
pub const _RGNDATAHEADER = struct__RGNDATAHEADER;
pub const _RGNDATA = struct__RGNDATA;
pub const _ABC = struct__ABC;
pub const _ABCFLOAT = struct__ABCFLOAT;
pub const _OUTLINETEXTMETRICA = struct__OUTLINETEXTMETRICA;
pub const _OUTLINETEXTMETRICW = struct__OUTLINETEXTMETRICW;
pub const tagPOLYTEXTA = struct_tagPOLYTEXTA;
pub const tagPOLYTEXTW = struct_tagPOLYTEXTW;
pub const _FIXED = struct__FIXED;
pub const _MAT2 = struct__MAT2;
pub const _GLYPHMETRICS = struct__GLYPHMETRICS;
pub const tagPOINTFX = struct_tagPOINTFX;
pub const tagTTPOLYCURVE = struct_tagTTPOLYCURVE;
pub const tagTTPOLYGONHEADER = struct_tagTTPOLYGONHEADER;
pub const tagGCP_RESULTSA = struct_tagGCP_RESULTSA;
pub const tagGCP_RESULTSW = struct_tagGCP_RESULTSW;
pub const _RASTERIZER_STATUS = struct__RASTERIZER_STATUS;
pub const tagPIXELFORMATDESCRIPTOR = struct_tagPIXELFORMATDESCRIPTOR;
pub const tagWCRANGE = struct_tagWCRANGE;
pub const tagGLYPHSET = struct_tagGLYPHSET;
pub const tagDESIGNVECTOR = struct_tagDESIGNVECTOR;
pub const tagAXISINFOA = struct_tagAXISINFOA;
pub const tagAXISINFOW = struct_tagAXISINFOW;
pub const tagAXESLISTA = struct_tagAXESLISTA;
pub const tagAXESLISTW = struct_tagAXESLISTW;
pub const tagENUMLOGFONTEXDVA = struct_tagENUMLOGFONTEXDVA;
pub const tagENUMLOGFONTEXDVW = struct_tagENUMLOGFONTEXDVW;
pub const tagENUMTEXTMETRICA = struct_tagENUMTEXTMETRICA;
pub const tagENUMTEXTMETRICW = struct_tagENUMTEXTMETRICW;
pub const _TRIVERTEX = struct__TRIVERTEX;
pub const _GRADIENT_TRIANGLE = struct__GRADIENT_TRIANGLE;
pub const _GRADIENT_RECT = struct__GRADIENT_RECT;
pub const _BLENDFUNCTION = struct__BLENDFUNCTION;
pub const tagDIBSECTION = struct_tagDIBSECTION;
pub const tagCOLORADJUSTMENT = struct_tagCOLORADJUSTMENT;
pub const _DOCINFOA = struct__DOCINFOA;
pub const _DOCINFOW = struct__DOCINFOW;
pub const tagKERNINGPAIR = struct_tagKERNINGPAIR;
pub const tagEMR = struct_tagEMR;
pub const tagEMRTEXT = struct_tagEMRTEXT;
pub const tagABORTPATH = struct_tagABORTPATH;
pub const tagEMRSELECTCLIPPATH = struct_tagEMRSELECTCLIPPATH;
pub const tagEMRSETMITERLIMIT = struct_tagEMRSETMITERLIMIT;
pub const tagEMRRESTOREDC = struct_tagEMRRESTOREDC;
pub const tagEMRSETARCDIRECTION = struct_tagEMRSETARCDIRECTION;
pub const tagEMRSETMAPPERFLAGS = struct_tagEMRSETMAPPERFLAGS;
pub const tagEMRSETTEXTCOLOR = struct_tagEMRSETTEXTCOLOR;
pub const tagEMRSELECTOBJECT = struct_tagEMRSELECTOBJECT;
pub const tagEMRSELECTPALETTE = struct_tagEMRSELECTPALETTE;
pub const tagEMRRESIZEPALETTE = struct_tagEMRRESIZEPALETTE;
pub const tagEMRSETPALETTEENTRIES = struct_tagEMRSETPALETTEENTRIES;
pub const tagEMRSETCOLORADJUSTMENT = struct_tagEMRSETCOLORADJUSTMENT;
pub const tagEMRGDICOMMENT = struct_tagEMRGDICOMMENT;
pub const tagEMREOF = struct_tagEMREOF;
pub const tagEMRLINETO = struct_tagEMRLINETO;
pub const tagEMROFFSETCLIPRGN = struct_tagEMROFFSETCLIPRGN;
pub const tagEMRFILLPATH = struct_tagEMRFILLPATH;
pub const tagEMREXCLUDECLIPRECT = struct_tagEMREXCLUDECLIPRECT;
pub const tagEMRSETVIEWPORTORGEX = struct_tagEMRSETVIEWPORTORGEX;
pub const tagEMRSETVIEWPORTEXTEX = struct_tagEMRSETVIEWPORTEXTEX;
pub const tagEMRSCALEVIEWPORTEXTEX = struct_tagEMRSCALEVIEWPORTEXTEX;
pub const tagEMRSETWORLDTRANSFORM = struct_tagEMRSETWORLDTRANSFORM;
pub const tagEMRMODIFYWORLDTRANSFORM = struct_tagEMRMODIFYWORLDTRANSFORM;
pub const tagEMRSETPIXELV = struct_tagEMRSETPIXELV;
pub const tagEMREXTFLOODFILL = struct_tagEMREXTFLOODFILL;
pub const tagEMRELLIPSE = struct_tagEMRELLIPSE;
pub const tagEMRROUNDRECT = struct_tagEMRROUNDRECT;
pub const tagEMRARC = struct_tagEMRARC;
pub const tagEMRANGLEARC = struct_tagEMRANGLEARC;
pub const tagEMRPOLYLINE = struct_tagEMRPOLYLINE;
pub const tagEMRPOLYLINE16 = struct_tagEMRPOLYLINE16;
pub const tagEMRPOLYDRAW = struct_tagEMRPOLYDRAW;
pub const tagEMRPOLYDRAW16 = struct_tagEMRPOLYDRAW16;
pub const tagEMRPOLYPOLYLINE = struct_tagEMRPOLYPOLYLINE;
pub const tagEMRPOLYPOLYLINE16 = struct_tagEMRPOLYPOLYLINE16;
pub const tagEMRINVERTRGN = struct_tagEMRINVERTRGN;
pub const tagEMRFILLRGN = struct_tagEMRFILLRGN;
pub const tagEMRFRAMERGN = struct_tagEMRFRAMERGN;
pub const tagEMREXTSELECTCLIPRGN = struct_tagEMREXTSELECTCLIPRGN;
pub const tagEMREXTTEXTOUTA = struct_tagEMREXTTEXTOUTA;
pub const tagEMRPOLYTEXTOUTA = struct_tagEMRPOLYTEXTOUTA;
pub const tagEMRBITBLT = struct_tagEMRBITBLT;
pub const tagEMRSTRETCHBLT = struct_tagEMRSTRETCHBLT;
pub const tagEMRMASKBLT = struct_tagEMRMASKBLT;
pub const tagEMRPLGBLT = struct_tagEMRPLGBLT;
pub const tagEMRSETDIBITSTODEVICE = struct_tagEMRSETDIBITSTODEVICE;
pub const tagEMRSTRETCHDIBITS = struct_tagEMRSTRETCHDIBITS;
pub const tagEMREXTCREATEFONTINDIRECTW = struct_tagEMREXTCREATEFONTINDIRECTW;
pub const tagEMRCREATEPALETTE = struct_tagEMRCREATEPALETTE;
pub const tagEMRCREATEPEN = struct_tagEMRCREATEPEN;
pub const tagEMREXTCREATEPEN = struct_tagEMREXTCREATEPEN;
pub const tagEMRCREATEBRUSHINDIRECT = struct_tagEMRCREATEBRUSHINDIRECT;
pub const tagEMRCREATEMONOBRUSH = struct_tagEMRCREATEMONOBRUSH;
pub const tagEMRCREATEDIBPATTERNBRUSHPT = struct_tagEMRCREATEDIBPATTERNBRUSHPT;
pub const tagEMRFORMAT = struct_tagEMRFORMAT;
pub const tagEMRGLSRECORD = struct_tagEMRGLSRECORD;
pub const tagEMRGLSBOUNDEDRECORD = struct_tagEMRGLSBOUNDEDRECORD;
pub const tagEMRPIXELFORMAT = struct_tagEMRPIXELFORMAT;
pub const tagEMRCREATECOLORSPACE = struct_tagEMRCREATECOLORSPACE;
pub const tagEMRSETCOLORSPACE = struct_tagEMRSETCOLORSPACE;
pub const tagEMREXTESCAPE = struct_tagEMREXTESCAPE;
pub const tagEMRNAMEDESCAPE = struct_tagEMRNAMEDESCAPE;
pub const tagEMRSETICMPROFILE = struct_tagEMRSETICMPROFILE;
pub const tagEMRCREATECOLORSPACEW = struct_tagEMRCREATECOLORSPACEW;
pub const tagCOLORMATCHTOTARGET = struct_tagCOLORMATCHTOTARGET;
pub const tagCOLORCORRECTPALETTE = struct_tagCOLORCORRECTPALETTE;
pub const tagEMRALPHABLEND = struct_tagEMRALPHABLEND;
pub const tagEMRGRADIENTFILL = struct_tagEMRGRADIENTFILL;
pub const tagEMRTRANSPARENTBLT = struct_tagEMRTRANSPARENTBLT;
pub const _POINTFLOAT = struct__POINTFLOAT;
pub const _GLYPHMETRICSFLOAT = struct__GLYPHMETRICSFLOAT;
pub const tagLAYERPLANEDESCRIPTOR = struct_tagLAYERPLANEDESCRIPTOR;
pub const _WGLSWAP = struct__WGLSWAP;
pub const tagCREATESTRUCTA = struct_tagCREATESTRUCTA;
pub const tagCBT_CREATEWNDA = struct_tagCBT_CREATEWNDA;
pub const tagCREATESTRUCTW = struct_tagCREATESTRUCTW;
pub const tagCBT_CREATEWNDW = struct_tagCBT_CREATEWNDW;
pub const tagCBTACTIVATESTRUCT = struct_tagCBTACTIVATESTRUCT;
pub const tagWTSSESSION_NOTIFICATION = struct_tagWTSSESSION_NOTIFICATION;
pub const tagEVENTMSG = struct_tagEVENTMSG;
pub const tagCWPSTRUCT = struct_tagCWPSTRUCT;
pub const tagCWPRETSTRUCT = struct_tagCWPRETSTRUCT;
pub const tagKBDLLHOOKSTRUCT = struct_tagKBDLLHOOKSTRUCT;
pub const tagMSLLHOOKSTRUCT = struct_tagMSLLHOOKSTRUCT;
pub const tagDEBUGHOOKINFO = struct_tagDEBUGHOOKINFO;
pub const tagMOUSEHOOKSTRUCT = struct_tagMOUSEHOOKSTRUCT;
pub const tagMOUSEHOOKSTRUCTEX = struct_tagMOUSEHOOKSTRUCTEX;
pub const tagHARDWAREHOOKSTRUCT = struct_tagHARDWAREHOOKSTRUCT;
pub const tagMOUSEMOVEPOINT = struct_tagMOUSEMOVEPOINT;
pub const tagUSEROBJECTFLAGS = struct_tagUSEROBJECTFLAGS;
pub const tagWNDCLASSEXA = struct_tagWNDCLASSEXA;
pub const tagWNDCLASSEXW = struct_tagWNDCLASSEXW;
pub const tagWNDCLASSA = struct_tagWNDCLASSA;
pub const tagWNDCLASSW = struct_tagWNDCLASSW;
pub const tagMSG = struct_tagMSG;
pub const tagMINMAXINFO = struct_tagMINMAXINFO;
pub const tagCOPYDATASTRUCT = struct_tagCOPYDATASTRUCT;
pub const tagMDINEXTMENU = struct_tagMDINEXTMENU;
pub const tagWINDOWPOS = struct_tagWINDOWPOS;
pub const tagNCCALCSIZE_PARAMS = struct_tagNCCALCSIZE_PARAMS;
pub const tagTRACKMOUSEEVENT = struct_tagTRACKMOUSEEVENT;
pub const tagACCEL = struct_tagACCEL;
pub const tagPAINTSTRUCT = struct_tagPAINTSTRUCT;
pub const tagWINDOWPLACEMENT = struct_tagWINDOWPLACEMENT;
pub const tagNMHDR = struct_tagNMHDR;
pub const tagSTYLESTRUCT = struct_tagSTYLESTRUCT;
pub const tagMEASUREITEMSTRUCT = struct_tagMEASUREITEMSTRUCT;
pub const tagDRAWITEMSTRUCT = struct_tagDRAWITEMSTRUCT;
pub const tagDELETEITEMSTRUCT = struct_tagDELETEITEMSTRUCT;
pub const tagCOMPAREITEMSTRUCT = struct_tagCOMPAREITEMSTRUCT;
pub const tagUPDATELAYEREDWINDOWINFO = struct_tagUPDATELAYEREDWINDOWINFO;
pub const tagMOUSEINPUT = struct_tagMOUSEINPUT;
pub const tagKEYBDINPUT = struct_tagKEYBDINPUT;
pub const tagHARDWAREINPUT = struct_tagHARDWAREINPUT;
pub const tagINPUT = struct_tagINPUT;
pub const HTOUCHINPUT__ = struct_HTOUCHINPUT__;
pub const tagTOUCHINPUT = struct_tagTOUCHINPUT;
pub const tagPOINTER_INPUT_TYPE = enum_tagPOINTER_INPUT_TYPE;
pub const tagPOINTER_BUTTON_CHANGE_TYPE = enum_tagPOINTER_BUTTON_CHANGE_TYPE;
pub const tagPOINTER_INFO = struct_tagPOINTER_INFO;
pub const tagPOINTER_TOUCH_INFO = struct_tagPOINTER_TOUCH_INFO;
pub const tagPOINTER_PEN_INFO = struct_tagPOINTER_PEN_INFO;
pub const tagUSAGE_PROPERTIES = struct_tagUSAGE_PROPERTIES;
pub const tagPOINTER_TYPE_INFO = struct_tagPOINTER_TYPE_INFO;
pub const tagINPUT_INJECTION_VALUE = struct_tagINPUT_INJECTION_VALUE;
pub const HSYNTHETICPOINTERDEVICE__ = struct_HSYNTHETICPOINTERDEVICE__;
pub const tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION = struct_tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION;
pub const tagTOUCH_HIT_TESTING_INPUT = struct_tagTOUCH_HIT_TESTING_INPUT;
pub const tagFEEDBACK_TYPE = enum_tagFEEDBACK_TYPE;
pub const tagINPUT_TRANSFORM = struct_tagINPUT_TRANSFORM;
pub const tagLASTINPUTINFO = struct_tagLASTINPUTINFO;
pub const tagTPMPARAMS = struct_tagTPMPARAMS;
pub const tagMENUINFO = struct_tagMENUINFO;
pub const tagMENUGETOBJECTINFO = struct_tagMENUGETOBJECTINFO;
pub const tagMENUITEMINFOA = struct_tagMENUITEMINFOA;
pub const tagMENUITEMINFOW = struct_tagMENUITEMINFOW;
pub const tagDROPSTRUCT = struct_tagDROPSTRUCT;
pub const tagDRAWTEXTPARAMS = struct_tagDRAWTEXTPARAMS;
pub const tagHELPINFO = struct_tagHELPINFO;
pub const tagMSGBOXPARAMSA = struct_tagMSGBOXPARAMSA;
pub const tagMSGBOXPARAMSW = struct_tagMSGBOXPARAMSW;
pub const _ICONINFO = struct__ICONINFO;
pub const tagCURSORSHAPE = struct_tagCURSORSHAPE;
pub const _ICONINFOEXA = struct__ICONINFOEXA;
pub const _ICONINFOEXW = struct__ICONINFOEXW;
pub const tagSCROLLINFO = struct_tagSCROLLINFO;
pub const tagMDICREATESTRUCTA = struct_tagMDICREATESTRUCTA;
pub const tagMDICREATESTRUCTW = struct_tagMDICREATESTRUCTW;
pub const tagCLIENTCREATESTRUCT = struct_tagCLIENTCREATESTRUCT;
pub const tagMULTIKEYHELPA = struct_tagMULTIKEYHELPA;
pub const tagMULTIKEYHELPW = struct_tagMULTIKEYHELPW;
pub const tagHELPWININFOA = struct_tagHELPWININFOA;
pub const tagHELPWININFOW = struct_tagHELPWININFOW;
pub const tagTouchPredictionParameters = struct_tagTouchPredictionParameters;
pub const tagHANDEDNESS = enum_tagHANDEDNESS;
pub const tagNONCLIENTMETRICSA = struct_tagNONCLIENTMETRICSA;
pub const tagNONCLIENTMETRICSW = struct_tagNONCLIENTMETRICSW;
pub const tagMINIMIZEDMETRICS = struct_tagMINIMIZEDMETRICS;
pub const tagICONMETRICSA = struct_tagICONMETRICSA;
pub const tagICONMETRICSW = struct_tagICONMETRICSW;
pub const tagANIMATIONINFO = struct_tagANIMATIONINFO;
pub const tagSERIALKEYSA = struct_tagSERIALKEYSA;
pub const tagSERIALKEYSW = struct_tagSERIALKEYSW;
pub const tagHIGHCONTRASTA = struct_tagHIGHCONTRASTA;
pub const tagHIGHCONTRASTW = struct_tagHIGHCONTRASTW;
pub const _VIDEOPARAMETERS = struct__VIDEOPARAMETERS;
pub const tagFILTERKEYS = struct_tagFILTERKEYS;
pub const tagSTICKYKEYS = struct_tagSTICKYKEYS;
pub const tagMOUSEKEYS = struct_tagMOUSEKEYS;
pub const tagACCESSTIMEOUT = struct_tagACCESSTIMEOUT;
pub const tagSOUNDSENTRYA = struct_tagSOUNDSENTRYA;
pub const tagSOUNDSENTRYW = struct_tagSOUNDSENTRYW;
pub const tagTOGGLEKEYS = struct_tagTOGGLEKEYS;
pub const tagAUDIODESCRIPTION = struct_tagAUDIODESCRIPTION;
pub const tagMONITORINFO = struct_tagMONITORINFO;
pub const tagMONITORINFOEXA = struct_tagMONITORINFOEXA;
pub const tagMONITORINFOEXW = struct_tagMONITORINFOEXW;
pub const tagGUITHREADINFO = struct_tagGUITHREADINFO;
pub const tagCURSORINFO = struct_tagCURSORINFO;
pub const tagWINDOWINFO = struct_tagWINDOWINFO;
pub const tagTITLEBARINFO = struct_tagTITLEBARINFO;
pub const tagTITLEBARINFOEX = struct_tagTITLEBARINFOEX;
pub const tagMENUBARINFO = struct_tagMENUBARINFO;
pub const tagSCROLLBARINFO = struct_tagSCROLLBARINFO;
pub const tagCOMBOBOXINFO = struct_tagCOMBOBOXINFO;
pub const tagALTTABINFO = struct_tagALTTABINFO;
pub const HRAWINPUT__ = struct_HRAWINPUT__;
pub const tagRAWINPUTHEADER = struct_tagRAWINPUTHEADER;
pub const tagRAWMOUSE = struct_tagRAWMOUSE;
pub const tagRAWKEYBOARD = struct_tagRAWKEYBOARD;
pub const tagRAWHID = struct_tagRAWHID;
pub const tagRAWINPUT = struct_tagRAWINPUT;
pub const tagRID_DEVICE_INFO_MOUSE = struct_tagRID_DEVICE_INFO_MOUSE;
pub const tagRID_DEVICE_INFO_KEYBOARD = struct_tagRID_DEVICE_INFO_KEYBOARD;
pub const tagRID_DEVICE_INFO_HID = struct_tagRID_DEVICE_INFO_HID;
pub const tagRID_DEVICE_INFO = struct_tagRID_DEVICE_INFO;
pub const tagRAWINPUTDEVICE = struct_tagRAWINPUTDEVICE;
pub const tagRAWINPUTDEVICELIST = struct_tagRAWINPUTDEVICELIST;
pub const tagPOINTER_DEVICE_TYPE = enum_tagPOINTER_DEVICE_TYPE;
pub const tagPOINTER_DEVICE_INFO = struct_tagPOINTER_DEVICE_INFO;
pub const tagPOINTER_DEVICE_PROPERTY = struct_tagPOINTER_DEVICE_PROPERTY;
pub const tagPOINTER_DEVICE_CURSOR_TYPE = enum_tagPOINTER_DEVICE_CURSOR_TYPE;
pub const tagPOINTER_DEVICE_CURSOR_INFO = struct_tagPOINTER_DEVICE_CURSOR_INFO;
pub const tagCHANGEFILTERSTRUCT = struct_tagCHANGEFILTERSTRUCT;
pub const HGESTUREINFO__ = struct_HGESTUREINFO__;
pub const tagGESTUREINFO = struct_tagGESTUREINFO;
pub const tagGESTURENOTIFYSTRUCT = struct_tagGESTURENOTIFYSTRUCT;
pub const tagGESTURECONFIG = struct_tagGESTURECONFIG;
pub const tagINPUT_MESSAGE_DEVICE_TYPE = enum_tagINPUT_MESSAGE_DEVICE_TYPE;
pub const tagINPUT_MESSAGE_ORIGIN_ID = enum_tagINPUT_MESSAGE_ORIGIN_ID;
pub const tagINPUT_MESSAGE_SOURCE = struct_tagINPUT_MESSAGE_SOURCE;
pub const tagAR_STATE = enum_tagAR_STATE;
pub const _cpinfo = struct__cpinfo;
pub const _cpinfoexA = struct__cpinfoexA;
pub const _cpinfoexW = struct__cpinfoexW;
pub const _numberfmtA = struct__numberfmtA;
pub const _numberfmtW = struct__numberfmtW;
pub const _currencyfmtA = struct__currencyfmtA;
pub const _currencyfmtW = struct__currencyfmtW;
pub const SYSNLS_FUNCTION = enum_SYSNLS_FUNCTION;
pub const _nlsversioninfo = struct__nlsversioninfo;
pub const _nlsversioninfoex = struct__nlsversioninfoex;
pub const SYSGEOTYPE = enum_SYSGEOTYPE;
pub const SYSGEOCLASS = enum_SYSGEOCLASS;
pub const _NORM_FORM = enum__NORM_FORM;
pub const _FILEMUIINFO = struct__FILEMUIINFO;
pub const _COORD = struct__COORD;
pub const _SMALL_RECT = struct__SMALL_RECT;
pub const _KEY_EVENT_RECORD = struct__KEY_EVENT_RECORD;
pub const _MOUSE_EVENT_RECORD = struct__MOUSE_EVENT_RECORD;
pub const _WINDOW_BUFFER_SIZE_RECORD = struct__WINDOW_BUFFER_SIZE_RECORD;
pub const _MENU_EVENT_RECORD = struct__MENU_EVENT_RECORD;
pub const _FOCUS_EVENT_RECORD = struct__FOCUS_EVENT_RECORD;
pub const _INPUT_RECORD = struct__INPUT_RECORD;
pub const _CHAR_INFO = struct__CHAR_INFO;
pub const _CONSOLE_FONT_INFO = struct__CONSOLE_FONT_INFO;
pub const _CONSOLE_READCONSOLE_CONTROL = struct__CONSOLE_READCONSOLE_CONTROL;
pub const _CONSOLE_CURSOR_INFO = struct__CONSOLE_CURSOR_INFO;
pub const _CONSOLE_SCREEN_BUFFER_INFO = struct__CONSOLE_SCREEN_BUFFER_INFO;
pub const _CONSOLE_SCREEN_BUFFER_INFOEX = struct__CONSOLE_SCREEN_BUFFER_INFOEX;
pub const _CONSOLE_FONT_INFOEX = struct__CONSOLE_FONT_INFOEX;
pub const _CONSOLE_SELECTION_INFO = struct__CONSOLE_SELECTION_INFO;
pub const _CONSOLE_HISTORY_INFO = struct__CONSOLE_HISTORY_INFO;
pub const tagVS_FIXEDFILEINFO = struct_tagVS_FIXEDFILEINFO;
pub const val_context = struct_val_context;
pub const pvalueA = struct_pvalueA;
pub const pvalueW = struct_pvalueW;
pub const provider_info = struct_provider_info;
pub const value_entA = struct_value_entA;
pub const value_entW = struct_value_entW;
pub const _NETRESOURCEA = struct__NETRESOURCEA;
pub const _NETRESOURCEW = struct__NETRESOURCEW;
pub const _CONNECTDLGSTRUCTA = struct__CONNECTDLGSTRUCTA;
pub const _CONNECTDLGSTRUCTW = struct__CONNECTDLGSTRUCTW;
pub const _DISCDLGSTRUCTA = struct__DISCDLGSTRUCTA;
pub const _DISCDLGSTRUCTW = struct__DISCDLGSTRUCTW;
pub const _UNIVERSAL_NAME_INFOA = struct__UNIVERSAL_NAME_INFOA;
pub const _UNIVERSAL_NAME_INFOW = struct__UNIVERSAL_NAME_INFOW;
pub const _REMOTE_NAME_INFOA = struct__REMOTE_NAME_INFOA;
pub const _REMOTE_NAME_INFOW = struct__REMOTE_NAME_INFOW;
pub const _NETINFOSTRUCT = struct__NETINFOSTRUCT;
pub const _NETCONNECTINFOSTRUCT = struct__NETCONNECTINFOSTRUCT;
pub const HCONVLIST__ = struct_HCONVLIST__;
pub const HCONV__ = struct_HCONV__;
pub const HSZ__ = struct_HSZ__;
pub const HDDEDATA__ = struct_HDDEDATA__;
pub const tagHSZPAIR = struct_tagHSZPAIR;
pub const tagCONVCONTEXT = struct_tagCONVCONTEXT;
pub const tagCONVINFO = struct_tagCONVINFO;
pub const tagDDEML_MSG_HOOK_DATA = struct_tagDDEML_MSG_HOOK_DATA;
pub const tagMONMSGSTRUCT = struct_tagMONMSGSTRUCT;
pub const tagMONCBSTRUCT = struct_tagMONCBSTRUCT;
pub const tagMONHSZSTRUCTA = struct_tagMONHSZSTRUCTA;
pub const tagMONHSZSTRUCTW = struct_tagMONHSZSTRUCTW;
pub const tagMONERRSTRUCT = struct_tagMONERRSTRUCT;
pub const tagMONLINKSTRUCT = struct_tagMONLINKSTRUCT;
pub const tagMONCONVSTRUCT = struct_tagMONCONVSTRUCT;
pub const tagCRGB = struct_tagCRGB;
pub const mmtime_tag = struct_mmtime_tag;
pub const HDRVR__ = struct_HDRVR__;
pub const tagMCI_GENERIC_PARMS = struct_tagMCI_GENERIC_PARMS;
pub const tagMCI_OPEN_PARMSA = struct_tagMCI_OPEN_PARMSA;
pub const tagMCI_OPEN_PARMSW = struct_tagMCI_OPEN_PARMSW;
pub const tagMCI_PLAY_PARMS = struct_tagMCI_PLAY_PARMS;
pub const tagMCI_SEEK_PARMS = struct_tagMCI_SEEK_PARMS;
pub const tagMCI_STATUS_PARMS = struct_tagMCI_STATUS_PARMS;
pub const tagMCI_INFO_PARMSA = struct_tagMCI_INFO_PARMSA;
pub const tagMCI_INFO_PARMSW = struct_tagMCI_INFO_PARMSW;
pub const tagMCI_GETDEVCAPS_PARMS = struct_tagMCI_GETDEVCAPS_PARMS;
pub const tagMCI_SYSINFO_PARMSA = struct_tagMCI_SYSINFO_PARMSA;
pub const tagMCI_SYSINFO_PARMSW = struct_tagMCI_SYSINFO_PARMSW;
pub const tagMCI_SET_PARMS = struct_tagMCI_SET_PARMS;
pub const tagMCI_BREAK_PARMS = struct_tagMCI_BREAK_PARMS;
pub const tagMCI_SAVE_PARMSA = struct_tagMCI_SAVE_PARMSA;
pub const tagMCI_SAVE_PARMSW = struct_tagMCI_SAVE_PARMSW;
pub const tagMCI_LOAD_PARMSA = struct_tagMCI_LOAD_PARMSA;
pub const tagMCI_LOAD_PARMSW = struct_tagMCI_LOAD_PARMSW;
pub const tagMCI_RECORD_PARMS = struct_tagMCI_RECORD_PARMS;
pub const tagMCI_VD_PLAY_PARMS = struct_tagMCI_VD_PLAY_PARMS;
pub const tagMCI_VD_STEP_PARMS = struct_tagMCI_VD_STEP_PARMS;
pub const tagMCI_VD_ESCAPE_PARMSA = struct_tagMCI_VD_ESCAPE_PARMSA;
pub const tagMCI_VD_ESCAPE_PARMSW = struct_tagMCI_VD_ESCAPE_PARMSW;
pub const tagMCI_WAVE_OPEN_PARMSA = struct_tagMCI_WAVE_OPEN_PARMSA;
pub const tagMCI_WAVE_OPEN_PARMSW = struct_tagMCI_WAVE_OPEN_PARMSW;
pub const tagMCI_WAVE_DELETE_PARMS = struct_tagMCI_WAVE_DELETE_PARMS;
pub const tagMCI_WAVE_SET_PARMS = struct_tagMCI_WAVE_SET_PARMS;
pub const tagMCI_SEQ_SET_PARMS = struct_tagMCI_SEQ_SET_PARMS;
pub const tagMCI_ANIM_OPEN_PARMSA = struct_tagMCI_ANIM_OPEN_PARMSA;
pub const tagMCI_ANIM_OPEN_PARMSW = struct_tagMCI_ANIM_OPEN_PARMSW;
pub const tagMCI_ANIM_PLAY_PARMS = struct_tagMCI_ANIM_PLAY_PARMS;
pub const tagMCI_ANIM_STEP_PARMS = struct_tagMCI_ANIM_STEP_PARMS;
pub const tagMCI_ANIM_WINDOW_PARMSA = struct_tagMCI_ANIM_WINDOW_PARMSA;
pub const tagMCI_ANIM_WINDOW_PARMSW = struct_tagMCI_ANIM_WINDOW_PARMSW;
pub const tagMCI_ANIM_RECT_PARMS = struct_tagMCI_ANIM_RECT_PARMS;
pub const tagMCI_ANIM_UPDATE_PARMS = struct_tagMCI_ANIM_UPDATE_PARMS;
pub const tagMCI_OVLY_OPEN_PARMSA = struct_tagMCI_OVLY_OPEN_PARMSA;
pub const tagMCI_OVLY_OPEN_PARMSW = struct_tagMCI_OVLY_OPEN_PARMSW;
pub const tagMCI_OVLY_WINDOW_PARMSA = struct_tagMCI_OVLY_WINDOW_PARMSA;
pub const tagMCI_OVLY_WINDOW_PARMSW = struct_tagMCI_OVLY_WINDOW_PARMSW;
pub const tagMCI_OVLY_RECT_PARMS = struct_tagMCI_OVLY_RECT_PARMS;
pub const tagMCI_OVLY_SAVE_PARMSA = struct_tagMCI_OVLY_SAVE_PARMSA;
pub const tagMCI_OVLY_SAVE_PARMSW = struct_tagMCI_OVLY_SAVE_PARMSW;
pub const tagMCI_OVLY_LOAD_PARMSA = struct_tagMCI_OVLY_LOAD_PARMSA;
pub const tagMCI_OVLY_LOAD_PARMSW = struct_tagMCI_OVLY_LOAD_PARMSW;
pub const tagDRVCONFIGINFO = struct_tagDRVCONFIGINFO;
pub const HMMIO__ = struct_HMMIO__;
pub const _MMIOINFO = struct__MMIOINFO;
pub const _MMCKINFO = struct__MMCKINFO;
pub const HWAVE__ = struct_HWAVE__;
pub const HWAVEIN__ = struct_HWAVEIN__;
pub const HWAVEOUT__ = struct_HWAVEOUT__;
pub const wavehdr_tag = struct_wavehdr_tag;
pub const tagWAVEOUTCAPSA = struct_tagWAVEOUTCAPSA;
pub const tagWAVEOUTCAPSW = struct_tagWAVEOUTCAPSW;
pub const tagWAVEOUTCAPS2A = struct_tagWAVEOUTCAPS2A;
pub const tagWAVEOUTCAPS2W = struct_tagWAVEOUTCAPS2W;
pub const tagWAVEINCAPSA = struct_tagWAVEINCAPSA;
pub const tagWAVEINCAPSW = struct_tagWAVEINCAPSW;
pub const tagWAVEINCAPS2A = struct_tagWAVEINCAPS2A;
pub const tagWAVEINCAPS2W = struct_tagWAVEINCAPS2W;
pub const waveformat_tag = struct_waveformat_tag;
pub const pcmwaveformat_tag = struct_pcmwaveformat_tag;
pub const tWAVEFORMATEX = struct_tWAVEFORMATEX;
pub const HMIDI__ = struct_HMIDI__;
pub const HMIDIIN__ = struct_HMIDIIN__;
pub const HMIDIOUT__ = struct_HMIDIOUT__;
pub const HMIDISTRM__ = struct_HMIDISTRM__;
pub const tagMIDIOUTCAPSA = struct_tagMIDIOUTCAPSA;
pub const tagMIDIOUTCAPSW = struct_tagMIDIOUTCAPSW;
pub const tagMIDIOUTCAPS2A = struct_tagMIDIOUTCAPS2A;
pub const tagMIDIOUTCAPS2W = struct_tagMIDIOUTCAPS2W;
pub const tagMIDIINCAPSA = struct_tagMIDIINCAPSA;
pub const tagMIDIINCAPSW = struct_tagMIDIINCAPSW;
pub const tagMIDIINCAPS2A = struct_tagMIDIINCAPS2A;
pub const tagMIDIINCAPS2W = struct_tagMIDIINCAPS2W;
pub const midihdr_tag = struct_midihdr_tag;
pub const midievent_tag = struct_midievent_tag;
pub const midistrmbuffver_tag = struct_midistrmbuffver_tag;
pub const midiproptimediv_tag = struct_midiproptimediv_tag;
pub const midiproptempo_tag = struct_midiproptempo_tag;
pub const tagAUXCAPSA = struct_tagAUXCAPSA;
pub const tagAUXCAPSW = struct_tagAUXCAPSW;
pub const tagAUXCAPS2A = struct_tagAUXCAPS2A;
pub const tagAUXCAPS2W = struct_tagAUXCAPS2W;
pub const HMIXEROBJ__ = struct_HMIXEROBJ__;
pub const HMIXER__ = struct_HMIXER__;
pub const tagMIXERCAPSA = struct_tagMIXERCAPSA;
pub const tagMIXERCAPSW = struct_tagMIXERCAPSW;
pub const tagMIXERCAPS2A = struct_tagMIXERCAPS2A;
pub const tagMIXERCAPS2W = struct_tagMIXERCAPS2W;
pub const tagMIXERLINEA = struct_tagMIXERLINEA;
pub const tagMIXERLINEW = struct_tagMIXERLINEW;
pub const tagMIXERCONTROLA = struct_tagMIXERCONTROLA;
pub const tagMIXERCONTROLW = struct_tagMIXERCONTROLW;
pub const tagMIXERLINECONTROLSA = struct_tagMIXERLINECONTROLSA;
pub const tagMIXERLINECONTROLSW = struct_tagMIXERLINECONTROLSW;
pub const tMIXERCONTROLDETAILS = struct_tMIXERCONTROLDETAILS;
pub const tagMIXERCONTROLDETAILS_LISTTEXTA = struct_tagMIXERCONTROLDETAILS_LISTTEXTA;
pub const tagMIXERCONTROLDETAILS_LISTTEXTW = struct_tagMIXERCONTROLDETAILS_LISTTEXTW;
pub const tMIXERCONTROLDETAILS_BOOLEAN = struct_tMIXERCONTROLDETAILS_BOOLEAN;
pub const tMIXERCONTROLDETAILS_SIGNED = struct_tMIXERCONTROLDETAILS_SIGNED;
pub const tMIXERCONTROLDETAILS_UNSIGNED = struct_tMIXERCONTROLDETAILS_UNSIGNED;
pub const timecaps_tag = struct_timecaps_tag;
pub const tagJOYCAPSA = struct_tagJOYCAPSA;
pub const tagJOYCAPSW = struct_tagJOYCAPSW;
pub const tagJOYCAPS2A = struct_tagJOYCAPS2A;
pub const tagJOYCAPS2W = struct_tagJOYCAPS2W;
pub const joyinfo_tag = struct_joyinfo_tag;
pub const joyinfoex_tag = struct_joyinfoex_tag;
pub const _NCB = struct__NCB;
pub const _ADAPTER_STATUS = struct__ADAPTER_STATUS;
pub const _NAME_BUFFER = struct__NAME_BUFFER;
pub const _SESSION_HEADER = struct__SESSION_HEADER;
pub const _SESSION_BUFFER = struct__SESSION_BUFFER;
pub const _LANA_ENUM = struct__LANA_ENUM;
pub const _FIND_NAME_HEADER = struct__FIND_NAME_HEADER;
pub const _FIND_NAME_BUFFER = struct__FIND_NAME_BUFFER;
pub const _ACTION_HEADER = struct__ACTION_HEADER;
pub const _RPC_BINDING_VECTOR = struct__RPC_BINDING_VECTOR;
pub const _UUID_VECTOR = struct__UUID_VECTOR;
pub const _RPC_IF_ID = struct__RPC_IF_ID;
pub const _RPC_PROTSEQ_VECTORA = struct__RPC_PROTSEQ_VECTORA;
pub const _RPC_PROTSEQ_VECTORW = struct__RPC_PROTSEQ_VECTORW;
pub const _RPC_POLICY = struct__RPC_POLICY;
pub const _RPC_SECURITY_QOS = struct__RPC_SECURITY_QOS;
pub const _SEC_WINNT_AUTH_IDENTITY_W = struct__SEC_WINNT_AUTH_IDENTITY_W;
pub const _SEC_WINNT_AUTH_IDENTITY_A = struct__SEC_WINNT_AUTH_IDENTITY_A;
pub const _RPC_HTTP_TRANSPORT_CREDENTIALS_W = struct__RPC_HTTP_TRANSPORT_CREDENTIALS_W;
pub const _RPC_HTTP_TRANSPORT_CREDENTIALS_A = struct__RPC_HTTP_TRANSPORT_CREDENTIALS_A;
pub const _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W = struct__RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W;
pub const _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A = struct__RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A;
pub const _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W = struct__RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W;
pub const _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A = struct__RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A;
pub const _RPC_SECURITY_QOS_V2_W = struct__RPC_SECURITY_QOS_V2_W;
pub const _RPC_SECURITY_QOS_V2_A = struct__RPC_SECURITY_QOS_V2_A;
pub const _RPC_SECURITY_QOS_V3_W = struct__RPC_SECURITY_QOS_V3_W;
pub const _RPC_SECURITY_QOS_V3_A = struct__RPC_SECURITY_QOS_V3_A;
pub const _RPC_SECURITY_QOS_V4_W = struct__RPC_SECURITY_QOS_V4_W;
pub const _RPC_SECURITY_QOS_V4_A = struct__RPC_SECURITY_QOS_V4_A;
pub const _RPC_SECURITY_QOS_V5_W = struct__RPC_SECURITY_QOS_V5_W;
pub const _RPC_SECURITY_QOS_V5_A = struct__RPC_SECURITY_QOS_V5_A;
pub const _RPC_BINDING_HANDLE_TEMPLATE_V1_W = struct__RPC_BINDING_HANDLE_TEMPLATE_V1_W;
pub const _RPC_BINDING_HANDLE_TEMPLATE_V1_A = struct__RPC_BINDING_HANDLE_TEMPLATE_V1_A;
pub const _RPC_BINDING_HANDLE_SECURITY_V1_W = struct__RPC_BINDING_HANDLE_SECURITY_V1_W;
pub const _RPC_BINDING_HANDLE_SECURITY_V1_A = struct__RPC_BINDING_HANDLE_SECURITY_V1_A;
pub const _RPC_BINDING_HANDLE_OPTIONS_V1 = struct__RPC_BINDING_HANDLE_OPTIONS_V1;
pub const _RPC_HTTP_REDIRECTOR_STAGE = enum__RPC_HTTP_REDIRECTOR_STAGE;
pub const _RPC_VERSION = struct__RPC_VERSION;
pub const _RPC_SYNTAX_IDENTIFIER = struct__RPC_SYNTAX_IDENTIFIER;
pub const _RPC_MESSAGE = struct__RPC_MESSAGE;
pub const RPC_ADDRESS_CHANGE_TYPE = enum_RPC_ADDRESS_CHANGE_TYPE;
pub const _RPC_PROTSEQ_ENDPOINT = struct__RPC_PROTSEQ_ENDPOINT;
pub const _RPC_SERVER_INTERFACE = struct__RPC_SERVER_INTERFACE;
pub const _RPC_CLIENT_INTERFACE = struct__RPC_CLIENT_INTERFACE;
pub const _LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION = enum__LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION;
pub const _RPC_SEC_CONTEXT_KEY_INFO = struct__RPC_SEC_CONTEXT_KEY_INFO;
pub const _RPC_TRANSFER_SYNTAX = struct__RPC_TRANSFER_SYNTAX;
pub const _RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR = struct__RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR;
pub const _RDR_CALLOUT_STATE = struct__RDR_CALLOUT_STATE;
pub const RpcProxyPerfCounters = enum_RpcProxyPerfCounters;
pub const tagI_RpcProxyCallbackInterface = struct_tagI_RpcProxyCallbackInterface;
pub const _RPC_NOTIFICATION_TYPES = enum__RPC_NOTIFICATION_TYPES;
pub const _RPC_ASYNC_EVENT = enum__RPC_ASYNC_EVENT;
pub const _RPC_ASYNC_NOTIFICATION_INFO = union__RPC_ASYNC_NOTIFICATION_INFO;
pub const _RPC_ASYNC_STATE = struct__RPC_ASYNC_STATE;
pub const tagExtendedErrorParamTypes = enum_tagExtendedErrorParamTypes;
pub const tagBinaryParam = struct_tagBinaryParam;
pub const tagRPC_EE_INFO_PARAM = struct_tagRPC_EE_INFO_PARAM;
pub const tagRPC_EXTENDED_ERROR_INFO = struct_tagRPC_EXTENDED_ERROR_INFO;
pub const tagRPC_ERROR_ENUM_HANDLE = struct_tagRPC_ERROR_ENUM_HANDLE;
pub const tagRpcLocalAddressFormat = enum_tagRpcLocalAddressFormat;
pub const _RPC_CALL_LOCAL_ADDRESS_V1 = struct__RPC_CALL_LOCAL_ADDRESS_V1;
pub const tagRPC_CALL_ATTRIBUTES_V1_W = struct_tagRPC_CALL_ATTRIBUTES_V1_W;
pub const tagRPC_CALL_ATTRIBUTES_V1_A = struct_tagRPC_CALL_ATTRIBUTES_V1_A;
pub const tagRpcCallType = enum_tagRpcCallType;
pub const tagRpcCallClientLocality = enum_tagRpcCallClientLocality;
pub const tagRPC_CALL_ATTRIBUTES_V2_W = struct_tagRPC_CALL_ATTRIBUTES_V2_W;
pub const tagRPC_CALL_ATTRIBUTES_V2_A = struct_tagRPC_CALL_ATTRIBUTES_V2_A;
pub const tagRPC_CALL_ATTRIBUTES_V3_W = struct_tagRPC_CALL_ATTRIBUTES_V3_W;
pub const tagRPC_CALL_ATTRIBUTES_V3_A = struct_tagRPC_CALL_ATTRIBUTES_V3_A;
pub const _RPC_NOTIFICATIONS = enum__RPC_NOTIFICATIONS;
pub const HDROP__ = struct_HDROP__;
pub const _DRAGINFOA = struct__DRAGINFOA;
pub const _DRAGINFOW = struct__DRAGINFOW;
pub const _AppBarData = struct__AppBarData;
pub const _SHFILEOPSTRUCTA = struct__SHFILEOPSTRUCTA;
pub const _SHFILEOPSTRUCTW = struct__SHFILEOPSTRUCTW;
pub const _SHNAMEMAPPINGA = struct__SHNAMEMAPPINGA;
pub const _SHNAMEMAPPINGW = struct__SHNAMEMAPPINGW;
pub const _SHELLEXECUTEINFOA = struct__SHELLEXECUTEINFOA;
pub const _SHELLEXECUTEINFOW = struct__SHELLEXECUTEINFOW;
pub const _SHCREATEPROCESSINFOW = struct__SHCREATEPROCESSINFOW;
pub const _SHQUERYRBINFO = struct__SHQUERYRBINFO;
pub const _NOTIFYICONDATAA = struct__NOTIFYICONDATAA;
pub const _NOTIFYICONDATAW = struct__NOTIFYICONDATAW;
pub const _NOTIFYICONIDENTIFIER = struct__NOTIFYICONIDENTIFIER;
pub const _SHFILEINFOA = struct__SHFILEINFOA;
pub const _SHFILEINFOW = struct__SHFILEINFOW;
pub const _SHSTOCKICONINFO = struct__SHSTOCKICONINFO;
pub const _OPEN_PRINTER_PROPS_INFOA = struct__OPEN_PRINTER_PROPS_INFOA;
pub const _OPEN_PRINTER_PROPS_INFOW = struct__OPEN_PRINTER_PROPS_INFOW;
pub const NET_ADDRESS_INFO_ = struct_NET_ADDRESS_INFO_;
pub const tagNC_ADDRESS = struct_tagNC_ADDRESS;
pub const _PERF_DATA_BLOCK = struct__PERF_DATA_BLOCK;
pub const _PERF_OBJECT_TYPE = struct__PERF_OBJECT_TYPE;
pub const _PERF_COUNTER_DEFINITION = struct__PERF_COUNTER_DEFINITION;
pub const _PERF_INSTANCE_DEFINITION = struct__PERF_INSTANCE_DEFINITION;
pub const _PERF_COUNTER_BLOCK = struct__PERF_COUNTER_BLOCK;
pub const timeval = struct_timeval;
pub const hostent = struct_hostent;
pub const netent = struct_netent;
pub const servent = struct_servent;
pub const protoent = struct_protoent;
pub const in_addr = struct_in_addr;
pub const sockaddr_in = struct_sockaddr_in;
pub const WSAData = struct_WSAData;
pub const ip_mreq = struct_ip_mreq;
pub const sockaddr = struct_sockaddr;
pub const sockproto = struct_sockproto;
pub const linger = struct_linger;
pub const _TRANSMIT_FILE_BUFFERS = struct__TRANSMIT_FILE_BUFFERS;
pub const _CMS_KEY_INFO = struct__CMS_KEY_INFO;
pub const _HMAC_Info = struct__HMAC_Info;
pub const _SCHANNEL_ALG = struct__SCHANNEL_ALG;
pub const _PROV_ENUMALGS = struct__PROV_ENUMALGS;
pub const _PROV_ENUMALGS_EX = struct__PROV_ENUMALGS_EX;
pub const _PUBLICKEYSTRUC = struct__PUBLICKEYSTRUC;
pub const _RSAPUBKEY = struct__RSAPUBKEY;
pub const _PUBKEY = struct__PUBKEY;
pub const _DSSSEED = struct__DSSSEED;
pub const _PUBKEYVER3 = struct__PUBKEYVER3;
pub const _PRIVKEYVER3 = struct__PRIVKEYVER3;
pub const _KEY_TYPE_SUBTYPE = struct__KEY_TYPE_SUBTYPE;
pub const _CERT_FORTEZZA_DATA_PROP = struct__CERT_FORTEZZA_DATA_PROP;
pub const _CRYPT_RC4_KEY_STATE = struct__CRYPT_RC4_KEY_STATE;
pub const _CRYPT_DES_KEY_STATE = struct__CRYPT_DES_KEY_STATE;
pub const _CRYPT_3DES_KEY_STATE = struct__CRYPT_3DES_KEY_STATE;
pub const _CRYPT_AES_128_KEY_STATE = struct__CRYPT_AES_128_KEY_STATE;
pub const _CRYPT_AES_256_KEY_STATE = struct__CRYPT_AES_256_KEY_STATE;
pub const _CRYPTOAPI_BLOB = struct__CRYPTOAPI_BLOB;
pub const _CMS_DH_KEY_INFO = struct__CMS_DH_KEY_INFO;
pub const __BCRYPT_KEY_LENGTHS_STRUCT = struct___BCRYPT_KEY_LENGTHS_STRUCT;
pub const _BCRYPT_OID = struct__BCRYPT_OID;
pub const _BCRYPT_OID_LIST = struct__BCRYPT_OID_LIST;
pub const _BCRYPT_PKCS1_PADDING_INFO = struct__BCRYPT_PKCS1_PADDING_INFO;
pub const _BCRYPT_PSS_PADDING_INFO = struct__BCRYPT_PSS_PADDING_INFO;
pub const _BCRYPT_OAEP_PADDING_INFO = struct__BCRYPT_OAEP_PADDING_INFO;
pub const _BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO = struct__BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO;
pub const _BCryptBuffer = struct__BCryptBuffer;
pub const _BCryptBufferDesc = struct__BCryptBufferDesc;
pub const _BCRYPT_KEY_BLOB = struct__BCRYPT_KEY_BLOB;
pub const _BCRYPT_RSAKEY_BLOB = struct__BCRYPT_RSAKEY_BLOB;
pub const _BCRYPT_ECCKEY_BLOB = struct__BCRYPT_ECCKEY_BLOB;
pub const _SSL_ECCKEY_BLOB = struct__SSL_ECCKEY_BLOB;
pub const _BCRYPT_ECCFULLKEY_BLOB = struct__BCRYPT_ECCFULLKEY_BLOB;
pub const _BCRYPT_DH_KEY_BLOB = struct__BCRYPT_DH_KEY_BLOB;
pub const _BCRYPT_DH_PARAMETER_HEADER = struct__BCRYPT_DH_PARAMETER_HEADER;
pub const _BCRYPT_DSA_KEY_BLOB = struct__BCRYPT_DSA_KEY_BLOB;
pub const _BCRYPT_DSA_KEY_BLOB_V2 = struct__BCRYPT_DSA_KEY_BLOB_V2;
pub const _BCRYPT_KEY_DATA_BLOB_HEADER = struct__BCRYPT_KEY_DATA_BLOB_HEADER;
pub const _BCRYPT_DSA_PARAMETER_HEADER = struct__BCRYPT_DSA_PARAMETER_HEADER;
pub const _BCRYPT_DSA_PARAMETER_HEADER_V2 = struct__BCRYPT_DSA_PARAMETER_HEADER_V2;
pub const _BCRYPT_ECC_CURVE_NAMES = struct__BCRYPT_ECC_CURVE_NAMES;
pub const _BCRYPT_MULTI_HASH_OPERATION = struct__BCRYPT_MULTI_HASH_OPERATION;
pub const _BCRYPT_MULTI_OBJECT_LENGTH_STRUCT = struct__BCRYPT_MULTI_OBJECT_LENGTH_STRUCT;
pub const _BCRYPT_ALGORITHM_IDENTIFIER = struct__BCRYPT_ALGORITHM_IDENTIFIER;
pub const _BCRYPT_PROVIDER_NAME = struct__BCRYPT_PROVIDER_NAME;
pub const _BCRYPT_INTERFACE_VERSION = struct__BCRYPT_INTERFACE_VERSION;
pub const _CRYPT_INTERFACE_REG = struct__CRYPT_INTERFACE_REG;
pub const _CRYPT_IMAGE_REG = struct__CRYPT_IMAGE_REG;
pub const _CRYPT_PROVIDER_REG = struct__CRYPT_PROVIDER_REG;
pub const _CRYPT_PROVIDERS = struct__CRYPT_PROVIDERS;
pub const _CRYPT_CONTEXT_CONFIG = struct__CRYPT_CONTEXT_CONFIG;
pub const _CRYPT_CONTEXT_FUNCTION_CONFIG = struct__CRYPT_CONTEXT_FUNCTION_CONFIG;
pub const _CRYPT_CONTEXTS = struct__CRYPT_CONTEXTS;
pub const _CRYPT_CONTEXT_FUNCTIONS = struct__CRYPT_CONTEXT_FUNCTIONS;
pub const _CRYPT_CONTEXT_FUNCTION_PROVIDERS = struct__CRYPT_CONTEXT_FUNCTION_PROVIDERS;
pub const _CRYPT_PROPERTY_REF = struct__CRYPT_PROPERTY_REF;
pub const _CRYPT_IMAGE_REF = struct__CRYPT_IMAGE_REF;
pub const _CRYPT_PROVIDER_REF = struct__CRYPT_PROVIDER_REF;
pub const _CRYPT_PROVIDER_REFS = struct__CRYPT_PROVIDER_REFS;
pub const _NCRYPT_CIPHER_PADDING_INFO = struct__NCRYPT_CIPHER_PADDING_INFO;
pub const _NCRYPT_PLATFORM_ATTEST_PADDING_INFO = struct__NCRYPT_PLATFORM_ATTEST_PADDING_INFO;
pub const _NCRYPT_KEY_ATTEST_PADDING_INFO = struct__NCRYPT_KEY_ATTEST_PADDING_INFO;
pub const _NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES = struct__NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES;
pub const _NCRYPT_VSM_KEY_ATTESTATION_STATEMENT = struct__NCRYPT_VSM_KEY_ATTESTATION_STATEMENT;
pub const _NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = struct__NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS;
pub const _NCRYPT_EXPORTED_ISOLATED_KEY_HEADER = struct__NCRYPT_EXPORTED_ISOLATED_KEY_HEADER;
pub const _NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE = struct__NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE;
pub const __NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT = struct___NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT;
pub const _NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT = struct__NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT;
pub const _NCryptAlgorithmName = struct__NCryptAlgorithmName;
pub const __NCRYPT_UI_POLICY = struct___NCRYPT_UI_POLICY;
pub const __NCRYPT_KEY_ACCESS_POLICY_BLOB = struct___NCRYPT_KEY_ACCESS_POLICY_BLOB;
pub const __NCRYPT_SUPPORTED_LENGTHS = struct___NCRYPT_SUPPORTED_LENGTHS;
pub const __NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO = struct___NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO;
pub const __NCRYPT_PCP_TPM_FW_VERSION_INFO = struct___NCRYPT_PCP_TPM_FW_VERSION_INFO;
pub const __NCRYPT_PCP_RAW_POLICYDIGEST = struct___NCRYPT_PCP_RAW_POLICYDIGEST;
pub const _NCRYPT_KEY_BLOB_HEADER = struct__NCRYPT_KEY_BLOB_HEADER;
pub const _CRYPT_BIT_BLOB = struct__CRYPT_BIT_BLOB;
pub const _CRYPT_ALGORITHM_IDENTIFIER = struct__CRYPT_ALGORITHM_IDENTIFIER;
pub const _CRYPT_OBJID_TABLE = struct__CRYPT_OBJID_TABLE;
pub const _CRYPT_HASH_INFO = struct__CRYPT_HASH_INFO;
pub const _CERT_EXTENSION = struct__CERT_EXTENSION;
pub const _CRYPT_ATTRIBUTE_TYPE_VALUE = struct__CRYPT_ATTRIBUTE_TYPE_VALUE;
pub const _CRYPT_ATTRIBUTE = struct__CRYPT_ATTRIBUTE;
pub const _CRYPT_ATTRIBUTES = struct__CRYPT_ATTRIBUTES;
pub const _CERT_RDN_ATTR = struct__CERT_RDN_ATTR;
pub const _CERT_RDN = struct__CERT_RDN;
pub const _CERT_NAME_INFO = struct__CERT_NAME_INFO;
pub const _CERT_NAME_VALUE = struct__CERT_NAME_VALUE;
pub const _CERT_PUBLIC_KEY_INFO = struct__CERT_PUBLIC_KEY_INFO;
pub const _CRYPT_ECC_PRIVATE_KEY_INFO = struct__CRYPT_ECC_PRIVATE_KEY_INFO;
pub const _CRYPT_PRIVATE_KEY_INFO = struct__CRYPT_PRIVATE_KEY_INFO;
pub const _CRYPT_ENCRYPTED_PRIVATE_KEY_INFO = struct__CRYPT_ENCRYPTED_PRIVATE_KEY_INFO;
pub const _CRYPT_PKCS8_IMPORT_PARAMS = struct__CRYPT_PKCS8_IMPORT_PARAMS;
pub const _CRYPT_PKCS8_EXPORT_PARAMS = struct__CRYPT_PKCS8_EXPORT_PARAMS;
pub const _CERT_INFO = struct__CERT_INFO;
pub const _CRL_ENTRY = struct__CRL_ENTRY;
pub const _CRL_INFO = struct__CRL_INFO;
pub const _CERT_OR_CRL_BLOB = struct__CERT_OR_CRL_BLOB;
pub const _CERT_OR_CRL_BUNDLE = struct__CERT_OR_CRL_BUNDLE;
pub const _CERT_REQUEST_INFO = struct__CERT_REQUEST_INFO;
pub const _CERT_KEYGEN_REQUEST_INFO = struct__CERT_KEYGEN_REQUEST_INFO;
pub const _CERT_SIGNED_CONTENT_INFO = struct__CERT_SIGNED_CONTENT_INFO;
pub const _CTL_USAGE = struct__CTL_USAGE;
pub const _CTL_ENTRY = struct__CTL_ENTRY;
pub const _CTL_INFO = struct__CTL_INFO;
pub const _CRYPT_TIME_STAMP_REQUEST_INFO = struct__CRYPT_TIME_STAMP_REQUEST_INFO;
pub const _CRYPT_ENROLLMENT_NAME_VALUE_PAIR = struct__CRYPT_ENROLLMENT_NAME_VALUE_PAIR;
pub const _CRYPT_CSP_PROVIDER = struct__CRYPT_CSP_PROVIDER;
pub const _CRYPT_ENCODE_PARA = struct__CRYPT_ENCODE_PARA;
pub const _CRYPT_DECODE_PARA = struct__CRYPT_DECODE_PARA;
pub const _CERT_EXTENSIONS = struct__CERT_EXTENSIONS;
pub const _CERT_AUTHORITY_KEY_ID_INFO = struct__CERT_AUTHORITY_KEY_ID_INFO;
pub const _CERT_PRIVATE_KEY_VALIDITY = struct__CERT_PRIVATE_KEY_VALIDITY;
pub const _CERT_KEY_ATTRIBUTES_INFO = struct__CERT_KEY_ATTRIBUTES_INFO;
pub const _CERT_POLICY_ID = struct__CERT_POLICY_ID;
pub const _CERT_KEY_USAGE_RESTRICTION_INFO = struct__CERT_KEY_USAGE_RESTRICTION_INFO;
pub const _CERT_OTHER_NAME = struct__CERT_OTHER_NAME;
pub const _CERT_ALT_NAME_ENTRY = struct__CERT_ALT_NAME_ENTRY;
pub const _CERT_ALT_NAME_INFO = struct__CERT_ALT_NAME_INFO;
pub const _CERT_BASIC_CONSTRAINTS_INFO = struct__CERT_BASIC_CONSTRAINTS_INFO;
pub const _CERT_BASIC_CONSTRAINTS2_INFO = struct__CERT_BASIC_CONSTRAINTS2_INFO;
pub const _CERT_POLICY_QUALIFIER_INFO = struct__CERT_POLICY_QUALIFIER_INFO;
pub const _CERT_POLICY_INFO = struct__CERT_POLICY_INFO;
pub const _CERT_POLICIES_INFO = struct__CERT_POLICIES_INFO;
pub const _CERT_POLICY_QUALIFIER_NOTICE_REFERENCE = struct__CERT_POLICY_QUALIFIER_NOTICE_REFERENCE;
pub const _CERT_POLICY_QUALIFIER_USER_NOTICE = struct__CERT_POLICY_QUALIFIER_USER_NOTICE;
pub const _CPS_URLS = struct__CPS_URLS;
pub const _CERT_POLICY95_QUALIFIER1 = struct__CERT_POLICY95_QUALIFIER1;
pub const _CERT_POLICY_MAPPING = struct__CERT_POLICY_MAPPING;
pub const _CERT_POLICY_MAPPINGS_INFO = struct__CERT_POLICY_MAPPINGS_INFO;
pub const _CERT_POLICY_CONSTRAINTS_INFO = struct__CERT_POLICY_CONSTRAINTS_INFO;
pub const _CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = struct__CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY;
pub const _CRYPT_CONTENT_INFO = struct__CRYPT_CONTENT_INFO;
pub const _CRYPT_SEQUENCE_OF_ANY = struct__CRYPT_SEQUENCE_OF_ANY;
pub const _CERT_AUTHORITY_KEY_ID2_INFO = struct__CERT_AUTHORITY_KEY_ID2_INFO;
pub const _CERT_ACCESS_DESCRIPTION = struct__CERT_ACCESS_DESCRIPTION;
pub const _CERT_AUTHORITY_INFO_ACCESS = struct__CERT_AUTHORITY_INFO_ACCESS;
pub const _CRL_DIST_POINT_NAME = struct__CRL_DIST_POINT_NAME;
pub const _CRL_DIST_POINT = struct__CRL_DIST_POINT;
pub const _CRL_DIST_POINTS_INFO = struct__CRL_DIST_POINTS_INFO;
pub const _CROSS_CERT_DIST_POINTS_INFO = struct__CROSS_CERT_DIST_POINTS_INFO;
pub const _CERT_PAIR = struct__CERT_PAIR;
pub const _CRL_ISSUING_DIST_POINT = struct__CRL_ISSUING_DIST_POINT;
pub const _CERT_GENERAL_SUBTREE = struct__CERT_GENERAL_SUBTREE;
pub const _CERT_NAME_CONSTRAINTS_INFO = struct__CERT_NAME_CONSTRAINTS_INFO;
pub const _CERT_DSS_PARAMETERS = struct__CERT_DSS_PARAMETERS;
pub const _CERT_DH_PARAMETERS = struct__CERT_DH_PARAMETERS;
pub const _CERT_ECC_SIGNATURE = struct__CERT_ECC_SIGNATURE;
pub const _CERT_X942_DH_VALIDATION_PARAMS = struct__CERT_X942_DH_VALIDATION_PARAMS;
pub const _CERT_X942_DH_PARAMETERS = struct__CERT_X942_DH_PARAMETERS;
pub const _CRYPT_X942_OTHER_INFO = struct__CRYPT_X942_OTHER_INFO;
pub const _CRYPT_ECC_CMS_SHARED_INFO = struct__CRYPT_ECC_CMS_SHARED_INFO;
pub const _CRYPT_RC2_CBC_PARAMETERS = struct__CRYPT_RC2_CBC_PARAMETERS;
pub const _CRYPT_SMIME_CAPABILITY = struct__CRYPT_SMIME_CAPABILITY;
pub const _CRYPT_SMIME_CAPABILITIES = struct__CRYPT_SMIME_CAPABILITIES;
pub const _CERT_QC_STATEMENT = struct__CERT_QC_STATEMENT;
pub const _CERT_QC_STATEMENTS_EXT_INFO = struct__CERT_QC_STATEMENTS_EXT_INFO;
pub const _CRYPT_MASK_GEN_ALGORITHM = struct__CRYPT_MASK_GEN_ALGORITHM;
pub const _CRYPT_RSA_SSA_PSS_PARAMETERS = struct__CRYPT_RSA_SSA_PSS_PARAMETERS;
pub const _CRYPT_PSOURCE_ALGORITHM = struct__CRYPT_PSOURCE_ALGORITHM;
pub const _CRYPT_RSAES_OAEP_PARAMETERS = struct__CRYPT_RSAES_OAEP_PARAMETERS;
pub const _CMC_TAGGED_ATTRIBUTE = struct__CMC_TAGGED_ATTRIBUTE;
pub const _CMC_TAGGED_CERT_REQUEST = struct__CMC_TAGGED_CERT_REQUEST;
pub const _CMC_TAGGED_REQUEST = struct__CMC_TAGGED_REQUEST;
pub const _CMC_TAGGED_CONTENT_INFO = struct__CMC_TAGGED_CONTENT_INFO;
pub const _CMC_TAGGED_OTHER_MSG = struct__CMC_TAGGED_OTHER_MSG;
pub const _CMC_DATA_INFO = struct__CMC_DATA_INFO;
pub const _CMC_RESPONSE_INFO = struct__CMC_RESPONSE_INFO;
pub const _CMC_PEND_INFO = struct__CMC_PEND_INFO;
pub const _CMC_STATUS_INFO = struct__CMC_STATUS_INFO;
pub const _CMC_ADD_EXTENSIONS_INFO = struct__CMC_ADD_EXTENSIONS_INFO;
pub const _CMC_ADD_ATTRIBUTES_INFO = struct__CMC_ADD_ATTRIBUTES_INFO;
pub const _CERT_TEMPLATE_EXT = struct__CERT_TEMPLATE_EXT;
pub const _CERT_HASHED_URL = struct__CERT_HASHED_URL;
pub const _CERT_LOGOTYPE_DETAILS = struct__CERT_LOGOTYPE_DETAILS;
pub const _CERT_LOGOTYPE_REFERENCE = struct__CERT_LOGOTYPE_REFERENCE;
pub const _CERT_LOGOTYPE_IMAGE_INFO = struct__CERT_LOGOTYPE_IMAGE_INFO;
pub const _CERT_LOGOTYPE_IMAGE = struct__CERT_LOGOTYPE_IMAGE;
pub const _CERT_LOGOTYPE_AUDIO_INFO = struct__CERT_LOGOTYPE_AUDIO_INFO;
pub const _CERT_LOGOTYPE_AUDIO = struct__CERT_LOGOTYPE_AUDIO;
pub const _CERT_LOGOTYPE_DATA = struct__CERT_LOGOTYPE_DATA;
pub const _CERT_LOGOTYPE_INFO = struct__CERT_LOGOTYPE_INFO;
pub const _CERT_OTHER_LOGOTYPE_INFO = struct__CERT_OTHER_LOGOTYPE_INFO;
pub const _CERT_LOGOTYPE_EXT_INFO = struct__CERT_LOGOTYPE_EXT_INFO;
pub const _CERT_BIOMETRIC_DATA = struct__CERT_BIOMETRIC_DATA;
pub const _CERT_BIOMETRIC_EXT_INFO = struct__CERT_BIOMETRIC_EXT_INFO;
pub const _OCSP_SIGNATURE_INFO = struct__OCSP_SIGNATURE_INFO;
pub const _OCSP_SIGNED_REQUEST_INFO = struct__OCSP_SIGNED_REQUEST_INFO;
pub const _OCSP_CERT_ID = struct__OCSP_CERT_ID;
pub const _OCSP_REQUEST_ENTRY = struct__OCSP_REQUEST_ENTRY;
pub const _OCSP_REQUEST_INFO = struct__OCSP_REQUEST_INFO;
pub const _OCSP_RESPONSE_INFO = struct__OCSP_RESPONSE_INFO;
pub const _OCSP_BASIC_SIGNED_RESPONSE_INFO = struct__OCSP_BASIC_SIGNED_RESPONSE_INFO;
pub const _OCSP_BASIC_REVOKED_INFO = struct__OCSP_BASIC_REVOKED_INFO;
pub const _OCSP_BASIC_RESPONSE_ENTRY = struct__OCSP_BASIC_RESPONSE_ENTRY;
pub const _OCSP_BASIC_RESPONSE_INFO = struct__OCSP_BASIC_RESPONSE_INFO;
pub const _CERT_SUPPORTED_ALGORITHM_INFO = struct__CERT_SUPPORTED_ALGORITHM_INFO;
pub const _CERT_TPM_SPECIFICATION_INFO = struct__CERT_TPM_SPECIFICATION_INFO;
pub const _CRYPT_OID_FUNC_ENTRY = struct__CRYPT_OID_FUNC_ENTRY;
pub const _CRYPT_OID_INFO = struct__CRYPT_OID_INFO;
pub const _CERT_STRONG_SIGN_SERIALIZED_INFO = struct__CERT_STRONG_SIGN_SERIALIZED_INFO;
pub const _CERT_STRONG_SIGN_PARA = struct__CERT_STRONG_SIGN_PARA;
pub const _CERT_ISSUER_SERIAL_NUMBER = struct__CERT_ISSUER_SERIAL_NUMBER;
pub const _CERT_ID = struct__CERT_ID;
pub const _CMSG_SIGNER_ENCODE_INFO = struct__CMSG_SIGNER_ENCODE_INFO;
pub const _CMSG_SIGNED_ENCODE_INFO = struct__CMSG_SIGNED_ENCODE_INFO;
pub const _CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = struct__CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO;
pub const _CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = struct__CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO;
pub const _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = struct__CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO;
pub const _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = struct__CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO;
pub const _CMSG_RECIPIENT_ENCODE_INFO = struct__CMSG_RECIPIENT_ENCODE_INFO;
pub const _CMSG_ENVELOPED_ENCODE_INFO = struct__CMSG_ENVELOPED_ENCODE_INFO;
pub const _CMSG_RC2_AUX_INFO = struct__CMSG_RC2_AUX_INFO;
pub const _CMSG_SP3_COMPATIBLE_AUX_INFO = struct__CMSG_SP3_COMPATIBLE_AUX_INFO;
pub const _CMSG_RC4_AUX_INFO = struct__CMSG_RC4_AUX_INFO;
pub const _CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = struct__CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO;
pub const _CMSG_HASHED_ENCODE_INFO = struct__CMSG_HASHED_ENCODE_INFO;
pub const _CMSG_ENCRYPTED_ENCODE_INFO = struct__CMSG_ENCRYPTED_ENCODE_INFO;
pub const _CMSG_STREAM_INFO = struct__CMSG_STREAM_INFO;
pub const _CMSG_SIGNER_INFO = struct__CMSG_SIGNER_INFO;
pub const _CMSG_CMS_SIGNER_INFO = struct__CMSG_CMS_SIGNER_INFO;
pub const _CMSG_KEY_TRANS_RECIPIENT_INFO = struct__CMSG_KEY_TRANS_RECIPIENT_INFO;
pub const _CMSG_RECIPIENT_ENCRYPTED_KEY_INFO = struct__CMSG_RECIPIENT_ENCRYPTED_KEY_INFO;
pub const _CMSG_KEY_AGREE_RECIPIENT_INFO = struct__CMSG_KEY_AGREE_RECIPIENT_INFO;
pub const _CMSG_MAIL_LIST_RECIPIENT_INFO = struct__CMSG_MAIL_LIST_RECIPIENT_INFO;
pub const _CMSG_CMS_RECIPIENT_INFO = struct__CMSG_CMS_RECIPIENT_INFO;
pub const _CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = struct__CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA;
pub const _CMSG_CTRL_DECRYPT_PARA = struct__CMSG_CTRL_DECRYPT_PARA;
pub const _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA = struct__CMSG_CTRL_KEY_TRANS_DECRYPT_PARA;
pub const _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA = struct__CMSG_CTRL_KEY_AGREE_DECRYPT_PARA;
pub const _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA = struct__CMSG_CTRL_MAIL_LIST_DECRYPT_PARA;
pub const _CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = struct__CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA;
pub const _CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = struct__CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA;
pub const _CMSG_CONTENT_ENCRYPT_INFO = struct__CMSG_CONTENT_ENCRYPT_INFO;
pub const _CMSG_KEY_TRANS_ENCRYPT_INFO = struct__CMSG_KEY_TRANS_ENCRYPT_INFO;
pub const _CMSG_KEY_AGREE_KEY_ENCRYPT_INFO = struct__CMSG_KEY_AGREE_KEY_ENCRYPT_INFO;
pub const _CMSG_KEY_AGREE_ENCRYPT_INFO = struct__CMSG_KEY_AGREE_ENCRYPT_INFO;
pub const _CMSG_MAIL_LIST_ENCRYPT_INFO = struct__CMSG_MAIL_LIST_ENCRYPT_INFO;
pub const _CMSG_CNG_CONTENT_DECRYPT_INFO = struct__CMSG_CNG_CONTENT_DECRYPT_INFO;
pub const _CERT_CONTEXT = struct__CERT_CONTEXT;
pub const _CRL_CONTEXT = struct__CRL_CONTEXT;
pub const _CTL_CONTEXT = struct__CTL_CONTEXT;
pub const _CRYPT_KEY_PROV_PARAM = struct__CRYPT_KEY_PROV_PARAM;
pub const _CRYPT_KEY_PROV_INFO = struct__CRYPT_KEY_PROV_INFO;
pub const _CERT_KEY_CONTEXT = struct__CERT_KEY_CONTEXT;
pub const _ROOT_INFO_LUID = struct__ROOT_INFO_LUID;
pub const _CRYPT_SMART_CARD_ROOT_INFO = struct__CRYPT_SMART_CARD_ROOT_INFO;
pub const _CERT_SYSTEM_STORE_RELOCATE_PARA = struct__CERT_SYSTEM_STORE_RELOCATE_PARA;
pub const _CERT_REGISTRY_STORE_CLIENT_GPT_PARA = struct__CERT_REGISTRY_STORE_CLIENT_GPT_PARA;
pub const _CERT_REGISTRY_STORE_ROAMING_PARA = struct__CERT_REGISTRY_STORE_ROAMING_PARA;
pub const _CERT_LDAP_STORE_OPENED_PARA = struct__CERT_LDAP_STORE_OPENED_PARA;
pub const _CERT_STORE_PROV_INFO = struct__CERT_STORE_PROV_INFO;
pub const _CERT_STORE_PROV_FIND_INFO = struct__CERT_STORE_PROV_FIND_INFO;
pub const _CRL_FIND_ISSUED_FOR_PARA = struct__CRL_FIND_ISSUED_FOR_PARA;
pub const _CTL_ANY_SUBJECT_INFO = struct__CTL_ANY_SUBJECT_INFO;
pub const _CTL_FIND_USAGE_PARA = struct__CTL_FIND_USAGE_PARA;
pub const _CTL_FIND_SUBJECT_PARA = struct__CTL_FIND_SUBJECT_PARA;
pub const _CERT_CREATE_CONTEXT_PARA = struct__CERT_CREATE_CONTEXT_PARA;
pub const _CERT_SYSTEM_STORE_INFO = struct__CERT_SYSTEM_STORE_INFO;
pub const _CERT_PHYSICAL_STORE_INFO = struct__CERT_PHYSICAL_STORE_INFO;
pub const _CTL_VERIFY_USAGE_PARA = struct__CTL_VERIFY_USAGE_PARA;
pub const _CTL_VERIFY_USAGE_STATUS = struct__CTL_VERIFY_USAGE_STATUS;
pub const _CERT_REVOCATION_CRL_INFO = struct__CERT_REVOCATION_CRL_INFO;
pub const _CERT_REVOCATION_CHAIN_PARA = struct__CERT_REVOCATION_CHAIN_PARA;
pub const _CERT_REVOCATION_PARA = struct__CERT_REVOCATION_PARA;
pub const _CERT_REVOCATION_STATUS = struct__CERT_REVOCATION_STATUS;
pub const _CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO = struct__CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO;
pub const _CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO = struct__CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO;
pub const _CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = struct__CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA;
pub const _CRYPT_SIGN_MESSAGE_PARA = struct__CRYPT_SIGN_MESSAGE_PARA;
pub const _CRYPT_VERIFY_MESSAGE_PARA = struct__CRYPT_VERIFY_MESSAGE_PARA;
pub const _CRYPT_ENCRYPT_MESSAGE_PARA = struct__CRYPT_ENCRYPT_MESSAGE_PARA;
pub const _CRYPT_DECRYPT_MESSAGE_PARA = struct__CRYPT_DECRYPT_MESSAGE_PARA;
pub const _CRYPT_HASH_MESSAGE_PARA = struct__CRYPT_HASH_MESSAGE_PARA;
pub const _CRYPT_KEY_SIGN_MESSAGE_PARA = struct__CRYPT_KEY_SIGN_MESSAGE_PARA;
pub const _CRYPT_KEY_VERIFY_MESSAGE_PARA = struct__CRYPT_KEY_VERIFY_MESSAGE_PARA;
pub const _CERT_CHAIN = struct__CERT_CHAIN;
pub const _CRYPT_BLOB_ARRAY = struct__CRYPT_BLOB_ARRAY;
pub const _CRYPT_CREDENTIALS = struct__CRYPT_CREDENTIALS;
pub const _CRYPT_PASSWORD_CREDENTIALSA = struct__CRYPT_PASSWORD_CREDENTIALSA;
pub const _CRYPT_PASSWORD_CREDENTIALSW = struct__CRYPT_PASSWORD_CREDENTIALSW;
pub const _CRYPTNET_URL_CACHE_PRE_FETCH_INFO = struct__CRYPTNET_URL_CACHE_PRE_FETCH_INFO;
pub const _CRYPTNET_URL_CACHE_FLUSH_INFO = struct__CRYPTNET_URL_CACHE_FLUSH_INFO;
pub const _CRYPTNET_URL_CACHE_RESPONSE_INFO = struct__CRYPTNET_URL_CACHE_RESPONSE_INFO;
pub const _CRYPT_RETRIEVE_AUX_INFO = struct__CRYPT_RETRIEVE_AUX_INFO;
pub const _CRYPT_ASYNC_RETRIEVAL_COMPLETION = struct__CRYPT_ASYNC_RETRIEVAL_COMPLETION;
pub const _CRYPT_URL_ARRAY = struct__CRYPT_URL_ARRAY;
pub const _CRYPT_URL_INFO = struct__CRYPT_URL_INFO;
pub const _CERT_CRL_CONTEXT_PAIR = struct__CERT_CRL_CONTEXT_PAIR;
pub const _CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO = struct__CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO;
pub const _CERT_CHAIN_ENGINE_CONFIG = struct__CERT_CHAIN_ENGINE_CONFIG;
pub const _CERT_TRUST_STATUS = struct__CERT_TRUST_STATUS;
pub const _CERT_REVOCATION_INFO = struct__CERT_REVOCATION_INFO;
pub const _CERT_TRUST_LIST_INFO = struct__CERT_TRUST_LIST_INFO;
pub const _CERT_CHAIN_ELEMENT = struct__CERT_CHAIN_ELEMENT;
pub const _CERT_SIMPLE_CHAIN = struct__CERT_SIMPLE_CHAIN;
pub const _CERT_CHAIN_CONTEXT = struct__CERT_CHAIN_CONTEXT;
pub const _CERT_USAGE_MATCH = struct__CERT_USAGE_MATCH;
pub const _CTL_USAGE_MATCH = struct__CTL_USAGE_MATCH;
pub const _CERT_CHAIN_PARA = struct__CERT_CHAIN_PARA;
pub const _CRL_REVOCATION_INFO = struct__CRL_REVOCATION_INFO;
pub const _CERT_CHAIN_FIND_BY_ISSUER_PARA = struct__CERT_CHAIN_FIND_BY_ISSUER_PARA;
pub const _CERT_CHAIN_POLICY_PARA = struct__CERT_CHAIN_POLICY_PARA;
pub const _CERT_CHAIN_POLICY_STATUS = struct__CERT_CHAIN_POLICY_STATUS;
pub const _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA = struct__AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA;
pub const _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS = struct__AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub const _AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA = struct__AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA;
pub const _HTTPSPolicyCallbackData = struct__HTTPSPolicyCallbackData;
pub const _EV_EXTRA_CERT_CHAIN_POLICY_PARA = struct__EV_EXTRA_CERT_CHAIN_POLICY_PARA;
pub const _EV_EXTRA_CERT_CHAIN_POLICY_STATUS = struct__EV_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub const _SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS = struct__SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub const _SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA = struct__SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA;
pub const _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA = struct__SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA;
pub const _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS = struct__SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS;
pub const _CRYPT_PKCS12_PBE_PARAMS = struct__CRYPT_PKCS12_PBE_PARAMS;
pub const _PKCS12_PBES2_EXPORT_PARAMS = struct__PKCS12_PBES2_EXPORT_PARAMS;
pub const _CERT_SERVER_OCSP_RESPONSE_CONTEXT = struct__CERT_SERVER_OCSP_RESPONSE_CONTEXT;
pub const _CERT_SERVER_OCSP_RESPONSE_OPEN_PARA = struct__CERT_SERVER_OCSP_RESPONSE_OPEN_PARA;
pub const _CERT_SELECT_CHAIN_PARA = struct__CERT_SELECT_CHAIN_PARA;
pub const _CERT_SELECT_CRITERIA = struct__CERT_SELECT_CRITERIA;
pub const _CRYPT_TIMESTAMP_REQUEST = struct__CRYPT_TIMESTAMP_REQUEST;
pub const _CRYPT_TIMESTAMP_RESPONSE = struct__CRYPT_TIMESTAMP_RESPONSE;
pub const _CRYPT_TIMESTAMP_ACCURACY = struct__CRYPT_TIMESTAMP_ACCURACY;
pub const _CRYPT_TIMESTAMP_INFO = struct__CRYPT_TIMESTAMP_INFO;
pub const _CRYPT_TIMESTAMP_CONTEXT = struct__CRYPT_TIMESTAMP_CONTEXT;
pub const _CRYPT_TIMESTAMP_PARA = struct__CRYPT_TIMESTAMP_PARA;
pub const _CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE = struct__CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE;
pub const _CRYPTPROTECT_PROMPTSTRUCT = struct__CRYPTPROTECT_PROMPTSTRUCT;
pub const _CERTIFICATE_BLOB = struct__CERTIFICATE_BLOB;
pub const _EFS_HASH_BLOB = struct__EFS_HASH_BLOB;
pub const _EFS_RPC_BLOB = struct__EFS_RPC_BLOB;
pub const _EFS_PIN_BLOB = struct__EFS_PIN_BLOB;
pub const _EFS_KEY_INFO = struct__EFS_KEY_INFO;
pub const _EFS_COMPATIBILITY_INFO = struct__EFS_COMPATIBILITY_INFO;
pub const _EFS_VERSION_INFO = struct__EFS_VERSION_INFO;
pub const _EFS_DECRYPTION_STATUS_INFO = struct__EFS_DECRYPTION_STATUS_INFO;
pub const _EFS_ENCRYPTION_STATUS_INFO = struct__EFS_ENCRYPTION_STATUS_INFO;
pub const _ENCRYPTION_CERTIFICATE = struct__ENCRYPTION_CERTIFICATE;
pub const _ENCRYPTION_CERTIFICATE_HASH = struct__ENCRYPTION_CERTIFICATE_HASH;
pub const _ENCRYPTION_CERTIFICATE_HASH_LIST = struct__ENCRYPTION_CERTIFICATE_HASH_LIST;
pub const _ENCRYPTION_CERTIFICATE_LIST = struct__ENCRYPTION_CERTIFICATE_LIST;
pub const _ENCRYPTED_FILE_METADATA_SIGNATURE = struct__ENCRYPTED_FILE_METADATA_SIGNATURE;
pub const _ENCRYPTION_PROTECTOR = struct__ENCRYPTION_PROTECTOR;
pub const _ENCRYPTION_PROTECTOR_LIST = struct__ENCRYPTION_PROTECTOR_LIST;
pub const _SCONTEXT_QUEUE = struct__SCONTEXT_QUEUE;
pub const _MIDL_STUB_MESSAGE = struct__MIDL_STUB_MESSAGE;
pub const __GENERIC_BINDING_INFO = struct___GENERIC_BINDING_INFO;
pub const _GENERIC_BINDING_ROUTINE_PAIR = struct__GENERIC_BINDING_ROUTINE_PAIR;
pub const _XMIT_ROUTINE_QUINTUPLE = struct__XMIT_ROUTINE_QUINTUPLE;
pub const _MALLOC_FREE_STRUCT = struct__MALLOC_FREE_STRUCT;
pub const _COMM_FAULT_OFFSETS = struct__COMM_FAULT_OFFSETS;
pub const _USER_MARSHAL_ROUTINE_QUADRUPLE = struct__USER_MARSHAL_ROUTINE_QUADRUPLE;
pub const _IDL_CS_CONVERT = enum__IDL_CS_CONVERT;
pub const _NDR_CS_SIZE_CONVERT_ROUTINES = struct__NDR_CS_SIZE_CONVERT_ROUTINES;
pub const _NDR_CS_ROUTINES = struct__NDR_CS_ROUTINES;
pub const _NDR_EXPR_DESC = struct__NDR_EXPR_DESC;
pub const _MIDL_STUB_DESC = struct__MIDL_STUB_DESC;
pub const _FULL_PTR_XLAT_TABLES = struct__FULL_PTR_XLAT_TABLES;
pub const _NDR_ASYNC_MESSAGE = struct__NDR_ASYNC_MESSAGE;
pub const _NDR_CORRELATION_INFO = struct__NDR_CORRELATION_INFO;
pub const _MIDL_METHOD_PROPERTY = struct__MIDL_METHOD_PROPERTY;
pub const _MIDL_METHOD_PROPERTY_MAP = struct__MIDL_METHOD_PROPERTY_MAP;
pub const _MIDL_INTERFACE_METHOD_PROPERTIES = struct__MIDL_INTERFACE_METHOD_PROPERTIES;
pub const _MIDL_SYNTAX_INFO = struct__MIDL_SYNTAX_INFO;
pub const NDR_ALLOC_ALL_NODES_CONTEXT = struct_NDR_ALLOC_ALL_NODES_CONTEXT;
pub const NDR_POINTER_QUEUE_STATE = struct_NDR_POINTER_QUEUE_STATE;
pub const _NDR_PROC_CONTEXT = struct__NDR_PROC_CONTEXT;
pub const _USER_MARSHAL_CB_TYPE = enum__USER_MARSHAL_CB_TYPE;
pub const _USER_MARSHAL_CB = struct__USER_MARSHAL_CB;
pub const _MIDL_FORMAT_STRING = struct__MIDL_FORMAT_STRING;
pub const _MIDL_SERVER_INFO_ = struct__MIDL_SERVER_INFO_;
pub const _MIDL_STUBLESS_PROXY_INFO = struct__MIDL_STUBLESS_PROXY_INFO;
pub const _CLIENT_CALL_RETURN = union__CLIENT_CALL_RETURN;
pub const _system_handle_t = enum__system_handle_t;
pub const _MIDL_INTERCEPTION_INFO = struct__MIDL_INTERCEPTION_INFO;
pub const _MIDL_WINRT_TYPE_SERIALIZATION_INFO = struct__MIDL_WINRT_TYPE_SERIALIZATION_INFO;
pub const tagRPCOLEMESSAGE = struct_tagRPCOLEMESSAGE;
pub const _NDR_USER_MARSHAL_INFO_LEVEL1 = struct__NDR_USER_MARSHAL_INFO_LEVEL1;
pub const _NDR_USER_MARSHAL_INFO = struct__NDR_USER_MARSHAL_INFO;
pub const _COAUTHIDENTITY = struct__COAUTHIDENTITY;
pub const _COAUTHINFO = struct__COAUTHINFO;
pub const tagMEMCTX = enum_tagMEMCTX;
pub const tagCLSCTX = enum_tagCLSCTX;
pub const tagMSHLFLAGS = enum_tagMSHLFLAGS;
pub const tagMSHCTX = enum_tagMSHCTX;
pub const _BYTE_BLOB = struct__BYTE_BLOB;
pub const _WORD_BLOB = struct__WORD_BLOB;
pub const _DWORD_BLOB = struct__DWORD_BLOB;
pub const _FLAGGED_BYTE_BLOB = struct__FLAGGED_BYTE_BLOB;
pub const _FLAGGED_WORD_BLOB = struct__FLAGGED_WORD_BLOB;
pub const _BYTE_SIZEDARR = struct__BYTE_SIZEDARR;
pub const _SHORT_SIZEDARR = struct__SHORT_SIZEDARR;
pub const _LONG_SIZEDARR = struct__LONG_SIZEDARR;
pub const _HYPER_SIZEDARR = struct__HYPER_SIZEDARR;
pub const tagBLOB = struct_tagBLOB;
pub const tagRemHGLOBAL = struct_tagRemHGLOBAL;
pub const tagRemHMETAFILEPICT = struct_tagRemHMETAFILEPICT;
pub const tagRemHENHMETAFILE = struct_tagRemHENHMETAFILE;
pub const tagRemHBITMAP = struct_tagRemHBITMAP;
pub const tagRemHPALETTE = struct_tagRemHPALETTE;
pub const tagRemBRUSH = struct_tagRemBRUSH;
pub const tagDVASPECT = enum_tagDVASPECT;
pub const tagSTGC = enum_tagSTGC;
pub const tagSTGMOVE = enum_tagSTGMOVE;
pub const tagSTATFLAG = enum_tagSTATFLAG;
pub const __MIDL_IWinTypes_0001 = union___MIDL_IWinTypes_0001;
pub const _userCLIPFORMAT = struct__userCLIPFORMAT;
pub const __MIDL_IWinTypes_0002 = union___MIDL_IWinTypes_0002;
pub const _GDI_NONREMOTE = struct__GDI_NONREMOTE;
pub const __MIDL_IWinTypes_0003 = union___MIDL_IWinTypes_0003;
pub const _userHGLOBAL = struct__userHGLOBAL;
pub const __MIDL_IWinTypes_0004 = union___MIDL_IWinTypes_0004;
pub const _userHMETAFILE = struct__userHMETAFILE;
pub const _remoteMETAFILEPICT = struct__remoteMETAFILEPICT;
pub const __MIDL_IWinTypes_0005 = union___MIDL_IWinTypes_0005;
pub const _userHMETAFILEPICT = struct__userHMETAFILEPICT;
pub const __MIDL_IWinTypes_0006 = union___MIDL_IWinTypes_0006;
pub const _userHENHMETAFILE = struct__userHENHMETAFILE;
pub const _userBITMAP = struct__userBITMAP;
pub const __MIDL_IWinTypes_0007 = union___MIDL_IWinTypes_0007;
pub const _userHBITMAP = struct__userHBITMAP;
pub const __MIDL_IWinTypes_0008 = union___MIDL_IWinTypes_0008;
pub const _userHPALETTE = struct__userHPALETTE;
pub const __MIDL_IWinTypes_0009 = union___MIDL_IWinTypes_0009;
pub const _RemotableHandle = struct__RemotableHandle;
pub const tagCY = union_tagCY;
pub const tagDEC = struct_tagDEC;
pub const tagBSTRBLOB = struct_tagBSTRBLOB;
pub const tagCLIPDATA = struct_tagCLIPDATA;
pub const VARENUM = enum_VARENUM;
pub const _tagpropertykey = struct__tagpropertykey;
pub const tagCSPLATFORM = struct_tagCSPLATFORM;
pub const tagQUERYCONTEXT = struct_tagQUERYCONTEXT;
pub const tagTYSPEC = enum_tagTYSPEC;
pub const __MIDL___MIDL_itf_wtypes_0000_0001_0005 = union___MIDL___MIDL_itf_wtypes_0000_0001_0005;
pub const __MIDL___MIDL_itf_wtypes_0000_0001_0001 = struct___MIDL___MIDL_itf_wtypes_0000_0001_0001;
pub const _STORAGE_HOTPLUG_INFO = struct__STORAGE_HOTPLUG_INFO;
pub const _STORAGE_DEVICE_NUMBER = struct__STORAGE_DEVICE_NUMBER;
pub const _STORAGE_DEVICE_NUMBERS = struct__STORAGE_DEVICE_NUMBERS;
pub const _STORAGE_DEVICE_NUMBER_EX = struct__STORAGE_DEVICE_NUMBER_EX;
pub const _STORAGE_BUS_RESET_REQUEST = struct__STORAGE_BUS_RESET_REQUEST;
pub const _PREVENT_MEDIA_REMOVAL = struct__PREVENT_MEDIA_REMOVAL;
pub const _CLASS_MEDIA_CHANGE_CONTEXT = struct__CLASS_MEDIA_CHANGE_CONTEXT;
pub const _TAPE_STATISTICS = struct__TAPE_STATISTICS;
pub const _TAPE_GET_STATISTICS = struct__TAPE_GET_STATISTICS;
pub const _STORAGE_MEDIA_TYPE = enum__STORAGE_MEDIA_TYPE;
pub const _STORAGE_BUS_TYPE = enum__STORAGE_BUS_TYPE;
pub const _DEVICE_MEDIA_INFO = struct__DEVICE_MEDIA_INFO;
pub const _GET_MEDIA_TYPES = struct__GET_MEDIA_TYPES;
pub const _STORAGE_PREDICT_FAILURE = struct__STORAGE_PREDICT_FAILURE;
pub const _STORAGE_FAILURE_PREDICTION_CONFIG = struct__STORAGE_FAILURE_PREDICTION_CONFIG;
pub const _STORAGE_QUERY_TYPE = enum__STORAGE_QUERY_TYPE;
pub const _STORAGE_SET_TYPE = enum__STORAGE_SET_TYPE;
pub const _STORAGE_PROPERTY_ID = enum__STORAGE_PROPERTY_ID;
pub const _STORAGE_PROPERTY_QUERY = struct__STORAGE_PROPERTY_QUERY;
pub const _STORAGE_PROPERTY_SET = struct__STORAGE_PROPERTY_SET;
pub const _STORAGE_DESCRIPTOR_HEADER = struct__STORAGE_DESCRIPTOR_HEADER;
pub const _STORAGE_DEVICE_DESCRIPTOR = struct__STORAGE_DEVICE_DESCRIPTOR;
pub const _STORAGE_ADAPTER_DESCRIPTOR = struct__STORAGE_ADAPTER_DESCRIPTOR;
pub const _STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR = struct__STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR;
pub const _STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR = struct__STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR;
pub const _STORAGE_PORT_CODE_SET = enum__STORAGE_PORT_CODE_SET;
pub const _STORAGE_MINIPORT_DESCRIPTOR = struct__STORAGE_MINIPORT_DESCRIPTOR;
pub const _STORAGE_IDENTIFIER_CODE_SET = enum__STORAGE_IDENTIFIER_CODE_SET;
pub const _STORAGE_IDENTIFIER_TYPE = enum__STORAGE_IDENTIFIER_TYPE;
pub const _STORAGE_ID_NAA_FORMAT = enum__STORAGE_ID_NAA_FORMAT;
pub const _STORAGE_ASSOCIATION_TYPE = enum__STORAGE_ASSOCIATION_TYPE;
pub const _STORAGE_IDENTIFIER = struct__STORAGE_IDENTIFIER;
pub const _STORAGE_DEVICE_ID_DESCRIPTOR = struct__STORAGE_DEVICE_ID_DESCRIPTOR;
pub const _DEVICE_SEEK_PENALTY_DESCRIPTOR = struct__DEVICE_SEEK_PENALTY_DESCRIPTOR;
pub const _DEVICE_WRITE_AGGREGATION_DESCRIPTOR = struct__DEVICE_WRITE_AGGREGATION_DESCRIPTOR;
pub const _DEVICE_TRIM_DESCRIPTOR = struct__DEVICE_TRIM_DESCRIPTOR;
pub const _DEVICE_LB_PROVISIONING_DESCRIPTOR = struct__DEVICE_LB_PROVISIONING_DESCRIPTOR;
pub const _STORAGE_LB_PROVISIONING_MAP_RESOURCES = struct__STORAGE_LB_PROVISIONING_MAP_RESOURCES;
pub const _DEVICE_POWER_DESCRIPTOR = struct__DEVICE_POWER_DESCRIPTOR;
pub const _DEVICE_COPY_OFFLOAD_DESCRIPTOR = struct__DEVICE_COPY_OFFLOAD_DESCRIPTOR;
pub const _STORAGE_DEVICE_RESILIENCY_DESCRIPTOR = struct__STORAGE_DEVICE_RESILIENCY_DESCRIPTOR;
pub const _STORAGE_RPMB_FRAME_TYPE = enum__STORAGE_RPMB_FRAME_TYPE;
pub const _STORAGE_RPMB_DESCRIPTOR = struct__STORAGE_RPMB_DESCRIPTOR;
pub const _STORAGE_CRYPTO_ALGORITHM_ID = enum__STORAGE_CRYPTO_ALGORITHM_ID;
pub const _STORAGE_CRYPTO_KEY_SIZE = enum__STORAGE_CRYPTO_KEY_SIZE;
pub const _STORAGE_CRYPTO_CAPABILITY = struct__STORAGE_CRYPTO_CAPABILITY;
pub const _STORAGE_CRYPTO_DESCRIPTOR = struct__STORAGE_CRYPTO_DESCRIPTOR;
pub const _STORAGE_TIER_MEDIA_TYPE = enum__STORAGE_TIER_MEDIA_TYPE;
pub const _STORAGE_TIER_CLASS = enum__STORAGE_TIER_CLASS;
pub const _STORAGE_TIER = struct__STORAGE_TIER;
pub const _STORAGE_DEVICE_TIERING_DESCRIPTOR = struct__STORAGE_DEVICE_TIERING_DESCRIPTOR;
pub const _STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR = struct__STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR;
pub const _STORAGE_PROTOCOL_TYPE = enum__STORAGE_PROTOCOL_TYPE;
pub const _STORAGE_PROTOCOL_NVME_DATA_TYPE = enum__STORAGE_PROTOCOL_NVME_DATA_TYPE;
pub const _STORAGE_PROTOCOL_ATA_DATA_TYPE = enum__STORAGE_PROTOCOL_ATA_DATA_TYPE;
pub const _STORAGE_PROTOCOL_UFS_DATA_TYPE = enum__STORAGE_PROTOCOL_UFS_DATA_TYPE;
pub const _STORAGE_PROTOCOL_SPECIFIC_DATA = struct__STORAGE_PROTOCOL_SPECIFIC_DATA;
pub const _STORAGE_PROTOCOL_SPECIFIC_DATA_EXT = struct__STORAGE_PROTOCOL_SPECIFIC_DATA_EXT;
pub const _STORAGE_PROTOCOL_DATA_DESCRIPTOR = struct__STORAGE_PROTOCOL_DATA_DESCRIPTOR;
pub const _STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT = struct__STORAGE_PROTOCOL_DATA_DESCRIPTOR_EXT;
pub const _STORAGE_TEMPERATURE_INFO = struct__STORAGE_TEMPERATURE_INFO;
pub const _STORAGE_TEMPERATURE_DATA_DESCRIPTOR = struct__STORAGE_TEMPERATURE_DATA_DESCRIPTOR;
pub const _STORAGE_TEMPERATURE_THRESHOLD = struct__STORAGE_TEMPERATURE_THRESHOLD;
pub const _STORAGE_DEVICE_FORM_FACTOR = enum__STORAGE_DEVICE_FORM_FACTOR;
pub const _STORAGE_COMPONENT_HEALTH_STATUS = enum__STORAGE_COMPONENT_HEALTH_STATUS;
pub const _STORAGE_SPEC_VERSION = union__STORAGE_SPEC_VERSION;
pub const _STORAGE_PHYSICAL_DEVICE_DATA = struct__STORAGE_PHYSICAL_DEVICE_DATA;
pub const _STORAGE_PHYSICAL_ADAPTER_DATA = struct__STORAGE_PHYSICAL_ADAPTER_DATA;
pub const _STORAGE_PHYSICAL_NODE_DATA = struct__STORAGE_PHYSICAL_NODE_DATA;
pub const _STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR = struct__STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR;
pub const _STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR = struct__STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR;
pub const _STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR = struct__STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR;
pub const _STORAGE_DISK_HEALTH_STATUS = enum__STORAGE_DISK_HEALTH_STATUS;
pub const _STORAGE_DISK_OPERATIONAL_STATUS = enum__STORAGE_DISK_OPERATIONAL_STATUS;
pub const _STORAGE_OPERATIONAL_STATUS_REASON = enum__STORAGE_OPERATIONAL_STATUS_REASON;
pub const _STORAGE_OPERATIONAL_REASON = struct__STORAGE_OPERATIONAL_REASON;
pub const _STORAGE_DEVICE_MANAGEMENT_STATUS = struct__STORAGE_DEVICE_MANAGEMENT_STATUS;
pub const _STORAGE_ADAPTER_SERIAL_NUMBER = struct__STORAGE_ADAPTER_SERIAL_NUMBER;
pub const _STORAGE_ZONED_DEVICE_TYPES = enum__STORAGE_ZONED_DEVICE_TYPES;
pub const _STORAGE_ZONE_TYPES = enum__STORAGE_ZONE_TYPES;
pub const _STORAGE_ZONE_GROUP = struct__STORAGE_ZONE_GROUP;
pub const _STORAGE_ZONED_DEVICE_DESCRIPTOR = struct__STORAGE_ZONED_DEVICE_DESCRIPTOR;
pub const _DEVICE_LOCATION = struct__DEVICE_LOCATION;
pub const _STORAGE_DEVICE_LOCATION_DESCRIPTOR = struct__STORAGE_DEVICE_LOCATION_DESCRIPTOR;
pub const _STORAGE_DEVICE_NUMA_PROPERTY = struct__STORAGE_DEVICE_NUMA_PROPERTY;
pub const _STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT = struct__STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT;
pub const _STORAGE_HW_ENDURANCE_INFO = struct__STORAGE_HW_ENDURANCE_INFO;
pub const _STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR = struct__STORAGE_HW_ENDURANCE_DATA_DESCRIPTOR;
pub const _DEVICE_DATA_SET_RANGE = struct__DEVICE_DATA_SET_RANGE;
pub const _DEVICE_MANAGE_DATA_SET_ATTRIBUTES = struct__DEVICE_MANAGE_DATA_SET_ATTRIBUTES;
pub const _DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT = struct__DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT;
pub const _DEVICE_DSM_DEFINITION = struct__DEVICE_DSM_DEFINITION;
pub const _DEVICE_DSM_NOTIFICATION_PARAMETERS = struct__DEVICE_DSM_NOTIFICATION_PARAMETERS;
pub const _STORAGE_OFFLOAD_TOKEN = struct__STORAGE_OFFLOAD_TOKEN;
pub const _DEVICE_DSM_OFFLOAD_READ_PARAMETERS = struct__DEVICE_DSM_OFFLOAD_READ_PARAMETERS;
pub const _STORAGE_OFFLOAD_READ_OUTPUT = struct__STORAGE_OFFLOAD_READ_OUTPUT;
pub const _DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS = struct__DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS;
pub const _STORAGE_OFFLOAD_WRITE_OUTPUT = struct__STORAGE_OFFLOAD_WRITE_OUTPUT;
pub const _DEVICE_DATA_SET_LBP_STATE_PARAMETERS = struct__DEVICE_DATA_SET_LBP_STATE_PARAMETERS;
pub const _DEVICE_DATA_SET_LB_PROVISIONING_STATE = struct__DEVICE_DATA_SET_LB_PROVISIONING_STATE;
pub const _DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2 = struct__DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2;
pub const _DEVICE_DATA_SET_REPAIR_PARAMETERS = struct__DEVICE_DATA_SET_REPAIR_PARAMETERS;
pub const _DEVICE_DATA_SET_REPAIR_OUTPUT = struct__DEVICE_DATA_SET_REPAIR_OUTPUT;
pub const _DEVICE_DATA_SET_SCRUB_OUTPUT = struct__DEVICE_DATA_SET_SCRUB_OUTPUT;
pub const _DEVICE_DATA_SET_SCRUB_EX_OUTPUT = struct__DEVICE_DATA_SET_SCRUB_EX_OUTPUT;
pub const _DEVICE_DSM_TIERING_QUERY_INPUT = struct__DEVICE_DSM_TIERING_QUERY_INPUT;
pub const _STORAGE_TIER_REGION = struct__STORAGE_TIER_REGION;
pub const _DEVICE_DSM_TIERING_QUERY_OUTPUT = struct__DEVICE_DSM_TIERING_QUERY_OUTPUT;
pub const _DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS = struct__DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS;
pub const _DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT = struct__DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT;
pub const _DEVICE_STORAGE_ADDRESS_RANGE = struct__DEVICE_STORAGE_ADDRESS_RANGE;
pub const _DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT = struct__DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT;
pub const _DEVICE_DSM_REPORT_ZONES_PARAMETERS = struct__DEVICE_DSM_REPORT_ZONES_PARAMETERS;
pub const _STORAGE_ZONES_ATTRIBUTES = enum__STORAGE_ZONES_ATTRIBUTES;
pub const _STORAGE_ZONE_CONDITION = enum__STORAGE_ZONE_CONDITION;
pub const _STORAGE_ZONE_DESCRIPTOR = struct__STORAGE_ZONE_DESCRIPTOR;
pub const _DEVICE_DSM_REPORT_ZONES_DATA = struct__DEVICE_DSM_REPORT_ZONES_DATA;
pub const _DEVICE_STORAGE_RANGE_ATTRIBUTES = struct__DEVICE_STORAGE_RANGE_ATTRIBUTES;
pub const _DEVICE_DSM_RANGE_ERROR_INFO = struct__DEVICE_DSM_RANGE_ERROR_INFO;
pub const _DEVICE_DSM_LOST_QUERY_PARAMETERS = struct__DEVICE_DSM_LOST_QUERY_PARAMETERS;
pub const _DEVICE_DSM_LOST_QUERY_OUTPUT = struct__DEVICE_DSM_LOST_QUERY_OUTPUT;
pub const _DEVICE_DSM_FREE_SPACE_OUTPUT = struct__DEVICE_DSM_FREE_SPACE_OUTPUT;
pub const _DEVICE_DSM_CONVERSION_OUTPUT = struct__DEVICE_DSM_CONVERSION_OUTPUT;
pub const _STORAGE_GET_BC_PROPERTIES_OUTPUT = struct__STORAGE_GET_BC_PROPERTIES_OUTPUT;
pub const _STORAGE_ALLOCATE_BC_STREAM_INPUT = struct__STORAGE_ALLOCATE_BC_STREAM_INPUT;
pub const _STORAGE_ALLOCATE_BC_STREAM_OUTPUT = struct__STORAGE_ALLOCATE_BC_STREAM_OUTPUT;
pub const _STORAGE_PRIORITY_HINT_SUPPORT = struct__STORAGE_PRIORITY_HINT_SUPPORT;
pub const _STORAGE_DIAGNOSTIC_LEVEL = enum__STORAGE_DIAGNOSTIC_LEVEL;
pub const _STORAGE_DIAGNOSTIC_TARGET_TYPE = enum__STORAGE_DIAGNOSTIC_TARGET_TYPE;
pub const _STORAGE_DIAGNOSTIC_REQUEST = struct__STORAGE_DIAGNOSTIC_REQUEST;
pub const _STORAGE_DIAGNOSTIC_DATA = struct__STORAGE_DIAGNOSTIC_DATA;
pub const _PHYSICAL_ELEMENT_STATUS_REQUEST = struct__PHYSICAL_ELEMENT_STATUS_REQUEST;
pub const _PHYSICAL_ELEMENT_STATUS_DESCRIPTOR = struct__PHYSICAL_ELEMENT_STATUS_DESCRIPTOR;
pub const _PHYSICAL_ELEMENT_STATUS = struct__PHYSICAL_ELEMENT_STATUS;
pub const _REMOVE_ELEMENT_AND_TRUNCATE_REQUEST = struct__REMOVE_ELEMENT_AND_TRUNCATE_REQUEST;
pub const _STORAGE_MEDIA_SERIAL_NUMBER_DATA = struct__STORAGE_MEDIA_SERIAL_NUMBER_DATA;
pub const _STORAGE_READ_CAPACITY = struct__STORAGE_READ_CAPACITY;
pub const _WRITE_CACHE_TYPE = enum__WRITE_CACHE_TYPE;
pub const _WRITE_CACHE_ENABLE = enum__WRITE_CACHE_ENABLE;
pub const _WRITE_CACHE_CHANGE = enum__WRITE_CACHE_CHANGE;
pub const _WRITE_THROUGH = enum__WRITE_THROUGH;
pub const _STORAGE_WRITE_CACHE_PROPERTY = struct__STORAGE_WRITE_CACHE_PROPERTY;
pub const _PERSISTENT_RESERVE_COMMAND = struct__PERSISTENT_RESERVE_COMMAND;
pub const _DEVICEDUMP_COLLECTION_TYPE = enum__DEVICEDUMP_COLLECTION_TYPE;
pub const _DEVICEDUMP_SUBSECTION_POINTER = struct__DEVICEDUMP_SUBSECTION_POINTER;
pub const _DEVICEDUMP_STRUCTURE_VERSION = struct__DEVICEDUMP_STRUCTURE_VERSION;
pub const _DEVICEDUMP_SECTION_HEADER = struct__DEVICEDUMP_SECTION_HEADER;
pub const _GP_LOG_PAGE_DESCRIPTOR = struct__GP_LOG_PAGE_DESCRIPTOR;
pub const _DEVICEDUMP_PUBLIC_SUBSECTION = struct__DEVICEDUMP_PUBLIC_SUBSECTION;
pub const _DEVICEDUMP_RESTRICTED_SUBSECTION = struct__DEVICEDUMP_RESTRICTED_SUBSECTION;
pub const _DEVICEDUMP_PRIVATE_SUBSECTION = struct__DEVICEDUMP_PRIVATE_SUBSECTION;
pub const _DEVICEDUMP_STORAGEDEVICE_DATA = struct__DEVICEDUMP_STORAGEDEVICE_DATA;
pub const _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD = struct__DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD;
pub const _DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP = struct__DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP;
pub const _STORAGE_IDLE_POWER = struct__STORAGE_IDLE_POWER;
pub const _STORAGE_POWERUP_REASON_TYPE = enum__STORAGE_POWERUP_REASON_TYPE;
pub const _STORAGE_IDLE_POWERUP_REASON = struct__STORAGE_IDLE_POWERUP_REASON;
pub const _STORAGE_DEVICE_POWER_CAP_UNITS = enum__STORAGE_DEVICE_POWER_CAP_UNITS;
pub const _STORAGE_DEVICE_POWER_CAP = struct__STORAGE_DEVICE_POWER_CAP;
pub const _STORAGE_RPMB_DATA_FRAME = struct__STORAGE_RPMB_DATA_FRAME;
pub const _STORAGE_RPMB_COMMAND_TYPE = enum__STORAGE_RPMB_COMMAND_TYPE;
pub const _STORAGE_EVENT_NOTIFICATION = struct__STORAGE_EVENT_NOTIFICATION;
pub const _STORAGE_COUNTER_TYPE = enum__STORAGE_COUNTER_TYPE;
pub const _STORAGE_COUNTER = struct__STORAGE_COUNTER;
pub const _STORAGE_COUNTERS = struct__STORAGE_COUNTERS;
pub const _STORAGE_HW_FIRMWARE_INFO_QUERY = struct__STORAGE_HW_FIRMWARE_INFO_QUERY;
pub const _STORAGE_HW_FIRMWARE_SLOT_INFO = struct__STORAGE_HW_FIRMWARE_SLOT_INFO;
pub const _STORAGE_HW_FIRMWARE_INFO = struct__STORAGE_HW_FIRMWARE_INFO;
pub const _STORAGE_HW_FIRMWARE_DOWNLOAD = struct__STORAGE_HW_FIRMWARE_DOWNLOAD;
pub const _STORAGE_HW_FIRMWARE_DOWNLOAD_V2 = struct__STORAGE_HW_FIRMWARE_DOWNLOAD_V2;
pub const _STORAGE_HW_FIRMWARE_ACTIVATE = struct__STORAGE_HW_FIRMWARE_ACTIVATE;
pub const _STORAGE_PROTOCOL_COMMAND = struct__STORAGE_PROTOCOL_COMMAND;
pub const _STORAGE_ATTRIBUTE_MGMT_ACTION = enum__STORAGE_ATTRIBUTE_MGMT_ACTION;
pub const _STORAGE_ATTRIBUTE_MGMT = struct__STORAGE_ATTRIBUTE_MGMT;
pub const _SCM_PD_HEALTH_NOTIFICATION_DATA = struct__SCM_PD_HEALTH_NOTIFICATION_DATA;
pub const _SCM_LOGICAL_DEVICE_INSTANCE = struct__SCM_LOGICAL_DEVICE_INSTANCE;
pub const _SCM_LOGICAL_DEVICES = struct__SCM_LOGICAL_DEVICES;
pub const _SCM_PHYSICAL_DEVICE_INSTANCE = struct__SCM_PHYSICAL_DEVICE_INSTANCE;
pub const _SCM_PHYSICAL_DEVICES = struct__SCM_PHYSICAL_DEVICES;
pub const _SCM_REGION_FLAG = enum__SCM_REGION_FLAG;
pub const _SCM_REGION = struct__SCM_REGION;
pub const _SCM_REGIONS = struct__SCM_REGIONS;
pub const _SCM_INTERLEAVED_PD_INFO = struct__SCM_INTERLEAVED_PD_INFO;
pub const _SCM_LD_INTERLEAVE_SET_INFO = struct__SCM_LD_INTERLEAVE_SET_INFO;
pub const _SCM_PD_QUERY_TYPE = enum__SCM_PD_QUERY_TYPE;
pub const _SCM_PD_PROPERTY_ID = enum__SCM_PD_PROPERTY_ID;
pub const _SCM_PD_PROPERTY_QUERY = struct__SCM_PD_PROPERTY_QUERY;
pub const _SCM_PD_DESCRIPTOR_HEADER = struct__SCM_PD_DESCRIPTOR_HEADER;
pub const _SCM_PD_DEVICE_HANDLE = struct__SCM_PD_DEVICE_HANDLE;
pub const _SCM_PD_DEVICE_INFO = struct__SCM_PD_DEVICE_INFO;
pub const _SCM_PD_DEVICE_SPECIFIC_PROPERTY = struct__SCM_PD_DEVICE_SPECIFIC_PROPERTY;
pub const _SCM_PD_DEVICE_SPECIFIC_INFO = struct__SCM_PD_DEVICE_SPECIFIC_INFO;
pub const _SCM_PD_FIRMWARE_SLOT_INFO = struct__SCM_PD_FIRMWARE_SLOT_INFO;
pub const _SCM_PD_FIRMWARE_INFO = struct__SCM_PD_FIRMWARE_INFO;
pub const _SCM_PD_HEALTH_STATUS = enum__SCM_PD_HEALTH_STATUS;
pub const _SCM_PD_OPERATIONAL_STATUS = enum__SCM_PD_OPERATIONAL_STATUS;
pub const _SCM_PD_OPERATIONAL_STATUS_REASON = enum__SCM_PD_OPERATIONAL_STATUS_REASON;
pub const _SCM_PD_MANAGEMENT_STATUS = struct__SCM_PD_MANAGEMENT_STATUS;
pub const _SCM_PD_LOCATION_STRING = struct__SCM_PD_LOCATION_STRING;
pub const _SCM_PD_FIRMWARE_DOWNLOAD = struct__SCM_PD_FIRMWARE_DOWNLOAD;
pub const _SCM_PD_FIRMWARE_ACTIVATE = struct__SCM_PD_FIRMWARE_ACTIVATE;
pub const _SCM_PD_PASSTHROUGH_INPUT = struct__SCM_PD_PASSTHROUGH_INPUT;
pub const _SCM_PD_PASSTHROUGH_OUTPUT = struct__SCM_PD_PASSTHROUGH_OUTPUT;
pub const _SCM_PD_PASSTHROUGH_INVDIMM_INPUT = struct__SCM_PD_PASSTHROUGH_INVDIMM_INPUT;
pub const _SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT = struct__SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT;
pub const _SCM_PD_REINITIALIZE_MEDIA_INPUT = struct__SCM_PD_REINITIALIZE_MEDIA_INPUT;
pub const _SCM_PD_MEDIA_REINITIALIZATION_STATUS = enum__SCM_PD_MEDIA_REINITIALIZATION_STATUS;
pub const _SCM_PD_REINITIALIZE_MEDIA_OUTPUT = struct__SCM_PD_REINITIALIZE_MEDIA_OUTPUT;
pub const _MEDIA_TYPE = enum__MEDIA_TYPE;
pub const _FORMAT_PARAMETERS = struct__FORMAT_PARAMETERS;
pub const _FORMAT_EX_PARAMETERS = struct__FORMAT_EX_PARAMETERS;
pub const _DISK_GEOMETRY = struct__DISK_GEOMETRY;
pub const _PARTITION_INFORMATION = struct__PARTITION_INFORMATION;
pub const _SET_PARTITION_INFORMATION = struct__SET_PARTITION_INFORMATION;
pub const _DRIVE_LAYOUT_INFORMATION = struct__DRIVE_LAYOUT_INFORMATION;
pub const _VERIFY_INFORMATION = struct__VERIFY_INFORMATION;
pub const _REASSIGN_BLOCKS = struct__REASSIGN_BLOCKS;
pub const _REASSIGN_BLOCKS_EX = struct__REASSIGN_BLOCKS_EX;
pub const _PARTITION_STYLE = enum__PARTITION_STYLE;
pub const _PARTITION_INFORMATION_GPT = struct__PARTITION_INFORMATION_GPT;
pub const _PARTITION_INFORMATION_MBR = struct__PARTITION_INFORMATION_MBR;
pub const _SET_PARTITION_INFORMATION_EX = struct__SET_PARTITION_INFORMATION_EX;
pub const _CREATE_DISK_GPT = struct__CREATE_DISK_GPT;
pub const _CREATE_DISK_MBR = struct__CREATE_DISK_MBR;
pub const _CREATE_DISK = struct__CREATE_DISK;
pub const _GET_LENGTH_INFORMATION = struct__GET_LENGTH_INFORMATION;
pub const _PARTITION_INFORMATION_EX = struct__PARTITION_INFORMATION_EX;
pub const _DRIVE_LAYOUT_INFORMATION_GPT = struct__DRIVE_LAYOUT_INFORMATION_GPT;
pub const _DRIVE_LAYOUT_INFORMATION_MBR = struct__DRIVE_LAYOUT_INFORMATION_MBR;
pub const _DRIVE_LAYOUT_INFORMATION_EX = struct__DRIVE_LAYOUT_INFORMATION_EX;
pub const _DETECTION_TYPE = enum__DETECTION_TYPE;
pub const _DISK_INT13_INFO = struct__DISK_INT13_INFO;
pub const _DISK_EX_INT13_INFO = struct__DISK_EX_INT13_INFO;
pub const _DISK_DETECTION_INFO = struct__DISK_DETECTION_INFO;
pub const _DISK_PARTITION_INFO = struct__DISK_PARTITION_INFO;
pub const _DISK_GEOMETRY_EX = struct__DISK_GEOMETRY_EX;
pub const _DISK_CONTROLLER_NUMBER = struct__DISK_CONTROLLER_NUMBER;
pub const _DISK_CACHE_INFORMATION = struct__DISK_CACHE_INFORMATION;
pub const _DISK_GROW_PARTITION = struct__DISK_GROW_PARTITION;
pub const _HISTOGRAM_BUCKET = struct__HISTOGRAM_BUCKET;
pub const _DISK_HISTOGRAM = struct__DISK_HISTOGRAM;
pub const _DISK_PERFORMANCE = struct__DISK_PERFORMANCE;
pub const _DISK_RECORD = struct__DISK_RECORD;
pub const _DISK_LOGGING = struct__DISK_LOGGING;
pub const _BIN_TYPES = enum__BIN_TYPES;
pub const _BIN_RANGE = struct__BIN_RANGE;
pub const _PERF_BIN = struct__PERF_BIN;
pub const _BIN_COUNT = struct__BIN_COUNT;
pub const _BIN_RESULTS = struct__BIN_RESULTS;
pub const _GETVERSIONINPARAMS = struct__GETVERSIONINPARAMS;
pub const _IDEREGS = struct__IDEREGS;
pub const _SENDCMDINPARAMS = struct__SENDCMDINPARAMS;
pub const _DRIVERSTATUS = struct__DRIVERSTATUS;
pub const _SENDCMDOUTPARAMS = struct__SENDCMDOUTPARAMS;
pub const _GET_DISK_ATTRIBUTES = struct__GET_DISK_ATTRIBUTES;
pub const _SET_DISK_ATTRIBUTES = struct__SET_DISK_ATTRIBUTES;
pub const _ELEMENT_TYPE = enum__ELEMENT_TYPE;
pub const _CHANGER_ELEMENT = struct__CHANGER_ELEMENT;
pub const _CHANGER_ELEMENT_LIST = struct__CHANGER_ELEMENT_LIST;
pub const _GET_CHANGER_PARAMETERS = struct__GET_CHANGER_PARAMETERS;
pub const _CHANGER_PRODUCT_DATA = struct__CHANGER_PRODUCT_DATA;
pub const _CHANGER_SET_ACCESS = struct__CHANGER_SET_ACCESS;
pub const _CHANGER_READ_ELEMENT_STATUS = struct__CHANGER_READ_ELEMENT_STATUS;
pub const _CHANGER_ELEMENT_STATUS = struct__CHANGER_ELEMENT_STATUS;
pub const _CHANGER_ELEMENT_STATUS_EX = struct__CHANGER_ELEMENT_STATUS_EX;
pub const _CHANGER_INITIALIZE_ELEMENT_STATUS = struct__CHANGER_INITIALIZE_ELEMENT_STATUS;
pub const _CHANGER_SET_POSITION = struct__CHANGER_SET_POSITION;
pub const _CHANGER_EXCHANGE_MEDIUM = struct__CHANGER_EXCHANGE_MEDIUM;
pub const _CHANGER_MOVE_MEDIUM = struct__CHANGER_MOVE_MEDIUM;
pub const _CHANGER_SEND_VOLUME_TAG_INFORMATION = struct__CHANGER_SEND_VOLUME_TAG_INFORMATION;
pub const _READ_ELEMENT_ADDRESS_INFO = struct__READ_ELEMENT_ADDRESS_INFO;
pub const _CHANGER_DEVICE_PROBLEM_TYPE = enum__CHANGER_DEVICE_PROBLEM_TYPE;
pub const _PATHNAME_BUFFER = struct__PATHNAME_BUFFER;
pub const _FSCTL_QUERY_FAT_BPB_BUFFER = struct__FSCTL_QUERY_FAT_BPB_BUFFER;
pub const _MOVE_FILE_DATA32 = struct__MOVE_FILE_DATA32;
pub const _FILE_PREFETCH = struct__FILE_PREFETCH;
pub const _FILE_PREFETCH_EX = struct__FILE_PREFETCH_EX;
pub const _FILESYSTEM_STATISTICS = struct__FILESYSTEM_STATISTICS;
pub const _FAT_STATISTICS = struct__FAT_STATISTICS;
pub const _EXFAT_STATISTICS = struct__EXFAT_STATISTICS;
pub const _NTFS_STATISTICS = struct__NTFS_STATISTICS;
pub const _FILESYSTEM_STATISTICS_EX = struct__FILESYSTEM_STATISTICS_EX;
pub const _NTFS_STATISTICS_EX = struct__NTFS_STATISTICS_EX;
pub const _FILE_OBJECTID_BUFFER = struct__FILE_OBJECTID_BUFFER;
pub const _FILE_SET_SPARSE_BUFFER = struct__FILE_SET_SPARSE_BUFFER;
pub const _FILE_ZERO_DATA_INFORMATION = struct__FILE_ZERO_DATA_INFORMATION;
pub const _FILE_ZERO_DATA_INFORMATION_EX = struct__FILE_ZERO_DATA_INFORMATION_EX;
pub const _FILE_ALLOCATED_RANGE_BUFFER = struct__FILE_ALLOCATED_RANGE_BUFFER;
pub const _ENCRYPTION_BUFFER = struct__ENCRYPTION_BUFFER;
pub const _DECRYPTION_STATUS_BUFFER = struct__DECRYPTION_STATUS_BUFFER;
pub const _REQUEST_RAW_ENCRYPTED_DATA = struct__REQUEST_RAW_ENCRYPTED_DATA;
pub const _ENCRYPTED_DATA_INFO = struct__ENCRYPTED_DATA_INFO;
pub const _EXTENDED_ENCRYPTED_DATA_INFO = struct__EXTENDED_ENCRYPTED_DATA_INFO;
pub const _PLEX_READ_DATA_REQUEST = struct__PLEX_READ_DATA_REQUEST;
pub const _SI_COPYFILE = struct__SI_COPYFILE;
pub const _FILE_MAKE_COMPATIBLE_BUFFER = struct__FILE_MAKE_COMPATIBLE_BUFFER;
pub const _FILE_SET_DEFECT_MGMT_BUFFER = struct__FILE_SET_DEFECT_MGMT_BUFFER;
pub const _FILE_QUERY_SPARING_BUFFER = struct__FILE_QUERY_SPARING_BUFFER;
pub const _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER = struct__FILE_QUERY_ON_DISK_VOL_INFO_BUFFER;
pub const _FILE_INITIATE_REPAIR_OUTPUT_BUFFER = struct__FILE_INITIATE_REPAIR_OUTPUT_BUFFER;
pub const _SHRINK_VOLUME_REQUEST_TYPES = enum__SHRINK_VOLUME_REQUEST_TYPES;
pub const _SHRINK_VOLUME_INFORMATION = struct__SHRINK_VOLUME_INFORMATION;
pub const _TXFS_MODIFY_RM = struct__TXFS_MODIFY_RM;
pub const _TXFS_QUERY_RM_INFORMATION = struct__TXFS_QUERY_RM_INFORMATION;
pub const _TXFS_ROLLFORWARD_REDO_INFORMATION = struct__TXFS_ROLLFORWARD_REDO_INFORMATION;
pub const _TXFS_START_RM_INFORMATION = struct__TXFS_START_RM_INFORMATION;
pub const _TXFS_GET_METADATA_INFO_OUT = struct__TXFS_GET_METADATA_INFO_OUT;
pub const _TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY = struct__TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY;
pub const _TXFS_LIST_TRANSACTION_LOCKED_FILES = struct__TXFS_LIST_TRANSACTION_LOCKED_FILES;
pub const _TXFS_LIST_TRANSACTIONS_ENTRY = struct__TXFS_LIST_TRANSACTIONS_ENTRY;
pub const _TXFS_LIST_TRANSACTIONS = struct__TXFS_LIST_TRANSACTIONS;
pub const _TXFS_READ_BACKUP_INFORMATION_OUT = struct__TXFS_READ_BACKUP_INFORMATION_OUT;
pub const _TXFS_WRITE_BACKUP_INFORMATION = struct__TXFS_WRITE_BACKUP_INFORMATION;
pub const _TXFS_GET_TRANSACTED_VERSION = struct__TXFS_GET_TRANSACTED_VERSION;
pub const _TXFS_SAVEPOINT_INFORMATION = struct__TXFS_SAVEPOINT_INFORMATION;
pub const _TXFS_CREATE_MINIVERSION_INFO = struct__TXFS_CREATE_MINIVERSION_INFO;
pub const _TXFS_TRANSACTION_ACTIVE_INFO = struct__TXFS_TRANSACTION_ACTIVE_INFO;
pub const _BOOT_AREA_INFO = struct__BOOT_AREA_INFO;
pub const _RETRIEVAL_POINTER_BASE = struct__RETRIEVAL_POINTER_BASE;
pub const _FILE_FS_PERSISTENT_VOLUME_INFORMATION = struct__FILE_FS_PERSISTENT_VOLUME_INFORMATION;
pub const _FILE_SYSTEM_RECOGNITION_INFORMATION = struct__FILE_SYSTEM_RECOGNITION_INFORMATION;
pub const _REQUEST_OPLOCK_INPUT_BUFFER = struct__REQUEST_OPLOCK_INPUT_BUFFER;
pub const _REQUEST_OPLOCK_OUTPUT_BUFFER = struct__REQUEST_OPLOCK_OUTPUT_BUFFER;
pub const _VIRTUAL_STORAGE_TYPE = struct__VIRTUAL_STORAGE_TYPE;
pub const _STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST = struct__STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST;
pub const _STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY = struct__STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY;
pub const _STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY = struct__STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY;
pub const _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE = struct__STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE;
pub const _SD_CHANGE_MACHINE_SID_INPUT = struct__SD_CHANGE_MACHINE_SID_INPUT;
pub const _SD_CHANGE_MACHINE_SID_OUTPUT = struct__SD_CHANGE_MACHINE_SID_OUTPUT;
pub const _SD_QUERY_STATS_INPUT = struct__SD_QUERY_STATS_INPUT;
pub const _SD_QUERY_STATS_OUTPUT = struct__SD_QUERY_STATS_OUTPUT;
pub const _SD_ENUM_SDS_INPUT = struct__SD_ENUM_SDS_INPUT;
pub const _SD_ENUM_SDS_ENTRY = struct__SD_ENUM_SDS_ENTRY;
pub const _SD_ENUM_SDS_OUTPUT = struct__SD_ENUM_SDS_OUTPUT;
pub const _SD_GLOBAL_CHANGE_INPUT = struct__SD_GLOBAL_CHANGE_INPUT;
pub const _SD_GLOBAL_CHANGE_OUTPUT = struct__SD_GLOBAL_CHANGE_OUTPUT;
pub const _LOOKUP_STREAM_FROM_CLUSTER_INPUT = struct__LOOKUP_STREAM_FROM_CLUSTER_INPUT;
pub const _LOOKUP_STREAM_FROM_CLUSTER_OUTPUT = struct__LOOKUP_STREAM_FROM_CLUSTER_OUTPUT;
pub const _LOOKUP_STREAM_FROM_CLUSTER_ENTRY = struct__LOOKUP_STREAM_FROM_CLUSTER_ENTRY;
pub const _FILE_TYPE_NOTIFICATION_INPUT = struct__FILE_TYPE_NOTIFICATION_INPUT;
pub const _CSV_MGMT_LOCK = struct__CSV_MGMT_LOCK;
pub const _CSV_NAMESPACE_INFO = struct__CSV_NAMESPACE_INFO;
pub const _CSV_CONTROL_OP = enum__CSV_CONTROL_OP;
pub const _CSV_CONTROL_PARAM = struct__CSV_CONTROL_PARAM;
pub const _CSV_QUERY_REDIRECT_STATE = struct__CSV_QUERY_REDIRECT_STATE;
pub const _CSV_QUERY_FILE_REVISION = struct__CSV_QUERY_FILE_REVISION;
pub const _CSV_QUERY_FILE_REVISION_FILE_ID_128 = struct__CSV_QUERY_FILE_REVISION_FILE_ID_128;
pub const _CSV_QUERY_MDS_PATH = struct__CSV_QUERY_MDS_PATH;
pub const _CSVFS_DISK_CONNECTIVITY = enum__CSVFS_DISK_CONNECTIVITY;
pub const _CSV_QUERY_VOLUME_REDIRECT_STATE = struct__CSV_QUERY_VOLUME_REDIRECT_STATE;
pub const _CSV_QUERY_MDS_PATH_V2 = struct__CSV_QUERY_MDS_PATH_V2;
pub const _CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT = struct__CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT;
pub const _STORAGE_RESERVE_ID = enum__STORAGE_RESERVE_ID;
pub const _CSV_IS_OWNED_BY_CSVFS = struct__CSV_IS_OWNED_BY_CSVFS;
pub const _FILE_LEVEL_TRIM_RANGE = struct__FILE_LEVEL_TRIM_RANGE;
pub const _FILE_LEVEL_TRIM = struct__FILE_LEVEL_TRIM;
pub const _FILE_LEVEL_TRIM_OUTPUT = struct__FILE_LEVEL_TRIM_OUTPUT;
pub const _QUERY_FILE_LAYOUT_FILTER_TYPE = enum__QUERY_FILE_LAYOUT_FILTER_TYPE;
pub const _CLUSTER_RANGE = struct__CLUSTER_RANGE;
pub const _FILE_REFERENCE_RANGE = struct__FILE_REFERENCE_RANGE;
pub const _QUERY_FILE_LAYOUT_INPUT = struct__QUERY_FILE_LAYOUT_INPUT;
pub const _QUERY_FILE_LAYOUT_OUTPUT = struct__QUERY_FILE_LAYOUT_OUTPUT;
pub const _FILE_LAYOUT_ENTRY = struct__FILE_LAYOUT_ENTRY;
pub const _FILE_LAYOUT_NAME_ENTRY = struct__FILE_LAYOUT_NAME_ENTRY;
pub const _FILE_LAYOUT_INFO_ENTRY = struct__FILE_LAYOUT_INFO_ENTRY;
pub const _STREAM_LAYOUT_ENTRY = struct__STREAM_LAYOUT_ENTRY;
pub const _STREAM_EXTENT_ENTRY = struct__STREAM_EXTENT_ENTRY;
pub const _FSCTL_GET_INTEGRITY_INFORMATION_BUFFER = struct__FSCTL_GET_INTEGRITY_INFORMATION_BUFFER;
pub const _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER = struct__FSCTL_SET_INTEGRITY_INFORMATION_BUFFER;
pub const _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX = struct__FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX;
pub const _FSCTL_OFFLOAD_READ_INPUT = struct__FSCTL_OFFLOAD_READ_INPUT;
pub const _FSCTL_OFFLOAD_READ_OUTPUT = struct__FSCTL_OFFLOAD_READ_OUTPUT;
pub const _FSCTL_OFFLOAD_WRITE_INPUT = struct__FSCTL_OFFLOAD_WRITE_INPUT;
pub const _FSCTL_OFFLOAD_WRITE_OUTPUT = struct__FSCTL_OFFLOAD_WRITE_OUTPUT;
pub const _SET_PURGE_FAILURE_MODE_INPUT = struct__SET_PURGE_FAILURE_MODE_INPUT;
pub const _REPAIR_COPIES_INPUT = struct__REPAIR_COPIES_INPUT;
pub const _REPAIR_COPIES_OUTPUT = struct__REPAIR_COPIES_OUTPUT;
pub const _FILE_REGION_INFO = struct__FILE_REGION_INFO;
pub const _FILE_REGION_OUTPUT = struct__FILE_REGION_OUTPUT;
pub const _FILE_REGION_INPUT = struct__FILE_REGION_INPUT;
pub const _WRITE_USN_REASON_INPUT = struct__WRITE_USN_REASON_INPUT;
pub const _FILE_STORAGE_TIER_MEDIA_TYPE = enum__FILE_STORAGE_TIER_MEDIA_TYPE;
pub const _FILE_STORAGE_TIER_CLASS = enum__FILE_STORAGE_TIER_CLASS;
pub const _FILE_STORAGE_TIER = struct__FILE_STORAGE_TIER;
pub const _FSCTL_QUERY_STORAGE_CLASSES_OUTPUT = struct__FSCTL_QUERY_STORAGE_CLASSES_OUTPUT;
pub const _DesiredStorageClass = struct__DesiredStorageClass;
pub const _StreamInformation = union__StreamInformation;
pub const _STREAM_INFORMATION_ENTRY = struct__STREAM_INFORMATION_ENTRY;
pub const _FSCTL_QUERY_REGION_INFO_INPUT = struct__FSCTL_QUERY_REGION_INFO_INPUT;
pub const _FILE_STORAGE_TIER_REGION = struct__FILE_STORAGE_TIER_REGION;
pub const _FSCTL_QUERY_REGION_INFO_OUTPUT = struct__FSCTL_QUERY_REGION_INFO_OUTPUT;
pub const _FILE_DESIRED_STORAGE_CLASS_INFORMATION = struct__FILE_DESIRED_STORAGE_CLASS_INFORMATION;
pub const _DUPLICATE_EXTENTS_DATA = struct__DUPLICATE_EXTENTS_DATA;
pub const _DUPLICATE_EXTENTS_DATA32 = struct__DUPLICATE_EXTENTS_DATA32;
pub const _DUPLICATE_EXTENTS_DATA_EX = struct__DUPLICATE_EXTENTS_DATA_EX;
pub const _DUPLICATE_EXTENTS_DATA_EX32 = struct__DUPLICATE_EXTENTS_DATA_EX32;
pub const _REFS_SMR_VOLUME_GC_STATE = enum__REFS_SMR_VOLUME_GC_STATE;
pub const _REFS_SMR_VOLUME_INFO_OUTPUT = struct__REFS_SMR_VOLUME_INFO_OUTPUT;
pub const _REFS_SMR_VOLUME_GC_ACTION = enum__REFS_SMR_VOLUME_GC_ACTION;
pub const _REFS_SMR_VOLUME_GC_METHOD = enum__REFS_SMR_VOLUME_GC_METHOD;
pub const _REFS_SMR_VOLUME_GC_PARAMETERS = struct__REFS_SMR_VOLUME_GC_PARAMETERS;
pub const _STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER = struct__STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER;
pub const _STREAMS_ASSOCIATE_ID_INPUT_BUFFER = struct__STREAMS_ASSOCIATE_ID_INPUT_BUFFER;
pub const _STREAMS_QUERY_ID_OUTPUT_BUFFER = struct__STREAMS_QUERY_ID_OUTPUT_BUFFER;
pub const _QUERY_BAD_RANGES_INPUT_RANGE = struct__QUERY_BAD_RANGES_INPUT_RANGE;
pub const _QUERY_BAD_RANGES_INPUT = struct__QUERY_BAD_RANGES_INPUT;
pub const _QUERY_BAD_RANGES_OUTPUT_RANGE = struct__QUERY_BAD_RANGES_OUTPUT_RANGE;
pub const _QUERY_BAD_RANGES_OUTPUT = struct__QUERY_BAD_RANGES_OUTPUT;
pub const _SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT = struct__SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT;
pub const _VIRTUAL_STORAGE_BEHAVIOR_CODE = enum__VIRTUAL_STORAGE_BEHAVIOR_CODE;
pub const _VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT = struct__VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT;
pub const _ENCRYPTION_KEY_CTRL_INPUT = struct__ENCRYPTION_KEY_CTRL_INPUT;
pub const _WOF_EXTERNAL_INFO = struct__WOF_EXTERNAL_INFO;
pub const _WOF_EXTERNAL_FILE_ID = struct__WOF_EXTERNAL_FILE_ID;
pub const _WOF_VERSION_INFO = struct__WOF_VERSION_INFO;
pub const _WIM_PROVIDER_EXTERNAL_INFO = struct__WIM_PROVIDER_EXTERNAL_INFO;
pub const _WIM_PROVIDER_ADD_OVERLAY_INPUT = struct__WIM_PROVIDER_ADD_OVERLAY_INPUT;
pub const _WIM_PROVIDER_UPDATE_OVERLAY_INPUT = struct__WIM_PROVIDER_UPDATE_OVERLAY_INPUT;
pub const _WIM_PROVIDER_REMOVE_OVERLAY_INPUT = struct__WIM_PROVIDER_REMOVE_OVERLAY_INPUT;
pub const _WIM_PROVIDER_SUSPEND_OVERLAY_INPUT = struct__WIM_PROVIDER_SUSPEND_OVERLAY_INPUT;
pub const _WIM_PROVIDER_OVERLAY_ENTRY = struct__WIM_PROVIDER_OVERLAY_ENTRY;
pub const _FILE_PROVIDER_EXTERNAL_INFO_V0 = struct__FILE_PROVIDER_EXTERNAL_INFO_V0;
pub const _FILE_PROVIDER_EXTERNAL_INFO_V1 = struct__FILE_PROVIDER_EXTERNAL_INFO_V1;
pub const _CONTAINER_VOLUME_STATE = struct__CONTAINER_VOLUME_STATE;
pub const _CONTAINER_ROOT_INFO_INPUT = struct__CONTAINER_ROOT_INFO_INPUT;
pub const _CONTAINER_ROOT_INFO_OUTPUT = struct__CONTAINER_ROOT_INFO_OUTPUT;
pub const _VIRTUALIZATION_INSTANCE_INFO_INPUT = struct__VIRTUALIZATION_INSTANCE_INFO_INPUT;
pub const _VIRTUALIZATION_INSTANCE_INFO_INPUT_EX = struct__VIRTUALIZATION_INSTANCE_INFO_INPUT_EX;
pub const _VIRTUALIZATION_INSTANCE_INFO_OUTPUT = struct__VIRTUALIZATION_INSTANCE_INFO_OUTPUT;
pub const _GET_FILTER_FILE_IDENTIFIER_INPUT = struct__GET_FILTER_FILE_IDENTIFIER_INPUT;
pub const _GET_FILTER_FILE_IDENTIFIER_OUTPUT = struct__GET_FILTER_FILE_IDENTIFIER_OUTPUT;
pub const _DISK_EXTENT = struct__DISK_EXTENT;
pub const _VOLUME_DISK_EXTENTS = struct__VOLUME_DISK_EXTENTS;
pub const _VOLUME_GET_GPT_ATTRIBUTES_INFORMATION = struct__VOLUME_GET_GPT_ATTRIBUTES_INFORMATION;
pub const _IO_IRP_EXT_TRACK_OFFSET_HEADER = struct__IO_IRP_EXT_TRACK_OFFSET_HEADER;
pub const _SCARD_IO_REQUEST = struct__SCARD_IO_REQUEST;
pub const _SCARD_T0_COMMAND = struct__SCARD_T0_COMMAND;
pub const _SCARD_T0_REQUEST = struct__SCARD_T0_REQUEST;
pub const _SCARD_T1_REQUEST = struct__SCARD_T1_REQUEST;
pub const _SCARD_ATRMASK = struct__SCARD_ATRMASK;
pub const _PSP = struct__PSP;
pub const _PROPSHEETPAGEA = struct__PROPSHEETPAGEA;
pub const _PROPSHEETPAGEW = struct__PROPSHEETPAGEW;
pub const _PROPSHEETPAGEA_V1 = struct__PROPSHEETPAGEA_V1;
pub const _PROPSHEETPAGEA_V2 = struct__PROPSHEETPAGEA_V2;
pub const _PROPSHEETPAGEA_V3 = struct__PROPSHEETPAGEA_V3;
pub const _PROPSHEETPAGEW_V1 = struct__PROPSHEETPAGEW_V1;
pub const _PROPSHEETPAGEW_V2 = struct__PROPSHEETPAGEW_V2;
pub const _PROPSHEETPAGEW_V3 = struct__PROPSHEETPAGEW_V3;
pub const _PROPSHEETHEADERA_V1 = struct__PROPSHEETHEADERA_V1;
pub const _PROPSHEETHEADERA_V2 = struct__PROPSHEETHEADERA_V2;
pub const _PROPSHEETHEADERW_V1 = struct__PROPSHEETHEADERW_V1;
pub const _PROPSHEETHEADERW_V2 = struct__PROPSHEETHEADERW_V2;
pub const _PSHNOTIFY = struct__PSHNOTIFY;
pub const _PRINTER_INFO_1A = struct__PRINTER_INFO_1A;
pub const _PRINTER_INFO_1W = struct__PRINTER_INFO_1W;
pub const _PRINTER_INFO_2A = struct__PRINTER_INFO_2A;
pub const _PRINTER_INFO_2W = struct__PRINTER_INFO_2W;
pub const _PRINTER_INFO_3 = struct__PRINTER_INFO_3;
pub const _PRINTER_INFO_4A = struct__PRINTER_INFO_4A;
pub const _PRINTER_INFO_4W = struct__PRINTER_INFO_4W;
pub const _PRINTER_INFO_5A = struct__PRINTER_INFO_5A;
pub const _PRINTER_INFO_5W = struct__PRINTER_INFO_5W;
pub const _PRINTER_INFO_6 = struct__PRINTER_INFO_6;
pub const _PRINTER_INFO_7A = struct__PRINTER_INFO_7A;
pub const _PRINTER_INFO_7W = struct__PRINTER_INFO_7W;
pub const _PRINTER_INFO_8A = struct__PRINTER_INFO_8A;
pub const _PRINTER_INFO_8W = struct__PRINTER_INFO_8W;
pub const _PRINTER_INFO_9A = struct__PRINTER_INFO_9A;
pub const _PRINTER_INFO_9W = struct__PRINTER_INFO_9W;
pub const _JOB_INFO_1A = struct__JOB_INFO_1A;
pub const _JOB_INFO_1W = struct__JOB_INFO_1W;
pub const _JOB_INFO_2A = struct__JOB_INFO_2A;
pub const _JOB_INFO_2W = struct__JOB_INFO_2W;
pub const _JOB_INFO_3 = struct__JOB_INFO_3;
pub const _JOB_INFO_4A = struct__JOB_INFO_4A;
pub const _JOB_INFO_4W = struct__JOB_INFO_4W;
pub const _ADDJOB_INFO_1A = struct__ADDJOB_INFO_1A;
pub const _ADDJOB_INFO_1W = struct__ADDJOB_INFO_1W;
pub const _DRIVER_INFO_1A = struct__DRIVER_INFO_1A;
pub const _DRIVER_INFO_1W = struct__DRIVER_INFO_1W;
pub const _DRIVER_INFO_2A = struct__DRIVER_INFO_2A;
pub const _DRIVER_INFO_2W = struct__DRIVER_INFO_2W;
pub const _DRIVER_INFO_3A = struct__DRIVER_INFO_3A;
pub const _DRIVER_INFO_3W = struct__DRIVER_INFO_3W;
pub const _DRIVER_INFO_4A = struct__DRIVER_INFO_4A;
pub const _DRIVER_INFO_4W = struct__DRIVER_INFO_4W;
pub const _DRIVER_INFO_5A = struct__DRIVER_INFO_5A;
pub const _DRIVER_INFO_5W = struct__DRIVER_INFO_5W;
pub const _DRIVER_INFO_6A = struct__DRIVER_INFO_6A;
pub const _DRIVER_INFO_6W = struct__DRIVER_INFO_6W;
pub const _DRIVER_INFO_8A = struct__DRIVER_INFO_8A;
pub const _DRIVER_INFO_8W = struct__DRIVER_INFO_8W;
pub const _DOC_INFO_1A = struct__DOC_INFO_1A;
pub const _DOC_INFO_1W = struct__DOC_INFO_1W;
pub const _FORM_INFO_1A = struct__FORM_INFO_1A;
pub const _FORM_INFO_1W = struct__FORM_INFO_1W;
pub const _FORM_INFO_2A = struct__FORM_INFO_2A;
pub const _FORM_INFO_2W = struct__FORM_INFO_2W;
pub const _DOC_INFO_2A = struct__DOC_INFO_2A;
pub const _DOC_INFO_2W = struct__DOC_INFO_2W;
pub const _DOC_INFO_3A = struct__DOC_INFO_3A;
pub const _DOC_INFO_3W = struct__DOC_INFO_3W;
pub const _PRINTPROCESSOR_INFO_1A = struct__PRINTPROCESSOR_INFO_1A;
pub const _PRINTPROCESSOR_INFO_1W = struct__PRINTPROCESSOR_INFO_1W;
pub const _PRINTPROCESSOR_CAPS_1 = struct__PRINTPROCESSOR_CAPS_1;
pub const _PRINTPROCESSOR_CAPS_2 = struct__PRINTPROCESSOR_CAPS_2;
pub const _PORT_INFO_1A = struct__PORT_INFO_1A;
pub const _PORT_INFO_1W = struct__PORT_INFO_1W;
pub const _PORT_INFO_2A = struct__PORT_INFO_2A;
pub const _PORT_INFO_2W = struct__PORT_INFO_2W;
pub const _PORT_INFO_3A = struct__PORT_INFO_3A;
pub const _PORT_INFO_3W = struct__PORT_INFO_3W;
pub const _MONITOR_INFO_1A = struct__MONITOR_INFO_1A;
pub const _MONITOR_INFO_1W = struct__MONITOR_INFO_1W;
pub const _MONITOR_INFO_2A = struct__MONITOR_INFO_2A;
pub const _MONITOR_INFO_2W = struct__MONITOR_INFO_2W;
pub const _DATATYPES_INFO_1A = struct__DATATYPES_INFO_1A;
pub const _DATATYPES_INFO_1W = struct__DATATYPES_INFO_1W;
pub const _PRINTER_DEFAULTSA = struct__PRINTER_DEFAULTSA;
pub const _PRINTER_DEFAULTSW = struct__PRINTER_DEFAULTSW;
pub const _PRINTER_ENUM_VALUESA = struct__PRINTER_ENUM_VALUESA;
pub const _PRINTER_ENUM_VALUESW = struct__PRINTER_ENUM_VALUESW;
pub const _PRINTER_NOTIFY_OPTIONS_TYPE = struct__PRINTER_NOTIFY_OPTIONS_TYPE;
pub const _PRINTER_NOTIFY_OPTIONS = struct__PRINTER_NOTIFY_OPTIONS;
pub const _PRINTER_NOTIFY_INFO_DATA = struct__PRINTER_NOTIFY_INFO_DATA;
pub const _PRINTER_NOTIFY_INFO = struct__PRINTER_NOTIFY_INFO;
pub const _BINARY_CONTAINER = struct__BINARY_CONTAINER;
pub const _BIDI_DATA = struct__BIDI_DATA;
pub const _BIDI_REQUEST_DATA = struct__BIDI_REQUEST_DATA;
pub const _BIDI_REQUEST_CONTAINER = struct__BIDI_REQUEST_CONTAINER;
pub const _BIDI_RESPONSE_DATA = struct__BIDI_RESPONSE_DATA;
pub const _BIDI_RESPONSE_CONTAINER = struct__BIDI_RESPONSE_CONTAINER;
pub const _PROVIDOR_INFO_1A = struct__PROVIDOR_INFO_1A;
pub const _PROVIDOR_INFO_1W = struct__PROVIDOR_INFO_1W;
pub const _PROVIDOR_INFO_2A = struct__PROVIDOR_INFO_2A;
pub const _PROVIDOR_INFO_2W = struct__PROVIDOR_INFO_2W;
pub const _PRINTER_OPTION_FLAGS = enum__PRINTER_OPTION_FLAGS;
pub const _PRINTER_OPTIONSA = struct__PRINTER_OPTIONSA;
pub const _PRINTER_OPTIONSW = struct__PRINTER_OPTIONSW;
pub const _PRINTER_CONNECTION_INFO_1A = struct__PRINTER_CONNECTION_INFO_1A;
pub const _PRINTER_CONNECTION_INFO_1W = struct__PRINTER_CONNECTION_INFO_1W;
pub const _CORE_PRINTER_DRIVERA = struct__CORE_PRINTER_DRIVERA;
pub const _CORE_PRINTER_DRIVERW = struct__CORE_PRINTER_DRIVERW;
pub const _div_t = struct__div_t;
pub const _ldiv_t = struct__ldiv_t;
pub const _lldiv_t = struct__lldiv_t;
pub const tagREGCLS = enum_tagREGCLS;
pub const tagCOINITBASE = enum_tagCOINITBASE;
pub const tagSTATSTG = struct_tagSTATSTG;
pub const tagMULTI_QI = struct_tagMULTI_QI;
pub const tagRPCOPT_PROPERTIES = enum_tagRPCOPT_PROPERTIES;
pub const tagGLOBALOPT_PROPERTIES = enum_tagGLOBALOPT_PROPERTIES;
pub const _APTTYPE = enum__APTTYPE;
pub const _THDTYPE = enum__THDTYPE;
pub const _COSERVERINFO = struct__COSERVERINFO;
pub const tagACTIVATIONTYPE = enum_tagACTIVATIONTYPE;
pub const tagEXTCONN = enum_tagEXTCONN;
pub const tagSTGTY = enum_tagSTGTY;
pub const tagSTREAM_SEEK = enum_tagSTREAM_SEEK;
pub const tagLOCKTYPE = enum_tagLOCKTYPE;
pub const tagSOLE_AUTHENTICATION_SERVICE = struct_tagSOLE_AUTHENTICATION_SERVICE;
pub const tagEOLE_AUTHENTICATION_CAPABILITIES = enum_tagEOLE_AUTHENTICATION_CAPABILITIES;
pub const tagSOLE_AUTHENTICATION_INFO = struct_tagSOLE_AUTHENTICATION_INFO;
pub const tagSOLE_AUTHENTICATION_LIST = struct_tagSOLE_AUTHENTICATION_LIST;
pub const tagRPCOPT_SERVER_LOCALITY_VALUES = enum_tagRPCOPT_SERVER_LOCALITY_VALUES;
pub const tagGLOBALOPT_EH_VALUES = enum_tagGLOBALOPT_EH_VALUES;
pub const tagGLOBALOPT_RPCTP_VALUES = enum_tagGLOBALOPT_RPCTP_VALUES;
pub const tagGLOBALOPT_RO_FLAGS = enum_tagGLOBALOPT_RO_FLAGS;
pub const tagGLOBALOPT_UNMARSHALING_POLICY_VALUES = enum_tagGLOBALOPT_UNMARSHALING_POLICY_VALUES;
pub const tagDCOM_CALL_STATE = enum_tagDCOM_CALL_STATE;
pub const _APTTYPEQUALIFIER = enum__APTTYPEQUALIFIER;
pub const tagServerInformation = struct_tagServerInformation;
pub const CO_MTA_USAGE_COOKIE__ = struct_CO_MTA_USAGE_COOKIE__;
pub const tagSTDMSHLFLAGS = enum_tagSTDMSHLFLAGS;
pub const tagTYPEKIND = enum_tagTYPEKIND;
pub const tagSAFEARRAYBOUND = struct_tagSAFEARRAYBOUND;
pub const tagARRAYDESC = struct_tagARRAYDESC;
pub const tagTYPEDESC = struct_tagTYPEDESC;
pub const tagIDLDESC = struct_tagIDLDESC;
pub const tagTYPEATTR = struct_tagTYPEATTR;
pub const tagDESCKIND = enum_tagDESCKIND;
pub const tagSAFEARRAY = struct_tagSAFEARRAY;
pub const tagVARIANT = struct_tagVARIANT;
pub const tagPARAMDESCEX = struct_tagPARAMDESCEX;
pub const tagPARAMDESC = struct_tagPARAMDESC;
pub const tagELEMDESC = struct_tagELEMDESC;
pub const tagFUNCKIND = enum_tagFUNCKIND;
pub const tagINVOKEKIND = enum_tagINVOKEKIND;
pub const tagCALLCONV = enum_tagCALLCONV;
pub const tagFUNCDESC = struct_tagFUNCDESC;
pub const tagVARKIND = enum_tagVARKIND;
pub const tagVARDESC = struct_tagVARDESC;
pub const tagBINDPTR = union_tagBINDPTR;
pub const tagDISPPARAMS = struct_tagDISPPARAMS;
pub const tagEXCEPINFO = struct_tagEXCEPINFO;
pub const tagSYSKIND = enum_tagSYSKIND;
pub const tagTLIBATTR = struct_tagTLIBATTR;
pub const tagVersionedStream = struct_tagVersionedStream;
pub const tagCAC = struct_tagCAC;
pub const tagCAUB = struct_tagCAUB;
pub const tagCAI = struct_tagCAI;
pub const tagCAUI = struct_tagCAUI;
pub const tagCAL = struct_tagCAL;
pub const tagCAUL = struct_tagCAUL;
pub const tagCAH = struct_tagCAH;
pub const tagCAUH = struct_tagCAUH;
pub const tagCAFLT = struct_tagCAFLT;
pub const tagCADBL = struct_tagCADBL;
pub const tagCABOOL = struct_tagCABOOL;
pub const tagCASCODE = struct_tagCASCODE;
pub const tagCACY = struct_tagCACY;
pub const tagCADATE = struct_tagCADATE;
pub const tagCAFILETIME = struct_tagCAFILETIME;
pub const tagCACLSID = struct_tagCACLSID;
pub const tagCACLIPDATA = struct_tagCACLIPDATA;
pub const tagCABSTR = struct_tagCABSTR;
pub const tagCABSTRBLOB = struct_tagCABSTRBLOB;
pub const tagCALPSTR = struct_tagCALPSTR;
pub const tagCALPWSTR = struct_tagCALPWSTR;
pub const tagCAPROPVARIANT = struct_tagCAPROPVARIANT;
pub const tagPROPVARIANT = struct_tagPROPVARIANT;
pub const tagCOWAIT_FLAGS = enum_tagCOWAIT_FLAGS;
pub const AgileReferenceOptions = enum_AgileReferenceOptions;
pub const tagBIND_OPTS = struct_tagBIND_OPTS;
pub const tagDVTARGETDEVICE = struct_tagDVTARGETDEVICE;
pub const tagFORMATETC = struct_tagFORMATETC;
pub const tagSTGMEDIUM = struct_tagSTGMEDIUM;
pub const tagSTATDATA = struct_tagSTATDATA;
pub const tagINTERFACEINFO = struct_tagINTERFACEINFO;
pub const tagStorageLayout = struct_tagStorageLayout;
pub const tagApplicationType = enum_tagApplicationType;
pub const tagShutdownType = enum_tagShutdownType;
pub const tagBIND_OPTS2 = struct_tagBIND_OPTS2;
pub const tagBIND_OPTS3 = struct_tagBIND_OPTS3;
pub const tagBIND_FLAGS = enum_tagBIND_FLAGS;
pub const tagMKSYS = enum_tagMKSYS;
pub const tagMKREDUCE = enum_tagMKREDUCE;
pub const tagRemSNB = struct_tagRemSNB;
pub const tagADVF = enum_tagADVF;
pub const tagTYMED = enum_tagTYMED;
pub const tagRemSTGMEDIUM = struct_tagRemSTGMEDIUM;
pub const __MIDL_IAdviseSink_0002 = union___MIDL_IAdviseSink_0002;
pub const _GDI_OBJECT = struct__GDI_OBJECT;
pub const __MIDL_IAdviseSink_0003 = union___MIDL_IAdviseSink_0003;
pub const _STGMEDIUM_UNION = struct__STGMEDIUM_UNION;
pub const _userSTGMEDIUM = struct__userSTGMEDIUM;
pub const _userFLAG_STGMEDIUM = struct__userFLAG_STGMEDIUM;
pub const _FLAG_STGMEDIUM = struct__FLAG_STGMEDIUM;
pub const tagDATADIR = enum_tagDATADIR;
pub const tagCALLTYPE = enum_tagCALLTYPE;
pub const tagSERVERCALL = enum_tagSERVERCALL;
pub const tagPENDINGTYPE = enum_tagPENDINGTYPE;
pub const tagPENDINGMSG = enum_tagPENDINGMSG;
pub const tagPROPSPEC = struct_tagPROPSPEC;
pub const tagSTATPROPSTG = struct_tagSTATPROPSTG;
pub const tagSTATPROPSETSTG = struct_tagSTATPROPSETSTG;
pub const tagCUSTDATAITEM = struct_tagCUSTDATAITEM;
pub const tagCUSTDATA = struct_tagCUSTDATA;
pub const tagCHANGEKIND = enum_tagCHANGEKIND;
pub const _wireSAFEARR_BSTR = struct__wireSAFEARR_BSTR;
pub const _wireSAFEARR_UNKNOWN = struct__wireSAFEARR_UNKNOWN;
pub const _wireSAFEARR_DISPATCH = struct__wireSAFEARR_DISPATCH;
pub const _wireSAFEARR_VARIANT = struct__wireSAFEARR_VARIANT;
pub const _wireBRECORD = struct__wireBRECORD;
pub const _wireSAFEARR_BRECORD = struct__wireSAFEARR_BRECORD;
pub const _wireSAFEARR_HAVEIID = struct__wireSAFEARR_HAVEIID;
pub const __MIDL_IOleAutomationTypes_0001 = union___MIDL_IOleAutomationTypes_0001;
pub const _wireSAFEARRAY_UNION = struct__wireSAFEARRAY_UNION;
pub const _wireSAFEARRAY = struct__wireSAFEARRAY;
pub const _wireVARIANT = struct__wireVARIANT;
pub const tagSF_TYPE = enum_tagSF_TYPE;
pub const tagTYPEFLAGS = enum_tagTYPEFLAGS;
pub const tagFUNCFLAGS = enum_tagFUNCFLAGS;
pub const tagVARFLAGS = enum_tagVARFLAGS;
pub const tagCLEANLOCALSTORAGE = struct_tagCLEANLOCALSTORAGE;
pub const tagLIBFLAGS = enum_tagLIBFLAGS;
pub const tagSTGOPTIONS = struct_tagSTGOPTIONS;
pub const tagCOINIT = enum_tagCOINIT;
pub const tagCOMSD = enum_tagCOMSD;
pub const __MIDL_IMonikerProp_0001 = enum___MIDL_IMonikerProp_0001;
pub const _tagBINDINFO = struct__tagBINDINFO;
pub const _tagAUTHENTICATEINFO = struct__tagAUTHENTICATEINFO;
pub const __MIDL_IUri_0001 = enum___MIDL_IUri_0001;
pub const _tagPROTOCOLDATA = struct__tagPROTOCOLDATA;
pub const _tagPARSEACTION = enum__tagPARSEACTION;
pub const _tagQUERYOPTION = enum__tagQUERYOPTION;
pub const _ZONEATTRIBUTES = struct__ZONEATTRIBUTES;
pub const _URLZONEREG = enum__URLZONEREG;
pub const _tagSOFTDISTINFO = struct__tagSOFTDISTINFO;
pub const _tagCODEBASEHOLD = struct__tagCODEBASEHOLD;
pub const _tagDATAINFO = struct__tagDATAINFO;
pub const __MIDL_IGetBindHandle_0001 = enum___MIDL_IGetBindHandle_0001;
pub const tagOLEVERB = struct_tagOLEVERB;
pub const tagOleMenuGroupWidths = struct_tagOleMenuGroupWidths;
pub const tagOIFI = struct_tagOIFI;
pub const tagDISCARDCACHE = enum_tagDISCARDCACHE;
pub const tagOLEGETMONIKER = enum_tagOLEGETMONIKER;
pub const tagOLEWHICHMK = enum_tagOLEWHICHMK;
pub const tagUSERCLASSTYPE = enum_tagUSERCLASSTYPE;
pub const tagOLEMISC = enum_tagOLEMISC;
pub const tagOLECLOSE = enum_tagOLECLOSE;
pub const tagOLERENDER = enum_tagOLERENDER;
pub const tagOBJECTDESCRIPTOR = struct_tagOBJECTDESCRIPTOR;
pub const tagOLEUPDATE = enum_tagOLEUPDATE;
pub const tagOLELINKBIND = enum_tagOLELINKBIND;
pub const tagBINDSPEED = enum_tagBINDSPEED;
pub const tagOLECONTF = enum_tagOLECONTF;
pub const tagOLEVERBATTRIB = enum_tagOLEVERBATTRIB;
pub const tagDOMNodeType = enum_tagDOMNodeType;
pub const _xml_error = struct__xml_error;
pub const tagXMLEMEM_TYPE = enum_tagXMLEMEM_TYPE;
pub const __MIDL_IBindStatusCallback_0001 = enum___MIDL_IBindStatusCallback_0001;
pub const __MIDL_IBindStatusCallback_0002 = enum___MIDL_IBindStatusCallback_0002;
pub const __MIDL_IBindStatusCallback_0003 = enum___MIDL_IBindStatusCallback_0003;
pub const __MIDL_IBindStatusCallback_0004 = enum___MIDL_IBindStatusCallback_0004;
pub const _REMSECURITY_ATTRIBUTES = struct__REMSECURITY_ATTRIBUTES;
pub const _tagRemBINDINFO = struct__tagRemBINDINFO;
pub const tagRemFORMATETC = struct_tagRemFORMATETC;
pub const __MIDL_IBindStatusCallback_0005 = enum___MIDL_IBindStatusCallback_0005;
pub const __MIDL_IBindStatusCallback_0006 = enum___MIDL_IBindStatusCallback_0006;
pub const tagBINDSTATUS = enum_tagBINDSTATUS;
pub const __MIDL_IBindStatusCallbackEx_0001 = enum___MIDL_IBindStatusCallbackEx_0001;
pub const __MIDL_IAuthenticateEx_0001 = enum___MIDL_IAuthenticateEx_0001;
pub const __MIDL_ICodeInstall_0001 = enum___MIDL_ICodeInstall_0001;
pub const __MIDL_IUri_0002 = enum___MIDL_IUri_0002;
pub const tagBINDSTRING = enum_tagBINDSTRING;
pub const _tagPI_FLAGS = enum__tagPI_FLAGS;
pub const _tagStartParam = struct__tagStartParam;
pub const _tagOIBDG_FLAGS = enum__tagOIBDG_FLAGS;
pub const _tagPSUACTION = enum__tagPSUACTION;
pub const _tagINTERNETFEATURELIST = enum__tagINTERNETFEATURELIST;
pub const __MIDL_IInternetSecurityManager_0001 = enum___MIDL_IInternetSecurityManager_0001;
pub const __MIDL_IInternetSecurityManager_0002 = enum___MIDL_IInternetSecurityManager_0002;
pub const __MIDL_IInternetSecurityManager_0003 = enum___MIDL_IInternetSecurityManager_0003;
pub const tagURLZONE = enum_tagURLZONE;
pub const tagURLTEMPLATE = enum_tagURLTEMPLATE;
pub const __MIDL_IInternetZoneManager_0001 = enum___MIDL_IInternetZoneManager_0001;
pub const __MIDL_IInternetZoneManager_0002 = enum___MIDL_IInternetZoneManager_0002;
pub const _tagPROTOCOLFILTERDATA = struct__tagPROTOCOLFILTERDATA;
pub const _tagHIT_LOGGING_INFO = struct__tagHIT_LOGGING_INFO;
pub const CONFIRMSAFETY = struct_CONFIRMSAFETY;
pub const _tagPROTOCOL_ARGUMENT = struct__tagPROTOCOL_ARGUMENT;
pub const PIDMSI_STATUS_VALUE = enum_PIDMSI_STATUS_VALUE;
pub const tagSERIALIZEDPROPERTYVALUE = struct_tagSERIALIZEDPROPERTYVALUE;
pub const tagREGKIND = enum_tagREGKIND;
pub const tagPARAMDATA = struct_tagPARAMDATA;
pub const tagMETHODDATA = struct_tagMETHODDATA;
pub const tagINTERFACEDATA = struct_tagINTERFACEDATA;
pub const _OLESTREAMVTBL = struct__OLESTREAMVTBL;
pub const _OLESTREAM = struct__OLESTREAM;
pub const tagOFN_NT4A = struct_tagOFN_NT4A;
pub const tagOFN_NT4W = struct_tagOFN_NT4W;
pub const tagOFNA = struct_tagOFNA;
pub const tagOFNW = struct_tagOFNW;
pub const _OFNOTIFYA = struct__OFNOTIFYA;
pub const _OFNOTIFYW = struct__OFNOTIFYW;
pub const _OFNOTIFYEXA = struct__OFNOTIFYEXA;
pub const _OFNOTIFYEXW = struct__OFNOTIFYEXW;
pub const tagCHOOSECOLORA = struct_tagCHOOSECOLORA;
pub const tagCHOOSECOLORW = struct_tagCHOOSECOLORW;
pub const tagFINDREPLACEA = struct_tagFINDREPLACEA;
pub const tagFINDREPLACEW = struct_tagFINDREPLACEW;
pub const tagCHOOSEFONTA = struct_tagCHOOSEFONTA;
pub const tagCHOOSEFONTW = struct_tagCHOOSEFONTW;
pub const tagPDA = struct_tagPDA;
pub const tagPDW = struct_tagPDW;
pub const tagPRINTPAGERANGE = struct_tagPRINTPAGERANGE;
pub const tagPDEXA = struct_tagPDEXA;
pub const tagPDEXW = struct_tagPDEXW;
pub const tagDEVNAMES = struct_tagDEVNAMES;
pub const tagPSDA = struct_tagPSDA;
pub const tagPSDW = struct_tagPSDW;
pub const _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM = struct__SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM;
pub const _SERVICE_DESCRIPTIONA = struct__SERVICE_DESCRIPTIONA;
pub const _SERVICE_DESCRIPTIONW = struct__SERVICE_DESCRIPTIONW;
pub const _SC_ACTION_TYPE = enum__SC_ACTION_TYPE;
pub const _SC_ACTION = struct__SC_ACTION;
pub const _SERVICE_FAILURE_ACTIONSA = struct__SERVICE_FAILURE_ACTIONSA;
pub const _SERVICE_FAILURE_ACTIONSW = struct__SERVICE_FAILURE_ACTIONSW;
pub const _SERVICE_DELAYED_AUTO_START_INFO = struct__SERVICE_DELAYED_AUTO_START_INFO;
pub const _SERVICE_FAILURE_ACTIONS_FLAG = struct__SERVICE_FAILURE_ACTIONS_FLAG;
pub const _SERVICE_SID_INFO = struct__SERVICE_SID_INFO;
pub const _SERVICE_REQUIRED_PRIVILEGES_INFOA = struct__SERVICE_REQUIRED_PRIVILEGES_INFOA;
pub const _SERVICE_REQUIRED_PRIVILEGES_INFOW = struct__SERVICE_REQUIRED_PRIVILEGES_INFOW;
pub const _SERVICE_PRESHUTDOWN_INFO = struct__SERVICE_PRESHUTDOWN_INFO;
pub const _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM = struct__SERVICE_TRIGGER_SPECIFIC_DATA_ITEM;
pub const _SERVICE_TRIGGER = struct__SERVICE_TRIGGER;
pub const _SERVICE_TRIGGER_INFO = struct__SERVICE_TRIGGER_INFO;
pub const _SERVICE_PREFERRED_NODE_INFO = struct__SERVICE_PREFERRED_NODE_INFO;
pub const _SERVICE_TIMECHANGE_INFO = struct__SERVICE_TIMECHANGE_INFO;
pub const _SERVICE_LAUNCH_PROTECTED_INFO = struct__SERVICE_LAUNCH_PROTECTED_INFO;
pub const SC_HANDLE__ = struct_SC_HANDLE__;
pub const SERVICE_STATUS_HANDLE__ = struct_SERVICE_STATUS_HANDLE__;
pub const _SC_STATUS_TYPE = enum__SC_STATUS_TYPE;
pub const _SC_ENUM_TYPE = enum__SC_ENUM_TYPE;
pub const _SERVICE_STATUS = struct__SERVICE_STATUS;
pub const _SERVICE_STATUS_PROCESS = struct__SERVICE_STATUS_PROCESS;
pub const _ENUM_SERVICE_STATUSA = struct__ENUM_SERVICE_STATUSA;
pub const _ENUM_SERVICE_STATUSW = struct__ENUM_SERVICE_STATUSW;
pub const _ENUM_SERVICE_STATUS_PROCESSA = struct__ENUM_SERVICE_STATUS_PROCESSA;
pub const _ENUM_SERVICE_STATUS_PROCESSW = struct__ENUM_SERVICE_STATUS_PROCESSW;
pub const _QUERY_SERVICE_LOCK_STATUSA = struct__QUERY_SERVICE_LOCK_STATUSA;
pub const _QUERY_SERVICE_LOCK_STATUSW = struct__QUERY_SERVICE_LOCK_STATUSW;
pub const _QUERY_SERVICE_CONFIGA = struct__QUERY_SERVICE_CONFIGA;
pub const _QUERY_SERVICE_CONFIGW = struct__QUERY_SERVICE_CONFIGW;
pub const _SERVICE_TABLE_ENTRYA = struct__SERVICE_TABLE_ENTRYA;
pub const _SERVICE_TABLE_ENTRYW = struct__SERVICE_TABLE_ENTRYW;
pub const _SERVICE_NOTIFY_1 = struct__SERVICE_NOTIFY_1;
pub const _SERVICE_NOTIFY_2A = struct__SERVICE_NOTIFY_2A;
pub const _SERVICE_NOTIFY_2W = struct__SERVICE_NOTIFY_2W;
pub const _SERVICE_CONTROL_STATUS_REASON_PARAMSA = struct__SERVICE_CONTROL_STATUS_REASON_PARAMSA;
pub const _SERVICE_CONTROL_STATUS_REASON_PARAMSW = struct__SERVICE_CONTROL_STATUS_REASON_PARAMSW;
pub const _SERVICE_START_REASON = struct__SERVICE_START_REASON;
pub const _SC_EVENT_TYPE = enum__SC_EVENT_TYPE;
pub const _SC_NOTIFICATION_REGISTRATION = struct__SC_NOTIFICATION_REGISTRATION;
pub const _MODEMDEVCAPS = struct__MODEMDEVCAPS;
pub const _MODEMSETTINGS = struct__MODEMSETTINGS;
pub const HIMC__ = struct_HIMC__;
pub const HIMCC__ = struct_HIMCC__;
pub const tagCOMPOSITIONFORM = struct_tagCOMPOSITIONFORM;
pub const tagCANDIDATEFORM = struct_tagCANDIDATEFORM;
pub const tagCANDIDATELIST = struct_tagCANDIDATELIST;
pub const tagREGISTERWORDA = struct_tagREGISTERWORDA;
pub const tagREGISTERWORDW = struct_tagREGISTERWORDW;
pub const tagRECONVERTSTRING = struct_tagRECONVERTSTRING;
pub const tagSTYLEBUFA = struct_tagSTYLEBUFA;
pub const tagSTYLEBUFW = struct_tagSTYLEBUFW;
pub const tagIMEMENUITEMINFOA = struct_tagIMEMENUITEMINFOA;
pub const tagIMEMENUITEMINFOW = struct_tagIMEMENUITEMINFOW;
pub const tagIMECHARPOSITION = struct_tagIMECHARPOSITION;
